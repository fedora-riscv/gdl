diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc2/configure cvs/gdl/configure
--- gdl-0.9rc2/configure	2009-01-20 12:33:51.000000000 -0700
+++ cvs/gdl/configure	2009-01-26 09:43:53.000000000 -0700
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.61 for gdl 0.9rc1 CVS.
+# Generated by GNU Autoconf 2.61 for gdl 0.9rc2 CVS.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
@@ -726,8 +726,8 @@
 # Identity of this package.
 PACKAGE_NAME='gdl'
 PACKAGE_TARNAME='gdl'
-PACKAGE_VERSION='0.9rc1 CVS'
-PACKAGE_STRING='gdl 0.9rc1 CVS'
+PACKAGE_VERSION='0.9rc2 CVS'
+PACKAGE_STRING='gdl 0.9rc2 CVS'
 PACKAGE_BUGREPORT=''
 
 # Factoring default headers for most tests.
@@ -1398,7 +1398,7 @@
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures gdl 0.9rc1 CVS to adapt to many kinds of systems.
+\`configure' configures gdl 0.9rc2 CVS to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1468,7 +1468,7 @@
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of gdl 0.9rc1 CVS:";;
+     short | recursive ) echo "Configuration of gdl 0.9rc2 CVS:";;
    esac
   cat <<\_ACEOF
 
@@ -1585,7 +1585,7 @@
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-gdl configure 0.9rc1 CVS
+gdl configure 0.9rc2 CVS
 generated by GNU Autoconf 2.61
 
 Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
@@ -1599,7 +1599,7 @@
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by gdl $as_me 0.9rc1 CVS, which was
+It was created by gdl $as_me 0.9rc2 CVS, which was
 generated by GNU Autoconf 2.61.  Invocation command line was
 
   $ $0 $@
@@ -2292,7 +2292,7 @@
 
 # Define the identity of the package.
  PACKAGE='gdl'
- VERSION='0.9rc1 CVS'
+ VERSION='0.9rc2 CVS'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -22298,7 +22298,7 @@
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by gdl $as_me 0.9rc1 CVS, which was
+This file was extended by gdl $as_me 0.9rc2 CVS, which was
 generated by GNU Autoconf 2.61.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -22351,7 +22351,7 @@
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
-gdl config.status 0.9rc1 CVS
+gdl config.status 0.9rc2 CVS
 configured by $0, generated by GNU Autoconf 2.61,
   with options \\"`echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc2/configure.in cvs/gdl/configure.in
--- gdl-0.9rc2/configure.in	2009-01-22 15:31:48.000000000 -0700
+++ cvs/gdl/configure.in	2009-01-26 09:43:53.000000000 -0700
@@ -1,4 +1,4 @@
-AC_INIT(gdl, 0.9rc2)
+AC_INIT(gdl, 0.9rc2 CVS)
 
 AM_CONFIG_HEADER(config.h)
 AM_INIT_AUTOMAKE
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc2/README cvs/gdl/README
--- gdl-0.9rc2/README	2009-01-20 13:01:46.000000000 -0700
+++ cvs/gdl/README	2008-04-08 11:10:46.000000000 -0600
@@ -97,7 +97,6 @@
 compiler) is needed for compiling GDL.
 Note that due to problems with static casts g++ 3.3.1
 does NOT compile GDL, but 3.3.2 and 3.4.1 work fine again.
-Since 0.9rc2 GDL should compile with gcc 4.3 .
 GDL compiles under Mac OS X (10.2, 10.3) with g++ 3.3 . 
 
 The GNU readline library 4.3 is needed (actually GDL should compile
Only in gdl-0.9rc2/src: basic_fun.cpp.ori
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc2/src/basic_fun_jmg.cpp cvs/gdl/src/basic_fun_jmg.cpp
--- gdl-0.9rc2/src/basic_fun_jmg.cpp	2009-01-20 12:33:52.000000000 -0700
+++ cvs/gdl/src/basic_fun_jmg.cpp	2009-01-26 09:43:54.000000000 -0700
@@ -462,6 +462,11 @@
 
     SizeT nEl = p0->N_Elements();
     SizeT Rank = p0->Rank();
+//     if( Rank == 0)
+//       e->Throw( "Parameter must be an array in this context: " 
+// 		+ e->GetParString( 0));
+
+
     SizeT Type = p0->Type();
 
     dimension dim;
Only in gdl-0.9rc2/src: basic_pro.cpp.sav
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc2/src/dcompiler.cpp cvs/gdl/src/dcompiler.cpp
--- gdl-0.9rc2/src/dcompiler.cpp	2009-01-20 12:33:52.000000000 -0700
+++ cvs/gdl/src/dcompiler.cpp	2009-01-26 09:43:54.000000000 -0700
@@ -158,6 +158,12 @@
     }
 }
 
+void DCompiler::ContinueMainPro()
+{
+  env = GDLInterpreter::CallStack()[0];
+  pro = static_cast<DSubUD*>( env->GetPro());
+}
+
 void DCompiler::StartFun(const string& n,const string& o)
 {
   ClearOwnCommon();
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc2/src/dcompiler.hpp cvs/gdl/src/dcompiler.hpp
--- gdl-0.9rc2/src/dcompiler.hpp	2009-01-20 12:33:57.000000000 -0700
+++ cvs/gdl/src/dcompiler.hpp	2009-01-26 09:43:54.000000000 -0700
@@ -66,6 +66,7 @@
   void AddPar(const std::string&);                 // add parameter
   void AddKey(const std::string&,const std::string&);   // add keyword,varName
   void StartPro(const std::string&,const std::string& o = "");     
+  void ContinueMainPro();
   void EndFunPro();       
   void EndInteractiveStatement();
   void EndPro();       
@@ -88,6 +89,8 @@
   int  NDefLabel();
   bool IsActivePro( DSub* p);
   bool ActiveProCompiled() const { return activeProCompiled;}
+  EnvBaseT* GetEnv() const { return env;}
+  void SetEnv( EnvBaseT* e) { env = e;}
 };
 
 #endif
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc2/src/file.cpp cvs/gdl/src/file.cpp
--- gdl-0.9rc2/src/file.cpp	2009-01-20 12:33:57.000000000 -0700
+++ cvs/gdl/src/file.cpp	2008-11-12 17:03:31.000000000 -0700
@@ -165,6 +165,89 @@
     return res;
   }
 
+  BaseGDL* file_info( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 1); 
+    
+    BaseGDL* p0 = e->GetParDefined( 0);
+
+    DStringGDL* p0S = dynamic_cast<DStringGDL*>( p0);
+    if( p0S == NULL)
+      e->Throw( "String expression required in this context: "+
+		e->GetParString(0));
+
+    static int directoryIx = e->KeywordIx( "NOEXPAND_PATH");
+    bool directory = e->KeywordSet( noexpand_pathIx);
+
+    DLongGDL* getMode = NULL; 
+    if( get_mode)
+      {
+	getMode = new DLongGDL( p0S->Dim()); // zero
+	e->SetKW( get_modeIx, getMode);
+      }
+    
+    DLongGDL* res = new DLongGDL( p0S->Dim()); // zero
+
+//     bool doStat = 
+//       zero_length || get_mode || directory || 
+//       regular || block_special || character_special || 
+//       named_pipe || socket || symlink;
+
+    SizeT nEl = p0S->N_Elements();
+    for( SizeT f=0; f<nEl; ++f)
+      {
+	const char* actFile = (*p0S)[ f].c_str();
+
+	struct stat statStruct;
+	int actStat = lstat( actFile, &statStruct);
+	if( actStat != 0) 
+	  continue;
+
+	// 	if( !wxFileExists( actFile) && !wxDirExists( actFile))
+	// 	  continue;
+
+	// 	if( directory && !wxDirExists( actFile))
+	// 	  continue;
+	// 	if( read && !wxFile::Access( actFile, wxFile::read))
+	// 	  continue;
+	// 	if( write && !wxFile::Access( actFile, wxFile::write))
+	// 	  continue;
+
+	if( read && access( actFile, R_OK) != 0)
+	  continue;
+	if( write && access( actFile, W_OK) != 0)
+	  continue;
+	if( executable && access( actFile, X_OK) != 0)
+	  continue;
+
+	if( zero_length && statStruct.st_size != 0) 
+	  continue;
+
+	if( get_mode)
+	  (*getMode)[ f] = statStruct.st_mode & 
+	    (S_IRWXU | S_IRWXG | S_IRWXO);
+	    
+	if( directory && S_ISDIR(statStruct.st_mode) == 0) 
+	  continue;
+	if( regular && S_ISREG(statStruct.st_mode) == 0) 
+	  continue;
+	if( block_special && S_ISBLK(statStruct.st_mode) == 0) 
+	  continue;
+	if( character_special && S_ISCHR(statStruct.st_mode) == 0) 
+	  continue;
+	if( named_pipe && S_ISFIFO(statStruct.st_mode) == 0) 
+	  continue;
+	if( socket && S_ISSOCK(statStruct.st_mode) == 0) 
+	  continue;
+	if( symlink && S_ISLNK(statStruct.st_mode) == 0) 
+	  continue;
+	
+	(*res)[ f] = 1;
+      }
+
+    return res;
+  }
+
   DString GetCWD()
   {
     SizeT bufSize = PATH_MAX;
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc2/src/file_info.cpp cvs/gdl/src/file_info.cpp
--- gdl-0.9rc2/src/file_info.cpp	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/file_info.cpp	2008-11-12 16:56:50.000000000 -0700
@@ -0,0 +1,4758 @@
+/***************************************************************************
+                          basic_fun.cpp  -  basic GDL library function
+                             -------------------
+    begin                : July 22 2002
+    copyright            : (C) 2002 by Marc Schellens (exceptions see below)
+    email                : m_schellens@users.sf.net
+
+ strtok_fun, getenv_fun, tag_names_fun, stregex_fun:
+ (C) 2004 by Peter Messmer    
+ 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "includefirst.hpp"
+
+#include <string>
+#include <fstream>
+//#include <memory>
+#include <regex.h> // stregex
+
+#ifdef __APPLE__
+# include <crt_externs.h>
+# define environ (*_NSGetEnviron())
+#else
+#include <unistd.h>
+#endif
+
+#if defined(__FreeBSD__)
+extern "C" char **environ;
+#endif
+
+#include "datatypes.hpp"
+#include "envt.hpp"
+#include "dpro.hpp"
+#include "dinterpreter.hpp"
+#include "basic_pro.hpp"
+#include "terminfo.hpp"
+#include "typedefs.hpp"
+
+/* max regexp error message length */
+#define MAX_REGEXPERR_LENGTH 80
+
+namespace lib {
+
+  using namespace std;
+  using namespace antlr;
+
+  // assumes all paramters from pOffs till end are dim
+  void arr( EnvT* e, dimension& dim, SizeT pOffs=0)
+  {
+    int nParam=e->NParam()-pOffs;
+
+    if( nParam <= 0)
+      e->Throw( "Incorrect number of arguments.");
+
+    if( nParam == 1 ) {
+      BaseGDL* par = e->GetParDefined( pOffs); 
+ 	
+      SizeT newDim;
+      int ret = par->Scalar2index( newDim);
+      if( ret > 0) {  // single argument
+	dim << newDim;
+	return;
+      } 
+      if( ret == 0) { //  array argument
+	DLongGDL* ind = 
+	  static_cast<DLongGDL*>(par->Convert2(LONG, BaseGDL::COPY)); 	 
+	e->Guard( ind);
+
+	for(SizeT i =0; i < par->N_Elements(); ++i)
+	  dim << (*ind)[i];	  
+
+	return;
+      }
+      e->Throw( "arr: should never arrive here.");	
+      return;
+    }
+
+    // max number checked in interpreter
+    SizeT endIx=nParam+pOffs;
+    for( SizeT i=pOffs; i<endIx; i++)
+      {
+	BaseGDL* par=e->GetParDefined( i);
+
+	SizeT newDim;
+	int ret=par->Scalar2index( newDim);
+	if( ret < 1 || newDim == 0)
+	  e->Throw( "Arguments must be all scalar > 0.");
+	
+	dim << newDim;
+      }
+  }
+
+  BaseGDL* bytarr( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim);
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DByteGDL(dim, BaseGDL::NOZERO);
+      return new DByteGDL(dim);
+    }
+    catch( GDLException ex)
+      {
+	e->Throw( ex.getMessage());
+      }
+  }
+  BaseGDL* intarr( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DIntGDL(dim, BaseGDL::NOZERO);
+      return new DIntGDL(dim);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "INTARR: "+ex.getMessage());
+      }
+  }
+  BaseGDL* uintarr( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DUIntGDL(dim, BaseGDL::NOZERO);
+      return new DUIntGDL(dim);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "UINTARR: "+ex.getMessage());
+      }
+  }
+  BaseGDL* lonarr( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DLongGDL(dim, BaseGDL::NOZERO);
+      return new DLongGDL(dim);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "LONARR: "+ex.getMessage());
+      }
+  }
+  BaseGDL* ulonarr( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DULongGDL(dim, BaseGDL::NOZERO);
+      return new DULongGDL(dim);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "ULONARR: "+ex.getMessage());
+      }
+  }
+  BaseGDL* lon64arr( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DLong64GDL(dim, BaseGDL::NOZERO);
+      return new DLong64GDL(dim);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "LON64ARR: "+ex.getMessage());
+      }
+  }
+  BaseGDL* ulon64arr( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DULong64GDL(dim, BaseGDL::NOZERO);
+      return new DULong64GDL(dim);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "ULON64ARR: "+ex.getMessage());
+      }
+  }
+  BaseGDL* fltarr( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DFloatGDL(dim, BaseGDL::NOZERO);
+      return new DFloatGDL(dim);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "FLTARR: "+ex.getMessage());
+      }
+  }
+  BaseGDL* dblarr( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DDoubleGDL(dim, BaseGDL::NOZERO);
+      return new DDoubleGDL(dim);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "DBLARR: "+ex.getMessage());
+      }
+  }
+  BaseGDL* strarr( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) 
+	throw GDLException( e->CallingNode(), "Keyword parameters not allowed in call.");
+      return new DStringGDL(dim);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "STRARR: "+ex.getMessage());
+      }
+  }
+  BaseGDL* complexarr( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DComplexGDL(dim, BaseGDL::NOZERO);
+      return new DComplexGDL(dim);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "COMPLEXARR: "+ex.getMessage());
+      }
+  }
+  BaseGDL* dcomplexarr( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+
+	if( e->KeywordSet(0)) return new DComplexDblGDL(dim, BaseGDL::NOZERO);
+      return new DComplexDblGDL(dim);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "DCOMPLEXARR: "+ex.getMessage());
+      }
+  }
+  BaseGDL* ptrarr( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      DPtrGDL* ret;
+
+      if( e->KeywordSet(0) || e->KeywordSet(1)) 
+	ret= new DPtrGDL(dim, BaseGDL::NOZERO);
+      else
+	return new DPtrGDL(dim);
+
+      if( e->KeywordSet(1))
+	{
+	  SizeT nEl=ret->N_Elements();
+	  SizeT sIx=e->NewHeap(nEl);
+	  for( SizeT i=0; i<nEl; i++) (*ret)[i]=sIx++;
+	}
+      return ret;
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "PTRARR: "+ex.getMessage());
+      }
+  }
+  BaseGDL* objarr( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DObjGDL(dim, BaseGDL::NOZERO);
+      return new DObjGDL(dim);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "OBJARR: "+ex.getMessage());
+      }
+  }
+
+  BaseGDL* ptr_new( EnvT* e)
+  {
+    int nParam=e->NParam();
+    
+    if( nParam > 0)
+      {
+	if( e->KeywordSet(0)) // NO_COPY
+	  {
+	    BaseGDL** p= &e->GetPar( 0);
+	    if( *p == NULL)
+	      throw GDLException( e->CallingNode(), "Parameter undefined: "+e->GetParString(0));
+
+	    DPtr heapID= e->NewHeap( 1, *p);
+	    *p=NULL;
+	    return new DPtrGDL( heapID);
+	  }
+	else
+	  {
+	    BaseGDL* p= e->GetParDefined( 0);
+
+	    DPtr heapID= e->NewHeap( 1, p->Dup());
+	    return new DPtrGDL( heapID);
+	  }
+      }
+    else
+      {
+	if( e->KeywordSet(1)) // ALLOCATE_HEAP
+	  {
+	    DPtr heapID= e->NewHeap();
+	    return new DPtrGDL( heapID);
+	  }
+	else
+	  {
+	    return new DPtrGDL( 0); // null ptr
+	  }
+      }
+  }
+
+  BaseGDL* ptr_valid( EnvT* e)
+  {
+    int nParam=e->NParam();
+    
+    if( e->KeywordPresent( 1)) // COUNT
+      {
+	e->SetKW( 1, new DLongGDL( e->Interpreter()->HeapSize()));
+      }
+
+    if( nParam == 0)
+      {
+	return e->Interpreter()->GetAllHeap();
+      } 
+
+    BaseGDL* p = e->GetPar( 0);
+    if( p == NULL)
+      {
+	return new DByteGDL( 0);
+      } 
+
+    if( e->KeywordSet( 0)) // CAST
+      {
+	DLongGDL* pL = dynamic_cast<DLongGDL*>( p);
+	if( pL == NULL)
+	  {
+	    pL = static_cast<DLongGDL*>(p->Convert2(LONG,BaseGDL::COPY)); 
+	    e->Guard( pL);
+	  }
+	
+	SizeT nEl = pL->N_Elements();
+	DPtrGDL* ret = new DPtrGDL( pL->Dim()); // zero
+	GDLInterpreter* interpreter = e->Interpreter();
+	for( SizeT i=0; i<nEl; ++i)
+	  {
+	    if( interpreter->PtrValid( (*pL)[ i])) 
+	      (*ret)[ i] = (*pL)[ i];
+	  }
+	return ret;
+      }
+
+    DPtrGDL* pPtr = dynamic_cast<DPtrGDL*>( p);
+    if( pPtr == NULL)
+      {
+	return new DByteGDL( p->Dim()); // zero
+      }
+
+    SizeT nEl = pPtr->N_Elements();
+    DByteGDL* ret = new DByteGDL( pPtr->Dim()); // zero
+    GDLInterpreter* interpreter = e->Interpreter();
+    for( SizeT i=0; i<nEl; ++i)
+      {
+	if( interpreter->PtrValid( (*pPtr)[ i])) 
+	  (*ret)[ i] = 1;
+      }
+    return ret;
+  }
+
+  BaseGDL* obj_valid( EnvT* e)
+  {
+    int nParam=e->NParam();
+    
+    if( e->KeywordPresent( 1)) // COUNT
+      {
+	e->SetKW( 1, new DLongGDL( e->Interpreter()->ObjHeapSize()));
+      }
+
+    if( nParam == 0)
+      {
+	return e->Interpreter()->GetAllObjHeap();
+      } 
+
+    BaseGDL* p = e->GetPar( 0);
+    if( p == NULL)
+      {
+	return new DByteGDL( 0);
+      } 
+
+    if( e->KeywordSet( 0)) // CAST
+      {
+	DLongGDL* pL = dynamic_cast<DLongGDL*>( p);
+	if( pL == NULL)
+	  {
+	    pL = static_cast<DLongGDL*>(p->Convert2(LONG,BaseGDL::COPY)); 
+	    e->Guard( pL);
+	  }
+	
+	SizeT nEl = pL->N_Elements();
+	DObjGDL* ret = new DObjGDL( pL->Dim()); // zero
+	GDLInterpreter* interpreter = e->Interpreter();
+	for( SizeT i=0; i<nEl; ++i)
+	  {
+	    if( interpreter->ObjValid( (*pL)[ i])) 
+	      (*ret)[ i] = (*pL)[ i];
+	  }
+	return ret;
+      }
+
+    DObjGDL* pObj = dynamic_cast<DObjGDL*>( p);
+    if( pObj == NULL)
+      {
+	return new DByteGDL( p->Dim()); // zero
+      }
+
+    SizeT nEl = pObj->N_Elements();
+    DByteGDL* ret = new DByteGDL( pObj->Dim()); // zero
+    GDLInterpreter* interpreter = e->Interpreter();
+    for( SizeT i=0; i<nEl; ++i)
+      {
+	if( interpreter->ObjValid( (*pObj)[ i])) 
+	  (*ret)[ i] = 1;
+      }
+    return ret;
+  }
+
+  BaseGDL* obj_new( EnvT* e)
+  {
+    StackGuard<EnvStackT> guard( e->Interpreter()->CallStack());
+    
+    int nParam=e->NParam();
+    
+    if( nParam == 0)
+      {
+	return new DObjGDL( 0);
+      }
+    
+    DString objName;
+    e->AssureScalarPar<DStringGDL>( 0, objName);
+
+    // this is a struct name -> convert to UPPERCASE
+    objName=StrUpCase(objName);
+
+    DStructDesc* objDesc=e->Interpreter()->GetStruct( objName, e->CallingNode());
+
+    DStructGDL* objStruct= new DStructGDL( objDesc, dimension());
+
+    DObj objID= e->NewObjHeap( 1, objStruct); // owns objStruct
+
+    BaseGDL* newObj = new DObjGDL( objID); // the object
+
+    try {
+      // call INIT function
+      DFun* objINIT= objDesc->GetFun( "INIT");
+      if( objINIT != NULL)
+	{
+	  // morph to obj environment and push it onto the stack again
+	  e->PushNewEnvUD( objINIT, 1, &newObj);
+	
+	  BaseGDL* res=e->Interpreter()->call_fun( objINIT->GetTree());
+	
+	  if( res == NULL || (!res->Scalar()) || res->False())
+	    {
+	      delete res;
+	      return new DObjGDL( 0);
+	    }
+	  delete res;
+	}
+    } catch(...) {
+      e->FreeObjHeap( objID); // newObj might be changed
+      delete newObj;
+      throw;
+    }
+
+    return newObj;
+  }
+
+  BaseGDL* bindgen( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DByteGDL(dim, BaseGDL::INDGEN);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "BINDGEN: "+ex.getMessage());
+      }
+  }
+  // keywords not supported yet
+  BaseGDL* indgen( EnvT* e)
+  {
+    dimension dim;
+
+    // Defaulting to INT
+    DType type = INT;
+
+    static int kwIx1 = e->KeywordIx("BYTE");
+    if (e->KeywordSet(kwIx1)){ type = BYTE; }
+
+    static int kwIx2 = e->KeywordIx("COMPLEX");
+    if (e->KeywordSet(kwIx2)){ type = COMPLEX; }
+    
+    static int kwIx3 = e->KeywordIx("DCOMPLEX");
+    if (e->KeywordSet(kwIx3)){ type = COMPLEXDBL; }
+
+    static int kwIx4 = e->KeywordIx("DOUBLE");
+    if (e->KeywordSet(kwIx4)){ type = DOUBLE; }
+
+    static int kwIx5 = e->KeywordIx("FLOAT");
+    if (e->KeywordSet(kwIx5)){ type = FLOAT; }
+    
+    static int kwIx6 = e->KeywordIx("L64");
+    if (e->KeywordSet(kwIx6)){ type = LONG64; }
+
+    static int kwIx7 = e->KeywordIx("LONG");
+    if (e->KeywordSet(kwIx7)){ type = LONG; }
+
+    static int kwIx8 = e->KeywordIx("STRING");
+    if (e->KeywordSet(kwIx8)){ type = STRING; }
+
+    static int kwIx9 = e->KeywordIx("UINT");
+    if (e->KeywordSet(kwIx9)){ type = UINT; }
+
+    static int kwIx10 = e->KeywordIx("UL64");
+    if (e->KeywordSet(kwIx10)){ type = ULONG64; }
+
+    static int kwIx11 = e->KeywordIx("ULONG");
+    if (e->KeywordSet(kwIx11)){ type = ULONG; }
+    
+    try
+      {
+	// Seeing if the user passed in a TYPE code
+	static int kwIx12 = e->KeywordIx("TYPE");
+	if ( e->KeywordPresent(kwIx12)){
+	  DLong temp_long;
+	  e->AssureLongScalarKW(kwIx12, temp_long);
+	  type = static_cast<DType>(temp_long);
+	}
+
+	arr(e, dim);
+	if (dim[0] == 0)
+	  throw GDLException( "Array dimensions must be greater than 0");
+
+	switch(type)
+	  {
+	  case INT:        return new DIntGDL(dim, BaseGDL::INDGEN);
+	  case BYTE:       return new DByteGDL(dim, BaseGDL::INDGEN);
+	  case COMPLEX:    return new DComplexGDL(dim, BaseGDL::INDGEN);
+	  case COMPLEXDBL: return new DComplexDblGDL(dim, BaseGDL::INDGEN);
+	  case DOUBLE:     return new DDoubleGDL(dim, BaseGDL::INDGEN);
+	  case FLOAT:      return new DFloatGDL(dim, BaseGDL::INDGEN);
+	  case LONG64:     return new DLong64GDL(dim, BaseGDL::INDGEN);
+	  case LONG:       return new DLongGDL(dim, BaseGDL::INDGEN);
+	  case STRING: {
+	    DULongGDL* iGen = new DULongGDL(dim, BaseGDL::INDGEN);
+	    return iGen->Convert2(STRING);
+	  }
+	  case UINT:       return new DUIntGDL(dim, BaseGDL::INDGEN);
+	  case ULONG64:    return new DULong64GDL(dim, BaseGDL::INDGEN);
+	  case ULONG:      return new DULongGDL(dim, BaseGDL::INDGEN);
+	  default:
+	    e->Throw( "Invalid type code specified.");
+	    break;
+	  }
+      }
+    catch( GDLException ex)
+      {
+	e->Throw( ex.getMessage());
+      }
+  }
+
+  BaseGDL* uindgen( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DUIntGDL(dim, BaseGDL::INDGEN);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "UINDGEN: "+ex.getMessage());
+      }
+  }
+  BaseGDL* sindgen( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      DULongGDL* iGen = new DULongGDL(dim, BaseGDL::INDGEN);
+      return iGen->Convert2( STRING);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "SINDGEN: "+ex.getMessage());
+      }
+  }
+  BaseGDL* lindgen( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      return new DLongGDL(dim, BaseGDL::INDGEN);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "LINDGEN: "+ex.getMessage());
+      }
+  }
+  BaseGDL* ulindgen( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DULongGDL(dim, BaseGDL::INDGEN);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "ULINDGEN: "+ex.getMessage());
+      }
+  }
+  BaseGDL* l64indgen( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DLong64GDL(dim, BaseGDL::INDGEN);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "L64INDGEN: "+ex.getMessage());
+      }
+  }
+  BaseGDL* ul64indgen( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DULong64GDL(dim, BaseGDL::INDGEN);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "UL64INDGEN: "+ex.getMessage());
+      }
+  }
+  BaseGDL* findgen( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DFloatGDL(dim, BaseGDL::INDGEN);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "FINDGEN: "+ex.getMessage());
+      }
+  }
+  BaseGDL* dindgen( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DDoubleGDL(dim, BaseGDL::INDGEN);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "DINDGEN: "+ex.getMessage());
+      }
+  }
+  BaseGDL* cindgen( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DComplexGDL(dim, BaseGDL::INDGEN);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "CINDGEN: "+ex.getMessage());
+      }
+  }
+  BaseGDL* dcindgen( EnvT* e)
+  {
+    dimension dim;
+    try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DComplexDblGDL(dim, BaseGDL::INDGEN);
+    }
+    catch( GDLException ex)
+      {
+	throw GDLException( e->CallingNode(), "DCINDGEN: "+ex.getMessage());
+      }
+  }
+
+  BaseGDL* n_elements( EnvT* e)
+  {
+    SizeT nParam=e->NParam();
+
+    if( nParam != 1)
+      throw GDLException( e->CallingNode(), 
+			  "N_ELEMENTS: Incorrect number of arguments.");
+
+    BaseGDL* p0=e->GetPar( 0);
+
+    if( p0 == NULL) return new DLongGDL( 0);
+    
+    return new DLongGDL( p0->N_Elements());
+  }
+
+  template< typename ComplexGDL, typename Complex, typename Float>
+  BaseGDL* complex_fun_template( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 1);
+  
+    if( nParam <= 2)
+      {
+	if( nParam == 2)
+	  {
+	    BaseGDL* p0=e->GetParDefined( 0);
+	    BaseGDL* p1=e->GetParDefined( 1);
+	    auto_ptr<Float> p0Float( static_cast<Float*>
+				     (p0->Convert2( Float::t,BaseGDL::COPY)));
+	    auto_ptr<Float> p1Float( static_cast<Float*>
+				     (p1->Convert2( Float::t,BaseGDL::COPY)));
+	    if( p0Float->Rank() == 0)
+	      {
+		ComplexGDL* res = new ComplexGDL( p1Float->Dim(), 
+						  BaseGDL::NOZERO);
+		
+		SizeT nE=p1Float->N_Elements();
+		for( SizeT i=0; i<nE; i++)
+		  {
+		    (*res)[i]=Complex( (*p0Float)[0], (*p1Float)[i]);
+		  }
+		return res;
+	      }
+	    else if( p1Float->Rank() == 0)
+	      {
+		ComplexGDL* res = new ComplexGDL( p0Float->Dim(), 
+						  BaseGDL::NOZERO);
+		
+		SizeT nE=p0Float->N_Elements();
+		for( SizeT i=0; i<nE; i++)
+		  {
+		    (*res)[i]=Complex( (*p0Float)[i], (*p1Float)[0]);
+		  }
+		return res;
+	      }
+	    else if( p0Float->N_Elements() >= p1Float->N_Elements())
+	      {
+		ComplexGDL* res = new ComplexGDL( p1Float->Dim(), 
+						  BaseGDL::NOZERO);
+
+		SizeT nE=p1Float->N_Elements();
+		for( SizeT i=0; i<nE; i++)
+		  {
+		    (*res)[i]=Complex( (*p0Float)[i], (*p1Float)[i]);
+		  }
+		return res;
+	      }
+	    else
+	      {
+		ComplexGDL* res = new ComplexGDL( p0Float->Dim(), 
+						  BaseGDL::NOZERO);
+		
+		SizeT nE=p0Float->N_Elements();
+		for( SizeT i=0; i<nE; i++)
+		  {
+		    (*res)[i]=Complex( (*p0Float)[i], (*p1Float)[i]);
+		  }
+		return res;
+	      }
+	  }
+	else
+	  {
+	    BaseGDL* p0 = e->GetParDefined( 0);
+	    return p0->Convert2( ComplexGDL::t, BaseGDL::COPY);
+	  }
+      }
+    else // COMPLEX( expr, offs, dim1,..,dim8)
+      {
+	BaseGDL* p0 = e->GetParDefined( 0);
+	// *** WRONG: with offs data is converted bytewise
+	auto_ptr<Float> p0Float(static_cast<Float*>
+				(p0->Convert2( Float::t,
+					       BaseGDL::COPY)));
+	DLong offs;
+	e->AssureLongScalarPar( 1, offs);
+      
+	dimension dim;
+	arr( e, dim, 2);
+
+	SizeT nElCreate=dim.N_Elements();
+	
+	SizeT nElSource=p0->N_Elements();
+      
+	if( (offs+2*nElCreate) > nElSource)
+	  e->Throw( "Specified offset to"
+		    " array is out of range: "+e->GetParString(0));
+	
+	ComplexGDL* res=new ComplexGDL( dim, BaseGDL::NOZERO);
+	
+	for( SizeT i=0; i<nElCreate; i++)
+	  {
+	    SizeT srcIx=2*i+offs;
+	    (*res)[i]=Complex( (*p0Float)[srcIx], (*p0Float)[srcIx+1]);
+	  }
+	
+	return res;
+      }
+  }
+
+  BaseGDL* complex_fun( EnvT* e)
+  {
+    return complex_fun_template< DComplexGDL, DComplex, DFloatGDL>( e);
+  }
+  BaseGDL* dcomplex_fun( EnvT* e)
+  {
+    return complex_fun_template< DComplexDblGDL, DComplexDbl, DDoubleGDL>( e);
+  }
+
+  template< class TargetClass>
+  BaseGDL* type_fun( EnvT* e)
+  {
+    SizeT nParam=e->NParam(1);
+
+    if( nParam == 1)
+      {
+	BaseGDL* p0=e->GetParDefined( 0);
+
+	assert( dynamic_cast< EnvUDT*>( e->Caller()) != NULL);
+
+	// type_fun( expr) just convert
+	if( static_cast< EnvUDT*>( e->Caller())->GetIOError() != NULL) 
+	  return p0->Convert2( TargetClass::t, 
+			       BaseGDL::COPY_THROWIOERROR);
+	else
+	  return p0->Convert2( TargetClass::t, BaseGDL::COPY);
+      }
+    
+    BaseGDL* p0=e->GetNumericParDefined( 0);
+
+    // BYTE( expr, offs, dim1,..,dim8)
+    DLong offs;
+    e->AssureLongScalarPar( 1, offs);
+
+    dimension dim;
+
+    if( nParam > 2)
+      arr( e, dim, 2);
+    
+    TargetClass* res=new TargetClass( dim, BaseGDL::NOZERO);
+
+    SizeT nByteCreate=res->NBytes(); // net size of new data
+      
+    SizeT nByteSource=p0->NBytes(); // net size of src
+      
+    if( offs < 0 || (offs+nByteCreate) > nByteSource)
+      {
+	delete res;
+	e->Throw( "Specified offset to"
+		  " expression is out of range: "+e->GetParString(0));
+      }
+
+    //*** POSSIBLE ERROR because of alignment here
+    void* srcAddr = static_cast<void*>( static_cast<char*>(p0->DataAddr()) + 
+					offs);
+    void* dstAddr = static_cast<void*>(&(*res)[0]);
+    memcpy( dstAddr, srcAddr, nByteCreate);
+
+    //     char* srcAddr = reinterpret_cast<char*>(p0->DataAddr());
+    //     char* dstAddr = reinterpret_cast<char*>(&(*res)[0]);
+    //     copy( srcAddr, srcAddr+nByteCreate, dstAddr);
+
+    return res;
+  }
+
+  BaseGDL* byte_fun( EnvT* e)
+  {
+    return type_fun<DByteGDL>( e);
+  }
+  BaseGDL* fix_fun( EnvT* e)
+  {
+    DIntGDL* type = e->IfDefGetKWAs<DIntGDL>( 0);
+    if (type != NULL) {
+      int typ = (*type)[0];
+      if (typ == BYTE) return type_fun<DByteGDL>( e);
+      if (typ == INT) return type_fun<DIntGDL>( e);
+      if (typ == UINT) return type_fun<DUIntGDL>( e);
+      if (typ == LONG) return type_fun<DLongGDL>( e);
+      if (typ == ULONG) return type_fun<DULongGDL>( e);
+      if (typ == LONG64) return type_fun<DLong64GDL>( e);
+      if (typ == ULONG64) return type_fun<DULong64GDL>( e);
+      if (typ == FLOAT) return type_fun<DFloatGDL>( e);
+      if (typ == DOUBLE) return type_fun<DDoubleGDL>( e);
+      if (typ == COMPLEX) return type_fun<DComplexGDL>( e);
+      if (typ == COMPLEXDBL) return type_fun<DComplexDblGDL>( e);
+      throw GDLException( e->CallingNode(), 
+			  "FIX: Improper TYPE value.");
+    }
+    return type_fun<DIntGDL>( e);
+  }
+  BaseGDL* uint_fun( EnvT* e)
+  {
+    return type_fun<DUIntGDL>( e);
+  }
+  BaseGDL* long_fun( EnvT* e)
+  {
+    return type_fun<DLongGDL>( e);
+  }
+  BaseGDL* ulong_fun( EnvT* e)
+  {
+    return type_fun<DULongGDL>( e);
+  }
+  BaseGDL* long64_fun( EnvT* e)
+  {
+    return type_fun<DLong64GDL>( e);
+  }
+  BaseGDL* ulong64_fun( EnvT* e)
+  {
+    return type_fun<DULong64GDL>( e);
+  }
+  BaseGDL* float_fun( EnvT* e)
+  {
+    return type_fun<DFloatGDL>( e);
+  }
+  BaseGDL* double_fun( EnvT* e)
+  {
+    return type_fun<DDoubleGDL>( e);
+  }
+  // STRING function behaves different
+  BaseGDL* string_fun( EnvT* e)
+  {
+    SizeT nParam=e->NParam();
+
+    if( nParam == 0)
+      throw GDLException( e->CallingNode(), 
+			  "STRING: Incorrect number of arguments.");
+
+    bool printKey =  e->KeywordSet( 4);
+    if( printKey || (e->GetKW( 0) != NULL)) // PRINT or FORMAT
+      {
+	stringstream os;
+
+	SizeT width = 0;
+	if( printKey) // otherwise: FORMAT -> width is ignored
+	  {
+	    width = TermWidth();
+	  }
+	
+	print_os( &os, e, 0, width);
+	
+	deque<DString> buf;
+	while( os.good())
+	  {
+	    string line;
+	    getline( os, line);
+	    if( os.good()) buf.push_back( line);
+	  }
+
+	SizeT bufSize = buf.size();
+	if( bufSize == 0)
+	  throw GDLException( "Internal error: STRING: print buffer empty.");
+
+	if( bufSize > 1) 
+	  {
+	    DStringGDL* retVal = 
+	      new DStringGDL( dimension( bufSize), BaseGDL::NOZERO);
+
+	    for( SizeT i=0; i<bufSize; ++i)
+	      (*retVal)[ i] = buf[ i];
+
+	    return retVal;
+	  }
+	else
+	  return new DStringGDL( buf[0]);
+      }
+    else
+      {
+	if( nParam == 1) // nParam == 1 -> conversion
+	  {
+	    BaseGDL* p0 = e->GetParDefined( 0);
+	    return p0->Convert2( STRING, BaseGDL::COPY);
+	  }
+	else // concatenation
+	  {
+	    DString s;
+	    for( SizeT i=0; i<nParam; ++i)
+	      {
+		BaseGDL* p = e->GetParDefined( i);
+		DStringGDL* sP = static_cast<DStringGDL*>
+		  ( p->Convert2(STRING,
+				BaseGDL::COPY_BYTE_AS_INT));
+
+		SizeT nEl = sP->N_Elements();
+		for( SizeT e=0; e<nEl; ++e)
+		  s += (*sP)[ e];
+		delete sP;
+	      }
+	    // IDL here breaks the string into tty-width substrings
+	    return new DStringGDL( s);
+	  }
+      }
+  }
+
+  BaseGDL* call_function( EnvT* e)
+  {
+    StackGuard<EnvStackT> guard( e->Interpreter()->CallStack());
+
+    int nParam=e->NParam();
+    if( nParam == 0)
+      throw GDLException( e->CallingNode(),
+			  "CALL_FUNCTION: No function specified.");
+    
+    DString callF;
+    e->AssureScalarPar<DStringGDL>( 0, callF);
+
+    // this is a function name -> convert to UPPERCASE
+    callF = StrUpCase( callF);
+
+    // first search library funcedures
+    int funIx=LibFunIx( callF);
+    if( funIx != -1)
+      {
+	e->PushNewEnv( libFunList[ funIx], 1);
+	
+	// make the call
+	EnvT* newEnv = static_cast<EnvT*>(e->Interpreter()->CallStack().back());
+	return static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
+      }
+    else
+      {
+	funIx = GDLInterpreter::GetFunIx( callF);
+	
+	e->PushNewEnvUD( funList[ funIx], 1);
+	
+	// make the call
+	EnvUDT* newEnv = static_cast<EnvUDT*>(e->Interpreter()->CallStack().back());
+	return e->Interpreter()->
+	  call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
+      }
+  }
+
+  BaseGDL* call_method_function( EnvT* e)
+  {
+    StackGuard<EnvStackT> guard( e->Interpreter()->CallStack());
+
+    int nParam=e->NParam();
+    if( nParam < 2)
+      throw GDLException( e->CallingNode(),
+			  "CALL_METHOD: Name and object reference"
+			  " must be specified.");
+    
+    DString callP;
+    e->AssureScalarPar<DStringGDL>( 0, callP);
+
+    // this is a procedure name -> convert to UPPERCASE
+    callP = StrUpCase( callP);
+    
+    DStructGDL* oStruct = e->GetObjectPar( 1);
+
+    DFun* method= oStruct->Desc()->GetFun( callP);
+
+    if( method == NULL)
+      throw GDLException( e->CallingNode(), "Method not found: "+callP);
+
+    e->PushNewEnv( method, 2, &e->GetPar( 1));
+    
+    // make the call
+    return e->Interpreter()->call_fun( method->GetTree());
+  }
+
+  BaseGDL* execute( EnvT* e)
+  {
+    int nParam=e->NParam( 1);
+
+    bool quietCompile = false;
+    if( nParam == 2)
+      {
+	BaseGDL* p1 = e->GetParDefined( 1);
+	
+	if( !p1->Scalar())
+	  throw GDLException( e->CallingNode(), "Expression"
+			      " must be scalar in this context: "+
+			      e->GetParString(1));
+	
+	quietCompile = p1->True();
+      }
+    
+    DString line;
+    e->AssureScalarPar<DStringGDL>( 0, line);
+
+    // remove current environment (own one)
+    EnvBaseT* caller = e->Caller();
+    e->Interpreter()->CallStack().pop_back();
+    delete e;
+
+    istringstream istr(line+"\n");
+
+    RefDNode theAST;
+    try {  
+      GDLLexer   lexer(istr, "");
+      GDLParser& parser=lexer.Parser();
+    
+      parser.interactive();
+    
+      theAST=parser.getAST();
+    }
+    catch( GDLException ex)
+      {
+	if( !quietCompile) GDLInterpreter::ReportCompileError( ex);
+	return new DIntGDL( 0);
+      }
+    catch( ANTLRException ex)
+      {
+	if( !quietCompile) cerr << "EXECUTE: Lexer/Parser exception: " <<  
+			     ex.getMessage() << endl;
+	return new DIntGDL( 0);
+      }
+    
+    if( theAST == NULL) return new DIntGDL( 1);
+
+    RefDNode trAST;
+    try
+      {
+	GDLTreeParser treeParser( caller);
+	  
+	treeParser.interactive(theAST);
+
+	trAST=treeParser.getAST();
+      }
+    catch( GDLException ex)
+      {
+	if( !quietCompile) GDLInterpreter::ReportCompileError( ex);
+	return new DIntGDL( 0);
+      }
+
+    catch( ANTLRException ex)
+      {
+	if( !quietCompile) cerr << "EXECUTE: Compiler exception: " <<  
+			     ex.getMessage() << endl;
+	return new DIntGDL( 0);
+      }
+      
+    if( trAST == NULL) return new DIntGDL( 1);
+
+    try
+      {
+	ProgNodeP progAST = ProgNode::NewProgNode( trAST);
+	auto_ptr< ProgNode> progAST_guard( progAST);
+
+	GDLInterpreter::RetCode retCode =
+	  caller->Interpreter()->execute( progAST);
+
+	if( retCode == GDLInterpreter::RC_OK)
+	  return new DIntGDL( 1);
+	else
+	  return new DIntGDL( 0);
+      }
+    catch( GDLException ex)
+      {
+	if( !quietCompile) cerr << "EXECUTE: Unhandled GDL exception: " <<  
+			     ex.getMessage() << endl;
+	return new DIntGDL( 0);
+      }
+    catch( ANTLRException ex)
+      {
+	if( !quietCompile) cerr << "EXECUTE: Interpreter exception: " <<  
+			     ex.getMessage() << endl;
+	return new DIntGDL( 0);
+      }
+
+    return new DIntGDL( 0); // control flow cannot reach here - compiler shut up
+  }
+
+  BaseGDL* assoc( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 2);
+
+    DLong lun;
+    e->AssureLongScalarPar( 0, lun);
+
+    bool stdLun = check_lun( e, lun);
+    if( stdLun)
+      e->Throw( "File unit does not allow"
+		" this operation. Unit: "+i2s( lun));
+
+    DLong offset = 0;
+    if( nParam >= 3) e->AssureLongScalarPar( 2, offset);
+    
+    BaseGDL* arr = e->GetParDefined( 1);
+    
+    if( arr->StrictScalar())
+      e->Throw( "Scalar variable not allowed in this"
+		" context: "+e->GetParString(1));
+    
+    return arr->AssocVar( lun, offset);
+  }
+
+  // gdl_ naming because of weired namespace problem in MSVC
+  BaseGDL* gdl_logical_and( EnvT* e)
+  {
+    SizeT nParam=e->NParam();
+    if( nParam != 2)
+      throw GDLException( e->CallingNode(),
+			  "LOGICAL_AND: Incorrect number of arguments.");
+
+    BaseGDL* e1=e->GetParDefined( 0);//, "LOGICAL_AND");
+    BaseGDL* e2=e->GetParDefined( 1);//, "LOGICAL_AND");
+
+    ULong nEl1 = e1->N_Elements();
+    ULong nEl2 = e2->N_Elements();
+
+    Data_<SpDByte>* res;
+
+    if( e1->Scalar()) 
+      {
+	if( e1->LogTrue(0)) 
+	  {
+	    res= new Data_<SpDByte>( e2->Dim(), BaseGDL::NOZERO);
+	    for( SizeT i=0; i < nEl2; i++)
+	      (*res)[i] = e2->LogTrue( i) ? 1 : 0;
+	  }
+	else
+	  {
+	    return new Data_<SpDByte>( e2->Dim());
+	  }
+      }
+    else if( e2->Scalar()) 
+      {
+	if( e2->LogTrue(0)) 
+	  {
+	    res= new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
+	    for( SizeT i=0; i < nEl1; i++)
+	      (*res)[i] = e1->LogTrue( i) ? 1 : 0;
+	  }
+	else
+	  {
+	    return new Data_<SpDByte>( e1->Dim());
+	  }
+      }
+    else if( nEl2 < nEl1) 
+      {
+	res= new Data_<SpDByte>( e2->Dim(), BaseGDL::NOZERO);
+	for( SizeT i=0; i < nEl2; i++)
+	  (*res)[i] = (e1->LogTrue( i) && e2->LogTrue( i)) ? 1 : 0;
+      }
+    else // ( nEl2 >= nEl1)
+      {
+	res= new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
+	for( SizeT i=0; i < nEl1; i++)
+	  (*res)[i] = (e1->LogTrue( i) && e2->LogTrue( i)) ? 1 : 0;
+      }
+    return res;
+  }
+
+  // gdl_ naming because of weired namespace problem in MSVC
+  BaseGDL* gdl_logical_or( EnvT* e)
+  {
+    SizeT nParam=e->NParam();
+    if( nParam != 2)
+      throw GDLException( e->CallingNode(),
+			  "LOGICAL_OR: Incorrect number of arguments.");
+
+    BaseGDL* e1=e->GetParDefined( 0);//, "LOGICAL_OR");
+    BaseGDL* e2=e->GetParDefined( 1);//, "LOGICAL_OR");
+
+    ULong nEl1 = e1->N_Elements();
+    ULong nEl2 = e2->N_Elements();
+
+    Data_<SpDByte>* res;
+
+    if( e1->Scalar()) 
+      {
+	if( e1->LogTrue(0)) 
+	  {
+	    res= new Data_<SpDByte>( e2->Dim(), BaseGDL::NOZERO);
+	    for( SizeT i=0; i < nEl2; i++)
+	      (*res)[i] = 1;
+	  }
+	else
+	  {
+	    res= new Data_<SpDByte>( e2->Dim(), BaseGDL::NOZERO);
+	    for( SizeT i=0; i < nEl2; i++)
+	      (*res)[i] = e2->LogTrue( i) ? 1 : 0;
+	  }
+      }
+    else if( e2->Scalar()) 
+      {
+	if( e2->LogTrue(0)) 
+	  {
+	    res= new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
+	    for( SizeT i=0; i < nEl1; i++)
+	      (*res)[i] = 1;
+	  }
+	else
+	  {
+	    res= new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
+	    for( SizeT i=0; i < nEl1; i++)
+	      (*res)[i] = e1->LogTrue( i) ? 1 : 0;
+	  }
+      }
+    else if( nEl2 < nEl1) 
+      {
+	res= new Data_<SpDByte>( e2->Dim(), BaseGDL::NOZERO);
+	for( SizeT i=0; i < nEl2; i++)
+	  (*res)[i] = (e1->LogTrue( i) || e2->LogTrue( i)) ? 1 : 0;
+      }
+    else // ( nEl2 >= nEl1)
+      {
+	res= new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
+	for( SizeT i=0; i < nEl1; i++)
+	  (*res)[i] = (e1->LogTrue( i) || e2->LogTrue( i)) ? 1 : 0;
+      }
+    return res;
+  }
+
+  BaseGDL* logical_true( EnvT* e)
+  {
+    SizeT nParam=e->NParam();
+    if( nParam != 1)
+      throw GDLException( e->CallingNode(),
+			  "LOGICAL_TRUE: Incorrect number of arguments.");
+
+    BaseGDL* e1=e->GetParDefined( 0);//, "LOGICAL_TRUE");
+    
+    ULong nEl1 = e1->N_Elements();
+
+    Data_<SpDByte>* res = new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
+    for( SizeT i=0; i < nEl1; i++)
+      (*res)[i] = e1->LogTrue( i) ? 1 : 0;
+    
+    return res;
+  }
+
+  BaseGDL* replicate( EnvT* e)
+  {
+    SizeT nParam=e->NParam();
+    if( nParam < 2)
+      e->Throw( "Incorrect number of arguments.");
+    dimension dim;
+    arr( e, dim, 1);
+
+    BaseGDL* p0=e->GetParDefined( 0);//, "REPLICATE");
+    if( !p0->Scalar())
+      e->Throw(	"Expression must be a scalar in this context: "+
+		e->GetParString(0));
+
+    return p0->New( dim, BaseGDL::INIT);
+  }
+
+  BaseGDL* strtrim( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 1);//, "STRTRIM");
+
+    BaseGDL* p0 = e->GetPar( 0);
+    if( p0 == NULL)
+      throw GDLException( e->CallingNode(),
+			  "STRTRIM: Variable is undefined: "+
+			  e->GetParString(0));
+    DStringGDL* p0S = static_cast<DStringGDL*>
+      (p0->Convert2(STRING,BaseGDL::COPY));
+    
+    DLong mode = 0;
+    if( nParam == 2)
+      {
+	BaseGDL* p1 = e->GetPar( 1);
+	if( p1 == NULL)
+	  throw GDLException( e->CallingNode(),
+			      "Variable is undefined: "+e->GetParString(1));
+	if( !p1->Scalar())
+	  throw GDLException( e->CallingNode(),
+			      "STRTRIM: Expression must be a "
+			      "scalar in this context: "+
+			      e->GetParString(1));
+	DLongGDL* p1L = static_cast<DLongGDL*>
+	  (p1->Convert2(LONG,BaseGDL::COPY));
+
+	mode = (*p1L)[ 0];
+
+	delete p1L;
+
+	if( mode < 0 || mode > 2)
+	  {
+	    ostringstream os;
+	    p1->ToStream( os);
+	    throw GDLException( e->CallingNode(),
+				"STRTRIM: Value of <"+ p1->TypeStr() +
+				"  ("+os.str()+
+				")> is out of allowed range.");
+	  }
+      }
+    
+    SizeT nEl = p0S->N_Elements();
+
+    if( mode == 2) // both
+      for( SizeT i=0; i<nEl; ++i)
+	{
+	  unsigned long first= (*p0S)[ i].find_first_not_of(" \t");
+	  if( first == (*p0S)[ i].npos)
+	    {
+	      (*p0S)[ i] = "";
+	    }
+	  else
+	    {
+	      unsigned long last = (*p0S)[ i].find_last_not_of(" \t");
+	      (*p0S)[ i] = (*p0S)[ i].substr(first,last-first+1);
+	    }
+	}
+    else if( mode == 1) // leading
+      for( SizeT i=0; i<nEl; ++i)
+	{
+	  unsigned long first= (*p0S)[ i].find_first_not_of(" \t");
+	  if( first == (*p0S)[ i].npos)
+	    {
+	      (*p0S)[ i] = "";
+	    }
+	  else
+	    {
+	      (*p0S)[ i] = (*p0S)[ i].substr(first);
+	    }
+	}
+    else // trailing
+      for( SizeT i=0; i<nEl; ++i)
+	{
+	  unsigned long last = (*p0S)[ i].find_last_not_of(" \t");
+	  if( last == (*p0S)[ i].npos)
+	    {
+	      (*p0S)[ i] = "";
+	    }
+	  else
+	    {
+	      (*p0S)[ i] = (*p0S)[ i].substr(0,last+1);
+	    }
+	}
+
+    return p0S;
+  }
+
+  BaseGDL* strcompress( EnvT* e)
+  {
+    e->NParam( 1);
+
+    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+
+    bool removeAll =  e->KeywordSet(0);
+
+    DStringGDL* res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
+
+    SizeT nEl = p0S->N_Elements();
+    for( SizeT i=0; i<nEl; ++i)
+      {
+	(*res)[ i] = StrCompress((*p0S)[ i], removeAll);
+      }
+    
+    return res;
+  }
+
+  BaseGDL* strpos( EnvT* e)
+  {
+    e->NParam( 2);//, "STRPOS");
+
+    bool reverseOffset =  e->KeywordSet(0); // REVERSE_OFFSET
+    bool reverseSearch =  e->KeywordSet(1); // REVERSE_SEARCH
+
+    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+
+    DString searchString;
+    //     e->AssureScalarPar<DStringGDL>( 1, searchString);
+    DStringGDL* sStr = e->GetParAs<DStringGDL>( 1);
+    if( !sStr->Scalar( searchString))
+      e->Throw( "Search string must be a scalar or one element array: "+
+		e->GetParString( 1));
+
+    DLong pos = string::npos;
+    BaseGDL* p2 = e->GetPar( 2);
+    if( p2 != NULL) e->AssureLongScalarPar( 2, pos);
+
+    DLongGDL* res = new DLongGDL( p0S->Dim(), BaseGDL::NOZERO);
+
+    SizeT nSrcStr = p0S->N_Elements();
+    for( long i=0; i<nSrcStr; ++i)
+      {
+	(*res)[ i] = StrPos((*p0S)[ i], searchString, pos, 
+			    reverseOffset, reverseSearch);
+      }
+    
+    return res;
+  }
+
+  BaseGDL* strmid( EnvT* e)
+  {
+    e->NParam( 2);//, "STRMID");
+
+    bool reverse =  e->KeywordSet(0);
+
+    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+    DLongGDL*   p1L = e->GetParAs<DLongGDL>( 1);
+
+    BaseGDL*  p2  = e->GetPar( 2);
+    DLongGDL* p2L = NULL;
+    if( p2 != NULL) p2L = e->GetParAs<DLongGDL>( 2);
+
+    DLong scVal1;
+    bool sc1 = p1L->Scalar( scVal1);
+
+    DLong scVal2 = string::npos;
+    bool sc2 = true;
+    if( p2L != NULL) sc2 = p2L->Scalar( scVal2);
+
+    DLong stride;
+    if( !sc1 && !sc2)
+      {
+	stride = p1L->Dim( 0);
+	if( stride != p2L->Dim( 0))
+	  throw GDLException( e->CallingNode(),
+			      "STRMID: Starting offset and Length arguments "
+			      "have incompatible first dimension.");	  
+      }
+    else
+      {
+	// at least one scalar, p2L possibly NULL
+	if( p2L == NULL)
+	  stride = p1L->Dim( 0);
+	else
+	  stride = max( p1L->Dim( 0), p2L->Dim( 0));
+	
+	stride = (stride > 0)? stride : 1;
+      }
+
+    dimension resDim( p0S->Dim());
+    if( stride > 1)
+      resDim >> stride;
+
+    DStringGDL* res = new DStringGDL( resDim, BaseGDL::NOZERO);
+
+    SizeT nEl1 = p1L->N_Elements();
+    SizeT nEl2 = (sc2)? 1 : p2L->N_Elements();
+
+    SizeT nSrcStr = p0S->N_Elements();
+    for( long i=0; i<nSrcStr; ++i)
+      {
+	for( long ii=0; ii<stride; ++ii)
+	  {
+	    SizeT destIx = i * stride + ii;
+	    DLong actFirst = (sc1)? scVal1 : (*p1L)[ destIx % nEl1];
+	    DLong actLen   = (sc2)? scVal2 : (*p2L)[ destIx % nEl2];
+	    (*res)[ destIx] = StrMid((*p0S)[ i], actFirst, actLen, reverse);
+	  }
+      }
+    
+    return res;
+  }
+
+  BaseGDL* strlowcase( EnvT* e)
+  {
+    e->NParam( 1);//, "STRLOWCASE");
+
+    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+
+    DStringGDL* res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
+    
+    SizeT nEl = p0S->N_Elements();
+    for( SizeT i=0; i<nEl; ++i)
+      {
+	(*res)[ i] = StrLowCase((*p0S)[ i]);
+      }
+    
+    return res;
+  }
+
+  BaseGDL* strupcase( EnvT* e)
+  {
+    e->NParam( 1);//, "STRUPCASE");
+
+    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+
+    DStringGDL* res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
+    
+    SizeT nEl = p0S->N_Elements();
+    for( SizeT i=0; i<nEl; ++i)
+      {
+	(*res)[ i] = StrUpCase((*p0S)[ i]);
+      }
+    
+    return res;
+  }
+
+  BaseGDL* strlen( EnvT* e)
+  {
+    e->NParam( 1);//, "STRLEN");
+
+    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+
+    DLongGDL* res = new DLongGDL( p0S->Dim(), BaseGDL::NOZERO);
+
+    SizeT nEl = p0S->N_Elements();
+    for( SizeT i=0; i<nEl; ++i)
+      {
+	(*res)[ i] = (*p0S)[ i].length();
+      }
+    
+    return res;
+  }
+
+  BaseGDL* strjoin( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 1);
+
+    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+    SizeT nEl = p0S->N_Elements();
+
+    DString delim = "";
+    if( nParam > 1)
+      e->AssureStringScalarPar( 1, delim);
+    
+    bool single = e->KeywordSet( 0); // SINGLE
+
+    if( single)
+      {
+	DStringGDL* res = new DStringGDL( (*p0S)[0]);
+	DString&    scl = (*res)[0];
+
+	for( SizeT i=1; i<nEl; ++i)
+	  scl += delim + (*p0S)[i];
+
+	return res;
+      }
+
+    dimension resDim( p0S->Dim());
+    resDim.Purge();
+    
+    SizeT stride = resDim.Stride( 1);
+
+    resDim.Remove( 0);
+
+    DStringGDL* res = new DStringGDL( resDim, BaseGDL::NOZERO);
+    for( SizeT src=0, dst=0; src<nEl; ++dst)
+      {
+	(*res)[ dst] = (*p0S)[ src++];
+	for(SizeT l=1; l<stride; ++l)
+	  (*res)[ dst] += delim + (*p0S)[ src++];
+      }
+    
+    return res;
+  }
+
+  BaseGDL* where( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 1);//, "WHERE");
+
+    BaseGDL* p0 = e->GetParDefined( 0);//, "WHERE");
+
+    SizeT nEl = p0->N_Elements();
+
+    SizeT count;
+
+    DLong* ixList = p0->Where( e->KeywordPresent( 0), count);
+    ArrayGuard<DLong> guard( ixList);
+    SizeT nCount = nEl - count;
+
+    if( e->KeywordPresent( 0)) // COMPLEMENT
+      {
+	if( nCount == 0)
+	  {
+	    e->SetKW( 0, new DLongGDL( -1));
+	  }
+	else
+	  {
+	    DLongGDL* cIxList = new DLongGDL( dimension( &nCount, 1), 
+					      BaseGDL::NOZERO);
+	    
+	    SizeT cIx = nEl;
+	    for( SizeT i=0; i<nCount; ++i)
+	      (*cIxList)[ i] = ixList[ --cIx];
+	    
+	    e->SetKW( 0, cIxList);
+	  }
+      }
+
+    if( e->KeywordPresent( 1)) // NCOMPLEMENT
+      {
+	e->SetKW( 1, new DLongGDL( nCount));
+      }
+
+    if( nParam == 2)
+      {
+	e->SetPar( 1, new DLongGDL( count));
+      }
+
+    if( count == 0) return new DLongGDL( -1);
+
+    return new DLongGDL( ixList, count);
+
+    //     DLongGDL* res = new DLongGDL( dimension( &count, 1), 
+    // 				  BaseGDL::NOZERO);
+    //     for( SizeT i=0; i<count; ++i)
+    //       (*res)[ i] = ixList[ i];
+
+    //     return res;
+  }
+
+  BaseGDL* n_params( EnvT* e) 
+  {
+    EnvUDT* caller = static_cast<EnvUDT*>(e->Caller());
+    if( caller == NULL) return new DLongGDL( 0);
+    DLong nP = caller->NParam();
+    if( caller->IsObject()) 
+      return new DLongGDL( nP-1); // "self" is not counted
+    return new DLongGDL( nP);
+  }
+
+  BaseGDL* keyword_set( EnvT* e)
+  {
+    e->NParam( 1);//, "KEYWORD_SET");
+
+    BaseGDL* p0 = e->GetPar( 0);
+    if( p0 == NULL) return new DIntGDL( 0);
+    if( !p0->Scalar()) return new DIntGDL( 1);
+    if( p0->Type() == STRUCT) return new DIntGDL( 1);
+    if( p0->LogTrue()) return new DIntGDL( 1);
+    return new DIntGDL( 0);
+  }
+
+  // passing 2nd argument by value is slightly better for float and double, 
+  // but incur some overhead for the complex class.
+  template<class T> inline void AddOmitNaN(T& dest, T value)
+  { if (isfinite(value)) dest += value; }
+  template<class T> inline void AddOmitNaNCpx(T& dest, T value)
+  {
+    dest += T(isfinite(value.real())? value.real() : 0,
+	      isfinite(value.imag())? value.imag() : 0);
+  }
+  template<> inline void AddOmitNaN(DComplex& dest, DComplex value)
+  { AddOmitNaNCpx<DComplex>(dest, value); }
+  template<> inline void AddOmitNaN(DComplexDbl& dest, DComplexDbl value)
+  { AddOmitNaNCpx<DComplexDbl>(dest, value); }
+
+  template<class T> inline void NaN2Zero(T& value)
+  { if (!isfinite(value)) value = 0; }
+  template<class T> inline void NaN2ZeroCpx(T& value)
+  {
+    value = T(isfinite(value.real())? value.real() : 0, 
+              isfinite(value.imag())? value.imag() : 0);
+  }
+  template<> inline void NaN2Zero(DComplex& value)
+  { NaN2ZeroCpx< DComplex>(value); }
+  template<> inline void NaN2Zero(DComplexDbl& value)
+  { NaN2ZeroCpx< DComplexDbl>(value); }
+
+  // total over all elements
+  template<class T>
+  BaseGDL* total_template( T* src, bool omitNaN)
+  {
+    if (!omitNaN) return new T(src->Sum());
+    typename T::Ty sum = 0;
+    SizeT nEl = src->N_Elements();
+    for ( SizeT i=0; i<nEl; ++i)
+      {
+	AddOmitNaN(sum, (*src)[ i]);
+      }
+    return new T(sum);
+  }
+  
+  // cumulative over all dims
+  template<typename T>
+  BaseGDL* total_cu_template( T* res, bool omitNaN)
+  {
+    SizeT nEl = res->N_Elements();
+    if (omitNaN)
+      {
+        for( SizeT i=0; i<nEl; ++i)
+          NaN2Zero((*res)[i]);
+      }
+    for( SizeT i=1,ii=0; i<nEl; ++i,++ii)
+      (*res)[i] += (*res)[ii];
+    return res;
+  }
+
+  // total over one dim
+  template< typename T>
+  BaseGDL* total_over_dim_template( T* src, 
+				    const dimension& srcDim, 
+				    SizeT sumDimIx,
+                                    bool omitNaN)
+  {
+    SizeT nEl = src->N_Elements();
+    
+    // get dest dim and number of summations
+    dimension destDim = srcDim;
+    SizeT nSum = destDim.Remove( sumDimIx);
+
+    T* res = new T( destDim); // zero fields
+
+    // sumStride is also the number of linear src indexing
+    SizeT sumStride = srcDim.Stride( sumDimIx); 
+    SizeT outerStride = srcDim.Stride( sumDimIx + 1);
+    SizeT sumLimit = nSum * sumStride;
+    SizeT rIx=0;
+    for( SizeT o=0; o < nEl; o += outerStride)
+      for( SizeT i=0; i < sumStride; ++i)
+	{
+	  SizeT oi = o+i;
+	  SizeT oiLimit = sumLimit + oi;
+          if( omitNaN)
+            {
+              for( SizeT s=oi; s<oiLimit; s += sumStride)
+                AddOmitNaN((*res)[ rIx], (*src)[ s]);
+	    }
+          else
+            {
+  	      for( SizeT s=oi; s<oiLimit; s += sumStride)
+	        (*res)[ rIx] += (*src)[ s];
+            }
+	  ++rIx;
+	}
+    return res;
+  }
+
+  // cumulative over one dim
+  template< typename T>
+  BaseGDL* total_over_dim_cu_template( T* res, 
+				       SizeT sumDimIx,
+                                       bool omitNaN)
+  {
+    SizeT nEl = res->N_Elements();
+    const dimension& resDim = res->Dim();
+    if (omitNaN)
+      {
+        for( SizeT i=0; i<nEl; ++i)
+          NaN2Zero((*res)[i]);
+      }
+    SizeT cumStride = resDim.Stride( sumDimIx); 
+    SizeT outerStride = resDim.Stride( sumDimIx + 1);
+    for( SizeT o=0; o < nEl; o += outerStride)
+      {
+	SizeT cumLimit = o+outerStride;
+	for( SizeT i=o+cumStride, ii=o; i<cumLimit; ++i, ++ii)
+	  (*res)[ i] += (*res)[ ii];
+      }
+    return res;
+  }
+
+
+  BaseGDL* total( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 1);//, "TOTAL");
+
+    BaseGDL* p0 = e->GetParDefined( 0);//, "TOTAL");
+
+    SizeT nEl = p0->N_Elements();
+    if( nEl == 0)
+      e->Throw( "Variable is undefined: "+e->GetParString(0));
+
+    if( p0->Type() == STRING)
+      e->Throw( "String expression not allowed "
+		"in this context: "+e->GetParString(0));
+    
+    static int cumIx = e->KeywordIx( "CUMULATIVE");
+    static int intIx = e->KeywordIx("INTEGER");
+    static int doubleIx = e->KeywordIx( "DOUBLE");
+    static int nanIx = e->KeywordIx( "NAN");
+
+    bool cumulative = e->KeywordSet( cumIx);
+    bool intRes  = e->KeywordSet( intIx);
+    bool doubleRes  = e->KeywordSet( doubleIx);
+    bool nan        = e->KeywordSet( nanIx);
+
+    DLong sumDim = 0;
+    if( nParam == 2)
+      e->AssureLongScalarPar( 1, sumDim);
+
+    if( sumDim == 0)
+      {
+	if( !cumulative)
+	  {
+
+	    // Integer parts by Erin Sheldon
+	    // In IDL total(), the INTEGER keyword takes precedence 
+	    if( intRes )
+	      {
+		// We use LONG64 unless the input is ULONG64
+		if ( p0->Type() == LONG64 )
+		  {
+		    return total_template<DLong64GDL>
+		      ( static_cast<DLong64GDL*>(p0), nan );
+		  }
+		if ( p0->Type() == ULONG64 )
+		  {
+		    return total_template<DULong64GDL>
+		      ( static_cast<DULong64GDL*>(p0), nan );
+		  }
+
+		// Conver to Long64
+		DLong64GDL* p0L64 = static_cast<DLong64GDL*>
+		  (p0->Convert2( LONG64, BaseGDL::COPY));
+		e->Guard( p0L64);
+		return total_template<DLong64GDL>( p0L64, nan);
+
+	      } // integer results
+
+
+	    if( p0->Type() == DOUBLE)
+	      {
+		return total_template<DDoubleGDL>
+                  ( static_cast<DDoubleGDL*>(p0), nan); 
+	      }
+	    if( p0->Type() == COMPLEXDBL)
+	      {
+		return total_template<DComplexDblGDL>
+                  ( static_cast<DComplexDblGDL*>(p0), nan); 
+	      }
+
+	    if( !doubleRes)
+	      {
+		if( p0->Type() == FLOAT)
+		  {
+		    return total_template<DFloatGDL>
+		      ( static_cast<DFloatGDL*>(p0), nan); 
+		  }
+		if( p0->Type() == COMPLEX)
+		  {
+		    return total_template<DComplexGDL>
+		      ( static_cast<DComplexGDL*>(p0), nan); 
+		  }
+ 		DFloatGDL* p0F = static_cast<DFloatGDL*>
+ 		  (p0->Convert2( FLOAT,BaseGDL::COPY));
+ 		e->Guard( p0F);
+		return total_template<DFloatGDL>( p0F, false);
+	      }
+	    if( p0->Type() == COMPLEX)
+	      {
+		DComplexDblGDL* p0D = static_cast<DComplexDblGDL*>
+		  (p0->Convert2( COMPLEXDBL,BaseGDL::COPY));
+		e->Guard( p0D);
+		return total_template<DComplexDblGDL>( p0D, nan); 
+	      }
+	    
+	    DDoubleGDL* p0D = static_cast<DDoubleGDL*>
+	      (p0->Convert2( DOUBLE, BaseGDL::COPY));
+	    e->Guard( p0D);
+	    return total_template<DDoubleGDL>( p0D, nan);
+	  }
+	else // cumulative
+	  {
+
+	    // INTEGER keyword takes precedence
+	    if( intRes )
+	      {
+		// We use LONG64 unless the input is ULONG64
+		if ( p0->Type() == LONG64 )
+		  {
+		    return total_cu_template<DLong64GDL>
+		      ( static_cast<DLong64GDL*>(p0)->Dup(), nan );
+		  }
+		if ( p0->Type() == ULONG64 )
+		  {
+		    return total_cu_template<DULong64GDL>
+		      ( static_cast<DULong64GDL*>(p0)->Dup(), nan );
+		  }
+
+		// Convert to Long64
+		return total_cu_template<DLong64GDL>
+		  ( static_cast<DLong64GDL*>
+		    (p0->Convert2( LONG64, BaseGDL::COPY)), nan);
+						     
+	      } // integer results
+
+
+	    // special case as DOUBLE type overrides /DOUBLE
+	    if( p0->Type() == DOUBLE)
+	      {
+  	        return total_cu_template< DDoubleGDL>
+		  ( static_cast<DDoubleGDL*>(p0)->Dup(), nan);
+	      }
+	    if( p0->Type() == COMPLEXDBL)
+	      {
+  	        return total_cu_template< DComplexDblGDL>
+		  ( static_cast<DComplexDblGDL*>(p0)->Dup(), nan);
+	      }
+
+
+
+	    if( !doubleRes)
+	      {
+		// special case for FLOAT has no advantage here
+		if( p0->Type() == COMPLEX)
+		  {
+		    return total_cu_template< DComplexGDL>
+                      ( static_cast<DComplexGDL*>(p0)->Dup(), nan);
+		  }
+    	        return total_cu_template< DFloatGDL>
+		  ( static_cast<DFloatGDL*>( p0->Convert2(FLOAT, 
+							  BaseGDL::COPY)), nan);
+	      }
+	    if( p0->Type() == COMPLEX)
+	      {
+		return total_cu_template< DComplexDblGDL>
+		  ( static_cast<DComplexDblGDL*>(p0->Convert2( COMPLEXDBL, 
+							       BaseGDL::COPY)), nan);
+	      }
+    	    return total_cu_template< DDoubleGDL>
+	      ( static_cast<DDoubleGDL*>(p0->Convert2( DOUBLE, 
+						       BaseGDL::COPY)), nan);
+	  }
+      }
+
+    // total over sumDim
+    dimension srcDim = p0->Dim();
+    SizeT srcRank = srcDim.Rank();
+
+    if( sumDim < 1 || sumDim > srcRank)
+      throw GDLException( e->CallingNode(), 
+			  "TOTAL: Array must have "+i2s(sumDim)+
+			  " dimensions: "+e->GetParString(0));
+
+    if( !cumulative)
+      {
+
+	// INTEGER keyword takes precedence 
+	if( intRes )
+	  {
+	    // We use LONG64 unless the input is ULONG64
+	    if ( p0->Type() == LONG64 )
+	      {
+		return total_over_dim_template<DLong64GDL>
+		  ( static_cast<DLong64GDL*>(p0), srcDim, sumDim-1, nan );
+	      }
+	    if ( p0->Type() == ULONG64 )
+	      {
+		return total_over_dim_template<DULong64GDL>
+		  ( static_cast<DULong64GDL*>(p0), srcDim, sumDim-1, nan );
+	      }
+	    
+	    // Conver to Long64
+	    DLong64GDL* p0L64 = static_cast<DLong64GDL*>
+	      (p0->Convert2( LONG64, BaseGDL::COPY));
+	    e->Guard( p0L64);
+	    return total_over_dim_template<DLong64GDL>
+	      ( p0L64, srcDim, sumDim-1, nan);
+	    
+	  } // integer results
+
+
+	if( p0->Type() == DOUBLE)
+	  {
+	    return total_over_dim_template< DDoubleGDL>
+	      ( static_cast<DDoubleGDL*>(p0), srcDim, sumDim-1, nan);
+	  }
+	if( p0->Type() == COMPLEXDBL)
+	  {
+	    return total_over_dim_template< DComplexDblGDL>
+	      ( static_cast<DComplexDblGDL*>(p0), srcDim, sumDim-1, nan);
+	  }
+	if( !doubleRes)
+	  {
+	    if( p0->Type() == FLOAT)
+	      {
+		return total_over_dim_template< DFloatGDL>
+		  ( static_cast<DFloatGDL*>(p0), srcDim, sumDim-1, nan);
+	      }
+	    if( p0->Type() == COMPLEX)
+	      {
+		return total_over_dim_template< DComplexGDL>
+		  ( static_cast<DComplexGDL*>(p0), srcDim, sumDim-1, nan);
+	      }
+	    // default for NOT /DOUBLE
+	    DFloatGDL* p0F = static_cast<DFloatGDL*>
+	      (p0->Convert2( FLOAT,BaseGDL::COPY));
+	    e->Guard( p0F);
+	    return total_over_dim_template< DFloatGDL>
+	      ( p0F, srcDim, sumDim-1, false);
+	  }
+	if( p0->Type() == COMPLEX)
+	  {
+	    DComplexDblGDL* p0D = static_cast<DComplexDblGDL*>
+	      (p0->Convert2( COMPLEXDBL,BaseGDL::COPY));
+	    e->Guard( p0D);
+	    return total_over_dim_template< DComplexDblGDL>
+	      ( p0D, srcDim, sumDim-1, nan);
+	  }
+	// default for /DOUBLE
+	DDoubleGDL* p0D = static_cast<DDoubleGDL*>
+	  (p0->Convert2( DOUBLE,BaseGDL::COPY));
+	e->Guard( p0D);
+	return total_over_dim_template< DDoubleGDL>( p0D, srcDim, sumDim-1,nan);
+      }
+    else // cumulative
+      {
+
+	// INTEGER keyword takes precedence
+	if( intRes )
+	  {
+	    // We use LONG64 unless the input is ULONG64
+	    if ( p0->Type() == LONG64 )
+	      {
+		return total_over_dim_cu_template<DLong64GDL>
+		  ( static_cast<DLong64GDL*>(p0)->Dup(), sumDim-1, nan );
+	      }
+	    if ( p0->Type() == ULONG64 )
+	      {
+		return total_over_dim_cu_template<DULong64GDL>
+		  ( static_cast<DULong64GDL*>(p0)->Dup(), sumDim-1, nan );
+	      }
+	    
+	    // Convert to Long64
+	    return total_over_dim_cu_template<DLong64GDL>
+	      ( static_cast<DLong64GDL*>
+		(p0->Convert2( LONG64, BaseGDL::COPY)), sumDim-1, nan);
+	    
+	  } // integer results
+
+
+	if( p0->Type() == DOUBLE)
+	  {
+	    return total_over_dim_cu_template< DDoubleGDL>
+	      ( static_cast<DDoubleGDL*>(p0)->Dup(), sumDim-1, nan);
+	  }
+	if( p0->Type() == COMPLEXDBL)
+	  {
+	    return total_over_dim_cu_template< DComplexDblGDL>
+	      ( static_cast<DComplexDblGDL*>(p0)->Dup(), sumDim-1, nan);
+	  }
+	if( !doubleRes)
+	  {
+	    // special case for FLOAT has no advantage here
+	    if( p0->Type() == COMPLEX)
+	      {
+		return total_over_dim_cu_template< DComplexGDL>
+		  ( static_cast<DComplexGDL*>(p0)->Dup(), sumDim-1, nan);
+	      }
+	    // default for NOT /DOUBLE
+	    return total_over_dim_cu_template< DFloatGDL>
+	      ( static_cast<DFloatGDL*>( p0->Convert2( FLOAT, 
+						       BaseGDL::COPY)), sumDim-1, nan);
+	  }
+	if( p0->Type() == COMPLEX)
+	  {
+	    return total_over_dim_cu_template< DComplexDblGDL>
+	      ( static_cast<DComplexDblGDL*>(p0->Convert2( COMPLEXDBL,
+							   BaseGDL::COPY)), sumDim-1, nan);
+	  }
+	// default for /DOUBLE
+	return total_over_dim_cu_template< DDoubleGDL>
+	  ( static_cast<DDoubleGDL*>(p0->Convert2( DOUBLE,
+						   BaseGDL::COPY)), sumDim-1, nan);
+      }
+  }
+
+
+  // passing 2nd argument by value is slightly better for float and double, 
+  // but incur some overhead for the complex class.
+  template<class T> inline void MultOmitNaN(T& dest, T value)
+  { if (isfinite(value)) dest *= value; }
+  template<class T> inline void MultOmitNaNCpx(T& dest, T value)
+  {
+    dest *= T(isfinite(value.real())? value.real() : 1,
+	      isfinite(value.imag())? value.imag() : 1);
+  }
+  template<> inline void MultOmitNaN(DComplex& dest, DComplex value)
+  { MultOmitNaNCpx<DComplex>(dest, value); }
+  template<> inline void MultOmitNaN(DComplexDbl& dest, DComplexDbl value)
+  { MultOmitNaNCpx<DComplexDbl>(dest, value); }
+
+  template<class T> inline void Nan2One(T& value)
+  { if (!isfinite(value)) value = 1; }
+  template<class T> inline void Nan2OneCpx(T& value)
+  {
+    value = T(isfinite(value.real())? value.real() : 1, 
+              isfinite(value.imag())? value.imag() : 1);
+  }
+  template<> inline void Nan2One(DComplex& value)
+  { Nan2OneCpx< DComplex>(value); }
+  template<> inline void Nan2One(DComplexDbl& value)
+  { Nan2OneCpx< DComplexDbl>(value); }
+
+  // product over all elements
+  template<class T>
+  BaseGDL* product_template( T* src, bool omitNaN)
+  {
+    typename T::Ty sum = 1;
+    SizeT nEl = src->N_Elements();
+    if( !omitNaN) 
+      for ( SizeT i=0; i<nEl; ++i)
+	{
+	  sum *= (*src)[ i];
+	}
+    else
+      for ( SizeT i=0; i<nEl; ++i)
+	{
+	  MultOmitNaN( sum, (*src)[ i]);
+	}
+    return new T( sum);
+  }
+  
+  // cumulative over all dims
+  template<typename T>
+  BaseGDL* product_cu_template( T* res, bool omitNaN)
+  {
+    SizeT nEl = res->N_Elements();
+    if( omitNaN)
+      {
+        for( SizeT i=0; i<nEl; ++i)
+          Nan2One( (*res)[i]);
+      }
+    for( SizeT i=1,ii=0; i<nEl; ++i,++ii)
+      (*res)[i] *= (*res)[ii];
+    return res;
+  }
+
+  // product over one dim
+  template< typename T>
+  BaseGDL* product_over_dim_template( T* src, 
+				      const dimension& srcDim, 
+				      SizeT sumDimIx,
+				      bool omitNaN)
+  {
+    SizeT nEl = src->N_Elements();
+    
+    // get dest dim and number of summations
+    dimension destDim = srcDim;
+    SizeT nSum = destDim.Remove( sumDimIx);
+
+    T* res = new T( destDim, BaseGDL::NOZERO);
+
+    // sumStride is also the number of linear src indexing
+    SizeT sumStride = srcDim.Stride( sumDimIx); 
+    SizeT outerStride = srcDim.Stride( sumDimIx + 1);
+    SizeT sumLimit = nSum * sumStride;
+    SizeT rIx=0;
+    for( SizeT o=0; o < nEl; o += outerStride)
+      for( SizeT i=0; i < sumStride; ++i)
+	{
+	  (*res)[ rIx] = 1;
+	  SizeT oi = o+i;
+	  SizeT oiLimit = sumLimit + oi;
+          if( omitNaN)
+            {
+              for( SizeT s=oi; s<oiLimit; s += sumStride)
+                MultOmitNaN((*res)[ rIx], (*src)[ s]);
+	    }
+          else
+            {
+  	      for( SizeT s=oi; s<oiLimit; s += sumStride)
+	        (*res)[ rIx] *= (*src)[ s];
+            }
+	  ++rIx;
+	}
+    return res;
+  }
+
+  // cumulative over one dim
+  template< typename T>
+  BaseGDL* product_over_dim_cu_template( T* res, 
+					 SizeT sumDimIx,
+					 bool omitNaN)
+  {
+    SizeT nEl = res->N_Elements();
+    const dimension& resDim = res->Dim();
+    if (omitNaN)
+      {
+        for( SizeT i=0; i<nEl; ++i)
+          Nan2One((*res)[i]);
+      }
+    SizeT cumStride = resDim.Stride( sumDimIx); 
+    SizeT outerStride = resDim.Stride( sumDimIx + 1);
+    for( SizeT o=0; o < nEl; o += outerStride)
+      {
+	SizeT cumLimit = o+outerStride;
+	for( SizeT i=o+cumStride, ii=o; i<cumLimit; ++i, ++ii)
+	  (*res)[ i] *= (*res)[ ii];
+      }
+    return res;
+  }
+
+  BaseGDL* product( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 1);
+
+    BaseGDL* p0 = e->GetParDefined( 0);
+
+    SizeT nEl = p0->N_Elements();
+    if( nEl == 0)
+      e->Throw( "Variable is undefined: "+e->GetParString(0));
+
+    if( p0->Type() == STRING)
+      e->Throw( "String expression not allowed "
+		"in this context: "+e->GetParString(0));
+    
+    static int cumIx = e->KeywordIx( "CUMULATIVE");
+    static int nanIx = e->KeywordIx( "NAN");
+    bool cumulative = e->KeywordSet( cumIx);
+    bool nan        = e->KeywordSet( nanIx);
+
+    DLong sumDim = 0;
+    if( nParam == 2)
+      e->AssureLongScalarPar( 1, sumDim);
+
+    if( sumDim == 0)
+      {
+	if( !cumulative)
+	  {
+	    if( p0->Type() == DOUBLE)
+	      {
+		return product_template<DDoubleGDL>
+                  ( static_cast<DDoubleGDL*>(p0), nan); 
+	      }
+	    if( p0->Type() == COMPLEXDBL)
+	      {
+		return product_template<DComplexDblGDL>
+                  ( static_cast<DComplexDblGDL*>(p0), nan); 
+	      }
+	    if( p0->Type() == COMPLEX)
+	      {
+		DComplexDblGDL* p0D = static_cast<DComplexDblGDL*>
+		  (p0->Convert2( COMPLEXDBL,BaseGDL::COPY));
+		e->Guard( p0D);
+		return product_template<DComplexDblGDL>( p0D, nan); 
+	      }
+	    
+	    DDoubleGDL* p0D = static_cast<DDoubleGDL*>
+	      (p0->Convert2( DOUBLE, BaseGDL::COPY));
+	    e->Guard( p0D);
+	    return product_template<DDoubleGDL>( p0D, nan);
+	  }
+	else // cumulative
+	  {
+	    // special case as DOUBLE type overrides /DOUBLE
+	    if( p0->Type() == DOUBLE)
+	      {
+  	        return product_cu_template< DDoubleGDL>
+		  ( static_cast<DDoubleGDL*>(p0)->Dup(), nan);
+	      }
+	    if( p0->Type() == COMPLEXDBL)
+	      {
+  	        return product_cu_template< DComplexDblGDL>
+		  ( static_cast<DComplexDblGDL*>(p0)->Dup(), nan);
+	      }
+	    if( p0->Type() == COMPLEX)
+	      {
+		return product_cu_template< DComplexDblGDL>
+		  ( static_cast<DComplexDblGDL*>(p0->Convert2( COMPLEXDBL, 
+							       BaseGDL::COPY)), nan);
+	      }
+    	    return product_cu_template< DDoubleGDL>
+	      ( static_cast<DDoubleGDL*>(p0->Convert2( DOUBLE, 
+						       BaseGDL::COPY)), nan);
+	  }
+      }
+
+    // product over sumDim
+    dimension srcDim = p0->Dim();
+    SizeT srcRank = srcDim.Rank();
+
+    if( sumDim < 1 || sumDim > srcRank)
+      e->Throw( "Array must have "+i2s(sumDim)+
+		" dimensions: "+e->GetParString(0));
+
+    if( !cumulative)
+      {
+	if( p0->Type() == DOUBLE)
+	  {
+	    return product_over_dim_template< DDoubleGDL>
+	      ( static_cast<DDoubleGDL*>(p0), srcDim, sumDim-1, nan);
+	  }
+	if( p0->Type() == COMPLEXDBL)
+	  {
+	    return product_over_dim_template< DComplexDblGDL>
+	      ( static_cast<DComplexDblGDL*>(p0), srcDim, sumDim-1, nan);
+	  }
+	if( p0->Type() == COMPLEX)
+	  {
+	    DComplexDblGDL* p0D = static_cast<DComplexDblGDL*>
+	      (p0->Convert2( COMPLEXDBL,BaseGDL::COPY));
+	    e->Guard( p0D);
+	    return product_over_dim_template< DComplexDblGDL>
+	      ( p0D, srcDim, sumDim-1, nan);
+	  }
+
+	DDoubleGDL* p0D = static_cast<DDoubleGDL*>
+	  (p0->Convert2( DOUBLE,BaseGDL::COPY));
+	e->Guard( p0D);
+	return product_over_dim_template< DDoubleGDL>( p0D, srcDim, sumDim-1,nan);
+      }
+    else // cumulative
+      {
+	if( p0->Type() == DOUBLE)
+	  {
+	    return product_over_dim_cu_template< DDoubleGDL>
+	      ( static_cast<DDoubleGDL*>(p0)->Dup(), sumDim-1, nan);
+	  }
+	if( p0->Type() == COMPLEXDBL)
+	  {
+	    return product_over_dim_cu_template< DComplexDblGDL>
+	      ( static_cast<DComplexDblGDL*>(p0)->Dup(), sumDim-1, nan);
+	  }
+	if( p0->Type() == COMPLEX)
+	  {
+	    return product_over_dim_cu_template< DComplexDblGDL>
+	      ( static_cast<DComplexDblGDL*>(p0->Convert2( COMPLEXDBL,
+							   BaseGDL::COPY)), sumDim-1, nan);
+	  }
+
+	return product_over_dim_cu_template< DDoubleGDL>
+	  ( static_cast<DDoubleGDL*>(p0->Convert2( DOUBLE,
+						   BaseGDL::COPY)), sumDim-1, nan);
+      }
+  }
+
+  BaseGDL* array_equal( EnvT* e)
+  {
+    e->NParam( 2);//, "ARRAY_EQUAL");
+
+    BaseGDL* p0 = e->GetParDefined( 0);//, "ARRAY_EQUAL");
+    BaseGDL* p1 = e->GetParDefined( 1);//, "ARRAY_EQUAL");
+
+    if( p0 == p1) return new DByteGDL( 1);
+
+    SizeT nEl0 = p0->N_Elements();
+    SizeT nEl1 = p1->N_Elements();
+    if( nEl0 != nEl1 && nEl0 != 1 && nEl1 != 1)
+      return new DByteGDL( 0);
+    
+    if( p0->Type() != p1->Type())
+      {
+	if( e->KeywordSet( 0)) // NO_TYPECONV
+	  return new DByteGDL( 0);
+	else
+	  {
+	    DType aTy=p0->Type();
+	    DType bTy=p1->Type();
+	    if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+	      {
+		p1 = p1->Convert2( aTy, BaseGDL::COPY);
+		e->Guard( p1);
+	      }
+	    else
+	      {
+		p0 = p0->Convert2( bTy, BaseGDL::COPY);
+		e->Guard( p0);
+	      }
+	  }
+      }
+    
+    if( p0->ArrayEqual( p1)) return new DByteGDL( 1);
+
+    return new DByteGDL( 0);
+  }
+
+  BaseGDL* min_fun( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 1);
+    
+    BaseGDL* searchArr = e->GetParDefined( 0);
+
+    DLong    minEl;
+    BaseGDL* res;
+    // bool omitNaN = e->KeywordPresent( 1); // NAN keyword 
+    bool omitNaN = e->KeywordSet( "NAN");
+
+    bool subMax = e->KeywordPresent( 2);   // SUBSCRIPT_MAX present
+
+    if( nParam == 2)
+      e->AssureGlobalPar( 1);
+
+    if( e->KeywordPresent( 0)) // MAX keyword given
+      {
+	e->AssureGlobalKW( 0);
+	delete e->GetKW( 0);
+ 
+	DLong maxEl;
+
+	searchArr->MinMax( &minEl, &maxEl, &res, &e->GetKW( 0), omitNaN);
+	if ( subMax)
+	  {
+	    e->SetKW( 2, new DLongGDL(maxEl));
+	  }
+      }
+    else // no MAX keyword
+      {
+	if( subMax)
+	  {
+	    DLong maxEl;
+	    searchArr->MinMax( &minEl, &maxEl, &res, NULL, omitNaN);
+	    e->SetKW( 2, new DLongGDL(maxEl));
+	  }
+	else
+	  searchArr->MinMax( &minEl, NULL, &res, NULL, omitNaN);
+      }
+    
+    // handle index
+    if( nParam == 2)
+      {
+	delete e->GetPar( 1);
+	e->GetPar( 1) = new DLongGDL( minEl);
+      }
+    else
+      {
+	SysVar::SetC( minEl);
+      }
+    return res;
+  }
+
+  BaseGDL* max_fun( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 1);
+    
+    BaseGDL* searchArr = e->GetParDefined( 0);
+
+    DLong    maxEl;
+    BaseGDL* res;
+    //bool omitNaN = e->KeywordPresent( 1); // NAN keyword 
+    bool omitNaN = e->KeywordSet( "NAN");
+
+    bool subMin = e->KeywordPresent( 2);  // SUBSCRIPT_MIN present
+
+    if( nParam == 2)
+      e->AssureGlobalPar( 1);
+
+    if( e->KeywordPresent( 0)) // MIN keyword given
+      {
+	e->AssureGlobalKW( 0);
+	delete e->GetKW( 0);
+ 
+	DLong minEl;
+
+	searchArr->MinMax( &minEl, &maxEl, &e->GetKW( 0), &res, omitNaN);
+	if( subMin)
+	  {
+	    e->SetKW( 2, new DLongGDL(minEl));
+	  }
+      }
+    else // no MIN keyword
+      {
+	if( subMin)
+	  {
+	    DLong minEl;
+	    searchArr->MinMax( &minEl, &maxEl, NULL, &res, omitNaN);
+	    e->SetKW( 2, new DLongGDL(minEl));
+	  }
+	else
+	  searchArr->MinMax( NULL, &maxEl, NULL, &res, omitNaN);
+      }
+
+    // handle index
+    if( nParam == 2)
+      {
+	delete e->GetPar( 1);
+	e->GetPar( 1) = new DLongGDL( maxEl);
+      }
+    else
+      {
+	SysVar::SetC( maxEl);
+      }
+
+    return res;
+  }
+ 
+  BaseGDL* transpose( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 1); 
+
+    BaseGDL* p0 = e->GetParDefined( 0);
+    if( p0->Type() == STRUCT)
+      e->Throw("Struct expression not allowed in this context: "+
+	       e->GetParString(0));
+    
+    SizeT rank = p0->Rank();
+    if( rank == 0)
+      e->Throw( "Expression must be an array "
+		"in this context: "+ e->GetParString(0));
+    
+    if( nParam == 2) 
+      {
+ 
+	BaseGDL* p1 = e->GetParDefined( 1);
+	if( p1->N_Elements() != rank)
+	  e->Throw("Incorrect number of elements in permutation.");
+
+	DUInt* perm = new DUInt[rank];
+	auto_ptr<DUInt> perm_guard( perm);
+
+	DUIntGDL* p1L = static_cast<DUIntGDL*>
+	  (p1->Convert2( UINT, BaseGDL::COPY));
+	for( SizeT i=0; i<rank; ++i) perm[i] = (*p1L)[ i];
+	delete p1L;
+
+	// check permutaion vector
+	for( SizeT i=0; i<rank; ++i) 
+	  {
+	    DUInt j;
+	    for( j=0; j<rank; ++j) if( perm[j] == i) break;
+	    if (j == rank)
+	      e->Throw( "Incorrect permutation vector.");
+	  }
+	return p0->Transpose( perm);
+      }
+
+    return p0->Transpose( NULL);
+  }
+
+ 
+
+  // helper function for sort_fun, recursive
+  // optimized version
+  template< typename IndexT>
+  void MergeSortOpt( BaseGDL* p0, IndexT* hhS, IndexT* h1, IndexT* h2,
+		     SizeT len) 
+  {
+    if( len <= 1) return;       
+
+    SizeT h1N = len / 2;
+    SizeT h2N = len - h1N;
+
+    // 1st half
+    MergeSortOpt(p0, hhS, h1, h2, h1N);
+
+    // 2nd half
+    IndexT* hhM = &hhS[h1N]; 
+    MergeSortOpt(p0, hhM, h1, h2, h2N);
+
+    SizeT i;
+    for(i=0; i<h1N; ++i) h1[i] = hhS[ i];
+    for(i=0; i<h2N; ++i) h2[i] = hhM[ i];
+
+    SizeT  h1Ix = 0;
+    SizeT  h2Ix = 0;
+    for( i=0; (h1Ix < h1N) && (h2Ix < h2N); ++i) 
+      {
+	// the actual comparisson
+	if( p0->Greater( h1[h1Ix], h2[h2Ix])) 
+	  hhS[ i] = h2[ h2Ix++];
+	else
+	  hhS[ i] = h1[ h1Ix++];
+      }
+    for(; h1Ix < h1N; ++i) hhS[ i] = h1[ h1Ix++];
+    for(; h2Ix < h2N; ++i) hhS[ i] = h2[ h2Ix++];
+  }
+
+  // helper function for sort_fun, recursive
+  void MergeSort( BaseGDL* p0, SizeT* hh, SizeT* h1, SizeT* h2,
+		  SizeT start, SizeT end) 
+  {
+    if( start+1 >= end) return;       
+
+    SizeT middle = (start+end) / 2;
+
+    MergeSort(p0, hh, h1, h2, start, middle);
+    MergeSort(p0, hh, h1, h2, middle, end);
+
+    SizeT h1N = middle - start;
+    SizeT h2N = end - middle;
+
+    SizeT* hhS = &hh[start];
+
+    SizeT i;
+    for(i=0; i<h1N; ++i) h1[i] = hhS[ i];
+    for(i=0; i<h2N; ++i) h2[i] = hh[middle + i];
+
+    SizeT  h1Ix = 0;
+    SizeT  h2Ix = 0;
+    for( i=0; (h1Ix < h1N) && (h2Ix < h2N); ++i) 
+      {
+	// the actual comparisson
+	if( p0->Greater( h1[h1Ix], h2[h2Ix])) 
+	  hhS[ i] = h2[ h2Ix++];
+	else
+	  hhS[ i] = h1[ h1Ix++];
+      }
+    for(; h1Ix < h1N; ++i) hhS[ i] = h1[ h1Ix++];
+    for(; h2Ix < h2N; ++i) hhS[ i] = h2[ h2Ix++];
+  }
+
+  // sort function uses MergeSort
+  BaseGDL* sort_fun( EnvT* e)
+  {
+    e->NParam( 1);
+    
+    BaseGDL* p0 = e->GetParDefined( 0);
+
+    if( p0->Type() == STRUCT)
+      e->Throw( "Struct expression not allowed in this context: "+
+		e->GetParString(0));
+    
+    static int l64Ix = e->KeywordIx( "L64");
+    bool l64 = e->KeywordSet( l64Ix);
+    
+    SizeT nEl = p0->N_Elements();
+    
+    // helper arrays
+    DLongGDL* res = new DLongGDL( dimension( nEl), BaseGDL::INDGEN);
+
+    DLong *hh = static_cast<DLong*>(res->DataAddr());
+
+    DLong* h1 = new DLong[ nEl/2];
+    DLong* h2 = new DLong[ (nEl+1)/2];
+    // call the sort routine
+    MergeSortOpt<DLong>( p0, hh, h1, h2, nEl);
+    delete[] h1;
+    delete[] h2;
+
+    if( l64) 
+      {
+	// leave it this way, as sorting of more than 2^31
+	// items seems not feasible in the future we might 
+	// use MergeSortOpt<DLong64>(...) for this 
+	return res->Convert2( LONG64);
+      }
+
+    return res;
+  }
+
+  // uses MergeSort
+  BaseGDL* median( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 1);
+    
+    if( !(nParam > 1))
+      {
+	BaseGDL* p0 = e->GetParDefined( 0);
+
+	if( p0->Type() == STRUCT)
+	  e->Throw( "Struct expression not allowed in this context: "+
+		    e->GetParString(0));
+
+	if( p0->Rank() == 0)
+	  e->Throw( "Expression must be an array in this context: "+
+		    e->GetParString(0));
+    
+	SizeT nEl = p0->N_Elements();
+	
+	static int evenIx = e->KeywordIx( "EVEN");
+	static int doubleIx = e->KeywordIx( "DOUBLE");
+
+	// DIM keyword
+	DLong dim = 0;
+	DLong nmed = 1;
+	DDoubleGDL *res;
+	e->AssureLongScalarKWIfPresent( "DIM", dim);
+	
+	if (dim > p0->Rank())
+	  e->Throw( "Illegal keyword value for DIMENSION.");
+	
+	if (dim > 0) {
+	  DLong dims[8];
+	  DLong k = 0;
+	  for (SizeT i=0; i<p0->Rank(); ++i)
+	    if (i != (dim-1)) {
+	      nmed *= p0->Dim(i);
+	      dims[k++] = p0->Dim(i);
+	    }
+	  dimension dimRes((DLong *) dims, p0->Rank()-1);
+	  res = new DDoubleGDL( dimRes, BaseGDL::NOZERO);
+	} else {
+	  res = new DDoubleGDL( 1);
+	}
+	
+	// helper arrays
+	if (nmed > 1) nEl = p0->N_Elements() / nmed;
+	
+	DLong *hh = new DLong[ nEl];
+	DLong* h1 = new DLong[ nEl/2];
+	DLong* h2 = new DLong[ (nEl+1)/2];
+	
+	DLong accumStride = 1;
+	if (nmed > 1)
+	  for( DLong i=0; i<dim-1; ++i) accumStride *= p0->Dim(i);
+	
+	// Loop over all subarray medians
+	for (SizeT k=0; k<nmed; ++k) {
+	  
+	  if (nmed == 1) { 
+	    for( DLong i=0; i<nEl; ++i) hh[i] = i;
+	  } else {
+	    // Starting Element
+	    DLong start = accumStride * p0->Dim(dim-1) * (k / accumStride) + 
+	      (k % accumStride);
+	    for( DLong i=0; i<nEl; ++i) hh[i] = start + i * accumStride;
+	  }
+	  //    ArrayGuard< DLong> hhGuard( hh);
+	  
+	  // call the sort routine
+	  MergeSortOpt<DLong>( p0, hh, h1, h2, nEl);
+	  DLong medEl = hh[ nEl/2];
+	  DLong medEl_1 = hh[ nEl/2 - 1];
+	  
+	  if( (nEl % 2) == 1 || !e->KeywordSet( evenIx)) {
+	    if (nmed == 1)
+	      res = (DDoubleGDL *) (p0->NewIx( medEl))->Convert2( DOUBLE);
+	    else {
+	      DDoubleGDL* op1 = 
+		static_cast<DDoubleGDL*>((p0->NewIx( medEl))->Convert2( DOUBLE));
+	      (*res)[k] = (*op1)[0];
+	    }
+	  } else {
+	    DDoubleGDL* op1 = 
+	      static_cast<DDoubleGDL*>((p0->NewIx( medEl))->Convert2( DOUBLE)); 
+	    e->Guard( op1);
+	    DDoubleGDL* op2 = 
+	      static_cast<DDoubleGDL*>((p0->NewIx( medEl_1))->Convert2( DOUBLE));
+	    static DDoubleGDL* op3 = new DDoubleGDL( 2.0);
+	    if (nmed == 1)
+	      res = op2->Add( op1)->Div( op3);
+	    else {
+	      op1 = op2->Add( op1)->Div( op3);
+	      (*res)[k] = (*op1)[0];
+	    }
+	  }
+	}
+	delete[] h1;
+	delete[] h2;
+	delete[] hh;
+	
+	if( p0->Type() == DOUBLE || 
+	    p0->Type() == COMPLEXDBL || 
+	    e->KeywordSet( doubleIx))
+	  return res;
+	else
+	  return res->Convert2( FLOAT);
+      }
+    else 
+      // with parameter Width : median filtering with no optmisation,
+      //  such as histogram algorithms.
+      // Copyright: (C) 2008 by Nicolas Galmiche
+      {
+	cout << "c0 " << endl;	  
+
+	// basic checks on "vector/array" input	
+	DDoubleGDL* p0 = e->GetParAs<DDoubleGDL>( 0);	
+
+	cout << "c1 " << endl;	  
+
+
+    	if( p0->Type() == STRUCT)
+	  e->Throw( "Struct expression not allowed in this context: "+ e->GetParString(0));	
+   	if( p0->Rank() == 0)
+	  e->Throw( "Expression must be an array in this context: "+ e->GetParString(0));
+   	
+	if( p0->Rank() > 2)
+	  e->Throw( "Only 1 or 2 dimensions allowed: "+ e->GetParString(0));
+
+ 	cout << "c2 " << endl;	  
+   	
+	// basic checks on "width" input		
+ 	DDoubleGDL* p1d = e->GetParAs<DDoubleGDL>(1);
+ 	
+	if (p1d->N_Elements() > 1 || (*p1d)[0] <=0 ) 
+	  e->Throw( "Width must be a positive scalar or 1 (positive) element array in this context: "+ e->GetParString(0));
+	DLong MaxAllowedWidth=0;
+	if (p0->Rank() == 1) MaxAllowedWidth=p0->N_Elements();
+	if (p0->Rank() == 2) {
+	  MaxAllowedWidth=p0->Dim(0);
+	  if (p0->Dim(1) < MaxAllowedWidth) MaxAllowedWidth=p0->Dim(1);	   
+	}
+	int debug =1;
+	if (debug == 1) {
+	  cout << "X dim " << p0->Dim(0) <<endl;
+	  cout << "y dim " << p0->Dim(1) <<endl;	  
+	  cout << "MaxAllowedWidth " << MaxAllowedWidth <<endl;
+	}
+	if (!isfinite( (*p1d)[0]))
+	  e->Throw("% MEDIAN: Width must be > 1, and < dimension of array (NaN or Inf)");
+	
+ 	DLongGDL* p1 = e->GetParAs<DLongGDL>(1);	
+
+	DDoubleGDL *tamp = new DDoubleGDL(p0->Dim(),BaseGDL::NOZERO);
+	DDouble min=((*p0)[0]);
+     	DDouble max=min;
+    	 
+     	for (SizeT ii=0 ; ii<p0->N_Elements() ; ++ii)
+	  {(*tamp)[ii]=(*p0)[ii];
+	  if ( (*p0)[ii] < min ) min = ((*p0)[ii]);
+	  if ( (*p0)[ii] > max ) max = ((*p0)[ii]);
+	  }	
+		
+   	//---------------------------- END d'acquisistion des paramètres -------------------------------------	
+
+	
+	static int evenIx = e->KeywordIx( "EVEN");
+    	static int doubleIx = e->KeywordIx( "DOUBLE");
+	static DStructGDL *Values =  SysVar::Values();                                                
+    	DDouble d_nan=(*static_cast<DDoubleGDL*>(Values->GetTag(Values->Desc()->TagIndex("D_NAN"), 0)))[0]; 
+	DDouble d_infinity= (*static_cast<DDoubleGDL*>(Values->GetTag(Values->Desc()->TagIndex("D_INFINITY"), 0)))[0]; 
+ 
+	//------------------------------ Init variables and allocation ---------------------------------------
+	SizeT width=(*p1)[0];
+	SizeT N_MaskElem= width*width;
+	SizeT larg = p0->Stride(1);
+	SizeT haut = p0->Stride(2)/larg;
+	SizeT lim= static_cast<SizeT>(round(width/2));
+	SizeT init=(lim*larg+lim);
+	
+	// we don't go further if dimension(s) versus not width OK
+
+	if (debug == 1) {cout << "ici" <<endl;}
+	
+	if ( p0->Rank() == 1) {
+	  if (larg < width || width==1 ) e->Throw( "% MEDIAN: Width must be > 1, and < width of vector");
+	} 
+	if ( p0->Rank() == 2) {	
+	  if (larg < width || haut < width || width==1) e->Throw("% MEDIAN: Width must be > 1, and < dimension of array");
+	}
+
+	// for 2D arrays, we use the algorithm described in paper
+	// from T. Huang, G. Yang, and G. Tang, “A Fast Two-Dimensional Median
+	// Filtering Algorithm,” IEEE Trans. Acoust., Speech, Signal Processing,
+	// vol. 27, no. 1, pp. 13–18, 1979.
+
+	if ( (e->GetParDefined( 0)->Type() == BYTE ||
+	      e->GetParDefined( 0)->Type() == INT  || 
+	      e->GetParDefined( 0)->Type() == UINT ||
+	      e->GetParDefined( 0)->Type() == LONG ||
+	      e->GetParDefined( 0)->Type() == ULONG ||
+	      e->GetParDefined( 0)->Type() == LONG64 ||
+	      e->GetParDefined( 0)->Type() == ULONG64) &&
+	     (haut>1))
+	  {
+	    SizeT taille=static_cast<SizeT>(abs(max)-min+1);		
+	    DDoubleGDL* Histo = new DDoubleGDL(taille,BaseGDL::NOZERO);
+	    if (width % 2 ==0)
+	      {
+		for(SizeT i=0 ; i<haut-2*lim ; ++i)				
+		  {
+		    SizeT ltmed=0;
+		    SizeT med=0;
+		    SizeT initial=init+i*larg-lim*larg-lim;
+		    for(SizeT pp=0 ; pp<taille;++pp)(*Histo)[pp]=0;	
+		    for (SizeT ii=initial ; ii <initial+ width ; ++ii)
+		      {	
+			for(SizeT yy=0;yy<width;yy++)
+			  (*Histo)[static_cast<SizeT>((*p0)[ii+yy*larg]-min)]++;
+		      }
+		    
+		    while (ltmed+(*Histo)[med]<=(N_MaskElem /2))
+		      {
+			ltmed+= static_cast<SizeT>((*Histo)[med]);
+			++med;
+		      }
+		    if (e->KeywordSet( evenIx))
+		      {
+			
+			SizeT EvenMed=med;
+			//if ((*Histo)[EvenMed]==1 || (ltmed!=0 && ltmed !=(N_MaskElem /2) -1))
+			if ((*Histo)[EvenMed]==1 || (ltmed!=0 && N_MaskElem /2- ltmed!=1) )
+			  {
+			    while ((*Histo)[EvenMed-1]==0)
+			      {  EvenMed--;}
+			    (*tamp)[init+i*larg]=((med+min)+(EvenMed-1+min))/2;
+			  }
+			else
+			  (*tamp)[init+i*larg]=med+min;
+		      }
+		    else
+		      {(*tamp)[init+i*larg]=med+min; }
+		    
+		    for(SizeT j=init+i*larg +1; j<init+(i+1)*larg-2*lim ;++ j)	
+		      {				
+			SizeT initMask=j-lim*larg-lim;			
+			for(SizeT k=0;k<2*lim;++k)			
+			  {	
+			    (*Histo)[static_cast<SizeT>((*p0)[initMask-1+k*larg]-min)]--;
+			    if ((*p0)[initMask-1+k*larg]-min<med)ltmed--;
+				 						
+			    (*Histo)[static_cast<SizeT>((*p0)[initMask+k*larg+2*lim-1]-min)]++;
+			    if ((*p0)[initMask+k*larg+2*lim-1]-min<med)ltmed++;
+			  }
+			if (ltmed>N_MaskElem /2)
+			  {
+			    while(ltmed>N_MaskElem /2)
+			      {
+				--med;
+				ltmed-=static_cast<SizeT>((*Histo)[med]);
+			      }
+			  }
+			else
+			  {
+			    while (ltmed+(*Histo)[med]<=(N_MaskElem /2))
+			      {
+				ltmed+= static_cast<SizeT>((*Histo)[med]);
+				++med;
+			      }	
+			  }
+			
+			if (e->KeywordSet( evenIx))
+			  {
+			    SizeT EvenMed=med;
+			    if ((*Histo)[EvenMed]==1 || (ltmed!=0 &&N_MaskElem /2- ltmed!=1 ))
+			      {
+				while ((*Histo)[EvenMed-1]==0)
+				  {  EvenMed--;}
+				(*tamp)[j]=((med+min)+(EvenMed-1+min))/2;
+			      }
+			    else
+			      {(*tamp)[j]=med+min; }
+			  }
+			else
+			  {(*tamp)[j]=med+min; }
+		      }
+		  } 
+	      }
+	    else
+	      {
+		for(SizeT i=0 ; i<haut-2*lim ; ++i)				
+		  {
+		    SizeT ltmed=0;
+		    SizeT med=0;
+		    SizeT initial=init+i*larg-lim*larg-lim;
+		    for(SizeT pp=0 ; pp<taille;++pp)(*Histo)[pp]=0;	
+		    for (SizeT ii=initial ; ii <initial+ width ; ++ii)
+		      {	
+			for(SizeT yy=0;yy<width;yy++)
+			  (*Histo)[static_cast<SizeT>((*p0)[ii+yy*larg]-min)]++;
+		      }
+
+		    while (ltmed+(*Histo)[med]<=(N_MaskElem /2))
+		      {
+			ltmed+= static_cast<SizeT>((*Histo)[med]);
+			++med;
+		      }
+		    (*tamp)[init+i*larg]=med+min;
+	
+		    for(SizeT j=init+i*larg +1; j<init+(i+1)*larg-2*lim ;++ j)	
+		      {	
+			
+			SizeT initMask=j-lim*larg-lim;			
+			for(SizeT k=0;k<=2*lim;++k)			
+			  {	
+			    (*Histo)[static_cast<SizeT>((*p0)[initMask-1+k*larg]-min)]--;
+			    if ((*p0)[initMask-1+k*larg]-min<med)ltmed--;
+				 						 						 		
+			    (*Histo)[static_cast<SizeT>((*p0)[initMask+k*larg+2*lim]-min)]++;
+			    if ((*p0)[initMask+k*larg+2*lim]-min<med)ltmed++;
+			  }
+			if (ltmed>N_MaskElem /2)
+			  {
+			    while(ltmed>N_MaskElem /2)
+			      {
+				--med;
+				ltmed-=static_cast<SizeT>((*Histo)[med]);
+			      }
+			  }
+			else
+			  {
+			    while (ltmed+(*Histo)[med]<=(N_MaskElem /2))
+			      {
+				ltmed+= static_cast<SizeT>((*Histo)[med]);
+				++med;
+			      }	
+			  }
+			
+			(*tamp)[j]=med+min;
+			
+		      }
+		  } 
+	      }
+	
+	  }
+	else
+	  {	
+	    DLong* hh; 
+	    DLong* h1;
+	    DLong* h2;
+	    DDoubleGDL* Mask,*Mask1D;
+	    if ( p0->Rank() != 1 )
+	      {
+		hh = new DLong[ N_MaskElem];
+    		h1 = new DLong[ N_MaskElem/2];
+		h2= new DLong[ (N_MaskElem+1)/2];
+		Mask = new DDoubleGDL(N_MaskElem,BaseGDL::NOZERO);
+		
+		for( DLong i=0; i<N_MaskElem; ++i) hh[i] = i;
+	      }
+	    else
+	      {
+		hh = new DLong[ width];
+		h1 = new DLong[ width/2];
+		h2= new DLong[(width+1)/2];
+		Mask1D = new DDoubleGDL(width,BaseGDL::NOZERO);
+		
+		for( DLong i=0; i<width; ++i) hh[i] = i;
+	      }
+	
+	    //-------------------------------- END OF VARIABLES INIT ---------------------------------------------
+
+	    //------------------------------ Median Filter Algorithms ---------------------------------------
+	
+	    if ( width % 2 ==0)
+	      {
+		if ( p0->Rank() == 1 )//------------------------  For a vector with even width -------------------
+		  {	
+		    for (SizeT col= lim ; col<larg-lim ; ++col)
+		      {	
+			SizeT ctl_NaN=0;
+			SizeT kk=0;
+			for (SizeT ind=col-lim ; ind<col+lim ; ++ind)
+			  {
+			    if( (*p0)[ind]!=d_infinity && (*p0)[ind]!=-d_infinity && isfinite((*p0)[ind])==0)
+			      ctl_NaN++;
+			    else
+			      {	
+				(*Mask1D)[kk]=(*p0)[ind];
+				kk++;
+			      }
+			  }
+			if (ctl_NaN!=0)
+			  {
+			    if(ctl_NaN==width)(*tamp)[col]= d_nan;
+			    else 
+			      {
+				DLong*	hhbis = new DLong[ width-ctl_NaN];
+				DLong*	h1bis = new DLong[ width-ctl_NaN/2];
+				DLong*	h2bis= new DLong[(width-ctl_NaN+1)/2];
+				DDoubleGDL *Mask1Dbis = new DDoubleGDL(width-ctl_NaN,BaseGDL::NOZERO);
+				for( DLong t=0; t<width-ctl_NaN; ++t) hhbis[t] = t;
+				for( DLong ii=0; ii<width-ctl_NaN; ++ii)(*Mask1Dbis)[ii]=(*Mask1D)[ii];
+				BaseGDL* besort=static_cast<BaseGDL*>(Mask1Dbis);	
+				MergeSortOpt<DLong>( besort, hhbis, h1bis, h2bis,(width - ctl_NaN));
+				if (e->KeywordSet( evenIx)&& (width - ctl_NaN) % 2 == 0)
+				  (*tamp)[col]=((*Mask1Dbis)[hhbis[ (width-ctl_NaN)/2]]+(*Mask1Dbis
+											 )[hhbis	[ (width - ctl_NaN-1)/2]])/2;	
+				else
+				  (*tamp)[col]=(*Mask1Dbis)[hhbis[ (width- ctl_NaN)/2]];
+				delete[]hhbis;
+				delete[]h2bis;
+				delete[]h1bis;
+			      }
+			  }	
+			else
+			  {
+			    BaseGDL* besort=static_cast<BaseGDL*>(Mask1D);	
+			    MergeSortOpt<DLong>( besort, hh, h1, h2,width ); // call the sort routine
+
+			    if (e->KeywordSet( evenIx))
+
+			      (*tamp)[col]=((*Mask1D)[hh[ width/2]]+(*Mask1D)[hh[ (width-1)/2]])/2;
+			    else
+			      (*tamp)[col]=(*Mask1D)[hh[ width/2]];// replace value by Mask median 
+			  }
+		      }
+			
+		  }
+		else//------------------------  For an array with even width -------------------
+		  {
+		    SizeT jj;
+		    for(SizeT i=0 ; i<haut-2*lim ; ++i)		// lines to replace
+		      {
+		 	for(SizeT j=init+i*larg ; j<init+(i+1)*larg-2*lim ; ++j)// elements to replace
+			  {
+			    SizeT initMask=j-lim*larg-lim;	// left corner of mask
+			    SizeT kk=0;
+			    SizeT ctl_NaN=0;
+			    for(SizeT k=0;k<2*lim;++k)		// lines of mask
+			      {	
+								
+				for(jj=initMask+k*larg ; jj<(initMask+k*larg)+2*lim ; ++jj) // elements of mask
+				  {
+				    if( (*p0)[jj]!=d_infinity && (*p0)[jj]!=-d_infinity && isfinite((*p0)[jj])==0)
+				      ctl_NaN++;
+				    else
+				      {
+					(*Mask)[kk]=(*p0)[jj];
+					kk++;
+				      }
+				  }
+			      }
+			    if (ctl_NaN!=0)
+			      {
+				if(ctl_NaN==N_MaskElem)(*tamp)[j]= d_nan;
+				else {
+				  DLong*	hhb = new DLong[ N_MaskElem-ctl_NaN];
+				  DLong*	h1b = new DLong[ (N_MaskElem-ctl_NaN)/2];
+				  DLong*	h2b = new DLong[(N_MaskElem-ctl_NaN+1)/2];
+				  DDoubleGDL *Maskb = new DDoubleGDL(N_MaskElem-ctl_NaN,BaseGDL::NOZERO);
+				  for( DLong t=0; t<N_MaskElem-ctl_NaN; ++t) hhb[t] = t;
+				  for( DLong ii=0; ii<N_MaskElem-ctl_NaN; ++ii)(*Maskb)[ii]=(*Mask)[ii];
+				  BaseGDL* besort=static_cast<BaseGDL*>(Maskb);	
+				  MergeSortOpt<DLong>( besort, hhb, h1b, h2b,(N_MaskElem - ctl_NaN)); 
+				  if ((N_MaskElem - ctl_NaN) % 2 == 0 && e->KeywordSet( evenIx))
+				    (*tamp)[j]=((*Maskb)[hhb[ (N_MaskElem-ctl_NaN)/2]]+(*Maskb)[hhb 
+												[ (N_MaskElem - 
+												   ctl_NaN-1)/2]])/2;
+				  else
+				    (*tamp)[j]=(*Maskb)[hhb[ (N_MaskElem- ctl_NaN)/2]];
+				  delete[]hhb;
+				  delete[]h2b;
+				  delete[]h1b;
+				}
+			      }	
+			    else
+			      {
+			 	BaseGDL* besort=static_cast<BaseGDL*>(Mask);	
+			 	MergeSortOpt<DLong>( besort, hh, h1, h2, N_MaskElem); // call the sort routine
+				if (e->KeywordSet( evenIx))
+				  (*tamp)[j]=((*Mask)[hh[ N_MaskElem/2]]+(*Mask)[hh[ (N_MaskElem-1)/2]])/2;
+				else
+				  (*tamp)[j]=(*Mask)[hh[ N_MaskElem/2]];// replace value by median Mask one
+			      }
+			  }
+		      }
+		  }
+	      }
+
+	    else
+	      {
+		if ( p0->Rank() == 1 )//------------------------  For a vector with odd width -------------------
+	
+		  {	
+		    for (SizeT col= lim ; col<larg-lim ; ++col)
+		      {	
+			SizeT kk=0;
+			SizeT ctl_NaN=0;
+			for (SizeT ind=col-lim ; ind<=col+lim ; ++ind)
+			  {if( (*p0)[ind]!=d_infinity && (*p0)[ind]!=-d_infinity && isfinite((*p0)[ind])==0)
+			    ctl_NaN++;
+			  else{
+			    (*Mask1D)[kk]=(*p0)[ind];				
+			    kk++;
+			  }
+			  }
+			if (ctl_NaN!=0)
+			  {
+			    if(ctl_NaN==width)(*tamp)[col]= d_nan;
+			    else {
+			      DLong*	hhbis = new DLong[ width-ctl_NaN];
+			      DLong*	h1bis = new DLong[ width-ctl_NaN/2];
+			      DLong*	h2bis= new DLong[(width-ctl_NaN+1)/2];
+			      DDoubleGDL *Mask1Dbis = new DDoubleGDL(width-ctl_NaN,BaseGDL::NOZERO);
+			      for( DLong t=0; t<width-ctl_NaN; ++t) hhbis[t] = t;
+			      for( DLong ii=0; ii<width-ctl_NaN; ++ii)(*Mask1Dbis)[ii]=(*Mask1D)[ii];
+			      BaseGDL* besort=static_cast<BaseGDL*>(Mask1Dbis);	
+			      MergeSortOpt<DLong>( besort, hhbis, h1bis, h2bis,(width - ctl_NaN)); 
+			      if (e->KeywordSet( evenIx)&& (width - ctl_NaN) % 2 == 0)
+				(*tamp)[col]=((*Mask1Dbis)[hhbis[ (width-ctl_NaN)/2]]+(*Mask1Dbis
+										       )[hhbis	[ (width - ctl_NaN-1)/2]])/2;	
+			      else(*tamp)[col]=(*Mask1Dbis)[hhbis[ (width- ctl_NaN)/2]];
+			      delete[]hhbis;
+			      delete[]h2bis;
+			      delete[]h1bis;
+			    }
+			  }	
+			else
+			  {
+			    BaseGDL* besort=static_cast<BaseGDL*>(Mask1D);	
+			    MergeSortOpt<DLong>( besort, hh, h1, h2,width ); // call the sort routine
+			    (*tamp)[col]=(*Mask1D)[hh[ (width)/2]];	// replace value by Mask median 
+			  }
+		      }
+		
+		  }
+	
+		else //-----------------------------  For an array with odd width ---------------------------------
+		  {
+		    SizeT jj;
+		    for(SizeT i=0 ; i<haut-2*lim ; ++i)				// lines to replace
+		      {
+		
+		 	SizeT initial=init+i*larg-lim*larg-lim;
+			SizeT dd=0;SizeT ctl_NaN_init=0;
+			for(SizeT yy=0;yy<width;yy++)
+			  {	
+			    for (SizeT ii=initial+yy*larg ; ii <initial+ yy*larg+ width; ++ii)
+			      {
+					
+				if( (*p0)[ii]!=d_infinity && (*p0)[ii]!=-d_infinity && isfinite((*p0)[ii])==0)
+				  ctl_NaN_init++;
+				else
+				  (*Mask)[dd]=(*p0)[ii];
+				dd++;
+			      }
+			  }
+			SizeT kk=0;
+
+		 	for(SizeT j=init+i*larg ; j<init+(i+1)*larg-2*lim ; ++j)// elements to replace
+			  {
+			    SizeT initMask=j-lim*larg-lim;			// left corner of mask
+			    SizeT kk=0;
+			    SizeT ctl_NaN=0;
+			    for(SizeT k=0;k<=2*lim;++k)			// lines of mask
+			      {	
+								
+				for(jj=initMask+k*larg ; jj<=(initMask+k*larg)+2*lim ; ++jj) // elements of mask
+				  {
+				    if( (*p0)[jj]!=d_infinity && (*p0)[jj]!=-d_infinity && isfinite((*p0)[jj])==0)
+				      ctl_NaN++;
+						
+				    else
+				      {
+					(*Mask)[kk]=(*p0)[jj];
+					kk++;
+				      }
+				  }
+				
+			      }
+			 
+			    if (ctl_NaN!=0)
+			      {	
+				if(ctl_NaN==N_MaskElem)(*tamp)[j]= d_nan;
+				else {
+						
+				  DLong*	hhb = new DLong[ N_MaskElem-ctl_NaN];
+				  DLong*	h1b = new DLong[ (N_MaskElem-ctl_NaN)/2];
+				  DLong*	h2b= new DLong[(N_MaskElem-ctl_NaN+1)/2];
+				  DDoubleGDL*Maskb = new DDoubleGDL(N_MaskElem-ctl_NaN,BaseGDL::NOZERO);
+				  for( DLong t=0; t<N_MaskElem-ctl_NaN; ++t) hhb[t] = t;
+				  for( DLong ii=0; ii<N_MaskElem-ctl_NaN; ++ii)(*Maskb)[ii]=(*Mask)[ii];
+				  BaseGDL* besort=static_cast<BaseGDL*>(Maskb);	
+				  MergeSortOpt<DLong>( besort, hhb, h1b, h2b,(N_MaskElem - ctl_NaN)); 
+				  if ((N_MaskElem - ctl_NaN) % 2 == 0 && e->KeywordSet( evenIx))
+				    (*tamp)[j]=((*Maskb)[hhb[ (N_MaskElem-ctl_NaN)/2]]+(*Maskb)[hhb 
+												[ (N_MaskElem - 
+												   ctl_NaN-1)/2]])/2;
+				  else(*tamp)[j]=(*Maskb)[hhb[(N_MaskElem- ctl_NaN)/2]];
+				  delete[]hhb;
+				  delete[]h2b;
+				  delete[]h1b;
+				}
+			      }	
+			    else
+			      {
+				BaseGDL* besort=static_cast<BaseGDL*>(Mask);	
+			 	MergeSortOpt<DLong>( besort, hh, h1, h2, N_MaskElem); // call the sort routine
+				(*tamp)[j]=(*Mask)[hh[ (N_MaskElem)/2]];	// replace value by Mask median 
+			      }
+			  }
+		      }
+		  }
+	      }
+	    
+	    //--------------------------- END OF MEDIAN FILTER ALOGORITHMS -----------------------------------
+
+	    delete[] h1;
+	    delete[] h2;
+	    delete[] hh;   	
+	  }
+       	if ( e->GetParDefined( 0)->Type() == DOUBLE || p0->Type() == COMPLEXDBL ||e->KeywordSet( doubleIx) )
+	  return tamp;
+	else if (e->GetParDefined( 0)->Type() == BYTE) 
+	  return tamp->Convert2(BYTE,BaseGDL::CONVERT);
+	
+	return tamp->Convert2(FLOAT,BaseGDL::CONVERT);
+	
+      }// end if
+
+  }// end of median
+
+  BaseGDL* shift_fun( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 2);
+
+    BaseGDL* p0 = e->GetParDefined( 0);
+
+    SizeT nShift = nParam - 1;
+    if( nShift == 1)
+      {
+	DLong s1;
+	e->AssureLongScalarPar( 1, s1);
+
+	return p0->CShift( s1);
+      }
+    
+    if( p0->Rank() != nShift)
+      e->Throw( "Incorrect number of arguments.");
+
+    DLong sIx[ MAXRANK];
+    for( SizeT i=0; i< nShift; i++)
+      e->AssureLongScalarPar( i+1, sIx[ i]);
+
+    return p0->CShift( sIx);
+  }
+
+  BaseGDL* arg_present( EnvT* e)
+  {
+    e->NParam( 1);
+    
+    if( !e->GlobalPar( 0))
+      return new DIntGDL( 0);
+
+    EnvBaseT* caller = e->Caller();
+    if( caller == NULL)
+      return new DIntGDL( 0);
+
+    BaseGDL** pp0 = &e->GetPar( 0);
+    
+    int ix = caller->FindGlobalKW( pp0);
+    if( ix == -1)
+      return new DIntGDL( 0);
+
+    return new DIntGDL( 1);
+  }
+
+  BaseGDL* eof_fun( EnvT* e)
+  {
+    e->NParam( 1);
+
+    DLong lun;
+    e->AssureLongScalarPar( 0, lun);
+
+    bool stdLun = check_lun( e, lun);
+    if( stdLun)
+      return new DIntGDL( 0);
+
+    // nicer error message (Disregard if socket)
+    if ( fileUnits[ lun-1].SockNum() == -1) {
+      if( !fileUnits[ lun-1].IsOpen())
+	throw GDLIOException( e->CallingNode(), e->GetPro()->ObjectName()+
+			      ": File unit is not open: "+i2s( lun)+".");
+
+      if( fileUnits[ lun-1].Eof())
+	return new DIntGDL( 1);
+    } else {
+      // Socket
+      string *recvBuf = &fileUnits[ lun-1].RecvBuf();
+      if (recvBuf->size() == 0)
+	return new DIntGDL( 1);
+    }
+    return new DIntGDL( 0);
+  }
+
+  BaseGDL* convol( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 2); 
+
+    BaseGDL* p0 = e->GetNumericParDefined( 0);
+    if( p0->Rank() == 0) 
+      e->Throw( "Expression must be an array in this context: "+
+		e->GetParString(0));
+    
+    BaseGDL* p1 = e->GetNumericParDefined( 1);
+    if( p1->Rank() == 0) 
+      e->Throw( "Expression must be an array in this context: "+
+		e->GetParString(1));
+    
+    if( p0->N_Elements() <= p1->N_Elements())
+      e->Throw( "Incompatible dimensions for Array and Kernel.");
+
+    // rank 1 for kernel works always
+    if( p1->Rank() != 1)
+      {
+	SizeT rank = p0->Rank();
+	if( rank != p1->Rank())
+	  e->Throw( "Incompatible dimensions for Array and Kernel.");
+
+	for( SizeT r=0; r<rank; ++r)
+	  if( p0->Dim( r) <= p1->Dim( r))
+	    e->Throw( "Incompatible dimensions for Array and Kernel.");
+      }
+
+    // convert kernel to array type
+    auto_ptr<BaseGDL> p1Guard;
+    if( p0->Type() == BYTE)
+      {
+	if( p1->Type() != INT)
+	  {
+	    p1 = p1->Convert2( INT, BaseGDL::COPY); 
+	    p1Guard.reset( p1);
+	  }
+      }
+    else if( p0->Type() != p1->Type())
+      {
+	p1 = p1->Convert2( p0->Type(), BaseGDL::COPY); 
+	p1Guard.reset( p1);
+      }
+
+    BaseGDL* scale;
+    auto_ptr<BaseGDL> scaleGuard;
+    if( nParam > 2)
+      {
+	scale = e->GetParDefined( 2);
+	if( scale->Rank() > 0)
+	  e->Throw( "Expression must be a scalar in this context: "+
+		    e->GetParString(2));
+
+	// p1 here handles BYTE case also
+	if( p1->Type() != scale->Type())
+	  {
+	    scale = scale->Convert2( p1->Type(),BaseGDL::COPY); 
+	    scaleGuard.reset( scale);
+	  }
+      }
+    else
+      {
+	scale = p1->New( dimension(), BaseGDL::ZERO);
+      }
+
+    bool center = true;
+    static int centerIx = e->KeywordIx( "CENTER");
+    if( e->KeywordPresent( centerIx))
+      {
+	DLong c;
+	e->AssureLongScalarKW( centerIx, c);
+	center = (c != 0);
+      }
+
+    // overrides EDGE_TRUNCATE
+    static int edge_wrapIx = e->KeywordIx( "EDGE_WRAP");
+    bool edge_wrap = e->KeywordSet( edge_wrapIx);
+    static int edge_truncateIx = e->KeywordIx( "EDGE_TRUNCATE");
+    bool edge_truncate = e->KeywordSet( edge_truncateIx);
+
+    int edgeMode = 0; 
+    if( edge_wrap)
+      edgeMode = 1;
+    else if( edge_truncate)
+      edgeMode = 2;
+
+    // p0, p1 and scale have same type
+    // p1 has rank of 1 or same rank as p0 with each dimension smaller than p0
+    // scale is a scalar
+    return p0->Convol( p1, scale, center, edgeMode);
+  }
+
+  BaseGDL* rebin_fun( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 2);
+
+    BaseGDL* p0 = e->GetNumericParDefined( 0);
+
+    SizeT rank = p0->Rank();
+
+    if( rank == 0) 
+      e->Throw( "Expression must be an array in this context: "+
+		e->GetParString(0));
+    
+    SizeT resDimInit[ MAXRANK];
+    for( SizeT p=1; p<nParam; ++p)
+      {
+	DLong newDim;
+	e->AssureLongScalarPar( p, newDim);
+
+	if( newDim <= 0)
+	  e->Throw( "Array dimensions must be greater than 0.");
+	
+	if( rank >= p)
+	  {
+	    SizeT oldDim = p0->Dim( p-1);
+
+	    if( newDim > oldDim)
+	      {
+		if( (newDim % oldDim) != 0)
+		  e->Throw( "Result dimensions must be integer factor "
+			    "of original dimensions.");
+	      }
+	    else
+	      {
+		if( (oldDim % newDim) != 0)
+		  e->Throw( "Result dimensions must be integer factor "
+			    "of original dimensions.");
+	      }
+	  }
+	
+	resDimInit[ p-1] = newDim; 
+      }
+
+    dimension resDim( resDimInit, nParam-1);
+
+    static int sampleIx = e->KeywordIx( "SAMPLE");
+    bool sample = e->KeywordSet( sampleIx);
+    
+    return p0->Rebin( resDim, sample);
+  }
+
+  BaseGDL* obj_class( EnvT* e)
+  {
+    SizeT nParam = e->NParam();
+
+    static int countIx = e->KeywordIx( "COUNT");
+    static int superIx = e->KeywordIx( "SUPERCLASS");
+
+    bool super = e->KeywordSet( superIx);
+
+    bool count = e->KeywordPresent( countIx);
+    if( count)
+      e->AssureGlobalKW( countIx);
+
+    if( nParam > 0)
+      {
+	BaseGDL* p0 = e->GetParDefined( 0);
+
+	if( p0->Type() != STRING && p0->Type() != OBJECT)
+	  e->Throw( "Argument must be a scalar object reference or string: "+
+		    e->GetParString(0));
+
+	if( !p0->Scalar())
+	  e->Throw( "Expression must be a scalar or 1 element "
+		    "array in this context: "+e->GetParString(0));
+
+	DStructDesc* objDesc;
+
+	if( p0->Type() == STRING)
+	  {
+	    DString objName;
+	    e->AssureScalarPar<DStringGDL>( 0, objName);
+	    objName = StrUpCase( objName);
+
+	    objDesc = FindInStructList( structList, objName);
+	    if( objDesc == NULL)
+	      {
+		if( count)
+		  e->SetKW( countIx, new DLongGDL( 0));
+		return new DStringGDL( "");
+	      }
+	  }
+	else // OBJECT
+	  {
+	    DObj objRef;
+	    e->AssureScalarPar<DObjGDL>( 0, objRef);
+
+	    if( objRef == 0)
+	      {
+		if( count)
+		  e->SetKW( countIx, new DLongGDL( 0));
+		return new DStringGDL( "");
+	      }
+
+	    DStructGDL* oStruct;
+	    try {
+	      oStruct = e->GetObjHeap( objRef);
+	    }
+	    catch ( GDLInterpreter::HeapException)
+	      { // non valid object
+		if( count)
+		  e->SetKW( countIx, new DLongGDL( 0));
+		return new DStringGDL( "");
+	      }
+
+	    objDesc = oStruct->Desc(); // cannot be NULL
+	  }
+
+	if( !super)
+	  {
+	    if( count)
+	      e->SetKW( countIx, new DLongGDL( 1));
+	    return new DStringGDL( objDesc->Name());
+	  }
+	
+	deque< string> pNames;
+	objDesc->GetParentNames( pNames);
+
+	SizeT nNames = pNames.size();
+	    
+	if( count)
+	  e->SetKW( countIx, new DLongGDL( nNames));
+
+	if( nNames == 0)
+	  {
+	    return new DStringGDL( "");
+	  }
+
+	DStringGDL* res = new DStringGDL( dimension( nNames), 
+					  BaseGDL::NOZERO);
+
+	for( SizeT i=0; i<nNames; ++i)
+	  {
+	    (*res)[i] = pNames[i];
+	  }
+	
+	return res;
+      }
+
+    if( super)
+      e->Throw( "Conflicting keywords.");
+
+    SizeT nObj = structList.size();
+
+    DStringGDL* res = new DStringGDL( dimension( nObj), 
+				      BaseGDL::NOZERO);
+
+    for( SizeT i=0; i<nObj; ++i)
+      {
+	(*res)[i] = structList[i]->Name();
+      }
+	
+    return res;
+  }
+
+  BaseGDL* obj_isa( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 2);
+
+    BaseGDL* p0 = e->GetPar( 0);
+    if( p0 == NULL || p0->Type() != OBJECT)
+      e->Throw( "Object reference type required in this context: "+
+		e->GetParString(0));
+
+    DString className;
+    e->AssureScalarPar<DStringGDL>( 1, className);
+    className = StrUpCase( className);
+
+    DObjGDL* pObj = static_cast<DObjGDL*>( p0);
+
+    DByteGDL* res = new DByteGDL( pObj->Dim()); // zero 
+
+    GDLInterpreter* interpreter = e->Interpreter();
+
+    SizeT nElem = pObj->N_Elements();
+    for( SizeT i=0; i<nElem; ++i)
+      {
+	if( interpreter->ObjValid( (*pObj)[ i])) 
+	  {
+	    DStructGDL* oStruct = e->GetObjHeap( (*pObj)[i]);
+	    if( oStruct->Desc()->IsParent( className))
+	      (*res)[i] = 1;
+	  }
+      }
+    
+    return res;
+  }
+
+  BaseGDL* n_tags( EnvT* e)
+  {
+    e->NParam( 1);
+
+    BaseGDL* p0 = e->GetPar( 0);
+    if( p0 == NULL)
+      return new DLongGDL( 0);
+    
+    if( p0->Type() != STRUCT)
+      return new DLongGDL( 0);
+    
+    DStructGDL* s = static_cast<DStructGDL*>( p0);
+
+    static int lengthIx = e->KeywordIx( "LENGTH");
+    bool length = e->KeywordSet( lengthIx);
+    
+    if( length)
+      return new DLongGDL( s->Sizeof());
+
+    return new DLongGDL( s->Desc()->NTags());
+  }
+
+  BaseGDL* bytscl( EnvT* e)
+  {
+    e->NParam( 1);
+
+    BaseGDL* p0=e->GetNumericParDefined( 0);
+
+    static int minIx = e->KeywordIx( "MIN");
+    static int maxIx = e->KeywordIx( "MAX");
+    static int topIx = e->KeywordIx( "TOP");
+    bool omitNaN = e->KeywordPresent( 3);
+
+    DLong topL=255;
+    if( e->GetKW( topIx) != NULL)
+      e->AssureLongScalarKW( topIx, topL);
+    DByte top = static_cast<DByte>(topL);
+    DDouble dTop = static_cast<DDouble>(top);
+
+    DDouble min;
+    bool minSet = false;
+    if( e->GetKW( minIx) != NULL)
+      {
+	e->AssureDoubleScalarKW( minIx, min);
+	minSet = true;
+      }
+
+    DDouble max;
+    bool maxSet = false;
+    if( e->GetKW( maxIx) != NULL)
+      {
+	e->AssureDoubleScalarKW( maxIx, max);
+	maxSet = true;
+      }
+
+    DDoubleGDL* dRes = 
+      static_cast<DDoubleGDL*>(p0->Convert2( DOUBLE, BaseGDL::COPY));
+
+    DLong maxEl, minEl;
+    if( !maxSet || !minSet)
+      dRes->MinMax( &minEl, &maxEl, NULL, NULL, omitNaN);
+    if( !minSet)
+      min = (*dRes)[ minEl];
+    if( !maxSet)
+      max = (*dRes)[ maxEl];
+
+    SizeT nEl = dRes->N_Elements();
+    for( SizeT i=0; i<nEl; ++i)
+      {
+	DDouble& d = (*dRes)[ i];
+	if( d <= min)
+	  (*dRes)[ i] = 0;
+	else if( d >= max)
+	  (*dRes)[ i] = dTop;
+	else
+	  (*dRes)[ i] =  round((d - min) / (max-min) * dTop);
+      }
+
+    return dRes->Convert2( BYTE);
+  } 
+
+  BaseGDL* strtok_fun( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 1);
+    
+    DString stringIn;
+    e->AssureStringScalarPar( 0, stringIn);
+
+    DString pattern = " \t";
+    if(nParam > 1) {
+      e->AssureStringScalarPar( 1, pattern);
+    }
+    
+    static int extractIx = e->KeywordIx( "EXTRACT");
+    bool extract = e->KeywordSet( extractIx);
+
+    static int lengthIx = e->KeywordIx( "LENGTH");
+    bool lengthPresent = e->KeywordPresent( lengthIx);
+
+    if( extract && lengthPresent)
+      e->Throw( "Conflicting keywords.");
+    
+    static int pre0Ix = e->KeywordIx( "PRESERVE_NULL");
+    bool pre0 = e->KeywordSet( pre0Ix);
+
+    static int regexIx = e->KeywordIx( "REGEX");
+    bool regex = e->KeywordPresent( regexIx);
+    char err_msg[MAX_REGEXPERR_LENGTH];
+    regex_t regexp;
+    
+    deque<long> tokenStart;
+    deque<long> tokenLen;
+ 
+    int strLen = stringIn.length();
+
+    DString escape = "";
+    e->AssureStringScalarKWIfPresent( "ESCAPE", escape);
+    deque<long> escList;
+    long pos = 0;
+    while(pos != string::npos)
+      {
+	pos = stringIn.find_first_of( escape, pos);
+	if( pos != string::npos)
+	  {
+	    escList.push_back( pos+1); // remember escaped char
+	    pos += 2; // skip escaped char
+	  }
+      }
+    deque<long>::iterator escBeg = escList.begin();
+    deque<long>::iterator escEnd = escList.end();
+
+    long tokB = 0;
+    long tokE;
+    long nextE = 0;
+    long actLen;
+
+    // If regex then compile regex
+    if( regex) {
+      if (pattern == " \t") pattern = " "; // regcomp doesn't like "\t" JMG
+      int compRes = regcomp( &regexp, pattern.c_str(), REG_EXTENDED);
+      if (compRes) {
+	regerror(compRes, &regexp, err_msg, MAX_REGEXPERR_LENGTH);
+	throw GDLException(e->CallingNode(), 
+			   "STREGEX: Error processing regular expression: "+
+			   pattern+"\n           "+string(err_msg)+".");
+      }
+    }
+
+    for(;;)
+      {
+	regmatch_t pmatch[1];
+	if( regex) {
+	  int matchres = regexec( &regexp, stringIn.c_str()+nextE, 1, pmatch, 0);
+	  tokE = matchres? -1:pmatch[0].rm_so;
+	} else { 
+	  tokE = stringIn.find_first_of( pattern, nextE);
+	}
+
+	if( tokE == string::npos)
+	  {
+	    actLen = strLen - tokB;
+	    if( actLen > 0 || pre0)
+	      {
+		tokenStart.push_back( tokB);
+		tokenLen.push_back( actLen);
+	      }
+	    break;
+	  }
+
+	if( find( escBeg, escEnd, tokE) == escEnd) 
+	  {
+	    if (regex) actLen = tokE; else actLen = tokE - tokB;
+	    if( actLen > 0 || pre0)
+	      {
+		tokenStart.push_back( tokB);
+		tokenLen.push_back( actLen);
+	      }
+	    if (regex) tokB += pmatch[0].rm_eo; else tokB = tokE + 1;
+	  }
+	if (regex) nextE += pmatch[0].rm_eo; else nextE = tokE + 1;
+      } // for(;;)
+
+    if (regex) regfree( &regexp);
+
+    SizeT nTok = tokenStart.size();
+
+    if( !extract)
+      {    
+	dimension dim(nTok);
+	if( lengthPresent) 
+	  {
+	    e->AssureGlobalKW( lengthIx);
+	    
+	    if( nTok > 0)
+	      {
+		DLongGDL* len = new DLongGDL(dim);
+		for(int i=0; i < nTok; i++)
+		  (*len)[i] = tokenLen[i];
+
+		e->SetKW( lengthIx, len);
+	      }
+	    else
+	      {
+		e->SetKW( lengthIx, new DLongGDL( 0));
+	      }
+	  }
+	
+	if( nTok == 0) return new DLongGDL( 0);
+    
+	DLongGDL* d = new DLongGDL(dim);
+	for(int i=0; i < nTok; i++)
+	  (*d)[i] = tokenStart[i];
+	return d; 
+      } 
+
+    // EXTRACT
+    if( nTok == 0) return new DStringGDL( "");
+
+    dimension dim(nTok);
+    DStringGDL *d = new DStringGDL(dim);
+    for(int i=0; i < nTok; i++) 
+      {
+	(*d)[i] = stringIn.substr(tokenStart[i], tokenLen[i]);	
+
+	// remove escape
+	DString& act = (*d)[i];
+	long escPos = act.find_first_of( escape, 0);
+	while( escPos != string::npos)
+	  {
+	    act = act.substr( 0, escPos)+act.substr( escPos+1);
+	    escPos = act.find_first_of( escape, escPos+1);
+	  }
+      }
+    return d;
+  }
+
+  BaseGDL* getenv_fun( EnvT* e)
+  {
+    SizeT nParam=e->NParam();
+
+    static int environmentIx = e->KeywordIx( "ENVIRONMENT" );
+    bool environment = e->KeywordSet( environmentIx );
+  
+    SizeT nEnv; 
+    DStringGDL* env;
+
+    if( environment) {
+      // determine number of environment entries
+      for(nEnv = 0; environ[nEnv] != NULL  ; ++nEnv);
+
+      dimension dim( nEnv );
+      env = new DStringGDL(dim);
+
+      // copy stuff into local string array
+      for(SizeT i=0; i < nEnv ; ++i)
+        (*env)[i] = environ[i];
+
+    } else {
+
+      if(nParam != 1) 
+        e->Throw( "Incorrect number of arguments.");
+
+      DStringGDL* name = e->GetParAs<DStringGDL>(0);
+      nEnv = name->N_Elements();
+
+      env = new DStringGDL( name->Dim());
+ 
+      // copy the stuff into local string only if param found
+      char *resPtr;
+      for(SizeT i=0; i < nEnv ; ++i)
+	{
+	  // handle special environment variables
+	  // GDL_TMPDIR, IDL_TMPDIR
+	  if( (*name)[i] == "GDL_TMPDIR" || (*name)[i] == "IDL_TMPDIR")
+	    {
+	      resPtr = getenv((*name)[i].c_str());
+
+	      if( resPtr != NULL)
+		(*env)[i] = resPtr;
+	      else
+		(*env)[i] = SysVar::Dir();
+
+	      AppendIfNeeded( (*env)[i], "/");
+	    }
+	  else // normal environment variables
+	    if( (resPtr = getenv((*name)[i].c_str())) ) 
+	      (*env)[i] = resPtr;
+	}
+    }
+    
+    return env;
+  }
+
+  BaseGDL* tag_names_fun( EnvT* e)
+  {
+    SizeT nParam=e->NParam();
+    DStructGDL* struc= e->GetParAs<DStructGDL>(0);
+
+    static int structureNameIx = e->KeywordIx( "STRUCTURE_NAME" );
+    bool structureName = e->KeywordSet( structureNameIx );
+    
+    DStringGDL* tagNames;
+
+    if(structureName){
+        
+      if ((*struc).Desc()->Name() != "$truct")
+	tagNames =  new DStringGDL((*struc).Desc()->Name());
+      else
+	tagNames =  new DStringGDL("");
+
+    } else {
+      SizeT nTags = (*struc).Desc()->NTags();
+    
+      tagNames = new DStringGDL(dimension(nTags));
+      for(int i=0; i < nTags; ++i)
+        (*tagNames)[i] = (*struc).Desc()->TagName(i);
+    }
+
+    return tagNames;
+  }
+
+  BaseGDL* stregex_fun( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 2);
+    
+    DStringGDL* stringExpr= e->GetParAs<DStringGDL>(0);
+    DString pattern;
+    e->AssureStringScalarPar(1, pattern);
+
+    static int booleanIx = e->KeywordIx( "BOOLEAN" );
+    bool booleanKW = e->KeywordSet( booleanIx );
+
+    static int extractIx = e->KeywordIx( "EXTRACT" );
+    bool extractKW = e->KeywordSet( extractIx );
+
+    static int foldCaseIx = e->KeywordIx( "FOLD_CASE" );
+    bool foldCaseKW = e->KeywordSet( foldCaseIx );
+
+    //XXXpch: this is wrong, should check arg_present
+    static int lengthIx = e->KeywordIx( "LENGTH" );
+    bool lengthKW = e->KeywordSet( lengthIx );
+   
+    static int subexprIx = e->KeywordIx( "SUBEXPR" );
+    bool subexprKW = e->KeywordSet( subexprIx );
+ 
+    if( booleanKW && (subexprKW || extractKW || lengthKW))
+      e->Throw( "Conflicting keywords.");
+    //    if( subexprKW) 
+    // e->Throw( "Subexpression not yet implemented.");
+
+  
+    int nStr = stringExpr->N_Elements();
+    dimension dim = stringExpr->Dim();
+
+    DLongGDL* len;
+    if( lengthKW) {
+      e->AssureGlobalKW( lengthIx);
+      len = new DLongGDL(dim);
+    } 
+    
+    BaseGDL* result;
+
+    if( booleanKW) 
+      result = new DByteGDL(dim);
+    else if( extractKW && !subexprKW)
+      result = new DStringGDL(dim); 
+    else 
+      result = new DLongGDL(dim); 
+
+    char err_msg[MAX_REGEXPERR_LENGTH];
+
+    // set the compile flags 
+    int cflags = REG_EXTENDED;
+    if (foldCaseKW)
+      cflags |= REG_ICASE;
+    if (booleanKW)
+      cflags |= REG_NOSUB;
+
+    //    cout << pattern.c_str() << endl;
+
+    // compile the regular expression
+    regex_t regexp;
+    int compRes = regcomp( &regexp, pattern.c_str(), cflags);
+    
+    if (compRes) {
+      regerror(compRes, &regexp, err_msg, MAX_REGEXPERR_LENGTH);
+      throw GDLException(e->CallingNode(), 
+                         "STREGEX: Error processing regular expression: "+
+                         pattern+"\n           "+string(err_msg)+".");
+    }
+
+    int nmatch = 1;
+    if( subexprKW) nmatch = 16;
+
+    regmatch_t pmatch[16];
+    int eflags = 0; 
+ 
+    // now match towards the string
+    int matchres = regexec( &regexp, (*stringExpr)[0].c_str(), 
+			      nmatch, pmatch, eflags);
+
+    // subexpressions
+    if ( extractKW && subexprKW) {
+
+      // Find number of subexpressions
+      SizeT nOut = 0;
+      for( SizeT i = 0; i<nmatch; ++i) {
+	if ( pmatch[i].rm_so == -1) break;
+	nOut++;
+      }
+
+      // Loop through subexpressions & fill output array
+      dim << nOut;
+      result = new DStringGDL(dim); 
+      for( SizeT i = 0; i<nOut; ++i) {
+	(* static_cast<DStringGDL*>(result))[i] = 
+	  (*stringExpr)[0].substr( pmatch[i].rm_so, 
+				   pmatch[i].rm_eo - pmatch[i].rm_so);
+      }
+    } else {
+      if( booleanKW)
+	(* static_cast<DByteGDL*>(result)) = (matchres == 0);
+      else if ( extractKW)
+	(* static_cast<DStringGDL*>(result))[0] = 
+	  (*stringExpr)[0].substr( pmatch[0].rm_so, 
+				   pmatch[0].rm_eo - pmatch[0].rm_so);
+      else
+	(* static_cast<DLongGDL*>(result))[0] = matchres? -1:pmatch[0].rm_so;
+    }
+
+    if( lengthKW)
+      (*len)[0] = pmatch[0].rm_eo - pmatch[0].rm_so;
+
+
+    regfree( &regexp);
+
+    if( lengthKW)
+      e->SetKW( lengthIx, len);    
+
+    return result;
+  }
+
+  BaseGDL* routine_info( EnvT* e)
+  {
+    SizeT nParam=e->NParam();
+
+    static int functionsIx = e->KeywordIx( "FUNCTIONS" );
+    bool functionsKW = e->KeywordSet( functionsIx );
+    static int systemIx = e->KeywordIx( "SYSTEM" );
+    bool systemKW = e->KeywordSet( systemIx );
+    static int disabledIx = e->KeywordIx( "DISABLED" );
+    bool disabledKW = e->KeywordSet( disabledIx );
+
+    // GDL does not have disabled routines
+    if( disabledKW) return new DStringGDL("");
+
+    //    if( functionsKW || systemKW || nParam == 0)
+    //      {
+    deque<DString> subList;
+	    
+    if( functionsKW)
+      {
+	if( systemKW)
+	  {
+	    SizeT n = libFunList.size();
+	    if( n == 0) return new DStringGDL("");
+
+	    DStringGDL* res = new DStringGDL( dimension( n), BaseGDL::NOZERO);
+	    for( SizeT i = 0; i<n; ++i)
+	      (*res)[i] = libFunList[ i]->ObjectName();
+
+	    return res;
+	  }
+	else
+	  {
+	    SizeT n = funList.size();
+	    if( n == 0) return new DStringGDL("");
+	    subList.resize( n);
+		
+	    for( SizeT i = 0; i<n; ++i)
+	      subList.push_back( funList[ i]->ObjectName());
+	  }
+      }
+    else
+      {
+	if( systemKW)
+	  {
+	    SizeT n = libProList.size();
+	    if( n == 0) return new DStringGDL("");
+
+	    DStringGDL* res = new DStringGDL( dimension( n), BaseGDL::NOZERO);
+	    for( SizeT i = 0; i<n; ++i)
+	      (*res)[i] = libProList[ i]->ObjectName();
+
+	    return res;
+	  }
+	else
+	  {
+	    SizeT n = proList.size();
+	    if( n == 0) return new DStringGDL("");
+	    subList.resize( n);
+		
+	    for( SizeT i = 0; i<n; ++i)
+	      subList.push_back( proList[ i]->ObjectName());
+	  }
+      }
+	
+    sort( subList.begin(), subList.end());
+    SizeT nS = subList.size();
+
+    DStringGDL* res = new DStringGDL( dimension( nS), BaseGDL::NOZERO);
+    for( SizeT s=0; s<nS; ++s)
+      (*res)[ s] = subList[ s];
+
+    return res;
+    //      }
+  }
+
+  BaseGDL* temporary( EnvT* e)
+  {
+    SizeT nParam=e->NParam(1);
+
+    BaseGDL** p0 = &e->GetParDefined( 0);
+
+    BaseGDL* ret = *p0;
+
+    *p0 = NULL; // make parameter undefined
+    return ret;
+  }
+
+
+  inline DByte StrCmp( const string& s1, const string& s2, DLong n)
+  {
+    if( n <= 0) return 1;
+    if( s1.substr(0,n) == s2.substr(0,n)) return 1;
+    return 0;
+  }
+  inline DByte StrCmp( const string& s1, const string& s2)
+  {
+    if( s1 == s2) return 1;
+    return 0;
+  }
+  inline DByte StrCmpFold( const string& s1, const string& s2, DLong n)
+  {
+    if( n <= 0) return 1;
+    if( StrUpCase( s1.substr(0,n)) == StrUpCase(s2.substr(0,n))) return 1;
+    return 0;
+  }
+  inline DByte StrCmpFold( const string& s1, const string& s2)
+  {
+    if( StrUpCase( s1) == StrUpCase(s2)) return 1;
+    return 0;
+  }
+
+  BaseGDL* strcmp_fun( EnvT* e)
+  {
+    SizeT nParam=e->NParam(2);
+
+    DStringGDL* s0 = static_cast<DStringGDL*>( e->GetParAs< DStringGDL>( 0));
+    DStringGDL* s1 = static_cast<DStringGDL*>( e->GetParAs< DStringGDL>( 1));
+
+    DLongGDL* l2 = NULL;
+    if( nParam > 2)
+      {
+	l2 = static_cast<DLongGDL*>( e->GetParAs< DLongGDL>( 2));
+      }
+
+    static int foldIx = e->KeywordIx( "FOLD_CASE");
+    bool fold = e->KeywordSet( foldIx );
+    
+    if( s0->Scalar() && s1->Scalar())
+      {
+	if( l2 == NULL)
+	  {
+	    if( fold)
+	      return new DByteGDL( StrCmpFold( (*s0)[0], (*s1)[0]));
+	    else
+	      return new DByteGDL( StrCmp( (*s0)[0], (*s1)[0]));
+	  }
+	else
+	  {
+	    DByteGDL* res = new DByteGDL( l2->Dim(), BaseGDL::NOZERO);
+	    SizeT nEl = l2->N_Elements();
+	    if( fold)
+	      for( SizeT i=0; i<nEl; ++i)
+		(*res)[i] = StrCmpFold( (*s0)[0], (*s1)[0], (*l2)[i]);
+	    else
+	      for( SizeT i=0; i<nEl; ++i)
+		(*res)[i] = StrCmp( (*s0)[0], (*s1)[0], (*l2)[i]);
+	    return res;
+	  }
+      }
+    else // at least one array
+      {
+	if( l2 == NULL)
+	  {
+	    if( s0->Scalar())
+	      {
+		DByteGDL* res = new DByteGDL( s1->Dim(), BaseGDL::NOZERO);
+		SizeT nEl = s1->N_Elements();
+		if( fold)
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmpFold( (*s0)[0], (*s1)[i]);
+		else
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmp( (*s0)[0], (*s1)[i]);
+		return res;
+	      }
+	    else if( s1->Scalar())
+	      {
+		DByteGDL* res = new DByteGDL( s0->Dim(), BaseGDL::NOZERO);
+		SizeT nEl = s0->N_Elements();
+		if( fold)
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmpFold( (*s0)[i], (*s1)[0]);
+		else
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmp( (*s0)[i], (*s1)[0]);
+		return res;
+	      }
+	    else // both arrays
+	      {
+		DByteGDL* res;
+		SizeT    nEl;
+		if( s0->N_Elements() <= s1->N_Elements())
+		  {
+		    res = new DByteGDL( s0->Dim(), BaseGDL::NOZERO);
+		    nEl = s0->N_Elements();
+		  }
+		else		      
+		  {
+		    res = new DByteGDL( s1->Dim(), BaseGDL::NOZERO);
+		    nEl = s1->N_Elements();
+		  }
+		if( fold)
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmpFold( (*s0)[i], (*s1)[0]);
+		else
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmp( (*s0)[i], (*s1)[0]);
+		return res;
+	      }
+	  }
+	else // l2 != NULL
+	  {
+	    DByteGDL* res;
+	    SizeT    nEl;
+	    bool l2Scalar = l2->Scalar();
+	    if( s0->Scalar())
+	      {
+		if( l2Scalar || s1->N_Elements() <= l2->N_Elements())
+		  {
+		    res = new DByteGDL( s1->Dim(), BaseGDL::NOZERO);
+		    nEl = s1->N_Elements();
+		  }
+		else
+		  {
+		    res = new DByteGDL( l2->Dim(), BaseGDL::NOZERO);
+		    nEl = l2->N_Elements();
+		  }
+		if( fold)
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmpFold( (*s0)[0], (*s1)[i], (*l2)[l2Scalar?0:i]);
+		else
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmp( (*s0)[0], (*s1)[i], (*l2)[l2Scalar?0:i]);
+		return res;
+	      }
+	    else if( s1->Scalar())
+	      {
+		if( l2Scalar || s0->N_Elements() <= l2->N_Elements())
+		  {
+		    res = new DByteGDL( s0->Dim(), BaseGDL::NOZERO);
+		    nEl = s0->N_Elements();
+		  }
+		else
+		  {
+		    res = new DByteGDL( l2->Dim(), BaseGDL::NOZERO);
+		    nEl = l2->N_Elements();
+		  }
+		if( fold)
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmpFold( (*s0)[i], (*s1)[0], (*l2)[l2Scalar?0:i]);
+		else
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmp( (*s0)[i], (*s1)[0], (*l2)[l2Scalar?0:i]);
+		return res;
+	      }
+	    else // s1 and s2 are arrays
+	      {
+		if( l2Scalar)
+		  if( s0->N_Elements() <= s1->N_Elements())
+		    {
+		      res = new DByteGDL( s0->Dim(), BaseGDL::NOZERO);
+		      nEl = s0->N_Elements();
+		    }
+		  else 
+		    {
+		      res = new DByteGDL( s1->Dim(), BaseGDL::NOZERO);
+		      nEl = s1->N_Elements();
+		    }
+		else 
+		  {
+		    if( s0->N_Elements() <= s1->N_Elements())
+		      if( s0->N_Elements() <= l2->N_Elements())
+			{
+			  res = new DByteGDL( s0->Dim(), BaseGDL::NOZERO);
+			  nEl = s0->N_Elements();
+			}
+		      else
+			{
+			  res = new DByteGDL( l2->Dim(), BaseGDL::NOZERO);
+			  nEl = l2->N_Elements();
+			}
+		    else
+		      if( s1->N_Elements() <= l2->N_Elements())
+			{
+			  res = new DByteGDL( s1->Dim(), BaseGDL::NOZERO);
+			  nEl = s1->N_Elements();
+			}
+		      else
+			{
+			  res = new DByteGDL( l2->Dim(), BaseGDL::NOZERO);
+			  nEl = l2->N_Elements();
+			}
+		  }
+		if( fold)
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmpFold( (*s0)[i], (*s1)[i], (*l2)[l2Scalar?0:i]);
+		else
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmp( (*s0)[i], (*s1)[i], (*l2)[l2Scalar?0:i]);
+		return res;
+	      }
+	  }
+      }
+  }
+
+  string TagName( EnvT* e, const string& name)
+  {
+    string n = StrUpCase( name);
+    SizeT len = n.size();
+    if( n[0] != '_' && (n[0] < 'A' || n[0] > 'Z'))
+      e->Throw( "Illegal tag name: "+name+".");
+    for( SizeT i=1; i<len; ++i)
+      {
+	if( n[i] == ' ')
+	  n[i] = '_';
+	else 
+	  if( n[i] != '_' && n[i] != '$' && 
+	      (n[i] < 'A' || n[i] > 'Z') &&
+	      (n[i] < '0' || n[i] > '9'))
+	    e->Throw( "Illegal tag name: "+name+".");
+      }
+    return n;
+  }
+
+  BaseGDL* create_struct( EnvT* e)
+  {
+    static int nameIx = e->KeywordIx( "NAME" );
+    DString name = "$truct";
+    if( e->KeywordPresent( nameIx)) {
+      // Check if name exists, if not then treat as unnamed
+      if (e->GetKW( nameIx) != NULL)
+	e->AssureStringScalarKW( nameIx, name);
+    }
+
+    if( name != "$truct") // named struct
+      {
+	name = StrUpCase( name);
+	
+	SizeT nParam=e->NParam();
+
+	if( nParam == 0)
+	  {
+	    DStructDesc* desc = 
+	      e->Interpreter()->GetStruct( name, e->CallingNode());
+	   
+	    dimension dim( 1);
+	    return new DStructGDL( desc, dim);
+	  }
+
+	DStructDesc*          nStructDesc;
+	auto_ptr<DStructDesc> nStructDescGuard;
+	
+	DStructDesc* oStructDesc=
+	  FindInStructList( structList, name);
+	
+	if( oStructDesc == NULL || oStructDesc->NTags() > 0)
+	  {
+	    // not defined at all yet (-> define now)
+	    // or completely defined  (-> define now and check equality)
+	    nStructDesc= new DStructDesc( name);
+                    
+	    // guard it
+	    nStructDescGuard.reset( nStructDesc); 
+	  }
+	else
+	  {   
+	    // NTags() == 0
+	    // not completely defined (only name in list)
+	    nStructDesc= oStructDesc;
+	  }
+                
+	// the instance variable
+	// 	dimension dim( 1);
+	// 	DStructGDL* instance = new DStructGDL( nStructDesc, dim);
+	DStructGDL* instance = new DStructGDL( nStructDesc);
+	auto_ptr<DStructGDL> instance_guard(instance);
+
+	for( SizeT p=0; p<nParam; ++p)
+	  {
+	    BaseGDL* par = e->GetParDefined( p);
+	    DStructGDL* parStruct = dynamic_cast<DStructGDL*>( par);
+	    if( parStruct != NULL)
+	      {
+		// add struct
+		if( !parStruct->Scalar())
+		  e->Throw("Expression must be a scalar in this context: "+
+			   e->GetParString( p));
+		
+		DStructDesc* desc = parStruct->Desc();
+		for( SizeT t=0; t< desc->NTags(); ++t)
+		  {
+		    instance->NewTag( desc->TagName( t), 
+				      parStruct->GetTag( t)->Dup());
+		  }
+	      }
+	    else
+	      {
+		// add tag value pair
+		DStringGDL* tagNames = e->GetParAs<DStringGDL>( p);
+		SizeT nTags = tagNames->N_Elements();
+
+		SizeT tagStart = p+1;
+		SizeT tagEnd   = p+nTags;
+		if( tagEnd >= nParam)
+		  e->Throw( "Incorrect number of arguments.");
+
+		do{
+		  ++p;
+		  BaseGDL* value = e->GetParDefined( p);
+		    
+		  // add 
+		  instance->NewTag( TagName( e, (*tagNames)[ p-tagStart]),
+				    value->Dup());
+		} 
+		while( p<tagEnd);
+	      }
+	  }
+
+	if( oStructDesc != NULL)
+	  {
+	    if( oStructDesc != nStructDesc)
+	      {
+		oStructDesc->AssureIdentical(nStructDesc);
+		instance->DStructGDL::SetDesc(oStructDesc);
+		//delete nStructDesc; // auto_ptr
+	      }
+	  }
+	else
+	  {
+	    // release from guard (if not NULL)
+	    nStructDescGuard.release();
+	    // insert into struct list 
+	    structList.push_back(nStructDesc);
+	  }
+	
+	instance_guard.release();
+	return instance;
+      }
+    else 
+      { // unnamed struc
+
+	// Handle case of single structure parameter
+	SizeT nParam;
+	nParam = e->NParam();
+	BaseGDL* par = e->GetParDefined( 0);
+	DStructGDL* parStruct = dynamic_cast<DStructGDL*>( par);
+	if (nParam != 1 || parStruct == NULL)
+	  nParam=e->NParam(2);
+
+	DStructDesc*          nStructDesc = new DStructDesc( "$truct");
+	// instance takes care of nStructDesc since it is unnamed
+	// 	dimension dim( 1);
+	// 	DStructGDL* instance = new DStructGDL( nStructDesc, dim);
+	DStructGDL* instance = new DStructGDL( nStructDesc);
+	auto_ptr<DStructGDL> instance_guard(instance);
+
+	for( SizeT p=0; p<nParam;)
+	  {
+	    BaseGDL* par = e->GetParDefined( p);
+	    DStructGDL* parStruct = dynamic_cast<DStructGDL*>( par);
+	    if( parStruct != NULL)
+	      {
+		// add struct
+		if( !parStruct->Scalar())
+		  e->Throw("Expression must be a scalar in this context: "+
+			   e->GetParString( p));
+		
+		DStructDesc* desc = parStruct->Desc();
+		for( SizeT t=0; t< desc->NTags(); ++t)
+		  {
+		    instance->NewTag( desc->TagName( t), 
+				      parStruct->GetTag( t)->Dup());
+		  }
+		++p;
+	      }
+	    else
+	      {
+		// add tag value pair
+		DStringGDL* tagNames = e->GetParAs<DStringGDL>( p);
+		SizeT nTags = tagNames->N_Elements();
+
+		SizeT tagStart = p+1;
+		SizeT tagEnd   = p+nTags;
+		if( tagEnd >= nParam)
+		  e->Throw( "Incorrect number of arguments.");
+
+		for(++p; p<=tagEnd; ++p)
+		  {
+		    BaseGDL* value = e->GetParDefined( p);
+
+		    // add 
+		    instance->NewTag( TagName( e, (*tagNames)[ p-tagStart]),
+				      value->Dup());
+		  }
+	      }
+	  }
+	
+	instance_guard.release();
+	return instance;
+      }
+  }
+
+  BaseGDL* rotate( EnvT* e)
+  {
+    e->NParam(2);
+
+    BaseGDL* p0 = e->GetParDefined( 0);
+    if( p0->Rank() != 1 && p0->Rank() != 2)
+      e->Throw( "Expression must be a scalar or 1 element array in this context: "+
+		e->GetParString( 0));
+
+    if( p0->Type() == STRUCT)
+      e->Throw( "STRUCT expression not allowed in this context: "+
+		e->GetParString( 0));
+    
+    DLong dir;
+    e->AssureLongScalarPar( 1, dir);
+
+    return p0->Rotate( dir);
+  }
+
+} // namespace
+
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc2/src/gdlc.g cvs/gdl/src/gdlc.g
--- gdl-0.9rc2/src/gdlc.g	2009-01-20 12:33:55.000000000 -0700
+++ cvs/gdl/src/gdlc.g	2009-01-26 09:43:54.000000000 -0700
@@ -242,6 +242,7 @@
                 compileOpt=NONE; // reset compileOpt    
                 if( subReached) goto bailOut;
             }
+        | common_block
         )* // optional - only main program is also ok
 
         ( statement_list END! (end_unit)? )? // $MAIN$ program
Only in gdl-0.9rc2/src: gdlc.i.noopt.g
Only in gdl-0.9rc2/src: gdlc.i.opt.g
Only in gdl-0.9rc2/src: gdlc.i.rc1.g
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc2/src/gdlc.tree.g cvs/gdl/src/gdlc.tree.g
--- gdl-0.9rc2/src/gdlc.tree.g	2009-01-20 12:33:56.000000000 -0700
+++ cvs/gdl/src/gdlc.tree.g	2009-01-26 09:43:54.000000000 -0700
@@ -177,12 +177,46 @@
 
 // file parsing
 translation_unit
+{
+    bool mainStarted = false;
+}
 	: (   options {greedy=true;}: procedure_def
-		| function_def
-		| forward_function)*
-        
+    | function_def
+    | forward_function
+    |   {
+            EnvBaseT* envBefore = comp.GetEnv();
+            if( !mainStarted)
+                {
+                    comp.StartPro( "$MAIN$");                        
+                    mainStarted = true;
+                }
+            comp.ContinueMainPro();
+        }
+        common_block
+        {
+            comp.EndInteractiveStatement();
+            comp.SetEnv( envBefore);
+        }
+    )*
+    
+    (
+        {
+            if( !mainStarted)
+                {
+                    comp.StartPro( "$MAIN$");                        
+                    mainStarted = true;
+                }
+            comp.ContinueMainPro();
+        }
+        retAST:statement_list
+        {
+            comp.SetTree( #retAST);
+            comp.EndPro();
+        }
+    )?
+
         // optional main program
-        ( main_program)?
+//         ( main_program)?
         
         exception 
         catch [ GDLException& e] 
@@ -221,16 +255,6 @@
         }
   ;
 
-main_program!
-    :   {
-            comp.StartPro( "$MAIN$");
-        }
-           retAST:statement_list
-        {
-            comp.SetTree( #retAST);
-            comp.EndPro();
-        }
-    ;
 
 forward_function!
 	: #(FORWARD 
Only in gdl-0.9rc2/src: GDLInterpreter.cvs.cpp
Only in gdl-0.9rc2/src: GDLInterpreterHack.cpp
Only in gdl-0.9rc2/src: GDLInterpreter.opt.cpp.off
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc2/src/GDLParser.cpp cvs/gdl/src/GDLParser.cpp
--- gdl-0.9rc2/src/GDLParser.cpp	2009-01-20 12:33:52.000000000 -0700
+++ cvs/gdl/src/GDLParser.cpp	2009-01-26 09:43:53.000000000 -0700
@@ -743,6 +743,12 @@
 						astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 					}
 				}
+				else if ((LA(1) == COMMON) && (LA(2) == IDENTIFIER)) {
+					common_block();
+					if (inputState->guessing==0) {
+						astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+					}
+				}
 			else {
 				goto _loop4;
 			}
@@ -1156,6 +1162,89 @@
 	returnAST = function_def_AST;
 }
 
+void GDLParser::common_block() {
+	returnAST = RefDNode(antlr::nullAST);
+	antlr::ASTPair currentAST;
+	RefDNode common_block_AST = RefDNode(antlr::nullAST);
+	
+	match(COMMON);
+	RefDNode tmp11_AST = RefDNode(antlr::nullAST);
+	if ( inputState->guessing == 0 ) {
+		tmp11_AST = astFactory->create(LT(1));
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp11_AST));
+	}
+	match(IDENTIFIER);
+	{
+	switch ( LA(1)) {
+	case antlr::Token::EOF_TYPE:
+	case IDENTIFIER:
+	case BEGIN:
+	case CASE:
+	case COMMON:
+	case COMPILE_OPT:
+	case ELSE:
+	case FOR:
+	case FORWARD:
+	case FUNCTION:
+	case GOTO:
+	case IF:
+	case INHERITS:
+	case ON_IOERROR:
+	case PRO:
+	case REPEAT:
+	case SWITCH:
+	case UNTIL:
+	case WHILE:
+	case END_U:
+	case DEC:
+	case INC:
+	case LBRACE:
+	case SYSVARNAME:
+	case ASTERIX:
+	{
+		if ( inputState->guessing==0 ) {
+			common_block_AST = RefDNode(currentAST.root);
+			common_block_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(COMMONDECL,"commondecl")))->add(antlr::RefAST(common_block_AST))));
+			currentAST.root = common_block_AST;
+			if ( common_block_AST!=RefDNode(antlr::nullAST) &&
+				common_block_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+				  currentAST.child = common_block_AST->getFirstChild();
+			else
+				currentAST.child = common_block_AST;
+			currentAST.advanceChildToEnd();
+		}
+		break;
+	}
+	case COMMA:
+	{
+		match(COMMA);
+		identifier_list();
+		if (inputState->guessing==0) {
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
+		if ( inputState->guessing==0 ) {
+			common_block_AST = RefDNode(currentAST.root);
+			common_block_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(COMMONDEF,"commondef")))->add(antlr::RefAST(common_block_AST))));
+			currentAST.root = common_block_AST;
+			if ( common_block_AST!=RefDNode(antlr::nullAST) &&
+				common_block_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+				  currentAST.child = common_block_AST->getFirstChild();
+			else
+				currentAST.child = common_block_AST;
+			currentAST.advanceChildToEnd();
+		}
+		break;
+	}
+	default:
+	{
+		throw antlr::NoViableAltException(LT(1), getFilename());
+	}
+	}
+	}
+	common_block_AST = RefDNode(currentAST.root);
+	returnAST = common_block_AST;
+}
+
 void GDLParser::statement_list() {
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
@@ -1211,18 +1300,18 @@
 	switch ( LA(1)) {
 	case FUNCTION:
 	{
-		RefDNode tmp10_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp13_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp10_AST = astFactory->create(LT(1));
+			tmp13_AST = astFactory->create(LT(1));
 		}
 		match(FUNCTION);
 		break;
 	}
 	case PRO:
 	{
-		RefDNode tmp11_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp14_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp11_AST = astFactory->create(LT(1));
+			tmp14_AST = astFactory->create(LT(1));
 		}
 		match(PRO);
 		break;
@@ -1233,9 +1322,9 @@
 	}
 	}
 	}
-	RefDNode tmp12_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp15_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp12_AST = astFactory->create(LT(1));
+		tmp15_AST = astFactory->create(LT(1));
 	}
 	match(IDENTIFIER);
 	if ( inputState->guessing==0 ) {
@@ -1248,14 +1337,14 @@
 	switch ( LA(1)) {
 	case METHOD:
 	{
-		RefDNode tmp13_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp16_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp13_AST = astFactory->create(LT(1));
+			tmp16_AST = astFactory->create(LT(1));
 		}
 		match(METHOD);
-		RefDNode tmp14_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp17_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp14_AST = astFactory->create(LT(1));
+			tmp17_AST = astFactory->create(LT(1));
 		}
 		match(IDENTIFIER);
 		break;
@@ -1275,9 +1364,9 @@
 	switch ( LA(1)) {
 	case COMMA:
 	{
-		RefDNode tmp15_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp18_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp15_AST = astFactory->create(LT(1));
+			tmp18_AST = astFactory->create(LT(1));
 		}
 		match(COMMA);
 		parameter_declaration();
@@ -1304,10 +1393,10 @@
 	
 	{
 	if ((LA(1) == IDENTIFIER) && (LA(2) == COMMA || LA(2) == END_U)) {
-		RefDNode tmp16_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp19_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp16_AST = astFactory->create(LT(1));
-			astFactory->addASTChild(currentAST, antlr::RefAST(tmp16_AST));
+			tmp19_AST = astFactory->create(LT(1));
+			astFactory->addASTChild(currentAST, antlr::RefAST(tmp19_AST));
 		}
 		match(IDENTIFIER);
 	}
@@ -1328,10 +1417,10 @@
 			match(COMMA);
 			{
 			if ((LA(1) == IDENTIFIER) && (LA(2) == COMMA || LA(2) == END_U)) {
-				RefDNode tmp18_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp21_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp18_AST = astFactory->create(LT(1));
-					astFactory->addASTChild(currentAST, antlr::RefAST(tmp18_AST));
+					tmp21_AST = astFactory->create(LT(1));
+					astFactory->addASTChild(currentAST, antlr::RefAST(tmp21_AST));
 				}
 				match(IDENTIFIER);
 			}
@@ -1555,72 +1644,72 @@
 	switch ( LA(1)) {
 	case END:
 	{
-		RefDNode tmp19_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp22_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp19_AST = astFactory->create(LT(1));
+			tmp22_AST = astFactory->create(LT(1));
 		}
 		match(END);
 		break;
 	}
 	case ENDIF:
 	{
-		RefDNode tmp20_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp23_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp20_AST = astFactory->create(LT(1));
+			tmp23_AST = astFactory->create(LT(1));
 		}
 		match(ENDIF);
 		break;
 	}
 	case ENDELSE:
 	{
-		RefDNode tmp21_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp24_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp21_AST = astFactory->create(LT(1));
+			tmp24_AST = astFactory->create(LT(1));
 		}
 		match(ENDELSE);
 		break;
 	}
 	case ENDCASE:
 	{
-		RefDNode tmp22_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp25_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp22_AST = astFactory->create(LT(1));
+			tmp25_AST = astFactory->create(LT(1));
 		}
 		match(ENDCASE);
 		break;
 	}
 	case ENDSWITCH:
 	{
-		RefDNode tmp23_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp26_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp23_AST = astFactory->create(LT(1));
+			tmp26_AST = astFactory->create(LT(1));
 		}
 		match(ENDSWITCH);
 		break;
 	}
 	case ENDFOR:
 	{
-		RefDNode tmp24_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp27_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp24_AST = astFactory->create(LT(1));
+			tmp27_AST = astFactory->create(LT(1));
 		}
 		match(ENDFOR);
 		break;
 	}
 	case ENDWHILE:
 	{
-		RefDNode tmp25_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp28_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp25_AST = astFactory->create(LT(1));
+			tmp28_AST = astFactory->create(LT(1));
 		}
 		match(ENDWHILE);
 		break;
 	}
 	case ENDREP:
 	{
-		RefDNode tmp26_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp29_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp26_AST = astFactory->create(LT(1));
+			tmp29_AST = astFactory->create(LT(1));
 		}
 		match(ENDREP);
 		break;
@@ -1682,20 +1771,20 @@
 		switch ( LA(1)) {
 		case DEC:
 		{
-			RefDNode tmp30_AST = RefDNode(antlr::nullAST);
+			RefDNode tmp33_AST = RefDNode(antlr::nullAST);
 			if ( inputState->guessing == 0 ) {
-				tmp30_AST = astFactory->create(LT(1));
-				astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp30_AST));
+				tmp33_AST = astFactory->create(LT(1));
+				astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp33_AST));
 			}
 			match(DEC);
 			break;
 		}
 		case INC:
 		{
-			RefDNode tmp31_AST = RefDNode(antlr::nullAST);
+			RefDNode tmp34_AST = RefDNode(antlr::nullAST);
 			if ( inputState->guessing == 0 ) {
-				tmp31_AST = astFactory->create(LT(1));
-				astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp31_AST));
+				tmp34_AST = astFactory->create(LT(1));
+				astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp34_AST));
 			}
 			match(INC);
 			break;
@@ -1830,20 +1919,20 @@
 			switch ( LA(1)) {
 			case DEC:
 			{
-				RefDNode tmp32_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp35_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp32_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp32_AST));
+					tmp35_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp35_AST));
 				}
 				match(DEC);
 				break;
 			}
 			case INC:
 			{
-				RefDNode tmp33_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp36_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp33_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp33_AST));
+					tmp36_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp36_AST));
 				}
 				match(INC);
 				break;
@@ -1914,190 +2003,190 @@
 				switch ( LA(1)) {
 				case AND_OP_EQ:
 				{
-					RefDNode tmp35_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp38_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp35_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp35_AST));
+						tmp38_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp38_AST));
 					}
 					match(AND_OP_EQ);
 					break;
 				}
 				case ASTERIX_EQ:
 				{
-					RefDNode tmp36_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp39_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp36_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp36_AST));
+						tmp39_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp39_AST));
 					}
 					match(ASTERIX_EQ);
 					break;
 				}
 				case EQ_OP_EQ:
 				{
-					RefDNode tmp37_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp40_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp37_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp37_AST));
+						tmp40_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp40_AST));
 					}
 					match(EQ_OP_EQ);
 					break;
 				}
 				case GE_OP_EQ:
 				{
-					RefDNode tmp38_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp41_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp38_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp38_AST));
+						tmp41_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp41_AST));
 					}
 					match(GE_OP_EQ);
 					break;
 				}
 				case GTMARK_EQ:
 				{
-					RefDNode tmp39_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp42_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp39_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp39_AST));
+						tmp42_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp42_AST));
 					}
 					match(GTMARK_EQ);
 					break;
 				}
 				case GT_OP_EQ:
 				{
-					RefDNode tmp40_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp43_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp40_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp40_AST));
+						tmp43_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp43_AST));
 					}
 					match(GT_OP_EQ);
 					break;
 				}
 				case LE_OP_EQ:
 				{
-					RefDNode tmp41_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp44_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp41_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp41_AST));
+						tmp44_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp44_AST));
 					}
 					match(LE_OP_EQ);
 					break;
 				}
 				case LTMARK_EQ:
 				{
-					RefDNode tmp42_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp45_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp42_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp42_AST));
+						tmp45_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp45_AST));
 					}
 					match(LTMARK_EQ);
 					break;
 				}
 				case LT_OP_EQ:
 				{
-					RefDNode tmp43_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp46_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp43_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp43_AST));
+						tmp46_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp46_AST));
 					}
 					match(LT_OP_EQ);
 					break;
 				}
 				case MATRIX_OP1_EQ:
 				{
-					RefDNode tmp44_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp47_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp44_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp44_AST));
+						tmp47_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp47_AST));
 					}
 					match(MATRIX_OP1_EQ);
 					break;
 				}
 				case MATRIX_OP2_EQ:
 				{
-					RefDNode tmp45_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp48_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp45_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp45_AST));
+						tmp48_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp48_AST));
 					}
 					match(MATRIX_OP2_EQ);
 					break;
 				}
 				case MINUS_EQ:
 				{
-					RefDNode tmp46_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp49_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp46_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp46_AST));
+						tmp49_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp49_AST));
 					}
 					match(MINUS_EQ);
 					break;
 				}
 				case MOD_OP_EQ:
 				{
-					RefDNode tmp47_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp50_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp47_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp47_AST));
+						tmp50_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp50_AST));
 					}
 					match(MOD_OP_EQ);
 					break;
 				}
 				case NE_OP_EQ:
 				{
-					RefDNode tmp48_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp51_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp48_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp48_AST));
+						tmp51_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp51_AST));
 					}
 					match(NE_OP_EQ);
 					break;
 				}
 				case OR_OP_EQ:
 				{
-					RefDNode tmp49_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp52_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp49_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp49_AST));
+						tmp52_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp52_AST));
 					}
 					match(OR_OP_EQ);
 					break;
 				}
 				case PLUS_EQ:
 				{
-					RefDNode tmp50_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp53_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp50_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp50_AST));
+						tmp53_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp53_AST));
 					}
 					match(PLUS_EQ);
 					break;
 				}
 				case POW_EQ:
 				{
-					RefDNode tmp51_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp54_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp51_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp51_AST));
+						tmp54_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp54_AST));
 					}
 					match(POW_EQ);
 					break;
 				}
 				case SLASH_EQ:
 				{
-					RefDNode tmp52_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp55_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp52_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp52_AST));
+						tmp55_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp55_AST));
 					}
 					match(SLASH_EQ);
 					break;
 				}
 				case XOR_OP_EQ:
 				{
-					RefDNode tmp53_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp56_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp53_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp53_AST));
+						tmp56_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp56_AST));
 					}
 					match(XOR_OP_EQ);
 					break;
@@ -2121,20 +2210,20 @@
 				switch ( LA(1)) {
 				case DEC:
 				{
-					RefDNode tmp54_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp57_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp54_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp54_AST));
+						tmp57_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp57_AST));
 					}
 					match(DEC);
 					break;
 				}
 				case INC:
 				{
-					RefDNode tmp55_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp58_AST = RefDNode(antlr::nullAST);
 					if ( inputState->guessing == 0 ) {
-						tmp55_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp55_AST));
+						tmp58_AST = astFactory->create(LT(1));
+						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp58_AST));
 					}
 					match(INC);
 					break;
@@ -2220,10 +2309,10 @@
 	int numBranch=0;
 	
 	
-	RefDNode tmp57_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp60_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp57_AST = astFactory->create(LT(1));
-		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp57_AST));
+		tmp60_AST = astFactory->create(LT(1));
+		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp60_AST));
 	}
 	match(SWITCH);
 	expr();
@@ -2322,7 +2411,7 @@
 	}
 	if ( inputState->guessing==0 ) {
 		
-		tmp57_AST->SetNumBranch(numBranch);
+		tmp60_AST->SetNumBranch(numBranch);
 		
 	}
 	switch_statement_AST = RefDNode(currentAST.root);
@@ -2342,10 +2431,10 @@
 	switch ( LA(1)) {
 	case QUESTION:
 	{
-		RefDNode tmp59_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp62_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp59_AST = astFactory->create(LT(1));
-			astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp59_AST));
+			tmp62_AST = astFactory->create(LT(1));
+			astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp62_AST));
 		}
 		match(QUESTION);
 		expr();
@@ -2595,18 +2684,18 @@
 	switch ( LA(1)) {
 	case ENDSWITCH:
 	{
-		RefDNode tmp66_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp69_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp66_AST = astFactory->create(LT(1));
+			tmp69_AST = astFactory->create(LT(1));
 		}
 		match(ENDSWITCH);
 		break;
 	}
 	case END:
 	{
-		RefDNode tmp67_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp70_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp67_AST = astFactory->create(LT(1));
+			tmp70_AST = astFactory->create(LT(1));
 		}
 		match(END);
 		break;
@@ -2633,9 +2722,9 @@
 	}
 	case ENDELSE:
 	{
-		RefDNode tmp68_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp71_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp68_AST = astFactory->create(LT(1));
+			tmp71_AST = astFactory->create(LT(1));
 		}
 		match(ENDELSE);
 		break;
@@ -2656,10 +2745,10 @@
 	int numBranch=0;
 	
 	
-	RefDNode tmp69_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp72_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp69_AST = astFactory->create(LT(1));
-		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp69_AST));
+		tmp72_AST = astFactory->create(LT(1));
+		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp72_AST));
 	}
 	match(CASE);
 	expr();
@@ -2758,7 +2847,7 @@
 	}
 	if ( inputState->guessing==0 ) {
 		
-		tmp69_AST->SetNumBranch(numBranch);
+		tmp72_AST->SetNumBranch(numBranch);
 		
 	}
 	case_statement_AST = RefDNode(currentAST.root);
@@ -2976,18 +3065,18 @@
 	switch ( LA(1)) {
 	case ENDCASE:
 	{
-		RefDNode tmp76_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp79_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp76_AST = astFactory->create(LT(1));
+			tmp79_AST = astFactory->create(LT(1));
 		}
 		match(ENDCASE);
 		break;
 	}
 	case END:
 	{
-		RefDNode tmp77_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp80_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp77_AST = astFactory->create(LT(1));
+			tmp80_AST = astFactory->create(LT(1));
 		}
 		match(END);
 		break;
@@ -3014,9 +3103,9 @@
 	}
 	case ENDELSE:
 	{
-		RefDNode tmp78_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp81_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp78_AST = astFactory->create(LT(1));
+			tmp81_AST = astFactory->create(LT(1));
 		}
 		match(ENDELSE);
 		break;
@@ -3034,20 +3123,20 @@
 	antlr::ASTPair currentAST;
 	RefDNode identifier_list_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode tmp79_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp82_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp79_AST = astFactory->create(LT(1));
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp79_AST));
+		tmp82_AST = astFactory->create(LT(1));
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp82_AST));
 	}
 	match(IDENTIFIER);
 	{ // ( ... )*
 	for (;;) {
 		if ((LA(1) == COMMA)) {
 			match(COMMA);
-			RefDNode tmp81_AST = RefDNode(antlr::nullAST);
+			RefDNode tmp84_AST = RefDNode(antlr::nullAST);
 			if ( inputState->guessing == 0 ) {
-				tmp81_AST = astFactory->create(LT(1));
-				astFactory->addASTChild(currentAST, antlr::RefAST(tmp81_AST));
+				tmp84_AST = astFactory->create(LT(1));
+				astFactory->addASTChild(currentAST, antlr::RefAST(tmp84_AST));
 			}
 			match(IDENTIFIER);
 		}
@@ -3067,17 +3156,17 @@
 	antlr::ASTPair currentAST;
 	RefDNode keyword_declaration_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode tmp82_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp85_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp82_AST = astFactory->create(LT(1));
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp82_AST));
+		tmp85_AST = astFactory->create(LT(1));
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp85_AST));
 	}
 	match(IDENTIFIER);
 	match(EQUAL);
-	RefDNode tmp84_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp87_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp84_AST = astFactory->create(LT(1));
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp84_AST));
+		tmp87_AST = astFactory->create(LT(1));
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp87_AST));
 	}
 	match(IDENTIFIER);
 	if ( inputState->guessing==0 ) {
@@ -3150,9 +3239,9 @@
 	antlr::RefToken  ii = antlr::nullToken;
 	RefDNode ii_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode tmp85_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp88_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp85_AST = astFactory->create(LT(1));
+		tmp88_AST = astFactory->create(LT(1));
 	}
 	match(COMPILE_OPT);
 	i = LT(1);
@@ -3168,9 +3257,9 @@
 	{ // ( ... )*
 	for (;;) {
 		if ((LA(1) == COMMA)) {
-			RefDNode tmp86_AST = RefDNode(antlr::nullAST);
+			RefDNode tmp89_AST = RefDNode(antlr::nullAST);
 			if ( inputState->guessing == 0 ) {
-				tmp86_AST = astFactory->create(LT(1));
+				tmp89_AST = astFactory->create(LT(1));
 			}
 			match(COMMA);
 			ii = LT(1);
@@ -3194,67 +3283,6 @@
 	returnAST = compile_opt_AST;
 }
 
-void GDLParser::common_block() {
-	returnAST = RefDNode(antlr::nullAST);
-	antlr::ASTPair currentAST;
-	RefDNode common_block_AST = RefDNode(antlr::nullAST);
-	
-	match(COMMON);
-	RefDNode tmp88_AST = RefDNode(antlr::nullAST);
-	if ( inputState->guessing == 0 ) {
-		tmp88_AST = astFactory->create(LT(1));
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp88_AST));
-	}
-	match(IDENTIFIER);
-	{
-	switch ( LA(1)) {
-	case ELSE:
-	case UNTIL:
-	case END_U:
-	{
-		if ( inputState->guessing==0 ) {
-			common_block_AST = RefDNode(currentAST.root);
-			common_block_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(COMMONDECL,"commondecl")))->add(antlr::RefAST(common_block_AST))));
-			currentAST.root = common_block_AST;
-			if ( common_block_AST!=RefDNode(antlr::nullAST) &&
-				common_block_AST->getFirstChild() != RefDNode(antlr::nullAST) )
-				  currentAST.child = common_block_AST->getFirstChild();
-			else
-				currentAST.child = common_block_AST;
-			currentAST.advanceChildToEnd();
-		}
-		break;
-	}
-	case COMMA:
-	{
-		match(COMMA);
-		identifier_list();
-		if (inputState->guessing==0) {
-			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		}
-		if ( inputState->guessing==0 ) {
-			common_block_AST = RefDNode(currentAST.root);
-			common_block_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(COMMONDEF,"commondef")))->add(antlr::RefAST(common_block_AST))));
-			currentAST.root = common_block_AST;
-			if ( common_block_AST!=RefDNode(antlr::nullAST) &&
-				common_block_AST->getFirstChild() != RefDNode(antlr::nullAST) )
-				  currentAST.child = common_block_AST->getFirstChild();
-			else
-				currentAST.child = common_block_AST;
-			currentAST.advanceChildToEnd();
-		}
-		break;
-	}
-	default:
-	{
-		throw antlr::NoViableAltException(LT(1), getFilename());
-	}
-	}
-	}
-	common_block_AST = RefDNode(currentAST.root);
-	returnAST = common_block_AST;
-}
-
 void GDLParser::endfor_mark() {
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc2/src/GDLParser.hpp cvs/gdl/src/GDLParser.hpp
--- gdl-0.9rc2/src/GDLParser.hpp	2009-01-20 12:33:51.000000000 -0700
+++ cvs/gdl/src/GDLParser.hpp	2009-01-26 09:43:53.000000000 -0700
@@ -98,6 +98,7 @@
 	public: void forward_function();
 	public: void procedure_def();
 	public: void function_def();
+	public: void common_block();
 	public: void statement_list();
 	public: void interactive_compile();
 	public: void parameter_declaration();
@@ -118,7 +119,6 @@
 	public: void keyword_declaration();
 	public: std::string  object_name();
 	public: void compile_opt();
-	public: void common_block();
 	public: void endfor_mark();
 	public: void endrep_mark();
 	public: void endwhile_mark();
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc2/src/GDLTreeParser.cpp cvs/gdl/src/GDLTreeParser.cpp
--- gdl-0.9rc2/src/GDLTreeParser.cpp	2009-01-20 12:33:54.000000000 -0700
+++ cvs/gdl/src/GDLTreeParser.cpp	2009-01-26 09:43:54.000000000 -0700
@@ -28,6 +28,11 @@
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
 	RefDNode translation_unit_AST = RefDNode(antlr::nullAST);
+	RefDNode retAST_AST = RefDNode(antlr::nullAST);
+	RefDNode retAST = RefDNode(antlr::nullAST);
+	
+	bool mainStarted = false;
+	
 	
 	try {      // for error handling
 		{ // ( ... )*
@@ -57,6 +62,24 @@
 					_t = _retTree;
 					astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 				}
+				else if ((_t->getType() == COMMONDECL || _t->getType() == COMMONDEF)) {
+					
+					EnvBaseT* envBefore = comp.GetEnv();
+					if( !mainStarted)
+					{
+					comp.StartPro( "$MAIN$");                        
+					mainStarted = true;
+					}
+					comp.ContinueMainPro();
+					
+					common_block(_t);
+					_t = _retTree;
+					astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+					
+					comp.EndInteractiveStatement();
+					comp.SetEnv( envBefore);
+					
+				}
 			else {
 				goto _loop3;
 			}
@@ -110,9 +133,23 @@
 		case SLASH_EQ:
 		case XOR_OP_EQ:
 		{
-			main_program(_t);
+			
+			if( !mainStarted)
+			{
+			comp.StartPro( "$MAIN$");                        
+			mainStarted = true;
+			}
+			comp.ContinueMainPro();
+			
+			retAST = (_t == ASTNULL) ? RefDNode(antlr::nullAST) : _t;
+			statement_list(_t);
 			_t = _retTree;
+			retAST_AST = returnAST;
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+			
+			comp.SetTree( retAST_AST);
+			comp.EndPro();
+			
 			break;
 		}
 		case 3:
@@ -158,12 +195,12 @@
 	RefDNode obj = RefDNode(antlr::nullAST);
 	RefDNode obj_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode __t20 = _t;
+	RefDNode __t19 = _t;
 	RefDNode tmp1_AST = RefDNode(antlr::nullAST);
 	RefDNode tmp1_AST_in = RefDNode(antlr::nullAST);
 	tmp1_AST = astFactory->create(antlr::RefAST(_t));
 	tmp1_AST_in = _t;
-	antlr::ASTPair __currentAST20 = currentAST;
+	antlr::ASTPair __currentAST19 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),PRO);
@@ -377,8 +414,8 @@
 	
 	comp.EndPro();
 	
-	currentAST = __currentAST20;
-	_t = __t20;
+	currentAST = __currentAST19;
+	_t = __t19;
 	_t = _t->getNextSibling();
 	returnAST = procedure_def_AST;
 	_retTree = _t;
@@ -394,12 +431,12 @@
 	RefDNode obj = RefDNode(antlr::nullAST);
 	RefDNode obj_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode __t25 = _t;
+	RefDNode __t24 = _t;
 	RefDNode tmp3_AST = RefDNode(antlr::nullAST);
 	RefDNode tmp3_AST_in = RefDNode(antlr::nullAST);
 	tmp3_AST = astFactory->create(antlr::RefAST(_t));
 	tmp3_AST_in = _t;
-	antlr::ASTPair __currentAST25 = currentAST;
+	antlr::ASTPair __currentAST24 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),FUNCTION);
@@ -613,8 +650,8 @@
 	
 	comp.EndFun();
 	
-	currentAST = __currentAST25;
-	_t = __t25;
+	currentAST = __currentAST24;
+	_t = __t24;
 	_t = _t->getNextSibling();
 	returnAST = function_def_AST;
 	_retTree = _t;
@@ -628,18 +665,18 @@
 	RefDNode id = RefDNode(antlr::nullAST);
 	RefDNode id_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode __t10 = _t;
+	RefDNode __t9 = _t;
 	RefDNode tmp5_AST = RefDNode(antlr::nullAST);
 	RefDNode tmp5_AST_in = RefDNode(antlr::nullAST);
 	tmp5_AST = astFactory->create(antlr::RefAST(_t));
 	tmp5_AST_in = _t;
-	antlr::ASTPair __currentAST10 = currentAST;
+	antlr::ASTPair __currentAST9 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),FORWARD);
 	_t = _t->getFirstChild();
 	{ // ( ... )+
-	int _cnt12=0;
+	int _cnt11=0;
 	for (;;) {
 		if (_t == RefDNode(antlr::nullAST) )
 			_t = ASTNULL;
@@ -654,40 +691,193 @@
 					
 		}
 		else {
-			if ( _cnt12>=1 ) { goto _loop12; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+			if ( _cnt11>=1 ) { goto _loop11; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 		}
 		
-		_cnt12++;
+		_cnt11++;
 	}
-	_loop12:;
+	_loop11:;
 	}  // ( ... )+
-	currentAST = __currentAST10;
-	_t = __t10;
+	currentAST = __currentAST9;
+	_t = __t9;
 	_t = _t->getNextSibling();
 	returnAST = forward_function_AST;
 	_retTree = _t;
 }
 
-void GDLTreeParser::main_program(RefDNode _t) {
-	RefDNode main_program_AST_in = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
+void GDLTreeParser::common_block(RefDNode _t) {
+	RefDNode common_block_AST_in = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
-	RefDNode main_program_AST = RefDNode(antlr::nullAST);
-	RefDNode retAST_AST = RefDNode(antlr::nullAST);
-	RefDNode retAST = RefDNode(antlr::nullAST);
-	
-	
-	comp.StartPro( "$MAIN$");
-	
-	retAST = (_t == ASTNULL) ? RefDNode(antlr::nullAST) : _t;
-	statement_list(_t);
-	_t = _retTree;
-	retAST_AST = returnAST;
+	RefDNode common_block_AST = RefDNode(antlr::nullAST);
+	RefDNode id = RefDNode(antlr::nullAST);
+	RefDNode id_AST = RefDNode(antlr::nullAST);
+	RefDNode cv = RefDNode(antlr::nullAST);
+	RefDNode cv_AST = RefDNode(antlr::nullAST);
+	RefDNode id2 = RefDNode(antlr::nullAST);
+	RefDNode id2_AST = RefDNode(antlr::nullAST);
 	
-	comp.SetTree( retAST_AST);
-	comp.EndPro();
+	if (_t == RefDNode(antlr::nullAST) )
+		_t = ASTNULL;
+	switch ( _t->getType()) {
+	case COMMONDEF:
+	{
+		RefDNode __t29 = _t;
+		RefDNode tmp6_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp6_AST_in = RefDNode(antlr::nullAST);
+		tmp6_AST = astFactory->create(antlr::RefAST(_t));
+		tmp6_AST_in = _t;
+		antlr::ASTPair __currentAST29 = currentAST;
+		currentAST.root = currentAST.child;
+		currentAST.child = RefDNode(antlr::nullAST);
+		match(antlr::RefAST(_t),COMMONDEF);
+		_t = _t->getFirstChild();
+		id = _t;
+		RefDNode id_AST_in = RefDNode(antlr::nullAST);
+		id_AST = astFactory->create(antlr::RefAST(id));
+		match(antlr::RefAST(_t),IDENTIFIER);
+		_t = _t->getNextSibling();
+		
+				DCommonBase* actCommon=comp.CommonDef(id->getText());
+			
+		{ // ( ... )+
+		int _cnt31=0;
+		for (;;) {
+			if (_t == RefDNode(antlr::nullAST) )
+				_t = ASTNULL;
+			if ((_t->getType() == IDENTIFIER)) {
+				cv = _t;
+				RefDNode cv_AST_in = RefDNode(antlr::nullAST);
+				cv_AST = astFactory->create(antlr::RefAST(cv));
+				match(antlr::RefAST(_t),IDENTIFIER);
+				_t = _t->getNextSibling();
+				
+						  comp.CommonVar(actCommon,cv->getText());
+						
+			}
+			else {
+				if ( _cnt31>=1 ) { goto _loop31; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+			}
+			
+			_cnt31++;
+		}
+		_loop31:;
+		}  // ( ... )+
+		currentAST = __currentAST29;
+		_t = __t29;
+		_t = _t->getNextSibling();
+		break;
+	}
+	case COMMONDECL:
+	{
+		RefDNode __t32 = _t;
+		RefDNode tmp7_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp7_AST_in = RefDNode(antlr::nullAST);
+		tmp7_AST = astFactory->create(antlr::RefAST(_t));
+		tmp7_AST_in = _t;
+		antlr::ASTPair __currentAST32 = currentAST;
+		currentAST.root = currentAST.child;
+		currentAST.child = RefDNode(antlr::nullAST);
+		match(antlr::RefAST(_t),COMMONDECL);
+		_t = _t->getFirstChild();
+		id2 = _t;
+		RefDNode id2_AST_in = RefDNode(antlr::nullAST);
+		id2_AST = astFactory->create(antlr::RefAST(id2));
+		match(antlr::RefAST(_t),IDENTIFIER);
+		_t = _t->getNextSibling();
+		
+				comp.CommonDecl(id2->getText());
+			
+		currentAST = __currentAST32;
+		_t = __t32;
+		_t = _t->getNextSibling();
+		break;
+	}
+	default:
+	{
+		throw antlr::NoViableAltException(antlr::RefAST(_t));
+	}
+	}
+	returnAST = common_block_AST;
+	_retTree = _t;
+}
+
+void GDLTreeParser::statement_list(RefDNode _t) {
+	RefDNode statement_list_AST_in = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
+	returnAST = RefDNode(antlr::nullAST);
+	antlr::ASTPair currentAST;
+	RefDNode statement_list_AST = RefDNode(antlr::nullAST);
 	
-	returnAST = main_program_AST;
+	{ // ( ... )+
+	int _cnt54=0;
+	for (;;) {
+		if (_t == RefDNode(antlr::nullAST) )
+			_t = ASTNULL;
+		switch ( _t->getType()) {
+		case ASSIGN:
+		case BLOCK:
+		case BREAK:
+		case CONTINUE:
+		case COMMONDECL:
+		case COMMONDEF:
+		case MPCALL:
+		case MPCALL_PARENT:
+		case PCALL:
+		case RETURN:
+		case CASE:
+		case FOR:
+		case FORWARD:
+		case GOTO:
+		case IF:
+		case ON_IOERROR:
+		case REPEAT:
+		case SWITCH:
+		case WHILE:
+		case DEC:
+		case INC:
+		case AND_OP_EQ:
+		case ASTERIX_EQ:
+		case EQ_OP_EQ:
+		case GE_OP_EQ:
+		case GTMARK_EQ:
+		case GT_OP_EQ:
+		case LE_OP_EQ:
+		case LTMARK_EQ:
+		case LT_OP_EQ:
+		case MATRIX_OP1_EQ:
+		case MATRIX_OP2_EQ:
+		case MINUS_EQ:
+		case MOD_OP_EQ:
+		case NE_OP_EQ:
+		case OR_OP_EQ:
+		case PLUS_EQ:
+		case POW_EQ:
+		case SLASH_EQ:
+		case XOR_OP_EQ:
+		{
+			statement(_t);
+			_t = _retTree;
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+			break;
+		}
+		case IDENTIFIER:
+		{
+			label(_t);
+			_t = _retTree;
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+			break;
+		}
+		default:
+		{
+			if ( _cnt54>=1 ) { goto _loop54; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+		}
+		}
+		_cnt54++;
+	}
+	_loop54:;
+	}  // ( ... )+
+	statement_list_AST = RefDNode(currentAST.root);
+	returnAST = statement_list_AST;
 	_retTree = _t;
 }
 
@@ -878,13 +1068,13 @@
 	}
 	case DEC:
 	{
-		RefDNode __t57 = _t;
-		RefDNode tmp6_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp6_AST_in = RefDNode(antlr::nullAST);
-		tmp6_AST = astFactory->create(antlr::RefAST(_t));
-		tmp6_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp6_AST));
-		antlr::ASTPair __currentAST57 = currentAST;
+		RefDNode __t56 = _t;
+		RefDNode tmp8_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp8_AST_in = RefDNode(antlr::nullAST);
+		tmp8_AST = astFactory->create(antlr::RefAST(_t));
+		tmp8_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp8_AST));
+		antlr::ASTPair __currentAST56 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),DEC);
@@ -892,21 +1082,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST57;
-		_t = __t57;
+		currentAST = __currentAST56;
+		_t = __t56;
 		_t = _t->getNextSibling();
 		statement_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case INC:
 	{
-		RefDNode __t58 = _t;
-		RefDNode tmp7_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp7_AST_in = RefDNode(antlr::nullAST);
-		tmp7_AST = astFactory->create(antlr::RefAST(_t));
-		tmp7_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp7_AST));
-		antlr::ASTPair __currentAST58 = currentAST;
+		RefDNode __t57 = _t;
+		RefDNode tmp9_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp9_AST_in = RefDNode(antlr::nullAST);
+		tmp9_AST = astFactory->create(antlr::RefAST(_t));
+		tmp9_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp9_AST));
+		antlr::ASTPair __currentAST57 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),INC);
@@ -914,19 +1104,19 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST58;
-		_t = __t58;
+		currentAST = __currentAST57;
+		_t = __t57;
 		_t = _t->getNextSibling();
 		statement_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case BREAK:
 	{
-		RefDNode tmp8_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp8_AST_in = RefDNode(antlr::nullAST);
-		tmp8_AST = astFactory->create(antlr::RefAST(_t));
-		tmp8_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp8_AST));
+		RefDNode tmp10_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp10_AST_in = RefDNode(antlr::nullAST);
+		tmp10_AST = astFactory->create(antlr::RefAST(_t));
+		tmp10_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp10_AST));
 		match(antlr::RefAST(_t),BREAK);
 		_t = _t->getNextSibling();
 		statement_AST = RefDNode(currentAST.root);
@@ -934,11 +1124,11 @@
 	}
 	case CONTINUE:
 	{
-		RefDNode tmp9_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp9_AST_in = RefDNode(antlr::nullAST);
-		tmp9_AST = astFactory->create(antlr::RefAST(_t));
-		tmp9_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp9_AST));
+		RefDNode tmp11_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp11_AST_in = RefDNode(antlr::nullAST);
+		tmp11_AST = astFactory->create(antlr::RefAST(_t));
+		tmp11_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp11_AST));
 		match(antlr::RefAST(_t),CONTINUE);
 		_t = _t->getNextSibling();
 		statement_AST = RefDNode(currentAST.root);
@@ -953,85 +1143,6 @@
 	_retTree = _t;
 }
 
-void GDLTreeParser::statement_list(RefDNode _t) {
-	RefDNode statement_list_AST_in = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
-	returnAST = RefDNode(antlr::nullAST);
-	antlr::ASTPair currentAST;
-	RefDNode statement_list_AST = RefDNode(antlr::nullAST);
-	
-	{ // ( ... )+
-	int _cnt55=0;
-	for (;;) {
-		if (_t == RefDNode(antlr::nullAST) )
-			_t = ASTNULL;
-		switch ( _t->getType()) {
-		case ASSIGN:
-		case BLOCK:
-		case BREAK:
-		case CONTINUE:
-		case COMMONDECL:
-		case COMMONDEF:
-		case MPCALL:
-		case MPCALL_PARENT:
-		case PCALL:
-		case RETURN:
-		case CASE:
-		case FOR:
-		case FORWARD:
-		case GOTO:
-		case IF:
-		case ON_IOERROR:
-		case REPEAT:
-		case SWITCH:
-		case WHILE:
-		case DEC:
-		case INC:
-		case AND_OP_EQ:
-		case ASTERIX_EQ:
-		case EQ_OP_EQ:
-		case GE_OP_EQ:
-		case GTMARK_EQ:
-		case GT_OP_EQ:
-		case LE_OP_EQ:
-		case LTMARK_EQ:
-		case LT_OP_EQ:
-		case MATRIX_OP1_EQ:
-		case MATRIX_OP2_EQ:
-		case MINUS_EQ:
-		case MOD_OP_EQ:
-		case NE_OP_EQ:
-		case OR_OP_EQ:
-		case PLUS_EQ:
-		case POW_EQ:
-		case SLASH_EQ:
-		case XOR_OP_EQ:
-		{
-			statement(_t);
-			_t = _retTree;
-			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-			break;
-		}
-		case IDENTIFIER:
-		{
-			label(_t);
-			_t = _retTree;
-			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-			break;
-		}
-		default:
-		{
-			if ( _cnt55>=1 ) { goto _loop55; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
-		}
-		}
-		_cnt55++;
-	}
-	_loop55:;
-	}  // ( ... )+
-	statement_list_AST = RefDNode(currentAST.root);
-	returnAST = statement_list_AST;
-	_retTree = _t;
-}
-
 void GDLTreeParser::parameter_declaration(RefDNode _t) {
 	RefDNode parameter_declaration_AST_in = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	returnAST = RefDNode(antlr::nullAST);
@@ -1040,18 +1151,18 @@
 	RefDNode id = RefDNode(antlr::nullAST);
 	RefDNode id_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode __t14 = _t;
-	RefDNode tmp10_AST = RefDNode(antlr::nullAST);
-	RefDNode tmp10_AST_in = RefDNode(antlr::nullAST);
-	tmp10_AST = astFactory->create(antlr::RefAST(_t));
-	tmp10_AST_in = _t;
-	antlr::ASTPair __currentAST14 = currentAST;
+	RefDNode __t13 = _t;
+	RefDNode tmp12_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp12_AST_in = RefDNode(antlr::nullAST);
+	tmp12_AST = astFactory->create(antlr::RefAST(_t));
+	tmp12_AST_in = _t;
+	antlr::ASTPair __currentAST13 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),PARADECL);
 	_t = _t->getFirstChild();
 	{ // ( ... )+
-	int _cnt16=0;
+	int _cnt15=0;
 	for (;;) {
 		if (_t == RefDNode(antlr::nullAST) )
 			_t = ASTNULL;
@@ -1076,15 +1187,15 @@
 		}
 		default:
 		{
-			if ( _cnt16>=1 ) { goto _loop16; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+			if ( _cnt15>=1 ) { goto _loop15; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 		}
 		}
-		_cnt16++;
+		_cnt15++;
 	}
-	_loop16:;
+	_loop15:;
 	}  // ( ... )+
-	currentAST = __currentAST14;
-	_t = __t14;
+	currentAST = __currentAST13;
+	_t = __t13;
 	_t = _t->getNextSibling();
 	returnAST = parameter_declaration_AST;
 	_retTree = _t;
@@ -1100,12 +1211,12 @@
 	RefDNode val = RefDNode(antlr::nullAST);
 	RefDNode val_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode __t18 = _t;
-	RefDNode tmp11_AST = RefDNode(antlr::nullAST);
-	RefDNode tmp11_AST_in = RefDNode(antlr::nullAST);
-	tmp11_AST = astFactory->create(antlr::RefAST(_t));
-	tmp11_AST_in = _t;
-	antlr::ASTPair __currentAST18 = currentAST;
+	RefDNode __t17 = _t;
+	RefDNode tmp13_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp13_AST_in = RefDNode(antlr::nullAST);
+	tmp13_AST = astFactory->create(antlr::RefAST(_t));
+	tmp13_AST_in = _t;
+	antlr::ASTPair __currentAST17 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),KEYDECL);
@@ -1120,8 +1231,8 @@
 	val_AST = astFactory->create(antlr::RefAST(val));
 	match(antlr::RefAST(_t),IDENTIFIER);
 	_t = _t->getNextSibling();
-	currentAST = __currentAST18;
-	_t = __t18;
+	currentAST = __currentAST17;
+	_t = __t17;
 	_t = _t->getNextSibling();
 	
 		  comp.AddKey(key->getText(),val->getText());
@@ -1130,103 +1241,6 @@
 	_retTree = _t;
 }
 
-void GDLTreeParser::common_block(RefDNode _t) {
-	RefDNode common_block_AST_in = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
-	returnAST = RefDNode(antlr::nullAST);
-	antlr::ASTPair currentAST;
-	RefDNode common_block_AST = RefDNode(antlr::nullAST);
-	RefDNode id = RefDNode(antlr::nullAST);
-	RefDNode id_AST = RefDNode(antlr::nullAST);
-	RefDNode cv = RefDNode(antlr::nullAST);
-	RefDNode cv_AST = RefDNode(antlr::nullAST);
-	RefDNode id2 = RefDNode(antlr::nullAST);
-	RefDNode id2_AST = RefDNode(antlr::nullAST);
-	
-	if (_t == RefDNode(antlr::nullAST) )
-		_t = ASTNULL;
-	switch ( _t->getType()) {
-	case COMMONDEF:
-	{
-		RefDNode __t30 = _t;
-		RefDNode tmp12_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp12_AST_in = RefDNode(antlr::nullAST);
-		tmp12_AST = astFactory->create(antlr::RefAST(_t));
-		tmp12_AST_in = _t;
-		antlr::ASTPair __currentAST30 = currentAST;
-		currentAST.root = currentAST.child;
-		currentAST.child = RefDNode(antlr::nullAST);
-		match(antlr::RefAST(_t),COMMONDEF);
-		_t = _t->getFirstChild();
-		id = _t;
-		RefDNode id_AST_in = RefDNode(antlr::nullAST);
-		id_AST = astFactory->create(antlr::RefAST(id));
-		match(antlr::RefAST(_t),IDENTIFIER);
-		_t = _t->getNextSibling();
-		
-				DCommonBase* actCommon=comp.CommonDef(id->getText());
-			
-		{ // ( ... )+
-		int _cnt32=0;
-		for (;;) {
-			if (_t == RefDNode(antlr::nullAST) )
-				_t = ASTNULL;
-			if ((_t->getType() == IDENTIFIER)) {
-				cv = _t;
-				RefDNode cv_AST_in = RefDNode(antlr::nullAST);
-				cv_AST = astFactory->create(antlr::RefAST(cv));
-				match(antlr::RefAST(_t),IDENTIFIER);
-				_t = _t->getNextSibling();
-				
-						  comp.CommonVar(actCommon,cv->getText());
-						
-			}
-			else {
-				if ( _cnt32>=1 ) { goto _loop32; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
-			}
-			
-			_cnt32++;
-		}
-		_loop32:;
-		}  // ( ... )+
-		currentAST = __currentAST30;
-		_t = __t30;
-		_t = _t->getNextSibling();
-		break;
-	}
-	case COMMONDECL:
-	{
-		RefDNode __t33 = _t;
-		RefDNode tmp13_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp13_AST_in = RefDNode(antlr::nullAST);
-		tmp13_AST = astFactory->create(antlr::RefAST(_t));
-		tmp13_AST_in = _t;
-		antlr::ASTPair __currentAST33 = currentAST;
-		currentAST.root = currentAST.child;
-		currentAST.child = RefDNode(antlr::nullAST);
-		match(antlr::RefAST(_t),COMMONDECL);
-		_t = _t->getFirstChild();
-		id2 = _t;
-		RefDNode id2_AST_in = RefDNode(antlr::nullAST);
-		id2_AST = astFactory->create(antlr::RefAST(id2));
-		match(antlr::RefAST(_t),IDENTIFIER);
-		_t = _t->getNextSibling();
-		
-				comp.CommonDecl(id2->getText());
-			
-		currentAST = __currentAST33;
-		_t = __t33;
-		_t = _t->getNextSibling();
-		break;
-	}
-	default:
-	{
-		throw antlr::NoViableAltException(antlr::RefAST(_t));
-	}
-	}
-	returnAST = common_block_AST;
-	_retTree = _t;
-}
-
 void GDLTreeParser::caseswitch_body(RefDNode _t) {
 	RefDNode caseswitch_body_AST_in = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	returnAST = RefDNode(antlr::nullAST);
@@ -1238,13 +1252,13 @@
 	switch ( _t->getType()) {
 	case BLOCK:
 	{
-		RefDNode __t35 = _t;
+		RefDNode __t34 = _t;
 		RefDNode tmp14_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp14_AST_in = RefDNode(antlr::nullAST);
 		tmp14_AST = astFactory->create(antlr::RefAST(_t));
 		tmp14_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp14_AST));
-		antlr::ASTPair __currentAST35 = currentAST;
+		antlr::ASTPair __currentAST34 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),BLOCK);
@@ -1313,21 +1327,21 @@
 		}
 		}
 		}
-		currentAST = __currentAST35;
-		_t = __t35;
+		currentAST = __currentAST34;
+		_t = __t34;
 		_t = _t->getNextSibling();
 		caseswitch_body_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case ELSEBLK:
 	{
-		RefDNode __t37 = _t;
+		RefDNode __t36 = _t;
 		RefDNode tmp15_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp15_AST_in = RefDNode(antlr::nullAST);
 		tmp15_AST = astFactory->create(antlr::RefAST(_t));
 		tmp15_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp15_AST));
-		antlr::ASTPair __currentAST37 = currentAST;
+		antlr::ASTPair __currentAST36 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ELSEBLK);
@@ -1393,8 +1407,8 @@
 		}
 		}
 		}
-		currentAST = __currentAST37;
-		_t = __t37;
+		currentAST = __currentAST36;
+		_t = __t36;
 		_t = _t->getNextSibling();
 		caseswitch_body_AST = RefDNode(currentAST.root);
 		break;
@@ -1430,13 +1444,13 @@
 	}
 	case DOT:
 	{
-		RefDNode __t210 = _t;
+		RefDNode __t209 = _t;
 		RefDNode tmp16_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp16_AST_in = RefDNode(antlr::nullAST);
 		tmp16_AST = astFactory->create(antlr::RefAST(_t));
 		tmp16_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp16_AST));
-		antlr::ASTPair __currentAST210 = currentAST;
+		antlr::ASTPair __currentAST209 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),DOT);
@@ -1445,7 +1459,7 @@
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 		{ // ( ... )+
-		int _cnt212=0;
+		int _cnt211=0;
 		for (;;) {
 			if (_t == RefDNode(antlr::nullAST) )
 				_t = ASTNULL;
@@ -1455,28 +1469,28 @@
 				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 			}
 			else {
-				if ( _cnt212>=1 ) { goto _loop212; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+				if ( _cnt211>=1 ) { goto _loop211; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 			}
 			
-			_cnt212++;
+			_cnt211++;
 		}
-		_loop212:;
+		_loop211:;
 		}  // ( ... )+
-		currentAST = __currentAST210;
-		_t = __t210;
+		currentAST = __currentAST209;
+		_t = __t209;
 		_t = _t->getNextSibling();
 		expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case DEREF:
 	{
-		RefDNode __t213 = _t;
+		RefDNode __t212 = _t;
 		RefDNode tmp17_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp17_AST_in = RefDNode(antlr::nullAST);
 		tmp17_AST = astFactory->create(antlr::RefAST(_t));
 		tmp17_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp17_AST));
-		antlr::ASTPair __currentAST213 = currentAST;
+		antlr::ASTPair __currentAST212 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),DEREF);
@@ -1484,8 +1498,8 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST213;
-		_t = __t213;
+		currentAST = __currentAST212;
+		_t = __t212;
 		_t = _t->getNextSibling();
 		expr_AST = RefDNode(currentAST.root);
 		break;
@@ -1575,12 +1589,12 @@
 	int labelStart = comp.NDefLabel();
 	
 	
-	RefDNode __t40 = _t;
+	RefDNode __t39 = _t;
 	s = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode s_AST_in = RefDNode(antlr::nullAST);
 	s_AST = astFactory->create(antlr::RefAST(s));
 	astFactory->addASTChild(currentAST, antlr::RefAST(s_AST));
-	antlr::ASTPair __currentAST40 = currentAST;
+	antlr::ASTPair __currentAST39 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),SWITCH);
@@ -1598,14 +1612,14 @@
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 		}
 		else {
-			goto _loop42;
+			goto _loop41;
 		}
 		
 	}
-	_loop42:;
+	_loop41:;
 	} // ( ... )*
-	currentAST = __currentAST40;
-	_t = __t40;
+	currentAST = __currentAST39;
+	_t = __t39;
 	_t = _t->getNextSibling();
 	
 	s_AST->SetLabelRange( labelStart, comp.NDefLabel());
@@ -1626,12 +1640,12 @@
 	int labelStart = comp.NDefLabel();
 	
 	
-	RefDNode __t44 = _t;
+	RefDNode __t43 = _t;
 	c = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode c_AST_in = RefDNode(antlr::nullAST);
 	c_AST = astFactory->create(antlr::RefAST(c));
 	astFactory->addASTChild(currentAST, antlr::RefAST(c_AST));
-	antlr::ASTPair __currentAST44 = currentAST;
+	antlr::ASTPair __currentAST43 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),CASE);
@@ -1649,14 +1663,14 @@
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 		}
 		else {
-			goto _loop46;
+			goto _loop45;
 		}
 		
 	}
-	_loop46:;
+	_loop45:;
 	} // ( ... )*
-	currentAST = __currentAST44;
-	_t = __t44;
+	currentAST = __currentAST43;
+	_t = __t43;
 	_t = _t->getNextSibling();
 	
 	c_AST->SetLabelRange( labelStart, comp.NDefLabel());
@@ -1672,13 +1686,13 @@
 	antlr::ASTPair currentAST;
 	RefDNode block_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode __t48 = _t;
+	RefDNode __t47 = _t;
 	RefDNode tmp18_AST = RefDNode(antlr::nullAST);
 	RefDNode tmp18_AST_in = RefDNode(antlr::nullAST);
 	tmp18_AST = astFactory->create(antlr::RefAST(_t));
 	tmp18_AST_in = _t;
 	astFactory->addASTChild(currentAST, antlr::RefAST(tmp18_AST));
-	antlr::ASTPair __currentAST48 = currentAST;
+	antlr::ASTPair __currentAST47 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),BLOCK);
@@ -1744,8 +1758,8 @@
 	}
 	}
 	}
-	currentAST = __currentAST48;
-	_t = __t48;
+	currentAST = __currentAST47;
+	_t = __t47;
 	_t = _t->getNextSibling();
 	block_AST = RefDNode(currentAST.root);
 	returnAST = block_AST;
@@ -1760,12 +1774,12 @@
 	RefDNode s_AST = RefDNode(antlr::nullAST);
 	RefDNode s = RefDNode(antlr::nullAST);
 	
-	RefDNode __t51 = _t;
+	RefDNode __t50 = _t;
 	RefDNode tmp19_AST = RefDNode(antlr::nullAST);
 	RefDNode tmp19_AST_in = RefDNode(antlr::nullAST);
 	tmp19_AST = astFactory->create(antlr::RefAST(_t));
 	tmp19_AST_in = _t;
-	antlr::ASTPair __currentAST51 = currentAST;
+	antlr::ASTPair __currentAST50 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),BLOCK);
@@ -1841,8 +1855,8 @@
 	}
 	}
 	}
-	currentAST = __currentAST51;
-	_t = __t51;
+	currentAST = __currentAST50;
+	_t = __t50;
 	_t = _t->getNextSibling();
 	returnAST = unblock_AST;
 	_retTree = _t;
@@ -1856,11 +1870,11 @@
 	RefDNode i = RefDNode(antlr::nullAST);
 	RefDNode i_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode __t67 = _t;
+	RefDNode __t66 = _t;
 	i = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode i_AST_in = RefDNode(antlr::nullAST);
 	i_AST = astFactory->create(antlr::RefAST(i));
-	antlr::ASTPair __currentAST67 = currentAST;
+	antlr::ASTPair __currentAST66 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),IDENTIFIER);
@@ -1871,8 +1885,8 @@
 	tmp20_AST_in = _t;
 	match(antlr::RefAST(_t),COLON);
 	_t = _t->getNextSibling();
-	currentAST = __currentAST67;
-	_t = __t67;
+	currentAST = __currentAST66;
+	_t = __t66;
 	_t = _t->getNextSibling();
 	label_AST = RefDNode(currentAST.root);
 	
@@ -1902,11 +1916,11 @@
 	RefDNode r_AST = RefDNode(antlr::nullAST);
 	RefDNode r = RefDNode(antlr::nullAST);
 	
-	RefDNode __t121 = _t;
+	RefDNode __t120 = _t;
 	a = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode a_AST_in = RefDNode(antlr::nullAST);
 	a_AST = astFactory->create(antlr::RefAST(a));
-	antlr::ASTPair __currentAST121 = currentAST;
+	antlr::ASTPair __currentAST120 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),ASSIGN);
@@ -1919,8 +1933,8 @@
 	expr(_t);
 	_t = _retTree;
 	r_AST = returnAST;
-	currentAST = __currentAST121;
-	_t = __t121;
+	currentAST = __currentAST120;
+	_t = __t120;
 	_t = _t->getNextSibling();
 	assign_expr_statement_AST = RefDNode(currentAST.root);
 	
@@ -2077,11 +2091,11 @@
 	switch ( _t->getType()) {
 	case AND_OP_EQ:
 	{
-		RefDNode __t124 = _t;
+		RefDNode __t123 = _t;
 		a1 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a1_AST_in = RefDNode(antlr::nullAST);
 		a1_AST = astFactory->create(antlr::RefAST(a1));
-		antlr::ASTPair __currentAST124 = currentAST;
+		antlr::ASTPair __currentAST123 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),AND_OP_EQ);
@@ -2094,8 +2108,8 @@
 		expr(_t);
 		_t = _retTree;
 		r1_AST = returnAST;
-		currentAST = __currentAST124;
-		_t = __t124;
+		currentAST = __currentAST123;
+		_t = __t123;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l1_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(AND_OP,"and")))->add(antlr::RefAST(l1_AST))->add(antlr::RefAST(r1_AST))))))->add(antlr::RefAST(RemoveNextSibling(l1_AST)))));
@@ -2110,11 +2124,11 @@
 	}
 	case ASTERIX_EQ:
 	{
-		RefDNode __t125 = _t;
+		RefDNode __t124 = _t;
 		a2 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a2_AST_in = RefDNode(antlr::nullAST);
 		a2_AST = astFactory->create(antlr::RefAST(a2));
-		antlr::ASTPair __currentAST125 = currentAST;
+		antlr::ASTPair __currentAST124 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ASTERIX_EQ);
@@ -2127,8 +2141,8 @@
 		expr(_t);
 		_t = _retTree;
 		r2_AST = returnAST;
-		currentAST = __currentAST125;
-		_t = __t125;
+		currentAST = __currentAST124;
+		_t = __t124;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l2_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASTERIX,"*")))->add(antlr::RefAST(l2_AST))->add(antlr::RefAST(r2_AST))))))->add(antlr::RefAST(RemoveNextSibling(l2_AST)))));
@@ -2143,11 +2157,11 @@
 	}
 	case EQ_OP_EQ:
 	{
-		RefDNode __t126 = _t;
+		RefDNode __t125 = _t;
 		a3 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a3_AST_in = RefDNode(antlr::nullAST);
 		a3_AST = astFactory->create(antlr::RefAST(a3));
-		antlr::ASTPair __currentAST126 = currentAST;
+		antlr::ASTPair __currentAST125 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),EQ_OP_EQ);
@@ -2160,8 +2174,8 @@
 		expr(_t);
 		_t = _retTree;
 		r3_AST = returnAST;
-		currentAST = __currentAST126;
-		_t = __t126;
+		currentAST = __currentAST125;
+		_t = __t125;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l3_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(EQ_OP,"eq")))->add(antlr::RefAST(l3_AST))->add(antlr::RefAST(r3_AST))))))->add(antlr::RefAST(RemoveNextSibling(l3_AST)))));
@@ -2176,11 +2190,11 @@
 	}
 	case GE_OP_EQ:
 	{
-		RefDNode __t127 = _t;
+		RefDNode __t126 = _t;
 		a4 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a4_AST_in = RefDNode(antlr::nullAST);
 		a4_AST = astFactory->create(antlr::RefAST(a4));
-		antlr::ASTPair __currentAST127 = currentAST;
+		antlr::ASTPair __currentAST126 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),GE_OP_EQ);
@@ -2193,8 +2207,8 @@
 		expr(_t);
 		_t = _retTree;
 		r4_AST = returnAST;
-		currentAST = __currentAST127;
-		_t = __t127;
+		currentAST = __currentAST126;
+		_t = __t126;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l4_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(GE_OP,"ge")))->add(antlr::RefAST(l4_AST))->add(antlr::RefAST(r4_AST))))))->add(antlr::RefAST(RemoveNextSibling(l4_AST)))));
@@ -2209,11 +2223,11 @@
 	}
 	case GTMARK_EQ:
 	{
-		RefDNode __t128 = _t;
+		RefDNode __t127 = _t;
 		a5 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a5_AST_in = RefDNode(antlr::nullAST);
 		a5_AST = astFactory->create(antlr::RefAST(a5));
-		antlr::ASTPair __currentAST128 = currentAST;
+		antlr::ASTPair __currentAST127 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),GTMARK_EQ);
@@ -2226,8 +2240,8 @@
 		expr(_t);
 		_t = _retTree;
 		r5_AST = returnAST;
-		currentAST = __currentAST128;
-		_t = __t128;
+		currentAST = __currentAST127;
+		_t = __t127;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l5_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(GTMARK,">")))->add(antlr::RefAST(l5_AST))->add(antlr::RefAST(r5_AST))))))->add(antlr::RefAST(RemoveNextSibling(l5_AST)))));
@@ -2242,11 +2256,11 @@
 	}
 	case GT_OP_EQ:
 	{
-		RefDNode __t129 = _t;
+		RefDNode __t128 = _t;
 		a6 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a6_AST_in = RefDNode(antlr::nullAST);
 		a6_AST = astFactory->create(antlr::RefAST(a6));
-		antlr::ASTPair __currentAST129 = currentAST;
+		antlr::ASTPair __currentAST128 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),GT_OP_EQ);
@@ -2259,8 +2273,8 @@
 		expr(_t);
 		_t = _retTree;
 		r6_AST = returnAST;
-		currentAST = __currentAST129;
-		_t = __t129;
+		currentAST = __currentAST128;
+		_t = __t128;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l6_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(GT_OP,"gt")))->add(antlr::RefAST(l6_AST))->add(antlr::RefAST(r6_AST))))))->add(antlr::RefAST(RemoveNextSibling(l6_AST)))));
@@ -2275,11 +2289,11 @@
 	}
 	case LE_OP_EQ:
 	{
-		RefDNode __t130 = _t;
+		RefDNode __t129 = _t;
 		a7 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a7_AST_in = RefDNode(antlr::nullAST);
 		a7_AST = astFactory->create(antlr::RefAST(a7));
-		antlr::ASTPair __currentAST130 = currentAST;
+		antlr::ASTPair __currentAST129 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LE_OP_EQ);
@@ -2292,8 +2306,8 @@
 		expr(_t);
 		_t = _retTree;
 		r7_AST = returnAST;
-		currentAST = __currentAST130;
-		_t = __t130;
+		currentAST = __currentAST129;
+		_t = __t129;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l7_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(LE_OP,"le")))->add(antlr::RefAST(l7_AST))->add(antlr::RefAST(r7_AST))))))->add(antlr::RefAST(RemoveNextSibling(l7_AST)))));
@@ -2308,11 +2322,11 @@
 	}
 	case LTMARK_EQ:
 	{
-		RefDNode __t131 = _t;
+		RefDNode __t130 = _t;
 		a8 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a8_AST_in = RefDNode(antlr::nullAST);
 		a8_AST = astFactory->create(antlr::RefAST(a8));
-		antlr::ASTPair __currentAST131 = currentAST;
+		antlr::ASTPair __currentAST130 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LTMARK_EQ);
@@ -2325,8 +2339,8 @@
 		expr(_t);
 		_t = _retTree;
 		r8_AST = returnAST;
-		currentAST = __currentAST131;
-		_t = __t131;
+		currentAST = __currentAST130;
+		_t = __t130;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l8_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(LTMARK,"<")))->add(antlr::RefAST(l8_AST))->add(antlr::RefAST(r8_AST))))))->add(antlr::RefAST(RemoveNextSibling(l8_AST)))));
@@ -2341,11 +2355,11 @@
 	}
 	case LT_OP_EQ:
 	{
-		RefDNode __t132 = _t;
+		RefDNode __t131 = _t;
 		a9 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a9_AST_in = RefDNode(antlr::nullAST);
 		a9_AST = astFactory->create(antlr::RefAST(a9));
-		antlr::ASTPair __currentAST132 = currentAST;
+		antlr::ASTPair __currentAST131 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LT_OP_EQ);
@@ -2358,8 +2372,8 @@
 		expr(_t);
 		_t = _retTree;
 		r9_AST = returnAST;
-		currentAST = __currentAST132;
-		_t = __t132;
+		currentAST = __currentAST131;
+		_t = __t131;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l9_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(LT_OP,"lt")))->add(antlr::RefAST(l9_AST))->add(antlr::RefAST(r9_AST))))))->add(antlr::RefAST(RemoveNextSibling(l9_AST)))));
@@ -2374,11 +2388,11 @@
 	}
 	case MATRIX_OP1_EQ:
 	{
-		RefDNode __t133 = _t;
+		RefDNode __t132 = _t;
 		a10 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a10_AST_in = RefDNode(antlr::nullAST);
 		a10_AST = astFactory->create(antlr::RefAST(a10));
-		antlr::ASTPair __currentAST133 = currentAST;
+		antlr::ASTPair __currentAST132 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MATRIX_OP1_EQ);
@@ -2391,8 +2405,8 @@
 		expr(_t);
 		_t = _retTree;
 		r10_AST = returnAST;
-		currentAST = __currentAST133;
-		_t = __t133;
+		currentAST = __currentAST132;
+		_t = __t132;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l10_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(MATRIX_OP1,"#")))->add(antlr::RefAST(l10_AST))->add(antlr::RefAST(r10_AST))))))->add(antlr::RefAST(RemoveNextSibling(l10_AST)))));
@@ -2407,11 +2421,11 @@
 	}
 	case MATRIX_OP2_EQ:
 	{
-		RefDNode __t134 = _t;
+		RefDNode __t133 = _t;
 		a11 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a11_AST_in = RefDNode(antlr::nullAST);
 		a11_AST = astFactory->create(antlr::RefAST(a11));
-		antlr::ASTPair __currentAST134 = currentAST;
+		antlr::ASTPair __currentAST133 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MATRIX_OP2_EQ);
@@ -2424,8 +2438,8 @@
 		expr(_t);
 		_t = _retTree;
 		r11_AST = returnAST;
-		currentAST = __currentAST134;
-		_t = __t134;
+		currentAST = __currentAST133;
+		_t = __t133;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l11_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(MATRIX_OP2,"##")))->add(antlr::RefAST(l11_AST))->add(antlr::RefAST(r11_AST))))))->add(antlr::RefAST(RemoveNextSibling(l11_AST)))));
@@ -2440,11 +2454,11 @@
 	}
 	case MINUS_EQ:
 	{
-		RefDNode __t135 = _t;
+		RefDNode __t134 = _t;
 		a12 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a12_AST_in = RefDNode(antlr::nullAST);
 		a12_AST = astFactory->create(antlr::RefAST(a12));
-		antlr::ASTPair __currentAST135 = currentAST;
+		antlr::ASTPair __currentAST134 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MINUS_EQ);
@@ -2457,8 +2471,8 @@
 		expr(_t);
 		_t = _retTree;
 		r12_AST = returnAST;
-		currentAST = __currentAST135;
-		_t = __t135;
+		currentAST = __currentAST134;
+		_t = __t134;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l12_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(MINUS,"-")))->add(antlr::RefAST(l12_AST))->add(antlr::RefAST(r12_AST))))))->add(antlr::RefAST(RemoveNextSibling(l12_AST)))));
@@ -2473,11 +2487,11 @@
 	}
 	case MOD_OP_EQ:
 	{
-		RefDNode __t136 = _t;
+		RefDNode __t135 = _t;
 		a13 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a13_AST_in = RefDNode(antlr::nullAST);
 		a13_AST = astFactory->create(antlr::RefAST(a13));
-		antlr::ASTPair __currentAST136 = currentAST;
+		antlr::ASTPair __currentAST135 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MOD_OP_EQ);
@@ -2490,8 +2504,8 @@
 		expr(_t);
 		_t = _retTree;
 		r13_AST = returnAST;
-		currentAST = __currentAST136;
-		_t = __t136;
+		currentAST = __currentAST135;
+		_t = __t135;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l13_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(MOD_OP,"mod")))->add(antlr::RefAST(l13_AST))->add(antlr::RefAST(r13_AST))))))->add(antlr::RefAST(RemoveNextSibling(l13_AST)))));
@@ -2506,11 +2520,11 @@
 	}
 	case NE_OP_EQ:
 	{
-		RefDNode __t137 = _t;
+		RefDNode __t136 = _t;
 		a14 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a14_AST_in = RefDNode(antlr::nullAST);
 		a14_AST = astFactory->create(antlr::RefAST(a14));
-		antlr::ASTPair __currentAST137 = currentAST;
+		antlr::ASTPair __currentAST136 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),NE_OP_EQ);
@@ -2523,8 +2537,8 @@
 		expr(_t);
 		_t = _retTree;
 		r14_AST = returnAST;
-		currentAST = __currentAST137;
-		_t = __t137;
+		currentAST = __currentAST136;
+		_t = __t136;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l14_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(NE_OP,"ne")))->add(antlr::RefAST(l14_AST))->add(antlr::RefAST(r14_AST))))))->add(antlr::RefAST(RemoveNextSibling(l14_AST)))));
@@ -2539,11 +2553,11 @@
 	}
 	case OR_OP_EQ:
 	{
-		RefDNode __t138 = _t;
+		RefDNode __t137 = _t;
 		a15 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a15_AST_in = RefDNode(antlr::nullAST);
 		a15_AST = astFactory->create(antlr::RefAST(a15));
-		antlr::ASTPair __currentAST138 = currentAST;
+		antlr::ASTPair __currentAST137 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),OR_OP_EQ);
@@ -2556,8 +2570,8 @@
 		expr(_t);
 		_t = _retTree;
 		r15_AST = returnAST;
-		currentAST = __currentAST138;
-		_t = __t138;
+		currentAST = __currentAST137;
+		_t = __t137;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l15_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(OR_OP,"or")))->add(antlr::RefAST(l15_AST))->add(antlr::RefAST(r15_AST))))))->add(antlr::RefAST(RemoveNextSibling(l15_AST)))));
@@ -2572,11 +2586,11 @@
 	}
 	case PLUS_EQ:
 	{
-		RefDNode __t139 = _t;
+		RefDNode __t138 = _t;
 		a16 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a16_AST_in = RefDNode(antlr::nullAST);
 		a16_AST = astFactory->create(antlr::RefAST(a16));
-		antlr::ASTPair __currentAST139 = currentAST;
+		antlr::ASTPair __currentAST138 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),PLUS_EQ);
@@ -2589,8 +2603,8 @@
 		expr(_t);
 		_t = _retTree;
 		r16_AST = returnAST;
-		currentAST = __currentAST139;
-		_t = __t139;
+		currentAST = __currentAST138;
+		_t = __t138;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l16_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(PLUS,"+")))->add(antlr::RefAST(l16_AST))->add(antlr::RefAST(r16_AST))))))->add(antlr::RefAST(RemoveNextSibling(l16_AST)))));
@@ -2605,11 +2619,11 @@
 	}
 	case POW_EQ:
 	{
-		RefDNode __t140 = _t;
+		RefDNode __t139 = _t;
 		a17 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a17_AST_in = RefDNode(antlr::nullAST);
 		a17_AST = astFactory->create(antlr::RefAST(a17));
-		antlr::ASTPair __currentAST140 = currentAST;
+		antlr::ASTPair __currentAST139 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),POW_EQ);
@@ -2622,8 +2636,8 @@
 		expr(_t);
 		_t = _retTree;
 		r17_AST = returnAST;
-		currentAST = __currentAST140;
-		_t = __t140;
+		currentAST = __currentAST139;
+		_t = __t139;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l17_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(POW,"^")))->add(antlr::RefAST(l17_AST))->add(antlr::RefAST(r17_AST))))))->add(antlr::RefAST(RemoveNextSibling(l17_AST)))));
@@ -2638,11 +2652,11 @@
 	}
 	case SLASH_EQ:
 	{
-		RefDNode __t141 = _t;
+		RefDNode __t140 = _t;
 		a18 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a18_AST_in = RefDNode(antlr::nullAST);
 		a18_AST = astFactory->create(antlr::RefAST(a18));
-		antlr::ASTPair __currentAST141 = currentAST;
+		antlr::ASTPair __currentAST140 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),SLASH_EQ);
@@ -2655,8 +2669,8 @@
 		expr(_t);
 		_t = _retTree;
 		r18_AST = returnAST;
-		currentAST = __currentAST141;
-		_t = __t141;
+		currentAST = __currentAST140;
+		_t = __t140;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l18_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(SLASH,"/")))->add(antlr::RefAST(l18_AST))->add(antlr::RefAST(r18_AST))))))->add(antlr::RefAST(RemoveNextSibling(l18_AST)))));
@@ -2671,11 +2685,11 @@
 	}
 	case XOR_OP_EQ:
 	{
-		RefDNode __t142 = _t;
+		RefDNode __t141 = _t;
 		a19 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a19_AST_in = RefDNode(antlr::nullAST);
 		a19_AST = astFactory->create(antlr::RefAST(a19));
-		antlr::ASTPair __currentAST142 = currentAST;
+		antlr::ASTPair __currentAST141 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),XOR_OP_EQ);
@@ -2688,8 +2702,8 @@
 		expr(_t);
 		_t = _retTree;
 		r19_AST = returnAST;
-		currentAST = __currentAST142;
-		_t = __t142;
+		currentAST = __currentAST141;
+		_t = __t141;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l19_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(XOR_OP,"xor")))->add(antlr::RefAST(l19_AST))->add(antlr::RefAST(r19_AST))))))->add(antlr::RefAST(RemoveNextSibling(l19_AST)))));
@@ -2731,13 +2745,13 @@
 	switch ( _t->getType()) {
 	case MPCALL:
 	{
-		RefDNode __t77 = _t;
+		RefDNode __t76 = _t;
 		RefDNode tmp21_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp21_AST_in = RefDNode(antlr::nullAST);
 		tmp21_AST = astFactory->create(antlr::RefAST(_t));
 		tmp21_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp21_AST));
-		antlr::ASTPair __currentAST77 = currentAST;
+		antlr::ASTPair __currentAST76 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MPCALL);
@@ -2762,27 +2776,27 @@
 				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 			}
 			else {
-				goto _loop79;
+				goto _loop78;
 			}
 			
 		}
-		_loop79:;
+		_loop78:;
 		} // ( ... )*
-		currentAST = __currentAST77;
-		_t = __t77;
+		currentAST = __currentAST76;
+		_t = __t76;
 		_t = _t->getNextSibling();
 		procedure_call_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case MPCALL_PARENT:
 	{
-		RefDNode __t80 = _t;
+		RefDNode __t79 = _t;
 		RefDNode tmp23_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp23_AST_in = RefDNode(antlr::nullAST);
 		tmp23_AST = astFactory->create(antlr::RefAST(_t));
 		tmp23_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp23_AST));
-		antlr::ASTPair __currentAST80 = currentAST;
+		antlr::ASTPair __currentAST79 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MPCALL_PARENT);
@@ -2814,26 +2828,26 @@
 				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 			}
 			else {
-				goto _loop82;
+				goto _loop81;
 			}
 			
 		}
-		_loop82:;
+		_loop81:;
 		} // ( ... )*
-		currentAST = __currentAST80;
-		_t = __t80;
+		currentAST = __currentAST79;
+		_t = __t79;
 		_t = _t->getNextSibling();
 		procedure_call_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case PCALL:
 	{
-		RefDNode __t83 = _t;
+		RefDNode __t82 = _t;
 		p = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode p_AST_in = RefDNode(antlr::nullAST);
 		p_AST = astFactory->create(antlr::RefAST(p));
 		astFactory->addASTChild(currentAST, antlr::RefAST(p_AST));
-		antlr::ASTPair __currentAST83 = currentAST;
+		antlr::ASTPair __currentAST82 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),PCALL);
@@ -2854,11 +2868,11 @@
 				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 			}
 			else {
-				goto _loop85;
+				goto _loop84;
 			}
 			
 		}
-		_loop85:;
+		_loop84:;
 		} // ( ... )*
 		
 		// first search library procedures
@@ -2876,8 +2890,8 @@
 		id_AST->SetProIx(i);
 		}
 		
-		currentAST = __currentAST83;
-		_t = __t83;
+		currentAST = __currentAST82;
+		_t = __t82;
 		_t = _t->getNextSibling();
 		procedure_call_AST = RefDNode(currentAST.root);
 		break;
@@ -2905,12 +2919,12 @@
 	int labelStart = comp.NDefLabel();
 	
 	
-	RefDNode __t64 = _t;
+	RefDNode __t63 = _t;
 	f = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode f_AST_in = RefDNode(antlr::nullAST);
 	f_AST = astFactory->create(antlr::RefAST(f));
 	astFactory->addASTChild(currentAST, antlr::RefAST(f_AST));
-	antlr::ASTPair __currentAST64 = currentAST;
+	antlr::ASTPair __currentAST63 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),FOR);
@@ -3024,8 +3038,8 @@
 	unblock(_t);
 	_t = _retTree;
 	astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-	currentAST = __currentAST64;
-	_t = __t64;
+	currentAST = __currentAST63;
+	_t = __t63;
 	_t = _t->getNextSibling();
 	
 	f_AST->SetLabelRange( labelStart, comp.NDefLabel());
@@ -3050,11 +3064,11 @@
 	int labelStart = comp.NDefLabel();
 	
 	
-	RefDNode __t60 = _t;
+	RefDNode __t59 = _t;
 	r = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode r_AST_in = RefDNode(antlr::nullAST);
 	r_AST = astFactory->create(antlr::RefAST(r));
-	antlr::ASTPair __currentAST60 = currentAST;
+	antlr::ASTPair __currentAST59 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),REPEAT);
@@ -3067,8 +3081,8 @@
 	expr(_t);
 	_t = _retTree;
 	e_AST = returnAST;
-	currentAST = __currentAST60;
-	_t = __t60;
+	currentAST = __currentAST59;
+	_t = __t59;
 	_t = _t->getNextSibling();
 	repeat_statement_AST = RefDNode(currentAST.root);
 	
@@ -3103,11 +3117,11 @@
 	int labelStart = comp.NDefLabel();
 	
 	
-	RefDNode __t62 = _t;
+	RefDNode __t61 = _t;
 	w = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode w_AST_in = RefDNode(antlr::nullAST);
 	w_AST = astFactory->create(antlr::RefAST(w));
-	antlr::ASTPair __currentAST62 = currentAST;
+	antlr::ASTPair __currentAST61 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),WHILE);
@@ -3120,8 +3134,8 @@
 	statement(_t);
 	_t = _retTree;
 	s_AST = returnAST;
-	currentAST = __currentAST62;
-	_t = __t62;
+	currentAST = __currentAST61;
+	_t = __t61;
 	_t = _t->getNextSibling();
 	while_statement_AST = RefDNode(currentAST.root);
 	
@@ -3158,12 +3172,12 @@
 	switch ( _t->getType()) {
 	case GOTO:
 	{
-		RefDNode __t69 = _t;
+		RefDNode __t68 = _t;
 		RefDNode tmp26_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp26_AST_in = RefDNode(antlr::nullAST);
 		tmp26_AST = astFactory->create(antlr::RefAST(_t));
 		tmp26_AST_in = _t;
-		antlr::ASTPair __currentAST69 = currentAST;
+		antlr::ASTPair __currentAST68 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),GOTO);
@@ -3173,8 +3187,8 @@
 		i1_AST = astFactory->create(antlr::RefAST(i1));
 		match(antlr::RefAST(_t),IDENTIFIER);
 		_t = _t->getNextSibling();
-		currentAST = __currentAST69;
-		_t = __t69;
+		currentAST = __currentAST68;
+		_t = __t68;
 		_t = _t->getNextSibling();
 		jump_statement_AST = RefDNode(currentAST.root);
 		
@@ -3193,12 +3207,12 @@
 	}
 	case RETURN:
 	{
-		RefDNode __t70 = _t;
+		RefDNode __t69 = _t;
 		RefDNode tmp27_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp27_AST_in = RefDNode(antlr::nullAST);
 		tmp27_AST = astFactory->create(antlr::RefAST(_t));
 		tmp27_AST_in = _t;
-		antlr::ASTPair __currentAST70 = currentAST;
+		antlr::ASTPair __currentAST69 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),RETURN);
@@ -3290,8 +3304,8 @@
 		}
 		}
 		}
-		currentAST = __currentAST70;
-		_t = __t70;
+		currentAST = __currentAST69;
+		_t = __t69;
 		_t = _t->getNextSibling();
 		jump_statement_AST = RefDNode(currentAST.root);
 		
@@ -3321,12 +3335,12 @@
 	}
 	case ON_IOERROR:
 	{
-		RefDNode __t72 = _t;
+		RefDNode __t71 = _t;
 		RefDNode tmp28_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp28_AST_in = RefDNode(antlr::nullAST);
 		tmp28_AST = astFactory->create(antlr::RefAST(_t));
 		tmp28_AST_in = _t;
-		antlr::ASTPair __currentAST72 = currentAST;
+		antlr::ASTPair __currentAST71 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ON_IOERROR);
@@ -3336,8 +3350,8 @@
 		i2_AST = astFactory->create(antlr::RefAST(i2));
 		match(antlr::RefAST(_t),IDENTIFIER);
 		_t = _t->getNextSibling();
-		currentAST = __currentAST72;
-		_t = __t72;
+		currentAST = __currentAST71;
+		_t = __t71;
 		_t = _t->getNextSibling();
 		jump_statement_AST = RefDNode(currentAST.root);
 		
@@ -3388,11 +3402,11 @@
 	int labelStart = comp.NDefLabel();
 	
 	
-	RefDNode __t74 = _t;
+	RefDNode __t73 = _t;
 	i = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode i_AST_in = RefDNode(antlr::nullAST);
 	i_AST = astFactory->create(antlr::RefAST(i));
-	antlr::ASTPair __currentAST74 = currentAST;
+	antlr::ASTPair __currentAST73 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),IF);
@@ -3490,8 +3504,8 @@
 	}
 	}
 	}
-	currentAST = __currentAST74;
-	_t = __t74;
+	currentAST = __currentAST73;
+	_t = __t73;
 	_t = _t->getNextSibling();
 	
 	i_AST->SetLabelRange( labelStart, comp.NDefLabel());
@@ -3612,11 +3626,11 @@
 	RefDNode variable;
 	
 	
-	RefDNode __t88 = _t;
+	RefDNode __t87 = _t;
 	d = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode d_AST_in = RefDNode(antlr::nullAST);
 	d_AST = astFactory->create(antlr::RefAST(d));
-	antlr::ASTPair __currentAST88 = currentAST;
+	antlr::ASTPair __currentAST87 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),KEYDEF);
@@ -3670,8 +3684,8 @@
 	else
 		currentAST.child = key_parameter_AST;
 	currentAST.advanceChildToEnd();
-	currentAST = __currentAST88;
-	_t = __t88;
+	currentAST = __currentAST87;
+	_t = __t87;
 	_t = _t->getNextSibling();
 	returnAST = key_parameter_AST;
 	_retTree = _t;
@@ -3753,12 +3767,12 @@
 	switch ( _t->getType()) {
 	case ARRAYDEF:
 	{
-		RefDNode __t91 = _t;
+		RefDNode __t90 = _t;
 		a = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a_AST_in = RefDNode(antlr::nullAST);
 		a_AST = astFactory->create(antlr::RefAST(a));
 		astFactory->addASTChild(currentAST, antlr::RefAST(a_AST));
-		antlr::ASTPair __currentAST91 = currentAST;
+		antlr::ASTPair __currentAST90 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ARRAYDEF);
@@ -3775,14 +3789,14 @@
 				/*check for constant expression*/
 			}
 			else {
-				goto _loop93;
+				goto _loop92;
 			}
 			
 		}
-		_loop93:;
+		_loop92:;
 		} // ( ... )*
-		currentAST = __currentAST91;
-		_t = __t91;
+		currentAST = __currentAST90;
+		_t = __t90;
 		_t = _t->getNextSibling();
 		
 		// better check here as then CONSTANT is propagated
@@ -3823,12 +3837,12 @@
 	}
 	case ARRAYDEF_CONST:
 	{
-		RefDNode __t94 = _t;
+		RefDNode __t93 = _t;
 		aa = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode aa_AST_in = RefDNode(antlr::nullAST);
 		aa_AST = astFactory->create(antlr::RefAST(aa));
 		astFactory->addASTChild(currentAST, antlr::RefAST(aa_AST));
-		antlr::ASTPair __currentAST94 = currentAST;
+		antlr::ASTPair __currentAST93 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ARRAYDEF_CONST);
@@ -3844,14 +3858,14 @@
 				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 			}
 			else {
-				goto _loop96;
+				goto _loop95;
 			}
 			
 		}
-		_loop96:;
+		_loop95:;
 		} // ( ... )*
-		currentAST = __currentAST94;
-		_t = __t94;
+		currentAST = __currentAST93;
+		_t = __t93;
 		_t = _t->getNextSibling();
 		
 		depth=0;
@@ -3909,12 +3923,12 @@
 	switch ( _t->getType()) {
 	case NSTRUC_REF:
 	{
-		RefDNode __t98 = _t;
+		RefDNode __t97 = _t;
 		n = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode n_AST_in = RefDNode(antlr::nullAST);
 		n_AST = astFactory->create(antlr::RefAST(n));
 		astFactory->addASTChild(currentAST, antlr::RefAST(n_AST));
-		antlr::ASTPair __currentAST98 = currentAST;
+		antlr::ASTPair __currentAST97 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),NSTRUC_REF);
@@ -3998,7 +4012,7 @@
 		case QUESTION:
 		{
 			{ // ( ... )+
-			int _cnt101=0;
+			int _cnt100=0;
 			for (;;) {
 				if (_t == RefDNode(antlr::nullAST) )
 					_t = ASTNULL;
@@ -4108,12 +4122,12 @@
 				}
 				default:
 				{
-					if ( _cnt101>=1 ) { goto _loop101; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+					if ( _cnt100>=1 ) { goto _loop100; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 				}
 				}
-				_cnt101++;
+				_cnt100++;
 			}
-			_loop101:;
+			_loop100:;
 			}  // ( ... )+
 			
 			// set to nstruct if defined here
@@ -4133,27 +4147,27 @@
 		}
 		}
 		}
-		currentAST = __currentAST98;
-		_t = __t98;
+		currentAST = __currentAST97;
+		_t = __t97;
 		_t = _t->getNextSibling();
 		struct_def_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case STRUC:
 	{
-		RefDNode __t102 = _t;
+		RefDNode __t101 = _t;
 		RefDNode tmp33_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp33_AST_in = RefDNode(antlr::nullAST);
 		tmp33_AST = astFactory->create(antlr::RefAST(_t));
 		tmp33_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp33_AST));
-		antlr::ASTPair __currentAST102 = currentAST;
+		antlr::ASTPair __currentAST101 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),STRUC);
 		_t = _t->getFirstChild();
 		{ // ( ... )+
-		int _cnt104=0;
+		int _cnt103=0;
 		for (;;) {
 			if (_t == RefDNode(antlr::nullAST) )
 				_t = ASTNULL;
@@ -4163,15 +4177,15 @@
 				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 			}
 			else {
-				if ( _cnt104>=1 ) { goto _loop104; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+				if ( _cnt103>=1 ) { goto _loop103; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 			}
 			
-			_cnt104++;
+			_cnt103++;
 		}
-		_loop104:;
+		_loop103:;
 		}  // ( ... )+
-		currentAST = __currentAST102;
-		_t = __t102;
+		currentAST = __currentAST101;
+		_t = __t101;
 		_t = _t->getNextSibling();
 		struct_def_AST = RefDNode(currentAST.root);
 		break;
@@ -4226,12 +4240,12 @@
 	
 	
 	{
-	RefDNode __t108 = _t;
+	RefDNode __t107 = _t;
 	RefDNode tmp35_AST = RefDNode(antlr::nullAST);
 	RefDNode tmp35_AST_in = RefDNode(antlr::nullAST);
 	tmp35_AST = astFactory->create(antlr::RefAST(_t));
 	tmp35_AST_in = _t;
-	antlr::ASTPair __currentAST108 = currentAST;
+	antlr::ASTPair __currentAST107 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),ARRAYIX);
@@ -4723,8 +4737,8 @@
 	}
 	}
 	}
-	currentAST = __currentAST108;
-	_t = __t108;
+	currentAST = __currentAST107;
+	_t = __t107;
 	_t = _t->getNextSibling();
 	}
 	returnAST = arrayindex_AST;
@@ -4743,7 +4757,7 @@
 	
 	
 	{ // ( ... )+
-	int _cnt116=0;
+	int _cnt115=0;
 	for (;;) {
 		if (_t == RefDNode(antlr::nullAST) )
 			_t = ASTNULL;
@@ -4753,12 +4767,12 @@
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 		}
 		else {
-			if ( _cnt116>=1 ) { goto _loop116; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+			if ( _cnt115>=1 ) { goto _loop115; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 		}
 		
-		_cnt116++;
+		_cnt115++;
 	}
-	_loop116:;
+	_loop115:;
 	}  // ( ... )+
 	arrayindex_list_AST = RefDNode(currentAST.root);
 	
@@ -4846,11 +4860,11 @@
 	RefDNode r_AST = RefDNode(antlr::nullAST);
 	RefDNode r = RefDNode(antlr::nullAST);
 	
-	RefDNode __t119 = _t;
+	RefDNode __t118 = _t;
 	a = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode a_AST_in = RefDNode(antlr::nullAST);
 	a_AST = astFactory->create(antlr::RefAST(a));
-	antlr::ASTPair __currentAST119 = currentAST;
+	antlr::ASTPair __currentAST118 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),ASSIGN);
@@ -4863,8 +4877,8 @@
 	expr(_t);
 	_t = _retTree;
 	r_AST = returnAST;
-	currentAST = __currentAST119;
-	_t = __t119;
+	currentAST = __currentAST118;
+	_t = __t118;
 	_t = _t->getNextSibling();
 	assign_expr_AST = RefDNode(currentAST.root);
 	
@@ -4904,12 +4918,12 @@
 	RefDNode i = RefDNode(antlr::nullAST);
 	RefDNode i_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode __t144 = _t;
+	RefDNode __t143 = _t;
 	RefDNode tmp38_AST = RefDNode(antlr::nullAST);
 	RefDNode tmp38_AST_in = RefDNode(antlr::nullAST);
 	tmp38_AST = astFactory->create(antlr::RefAST(_t));
 	tmp38_AST_in = _t;
-	antlr::ASTPair __currentAST144 = currentAST;
+	antlr::ASTPair __currentAST143 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),SYSVAR);
@@ -4919,8 +4933,8 @@
 	i_AST = astFactory->create(antlr::RefAST(i));
 	match(antlr::RefAST(_t),SYSVARNAME);
 	_t = _t->getNextSibling();
-	currentAST = __currentAST144;
-	_t = __t144;
+	currentAST = __currentAST143;
+	_t = __t143;
 	_t = _t->getNextSibling();
 	sysvar_AST = RefDNode(currentAST.root);
 	
@@ -4949,12 +4963,12 @@
 	RefDNode i = RefDNode(antlr::nullAST);
 	RefDNode i_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode __t146 = _t;
+	RefDNode __t145 = _t;
 	RefDNode tmp39_AST = RefDNode(antlr::nullAST);
 	RefDNode tmp39_AST_in = RefDNode(antlr::nullAST);
 	tmp39_AST = astFactory->create(antlr::RefAST(_t));
 	tmp39_AST_in = _t;
-	antlr::ASTPair __currentAST146 = currentAST;
+	antlr::ASTPair __currentAST145 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),VAR);
@@ -4964,8 +4978,8 @@
 	i_AST = astFactory->create(antlr::RefAST(i));
 	match(antlr::RefAST(_t),IDENTIFIER);
 	_t = _t->getNextSibling();
-	currentAST = __currentAST146;
-	_t = __t146;
+	currentAST = __currentAST145;
+	_t = __t145;
 	_t = _t->getNextSibling();
 	var_AST = RefDNode(currentAST.root);
 	
@@ -4993,17 +5007,17 @@
 	RefDNode e = RefDNode(antlr::nullAST);
 	
 	{ // ( ... )+
-	int _cnt150=0;
+	int _cnt149=0;
 	for (;;) {
 		if (_t == RefDNode(antlr::nullAST) )
 			_t = ASTNULL;
 		if ((_t->getType() == ARRAYIX)) {
-			RefDNode __t149 = _t;
+			RefDNode __t148 = _t;
 			RefDNode tmp40_AST = RefDNode(antlr::nullAST);
 			RefDNode tmp40_AST_in = RefDNode(antlr::nullAST);
 			tmp40_AST = astFactory->create(antlr::RefAST(_t));
 			tmp40_AST_in = _t;
-			antlr::ASTPair __currentAST149 = currentAST;
+			antlr::ASTPair __currentAST148 = currentAST;
 			currentAST.root = currentAST.child;
 			currentAST.child = RefDNode(antlr::nullAST);
 			match(antlr::RefAST(_t),ARRAYIX);
@@ -5012,8 +5026,8 @@
 			pos_parameter(_t);
 			_t = _retTree;
 			e_AST = returnAST;
-			currentAST = __currentAST149;
-			_t = __t149;
+			currentAST = __currentAST148;
+			_t = __t148;
 			_t = _t->getNextSibling();
 			arrayindex_list_to_expression_list_AST = RefDNode(currentAST.root);
 			
@@ -5029,12 +5043,12 @@
 			currentAST.advanceChildToEnd();
 		}
 		else {
-			if ( _cnt150>=1 ) { goto _loop150; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+			if ( _cnt149>=1 ) { goto _loop149; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 		}
 		
-		_cnt150++;
+		_cnt149++;
 	}
-	_loop150:;
+	_loop149:;
 	}  // ( ... )+
 	returnAST = arrayindex_list_to_expression_list_AST;
 	_retTree = _t;
@@ -5058,21 +5072,21 @@
 	bool isVar;
 	
 	
-	RefDNode __t152 = _t;
+	RefDNode __t151 = _t;
 	RefDNode tmp41_AST = RefDNode(antlr::nullAST);
 	RefDNode tmp41_AST_in = RefDNode(antlr::nullAST);
 	tmp41_AST = astFactory->create(antlr::RefAST(_t));
 	tmp41_AST_in = _t;
-	antlr::ASTPair __currentAST152 = currentAST;
+	antlr::ASTPair __currentAST151 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),ARRAYEXPR_FN);
 	_t = _t->getFirstChild();
-	RefDNode __t153 = _t;
+	RefDNode __t152 = _t;
 	va = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode va_AST_in = RefDNode(antlr::nullAST);
 	va_AST = astFactory->create(antlr::RefAST(va));
-	antlr::ASTPair __currentAST153 = currentAST;
+	antlr::ASTPair __currentAST152 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),VAR);
@@ -5082,8 +5096,8 @@
 	id_AST = astFactory->create(antlr::RefAST(id));
 	match(antlr::RefAST(_t),IDENTIFIER);
 	_t = _t->getNextSibling();
-	currentAST = __currentAST153;
-	_t = __t153;
+	currentAST = __currentAST152;
+	_t = __t152;
 	_t = _t->getNextSibling();
 	
 	id_text=id_AST->getText(); 
@@ -5167,8 +5181,8 @@
 	else
 		currentAST.child = arrayexpr_fn_AST;
 	currentAST.advanceChildToEnd();
-	currentAST = __currentAST152;
-	_t = __t152;
+	currentAST = __currentAST151;
+	_t = __t151;
 	_t = _t->getNextSibling();
 	returnAST = arrayexpr_fn_AST;
 	_retTree = _t;
@@ -5226,13 +5240,13 @@
 	}
 	case MFCALL:
 	{
-		RefDNode __t156 = _t;
+		RefDNode __t155 = _t;
 		RefDNode tmp42_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp42_AST_in = RefDNode(antlr::nullAST);
 		tmp42_AST = astFactory->create(antlr::RefAST(_t));
 		tmp42_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp42_AST));
-		antlr::ASTPair __currentAST156 = currentAST;
+		antlr::ASTPair __currentAST155 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MFCALL);
@@ -5257,27 +5271,27 @@
 				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 			}
 			else {
-				goto _loop158;
+				goto _loop157;
 			}
 			
 		}
-		_loop158:;
+		_loop157:;
 		} // ( ... )*
-		currentAST = __currentAST156;
-		_t = __t156;
+		currentAST = __currentAST155;
+		_t = __t155;
 		_t = _t->getNextSibling();
 		primary_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case MFCALL_PARENT:
 	{
-		RefDNode __t159 = _t;
+		RefDNode __t158 = _t;
 		RefDNode tmp44_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp44_AST_in = RefDNode(antlr::nullAST);
 		tmp44_AST = astFactory->create(antlr::RefAST(_t));
 		tmp44_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp44_AST));
-		antlr::ASTPair __currentAST159 = currentAST;
+		antlr::ASTPair __currentAST158 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MFCALL_PARENT);
@@ -5309,26 +5323,26 @@
 				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 			}
 			else {
-				goto _loop161;
+				goto _loop160;
 			}
 			
 		}
-		_loop161:;
+		_loop160:;
 		} // ( ... )*
-		currentAST = __currentAST159;
-		_t = __t159;
+		currentAST = __currentAST158;
+		_t = __t158;
 		_t = _t->getNextSibling();
 		primary_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case FCALL:
 	{
-		RefDNode __t162 = _t;
+		RefDNode __t161 = _t;
 		f = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode f_AST_in = RefDNode(antlr::nullAST);
 		f_AST = astFactory->create(antlr::RefAST(f));
 		astFactory->addASTChild(currentAST, antlr::RefAST(f_AST));
-		antlr::ASTPair __currentAST162 = currentAST;
+		antlr::ASTPair __currentAST161 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),FCALL);
@@ -5348,11 +5362,11 @@
 				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 			}
 			else {
-				goto _loop164;
+				goto _loop163;
 			}
 			
 		}
-		_loop164:;
+		_loop163:;
 		} // ( ... )*
 		
 		// first search library functions
@@ -5383,8 +5397,8 @@
 		f_AST->SetFunIx(i);
 		}
 		
-		currentAST = __currentAST162;
-		_t = __t162;
+		currentAST = __currentAST161;
+		_t = __t161;
 		_t = _t->getNextSibling();
 		primary_expr_AST = RefDNode(currentAST.root);
 		break;
@@ -5447,13 +5461,13 @@
 	switch ( _t->getType()) {
 	case QUESTION:
 	{
-		RefDNode __t166 = _t;
+		RefDNode __t165 = _t;
 		RefDNode tmp48_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp48_AST_in = RefDNode(antlr::nullAST);
 		tmp48_AST = astFactory->create(antlr::RefAST(_t));
 		tmp48_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp48_AST));
-		antlr::ASTPair __currentAST166 = currentAST;
+		antlr::ASTPair __currentAST165 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),QUESTION);
@@ -5467,21 +5481,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST166;
-		_t = __t166;
+		currentAST = __currentAST165;
+		_t = __t165;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case AND_OP:
 	{
-		RefDNode __t167 = _t;
+		RefDNode __t166 = _t;
 		RefDNode tmp49_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp49_AST_in = RefDNode(antlr::nullAST);
 		tmp49_AST = astFactory->create(antlr::RefAST(_t));
 		tmp49_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp49_AST));
-		antlr::ASTPair __currentAST167 = currentAST;
+		antlr::ASTPair __currentAST166 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),AND_OP);
@@ -5492,21 +5506,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST167;
-		_t = __t167;
+		currentAST = __currentAST166;
+		_t = __t166;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case OR_OP:
 	{
-		RefDNode __t168 = _t;
+		RefDNode __t167 = _t;
 		RefDNode tmp50_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp50_AST_in = RefDNode(antlr::nullAST);
 		tmp50_AST = astFactory->create(antlr::RefAST(_t));
 		tmp50_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp50_AST));
-		antlr::ASTPair __currentAST168 = currentAST;
+		antlr::ASTPair __currentAST167 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),OR_OP);
@@ -5517,21 +5531,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST168;
-		_t = __t168;
+		currentAST = __currentAST167;
+		_t = __t167;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case XOR_OP:
 	{
-		RefDNode __t169 = _t;
+		RefDNode __t168 = _t;
 		RefDNode tmp51_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp51_AST_in = RefDNode(antlr::nullAST);
 		tmp51_AST = astFactory->create(antlr::RefAST(_t));
 		tmp51_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp51_AST));
-		antlr::ASTPair __currentAST169 = currentAST;
+		antlr::ASTPair __currentAST168 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),XOR_OP);
@@ -5542,21 +5556,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST169;
-		_t = __t169;
+		currentAST = __currentAST168;
+		_t = __t168;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case LOG_AND:
 	{
-		RefDNode __t170 = _t;
+		RefDNode __t169 = _t;
 		RefDNode tmp52_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp52_AST_in = RefDNode(antlr::nullAST);
 		tmp52_AST = astFactory->create(antlr::RefAST(_t));
 		tmp52_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp52_AST));
-		antlr::ASTPair __currentAST170 = currentAST;
+		antlr::ASTPair __currentAST169 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LOG_AND);
@@ -5567,21 +5581,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST170;
-		_t = __t170;
+		currentAST = __currentAST169;
+		_t = __t169;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case LOG_OR:
 	{
-		RefDNode __t171 = _t;
+		RefDNode __t170 = _t;
 		RefDNode tmp53_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp53_AST_in = RefDNode(antlr::nullAST);
 		tmp53_AST = astFactory->create(antlr::RefAST(_t));
 		tmp53_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp53_AST));
-		antlr::ASTPair __currentAST171 = currentAST;
+		antlr::ASTPair __currentAST170 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LOG_OR);
@@ -5592,21 +5606,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST171;
-		_t = __t171;
+		currentAST = __currentAST170;
+		_t = __t170;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case EQ_OP:
 	{
-		RefDNode __t172 = _t;
+		RefDNode __t171 = _t;
 		RefDNode tmp54_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp54_AST_in = RefDNode(antlr::nullAST);
 		tmp54_AST = astFactory->create(antlr::RefAST(_t));
 		tmp54_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp54_AST));
-		antlr::ASTPair __currentAST172 = currentAST;
+		antlr::ASTPair __currentAST171 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),EQ_OP);
@@ -5617,21 +5631,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST172;
-		_t = __t172;
+		currentAST = __currentAST171;
+		_t = __t171;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case NE_OP:
 	{
-		RefDNode __t173 = _t;
+		RefDNode __t172 = _t;
 		RefDNode tmp55_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp55_AST_in = RefDNode(antlr::nullAST);
 		tmp55_AST = astFactory->create(antlr::RefAST(_t));
 		tmp55_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp55_AST));
-		antlr::ASTPair __currentAST173 = currentAST;
+		antlr::ASTPair __currentAST172 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),NE_OP);
@@ -5642,21 +5656,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST173;
-		_t = __t173;
+		currentAST = __currentAST172;
+		_t = __t172;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case LE_OP:
 	{
-		RefDNode __t174 = _t;
+		RefDNode __t173 = _t;
 		RefDNode tmp56_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp56_AST_in = RefDNode(antlr::nullAST);
 		tmp56_AST = astFactory->create(antlr::RefAST(_t));
 		tmp56_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp56_AST));
-		antlr::ASTPair __currentAST174 = currentAST;
+		antlr::ASTPair __currentAST173 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LE_OP);
@@ -5667,21 +5681,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST174;
-		_t = __t174;
+		currentAST = __currentAST173;
+		_t = __t173;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case LT_OP:
 	{
-		RefDNode __t175 = _t;
+		RefDNode __t174 = _t;
 		RefDNode tmp57_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp57_AST_in = RefDNode(antlr::nullAST);
 		tmp57_AST = astFactory->create(antlr::RefAST(_t));
 		tmp57_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp57_AST));
-		antlr::ASTPair __currentAST175 = currentAST;
+		antlr::ASTPair __currentAST174 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LT_OP);
@@ -5692,21 +5706,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST175;
-		_t = __t175;
+		currentAST = __currentAST174;
+		_t = __t174;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case GE_OP:
 	{
-		RefDNode __t176 = _t;
+		RefDNode __t175 = _t;
 		RefDNode tmp58_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp58_AST_in = RefDNode(antlr::nullAST);
 		tmp58_AST = astFactory->create(antlr::RefAST(_t));
 		tmp58_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp58_AST));
-		antlr::ASTPair __currentAST176 = currentAST;
+		antlr::ASTPair __currentAST175 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),GE_OP);
@@ -5717,21 +5731,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST176;
-		_t = __t176;
+		currentAST = __currentAST175;
+		_t = __t175;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case GT_OP:
 	{
-		RefDNode __t177 = _t;
+		RefDNode __t176 = _t;
 		RefDNode tmp59_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp59_AST_in = RefDNode(antlr::nullAST);
 		tmp59_AST = astFactory->create(antlr::RefAST(_t));
 		tmp59_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp59_AST));
-		antlr::ASTPair __currentAST177 = currentAST;
+		antlr::ASTPair __currentAST176 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),GT_OP);
@@ -5742,21 +5756,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST177;
-		_t = __t177;
+		currentAST = __currentAST176;
+		_t = __t176;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case NOT_OP:
 	{
-		RefDNode __t178 = _t;
+		RefDNode __t177 = _t;
 		RefDNode tmp60_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp60_AST_in = RefDNode(antlr::nullAST);
 		tmp60_AST = astFactory->create(antlr::RefAST(_t));
 		tmp60_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp60_AST));
-		antlr::ASTPair __currentAST178 = currentAST;
+		antlr::ASTPair __currentAST177 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),NOT_OP);
@@ -5764,21 +5778,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST178;
-		_t = __t178;
+		currentAST = __currentAST177;
+		_t = __t177;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case PLUS:
 	{
-		RefDNode __t179 = _t;
+		RefDNode __t178 = _t;
 		RefDNode tmp61_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp61_AST_in = RefDNode(antlr::nullAST);
 		tmp61_AST = astFactory->create(antlr::RefAST(_t));
 		tmp61_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp61_AST));
-		antlr::ASTPair __currentAST179 = currentAST;
+		antlr::ASTPair __currentAST178 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),PLUS);
@@ -5789,21 +5803,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST179;
-		_t = __t179;
+		currentAST = __currentAST178;
+		_t = __t178;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case MINUS:
 	{
-		RefDNode __t180 = _t;
+		RefDNode __t179 = _t;
 		RefDNode tmp62_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp62_AST_in = RefDNode(antlr::nullAST);
 		tmp62_AST = astFactory->create(antlr::RefAST(_t));
 		tmp62_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp62_AST));
-		antlr::ASTPair __currentAST180 = currentAST;
+		antlr::ASTPair __currentAST179 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MINUS);
@@ -5814,21 +5828,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST180;
-		_t = __t180;
+		currentAST = __currentAST179;
+		_t = __t179;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case LTMARK:
 	{
-		RefDNode __t181 = _t;
+		RefDNode __t180 = _t;
 		RefDNode tmp63_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp63_AST_in = RefDNode(antlr::nullAST);
 		tmp63_AST = astFactory->create(antlr::RefAST(_t));
 		tmp63_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp63_AST));
-		antlr::ASTPair __currentAST181 = currentAST;
+		antlr::ASTPair __currentAST180 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LTMARK);
@@ -5839,21 +5853,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST181;
-		_t = __t181;
+		currentAST = __currentAST180;
+		_t = __t180;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case GTMARK:
 	{
-		RefDNode __t182 = _t;
+		RefDNode __t181 = _t;
 		RefDNode tmp64_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp64_AST_in = RefDNode(antlr::nullAST);
 		tmp64_AST = astFactory->create(antlr::RefAST(_t));
 		tmp64_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp64_AST));
-		antlr::ASTPair __currentAST182 = currentAST;
+		antlr::ASTPair __currentAST181 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),GTMARK);
@@ -5864,8 +5878,8 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST182;
-		_t = __t182;
+		currentAST = __currentAST181;
+		_t = __t181;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
@@ -5880,13 +5894,13 @@
 	}
 	case LOG_NEG:
 	{
-		RefDNode __t183 = _t;
+		RefDNode __t182 = _t;
 		RefDNode tmp65_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp65_AST_in = RefDNode(antlr::nullAST);
 		tmp65_AST = astFactory->create(antlr::RefAST(_t));
 		tmp65_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp65_AST));
-		antlr::ASTPair __currentAST183 = currentAST;
+		antlr::ASTPair __currentAST182 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LOG_NEG);
@@ -5894,21 +5908,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST183;
-		_t = __t183;
+		currentAST = __currentAST182;
+		_t = __t182;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case ASTERIX:
 	{
-		RefDNode __t184 = _t;
+		RefDNode __t183 = _t;
 		RefDNode tmp66_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp66_AST_in = RefDNode(antlr::nullAST);
 		tmp66_AST = astFactory->create(antlr::RefAST(_t));
 		tmp66_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp66_AST));
-		antlr::ASTPair __currentAST184 = currentAST;
+		antlr::ASTPair __currentAST183 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ASTERIX);
@@ -5919,21 +5933,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST184;
-		_t = __t184;
+		currentAST = __currentAST183;
+		_t = __t183;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case MATRIX_OP1:
 	{
-		RefDNode __t185 = _t;
+		RefDNode __t184 = _t;
 		RefDNode tmp67_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp67_AST_in = RefDNode(antlr::nullAST);
 		tmp67_AST = astFactory->create(antlr::RefAST(_t));
 		tmp67_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp67_AST));
-		antlr::ASTPair __currentAST185 = currentAST;
+		antlr::ASTPair __currentAST184 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MATRIX_OP1);
@@ -5944,21 +5958,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST185;
-		_t = __t185;
+		currentAST = __currentAST184;
+		_t = __t184;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case MATRIX_OP2:
 	{
-		RefDNode __t186 = _t;
+		RefDNode __t185 = _t;
 		RefDNode tmp68_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp68_AST_in = RefDNode(antlr::nullAST);
 		tmp68_AST = astFactory->create(antlr::RefAST(_t));
 		tmp68_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp68_AST));
-		antlr::ASTPair __currentAST186 = currentAST;
+		antlr::ASTPair __currentAST185 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MATRIX_OP2);
@@ -5969,21 +5983,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST186;
-		_t = __t186;
+		currentAST = __currentAST185;
+		_t = __t185;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case SLASH:
 	{
-		RefDNode __t187 = _t;
+		RefDNode __t186 = _t;
 		RefDNode tmp69_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp69_AST_in = RefDNode(antlr::nullAST);
 		tmp69_AST = astFactory->create(antlr::RefAST(_t));
 		tmp69_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp69_AST));
-		antlr::ASTPair __currentAST187 = currentAST;
+		antlr::ASTPair __currentAST186 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),SLASH);
@@ -5994,21 +6008,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST187;
-		_t = __t187;
+		currentAST = __currentAST186;
+		_t = __t186;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case MOD_OP:
 	{
-		RefDNode __t188 = _t;
+		RefDNode __t187 = _t;
 		RefDNode tmp70_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp70_AST_in = RefDNode(antlr::nullAST);
 		tmp70_AST = astFactory->create(antlr::RefAST(_t));
 		tmp70_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp70_AST));
-		antlr::ASTPair __currentAST188 = currentAST;
+		antlr::ASTPair __currentAST187 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MOD_OP);
@@ -6019,21 +6033,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST188;
-		_t = __t188;
+		currentAST = __currentAST187;
+		_t = __t187;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case POW:
 	{
-		RefDNode __t189 = _t;
+		RefDNode __t188 = _t;
 		RefDNode tmp71_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp71_AST_in = RefDNode(antlr::nullAST);
 		tmp71_AST = astFactory->create(antlr::RefAST(_t));
 		tmp71_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp71_AST));
-		antlr::ASTPair __currentAST189 = currentAST;
+		antlr::ASTPair __currentAST188 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),POW);
@@ -6044,21 +6058,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST189;
-		_t = __t189;
+		currentAST = __currentAST188;
+		_t = __t188;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case DEC:
 	{
-		RefDNode __t190 = _t;
+		RefDNode __t189 = _t;
 		RefDNode tmp72_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp72_AST_in = RefDNode(antlr::nullAST);
 		tmp72_AST = astFactory->create(antlr::RefAST(_t));
 		tmp72_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp72_AST));
-		antlr::ASTPair __currentAST190 = currentAST;
+		antlr::ASTPair __currentAST189 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),DEC);
@@ -6066,21 +6080,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST190;
-		_t = __t190;
+		currentAST = __currentAST189;
+		_t = __t189;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case INC:
 	{
-		RefDNode __t191 = _t;
+		RefDNode __t190 = _t;
 		RefDNode tmp73_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp73_AST_in = RefDNode(antlr::nullAST);
 		tmp73_AST = astFactory->create(antlr::RefAST(_t));
 		tmp73_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp73_AST));
-		antlr::ASTPair __currentAST191 = currentAST;
+		antlr::ASTPair __currentAST190 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),INC);
@@ -6088,21 +6102,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST191;
-		_t = __t191;
+		currentAST = __currentAST190;
+		_t = __t190;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case POSTDEC:
 	{
-		RefDNode __t192 = _t;
+		RefDNode __t191 = _t;
 		RefDNode tmp74_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp74_AST_in = RefDNode(antlr::nullAST);
 		tmp74_AST = astFactory->create(antlr::RefAST(_t));
 		tmp74_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp74_AST));
-		antlr::ASTPair __currentAST192 = currentAST;
+		antlr::ASTPair __currentAST191 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),POSTDEC);
@@ -6110,21 +6124,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST192;
-		_t = __t192;
+		currentAST = __currentAST191;
+		_t = __t191;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case POSTINC:
 	{
-		RefDNode __t193 = _t;
+		RefDNode __t192 = _t;
 		RefDNode tmp75_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp75_AST_in = RefDNode(antlr::nullAST);
 		tmp75_AST = astFactory->create(antlr::RefAST(_t));
 		tmp75_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp75_AST));
-		antlr::ASTPair __currentAST193 = currentAST;
+		antlr::ASTPair __currentAST192 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),POSTINC);
@@ -6132,8 +6146,8 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST193;
-		_t = __t193;
+		currentAST = __currentAST192;
+		_t = __t192;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
@@ -6193,12 +6207,12 @@
 	RefDNode e_AST = RefDNode(antlr::nullAST);
 	RefDNode e = RefDNode(antlr::nullAST);
 	
-	RefDNode __t195 = _t;
+	RefDNode __t194 = _t;
 	u = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode u_AST_in = RefDNode(antlr::nullAST);
 	u_AST = astFactory->create(antlr::RefAST(u));
 	astFactory->addASTChild(currentAST, antlr::RefAST(u_AST));
-	antlr::ASTPair __currentAST195 = currentAST;
+	antlr::ASTPair __currentAST194 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),UMINUS);
@@ -6208,8 +6222,8 @@
 	_t = _retTree;
 	e_AST = returnAST;
 	astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-	currentAST = __currentAST195;
-	_t = __t195;
+	currentAST = __currentAST194;
+	_t = __t194;
 	_t = _t->getNextSibling();
 	uminus_AST = RefDNode(currentAST.root);
 	
@@ -6247,11 +6261,11 @@
 	RefDNode ex_AST = RefDNode(antlr::nullAST);
 	RefDNode ex = RefDNode(antlr::nullAST);
 	
-	RefDNode __t197 = _t;
+	RefDNode __t196 = _t;
 	e = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode e_AST_in = RefDNode(antlr::nullAST);
 	e_AST = astFactory->create(antlr::RefAST(e));
-	antlr::ASTPair __currentAST197 = currentAST;
+	antlr::ASTPair __currentAST196 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),EXPR);
@@ -6260,8 +6274,8 @@
 	expr(_t);
 	_t = _retTree;
 	ex_AST = returnAST;
-	currentAST = __currentAST197;
-	_t = __t197;
+	currentAST = __currentAST196;
+	_t = __t196;
 	_t = _t->getNextSibling();
 	brace_expr_AST = RefDNode(currentAST.root);
 	
@@ -6288,12 +6302,12 @@
 	RefDNode ex_AST = RefDNode(antlr::nullAST);
 	RefDNode ex = RefDNode(antlr::nullAST);
 	
-	RefDNode __t199 = _t;
+	RefDNode __t198 = _t;
 	RefDNode tmp76_AST = RefDNode(antlr::nullAST);
 	RefDNode tmp76_AST_in = RefDNode(antlr::nullAST);
 	tmp76_AST = astFactory->create(antlr::RefAST(_t));
 	tmp76_AST_in = _t;
-	antlr::ASTPair __currentAST199 = currentAST;
+	antlr::ASTPair __currentAST198 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),EXPR);
@@ -6302,8 +6316,8 @@
 	expr(_t);
 	_t = _retTree;
 	ex_AST = returnAST;
-	currentAST = __currentAST199;
-	_t = __t199;
+	currentAST = __currentAST198;
+	_t = __t198;
 	_t = _t->getNextSibling();
 	unbrace_expr_AST = RefDNode(currentAST.root);
 	
@@ -6375,13 +6389,13 @@
 	switch ( _t->getType()) {
 	case ARRAYEXPR:
 	{
-		RefDNode __t202 = _t;
+		RefDNode __t201 = _t;
 		RefDNode tmp77_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp77_AST_in = RefDNode(antlr::nullAST);
 		tmp77_AST = astFactory->create(antlr::RefAST(_t));
 		tmp77_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp77_AST));
-		antlr::ASTPair __currentAST202 = currentAST;
+		antlr::ASTPair __currentAST201 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ARRAYEXPR);
@@ -6392,8 +6406,8 @@
 		arrayindex_list(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST202;
-		_t = __t202;
+		currentAST = __currentAST201;
+		_t = __t201;
 		_t = _t->getNextSibling();
 		array_expr_AST = RefDNode(currentAST.root);
 		break;
@@ -6470,13 +6484,13 @@
 	switch ( _t->getType()) {
 	case ARRAYEXPR:
 	{
-		RefDNode __t205 = _t;
+		RefDNode __t204 = _t;
 		RefDNode tmp78_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp78_AST_in = RefDNode(antlr::nullAST);
 		tmp78_AST = astFactory->create(antlr::RefAST(_t));
 		tmp78_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp78_AST));
-		antlr::ASTPair __currentAST205 = currentAST;
+		antlr::ASTPair __currentAST204 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ARRAYEXPR);
@@ -6487,8 +6501,8 @@
 		arrayindex_list(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST205;
-		_t = __t205;
+		currentAST = __currentAST204;
+		_t = __t204;
 		_t = _t->getNextSibling();
 		tag_array_expr_1st_AST = RefDNode(currentAST.root);
 		break;
@@ -6561,13 +6575,13 @@
 	switch ( _t->getType()) {
 	case ARRAYEXPR:
 	{
-		RefDNode __t208 = _t;
+		RefDNode __t207 = _t;
 		RefDNode tmp80_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp80_AST_in = RefDNode(antlr::nullAST);
 		tmp80_AST = astFactory->create(antlr::RefAST(_t));
 		tmp80_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp80_AST));
-		antlr::ASTPair __currentAST208 = currentAST;
+		antlr::ASTPair __currentAST207 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ARRAYEXPR);
@@ -6578,8 +6592,8 @@
 		arrayindex_list(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST208;
-		_t = __t208;
+		currentAST = __currentAST207;
+		_t = __t207;
 		_t = _t->getNextSibling();
 		tag_array_expr_AST = RefDNode(currentAST.root);
 		break;
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc2/src/GDLTreeParser.hpp cvs/gdl/src/GDLTreeParser.hpp
--- gdl-0.9rc2/src/GDLTreeParser.hpp	2009-01-20 12:33:52.000000000 -0700
+++ cvs/gdl/src/GDLTreeParser.hpp	2009-01-26 09:43:54.000000000 -0700
@@ -145,13 +145,12 @@
 	public: void procedure_def(RefDNode _t);
 	public: void function_def(RefDNode _t);
 	public: void forward_function(RefDNode _t);
-	public: void main_program(RefDNode _t);
+	public: void common_block(RefDNode _t);
+	public: void statement_list(RefDNode _t);
 	public: void interactive(RefDNode _t);
 	public: void statement(RefDNode _t);
-	public: void statement_list(RefDNode _t);
 	public: void parameter_declaration(RefDNode _t);
 	public: void keyword_declaration(RefDNode _t);
-	public: void common_block(RefDNode _t);
 	public: void caseswitch_body(RefDNode _t);
 	public: void expr(RefDNode _t);
 	public: void switch_statement(RefDNode _t);
Only in gdl-0.9rc2/src: KEYWORDS
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc2/src/prognode.cpp cvs/gdl/src/prognode.cpp
--- gdl-0.9rc2/src/prognode.cpp	2009-01-20 12:33:52.000000000 -0700
+++ cvs/gdl/src/prognode.cpp	2009-01-26 09:43:54.000000000 -0700
@@ -23,8 +23,25 @@
 
 #include "dinterpreter.hpp"
 
+#include "objects.hpp"
+
 using namespace std;
 
+bool ProgNode::ConstantNode()
+  {
+    if( this->getType() == GDLTokenTypes::SYSVAR)
+      {
+	// note: this works, because system variables are never 
+	//       passed by reference
+       SizeT rdOnlySize = sysVarRdOnlyList.size();
+         for( SizeT i=0; i<rdOnlySize; ++i)
+                  if( sysVarRdOnlyList[ i] == this->var)
+		    return true;
+      }
+
+    return this->getType() == GDLTokenTypes::CONSTANT;
+  }
+
 BaseGDL* ARRAYDEFNode::Eval()
 {
   // GDLInterpreter::
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc2/src/prognode.hpp cvs/gdl/src/prognode.hpp
--- gdl-0.9rc2/src/prognode.hpp	2009-01-20 12:33:54.000000000 -0700
+++ cvs/gdl/src/prognode.hpp	2009-01-26 09:43:54.000000000 -0700
@@ -91,10 +91,7 @@
   virtual BaseGDL* EvalNC(); // non-copy
   virtual void     Run();
 
-  bool ConstantNode()
-  {
-    return this->getType() == GDLTokenTypes::CONSTANT;
-  }
+  bool ConstantNode();
 
   ProgNodeP getFirstChild() const
   {
