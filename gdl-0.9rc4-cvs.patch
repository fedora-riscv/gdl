diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/config.h.in cvs/gdl/config.h.in
--- gdl-0.9rc4/config.h.in	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/config.h.in	2010-05-21 10:23:52.639905982 -0600
@@ -12,6 +12,9 @@
 /* Define to 1 if you have the <dlfcn.h> header file. */
 #undef HAVE_DLFCN_H
 
+/* Define to 1 if you have the <gshhs.h> header file. */
+#undef HAVE_GSHHS_H
+
 /* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
 
@@ -136,6 +139,9 @@
 /* Define if you want to use GRIB */
 #undef USE_GRIB
 
+/* Define if you want to use GSHHS */
+#undef USE_GSHHS
+
 /* Define if you want to use HDF */
 #undef USE_HDF
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/configure cvs/gdl/configure
--- gdl-0.9rc4/configure	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/configure	2010-07-07 14:40:58.445004719 -0600
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.65 for gdl 0.9rc4.
+# Generated by GNU Autoconf 2.65 for gdl 0.9rc4 CVS.
 #
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
@@ -530,22 +530,22 @@
 # Check that we are running under the correct shell.
 SHELL=${CONFIG_SHELL-/bin/sh}
 
-case X$lt_ECHO in
+case X$ECHO in
 X*--fallback-echo)
   # Remove one level of quotation (which was required for Make).
-  ECHO=`echo "$lt_ECHO" | sed 's,\\\\\$\\$0,'$0','`
+  ECHO=`echo "$ECHO" | sed 's,\\\\\$\\$0,'$0','`
   ;;
 esac
 
-ECHO=${lt_ECHO-echo}
+echo=${ECHO-echo}
 if test "X$1" = X--no-reexec; then
   # Discard the --no-reexec flag, and continue.
   shift
 elif test "X$1" = X--fallback-echo; then
   # Avoid inline document here, it may be left over
   :
-elif test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t' ; then
-  # Yippee, $ECHO works!
+elif test "X`($echo '\t') 2>/dev/null`" = 'X\t' ; then
+  # Yippee, $echo works!
   :
 else
   # Restart under the correct shell.
@@ -555,9 +555,9 @@
 if test "X$1" = X--fallback-echo; then
   # used as fallback echo
   shift
-  cat <<_LT_EOF
+  cat <<EOF
 $*
-_LT_EOF
+EOF
   exit 0
 fi
 
@@ -565,116 +565,121 @@
 # if CDPATH is set.
 (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
-if test -z "$lt_ECHO"; then
-  if test "X${echo_test_string+set}" != Xset; then
-    # find a string as large as possible, as long as the shell can cope with it
-    for cmd in 'sed 50q "$0"' 'sed 20q "$0"' 'sed 10q "$0"' 'sed 2q "$0"' 'echo test'; do
-      # expected sizes: less than 2Kb, 1Kb, 512 bytes, 16 bytes, ...
-      if { echo_test_string=`eval $cmd`; } 2>/dev/null &&
-	 { test "X$echo_test_string" = "X$echo_test_string"; } 2>/dev/null
-      then
-        break
-      fi
-    done
-  fi
+if test -z "$ECHO"; then
+if test "X${echo_test_string+set}" != Xset; then
+# find a string as large as possible, as long as the shell can cope with it
+  for cmd in 'sed 50q "$0"' 'sed 20q "$0"' 'sed 10q "$0"' 'sed 2q "$0"' 'echo test'; do
+    # expected sizes: less than 2Kb, 1Kb, 512 bytes, 16 bytes, ...
+    if (echo_test_string=`eval $cmd`) 2>/dev/null &&
+       echo_test_string=`eval $cmd` &&
+       (test "X$echo_test_string" = "X$echo_test_string") 2>/dev/null
+    then
+      break
+    fi
+  done
+fi
 
-  if test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t' &&
-     echo_testing_string=`{ $ECHO "$echo_test_string"; } 2>/dev/null` &&
-     test "X$echo_testing_string" = "X$echo_test_string"; then
-    :
-  else
-    # The Solaris, AIX, and Digital Unix default echo programs unquote
-    # backslashes.  This makes it impossible to quote backslashes using
-    #   echo "$something" | sed 's/\\/\\\\/g'
-    #
-    # So, first we look for a working echo in the user's PATH.
+if test "X`($echo '\t') 2>/dev/null`" = 'X\t' &&
+   echo_testing_string=`($echo "$echo_test_string") 2>/dev/null` &&
+   test "X$echo_testing_string" = "X$echo_test_string"; then
+  :
+else
+  # The Solaris, AIX, and Digital Unix default echo programs unquote
+  # backslashes.  This makes it impossible to quote backslashes using
+  #   echo "$something" | sed 's/\\/\\\\/g'
+  #
+  # So, first we look for a working echo in the user's PATH.
 
-    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-    for dir in $PATH /usr/ucb; do
-      IFS="$lt_save_ifs"
-      if (test -f $dir/echo || test -f $dir/echo$ac_exeext) &&
-         test "X`($dir/echo '\t') 2>/dev/null`" = 'X\t' &&
-         echo_testing_string=`($dir/echo "$echo_test_string") 2>/dev/null` &&
-         test "X$echo_testing_string" = "X$echo_test_string"; then
-        ECHO="$dir/echo"
-        break
-      fi
-    done
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for dir in $PATH /usr/ucb; do
     IFS="$lt_save_ifs"
+    if (test -f $dir/echo || test -f $dir/echo$ac_exeext) &&
+       test "X`($dir/echo '\t') 2>/dev/null`" = 'X\t' &&
+       echo_testing_string=`($dir/echo "$echo_test_string") 2>/dev/null` &&
+       test "X$echo_testing_string" = "X$echo_test_string"; then
+      echo="$dir/echo"
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
 
-    if test "X$ECHO" = Xecho; then
-      # We didn't find a better echo, so look for alternatives.
-      if test "X`{ print -r '\t'; } 2>/dev/null`" = 'X\t' &&
-         echo_testing_string=`{ print -r "$echo_test_string"; } 2>/dev/null` &&
-         test "X$echo_testing_string" = "X$echo_test_string"; then
-        # This shell has a builtin print -r that does the trick.
-        ECHO='print -r'
-      elif { test -f /bin/ksh || test -f /bin/ksh$ac_exeext; } &&
-	   test "X$CONFIG_SHELL" != X/bin/ksh; then
-        # If we have ksh, try running configure again with it.
-        ORIGINAL_CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
-        export ORIGINAL_CONFIG_SHELL
-        CONFIG_SHELL=/bin/ksh
-        export CONFIG_SHELL
-        exec $CONFIG_SHELL "$0" --no-reexec ${1+"$@"}
-      else
-        # Try using printf.
-        ECHO='printf %s\n'
-        if test "X`{ $ECHO '\t'; } 2>/dev/null`" = 'X\t' &&
-	   echo_testing_string=`{ $ECHO "$echo_test_string"; } 2>/dev/null` &&
+  if test "X$echo" = Xecho; then
+    # We didn't find a better echo, so look for alternatives.
+    if test "X`(print -r '\t') 2>/dev/null`" = 'X\t' &&
+       echo_testing_string=`(print -r "$echo_test_string") 2>/dev/null` &&
+       test "X$echo_testing_string" = "X$echo_test_string"; then
+      # This shell has a builtin print -r that does the trick.
+      echo='print -r'
+    elif (test -f /bin/ksh || test -f /bin/ksh$ac_exeext) &&
+	 test "X$CONFIG_SHELL" != X/bin/ksh; then
+      # If we have ksh, try running configure again with it.
+      ORIGINAL_CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}
+      export ORIGINAL_CONFIG_SHELL
+      CONFIG_SHELL=/bin/ksh
+      export CONFIG_SHELL
+      exec $CONFIG_SHELL "$0" --no-reexec ${1+"$@"}
+    else
+      # Try using printf.
+      echo='printf %s\n'
+      if test "X`($echo '\t') 2>/dev/null`" = 'X\t' &&
+	 echo_testing_string=`($echo "$echo_test_string") 2>/dev/null` &&
+	 test "X$echo_testing_string" = "X$echo_test_string"; then
+	# Cool, printf works
+	:
+      elif echo_testing_string=`($ORIGINAL_CONFIG_SHELL "$0" --fallback-echo '\t') 2>/dev/null` &&
+	   test "X$echo_testing_string" = 'X\t' &&
+	   echo_testing_string=`($ORIGINAL_CONFIG_SHELL "$0" --fallback-echo "$echo_test_string") 2>/dev/null` &&
 	   test "X$echo_testing_string" = "X$echo_test_string"; then
-	  # Cool, printf works
-	  :
-        elif echo_testing_string=`($ORIGINAL_CONFIG_SHELL "$0" --fallback-echo '\t') 2>/dev/null` &&
-	     test "X$echo_testing_string" = 'X\t' &&
-	     echo_testing_string=`($ORIGINAL_CONFIG_SHELL "$0" --fallback-echo "$echo_test_string") 2>/dev/null` &&
-	     test "X$echo_testing_string" = "X$echo_test_string"; then
-	  CONFIG_SHELL=$ORIGINAL_CONFIG_SHELL
-	  export CONFIG_SHELL
-	  SHELL="$CONFIG_SHELL"
-	  export SHELL
-	  ECHO="$CONFIG_SHELL $0 --fallback-echo"
-        elif echo_testing_string=`($CONFIG_SHELL "$0" --fallback-echo '\t') 2>/dev/null` &&
-	     test "X$echo_testing_string" = 'X\t' &&
-	     echo_testing_string=`($CONFIG_SHELL "$0" --fallback-echo "$echo_test_string") 2>/dev/null` &&
-	     test "X$echo_testing_string" = "X$echo_test_string"; then
-	  ECHO="$CONFIG_SHELL $0 --fallback-echo"
-        else
-	  # maybe with a smaller string...
-	  prev=:
-
-	  for cmd in 'echo test' 'sed 2q "$0"' 'sed 10q "$0"' 'sed 20q "$0"' 'sed 50q "$0"'; do
-	    if { test "X$echo_test_string" = "X`eval $cmd`"; } 2>/dev/null
-	    then
-	      break
-	    fi
-	    prev="$cmd"
-	  done
+	CONFIG_SHELL=$ORIGINAL_CONFIG_SHELL
+	export CONFIG_SHELL
+	SHELL="$CONFIG_SHELL"
+	export SHELL
+	echo="$CONFIG_SHELL $0 --fallback-echo"
+      elif echo_testing_string=`($CONFIG_SHELL "$0" --fallback-echo '\t') 2>/dev/null` &&
+	   test "X$echo_testing_string" = 'X\t' &&
+	   echo_testing_string=`($CONFIG_SHELL "$0" --fallback-echo "$echo_test_string") 2>/dev/null` &&
+	   test "X$echo_testing_string" = "X$echo_test_string"; then
+	echo="$CONFIG_SHELL $0 --fallback-echo"
+      else
+	# maybe with a smaller string...
+	prev=:
 
-	  if test "$prev" != 'sed 50q "$0"'; then
-	    echo_test_string=`eval $prev`
-	    export echo_test_string
-	    exec ${ORIGINAL_CONFIG_SHELL-${CONFIG_SHELL-/bin/sh}} "$0" ${1+"$@"}
-	  else
-	    # Oops.  We lost completely, so just stick with echo.
-	    ECHO=echo
+	for cmd in 'echo test' 'sed 2q "$0"' 'sed 10q "$0"' 'sed 20q "$0"' 'sed 50q "$0"'; do
+	  if (test "X$echo_test_string" = "X`eval $cmd`") 2>/dev/null
+	  then
+	    break
 	  fi
-        fi
+	  prev="$cmd"
+	done
+
+	if test "$prev" != 'sed 50q "$0"'; then
+	  echo_test_string=`eval $prev`
+	  export echo_test_string
+	  exec ${ORIGINAL_CONFIG_SHELL-${CONFIG_SHELL-/bin/sh}} "$0" ${1+"$@"}
+	else
+	  # Oops.  We lost completely, so just stick with echo.
+	  echo=echo
+	fi
       fi
     fi
   fi
 fi
+fi
 
 # Copy echo and quote the copy suitably for passing to libtool from
 # the Makefile, instead of quoting the original, which is used later.
-lt_ECHO=$ECHO
-if test "X$lt_ECHO" = "X$CONFIG_SHELL $0 --fallback-echo"; then
-   lt_ECHO="$CONFIG_SHELL \\\$\$0 --fallback-echo"
+ECHO=$echo
+if test "X$ECHO" = "X$CONFIG_SHELL $0 --fallback-echo"; then
+   ECHO="$CONFIG_SHELL \\\$\$0 --fallback-echo"
 fi
 
 
 
 
+tagnames=${tagnames+${tagnames},}CXX
+
+tagnames=${tagnames+${tagnames},}F77
+
 test -n "$DJDIR" || exec 7<&0 </dev/null
 exec 6>&1
 
@@ -698,8 +703,8 @@
 # Identity of this package.
 PACKAGE_NAME='gdl'
 PACKAGE_TARNAME='gdl'
-PACKAGE_VERSION='0.9rc4'
-PACKAGE_STRING='gdl 0.9rc4'
+PACKAGE_VERSION='0.9rc4 CVS'
+PACKAGE_STRING='gdl 0.9rc4 CVS'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
@@ -739,9 +744,7 @@
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='am__EXEEXT_FALSE
-am__EXEEXT_TRUE
-LTLIBOBJS
+ac_subst_vars='LTLIBOBJS
 LIBOBJS
 EXT_INCLUDES
 EXT_LIBS
@@ -756,22 +759,15 @@
 BUILDASLIBRARY_FALSE
 BUILDASLIBRARY_TRUE
 HAVE_64BIT_OS
+LIBTOOL
+ac_ct_F77
+FFLAGS
+F77
 CXXCPP
 CPP
-OTOOL64
-OTOOL
-LIPO
-NMEDIT
-DSYMUTIL
-lt_ECHO
 AR
-OBJDUMP
+ECHO
 LN_S
-NM
-ac_ct_DUMPBIN
-DUMPBIN
-LD
-FGREP
 EGREP
 GREP
 SED
@@ -789,7 +785,6 @@
 build_vendor
 build_cpu
 build
-LIBTOOL
 RANLIB
 am__fastdepCXX_FALSE
 am__fastdepCXX_TRUE
@@ -814,7 +809,6 @@
 SET_MAKE
 AWK
 mkdir_p
-MKDIR_P
 INSTALL_STRIP_PROGRAM
 STRIP
 install_sh
@@ -826,7 +820,6 @@
 VERSION
 PACKAGE
 CYGPATH_W
-am__isrc
 INSTALL_DATA
 INSTALL_SCRIPT
 INSTALL_PROGRAM
@@ -874,10 +867,11 @@
 enable_dependency_tracking
 enable_shared
 enable_static
-with_pic
 enable_fast_install
 with_gnu_ld
 enable_libtool_lock
+with_pic
+with_tags
 enable_python_module
 with_ncursesdir
 with_readlinedir
@@ -899,6 +893,7 @@
 enable_python_version
 with_udunits
 with_grib
+with_gshhs
 '
       ac_precious_vars='build_alias
 host_alias
@@ -913,6 +908,8 @@
 CFLAGS
 CPP
 CXXCPP
+F77
+FFLAGS
 XMKMF'
 
 
@@ -1455,7 +1452,7 @@
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures gdl 0.9rc4 to adapt to many kinds of systems.
+\`configure' configures gdl 0.9rc4 CVS to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1529,7 +1526,7 @@
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of gdl 0.9rc4:";;
+     short | recursive ) echo "Configuration of gdl 0.9rc4 CVS:";;
    esac
   cat <<\_ACEOF
 
@@ -1551,9 +1548,10 @@
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
   --with-pic              try to use only PIC/non-PIC objects [default=use
                           both]
-  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
+  --with-tags[=TAGS]      include additional configurations [automatic]
   --with-ncursesdir=DIR   specify the ncurses (or curses) directory tree
   --with-readlinedir=DIR  specify the GNU readline directory tree
   --with-zlibdir=DIR      specify the Zlib directory tree
@@ -1572,6 +1570,7 @@
   --with-python=DIR       use Python package (with optional path DIR)
   --with-udunits=DIR      use UDUNITS-2 package (with optional path DIR)
   --with-grib=DIR         use GRIB package (with optional path DIR)
+  --with-gshhs=DIR        use GSHHS package (with optional path DIR)
 
 Some influential environment variables:
   CXX         C++ compiler command
@@ -1585,6 +1584,8 @@
   CFLAGS      C compiler flags
   CPP         C preprocessor
   CXXCPP      C++ preprocessor
+  F77         Fortran 77 compiler command
+  FFLAGS      Fortran 77 compiler flags
   XMKMF       Path to xmkmf, Makefile generator for X Window System
 
 Use these variables to override the choices made by `configure' or to help
@@ -1653,7 +1654,7 @@
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-gdl configure 0.9rc4
+gdl configure 0.9rc4 CVS
 generated by GNU Autoconf 2.65
 
 Copyright (C) 2009 Free Software Foundation, Inc.
@@ -1789,37 +1790,6 @@
 
 } # ac_fn_c_try_link
 
-# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
-# -------------------------------------------------------
-# Tests whether HEADER exists and can be compiled using the include files in
-# INCLUDES, setting the cache variable VAR accordingly.
-ac_fn_c_check_header_compile ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-#include <$2>
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  eval "$3=yes"
-else
-  eval "$3=no"
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
-
-} # ac_fn_c_check_header_compile
-
 # ac_fn_c_try_cpp LINENO
 # ----------------------
 # Try to preprocess conftest.$ac_ext, and return whether this succeeded.
@@ -1857,6 +1827,93 @@
 
 } # ac_fn_c_try_cpp
 
+# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists, giving a warning if it cannot be compiled using
+# the include files in INCLUDES and setting the cache variable VAR
+# accordingly.
+ac_fn_c_check_header_mongrel ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 usability" >&5
+$as_echo_n "checking $2 usability... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_header_compiler=yes
+else
+  ac_header_compiler=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 presence" >&5
+$as_echo_n "checking $2 presence... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <$2>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  ac_header_preproc=yes
+else
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((
+  yes:no: )
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: $2: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: $2:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: $2: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
+    ;;
+esac
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  eval "$3=\$ac_header_compiler"
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_header_mongrel
+
 # ac_fn_c_try_run LINENO
 # ----------------------
 # Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
@@ -1899,6 +1956,37 @@
 
 } # ac_fn_c_try_run
 
+# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists and can be compiled using the include files in
+# INCLUDES, setting the cache variable VAR accordingly.
+ac_fn_c_check_header_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+
+} # ac_fn_c_check_header_compile
+
 # ac_fn_c_check_func LINENO FUNC VAR
 # ----------------------------------
 # Tests whether FUNC exists, setting the cache variable VAR accordingly
@@ -2049,44 +2137,128 @@
 
 } # ac_fn_cxx_try_link
 
-# ac_fn_cxx_check_func LINENO FUNC VAR
-# ------------------------------------
-# Tests whether FUNC exists, setting the cache variable VAR accordingly
-ac_fn_cxx_check_func ()
+# ac_fn_f77_try_compile LINENO
+# ----------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_f77_try_compile ()
 {
   as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
-  $as_echo_n "(cached) " >&6
+  rm -f conftest.$ac_objext
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_f77_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then :
+  ac_retval=0
 else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $2 innocuous_$2
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $2 (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
+	ac_retval=1
+fi
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  as_fn_set_status $ac_retval
 
-#undef $2
+} # ac_fn_f77_try_compile
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $2 ();
-/* The GNU C library defines this for functions which it implements
+# ac_fn_f77_try_link LINENO
+# -------------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded.
+ac_fn_f77_try_link ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext conftest$ac_exeext
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_f77_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 $as_test_x conftest$ac_exeext
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
+  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
+  # interfere with the next link command; also delete a directory that is
+  # left behind by Apple's compiler.  We do this before executing the actions.
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  as_fn_set_status $ac_retval
+
+} # ac_fn_f77_try_link
+
+# ac_fn_cxx_check_func LINENO FUNC VAR
+# ------------------------------------
+# Tests whether FUNC exists, setting the cache variable VAR accordingly
+ac_fn_cxx_check_func ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if { as_var=$3; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $2 innocuous_$2
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $2 (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $2
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $2 ();
+/* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
 #if defined __stub_$2 || defined __stub___$2
@@ -2237,7 +2409,7 @@
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by gdl $as_me 0.9rc4, which was
+It was created by gdl $as_me 0.9rc4 CVS, which was
 generated by GNU Autoconf 2.65.  Invocation command line was
 
   $ $0 $@
@@ -2597,18 +2769,18 @@
 if test "x$with_netcdf"      = "x"; then with_netcdf=yes;      fi
 if test "x$with_hdf"         = "x"; then with_hdf=yes;         fi
 if test "x$with_hdf5"        = "x"; then with_hdf5=yes;        fi
-if test "x$with_fftw"        = "x"; then with_fftw=no;         fi
+if test "x$with_fftw"        = "x"; then with_fftw=auto;       fi
 if test "x$with_libproj4"    = "x"; then with_libproj4=no;     fi
 if test "x$with_mpich"       = "x"; then with_mpich=no;        fi
 if test "x$with_python"      = "x"; then with_python=yes;      fi
+if test "x$with_gshhs"       = "x"; then with_gshhs=no;        fi
 
 datasubdir="gnudatalanguage"
 
 
 ac_config_headers="$ac_config_headers config.h"
 
-am__api_version='1.11'
-
+am__api_version="1.9"
 ac_aux_dir=
 for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
   for ac_t in install-sh install.sh shtool; do
@@ -2730,29 +2902,16 @@
 # Just in case
 sleep 1
 echo timestamp > conftest.file
-# Reject unsafe characters in $srcdir or the absolute working directory
-# name.  Accept space and tab only in the latter.
-am_lf='
-'
-case `pwd` in
-  *[\\\"\#\$\&\'\`$am_lf]*)
-    as_fn_error "unsafe absolute working directory name" "$LINENO" 5;;
-esac
-case $srcdir in
-  *[\\\"\#\$\&\'\`$am_lf\ \	]*)
-    as_fn_error "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
-esac
-
 # Do `set' in a subshell so we don't clobber the current shell's
 # arguments.  Must try -L first in case configure is actually a
 # symlink; some systems play weird games with the mod time of symlinks
 # (eg FreeBSD returns the mod time of the symlink's containing
 # directory).
 if (
-   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+   set X `ls -Lt $srcdir/configure conftest.file 2> /dev/null`
    if test "$*" = "X"; then
       # -L didn't work.
-      set X `ls -t "$srcdir/configure" conftest.file`
+      set X `ls -t $srcdir/configure conftest.file`
    fi
    rm -f conftest.file
    if test "$*" != "X $srcdir/configure conftest.file" \
@@ -2790,14 +2949,7 @@
 # expand $ac_aux_dir to an absolute path
 am_aux_dir=`cd $ac_aux_dir && pwd`
 
-if test x"${MISSING+set}" != xset; then
-  case $am_aux_dir in
-  *\ * | *\	*)
-    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
-  *)
-    MISSING="\${SHELL} $am_aux_dir/missing" ;;
-  esac
-fi
+test x"${MISSING+set}" = xset || MISSING="\${SHELL} $am_aux_dir/missing"
 # Use eval to expand $SHELL
 if eval "$MISSING --run true"; then
   am_missing_run="$MISSING --run "
@@ -2807,162 +2959,38 @@
 $as_echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
 fi
 
-if test x"${install_sh}" != xset; then
-  case $am_aux_dir in
-  *\ * | *\	*)
-    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
-  *)
-    install_sh="\${SHELL} $am_aux_dir/install-sh"
-  esac
-fi
-
-# Installed binaries are usually stripped using `strip' when the user
-# run `make install-strip'.  However `strip' might not be the right
-# tool to use in cross-compilation environments, therefore Automake
-# will honor the `STRIP' environment variable to overrule this program.
-if test "$cross_compiling" != no; then
-  if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
-set dummy ${ac_tool_prefix}strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_STRIP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$STRIP"; then
-  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-STRIP=$ac_cv_prog_STRIP
-if test -n "$STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
-$as_echo "$STRIP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_STRIP"; then
-  ac_ct_STRIP=$STRIP
-  # Extract the first word of "strip", so it can be a program name with args.
-set dummy strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_STRIP"; then
-  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_STRIP="strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
-if test -n "$ac_ct_STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
-$as_echo "$ac_ct_STRIP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_STRIP" = x; then
-    STRIP=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    STRIP=$ac_ct_STRIP
-  fi
-else
-  STRIP="$ac_cv_prog_STRIP"
-fi
-
-fi
-INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a thread-safe mkdir -p" >&5
-$as_echo_n "checking for a thread-safe mkdir -p... " >&6; }
-if test -z "$MKDIR_P"; then
-  if test "${ac_cv_path_mkdir+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/opt/sfw/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in mkdir gmkdir; do
-	 for ac_exec_ext in '' $ac_executable_extensions; do
-	   { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; } || continue
-	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
-	     'mkdir (GNU coreutils) '* | \
-	     'mkdir (coreutils) '* | \
-	     'mkdir (fileutils) '4.1*)
-	       ac_cv_path_mkdir=$as_dir/$ac_prog$ac_exec_ext
-	       break 3;;
-	   esac
-	 done
-       done
+if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
+  # We used to keeping the `.' as first argument, in order to
+  # allow $(mkdir_p) to be used without argument.  As in
+  #   $(mkdir_p) $(somedir)
+  # where $(somedir) is conditionally defined.  However this is wrong
+  # for two reasons:
+  #  1. if the package is installed by a user who cannot write `.'
+  #     make install will fail,
+  #  2. the above comment should most certainly read
+  #     $(mkdir_p) $(DESTDIR)$(somedir)
+  #     so it does not work when $(somedir) is undefined and
+  #     $(DESTDIR) is not.
+  #  To support the latter case, we have to write
+  #     test -z "$(somedir)" || $(mkdir_p) $(DESTDIR)$(somedir),
+  #  so the `.' trick is pointless.
+  mkdir_p='mkdir -p --'
+else
+  # On NextStep and OpenStep, the `mkdir' command does not
+  # recognize any option.  It will interpret all options as
+  # directories to create, and then abort because `.' already
+  # exists.
+  for d in ./-p ./--version;
+  do
+    test -d $d && rmdir $d
   done
-IFS=$as_save_IFS
-
-fi
-
-  test -d ./--version && rmdir ./--version
-  if test "${ac_cv_path_mkdir+set}" = set; then
-    MKDIR_P="$ac_cv_path_mkdir -p"
+  # $(mkinstalldirs) is defined by Automake if mkinstalldirs exists.
+  if test -f "$ac_aux_dir/mkinstalldirs"; then
+    mkdir_p='$(mkinstalldirs)'
   else
-    # As a last resort, use the slow shell script.  Don't cache a
-    # value for MKDIR_P within a source directory, because that will
-    # break other packages using the cache if that directory is
-    # removed, or if the value is a relative name.
-    MKDIR_P="$ac_install_sh -d"
+    mkdir_p='$(install_sh) -d'
   fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $MKDIR_P" >&5
-$as_echo "$MKDIR_P" >&6; }
-
-mkdir_p="$MKDIR_P"
-case $mkdir_p in
-  [\\/$]* | ?:[\\/]*) ;;
-  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
-esac
 
 for ac_prog in gawk mawk nawk awk
 do
@@ -3046,14 +3074,10 @@
 fi
 rmdir .tst 2>/dev/null
 
-if test "`cd $srcdir && pwd`" != "`pwd`"; then
-  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
-  # is not polluted with repeated "-I."
-  am__isrc=' -I$(srcdir)'
-  # test to see if srcdir already configured
-  if test -f $srcdir/config.status; then
-    as_fn_error "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
-  fi
+# test to see if srcdir already configured
+if test "`cd $srcdir && pwd`" != "`pwd`" &&
+   test -f $srcdir/config.status; then
+  as_fn_error "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
 fi
 
 # test whether we have cygpath
@@ -3068,7 +3092,7 @@
 
 # Define the identity of the package.
  PACKAGE='gdl'
- VERSION='0.9rc4'
+ VERSION='0.9rc4 CVS'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -3096,45 +3120,23 @@
 
 MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
 
-# We need awk for the "check" target.  The system "awk" is bad on
-# some platforms.
-# Always define AMTAR for backward compatibility.
-
-AMTAR=${AMTAR-"${am_missing_run}tar"}
-
-am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
-
-
-
-
-
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+install_sh=${install_sh-"$am_aux_dir/install-sh"}
 
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-if test -z "$CXX"; then
-  if test -n "$CCC"; then
-    CXX=$CCC
-  else
-    if test -n "$ac_tool_prefix"; then
-  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+if test "$cross_compiling" != no; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CXX+set}" = set; then :
+if test "${ac_cv_prog_STRIP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$CXX"; then
-  ac_cv_prog_CXX="$CXX" # Let the user override the test.
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -3143,7 +3145,131 @@
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
+$as_echo "$STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
+$as_echo "$ac_ct_STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    STRIP=$ac_ct_STRIP
+  fi
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+fi
+INSTALL_STRIP_PROGRAM="\${SHELL} \$(install_sh) -c -s"
+
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+# Always define AMTAR for backward compatibility.
+
+AMTAR=${AMTAR-"${am_missing_run}tar"}
+
+am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
+
+
+
+
+
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+if test -z "$CXX"; then
+  if test -n "$CCC"; then
+    CXX=$CCC
+  else
+    if test -n "$ac_tool_prefix"; then
+  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_CXX+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CXX"; then
+  ac_cv_prog_CXX="$CXX" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -3629,7 +3755,7 @@
 am_make=${MAKE-make}
 cat > confinc << 'END'
 am__doit:
-	@echo this is the am__doit target
+	@echo done
 .PHONY: am__doit
 END
 # If we don't find an include directive, just comment out the code.
@@ -3640,24 +3766,24 @@
 _am_result=none
 # First try GNU make style include.
 echo "include confinc" > confmf
-# Ignore all kinds of additional output from `make'.
-case `$am_make -s -f confmf 2> /dev/null` in #(
-*the\ am__doit\ target*)
-  am__include=include
-  am__quote=
-  _am_result=GNU
-  ;;
-esac
+# We grep out `Entering directory' and `Leaving directory'
+# messages which can occur if `w' ends up in MAKEFLAGS.
+# In particular we don't look at `^make:' because GNU make might
+# be invoked under some other name (usually "gmake"), in which
+# case it prints its new name instead of `make'.
+if test "`$am_make -s -f confmf 2> /dev/null | grep -v 'ing directory'`" = "done"; then
+   am__include=include
+   am__quote=
+   _am_result=GNU
+fi
 # Now try BSD make style include.
 if test "$am__include" = "#"; then
    echo '.include "confinc"' > confmf
-   case `$am_make -s -f confmf 2> /dev/null` in #(
-   *the\ am__doit\ target*)
-     am__include=.include
-     am__quote="\""
-     _am_result=BSD
-     ;;
-   esac
+   if test "`$am_make -s -f confmf 2> /dev/null`" = "done"; then
+      am__include=.include
+      am__quote="\""
+      _am_result=BSD
+   fi
 fi
 
 
@@ -3674,7 +3800,9 @@
   am_depcomp="$ac_aux_dir/depcomp"
   AMDEPBACKSLASH='\'
 fi
- if test "x$enable_dependency_tracking" != xno; then
+
+
+if test "x$enable_dependency_tracking" != xno; then
   AMDEP_TRUE=
   AMDEP_FALSE='#'
 else
@@ -3684,6 +3812,7 @@
 
 
 
+
 depcc="$CXX"  am_compiler_list=
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
@@ -3714,11 +3843,6 @@
   if test "$am_compiler_list" = ""; then
      am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
   fi
-  am__universal=false
-  case " $depcc " in #(
-     *\ -arch\ *\ -arch\ *) am__universal=true ;;
-     esac
-
   for depmode in $am_compiler_list; do
     # Setup a source with many dependencies, because some compilers
     # like to wrap large dependency lists on column 80 (with \), and
@@ -3736,17 +3860,7 @@
     done
     echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
-    # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
-    am__obj=sub/conftest.${OBJEXT-o}
-    am__minus_obj="-o $am__obj"
     case $depmode in
-    gcc)
-      # This depmode causes a compiler race in universal mode.
-      test "$am__universal" = false || continue
-      ;;
     nosideeffect)
       # after this tag, mechanisms are not by side-effect, so they'll
       # only be used when explicitly requested
@@ -3756,23 +3870,18 @@
 	break
       fi
       ;;
-    msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
-      # not run yet.  These depmodes are late enough in the game, and
-      # so weak that their functioning should not be impacted.
-      am__obj=conftest.${OBJEXT-o}
-      am__minus_obj=
-      ;;
     none) break ;;
     esac
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.
     if depmode=$depmode \
-       source=sub/conftest.c object=$am__obj \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
        depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
-       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
          >/dev/null 2>conftest.err &&
-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
        grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
        ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
       # icc doesn't choke on unknown options, it will just issue warnings
       # or remarks (even with -Werror).  So we grep stderr for any message
@@ -3800,7 +3909,9 @@
 $as_echo "$am_cv_CXX_dependencies_compiler_type" >&6; }
 CXXDEPMODE=depmode=$am_cv_CXX_dependencies_compiler_type
 
- if
+
+
+if
   test "x$enable_dependency_tracking" != xno \
   && test "$am_cv_CXX_dependencies_compiler_type" = gcc3; then
   am__fastdepCXX_TRUE=
@@ -3903,30 +4014,77 @@
   RANLIB="$ac_cv_prog_RANLIB"
 fi
 
-case `pwd` in
-  *\ * | *\	*)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
-$as_echo "$as_me: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&2;} ;;
-esac
-
-
-
-macro_version='2.2.6b'
-macro_revision='1.3017'
-
-
-
-
-
-
-
-
+# Check whether --enable-shared was given.
+if test "${enable_shared+set}" = set; then :
+  enableval=$enable_shared; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_shared=yes ;;
+    no) enable_shared=no ;;
+    *)
+      enable_shared=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_shared=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_shared=yes
+fi
 
 
+# Check whether --enable-static was given.
+if test "${enable_static+set}" = set; then :
+  enableval=$enable_static; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_static=yes ;;
+    no) enable_static=no ;;
+    *)
+     enable_static=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_static=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_static=yes
+fi
 
 
+# Check whether --enable-fast-install was given.
+if test "${enable_fast_install+set}" = set; then :
+  enableval=$enable_fast_install; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_fast_install=yes ;;
+    no) enable_fast_install=no ;;
+    *)
+      enable_fast_install=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_fast_install=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_fast_install=yes
+fi
 
-ltmain="$ac_aux_dir/ltmain.sh"
 
 # Make sure we can run config.sub.
 $SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
@@ -4569,11 +4727,6 @@
   if test "$am_compiler_list" = ""; then
      am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
   fi
-  am__universal=false
-  case " $depcc " in #(
-     *\ -arch\ *\ -arch\ *) am__universal=true ;;
-     esac
-
   for depmode in $am_compiler_list; do
     # Setup a source with many dependencies, because some compilers
     # like to wrap large dependency lists on column 80 (with \), and
@@ -4591,17 +4744,7 @@
     done
     echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
-    # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
-    am__obj=sub/conftest.${OBJEXT-o}
-    am__minus_obj="-o $am__obj"
     case $depmode in
-    gcc)
-      # This depmode causes a compiler race in universal mode.
-      test "$am__universal" = false || continue
-      ;;
     nosideeffect)
       # after this tag, mechanisms are not by side-effect, so they'll
       # only be used when explicitly requested
@@ -4611,23 +4754,18 @@
 	break
       fi
       ;;
-    msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
-      # not run yet.  These depmodes are late enough in the game, and
-      # so weak that their functioning should not be impacted.
-      am__obj=conftest.${OBJEXT-o}
-      am__minus_obj=
-      ;;
     none) break ;;
     esac
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.
     if depmode=$depmode \
-       source=sub/conftest.c object=$am__obj \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
        depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
-       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
          >/dev/null 2>conftest.err &&
-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
        grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
        ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
       # icc doesn't choke on unknown options, it will just issue warnings
       # or remarks (even with -Werror).  So we grep stderr for any message
@@ -4655,7 +4793,9 @@
 $as_echo "$am_cv_CC_dependencies_compiler_type" >&6; }
 CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
 
- if
+
+
+if
   test "x$enable_dependency_tracking" != xno \
   && test "$am_cv_CC_dependencies_compiler_type" = gcc3; then
   am__fastdepCC_TRUE=
@@ -4668,85 +4808,62 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
 $as_echo_n "checking for a sed that does not truncate output... " >&6; }
-if test "${ac_cv_path_SED+set}" = set; then :
+if test "${lt_cv_path_SED+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-            ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
-     for ac_i in 1 2 3 4 5 6 7; do
-       ac_script="$ac_script$as_nl$ac_script"
-     done
-     echo "$ac_script" 2>/dev/null | sed 99q >conftest.sed
-     { ac_script=; unset ac_script;}
-     if test -z "$SED"; then
-  ac_path_SED_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+  # Loop through the user's path and test for sed and gsed.
+# Then use that list of sed's as ones to test for truncation.
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-    for ac_prog in sed gsed; do
+  for lt_ac_prog in sed gsed; do
     for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_SED" && $as_test_x "$ac_path_SED"; } || continue
-# Check for GNU ac_path_SED and select it if it is found.
-  # Check for GNU $ac_path_SED
-case `"$ac_path_SED" --version 2>&1` in
-*GNU*)
-  ac_cv_path_SED="$ac_path_SED" ac_path_SED_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo '' >> "conftest.nl"
-    "$ac_path_SED" -f conftest.sed < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_SED_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_SED="$ac_path_SED"
-      ac_path_SED_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_SED_found && break 3
+      if $as_executable_p "$as_dir/$lt_ac_prog$ac_exec_ext"; then
+        lt_ac_sed_list="$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext"
+      fi
     done
   done
-  done
+done
 IFS=$as_save_IFS
-  if test -z "$ac_cv_path_SED"; then
-    as_fn_error "no acceptable sed could be found in \$PATH" "$LINENO" 5
+lt_ac_max=0
+lt_ac_count=0
+# Add /usr/xpg4/bin/sed as it is typically found on Solaris
+# along with /bin/sed that truncates output.
+for lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do
+  test ! -f $lt_ac_sed && continue
+  cat /dev/null > conftest.in
+  lt_ac_count=0
+  echo $ECHO_N "0123456789$ECHO_C" >conftest.in
+  # Check for GNU sed and select it if it is found.
+  if "$lt_ac_sed" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then
+    lt_cv_path_SED=$lt_ac_sed
+    break
   fi
-else
-  ac_cv_path_SED=$SED
-fi
+  while true; do
+    cat conftest.in conftest.in >conftest.tmp
+    mv conftest.tmp conftest.in
+    cp conftest.in conftest.nl
+    echo >>conftest.nl
+    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break
+    cmp -s conftest.out conftest.nl || break
+    # 10000 chars as input seems more than enough
+    test $lt_ac_count -gt 10 && break
+    lt_ac_count=`expr $lt_ac_count + 1`
+    if test $lt_ac_count -gt $lt_ac_max; then
+      lt_ac_max=$lt_ac_count
+      lt_cv_path_SED=$lt_ac_sed
+    fi
+  done
+done
 
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_SED" >&5
-$as_echo "$ac_cv_path_SED" >&6; }
- SED="$ac_cv_path_SED"
-  rm -f conftest.sed
-
-test -z "$SED" && SED=sed
-Xsed="$SED -e 1s/^X//"
-
-
-
-
-
-
-
-
 
+SED=$lt_cv_path_SED
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $SED" >&5
+$as_echo "$SED" >&6; }
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
 $as_echo_n "checking for grep that handles long lines and -e... " >&6; }
@@ -4878,92 +4995,6 @@
  EGREP="$ac_cv_path_EGREP"
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for fgrep" >&5
-$as_echo_n "checking for fgrep... " >&6; }
-if test "${ac_cv_path_FGREP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if echo 'ab*c' | $GREP -F 'ab*c' >/dev/null 2>&1
-   then ac_cv_path_FGREP="$GREP -F"
-   else
-     if test -z "$FGREP"; then
-  ac_path_FGREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in fgrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_FGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_FGREP" && $as_test_x "$ac_path_FGREP"; } || continue
-# Check for GNU ac_path_FGREP and select it if it is found.
-  # Check for GNU $ac_path_FGREP
-case `"$ac_path_FGREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_FGREP="$ac_path_FGREP" ac_path_FGREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'FGREP' >> "conftest.nl"
-    "$ac_path_FGREP" FGREP < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_FGREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_FGREP="$ac_path_FGREP"
-      ac_path_FGREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_FGREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_FGREP"; then
-    as_fn_error "no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
-  fi
-else
-  ac_cv_path_FGREP=$FGREP
-fi
-
-   fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_FGREP" >&5
-$as_echo "$ac_cv_path_FGREP" >&6; }
- FGREP="$ac_cv_path_FGREP"
-
-
-test -z "$GREP" && GREP=grep
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
 
 # Check whether --with-gnu-ld was given.
 if test "${with_gnu_ld+set}" = set; then :
@@ -4989,9 +5020,9 @@
     [\\/]* | ?:[\\/]*)
       re_direlt='/[^/][^/]*/\.\./'
       # Canonicalize the pathname of ld
-      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
-      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
-	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
+      ac_prog=`echo $ac_prog| $SED 's%\\\\%/%g'`
+      while echo $ac_prog | grep "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`echo $ac_prog| $SED "s%$re_direlt%/%"`
       done
       test -z "$LD" && LD="$ac_prog"
       ;;
@@ -5069,15 +5100,33 @@
 with_gnu_ld=$lt_cv_prog_gnu_ld
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $LD option to reload object files" >&5
+$as_echo_n "checking for $LD option to reload object files... " >&6; }
+if test "${lt_cv_ld_reload_flag+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_ld_reload_flag='-r'
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_reload_flag" >&5
+$as_echo "$lt_cv_ld_reload_flag" >&6; }
+reload_flag=$lt_cv_ld_reload_flag
+case $reload_flag in
+"" | " "*) ;;
+*) reload_flag=" $reload_flag" ;;
+esac
+reload_cmds='$LD$reload_flag -o $output$reload_objs'
+case $host_os in
+  darwin*)
+    if test "$GCC" = yes; then
+      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
+    else
+      reload_cmds='$LD$reload_flag -o $output$reload_objs'
+    fi
+    ;;
+esac
 
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for BSD- or MS-compatible name lister (nm)" >&5
-$as_echo_n "checking for BSD- or MS-compatible name lister (nm)... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for BSD-compatible nm" >&5
+$as_echo_n "checking for BSD-compatible nm... " >&6; }
 if test "${lt_cv_path_NM+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
@@ -5122,149 +5171,12 @@
     done
     IFS="$lt_save_ifs"
   done
-  : ${lt_cv_path_NM=no}
+  test -z "$lt_cv_path_NM" && lt_cv_path_NM=nm
 fi
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_path_NM" >&5
 $as_echo "$lt_cv_path_NM" >&6; }
-if test "$lt_cv_path_NM" != "no"; then
-  NM="$lt_cv_path_NM"
-else
-  # Didn't find any BSD compatible name lister, look for dumpbin.
-  if test -n "$ac_tool_prefix"; then
-  for ac_prog in "dumpbin -symbols" "link -dump -symbols"
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_DUMPBIN+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$DUMPBIN"; then
-  ac_cv_prog_DUMPBIN="$DUMPBIN" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_DUMPBIN="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-DUMPBIN=$ac_cv_prog_DUMPBIN
-if test -n "$DUMPBIN"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DUMPBIN" >&5
-$as_echo "$DUMPBIN" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-    test -n "$DUMPBIN" && break
-  done
-fi
-if test -z "$DUMPBIN"; then
-  ac_ct_DUMPBIN=$DUMPBIN
-  for ac_prog in "dumpbin -symbols" "link -dump -symbols"
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_DUMPBIN+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_DUMPBIN"; then
-  ac_cv_prog_ac_ct_DUMPBIN="$ac_ct_DUMPBIN" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_DUMPBIN="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_DUMPBIN=$ac_cv_prog_ac_ct_DUMPBIN
-if test -n "$ac_ct_DUMPBIN"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DUMPBIN" >&5
-$as_echo "$ac_ct_DUMPBIN" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$ac_ct_DUMPBIN" && break
-done
-
-  if test "x$ac_ct_DUMPBIN" = x; then
-    DUMPBIN=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    DUMPBIN=$ac_ct_DUMPBIN
-  fi
-fi
-
-
-  if test "$DUMPBIN" != ":"; then
-    NM="$DUMPBIN"
-  fi
-fi
-test -z "$NM" && NM=nm
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the name lister ($NM) interface" >&5
-$as_echo_n "checking the name lister ($NM) interface... " >&6; }
-if test "${lt_cv_nm_interface+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_nm_interface="BSD nm"
-  echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:5253: $ac_compile\"" >&5)
-  (eval "$ac_compile" 2>conftest.err)
-  cat conftest.err >&5
-  (eval echo "\"\$as_me:5256: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
-  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
-  cat conftest.err >&5
-  (eval echo "\"\$as_me:5259: output\"" >&5)
-  cat conftest.out >&5
-  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
-    lt_cv_nm_interface="MS dumpbin"
-  fi
-  rm -f conftest*
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_nm_interface" >&5
-$as_echo "$lt_cv_nm_interface" >&6; }
+NM="$lt_cv_path_NM"
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ln -s works" >&5
 $as_echo_n "checking whether ln -s works... " >&6; }
@@ -5277,367 +5189,39 @@
 $as_echo "no, using $LN_S" >&6; }
 fi
 
-# find the maximum length of command line arguments
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the maximum length of command line arguments" >&5
-$as_echo_n "checking the maximum length of command line arguments... " >&6; }
-if test "${lt_cv_sys_max_cmd_len+set}" = set; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to recognise dependent libraries" >&5
+$as_echo_n "checking how to recognise dependent libraries... " >&6; }
+if test "${lt_cv_deplibs_check_method+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-    i=0
-  teststring="ABCD"
-
-  case $build_os in
-  msdosdjgpp*)
-    # On DJGPP, this test can blow up pretty badly due to problems in libc
-    # (any single argument exceeding 2000 bytes causes a buffer overrun
-    # during glob expansion).  Even if it were fixed, the result of this
-    # check would be larger than it should be.
-    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
-    ;;
+  lt_cv_file_magic_cmd='$MAGIC_CMD'
+lt_cv_file_magic_test_file=
+lt_cv_deplibs_check_method='unknown'
+# Need to set the preceding variable on all platforms that support
+# interlibrary dependencies.
+# 'none' -- dependencies not supported.
+# `unknown' -- same as none, but documents that we really don't know.
+# 'pass_all' -- all dependencies passed with no checks.
+# 'test_compile' -- check by making test program.
+# 'file_magic [[regex]]' -- check by looking for files in library path
+# which responds to the $file_magic_cmd with a given extended regex.
+# If you have `file' or equivalent on your system and you're not sure
+# whether `pass_all' will *always* work, you probably want this one.
 
-  gnu*)
-    # Under GNU Hurd, this test is not required because there is
-    # no limit to the length of command line arguments.
-    # Libtool will interpret -1 as no limit whatsoever
-    lt_cv_sys_max_cmd_len=-1;
-    ;;
+case $host_os in
+aix4* | aix5*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
 
-  cygwin* | mingw* | cegcc*)
-    # On Win9x/ME, this test blows up -- it succeeds, but takes
-    # about 5 minutes as the teststring grows exponentially.
-    # Worse, since 9x/ME are not pre-emptively multitasking,
-    # you end up with a "frozen" computer, even though with patience
-    # the test eventually succeeds (with a max line length of 256k).
-    # Instead, let's just punt: use the minimum linelength reported by
-    # all of the supported platforms: 8192 (on NT/2K/XP).
-    lt_cv_sys_max_cmd_len=8192;
-    ;;
+beos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
 
-  amigaos*)
-    # On AmigaOS with pdksh, this test takes hours, literally.
-    # So we just punt and use a minimum line length of 8192.
-    lt_cv_sys_max_cmd_len=8192;
-    ;;
-
-  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
-    # This has been around since 386BSD, at least.  Likely further.
-    if test -x /sbin/sysctl; then
-      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
-    elif test -x /usr/sbin/sysctl; then
-      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
-    else
-      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
-    fi
-    # And add a safety zone
-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
-    ;;
-
-  interix*)
-    # We know the value 262144 and hardcode it with a safety zone (like BSD)
-    lt_cv_sys_max_cmd_len=196608
-    ;;
-
-  osf*)
-    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
-    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
-    # nice to cause kernel panics so lets avoid the loop below.
-    # First set a reasonable default.
-    lt_cv_sys_max_cmd_len=16384
-    #
-    if test -x /sbin/sysconfig; then
-      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
-        *1*) lt_cv_sys_max_cmd_len=-1 ;;
-      esac
-    fi
-    ;;
-  sco3.2v5*)
-    lt_cv_sys_max_cmd_len=102400
-    ;;
-  sysv5* | sco5v6* | sysv4.2uw2*)
-    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
-    if test -n "$kargmax"; then
-      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[	 ]//'`
-    else
-      lt_cv_sys_max_cmd_len=32768
-    fi
-    ;;
-  *)
-    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
-    if test -n "$lt_cv_sys_max_cmd_len"; then
-      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
-      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
-    else
-      # Make teststring a little bigger before we do anything with it.
-      # a 1K string should be a reasonable start.
-      for i in 1 2 3 4 5 6 7 8 ; do
-        teststring=$teststring$teststring
-      done
-      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
-      # If test is not a shell built-in, we'll probably end up computing a
-      # maximum length that is only half of the actual maximum length, but
-      # we can't tell.
-      while { test "X"`$SHELL $0 --fallback-echo "X$teststring$teststring" 2>/dev/null` \
-	         = "XX$teststring$teststring"; } >/dev/null 2>&1 &&
-	      test $i != 17 # 1/2 MB should be enough
-      do
-        i=`expr $i + 1`
-        teststring=$teststring$teststring
-      done
-      # Only check the string length outside the loop.
-      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
-      teststring=
-      # Add a significant safety factor because C++ compilers can tack on
-      # massive amounts of additional arguments before passing them to the
-      # linker.  It appears as though 1/2 is a usable value.
-      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
-    fi
-    ;;
-  esac
-
-fi
-
-if test -n $lt_cv_sys_max_cmd_len ; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_sys_max_cmd_len" >&5
-$as_echo "$lt_cv_sys_max_cmd_len" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: none" >&5
-$as_echo "none" >&6; }
-fi
-max_cmd_len=$lt_cv_sys_max_cmd_len
-
-
-
-
-
-
-: ${CP="cp -f"}
-: ${MV="mv -f"}
-: ${RM="rm -f"}
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands some XSI constructs" >&5
-$as_echo_n "checking whether the shell understands some XSI constructs... " >&6; }
-# Try some XSI features
-xsi_shell=no
-( _lt_dummy="a/b/c"
-  test "${_lt_dummy##*/},${_lt_dummy%/*},"${_lt_dummy%"$_lt_dummy"}, \
-      = c,a/b,, \
-    && eval 'test $(( 1 + 1 )) -eq 2 \
-    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
-  && xsi_shell=yes
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $xsi_shell" >&5
-$as_echo "$xsi_shell" >&6; }
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands \"+=\"" >&5
-$as_echo_n "checking whether the shell understands \"+=\"... " >&6; }
-lt_shell_append=no
-( foo=bar; set foo baz; eval "$1+=\$2" && test "$foo" = barbaz ) \
-    >/dev/null 2>&1 \
-  && lt_shell_append=yes
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_shell_append" >&5
-$as_echo "$lt_shell_append" >&6; }
-
-
-if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
-  lt_unset=unset
-else
-  lt_unset=false
-fi
-
-
-
-
-
-# test EBCDIC or ASCII
-case `echo X|tr X '\101'` in
- A) # ASCII based system
-    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
-  lt_SP2NL='tr \040 \012'
-  lt_NL2SP='tr \015\012 \040\040'
-  ;;
- *) # EBCDIC based system
-  lt_SP2NL='tr \100 \n'
-  lt_NL2SP='tr \r\n \100\100'
-  ;;
-esac
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $LD option to reload object files" >&5
-$as_echo_n "checking for $LD option to reload object files... " >&6; }
-if test "${lt_cv_ld_reload_flag+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_ld_reload_flag='-r'
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_reload_flag" >&5
-$as_echo "$lt_cv_ld_reload_flag" >&6; }
-reload_flag=$lt_cv_ld_reload_flag
-case $reload_flag in
-"" | " "*) ;;
-*) reload_flag=" $reload_flag" ;;
-esac
-reload_cmds='$LD$reload_flag -o $output$reload_objs'
-case $host_os in
-  darwin*)
-    if test "$GCC" = yes; then
-      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
-    else
-      reload_cmds='$LD$reload_flag -o $output$reload_objs'
-    fi
-    ;;
-esac
-
-
-
-
-
-
-
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}objdump", so it can be a program name with args.
-set dummy ${ac_tool_prefix}objdump; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_OBJDUMP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$OBJDUMP"; then
-  ac_cv_prog_OBJDUMP="$OBJDUMP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_OBJDUMP="${ac_tool_prefix}objdump"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-OBJDUMP=$ac_cv_prog_OBJDUMP
-if test -n "$OBJDUMP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OBJDUMP" >&5
-$as_echo "$OBJDUMP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_OBJDUMP"; then
-  ac_ct_OBJDUMP=$OBJDUMP
-  # Extract the first word of "objdump", so it can be a program name with args.
-set dummy objdump; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_OBJDUMP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_OBJDUMP"; then
-  ac_cv_prog_ac_ct_OBJDUMP="$ac_ct_OBJDUMP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_OBJDUMP="objdump"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_OBJDUMP=$ac_cv_prog_ac_ct_OBJDUMP
-if test -n "$ac_ct_OBJDUMP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OBJDUMP" >&5
-$as_echo "$ac_ct_OBJDUMP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_OBJDUMP" = x; then
-    OBJDUMP="false"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    OBJDUMP=$ac_ct_OBJDUMP
-  fi
-else
-  OBJDUMP="$ac_cv_prog_OBJDUMP"
-fi
-
-test -z "$OBJDUMP" && OBJDUMP=objdump
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to recognize dependent libraries" >&5
-$as_echo_n "checking how to recognize dependent libraries... " >&6; }
-if test "${lt_cv_deplibs_check_method+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_file_magic_cmd='$MAGIC_CMD'
-lt_cv_file_magic_test_file=
-lt_cv_deplibs_check_method='unknown'
-# Need to set the preceding variable on all platforms that support
-# interlibrary dependencies.
-# 'none' -- dependencies not supported.
-# `unknown' -- same as none, but documents that we really don't know.
-# 'pass_all' -- all dependencies passed with no checks.
-# 'test_compile' -- check by making test program.
-# 'file_magic [[regex]]' -- check by looking for files in library path
-# which responds to the $file_magic_cmd with a given extended regex.
-# If you have `file' or equivalent on your system and you're not sure
-# whether `pass_all' will *always* work, you probably want this one.
-
-case $host_os in
-aix[4-9]*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-beos*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-bsdi[45]*)
-  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib)'
-  lt_cv_file_magic_cmd='/usr/bin/file -L'
-  lt_cv_file_magic_test_file=/shlib/libc.so
-  ;;
+bsdi[45]*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib)'
+  lt_cv_file_magic_cmd='/usr/bin/file -L'
+  lt_cv_file_magic_test_file=/shlib/libc.so
+  ;;
 
 cygwin*)
   # func_win32_libid is a shell function defined in ltmain.sh
@@ -5647,20 +5231,8 @@
 
 mingw* | pw32*)
   # Base MSYS/MinGW do not provide the 'file' command needed by
-  # func_win32_libid shell function, so use a weaker test based on 'objdump',
-  # unless we find 'file', for example because we are cross-compiling.
-  if ( file / ) >/dev/null 2>&1; then
-    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
-    lt_cv_file_magic_cmd='func_win32_libid'
-  else
-    lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'
-    lt_cv_file_magic_cmd='$OBJDUMP -f'
-  fi
-  ;;
-
-cegcc)
-  # use the weaker test based on 'objdump'. See mingw*.
-  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'
+  # func_win32_libid shell function, so use a weaker test based on 'objdump'.
+  lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'
   lt_cv_file_magic_cmd='$OBJDUMP -f'
   ;;
 
@@ -5668,8 +5240,8 @@
   lt_cv_deplibs_check_method=pass_all
   ;;
 
-freebsd* | dragonfly*)
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+freebsd* | kfreebsd*-gnu | dragonfly*)
+  if echo __ELF__ | $CC -E - | grep __ELF__ > /dev/null; then
     case $host_cpu in
     i*86 )
       # Not sure whether the presence of OpenBSD here was a mistake.
@@ -5706,7 +5278,7 @@
   esac
   ;;
 
-interix[3-9]*)
+interix3*)
   # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
   lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|\.a)$'
   ;;
@@ -5722,12 +5294,12 @@
   ;;
 
 # This must be Linux ELF.
-linux* | k*bsd*-gnu)
+linux*)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
 netbsd*)
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+  if echo __ELF__ | $CC -E - | grep __ELF__ > /dev/null; then
     lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
   else
     lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|_pic\.a)$'
@@ -5740,12 +5312,12 @@
   lt_cv_file_magic_test_file=/usr/lib/libnls.so
   ;;
 
-*nto* | *qnx*)
-  lt_cv_deplibs_check_method=pass_all
+nto-qnx*)
+  lt_cv_deplibs_check_method=unknown
   ;;
 
 openbsd*)
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
     lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|\.so|_pic\.a)$'
   else
     lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
@@ -5756,18 +5328,10 @@
   lt_cv_deplibs_check_method=pass_all
   ;;
 
-rdos*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
 solaris*)
   lt_cv_deplibs_check_method=pass_all
   ;;
 
-sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
 sysv4 | sysv4.3*)
   case $host_vendor in
   motorola)
@@ -5795,7 +5359,7 @@
   esac
   ;;
 
-tpf*)
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
   lt_cv_deplibs_check_method=pass_all
   ;;
 esac
@@ -5810,375 +5374,955 @@
 
 
 
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
 
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
 
+# Allow CC to be a program name with arguments.
+compiler=$CC
 
 
+# Check whether --enable-libtool-lock was given.
+if test "${enable_libtool_lock+set}" = set; then :
+  enableval=$enable_libtool_lock;
+fi
 
+test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
 
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
-set dummy ${ac_tool_prefix}ar; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_AR+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$AR"; then
-  ac_cv_prog_AR="$AR" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_AR="${ac_tool_prefix}ar"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+case $host in
+ia64-*-hpux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.$ac_objext` in
+    *ELF-32*)
+      HPUX_IA64_MODE="32"
+      ;;
+    *ELF-64*)
+      HPUX_IA64_MODE="64"
+      ;;
+    esac
   fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-AR=$ac_cv_prog_AR
-if test -n "$AR"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
-$as_echo "$AR" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
+  rm -rf conftest*
+  ;;
+*-*-irix6*)
+  # Find out which ABI we are using.
+  echo '#line 5418 "configure"' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+   if test "$lt_cv_prog_gnu_ld" = yes; then
+    case `/usr/bin/file conftest.$ac_objext` in
+    *32-bit*)
+      LD="${LD-ld} -melf32bsmip"
+      ;;
+    *N32*)
+      LD="${LD-ld} -melf32bmipn32"
+      ;;
+    *64-bit*)
+      LD="${LD-ld} -melf64bmip"
+      ;;
+    esac
+   else
+    case `/usr/bin/file conftest.$ac_objext` in
+    *32-bit*)
+      LD="${LD-ld} -32"
+      ;;
+    *N32*)
+      LD="${LD-ld} -n32"
+      ;;
+    *64-bit*)
+      LD="${LD-ld} -64"
+      ;;
+    esac
+   fi
+  fi
+  rm -rf conftest*
+  ;;
 
+x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*|s390*-*linux*|sparc*-*linux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.o` in
+    *32-bit*)
+      case $host in
+        x86_64-*linux*)
+          LD="${LD-ld} -m elf_i386"
+          ;;
+        ppc64-*linux*|powerpc64-*linux*)
+          LD="${LD-ld} -m elf32ppclinux"
+          ;;
+        s390x-*linux*)
+          LD="${LD-ld} -m elf_s390"
+          ;;
+        sparc64-*linux*)
+          LD="${LD-ld} -m elf32_sparc"
+          ;;
+      esac
+      ;;
+    *64-bit*)
+      case $host in
+        x86_64-*linux*)
+          LD="${LD-ld} -m elf_x86_64"
+          ;;
+        ppc*-*linux*|powerpc*-*linux*)
+          LD="${LD-ld} -m elf64ppc"
+          ;;
+        s390*-*linux*)
+          LD="${LD-ld} -m elf64_s390"
+          ;;
+        sparc*-*linux*)
+          LD="${LD-ld} -m elf64_sparc"
+          ;;
+      esac
+      ;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
 
-fi
-if test -z "$ac_cv_prog_AR"; then
-  ac_ct_AR=$AR
-  # Extract the first word of "ar", so it can be a program name with args.
-set dummy ar; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_AR+set}" = set; then :
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -belf"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler needs -belf" >&5
+$as_echo_n "checking whether the C compiler needs -belf... " >&6; }
+if test "${lt_cv_cc_needs_belf+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$ac_ct_AR"; then
-  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_AR="ar"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
+  ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
-fi
-fi
-ac_ct_AR=$ac_cv_prog_ac_ct_AR
-if test -n "$ac_ct_AR"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
-$as_echo "$ac_ct_AR" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
+     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-  if test "x$ac_ct_AR" = x; then
-    AR="false"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    AR=$ac_ct_AR
-  fi
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  lt_cv_cc_needs_belf=yes
 else
-  AR="$ac_cv_prog_AR"
+  lt_cv_cc_needs_belf=no
 fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+     ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
-test -z "$AR" && AR=ar
-test -z "$AR_FLAGS" && AR_FLAGS=cru
-
-
-
-
-
-
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_cc_needs_belf" >&5
+$as_echo "$lt_cv_cc_needs_belf" >&6; }
+  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
+    CFLAGS="$SAVE_CFLAGS"
+  fi
+  ;;
+sparc*-*solaris*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.o` in
+    *64-bit*)
+      case $lt_cv_prog_gnu_ld in
+      yes*) LD="${LD-ld} -m elf64_sparc" ;;
+      *)    LD="${LD-ld} -64" ;;
+      esac
+      ;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
 
 
+esac
 
+need_locks="$enable_libtool_lock"
 
 
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
-set dummy ${ac_tool_prefix}strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_STRIP+set}" = set; then :
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
+$as_echo_n "checking how to run the C preprocessor... " >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if test "${ac_cv_prog_CPP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$STRIP"; then
-  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
 do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-STRIP=$ac_cv_prog_STRIP
-if test -n "$STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
-$as_echo "$STRIP" >&6; }
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  # Broken: fails on valid input.
+continue
 fi
+rm -f conftest.err conftest.$ac_ext
 
-
-fi
-if test -z "$ac_cv_prog_STRIP"; then
-  ac_ct_STRIP=$STRIP
-  # Extract the first word of "strip", so it can be a program name with args.
-set dummy strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_STRIP"; then
-  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
 else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_STRIP="strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
 
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+  break
 fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
 fi
-ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
-if test -n "$ac_ct_STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
-$as_echo "$ac_ct_STRIP" >&6; }
+  CPP=$ac_cv_prog_CPP
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  ac_cv_prog_CPP=$CPP
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
+$as_echo "$CPP" >&6; }
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
 
-  if test "x$ac_ct_STRIP" = x; then
-    STRIP=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    STRIP=$ac_ct_STRIP
-  fi
 else
-  STRIP="$ac_cv_prog_STRIP"
+  # Broken: fails on valid input.
+continue
 fi
+rm -f conftest.err conftest.$ac_ext
 
-test -z "$STRIP" && STRIP=:
-
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
 
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
 
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details." "$LINENO" 5; }
+fi
 
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
-set dummy ${ac_tool_prefix}ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_RANLIB+set}" = set; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
+$as_echo_n "checking for ANSI C header files... " >&6; }
+if test "${ac_cv_header_stdc+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$RANLIB"; then
-  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
 
-fi
-fi
-RANLIB=$ac_cv_prog_RANLIB
-if test -n "$RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
-$as_echo "$RANLIB" >&6; }
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_stdc=yes
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  ac_cv_header_stdc=no
 fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <string.h>
 
-fi
-if test -z "$ac_cv_prog_RANLIB"; then
-  ac_ct_RANLIB=$RANLIB
-  # Extract the first word of "ranlib", so it can be a program name with args.
-set dummy ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_RANLIB"; then
-  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_RANLIB="ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then :
 
-fi
-fi
-ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
-if test -n "$ac_ct_RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
-$as_echo "$ac_ct_RANLIB" >&6; }
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  ac_cv_header_stdc=no
 fi
+rm -f conftest*
 
-  if test "x$ac_ct_RANLIB" = x; then
-    RANLIB=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    RANLIB=$ac_ct_RANLIB
-  fi
-else
-  RANLIB="$ac_cv_prog_RANLIB"
 fi
 
-test -z "$RANLIB" && RANLIB=:
-
-
-
-
-
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
 
-# Determine commands to create old-style static archives.
-old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'
-old_postinstall_cmds='chmod 644 $oldlib'
-old_postuninstall_cmds=
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then :
 
-if test -n "$RANLIB"; then
-  case $host_os in
-  openbsd*)
-    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$oldlib"
-    ;;
-  *)
-    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$oldlib"
-    ;;
-  esac
-  old_archive_cmds="$old_archive_cmds~\$RANLIB \$oldlib"
+else
+  ac_cv_header_stdc=no
 fi
+rm -f conftest*
 
+fi
 
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then :
+  :
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
 
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
 
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
 
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
+$as_echo "$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
 
+$as_echo "#define STDC_HEADERS 1" >>confdefs.h
 
+fi
 
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
+"
+eval as_val=\$$as_ac_Header
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
 
+fi
 
+done
 
 
+for ac_header in dlfcn.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default"
+if test "x$ac_cv_header_dlfcn_h" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_DLFCN_H 1
+_ACEOF
 
+fi
 
+done
 
 
 
+if test -n "$CXX" && ( test "X$CXX" != "Xno" &&
+    ( (test "X$CXX" = "Xg++" && `g++ -v >/dev/null 2>&1` ) ||
+    (test "X$CXX" != "Xg++"))) ; then
+  ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C++ preprocessor" >&5
+$as_echo_n "checking how to run the C++ preprocessor... " >&6; }
+if test -z "$CXXCPP"; then
+  if test "${ac_cv_prog_CXXCPP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+      # Double quotes because CXXCPP needs to be expanded
+    for CXXCPP in "$CXX -E" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_cxx_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_cxx_try_cpp "$LINENO"; then :
 
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
 
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_cxx_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
 
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+  break
+fi
 
+    done
+    ac_cv_prog_CXXCPP=$CXXCPP
 
+fi
+  CXXCPP=$ac_cv_prog_CXXCPP
+else
+  ac_cv_prog_CXXCPP=$CXXCPP
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CXXCPP" >&5
+$as_echo "$CXXCPP" >&6; }
+ac_preproc_ok=false
+for ac_cxx_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_cxx_try_cpp "$LINENO"; then :
 
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
 
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_cxx_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
 
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
 
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "C++ preprocessor \"$CXXCPP\" fails sanity check
+See \`config.log' for more details." "$LINENO" 5; }
+fi
 
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
 
+fi
 
 
+ac_ext=f
+ac_compile='$F77 -c $FFLAGS conftest.$ac_ext >&5'
+ac_link='$F77 -o conftest$ac_exeext $FFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_f77_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  for ac_prog in g77 xlf f77 frt pgf77 cf77 fort77 fl32 af77 xlf90 f90 pgf90 pghpf epcf90 gfortran g95 xlf95 f95 fort ifort ifc efc pgf95 lf95 ftn
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_F77+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$F77"; then
+  ac_cv_prog_F77="$F77" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_F77="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
+fi
+fi
+F77=$ac_cv_prog_F77
+if test -n "$F77"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $F77" >&5
+$as_echo "$F77" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
 
 
+    test -n "$F77" && break
+  done
+fi
+if test -z "$F77"; then
+  ac_ct_F77=$F77
+  for ac_prog in g77 xlf f77 frt pgf77 cf77 fort77 fl32 af77 xlf90 f90 pgf90 pghpf epcf90 gfortran g95 xlf95 f95 fort ifort ifc efc pgf95 lf95 ftn
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_ac_ct_F77+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_F77"; then
+  ac_cv_prog_ac_ct_F77="$ac_ct_F77" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_F77="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_F77=$ac_cv_prog_ac_ct_F77
+if test -n "$ac_ct_F77"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_F77" >&5
+$as_echo "$ac_ct_F77" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_F77" && break
+done
+
+  if test "x$ac_ct_F77" = x; then
+    F77=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    F77=$ac_ct_F77
+  fi
+fi
+
+
+# Provide some information about the compiler.
+$as_echo "$as_me:${as_lineno-$LINENO}: checking for Fortran 77 compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+  fi
+  rm -f conftest.er1 conftest.err
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
+rm -f a.out
+
+# If we don't use `.F' as extension, the preprocessor is not run on the
+# input file.  (Note that this only needs to work for GNU compilers.)
+ac_save_ext=$ac_ext
+ac_ext=F
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU Fortran 77 compiler" >&5
+$as_echo_n "checking whether we are using the GNU Fortran 77 compiler... " >&6; }
+if test "${ac_cv_f77_compiler_gnu+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat > conftest.$ac_ext <<_ACEOF
+      program main
+#ifndef __GNUC__
+       choke me
+#endif
+
+      end
+_ACEOF
+if ac_fn_f77_try_compile "$LINENO"; then :
+  ac_compiler_gnu=yes
+else
+  ac_compiler_gnu=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_f77_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_f77_compiler_gnu" >&5
+$as_echo "$ac_cv_f77_compiler_gnu" >&6; }
+ac_ext=$ac_save_ext
+ac_test_FFLAGS=${FFLAGS+set}
+ac_save_FFLAGS=$FFLAGS
+FFLAGS=
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $F77 accepts -g" >&5
+$as_echo_n "checking whether $F77 accepts -g... " >&6; }
+if test "${ac_cv_prog_f77_g+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  FFLAGS=-g
+cat > conftest.$ac_ext <<_ACEOF
+      program main
+
+      end
+_ACEOF
+if ac_fn_f77_try_compile "$LINENO"; then :
+  ac_cv_prog_f77_g=yes
+else
+  ac_cv_prog_f77_g=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_f77_g" >&5
+$as_echo "$ac_cv_prog_f77_g" >&6; }
+if test "$ac_test_FFLAGS" = set; then
+  FFLAGS=$ac_save_FFLAGS
+elif test $ac_cv_prog_f77_g = yes; then
+  if test "x$ac_cv_f77_compiler_gnu" = xyes; then
+    FFLAGS="-g -O2"
+  else
+    FFLAGS="-g"
+  fi
+else
+  if test "x$ac_cv_f77_compiler_gnu" = xyes; then
+    FFLAGS="-O2"
+  else
+    FFLAGS=
+  fi
+fi
+
+if test $ac_compiler_gnu = yes; then
+  G77=yes
+else
+  G77=
+fi
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+
+
+# Autoconf 2.13's AC_OBJEXT and AC_EXEEXT macros only works for C compilers!
+
+# find the maximum length of command line arguments
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the maximum length of command line arguments" >&5
+$as_echo_n "checking the maximum length of command line arguments... " >&6; }
+if test "${lt_cv_sys_max_cmd_len+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+    i=0
+  teststring="ABCD"
+
+  case $build_os in
+  msdosdjgpp*)
+    # On DJGPP, this test can blow up pretty badly due to problems in libc
+    # (any single argument exceeding 2000 bytes causes a buffer overrun
+    # during glob expansion).  Even if it were fixed, the result of this
+    # check would be larger than it should be.
+    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
+    ;;
+
+  gnu*)
+    # Under GNU Hurd, this test is not required because there is
+    # no limit to the length of command line arguments.
+    # Libtool will interpret -1 as no limit whatsoever
+    lt_cv_sys_max_cmd_len=-1;
+    ;;
+
+  cygwin* | mingw*)
+    # On Win9x/ME, this test blows up -- it succeeds, but takes
+    # about 5 minutes as the teststring grows exponentially.
+    # Worse, since 9x/ME are not pre-emptively multitasking,
+    # you end up with a "frozen" computer, even though with patience
+    # the test eventually succeeds (with a max line length of 256k).
+    # Instead, let's just punt: use the minimum linelength reported by
+    # all of the supported platforms: 8192 (on NT/2K/XP).
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  amigaos*)
+    # On AmigaOS with pdksh, this test takes hours, literally.
+    # So we just punt and use a minimum line length of 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
+    # This has been around since 386BSD, at least.  Likely further.
+    if test -x /sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
+    elif test -x /usr/sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
+    else
+      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
+    fi
+    # And add a safety zone
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    ;;
+
+  interix*)
+    # We know the value 262144 and hardcode it with a safety zone (like BSD)
+    lt_cv_sys_max_cmd_len=196608
+    ;;
+
+  osf*)
+    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
+    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
+    # nice to cause kernel panics so lets avoid the loop below.
+    # First set a reasonable default.
+    lt_cv_sys_max_cmd_len=16384
+    #
+    if test -x /sbin/sysconfig; then
+      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
+        *1*) lt_cv_sys_max_cmd_len=-1 ;;
+      esac
+    fi
+    ;;
+  sco3.2v5*)
+    lt_cv_sys_max_cmd_len=102400
+    ;;
+  sysv5* | sco5v6* | sysv4.2uw2*)
+    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
+    if test -n "$kargmax"; then
+      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[ 	]//'`
+    else
+      lt_cv_sys_max_cmd_len=32768
+    fi
+    ;;
+  *)
+    # If test is not a shell built-in, we'll probably end up computing a
+    # maximum length that is only half of the actual maximum length, but
+    # we can't tell.
+    SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
+    while (test "X"`$SHELL $0 --fallback-echo "X$teststring" 2>/dev/null` \
+	       = "XX$teststring") >/dev/null 2>&1 &&
+	    new_result=`expr "X$teststring" : ".*" 2>&1` &&
+	    lt_cv_sys_max_cmd_len=$new_result &&
+	    test $i != 17 # 1/2 MB should be enough
+    do
+      i=`expr $i + 1`
+      teststring=$teststring$teststring
+    done
+    teststring=
+    # Add a significant safety factor because C++ compilers can tack on massive
+    # amounts of additional arguments before passing them to the linker.
+    # It appears as though 1/2 is a usable value.
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
+    ;;
+  esac
+
+fi
+
+if test -n $lt_cv_sys_max_cmd_len ; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_sys_max_cmd_len" >&5
+$as_echo "$lt_cv_sys_max_cmd_len" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: none" >&5
+$as_echo "none" >&6; }
+fi
 
-# If no C compiler was specified, use CC.
-LTCC=${LTCC-"$CC"}
-
-# If no C compiler flags were specified, use CFLAGS.
-LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
 
-# Allow CC to be a program name with arguments.
-compiler=$CC
 
 
 # Check for command to grab the raw symbol name followed by C symbol from nm.
@@ -6197,18 +6341,33 @@
 # Regexp to match symbols that can be accessed directly from C.
 sympat='\([_A-Za-z][_A-Za-z0-9]*\)'
 
+# Transform an extracted symbol line into a proper C declaration
+lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^. .* \(.*\)$/extern int \1;/p'"
+
+# Transform an extracted symbol line into symbol name and symbol address
+lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (lt_ptr) 0},/p' -e 's/^$symcode \([^ ]*\) \([^ ]*\)$/  {\"\2\", (lt_ptr) \&\2},/p'"
+
 # Define system-specific variables.
 case $host_os in
 aix*)
   symcode='[BCDT]'
   ;;
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | pw32*)
   symcode='[ABCDGISTW]'
   ;;
-hpux*)
+hpux*) # Its linker distinguishes data from code symbols
   if test "$host_cpu" = ia64; then
     symcode='[ABCDEGRST]'
   fi
+  lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
+  lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (lt_ptr) 0},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"\2\", (lt_ptr) \&\2},/p'"
+  ;;
+linux*)
+  if test "$host_cpu" = ia64; then
+    symcode='[ABCDGIRSTW]'
+    lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
+    lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (lt_ptr) 0},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"\2\", (lt_ptr) \&\2},/p'"
+  fi
   ;;
 irix* | nonstopux*)
   symcode='[BCDEGRST]'
@@ -6233,72 +6392,44 @@
   ;;
 esac
 
-# If we're using GNU nm, then use its standard symbol codes.
-case `$NM -V 2>&1` in
-*GNU* | *'with BFD'*)
-  symcode='[ABCDGIRSTW]' ;;
-esac
-
-# Transform an extracted symbol line into a proper C declaration.
-# Some systems (esp. on ia64) link data and code symbols differently,
-# so use this general approach.
-lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
-
-# Transform an extracted symbol line into symbol name and symbol address
-lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"\2\", (void *) \&\2},/p'"
-lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([^ ]*\) $/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \(lib[^ ]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
-
 # Handle CRLF in mingw tool chain
 opt_cr=
 case $build_os in
 mingw*)
-  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
+  opt_cr=`echo 'x\{0,1\}' | tr x '\015'` # option cr in regexp
   ;;
 esac
 
-# Try without a prefix underscore, then with it.
+# If we're using GNU nm, then use its standard symbol codes.
+case `$NM -V 2>&1` in
+*GNU* | *'with BFD'*)
+  symcode='[ABCDGIRSTW]' ;;
+esac
+
+# Try without a prefix undercore, then with it.
 for ac_symprfx in "" "_"; do
 
   # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
   symxfrm="\\1 $ac_symprfx\\2 \\2"
 
   # Write the raw and C identifiers.
-  if test "$lt_cv_nm_interface" = "MS dumpbin"; then
-    # Fake it for dumpbin and say T for any non-static function
-    # and D for any global variable.
-    # Also find C++ and __fastcall symbols from MSVC++,
-    # which start with @ or ?.
-    lt_cv_sys_global_symbol_pipe="$AWK '"\
-"     {last_section=section; section=\$ 3};"\
-"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
-"     \$ 0!~/External *\|/{next};"\
-"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
-"     {if(hide[section]) next};"\
-"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
-"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
-"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
-"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
-"     ' prfx=^$ac_symprfx"
-  else
-    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[	 ]\($symcode$symcode*\)[	 ][	 ]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
-  fi
+  lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[ 	]\($symcode$symcode*\)[ 	][ 	]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
 
   # Check to see that the pipe works correctly.
   pipe_works=no
 
   rm -f conftest*
-  cat > conftest.$ac_ext <<_LT_EOF
+  cat > conftest.$ac_ext <<EOF
 #ifdef __cplusplus
 extern "C" {
 #endif
 char nm_test_var;
-void nm_test_func(void);
-void nm_test_func(void){}
+void nm_test_func(){}
 #ifdef __cplusplus
 }
 #endif
 int main(){nm_test_var='a';nm_test_func();return(0);}
-_LT_EOF
+EOF
 
   if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
   (eval $ac_compile) 2>&5
@@ -6320,44 +6451,42 @@
       fi
 
       # Make sure that we snagged all the symbols we need.
-      if $GREP ' nm_test_var$' "$nlist" >/dev/null; then
-	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
-	  cat <<_LT_EOF > conftest.$ac_ext
+      if grep ' nm_test_var$' "$nlist" >/dev/null; then
+	if grep ' nm_test_func$' "$nlist" >/dev/null; then
+	  cat <<EOF > conftest.$ac_ext
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-_LT_EOF
+EOF
 	  # Now generate the symbol file.
-	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
+	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | grep -v main >> conftest.$ac_ext'
 
-	  cat <<_LT_EOF >> conftest.$ac_ext
+	  cat <<EOF >> conftest.$ac_ext
+#if defined (__STDC__) && __STDC__
+# define lt_ptr_t void *
+#else
+# define lt_ptr_t char *
+# define const
+#endif
 
-/* The mapping between symbol names and symbols.  */
+/* The mapping between symbol names and symbols. */
 const struct {
   const char *name;
-  void       *address;
+  lt_ptr_t address;
 }
-lt__PROGRAM__LTX_preloaded_symbols[] =
+lt_preloaded_symbols[] =
 {
-  { "@PROGRAM@", (void *) 0 },
-_LT_EOF
-	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
-	  cat <<\_LT_EOF >> conftest.$ac_ext
-  {0, (void *) 0}
+EOF
+	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (lt_ptr_t) \&\2},/" < "$nlist" | grep -v main >> conftest.$ac_ext
+	  cat <<\EOF >> conftest.$ac_ext
+  {0, (lt_ptr_t) 0}
 };
 
-/* This works around a problem in FreeBSD linker */
-#ifdef FREEBSD_WORKAROUND
-static const void *lt_preloaded_setup() {
-  return lt__PROGRAM__LTX_preloaded_symbols;
-}
-#endif
-
 #ifdef __cplusplus
 }
 #endif
-_LT_EOF
+EOF
 	  # Now try linking the two files.
 	  mv conftest.$ac_objext conftstm.$ac_objext
 	  lt_save_LIBS="$LIBS"
@@ -6386,7 +6515,7 @@
     echo "$progname: failed program was:" >&5
     cat conftest.$ac_ext >&5
   fi
-  rm -rf conftest* conftst*
+  rm -f conftest* conftst*
 
   # Do not use the global_symbol_pipe unless it works.
   if test "$pipe_works" = yes; then
@@ -6409,234 +6538,80 @@
 $as_echo "ok" >&6; }
 fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for objdir" >&5
+$as_echo_n "checking for objdir... " >&6; }
+if test "${lt_cv_objdir+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  rm -f .libs 2>/dev/null
+mkdir .libs 2>/dev/null
+if test -d .libs; then
+  lt_cv_objdir=.libs
+else
+  # MS-DOS does not allow filenames that begin with a dot.
+  lt_cv_objdir=_libs
+fi
+rmdir .libs 2>/dev/null
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_objdir" >&5
+$as_echo "$lt_cv_objdir" >&6; }
+objdir=$lt_cv_objdir
 
 
 
 
 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-# Check whether --enable-libtool-lock was given.
-if test "${enable_libtool_lock+set}" = set; then :
-  enableval=$enable_libtool_lock;
-fi
-
-test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
-
-# Some flags need to be propagated to the compiler or linker for good
-# libtool support.
-case $host in
-ia64-*-hpux*)
-  # Find out which ABI we are using.
-  echo 'int i;' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    case `/usr/bin/file conftest.$ac_objext` in
-      *ELF-32*)
-	HPUX_IA64_MODE="32"
-	;;
-      *ELF-64*)
-	HPUX_IA64_MODE="64"
-	;;
-    esac
-  fi
-  rm -rf conftest*
-  ;;
-*-*-irix6*)
-  # Find out which ABI we are using.
-  echo '#line 6465 "configure"' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    if test "$lt_cv_prog_gnu_ld" = yes; then
-      case `/usr/bin/file conftest.$ac_objext` in
-	*32-bit*)
-	  LD="${LD-ld} -melf32bsmip"
-	  ;;
-	*N32*)
-	  LD="${LD-ld} -melf32bmipn32"
-	  ;;
-	*64-bit*)
-	  LD="${LD-ld} -melf64bmip"
-	;;
-      esac
-    else
-      case `/usr/bin/file conftest.$ac_objext` in
-	*32-bit*)
-	  LD="${LD-ld} -32"
-	  ;;
-	*N32*)
-	  LD="${LD-ld} -n32"
-	  ;;
-	*64-bit*)
-	  LD="${LD-ld} -64"
-	  ;;
-      esac
-    fi
-  fi
-  rm -rf conftest*
-  ;;
-
-x86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \
-s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
-  # Find out which ABI we are using.
-  echo 'int i;' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    case `/usr/bin/file conftest.o` in
-      *32-bit*)
-	case $host in
-	  x86_64-*kfreebsd*-gnu)
-	    LD="${LD-ld} -m elf_i386_fbsd"
-	    ;;
-	  x86_64-*linux*)
-	    LD="${LD-ld} -m elf_i386"
-	    ;;
-	  ppc64-*linux*|powerpc64-*linux*)
-	    LD="${LD-ld} -m elf32ppclinux"
-	    ;;
-	  s390x-*linux*)
-	    LD="${LD-ld} -m elf_s390"
-	    ;;
-	  sparc64-*linux*)
-	    LD="${LD-ld} -m elf32_sparc"
-	    ;;
-	esac
-	;;
-      *64-bit*)
-	case $host in
-	  x86_64-*kfreebsd*-gnu)
-	    LD="${LD-ld} -m elf_x86_64_fbsd"
-	    ;;
-	  x86_64-*linux*)
-	    LD="${LD-ld} -m elf_x86_64"
-	    ;;
-	  ppc*-*linux*|powerpc*-*linux*)
-	    LD="${LD-ld} -m elf64ppc"
-	    ;;
-	  s390*-*linux*|s390*-*tpf*)
-	    LD="${LD-ld} -m elf64_s390"
-	    ;;
-	  sparc*-*linux*)
-	    LD="${LD-ld} -m elf64_sparc"
-	    ;;
-	esac
-	;;
-    esac
+case $host_os in
+aix3*)
+  # AIX sometimes has problems with the GCC collect2 program.  For some
+  # reason, if we set the COLLECT_NAMES environment variable, the problems
+  # vanish in a puff of smoke.
+  if test "X${COLLECT_NAMES+set}" != Xset; then
+    COLLECT_NAMES=
+    export COLLECT_NAMES
   fi
-  rm -rf conftest*
   ;;
+esac
 
-*-*-sco3.2v5*)
-  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
-  SAVE_CFLAGS="$CFLAGS"
-  CFLAGS="$CFLAGS -belf"
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler needs -belf" >&5
-$as_echo_n "checking whether the C compiler needs -belf... " >&6; }
-if test "${lt_cv_cc_needs_belf+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed='sed -e 1s/^X//'
+sed_quote_subst='s/\([\\"\\`$\\\\]\)/\\\1/g'
 
-     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\([\\"\\`\\\\]\)/\\\1/g'
 
-int
-main ()
-{
+# Sed substitution to delay expansion of an escaped shell variable in a
+# double_quote_subst'ed string.
+delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
 
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  lt_cv_cc_needs_belf=yes
-else
-  lt_cv_cc_needs_belf=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-     ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
+# Sed substitution to avoid accidental globbing in evaled expressions
+no_glob_subst='s/\*/\\\*/g'
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_cc_needs_belf" >&5
-$as_echo "$lt_cv_cc_needs_belf" >&6; }
-  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
-    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
-    CFLAGS="$SAVE_CFLAGS"
-  fi
-  ;;
-sparc*-*solaris*)
-  # Find out which ABI we are using.
-  echo 'int i;' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    case `/usr/bin/file conftest.o` in
-    *64-bit*)
-      case $lt_cv_prog_gnu_ld in
-      yes*) LD="${LD-ld} -m elf64_sparc" ;;
-      *)
-	if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
-	  LD="${LD-ld} -64"
-	fi
-	;;
-      esac
-      ;;
-    esac
-  fi
-  rm -rf conftest*
-  ;;
-esac
+# Constants:
+rm="rm -f"
 
-need_locks="$enable_libtool_lock"
+# Global variables:
+default_ofile=libtool
+can_build_shared=yes
 
+# All known linkers require a `.a' archive for static linking (except MSVC,
+# which needs '.lib').
+libext=a
+ltmain="$ac_aux_dir/ltmain.sh"
+ofile="$default_ofile"
+with_gnu_ld="$lt_cv_prog_gnu_ld"
 
-  case $host_os in
-    rhapsody* | darwin*)
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}dsymutil", so it can be a program name with args.
-set dummy ${ac_tool_prefix}dsymutil; ac_word=$2
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ar; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_DSYMUTIL+set}" = set; then :
+if test "${ac_cv_prog_AR+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$DSYMUTIL"; then
-  ac_cv_prog_DSYMUTIL="$DSYMUTIL" # Let the user override the test.
+  if test -n "$AR"; then
+  ac_cv_prog_AR="$AR" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -6645,7 +6620,7 @@
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_DSYMUTIL="${ac_tool_prefix}dsymutil"
+    ac_cv_prog_AR="${ac_tool_prefix}ar"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -6655,10 +6630,10 @@
 
 fi
 fi
-DSYMUTIL=$ac_cv_prog_DSYMUTIL
-if test -n "$DSYMUTIL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DSYMUTIL" >&5
-$as_echo "$DSYMUTIL" >&6; }
+AR=$ac_cv_prog_AR
+if test -n "$AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
+$as_echo "$AR" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
@@ -6666,17 +6641,17 @@
 
 
 fi
-if test -z "$ac_cv_prog_DSYMUTIL"; then
-  ac_ct_DSYMUTIL=$DSYMUTIL
-  # Extract the first word of "dsymutil", so it can be a program name with args.
-set dummy dsymutil; ac_word=$2
+if test -z "$ac_cv_prog_AR"; then
+  ac_ct_AR=$AR
+  # Extract the first word of "ar", so it can be a program name with args.
+set dummy ar; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_DSYMUTIL+set}" = set; then :
+if test "${ac_cv_prog_ac_ct_AR+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$ac_ct_DSYMUTIL"; then
-  ac_cv_prog_ac_ct_DSYMUTIL="$ac_ct_DSYMUTIL" # Let the user override the test.
+  if test -n "$ac_ct_AR"; then
+  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -6685,7 +6660,7 @@
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_DSYMUTIL="dsymutil"
+    ac_cv_prog_ac_ct_AR="ar"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -6695,17 +6670,17 @@
 
 fi
 fi
-ac_ct_DSYMUTIL=$ac_cv_prog_ac_ct_DSYMUTIL
-if test -n "$ac_ct_DSYMUTIL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DSYMUTIL" >&5
-$as_echo "$ac_ct_DSYMUTIL" >&6; }
+ac_ct_AR=$ac_cv_prog_ac_ct_AR
+if test -n "$ac_ct_AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
+$as_echo "$ac_ct_AR" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
-  if test "x$ac_ct_DSYMUTIL" = x; then
-    DSYMUTIL=":"
+  if test "x$ac_ct_AR" = x; then
+    AR="false"
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
@@ -6713,22 +6688,22 @@
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
-    DSYMUTIL=$ac_ct_DSYMUTIL
+    AR=$ac_ct_AR
   fi
 else
-  DSYMUTIL="$ac_cv_prog_DSYMUTIL"
+  AR="$ac_cv_prog_AR"
 fi
 
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}nmedit", so it can be a program name with args.
-set dummy ${ac_tool_prefix}nmedit; ac_word=$2
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_NMEDIT+set}" = set; then :
+if test "${ac_cv_prog_RANLIB+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$NMEDIT"; then
-  ac_cv_prog_NMEDIT="$NMEDIT" # Let the user override the test.
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -6737,7 +6712,7 @@
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_NMEDIT="${ac_tool_prefix}nmedit"
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -6747,10 +6722,10 @@
 
 fi
 fi
-NMEDIT=$ac_cv_prog_NMEDIT
-if test -n "$NMEDIT"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $NMEDIT" >&5
-$as_echo "$NMEDIT" >&6; }
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
+$as_echo "$RANLIB" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
@@ -6758,17 +6733,17 @@
 
 
 fi
-if test -z "$ac_cv_prog_NMEDIT"; then
-  ac_ct_NMEDIT=$NMEDIT
-  # Extract the first word of "nmedit", so it can be a program name with args.
-set dummy nmedit; ac_word=$2
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_NMEDIT+set}" = set; then :
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$ac_ct_NMEDIT"; then
-  ac_cv_prog_ac_ct_NMEDIT="$ac_ct_NMEDIT" # Let the user override the test.
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -6777,7 +6752,7 @@
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_NMEDIT="nmedit"
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -6787,17 +6762,17 @@
 
 fi
 fi
-ac_ct_NMEDIT=$ac_cv_prog_ac_ct_NMEDIT
-if test -n "$ac_ct_NMEDIT"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_NMEDIT" >&5
-$as_echo "$ac_ct_NMEDIT" >&6; }
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
+$as_echo "$ac_ct_RANLIB" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
-  if test "x$ac_ct_NMEDIT" = x; then
-    NMEDIT=":"
+  if test "x$ac_ct_RANLIB" = x; then
+    RANLIB=":"
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
@@ -6805,22 +6780,22 @@
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
-    NMEDIT=$ac_ct_NMEDIT
+    RANLIB=$ac_ct_RANLIB
   fi
 else
-  NMEDIT="$ac_cv_prog_NMEDIT"
+  RANLIB="$ac_cv_prog_RANLIB"
 fi
 
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}lipo", so it can be a program name with args.
-set dummy ${ac_tool_prefix}lipo; ac_word=$2
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_LIPO+set}" = set; then :
+if test "${ac_cv_prog_STRIP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$LIPO"; then
-  ac_cv_prog_LIPO="$LIPO" # Let the user override the test.
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -6829,7 +6804,7 @@
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_LIPO="${ac_tool_prefix}lipo"
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -6839,28 +6814,28 @@
 
 fi
 fi
-LIPO=$ac_cv_prog_LIPO
-if test -n "$LIPO"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LIPO" >&5
-$as_echo "$LIPO" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
+$as_echo "$STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
 
 fi
-if test -z "$ac_cv_prog_LIPO"; then
-  ac_ct_LIPO=$LIPO
-  # Extract the first word of "lipo", so it can be a program name with args.
-set dummy lipo; ac_word=$2
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_LIPO+set}" = set; then :
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$ac_ct_LIPO"; then
-  ac_cv_prog_ac_ct_LIPO="$ac_ct_LIPO" # Let the user override the test.
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
 else
 as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in $PATH
@@ -6869,7 +6844,7 @@
   test -z "$as_dir" && as_dir=.
     for ac_exec_ext in '' $ac_executable_extensions; do
   if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_LIPO="lipo"
+    ac_cv_prog_ac_ct_STRIP="strip"
     $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
@@ -6879,17 +6854,17 @@
 
 fi
 fi
-ac_ct_LIPO=$ac_cv_prog_ac_ct_LIPO
-if test -n "$ac_ct_LIPO"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_LIPO" >&5
-$as_echo "$ac_ct_LIPO" >&6; }
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
+$as_echo "$ac_ct_STRIP" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
-  if test "x$ac_ct_LIPO" = x; then
-    LIPO=":"
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
   else
     case $cross_compiling:$ac_tool_warned in
 yes:)
@@ -6897,799 +6872,1115 @@
 $as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
 ac_tool_warned=yes ;;
 esac
-    LIPO=$ac_ct_LIPO
+    STRIP=$ac_ct_STRIP
   fi
 else
-  LIPO="$ac_cv_prog_LIPO"
+  STRIP="$ac_cv_prog_STRIP"
 fi
 
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}otool", so it can be a program name with args.
-set dummy ${ac_tool_prefix}otool; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_OTOOL+set}" = set; then :
+
+old_CC="$CC"
+old_CFLAGS="$CFLAGS"
+
+# Set sane defaults for various variables
+test -z "$AR" && AR=ar
+test -z "$AR_FLAGS" && AR_FLAGS=cru
+test -z "$AS" && AS=as
+test -z "$CC" && CC=cc
+test -z "$LTCC" && LTCC=$CC
+test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
+test -z "$DLLTOOL" && DLLTOOL=dlltool
+test -z "$LD" && LD=ld
+test -z "$LN_S" && LN_S="ln -s"
+test -z "$MAGIC_CMD" && MAGIC_CMD=file
+test -z "$NM" && NM=nm
+test -z "$SED" && SED=sed
+test -z "$OBJDUMP" && OBJDUMP=objdump
+test -z "$RANLIB" && RANLIB=:
+test -z "$STRIP" && STRIP=:
+test -z "$ac_objext" && ac_objext=o
+
+# Determine commands to create old-style static archives.
+old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs'
+old_postinstall_cmds='chmod 644 $oldlib'
+old_postuninstall_cmds=
+
+if test -n "$RANLIB"; then
+  case $host_os in
+  openbsd*)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$oldlib"
+    ;;
+  *)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$oldlib"
+    ;;
+  esac
+  old_archive_cmds="$old_archive_cmds~\$RANLIB \$oldlib"
+fi
+
+for cc_temp in $compiler""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$echo "X$cc_temp" | $Xsed -e 's%.*/%%' -e "s%^$host_alias-%%"`
+
+
+# Only perform the check for file, if the check method requires it
+case $deplibs_check_method in
+file_magic*)
+  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${ac_tool_prefix}file" >&5
+$as_echo_n "checking for ${ac_tool_prefix}file... " >&6; }
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$OTOOL"; then
-  ac_cv_prog_OTOOL="$OTOOL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_OTOOL="${ac_tool_prefix}otool"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
+  case $MAGIC_CMD in
+[\\/*] |  ?:[\\/]*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/${ac_tool_prefix}file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/${ac_tool_prefix}file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<EOF 1>&2
 
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac
 fi
-fi
-OTOOL=$ac_cv_prog_OTOOL
-if test -n "$OTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL" >&5
-$as_echo "$OTOOL" >&6; }
+
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
+$as_echo "$MAGIC_CMD" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
-
-fi
-if test -z "$ac_cv_prog_OTOOL"; then
-  ac_ct_OTOOL=$OTOOL
-  # Extract the first word of "otool", so it can be a program name with args.
-set dummy otool; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_OTOOL+set}" = set; then :
+if test -z "$lt_cv_path_MAGIC_CMD"; then
+  if test -n "$ac_tool_prefix"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for file" >&5
+$as_echo_n "checking for file... " >&6; }
+if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  if test -n "$ac_ct_OTOOL"; then
-  ac_cv_prog_ac_ct_OTOOL="$ac_ct_OTOOL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_OTOOL="otool"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
+  case $MAGIC_CMD in
+[\\/*] |  ?:[\\/]*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<EOF 1>&2
 
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac
 fi
-fi
-ac_ct_OTOOL=$ac_cv_prog_ac_ct_OTOOL
-if test -n "$ac_ct_OTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL" >&5
-$as_echo "$ac_ct_OTOOL" >&6; }
+
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
+$as_echo "$MAGIC_CMD" >&6; }
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
 fi
 
-  if test "x$ac_ct_OTOOL" = x; then
-    OTOOL=":"
   else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    OTOOL=$ac_ct_OTOOL
+    MAGIC_CMD=:
   fi
-else
-  OTOOL="$ac_cv_prog_OTOOL"
 fi
 
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}otool64", so it can be a program name with args.
-set dummy ${ac_tool_prefix}otool64; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_OTOOL64+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$OTOOL64"; then
-  ac_cv_prog_OTOOL64="$OTOOL64" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_OTOOL64="${ac_tool_prefix}otool64"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
   fi
-done
-  done
-IFS=$as_save_IFS
+  ;;
+esac
 
+enable_dlopen=no
+enable_win32_dll=no
+
+# Check whether --enable-libtool-lock was given.
+if test "${enable_libtool_lock+set}" = set; then :
+  enableval=$enable_libtool_lock;
 fi
-fi
-OTOOL64=$ac_cv_prog_OTOOL64
-if test -n "$OTOOL64"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL64" >&5
-$as_echo "$OTOOL64" >&6; }
+
+test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
+
+
+# Check whether --with-pic was given.
+if test "${with_pic+set}" = set; then :
+  withval=$with_pic; pic_mode="$withval"
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  pic_mode=default
 fi
 
+test -z "$pic_mode" && pic_mode=default
 
-fi
-if test -z "$ac_cv_prog_OTOOL64"; then
-  ac_ct_OTOOL64=$OTOOL64
-  # Extract the first word of "otool64", so it can be a program name with args.
-set dummy otool64; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_OTOOL64+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_OTOOL64"; then
-  ac_cv_prog_ac_ct_OTOOL64="$ac_ct_OTOOL64" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_OTOOL64="otool64"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
+# Use C for the default configuration in the libtool script
+tagname=
+lt_save_CC="$CC"
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
-fi
-fi
-ac_ct_OTOOL64=$ac_cv_prog_ac_ct_OTOOL64
-if test -n "$ac_ct_OTOOL64"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL64" >&5
-$as_echo "$ac_ct_OTOOL64" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
 
-  if test "x$ac_ct_OTOOL64" = x; then
-    OTOOL64=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    OTOOL64=$ac_ct_OTOOL64
-  fi
-else
-  OTOOL64="$ac_cv_prog_OTOOL64"
-fi
+# Source file extension for C test sources.
+ac_ext=c
 
+# Object file extension for compiled C test sources.
+objext=o
+objext=$objext
 
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="int some_variable = 0;\n"
 
+# Code to be used in simple link tests
+lt_simple_link_test_code='int main(){return(0);}\n'
 
 
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
 
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
 
+# Allow CC to be a program name with arguments.
+compiler=$CC
 
 
+# save warnings/boilerplate of simple test code
+ac_outfile=conftest.$ac_objext
+printf "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$rm conftest*
 
+ac_outfile=conftest.$ac_objext
+printf "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$rm conftest*
 
 
 
+lt_prog_compiler_no_builtin_flag=
 
+if test "$GCC" = yes; then
+  lt_prog_compiler_no_builtin_flag=' -fno-builtin'
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
+$as_echo_n "checking if $compiler supports -fno-rtti -fno-exceptions... " >&6; }
+if test "${lt_cv_prog_compiler_rtti_exceptions+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_rtti_exceptions=no
+  ac_outfile=conftest.$ac_objext
+   printf "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="-fno-rtti -fno-exceptions"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:7159: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:7163: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_rtti_exceptions=yes
+     fi
+   fi
+   $rm conftest*
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
+$as_echo "$lt_cv_prog_compiler_rtti_exceptions" >&6; }
 
+if test x"$lt_cv_prog_compiler_rtti_exceptions" = xyes; then
+    lt_prog_compiler_no_builtin_flag="$lt_prog_compiler_no_builtin_flag -fno-rtti -fno-exceptions"
+else
+    :
+fi
 
+fi
 
+lt_prog_compiler_wl=
+lt_prog_compiler_pic=
+lt_prog_compiler_static=
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
+$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
 
+  if test "$GCC" = yes; then
+    lt_prog_compiler_wl='-Wl,'
+    lt_prog_compiler_static='-static'
 
+    case $host_os in
+      aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static='-Bstatic'
+      fi
+      ;;
 
+    amigaos*)
+      # FIXME: we need at least 68020 code to build shared libraries, but
+      # adding the `-m68020' flag to GCC prevents building anything better,
+      # like `-m68040'.
+      lt_prog_compiler_pic='-m68020 -resident32 -malways-restore-a4'
+      ;;
 
+    beos* | cygwin* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
 
+    mingw* | pw32* | os2*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_prog_compiler_pic='-DDLL_EXPORT'
+      ;;
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -single_module linker flag" >&5
-$as_echo_n "checking for -single_module linker flag... " >&6; }
-if test "${lt_cv_apple_cc_single_mod+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_apple_cc_single_mod=no
-      if test -z "${LT_MULTI_MODULE}"; then
-	# By default we will add the -single_module flag. You can override
-	# by either setting the environment variable LT_MULTI_MODULE
-	# non-empty at configure time, or by adding -multi_module to the
-	# link flags.
-	rm -rf libconftest.dylib*
-	echo "int foo(void){return 1;}" > conftest.c
-	echo "$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
--dynamiclib -Wl,-single_module conftest.c" >&5
-	$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
-	  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err
-        _lt_result=$?
-	if test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then
-	  lt_cv_apple_cc_single_mod=yes
-	else
-	  cat conftest.err >&5
-	fi
-	rm -rf libconftest.dylib*
-	rm -f conftest.*
-      fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_apple_cc_single_mod" >&5
-$as_echo "$lt_cv_apple_cc_single_mod" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -exported_symbols_list linker flag" >&5
-$as_echo_n "checking for -exported_symbols_list linker flag... " >&6; }
-if test "${lt_cv_ld_exported_symbols_list+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_ld_exported_symbols_list=no
-      save_LDFLAGS=$LDFLAGS
-      echo "_main" > conftest.sym
-      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      lt_prog_compiler_pic='-fno-common'
+      ;;
 
-int
-main ()
-{
+    interix3*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
 
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  lt_cv_ld_exported_symbols_list=yes
-else
-  lt_cv_ld_exported_symbols_list=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-	LDFLAGS="$save_LDFLAGS"
+    msdosdjgpp*)
+      # Just because we use GCC doesn't mean we suddenly get shared libraries
+      # on systems that don't support them.
+      lt_prog_compiler_can_build_shared=no
+      enable_shared=no
+      ;;
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_exported_symbols_list" >&5
-$as_echo "$lt_cv_ld_exported_symbols_list" >&6; }
-    case $host_os in
-    rhapsody* | darwin1.[012])
-      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
-    darwin1.*)
-      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
-    darwin*) # darwin 5.x on
-      # if running on 10.5 or later, the deployment target defaults
-      # to the OS version, if on x86, and 10.4, the deployment
-      # target defaults to 10.4. Don't you love it?
-      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
-	10.0,*86*-darwin8*|10.0,*-darwin[91]*)
-	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
-	10.[012]*)
-	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
-	10.*)
-	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	lt_prog_compiler_pic=-Kconform_pic
+      fi
+      ;;
+
+    hpux*)
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic='-fPIC'
+	;;
       esac
-    ;;
-  esac
-    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
-      _lt_dar_single_mod='$single_module'
-    fi
-    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
-      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
-    else
-      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
-    fi
-    if test "$DSYMUTIL" != ":"; then
-      _lt_dsymutil='~$DSYMUTIL $lib || :'
-    else
-      _lt_dsymutil=
-    fi
-    ;;
-  esac
+      ;;
 
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
-$as_echo_n "checking how to run the C preprocessor... " >&6; }
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
-fi
-if test -z "$CPP"; then
-  if test "${ac_cv_prog_CPP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-      # Double quotes because CPP needs to be expanded
-    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
+    *)
+      lt_prog_compiler_pic='-fPIC'
+      ;;
+    esac
+  else
+    # PORTME Check for flag to pass linker flags through the system compiler.
+    case $host_os in
+    aix*)
+      lt_prog_compiler_wl='-Wl,'
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static='-Bstatic'
+      else
+	lt_prog_compiler_static='-bnso -bI:/lib/syscalls.exp'
+      fi
+      ;;
+      darwin*)
+        # PIC is the default on this platform
+        # Common symbols not allowed in MH_DYLIB files
+       case $cc_basename in
+         xlc*)
+         lt_prog_compiler_pic='-qnocommon'
+         lt_prog_compiler_wl='-Wl,'
+         ;;
+       esac
+       ;;
 
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.$ac_ext
+    mingw* | pw32* | os2*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_prog_compiler_pic='-DDLL_EXPORT'
+      ;;
 
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.$ac_ext
+    hpux9* | hpux10* | hpux11*)
+      lt_prog_compiler_wl='-Wl,'
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic='+Z'
+	;;
+      esac
+      # Is there a better lt_prog_compiler_static that works with the bundled CC?
+      lt_prog_compiler_static='${wl}-a ${wl}archive'
+      ;;
 
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-  break
-fi
+    irix5* | irix6* | nonstopux*)
+      lt_prog_compiler_wl='-Wl,'
+      # PIC (with -KPIC) is the default.
+      lt_prog_compiler_static='-non_shared'
+      ;;
 
-    done
-    ac_cv_prog_CPP=$CPP
+    newsos6)
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
 
-fi
-  CPP=$ac_cv_prog_CPP
-else
-  ac_cv_prog_CPP=$CPP
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
-$as_echo "$CPP" >&6; }
-ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
+    linux*)
+      case $cc_basename in
+      icc* | ecc*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-KPIC'
+	lt_prog_compiler_static='-static'
+        ;;
+      pgcc* | pgf77* | pgf90* | pgf95*)
+        # Portland Group compilers (*not* the Pentium gcc compiler,
+	# which looks to be a dead project)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-fpic'
+	lt_prog_compiler_static='-Bstatic'
+        ;;
+      ccc*)
+        lt_prog_compiler_wl='-Wl,'
+        # All Alpha code is PIC.
+        lt_prog_compiler_static='-non_shared'
+        ;;
+      esac
+      ;;
 
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.$ac_ext
+    osf3* | osf4* | osf5*)
+      lt_prog_compiler_wl='-Wl,'
+      # All OSF/1 code is PIC.
+      lt_prog_compiler_static='-non_shared'
+      ;;
 
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.$ac_ext
+    solaris*)
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      case $cc_basename in
+      f77* | f90* | f95*)
+	lt_prog_compiler_wl='-Qoption ld ';;
+      *)
+	lt_prog_compiler_wl='-Wl,';;
+      esac
+      ;;
 
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
+    sunos4*)
+      lt_prog_compiler_wl='-Qoption ld '
+      lt_prog_compiler_pic='-PIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
 
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." "$LINENO" 5; }
-fi
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
 
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
+    sysv4*MP*)
+      if test -d /usr/nec ;then
+	lt_prog_compiler_pic='-Kconform_pic'
+	lt_prog_compiler_static='-Bstatic'
+      fi
+      ;;
 
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
-$as_echo_n "checking for ANSI C header files... " >&6; }
-if test "${ac_cv_header_stdc+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <float.h>
+    unicos*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_can_build_shared=no
+      ;;
 
-int
-main ()
-{
+    uts4*)
+      lt_prog_compiler_pic='-pic'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
 
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_header_stdc=yes
-else
-  ac_cv_header_stdc=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+    *)
+      lt_prog_compiler_can_build_shared=no
+      ;;
+    esac
+  fi
 
-if test $ac_cv_header_stdc = yes; then
-  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <string.h>
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic" >&5
+$as_echo "$lt_prog_compiler_pic" >&6; }
 
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "memchr" >/dev/null 2>&1; then :
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$lt_prog_compiler_pic"; then
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic works" >&5
+$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic works... " >&6; }
+if test "${lt_prog_compiler_pic_works+set}" = set; then :
+  $as_echo_n "(cached) " >&6
 else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
+  lt_prog_compiler_pic_works=no
+  ac_outfile=conftest.$ac_objext
+   printf "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$lt_prog_compiler_pic -DPIC"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:7427: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:7431: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_prog_compiler_pic_works=yes
+     fi
+   fi
+   $rm conftest*
 
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic_works" >&5
+$as_echo "$lt_prog_compiler_pic_works" >&6; }
 
-if test $ac_cv_header_stdc = yes; then
-  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "free" >/dev/null 2>&1; then :
-
+if test x"$lt_prog_compiler_pic_works" = xyes; then
+    case $lt_prog_compiler_pic in
+     "" | " "*) ;;
+     *) lt_prog_compiler_pic=" $lt_prog_compiler_pic" ;;
+     esac
 else
-  ac_cv_header_stdc=no
+    lt_prog_compiler_pic=
+     lt_prog_compiler_can_build_shared=no
 fi
-rm -f conftest*
 
 fi
-
-if test $ac_cv_header_stdc = yes; then
-  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
-  if test "$cross_compiling" = yes; then :
-  :
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    lt_prog_compiler_pic=
+    ;;
+  *)
+    lt_prog_compiler_pic="$lt_prog_compiler_pic -DPIC"
+    ;;
+esac
+
+#
+# Check to make sure the static flag actually works.
+#
+wl=$lt_prog_compiler_wl eval lt_tmp_static_flag=\"$lt_prog_compiler_static\"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
+$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
+if test "${lt_prog_compiler_static_works+set}" = set; then :
+  $as_echo_n "(cached) " >&6
 else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ctype.h>
-#include <stdlib.h>
-#if ((' ' & 0x0FF) == 0x020)
-# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
-# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
-#else
-# define ISLOWER(c) \
-		   (('a' <= (c) && (c) <= 'i') \
-		     || ('j' <= (c) && (c) <= 'r') \
-		     || ('s' <= (c) && (c) <= 'z'))
-# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
-#endif
+  lt_prog_compiler_static_works=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
+   printf "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&5
+       $echo "X$_lt_linker_boilerplate" | $Xsed -e '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         lt_prog_compiler_static_works=yes
+       fi
+     else
+       lt_prog_compiler_static_works=yes
+     fi
+   fi
+   $rm conftest*
+   LDFLAGS="$save_LDFLAGS"
 
-#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
-int
-main ()
-{
-  int i;
-  for (i = 0; i < 256; i++)
-    if (XOR (islower (i), ISLOWER (i))
-	|| toupper (i) != TOUPPER (i))
-      return 2;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_static_works" >&5
+$as_echo "$lt_prog_compiler_static_works" >&6; }
 
+if test x"$lt_prog_compiler_static_works" = xyes; then
+    :
 else
-  ac_cv_header_stdc=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
+    lt_prog_compiler_static=
 fi
 
-fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
-$as_echo "$ac_cv_header_stdc" >&6; }
-if test $ac_cv_header_stdc = yes; then
 
-$as_echo "#define STDC_HEADERS 1" >>confdefs.h
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o=no
+   $rm -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   printf "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:7531: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:7535: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $rm conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $rm out/ii_files/* && rmdir out/ii_files
+   $rm out/* && rmdir out
+   cd ..
+   rmdir conftest
+   $rm conftest*
 
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
+$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
 
-# On IRIX 5.3, sys/types and inttypes.h are conflicting.
-for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-		  inttypes.h stdint.h unistd.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
-"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
 
+hard_links="nottested"
+if test "$lt_cv_prog_compiler_c_o" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
+$as_echo_n "checking if we can lock with hard links... " >&6; }
+  hard_links=yes
+  $rm conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
+$as_echo "$hard_links" >&6; }
+  if test "$hard_links" = no; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
+$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
+    need_locks=warn
+  fi
+else
+  need_locks=no
 fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
+
+  runpath_var=
+  allow_undefined_flag=
+  enable_shared_with_static_runtimes=no
+  archive_cmds=
+  archive_expsym_cmds=
+  old_archive_From_new_cmds=
+  old_archive_from_expsyms_cmds=
+  export_dynamic_flag_spec=
+  whole_archive_flag_spec=
+  thread_safe_flag_spec=
+  hardcode_libdir_flag_spec=
+  hardcode_libdir_flag_spec_ld=
+  hardcode_libdir_separator=
+  hardcode_direct=no
+  hardcode_minus_L=no
+  hardcode_shlibpath_var=unsupported
+  link_all_deplibs=unknown
+  hardcode_automatic=no
+  module_cmds=
+  module_expsym_cmds=
+  always_export_symbols=no
+  export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  # include_expsyms should be a list of space-separated symbols to be *always*
+  # included in the symbol list
+  include_expsyms=
+  # exclude_expsyms can be an extended regexp of symbols to exclude
+  # it will be wrapped by ` (' and `)$', so one must not match beginning or
+  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
+  # as well as any symbol that contains `d'.
+  exclude_expsyms="_GLOBAL_OFFSET_TABLE_"
+  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
+  # platforms (ab)use it in PIC code, but their linkers get confused if
+  # the symbol is explicitly referenced.  Since portable code cannot
+  # rely on this symbol name, it's probably fine to never include it in
+  # preloaded symbol tables.
+  extract_expsyms_cmds=
+  # Just being paranoid about ensuring that cc_basename is set.
+  for cc_temp in $compiler""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
 done
+cc_basename=`$echo "X$cc_temp" | $Xsed -e 's%.*/%%' -e "s%^$host_alias-%%"`
 
+  case $host_os in
+  cygwin* | mingw* | pw32*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+  esac
 
-for ac_header in dlfcn.h
-do :
-  ac_fn_c_check_header_compile "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default
-"
-if test "x$ac_cv_header_dlfcn_h" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_DLFCN_H 1
-_ACEOF
+  ld_shlibs=yes
+  if test "$with_gnu_ld" = yes; then
+    # If archive_cmds runs LD, not CC, wlarc should be empty
+    wlarc='${wl}'
 
-fi
+    # Set some defaults for GNU ld with shared library support. These
+    # are reset later if shared libraries are not supported. Putting them
+    # here allows them to be overridden if necessary.
+    runpath_var=LD_RUN_PATH
+    hardcode_libdir_flag_spec='${wl}--rpath ${wl}$libdir'
+    export_dynamic_flag_spec='${wl}--export-dynamic'
+    # ancient GNU ld didn't support --whole-archive et. al.
+    if $LD --help 2>&1 | grep 'no-whole-archive' > /dev/null; then
+	whole_archive_flag_spec="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+      else
+  	whole_archive_flag_spec=
+    fi
+    supports_anon_versioning=no
+    case `$LD -v 2>/dev/null` in
+      *\ [01].* | *\ 2.[0-9].* | *\ 2.10.*) ;; # catch versions < 2.11
+      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
+      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
+      *\ 2.11.*) ;; # other 2.11 versions
+      *) supports_anon_versioning=yes ;;
+    esac
 
-done
+    # See if GNU ld supports shared libraries.
+    case $host_os in
+    aix3* | aix4* | aix5*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+	ld_shlibs=no
+	cat <<EOF 1>&2
 
+*** Warning: the GNU linker, at least up to release 2.9.1, is reported
+*** to be unable to reliably create shared libraries on AIX.
+*** Therefore, libtool is disabling shared libraries support.  If you
+*** really care for shared libraries, you may want to modify your PATH
+*** so that a non-GNU linker is found, and then restart.
 
+EOF
+      fi
+      ;;
 
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-if test -z "$CXX"; then
-  if test -n "$CCC"; then
-    CXX=$CCC
-  else
-    if test -n "$ac_tool_prefix"; then
-  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_CXX+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CXX"; then
-  ac_cv_prog_CXX="$CXX" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
+    amigaos*)
+      archive_cmds='$rm $output_objdir/a2ixlibrary.data~$echo "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$echo "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$echo "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$echo "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
 
-fi
-fi
-CXX=$ac_cv_prog_CXX
-if test -n "$CXX"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CXX" >&5
-$as_echo "$CXX" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
+      # Samuel A. Falvo II <kc5tja@dolphin.openprojects.net> reports
+      # that the semantics of dynamic libraries on AmigaOS, at least up
+      # to version 4, is to share data among multiple programs linked
+      # with the same dynamic library.  Since this doesn't match the
+      # behavior of shared libraries on other platforms, we can't use
+      # them.
+      ld_shlibs=no
+      ;;
 
+    beos*)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+	allow_undefined_flag=unsupported
+	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	# support --undefined.  This deserves some investigation.  FIXME
+	archive_cmds='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
 
-    test -n "$CXX" && break
-  done
-fi
-if test -z "$CXX"; then
-  ac_ct_CXX=$CXX
-  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_prog_ac_ct_CXX+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_CXX"; then
-  ac_cv_prog_ac_ct_CXX="$ac_ct_CXX" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_CXX="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
+    cygwin* | mingw* | pw32*)
+      # _LT_AC_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
+      # as there is no search path for DLLs.
+      hardcode_libdir_flag_spec='-L$libdir'
+      allow_undefined_flag=unsupported
+      always_export_symbols=no
+      enable_shared_with_static_runtimes=yes
+      export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS] /s/.* \([^ ]*\)/\1 DATA/'\'' | $SED -e '\''/^[AITW] /s/.* //'\'' | sort | uniq > $export_symbols'
 
-fi
-fi
-ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
-if test -n "$ac_ct_CXX"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CXX" >&5
-$as_echo "$ac_ct_CXX" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
+      if $LD --help 2>&1 | grep 'auto-import' > /dev/null; then
+        archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	# If the export-symbols file already is a .def file (1st line
+	# is EXPORTS), use it as is; otherwise, prepend...
+	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	  cp $export_symbols $output_objdir/$soname.def;
+	else
+	  echo EXPORTS > $output_objdir/$soname.def;
+	  cat $export_symbols >> $output_objdir/$soname.def;
+	fi~
+	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
 
+    interix3*)
+      hardcode_direct=no
+      hardcode_shlibpath_var=no
+      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+      export_dynamic_flag_spec='${wl}-E'
+      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+      # Instead, shared libraries are loaded at an image base (0x10000000 by
+      # default) and relocated if they conflict, which is a slow very memory
+      # consuming and fragmenting process.  To avoid this, we pick a random,
+      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+      archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      archive_expsym_cmds='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      ;;
 
-  test -n "$ac_ct_CXX" && break
-done
+    linux*)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+	tmp_addflag=
+	case $cc_basename,$host_cpu in
+	pgcc*)				# Portland Group C compiler
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $echo \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag'
+	  ;;
+	pgf77* | pgf90* | pgf95*)	# Portland Group f77 and f90 compilers
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $echo \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag -Mnomain' ;;
+	ecc*,ia64* | icc*,ia64*)		# Intel C compiler on ia64
+	  tmp_addflag=' -i_dynamic' ;;
+	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
+	  tmp_addflag=' -i_dynamic -nofor_main' ;;
+	ifc* | ifort*)			# Intel Fortran compiler
+	  tmp_addflag=' -nofor_main' ;;
+	esac
+	archive_cmds='$CC -shared'"$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
 
-  if test "x$ac_ct_CXX" = x; then
-    CXX="g++"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    CXX=$ac_ct_CXX
-  fi
-fi
+	if test $supports_anon_versioning = yes; then
+	  archive_expsym_cmds='$echo "{ global:" > $output_objdir/$libname.ver~
+  cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+  $echo "local: *; };" >> $output_objdir/$libname.ver~
+	  $CC -shared'"$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+	fi
+      else
+	ld_shlibs=no
+      fi
+      ;;
 
-  fi
-fi
-# Provide some information about the compiler.
-$as_echo "$as_me:${as_lineno-$LINENO}: checking for C++ compiler version" >&5
-set X $ac_compile
-ac_compiler=$2
-for ac_option in --version -v -V -qversion; do
-  { { ac_try="$ac_compiler $ac_option >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    sed '10a\
-... rest of stderr output deleted ...
-         10q' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-  fi
-  rm -f conftest.er1 conftest.err
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-done
+    netbsd*)
+      if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
+	archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
+	wlarc=
+      else
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      fi
+      ;;
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C++ compiler" >&5
-$as_echo_n "checking whether we are using the GNU C++ compiler... " >&6; }
-if test "${ac_cv_cxx_compiler_gnu+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+    solaris*)
+      if $LD -v 2>&1 | grep 'BFD 2\.8' > /dev/null; then
+	ld_shlibs=no
+	cat <<EOF 1>&2
 
-int
-main ()
-{
-#ifndef __GNUC__
-       choke me
-#endif
+*** Warning: The releases 2.8.* of the GNU linker cannot reliably
+*** create shared libraries on Solaris systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.9.1 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
 
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  ac_compiler_gnu=yes
-else
-  ac_compiler_gnu=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
+EOF
+      elif $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cxx_compiler_gnu" >&5
-$as_echo "$ac_cv_cxx_compiler_gnu" >&6; }
-if test $ac_compiler_gnu = yes; then
-  GXX=yes
-else
-  GXX=
-fi
-ac_test_CXXFLAGS=${CXXFLAGS+set}
-ac_save_CXXFLAGS=$CXXFLAGS
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CXX accepts -g" >&5
-$as_echo_n "checking whether $CXX accepts -g... " >&6; }
-if test "${ac_cv_prog_cxx_g+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_save_cxx_werror_flag=$ac_cxx_werror_flag
-   ac_cxx_werror_flag=yes
-   ac_cv_prog_cxx_g=no
-   CXXFLAGS="-g"
-   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
 
-int
-main ()
-{
+*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
+*** reliably create shared libraries on SCO systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
 
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  ac_cv_prog_cxx_g=yes
-else
-  CXXFLAGS=""
-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+_LT_EOF
+	;;
+	*)
+	  if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+	    hardcode_libdir_flag_spec='`test -z "$SCOABSPATH" && echo ${wl}-rpath,$libdir`'
+	    archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib'
+	    archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname,\${SCOABSPATH:+${install_libdir}/}$soname,-retain-symbols-file,$export_symbols -o $lib'
+	  else
+	    ld_shlibs=no
+	  fi
+	;;
+      esac
+      ;;
+
+    sunos4*)
+      archive_cmds='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      wlarc=
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    *)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+    esac
+
+    if test "$ld_shlibs" = no; then
+      runpath_var=
+      hardcode_libdir_flag_spec=
+      export_dynamic_flag_spec=
+      whole_archive_flag_spec=
+    fi
+  else
+    # PORTME fill in a description of your system's linker (not GNU ld)
+    case $host_os in
+    aix3*)
+      allow_undefined_flag=unsupported
+      always_export_symbols=yes
+      archive_expsym_cmds='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      hardcode_minus_L=yes
+      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
+	# Neither direct hardcoding nor static linking is supported with a
+	# broken collect2.
+	hardcode_direct=unsupported
+      fi
+      ;;
+
+    aix4* | aix5*)
+      if test "$host_cpu" = ia64; then
+	# On IA64, the linker does run time linking by default, so we don't
+	# have to do anything special.
+	aix_use_runtimelinking=no
+	exp_sym_flag='-Bexport'
+	no_entry_flag=""
+      else
+	# If we're using GNU nm, then we don't want the "-C" option.
+	# -C means demangle to AIX nm, but means don't demangle with GNU nm
+	if $NM -V 2>&1 | grep 'GNU' > /dev/null; then
+	  export_symbols_cmds='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$2 == "T") || (\$2 == "D") || (\$2 == "B")) && (substr(\$3,1,1) != ".")) { print \$3 } }'\'' | sort -u > $export_symbols'
+	else
+	  export_symbols_cmds='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$2 == "T") || (\$2 == "D") || (\$2 == "B")) && (substr(\$3,1,1) != ".")) { print \$3 } }'\'' | sort -u > $export_symbols'
+	fi
+	aix_use_runtimelinking=no
+
+	# Test if we are trying to use run time linking or normal
+	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
+	# need to do runtime linking.
+	case $host_os in aix4.[23]|aix4.[23].*|aix5*)
+	  for ld_flag in $LDFLAGS; do
+  	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+  	    aix_use_runtimelinking=yes
+  	    break
+  	  fi
+	  done
+	  ;;
+	esac
+
+	exp_sym_flag='-bexport'
+	no_entry_flag='-bnoentry'
+      fi
+
+      # When large executables or shared objects are built, AIX ld can
+      # have problems creating the table of contents.  If linking a library
+      # or program results in "error TOC overflow" add -mminimal-toc to
+      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+      archive_cmds=''
+      hardcode_direct=yes
+      hardcode_libdir_separator=':'
+      link_all_deplibs=yes
+
+      if test "$GCC" = yes; then
+	case $host_os in aix4.[012]|aix4.[012].*)
+	# We only want to do this on AIX 4.2 and lower, the check
+	# below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" && \
+  	   strings "$collect2name" | grep resolve_lib_name >/dev/null
+	  then
+  	  # We have reworked collect2
+  	  hardcode_direct=yes
+	  else
+  	  # We have old collect2
+  	  hardcode_direct=unsupported
+  	  # It fails to find uninstalled libraries when the uninstalled
+  	  # path is not listed in the libpath.  Setting hardcode_minus_L
+  	  # to unsupported forces relinking
+  	  hardcode_minus_L=yes
+  	  hardcode_libdir_flag_spec='-L$libdir'
+  	  hardcode_libdir_separator=
+	  fi
+	  ;;
+	esac
+	shared_flag='-shared'
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag="$shared_flag "'${wl}-G'
+	fi
+      else
+	# not using gcc
+	if test "$host_cpu" = ia64; then
+  	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+  	# chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+	else
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag='${wl}-G'
+	  else
+	    shared_flag='${wl}-bM:SRE'
+	  fi
+	fi
+      fi
+
+      # It seems that -bexpall does not export symbols beginning with
+      # underscore (_), so it is better to generate a list of symbols to export.
+      always_export_symbols=yes
+      if test "$aix_use_runtimelinking" = yes; then
+	# Warning - without using the other runtime loading flags (-brtl),
+	# -berok will link without error, but may produce a broken library.
+	allow_undefined_flag='-berok'
+       # Determine the default libpath from the value encoded in an empty executable.
+       cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 int
@@ -7700,11 +7991,27 @@
   return 0;
 }
 _ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
+if ac_fn_c_try_link "$LINENO"; then :
 
-else
-  ac_cxx_werror_flag=$ac_save_cxx_werror_flag
-	 CXXFLAGS="-g"
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`; fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+
+       hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+	archive_expsym_cmds="\$CC"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then echo "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+       else
+	if test "$host_cpu" = ia64; then
+	  hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+	  allow_undefined_flag="-z nodefs"
+	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	else
+	 # Determine the default libpath from the value encoded in an empty executable.
 	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -7716,5977 +8023,9196 @@
   return 0;
 }
 _ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  ac_cv_prog_cxx_g=yes
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-   ac_cxx_werror_flag=$ac_save_cxx_werror_flag
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cxx_g" >&5
-$as_echo "$ac_cv_prog_cxx_g" >&6; }
-if test "$ac_test_CXXFLAGS" = set; then
-  CXXFLAGS=$ac_save_CXXFLAGS
-elif test $ac_cv_prog_cxx_g = yes; then
-  if test "$GXX" = yes; then
-    CXXFLAGS="-g -O2"
-  else
-    CXXFLAGS="-g"
-  fi
-else
-  if test "$GXX" = yes; then
-    CXXFLAGS="-O2"
-  else
-    CXXFLAGS=
-  fi
-fi
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-
-depcc="$CXX"  am_compiler_list=
+if ac_fn_c_try_link "$LINENO"; then :
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
-$as_echo_n "checking dependency style of $depcc... " >&6; }
-if test "${am_cv_CXX_dependencies_compiler_type+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
-  # We make a subdir and do the tests there.  Otherwise we can end up
-  # making bogus files that we don't know about and never remove.  For
-  # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
-  mkdir conftest.dir
-  # Copy depcomp to subdir because otherwise we won't find it if we're
-  # using a relative directory.
-  cp "$am_depcomp" conftest.dir
-  cd conftest.dir
-  # We will build objects and dependencies in a subdirectory because
-  # it helps to detect inapplicable dependency modes.  For instance
-  # both Tru64's cc and ICC support -MD to output dependencies as a
-  # side effect of compilation, but ICC will put the dependencies in
-  # the current directory while Tru64 will put them in the object
-  # directory.
-  mkdir sub
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`; fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
 
-  am_cv_CXX_dependencies_compiler_type=none
-  if test "$am_compiler_list" = ""; then
-     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
-  fi
-  am__universal=false
-  case " $depcc " in #(
-     *\ -arch\ *\ -arch\ *) am__universal=true ;;
-     esac
+	 hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+	  # Warning - without using the other run time loading flags,
+	  # -berok will link without error, but may produce a broken library.
+	  no_undefined_flag=' ${wl}-bernotok'
+	  allow_undefined_flag=' ${wl}-berok'
+	  # Exported symbols can be pulled into shared objects from archives
+	  whole_archive_flag_spec='$convenience'
+	  archive_cmds_need_lc=yes
+	  # This is similar to how AIX traditionally builds its shared libraries.
+	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	fi
+      fi
+      ;;
 
-  for depmode in $am_compiler_list; do
-    # Setup a source with many dependencies, because some compilers
-    # like to wrap large dependency lists on column 80 (with \), and
-    # we should not choose a depcomp mode which is confused by this.
-    #
-    # We need to recreate these files for each test, as the compiler may
-    # overwrite some of them when testing with obscure command lines.
-    # This happens at least with the AIX C compiler.
-    : > sub/conftest.c
-    for i in 1 2 3 4 5 6; do
-      echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
-    done
-    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+    amigaos*)
+      archive_cmds='$rm $output_objdir/a2ixlibrary.data~$echo "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$echo "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$echo "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$echo "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      # see comment about different semantics on the GNU ld section
+      ld_shlibs=no
+      ;;
 
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
-    # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
-    am__obj=sub/conftest.${OBJEXT-o}
-    am__minus_obj="-o $am__obj"
-    case $depmode in
-    gcc)
-      # This depmode causes a compiler race in universal mode.
-      test "$am__universal" = false || continue
+    bsdi[45]*)
+      export_dynamic_flag_spec=-rdynamic
       ;;
-    nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
-      if test "x$enable_dependency_tracking" = xyes; then
-	continue
-      else
-	break
-      fi
-      ;;
-    msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
-      # not run yet.  These depmodes are late enough in the game, and
-      # so weak that their functioning should not be impacted.
-      am__obj=conftest.${OBJEXT-o}
-      am__minus_obj=
+
+    cygwin* | mingw* | pw32*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec=' '
+      allow_undefined_flag=unsupported
+      # Tell ltmain to make .lib files, not .a files.
+      libext=lib
+      # Tell ltmain to make .dll files, not .so files.
+      shrext_cmds=".dll"
+      # FIXME: Setting linknames here is a bad hack.
+      archive_cmds='$CC -o $lib $libobjs $compiler_flags `echo "$deplibs" | $SED -e '\''s/ -lc$//'\''` -link -dll~linknames='
+      # The linker will automatically build a .lib file if we build a DLL.
+      old_archive_From_new_cmds='true'
+      # FIXME: Should let the user specify the lib program.
+      old_archive_cmds='lib /OUT:$oldlib$oldobjs$old_deplibs'
+      fix_srcfile_path='`cygpath -w "$srcfile"`'
+      enable_shared_with_static_runtimes=yes
       ;;
-    none) break ;;
-    esac
-    if depmode=$depmode \
-       source=sub/conftest.c object=$am__obj \
-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
-       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
-         >/dev/null 2>conftest.err &&
-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
-       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
-      # icc doesn't choke on unknown options, it will just issue warnings
-      # or remarks (even with -Werror).  So we grep stderr for any message
-      # that says an option was ignored or not supported.
-      # When given -MP, icc 7.0 and 7.1 complain thusly:
-      #   icc: Command line warning: ignoring option '-M'; no argument required
-      # The diagnosis changed in icc 8.0:
-      #   icc: Command line remark: option '-MP' not supported
-      if (grep 'ignoring option' conftest.err ||
-          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
-        am_cv_CXX_dependencies_compiler_type=$depmode
-        break
-      fi
+
+    darwin* | rhapsody*)
+      case $host_os in
+        rhapsody* | darwin1.[012])
+         allow_undefined_flag='${wl}-undefined ${wl}suppress'
+         ;;
+       *) # Darwin 1.3 on
+         if test -z ${MACOSX_DEPLOYMENT_TARGET} ; then
+           allow_undefined_flag='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
+         else
+           case ${MACOSX_DEPLOYMENT_TARGET} in
+             10.[012])
+               allow_undefined_flag='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
+               ;;
+             10.*)
+               allow_undefined_flag='${wl}-undefined ${wl}dynamic_lookup'
+               ;;
+           esac
+         fi
+         ;;
+      esac
+      archive_cmds_need_lc=no
+      hardcode_direct=no
+      hardcode_automatic=yes
+      hardcode_shlibpath_var=unsupported
+      whole_archive_flag_spec=''
+      link_all_deplibs=yes
+    if test "$GCC" = yes ; then
+    	output_verbose_link_cmd='echo'
+        archive_cmds='$CC -dynamiclib $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+      module_cmds='$CC $allow_undefined_flag -o $lib -bundle $libobjs $deplibs$compiler_flags'
+      # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin lds
+      archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -dynamiclib $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+      module_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC $allow_undefined_flag  -o $lib -bundle $libobjs $deplibs$compiler_flags~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+    else
+      case $cc_basename in
+        xlc*)
+         output_verbose_link_cmd='echo'
+         archive_cmds='$CC -qmkshrobj $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-install_name ${wl}`echo $rpath/$soname` $verstring'
+         module_cmds='$CC $allow_undefined_flag -o $lib -bundle $libobjs $deplibs$compiler_flags'
+          # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin lds
+         archive_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -qmkshrobj $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-install_name ${wl}$rpath/$soname $verstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          module_expsym_cmds='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC $allow_undefined_flag  -o $lib -bundle $libobjs $deplibs$compiler_flags~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          ;;
+       *)
+         ld_shlibs=no
+          ;;
+      esac
     fi
-  done
+      ;;
 
-  cd ..
-  rm -rf conftest.dir
-else
-  am_cv_CXX_dependencies_compiler_type=none
-fi
+    dgux*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_shlibpath_var=no
+      ;;
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_CXX_dependencies_compiler_type" >&5
-$as_echo "$am_cv_CXX_dependencies_compiler_type" >&6; }
-CXXDEPMODE=depmode=$am_cv_CXX_dependencies_compiler_type
+    freebsd1*)
+      ld_shlibs=no
+      ;;
 
- if
-  test "x$enable_dependency_tracking" != xno \
-  && test "$am_cv_CXX_dependencies_compiler_type" = gcc3; then
-  am__fastdepCXX_TRUE=
-  am__fastdepCXX_FALSE='#'
-else
-  am__fastdepCXX_TRUE='#'
-  am__fastdepCXX_FALSE=
-fi
+    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+    # support.  Future versions do this automatically, but an explicit c++rt0.o
+    # does not break anything, and helps significantly (at the cost of a little
+    # extra space).
+    freebsd2.2*)
+      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
 
+    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
+    freebsd2*)
+      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      hardcode_shlibpath_var=no
+      ;;
 
-if test -n "$CXX" && ( test "X$CXX" != "Xno" &&
-    ( (test "X$CXX" = "Xg++" && `g++ -v >/dev/null 2>&1` ) ||
-    (test "X$CXX" != "Xg++"))) ; then
-  ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C++ preprocessor" >&5
-$as_echo_n "checking how to run the C++ preprocessor... " >&6; }
-if test -z "$CXXCPP"; then
-  if test "${ac_cv_prog_CXXCPP+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-      # Double quotes because CXXCPP needs to be expanded
-    for CXXCPP in "$CXX -E" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_cxx_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_cxx_try_cpp "$LINENO"; then :
+    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
+    freebsd* | kfreebsd*-gnu | dragonfly*)
+      archive_cmds='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
 
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.$ac_ext
+    hpux9*)
+      if test "$GCC" = yes; then
+	archive_cmds='$rm $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      else
+	archive_cmds='$rm $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      fi
+      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_direct=yes
 
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_cxx_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.$ac_ext
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      hardcode_minus_L=yes
+      export_dynamic_flag_spec='${wl}-E'
+      ;;
 
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-  break
-fi
+    hpux10*)
+      if test "$GCC" = yes -a "$with_gnu_ld" = no; then
+	archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+	hardcode_libdir_separator=:
 
-    done
-    ac_cv_prog_CXXCPP=$CXXCPP
+	hardcode_direct=yes
+	export_dynamic_flag_spec='${wl}-E'
 
-fi
-  CXXCPP=$ac_cv_prog_CXXCPP
-else
-  ac_cv_prog_CXXCPP=$CXXCPP
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CXXCPP" >&5
-$as_echo "$CXXCPP" >&6; }
-ac_preproc_ok=false
-for ac_cxx_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_cxx_try_cpp "$LINENO"; then :
+	# hardcode_minus_L: Not really in the search PATH,
+	# but as the default location of the library.
+	hardcode_minus_L=yes
+      fi
+      ;;
 
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_cxx_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-_lt_caught_CXX_error=yes; }
-fi
-
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-
-else
-  _lt_caught_CXX_error=yes
-fi
+    hpux11*)
+      if test "$GCC" = yes -a "$with_gnu_ld" = no; then
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds='$CC -shared ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      else
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+	hardcode_libdir_separator=:
 
+	case $host_cpu in
+	hppa*64*|ia64*)
+	  hardcode_libdir_flag_spec_ld='+b $libdir'
+	  hardcode_direct=no
+	  hardcode_shlibpath_var=no
+	  ;;
+	*)
+	  hardcode_direct=yes
+	  export_dynamic_flag_spec='${wl}-E'
 
+	  # hardcode_minus_L: Not really in the search PATH,
+	  # but as the default location of the library.
+	  hardcode_minus_L=yes
+	  ;;
+	esac
+      fi
+      ;;
 
+    irix5* | irix6* | nonstopux*)
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	archive_cmds='$LD -shared $libobjs $deplibs $linker_flags -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+	hardcode_libdir_flag_spec_ld='-rpath $libdir'
+      fi
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      link_all_deplibs=yes
+      ;;
 
+    netbsd*)
+      if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
+	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
+      else
+	archive_cmds='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
+      fi
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
 
-# Set options
+    newsos6)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct=yes
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_shlibpath_var=no
+      ;;
 
+    openbsd*)
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
+	hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+	export_dynamic_flag_spec='${wl}-E'
+      else
+       case $host_os in
+	 openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+	   archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+	   hardcode_libdir_flag_spec='-R$libdir'
+	   ;;
+	 *)
+	   archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	   hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+	   ;;
+       esac
+      fi
+      ;;
 
+    os2*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      allow_undefined_flag=unsupported
+      archive_cmds='$echo "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$echo "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~$echo DATA >> $output_objdir/$libname.def~$echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~$echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
+      old_archive_From_new_cmds='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+      ;;
 
-        enable_dlopen=no
+    osf3*)
+      if test "$GCC" = yes; then
+	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	allow_undefined_flag=' -expect_unresolved \*'
+	archive_cmds='$LD -shared${allow_undefined_flag} $libobjs $deplibs $linker_flags -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+      fi
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
 
+    osf4* | osf5*)	# as osf3* with the addition of -msym flag
+      if test "$GCC" = yes; then
+	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      else
+	allow_undefined_flag=' -expect_unresolved \*'
+	archive_cmds='$LD -shared${allow_undefined_flag} $libobjs $deplibs $linker_flags -msym -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_expsym_cmds='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; echo "-hidden">> $lib.exp~
+	$LD -shared${allow_undefined_flag} -input $lib.exp $linker_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib~$rm $lib.exp'
 
-  enable_win32_dll=no
+	# Both c and cxx compiler support -rpath directly
+	hardcode_libdir_flag_spec='-rpath $libdir'
+      fi
+      hardcode_libdir_separator=:
+      ;;
 
+    solaris*)
+      no_undefined_flag=' -z text'
+      if test "$GCC" = yes; then
+	wlarc='${wl}'
+	archive_cmds='$CC -shared ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~$echo "local: *; };" >> $lib.exp~
+	  $CC -shared ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$rm $lib.exp'
+      else
+	wlarc=''
+	archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	archive_expsym_cmds='$echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~$echo "local: *; };" >> $lib.exp~
+  	$LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$rm $lib.exp'
+      fi
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_shlibpath_var=no
+      case $host_os in
+      solaris2.[0-5] | solaris2.[0-5].*) ;;
+      *)
+ 	# The compiler driver will combine linker options so we
+ 	# cannot just pass the convience library names through
+ 	# without $wl, iff we do not link with $LD.
+ 	# Luckily, gcc supports the same syntax we need for Sun Studio.
+ 	# Supported since Solaris 2.6 (maybe 2.5.1?)
+ 	case $wlarc in
+ 	'')
+ 	  whole_archive_flag_spec='-z allextract$convenience -z defaultextract' ;;
+ 	*)
+ 	  whole_archive_flag_spec='${wl}-z ${wl}allextract`for conv in $convenience\"\"; do test -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $echo \"$new_convenience\"` ${wl}-z ${wl}defaultextract' ;;
+ 	esac ;;
+      esac
+      link_all_deplibs=yes
+      ;;
 
-            # Check whether --enable-shared was given.
-if test "${enable_shared+set}" = set; then :
-  enableval=$enable_shared; p=${PACKAGE-default}
-    case $enableval in
-    yes) enable_shared=yes ;;
-    no) enable_shared=no ;;
-    *)
-      enable_shared=no
-      # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
-      for pkg in $enableval; do
-	IFS="$lt_save_ifs"
-	if test "X$pkg" = "X$p"; then
-	  enable_shared=yes
-	fi
-      done
-      IFS="$lt_save_ifs"
+    sunos4*)
+      if test "x$host_vendor" = xsequent; then
+	# Use $CC to link under sequent, because it throws in some extra .o
+	# files that make .init and .fini sections work.
+	archive_cmds='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      hardcode_shlibpath_var=no
       ;;
-    esac
-else
-  enable_shared=yes
-fi
 
+    sysv4)
+      case $host_vendor in
+	sni)
+	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct=yes # is this really true???
+	;;
+	siemens)
+	  ## LD is ld it makes a PLAMLIB
+	  ## CC just makes a GrossModule.
+	  archive_cmds='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+	  reload_cmds='$CC -r -o $output$reload_objs'
+	  hardcode_direct=no
+        ;;
+	motorola)
+	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct=no #Motorola manual says yes, but my tests say they lie
+	;;
+      esac
+      runpath_var='LD_RUN_PATH'
+      hardcode_shlibpath_var=no
+      ;;
 
+    sysv4.3*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_shlibpath_var=no
+      export_dynamic_flag_spec='-Bexport'
+      ;;
 
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	hardcode_shlibpath_var=no
+	runpath_var=LD_RUN_PATH
+	hardcode_runpath_var=yes
+	ld_shlibs=yes
+      fi
+      ;;
 
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7*)
+      no_undefined_flag='${wl}-z,text'
+      archive_cmds_need_lc=no
+      hardcode_shlibpath_var=no
+      runpath_var='LD_RUN_PATH'
 
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
 
+    sysv5* | sco3.2v5* | sco5v6*)
+      # Note: We can NOT use -z defs as we might desire, because we do not
+      # link with -lc, and that would cause any symbols used from libc to
+      # always be unresolved, which means just about no library would
+      # ever link correctly.  If we're not using GNU ld we use -z text
+      # though, which does catch some bad symbols but isn't as heavy-handed
+      # as -z defs.
+      no_undefined_flag='${wl}-z,text'
+      allow_undefined_flag='${wl}-z,nodefs'
+      archive_cmds_need_lc=no
+      hardcode_shlibpath_var=no
+      hardcode_libdir_flag_spec='`test -z "$SCOABSPATH" && echo ${wl}-R,$libdir`'
+      hardcode_libdir_separator=':'
+      link_all_deplibs=yes
+      export_dynamic_flag_spec='${wl}-Bexport'
+      runpath_var='LD_RUN_PATH'
 
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared ${wl}-h,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$CC -G ${wl}-h,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
 
+    uts4*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_shlibpath_var=no
+      ;;
 
-  # Check whether --enable-static was given.
-if test "${enable_static+set}" = set; then :
-  enableval=$enable_static; p=${PACKAGE-default}
-    case $enableval in
-    yes) enable_static=yes ;;
-    no) enable_static=no ;;
     *)
-     enable_static=no
-      # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
-      for pkg in $enableval; do
-	IFS="$lt_save_ifs"
-	if test "X$pkg" = "X$p"; then
-	  enable_static=yes
-	fi
-      done
-      IFS="$lt_save_ifs"
+      ld_shlibs=no
       ;;
     esac
-else
-  enable_static=yes
-fi
-
-
-
-
-
-
-
-
-
-
-# Check whether --with-pic was given.
-if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
-else
-  pic_mode=default
-fi
-
-
-test -z "$pic_mode" && pic_mode=default
-
-
-
+  fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs" >&5
+$as_echo "$ld_shlibs" >&6; }
+test "$ld_shlibs" = no && can_build_shared=no
 
+#
+# Do we need to explicitly link libc?
+#
+case "x$archive_cmds_need_lc" in
+x|xyes)
+  # Assume -lc should be added
+  archive_cmds_need_lc=yes
 
+  if test "$enable_shared" = yes && test "$GCC" = yes; then
+    case $archive_cmds in
+    *'~'*)
+      # FIXME: we may have to deal with multi-command sequences.
+      ;;
+    '$CC '*)
+      # Test whether the compiler implicitly links with -lc since on some
+      # systems, -lgcc has to come before -lc. If gcc already passes -lc
+      # to ld, don't add -lc before -lgcc.
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
+$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
+      $rm conftest*
+      printf "$lt_simple_compile_test_code" > conftest.$ac_ext
 
-  # Check whether --enable-fast-install was given.
-if test "${enable_fast_install+set}" = set; then :
-  enableval=$enable_fast_install; p=${PACKAGE-default}
-    case $enableval in
-    yes) enable_fast_install=yes ;;
-    no) enable_fast_install=no ;;
-    *)
-      enable_fast_install=no
-      # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
-      for pkg in $enableval; do
-	IFS="$lt_save_ifs"
-	if test "X$pkg" = "X$p"; then
-	  enable_fast_install=yes
-	fi
-      done
-      IFS="$lt_save_ifs"
+      if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } 2>conftest.err; then
+        soname=conftest
+        lib=conftest
+        libobjs=conftest.$ac_objext
+        deplibs=
+        wl=$lt_prog_compiler_wl
+	pic_flag=$lt_prog_compiler_pic
+        compiler_flags=-v
+        linker_flags=-v
+        verstring=
+        output_objdir=.
+        libname=conftest
+        lt_save_allow_undefined_flag=$allow_undefined_flag
+        allow_undefined_flag=
+        if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1\""; } >&5
+  (eval $archive_cmds 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+        then
+	  archive_cmds_need_lc=no
+        else
+	  archive_cmds_need_lc=yes
+        fi
+        allow_undefined_flag=$lt_save_allow_undefined_flag
+      else
+        cat conftest.err 1>&5
+      fi
+      $rm conftest*
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $archive_cmds_need_lc" >&5
+$as_echo "$archive_cmds_need_lc" >&6; }
       ;;
     esac
+  fi
+  ;;
+esac
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
+$as_echo_n "checking dynamic linker characteristics... " >&6; }
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+shrext_cmds=".so"
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+if test "$GCC" = yes; then
+  sys_lib_search_path_spec=`$CC -print-search-dirs | grep "^libraries:" | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+  if echo "$sys_lib_search_path_spec" | grep ';' >/dev/null ; then
+    # if the path contains ";" then we assume it to be the separator
+    # otherwise default to the standard path separator (i.e. ":") - it is
+    # assumed that no part of a normal pathname contains ";" but that should
+    # okay in the real world where ";" in dirpaths is itself problematic.
+    sys_lib_search_path_spec=`echo "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
+  else
+    sys_lib_search_path_spec=`echo "$sys_lib_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+  fi
 else
-  enable_fast_install=yes
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
 fi
+need_lib_prefix=unknown
+hardcode_into_libs=no
 
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+need_version=unknown
 
+case $host_os in
+aix3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  shlibpath_var=LIBPATH
 
+  # AIX 3 has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}${shared_ext}$major'
+  ;;
 
+aix4* | aix5*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[01] | aix4.[01].*)
+      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	   echo ' yes '
+	   echo '#endif'; } | ${CC} -E - | grep yes > /dev/null; then
+	:
+      else
+	can_build_shared=no
+      fi
+      ;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # soname into executable. Probably we can add versioning support to
+    # collect2, so additional links can be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}${shared_ext}$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  ;;
 
+amigaos*)
+  library_names_spec='$libname.ixlibrary $libname.a'
+  # Create ${libname}_ixlibrary.a entries in /sys/libs.
+  finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$echo "X$lib" | $Xsed -e '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $rm /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+  ;;
 
+beos*)
+  library_names_spec='${libname}${shared_ext}'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
 
+bsdi[45]*)
+  version_type=linux
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
 
+cygwin* | mingw* | pw32*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
 
+  case $GCC,$host_os in
+  yes,cygwin* | yes,mingw* | yes,pw32*)
+    library_names_spec='$libname.dll.a'
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i;echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname~
+      chmod a+x \$dldir/$dlname'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $rm \$dlpath'
+    shlibpath_overrides_runpath=yes
 
+    case $host_os in
+    cygwin*)
+      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
+      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      sys_lib_search_path_spec="/usr/lib /lib/w32api /lib /usr/local/lib"
+      ;;
+    mingw*)
+      # MinGW DLLs use traditional 'lib' prefix
+      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      sys_lib_search_path_spec=`$CC -print-search-dirs | grep "^libraries:" | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+      if echo "$sys_lib_search_path_spec" | grep ';[c-zC-Z]:/' >/dev/null; then
+        # It is most probably a Windows format PATH printed by
+        # mingw gcc, but we are running on Cygwin. Gcc prints its search
+        # path with ; separators, and with drive letters. We can handle the
+        # drive letters (cygwin fileutils understands them), so leave them,
+        # especially as we might pass files found there to a mingw objdump,
+        # which wouldn't understand a cygwinified path. Ahh.
+        sys_lib_search_path_spec=`echo "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
+      else
+        sys_lib_search_path_spec=`echo "$sys_lib_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+      fi
+      ;;
+    pw32*)
+      # pw32 DLLs use 'pw' prefix rather than 'lib'
+      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    esac
+    ;;
 
-# This can be used to rebuild libtool when needed
-LIBTOOL_DEPS="$ltmain"
-
-# Always use our own libtool.
-LIBTOOL='$(SHELL) $(top_builddir)/libtool'
-
-
-
-
-
-
-
-
-
-
-
-
-
+  *)
+    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    ;;
+  esac
+  dynamic_linker='Win32 ld.exe'
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
 
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${versuffix}$shared_ext ${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  soname_spec='${libname}${release}${major}$shared_ext'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
+  # Apple's gcc prints 'gcc -print-search-dirs' doesn't operate the same.
+  if test "$GCC" = yes; then
+    sys_lib_search_path_spec=`$CC -print-search-dirs | tr "\n" "$PATH_SEPARATOR" | sed -e 's/libraries:/@libraries:/' | tr "@" "\n" | grep "^libraries:" | sed -e "s/^libraries://" -e "s,=/,/,g" -e "s,$PATH_SEPARATOR, ,g" -e "s,.*,& /lib /usr/lib /usr/local/lib,g"`
+  else
+    sys_lib_search_path_spec='/lib /usr/lib /usr/local/lib'
+  fi
+  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
+  ;;
 
+dgux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
 
+freebsd1*)
+  dynamic_linker=no
+  ;;
 
+kfreebsd*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='GNU ld.so'
+  ;;
 
+freebsd* | dragonfly*)
+  # DragonFly does not have aout.  When/if they implement a new
+  # versioning mechanism, adjust this.
+  if test -x /usr/bin/objformat; then
+    objformat=`/usr/bin/objformat`
+  else
+    case $host_os in
+    freebsd[123]*) objformat=aout ;;
+    *) objformat=elf ;;
+    esac
+  fi
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  freebsd3.[01]* | freebsdelf3.[01]*)
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
+  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  freebsd*) # from 4.6 on
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
 
+gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  ;;
 
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  case $host_cpu in
+  ia64*)
+    shrext_cmds='.so'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.so"
+    shlibpath_var=LD_LIBRARY_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    if test "X$HPUX_IA64_MODE" = X32; then
+      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+    else
+      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    fi
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+   hppa*64*)
+     shrext_cmds='.sl'
+     hardcode_into_libs=yes
+     dynamic_linker="$host_os dld.sl"
+     shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+     shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+     library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+     soname_spec='${libname}${release}${shared_ext}$major'
+     sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+     sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+     ;;
+   *)
+    shrext_cmds='.sl'
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=SHLIB_PATH
+    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    ;;
+  esac
+  # HP-UX runs *really* slowly unless shared libraries are mode 555.
+  postinstall_cmds='chmod 555 $lib'
+  ;;
 
+interix3*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
 
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)
+	if test "$lt_cv_prog_gnu_ld" = yes; then
+		version_type=linux
+	else
+		version_type=irix
+	fi ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
+      libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
+      libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
+      libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  hardcode_into_libs=yes
+  ;;
 
+# No shared lib support for Linux oldld, aout, or coff.
+linux*oldld* | linux*aout* | linux*coff*)
+  dynamic_linker=no
+  ;;
 
+# This must be Linux ELF.
+linux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
 
-test -z "$LN_S" && LN_S="ln -s"
+  # find out which ABI we are using
+  libsuff=
+  case "$host_cpu" in
+  x86_64*|s390x*|powerpc64*)
+    echo '#line 8942 "configure"' > conftest.$ac_ext
+    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+      case `/usr/bin/file conftest.$ac_objext` in
+      *64-bit*)
+        libsuff=64
+        sys_lib_search_path_spec="/lib${libsuff} /usr/lib${libsuff} /usr/local/lib${libsuff}"
+        ;;
+      esac
+    fi
+    rm -rf conftest*
+    ;;
+  esac
 
+  # Append ld.so.conf contents to the search path
+  if test -f /etc/ld.so.conf; then
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib${libsuff} /usr/lib${libsuff} $lt_ld_extra"
+  fi
 
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
 
+knetbsd*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='GNU ld.so'
+  ;;
 
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
 
+newsos6)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
 
+nto-qnx*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
 
+openbsd*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec="/usr/lib"
+  need_lib_prefix=no
+  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
+  case $host_os in
+    openbsd3.3 | openbsd3.3.*) need_version=yes ;;
+    *)                         need_version=no  ;;
+  esac
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case $host_os in
+      openbsd2.[89] | openbsd2.[89].*)
+	shlibpath_overrides_runpath=no
+	;;
+      *)
+	shlibpath_overrides_runpath=yes
+	;;
+      esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  ;;
 
+os2*)
+  libname_spec='$name'
+  shrext_cmds=".dll"
+  need_lib_prefix=no
+  library_names_spec='$libname${shared_ext} $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
 
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  ;;
 
+solaris*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
 
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
 
+sysv4 | sysv4.3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      export_dynamic_flag_spec='${wl}-Blargedynsym'
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
 
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux
+    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
+    soname_spec='$libname${shared_ext}.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
 
-if test -n "${ZSH_VERSION+set}" ; then
-   setopt NO_GLOB_SUBST
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for objdir" >&5
-$as_echo_n "checking for objdir... " >&6; }
-if test "${lt_cv_objdir+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  rm -f .libs 2>/dev/null
-mkdir .libs 2>/dev/null
-if test -d .libs; then
-  lt_cv_objdir=.libs
-else
-  # MS-DOS does not allow filenames that begin with a dot.
-  lt_cv_objdir=_libs
-fi
-rmdir .libs 2>/dev/null
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_objdir" >&5
-$as_echo "$lt_cv_objdir" >&6; }
-objdir=$lt_cv_objdir
-
-
-
-
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  version_type=freebsd-elf
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  if test "$with_gnu_ld" = yes; then
+    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+    shlibpath_overrides_runpath=no
+  else
+    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    shlibpath_overrides_runpath=yes
+    case $host_os in
+      sco3.2v5*)
+        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
+	;;
+    esac
+  fi
+  sys_lib_dlsearch_path_spec='/usr/lib'
+  ;;
 
-cat >>confdefs.h <<_ACEOF
-#define LT_OBJDIR "$lt_cv_objdir/"
-_ACEOF
+uts4*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
 
+*)
+  dynamic_linker=no
+  ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
+$as_echo "$dynamic_linker" >&6; }
+test "$dynamic_linker" = no && can_build_shared=no
 
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
+$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
+hardcode_action=
+if test -n "$hardcode_libdir_flag_spec" || \
+   test -n "$runpath_var" || \
+   test "X$hardcode_automatic" = "Xyes" ; then
 
+  # We can hardcode non-existant directories.
+  if test "$hardcode_direct" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$_LT_AC_TAGVAR(hardcode_shlibpath_var, )" != no &&
+     test "$hardcode_minus_L" != no; then
+    # Linking always hardcodes the temporary library directory.
+    hardcode_action=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    hardcode_action=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  hardcode_action=unsupported
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action" >&5
+$as_echo "$hardcode_action" >&6; }
 
+if test "$hardcode_action" = relink; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
 
+striplib=
+old_striplib=
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stripping libraries is possible" >&5
+$as_echo_n "checking whether stripping libraries is possible... " >&6; }
+if test -n "$STRIP" && $STRIP -V 2>&1 | grep "GNU strip" >/dev/null; then
+  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
+  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+# FIXME - insert some real tests, host_os isn't really good enough
+  case $host_os in
+   darwin*)
+       if test -n "$STRIP" ; then
+         striplib="$STRIP -x"
+         { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+       else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+       ;;
+   *)
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    ;;
+  esac
+fi
 
+if test "x$enable_dlopen" != xyes; then
+  enable_dlopen=unknown
+  enable_dlopen_self=unknown
+  enable_dlopen_self_static=unknown
+else
+  lt_cv_dlopen=no
+  lt_cv_dlopen_libs=
 
+  case $host_os in
+  beos*)
+    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ;;
 
+  mingw* | pw32*)
+    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen_libs=
+   ;;
 
+  cygwin*)
+    lt_cv_dlopen="dlopen"
+    lt_cv_dlopen_libs=
+   ;;
 
+  darwin*)
+  # if libdl is installed we need to link against it
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dl_dlopen=yes
+else
+  ac_cv_lib_dl_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+else
 
+    lt_cv_dlopen="dyld"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
 
+fi
 
+   ;;
 
+  *)
+    ac_fn_c_check_func "$LINENO" "shl_load" "ac_cv_func_shl_load"
+if test "x$ac_cv_func_shl_load" = x""yes; then :
+  lt_cv_dlopen="shl_load"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shl_load in -ldld" >&5
+$as_echo_n "checking for shl_load in -ldld... " >&6; }
+if test "${ac_cv_lib_dld_shl_load+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-case $host_os in
-aix3*)
-  # AIX sometimes has problems with the GCC collect2 program.  For some
-  # reason, if we set the COLLECT_NAMES environment variable, the problems
-  # vanish in a puff of smoke.
-  if test "X${COLLECT_NAMES+set}" != Xset; then
-    COLLECT_NAMES=
-    export COLLECT_NAMES
-  fi
-  ;;
-esac
-
-# Sed substitution that helps us do robust quoting.  It backslashifies
-# metacharacters that are still active within double-quoted strings.
-sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
-
-# Same as above, but do not quote variable references.
-double_quote_subst='s/\(["`\\]\)/\\\1/g'
-
-# Sed substitution to delay expansion of an escaped shell variable in a
-# double_quote_subst'ed string.
-delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
-
-# Sed substitution to delay expansion of an escaped single quote.
-delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char shl_load ();
+int
+main ()
+{
+return shl_load ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dld_shl_load=yes
+else
+  ac_cv_lib_dld_shl_load=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_shl_load" >&5
+$as_echo "$ac_cv_lib_dld_shl_load" >&6; }
+if test "x$ac_cv_lib_dld_shl_load" = x""yes; then :
+  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-dld"
+else
+  ac_fn_c_check_func "$LINENO" "dlopen" "ac_cv_func_dlopen"
+if test "x$ac_cv_func_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-# Sed substitution to avoid accidental globbing in evaled expressions
-no_glob_subst='s/\*/\\\*/g'
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dl_dlopen=yes
+else
+  ac_cv_lib_dl_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -lsvld" >&5
+$as_echo_n "checking for dlopen in -lsvld... " >&6; }
+if test "${ac_cv_lib_svld_dlopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsvld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-# Global variables:
-ofile=libtool
-can_build_shared=yes
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_svld_dlopen=yes
+else
+  ac_cv_lib_svld_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_svld_dlopen" >&5
+$as_echo "$ac_cv_lib_svld_dlopen" >&6; }
+if test "x$ac_cv_lib_svld_dlopen" = x""yes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dld_link in -ldld" >&5
+$as_echo_n "checking for dld_link in -ldld... " >&6; }
+if test "${ac_cv_lib_dld_dld_link+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-# All known linkers require a `.a' archive for static linking (except MSVC,
-# which needs '.lib').
-libext=a
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dld_link ();
+int
+main ()
+{
+return dld_link ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dld_dld_link=yes
+else
+  ac_cv_lib_dld_dld_link=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_dld_link" >&5
+$as_echo "$ac_cv_lib_dld_dld_link" >&6; }
+if test "x$ac_cv_lib_dld_dld_link" = x""yes; then :
+  lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-dld"
+fi
 
-with_gnu_ld="$lt_cv_prog_gnu_ld"
 
-old_CC="$CC"
-old_CFLAGS="$CFLAGS"
+fi
 
-# Set sane defaults for various variables
-test -z "$CC" && CC=cc
-test -z "$LTCC" && LTCC=$CC
-test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
-test -z "$LD" && LD=ld
-test -z "$ac_objext" && ac_objext=o
 
-for cc_temp in $compiler""; do
-  case $cc_temp in
-    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
-    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
-    \-*) ;;
-    *) break;;
-  esac
-done
-cc_basename=`$ECHO "X$cc_temp" | $Xsed -e 's%.*/%%' -e "s%^$host_alias-%%"`
+fi
 
 
-# Only perform the check for file, if the check method requires it
-test -z "$MAGIC_CMD" && MAGIC_CMD=file
-case $deplibs_check_method in
-file_magic*)
-  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${ac_tool_prefix}file" >&5
-$as_echo_n "checking for ${ac_tool_prefix}file... " >&6; }
-if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $MAGIC_CMD in
-[\\/*] |  ?:[\\/]*)
-  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
-  ;;
-*)
-  lt_save_MAGIC_CMD="$MAGIC_CMD"
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
-  for ac_dir in $ac_dummy; do
-    IFS="$lt_save_ifs"
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/${ac_tool_prefix}file; then
-      lt_cv_path_MAGIC_CMD="$ac_dir/${ac_tool_prefix}file"
-      if test -n "$file_magic_test_file"; then
-	case $deplibs_check_method in
-	"file_magic "*)
-	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
-	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
-	    $EGREP "$file_magic_regex" > /dev/null; then
-	    :
-	  else
-	    cat <<_LT_EOF 1>&2
+fi
 
-*** Warning: the command libtool uses to detect shared libraries,
-*** $file_magic_cmd, produces output that libtool cannot recognize.
-*** The result is that libtool may fail to recognize shared libraries
-*** as such.  This will affect the creation of libtool libraries that
-*** depend on shared libraries, but programs linked with such libtool
-*** libraries will work regardless of this problem.  Nevertheless, you
-*** may want to report the problem to your system manager and/or to
-*** bug-libtool@gnu.org
 
-_LT_EOF
-	  fi ;;
-	esac
-      fi
-      break
-    fi
-  done
-  IFS="$lt_save_ifs"
-  MAGIC_CMD="$lt_save_MAGIC_CMD"
-  ;;
-esac
 fi
 
-MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-if test -n "$MAGIC_CMD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
-$as_echo "$MAGIC_CMD" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+
 fi
 
+    ;;
+  esac
 
+  if test "x$lt_cv_dlopen" != xno; then
+    enable_dlopen=yes
+  else
+    enable_dlopen=no
+  fi
 
+  case $lt_cv_dlopen in
+  dlopen)
+    save_CPPFLAGS="$CPPFLAGS"
+    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
 
+    save_LDFLAGS="$LDFLAGS"
+    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
 
-if test -z "$lt_cv_path_MAGIC_CMD"; then
-  if test -n "$ac_tool_prefix"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for file" >&5
-$as_echo_n "checking for file... " >&6; }
-if test "${lt_cv_path_MAGIC_CMD+set}" = set; then :
+    save_LIBS="$LIBS"
+    LIBS="$lt_cv_dlopen_libs $LIBS"
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program can dlopen itself" >&5
+$as_echo_n "checking whether a program can dlopen itself... " >&6; }
+if test "${lt_cv_dlopen_self+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  case $MAGIC_CMD in
-[\\/*] |  ?:[\\/]*)
-  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
-  ;;
-*)
-  lt_save_MAGIC_CMD="$MAGIC_CMD"
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
-  for ac_dir in $ac_dummy; do
-    IFS="$lt_save_ifs"
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/file; then
-      lt_cv_path_MAGIC_CMD="$ac_dir/file"
-      if test -n "$file_magic_test_file"; then
-	case $deplibs_check_method in
-	"file_magic "*)
-	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
-	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
-	    $EGREP "$file_magic_regex" > /dev/null; then
-	    :
-	  else
-	    cat <<_LT_EOF 1>&2
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self=cross
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<EOF
+#line 9521 "configure"
+#include "confdefs.h"
 
-*** Warning: the command libtool uses to detect shared libraries,
-*** $file_magic_cmd, produces output that libtool cannot recognize.
-*** The result is that libtool may fail to recognize shared libraries
-*** as such.  This will affect the creation of libtool libraries that
-*** depend on shared libraries, but programs linked with such libtool
-*** libraries will work regardless of this problem.  Nevertheless, you
-*** may want to report the problem to your system manager and/or to
-*** bug-libtool@gnu.org
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
 
-_LT_EOF
-	  fi ;;
-	esac
-      fi
-      break
-    fi
-  done
-  IFS="$lt_save_ifs"
-  MAGIC_CMD="$lt_save_MAGIC_CMD"
-  ;;
-esac
-fi
+#include <stdio.h>
 
-MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-if test -n "$MAGIC_CMD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
-$as_echo "$MAGIC_CMD" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
 
+#ifdef __cplusplus
+extern "C" void exit (int);
+#endif
+
+void fnord() { int i=42;}
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
 
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else if (dlsym( self,"_fnord")) status = $lt_dlneed_uscore;
+      /* dlclose (self); */
+    }
   else
-    MAGIC_CMD=:
-  fi
-fi
+    puts (dlerror ());
 
+    exit (status);
+}
+EOF
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&5 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_dlunknown|x*) lt_cv_dlopen_self=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self=no
   fi
-  ;;
-esac
+fi
+rm -fr conftest*
 
-# Use C for the default configuration in the libtool script
 
-lt_save_CC="$CC"
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self" >&5
+$as_echo "$lt_cv_dlopen_self" >&6; }
 
+    if test "x$lt_cv_dlopen_self" = xyes; then
+      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a statically linked program can dlopen itself" >&5
+$as_echo_n "checking whether a statically linked program can dlopen itself... " >&6; }
+if test "${lt_cv_dlopen_self_static+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self_static=cross
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<EOF
+#line 9621 "configure"
+#include "confdefs.h"
 
-# Source file extension for C test sources.
-ac_ext=c
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
 
-# Object file extension for compiled C test sources.
-objext=o
-objext=$objext
+#include <stdio.h>
 
-# Code to be used in simple compile tests
-lt_simple_compile_test_code="int some_variable = 0;"
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
 
-# Code to be used in simple link tests
-lt_simple_link_test_code='int main(){return(0);}'
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
 
+#ifdef __cplusplus
+extern "C" void exit (int);
+#endif
 
+void fnord() { int i=42;}
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
 
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else if (dlsym( self,"_fnord")) status = $lt_dlneed_uscore;
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
 
+    exit (status);
+}
+EOF
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&5 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_dlunknown|x*) lt_cv_dlopen_self_static=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self_static=no
+  fi
+fi
+rm -fr conftest*
 
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self_static" >&5
+$as_echo "$lt_cv_dlopen_self_static" >&6; }
+    fi
 
-# If no C compiler was specified, use CC.
-LTCC=${LTCC-"$CC"}
+    CPPFLAGS="$save_CPPFLAGS"
+    LDFLAGS="$save_LDFLAGS"
+    LIBS="$save_LIBS"
+    ;;
+  esac
 
-# If no C compiler flags were specified, use CFLAGS.
-LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
-
-# Allow CC to be a program name with arguments.
-compiler=$CC
+  case $lt_cv_dlopen_self in
+  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
+  *) enable_dlopen_self=unknown ;;
+  esac
 
-# Save the default compiler, since it gets overwritten when the other
-# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.
-compiler_DEFAULT=$CC
+  case $lt_cv_dlopen_self_static in
+  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
+  *) enable_dlopen_self_static=unknown ;;
+  esac
+fi
 
-# save warnings/boilerplate of simple test code
-ac_outfile=conftest.$ac_objext
-echo "$lt_simple_compile_test_code" >conftest.$ac_ext
-eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
-_lt_compiler_boilerplate=`cat conftest.err`
-$RM conftest*
 
-ac_outfile=conftest.$ac_objext
-echo "$lt_simple_link_test_code" >conftest.$ac_ext
-eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
-_lt_linker_boilerplate=`cat conftest.err`
-$RM -r conftest*
+# Report which library types will actually be built
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if libtool supports shared libraries" >&5
+$as_echo_n "checking if libtool supports shared libraries... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $can_build_shared" >&5
+$as_echo "$can_build_shared" >&6; }
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build shared libraries" >&5
+$as_echo_n "checking whether to build shared libraries... " >&6; }
+test "$can_build_shared" = "no" && enable_shared=no
 
-if test -n "$compiler"; then
+# On AIX, shared libraries and static libraries use the same namespace, and
+# are all built from PIC.
+case $host_os in
+aix3*)
+  test "$enable_shared" = yes && enable_static=no
+  if test -n "$RANLIB"; then
+    archive_cmds="$archive_cmds~\$RANLIB \$lib"
+    postinstall_cmds='$RANLIB $lib'
+  fi
+  ;;
 
-lt_prog_compiler_no_builtin_flag=
+aix4* | aix5*)
+  if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+    test "$enable_shared" = yes && enable_static=no
+  fi
+    ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_shared" >&5
+$as_echo "$enable_shared" >&6; }
 
-if test "$GCC" = yes; then
-  lt_prog_compiler_no_builtin_flag=' -fno-builtin'
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build static libraries" >&5
+$as_echo_n "checking whether to build static libraries... " >&6; }
+# Make sure either enable_shared or enable_static is yes.
+test "$enable_shared" = yes || enable_static=yes
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_static" >&5
+$as_echo "$enable_static" >&6; }
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
-$as_echo_n "checking if $compiler supports -fno-rtti -fno-exceptions... " >&6; }
-if test "${lt_cv_prog_compiler_rtti_exceptions+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_rtti_exceptions=no
-   ac_outfile=conftest.$ac_objext
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-   lt_compiler_flag="-fno-rtti -fno-exceptions"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   # The option is referenced via a variable to avoid confusing sed.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8518: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>conftest.err)
-   ac_status=$?
-   cat conftest.err >&5
-   echo "$as_me:8522: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s "$ac_outfile"; then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings other than the usual output.
-     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
-     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_rtti_exceptions=yes
-     fi
-   fi
-   $RM conftest*
+# The else clause should only fire when bootstrapping the
+# libtool distribution, otherwise you forgot to ship ltmain.sh
+# with your package, and you will get complaints that there are
+# no rules to generate ltmain.sh.
+if test -f "$ltmain"; then
+  # See if we are running on zsh, and set the options which allow our commands through
+  # without removal of \ escapes.
+  if test -n "${ZSH_VERSION+set}" ; then
+    setopt NO_GLOB_SUBST
+  fi
+  # Now quote all the things that may contain metacharacters while being
+  # careful not to overquote the AC_SUBSTed values.  We take copies of the
+  # variables and quote the copies for generation of the libtool script.
+  for var in echo old_CC old_CFLAGS AR AR_FLAGS EGREP RANLIB LN_S LTCC LTCFLAGS NM \
+    SED SHELL STRIP \
+    libname_spec library_names_spec soname_spec extract_expsyms_cmds \
+    old_striplib striplib file_magic_cmd finish_cmds finish_eval \
+    deplibs_check_method reload_flag reload_cmds need_locks \
+    lt_cv_sys_global_symbol_pipe lt_cv_sys_global_symbol_to_cdecl \
+    lt_cv_sys_global_symbol_to_c_name_address \
+    sys_lib_search_path_spec sys_lib_dlsearch_path_spec \
+    old_postinstall_cmds old_postuninstall_cmds \
+    compiler \
+    CC \
+    LD \
+    lt_prog_compiler_wl \
+    lt_prog_compiler_pic \
+    lt_prog_compiler_static \
+    lt_prog_compiler_no_builtin_flag \
+    export_dynamic_flag_spec \
+    thread_safe_flag_spec \
+    whole_archive_flag_spec \
+    enable_shared_with_static_runtimes \
+    old_archive_cmds \
+    old_archive_from_new_cmds \
+    predep_objects \
+    postdep_objects \
+    predeps \
+    postdeps \
+    compiler_lib_search_path \
+    archive_cmds \
+    archive_expsym_cmds \
+    postinstall_cmds \
+    postuninstall_cmds \
+    old_archive_from_expsyms_cmds \
+    allow_undefined_flag \
+    no_undefined_flag \
+    export_symbols_cmds \
+    hardcode_libdir_flag_spec \
+    hardcode_libdir_flag_spec_ld \
+    hardcode_libdir_separator \
+    hardcode_automatic \
+    module_cmds \
+    module_expsym_cmds \
+    lt_cv_prog_compiler_c_o \
+    exclude_expsyms \
+    include_expsyms; do
+
+    case $var in
+    old_archive_cmds | \
+    old_archive_from_new_cmds | \
+    archive_cmds | \
+    archive_expsym_cmds | \
+    module_cmds | \
+    module_expsym_cmds | \
+    old_archive_from_expsyms_cmds | \
+    export_symbols_cmds | \
+    extract_expsyms_cmds | reload_cmds | finish_cmds | \
+    postinstall_cmds | postuninstall_cmds | \
+    old_postinstall_cmds | old_postuninstall_cmds | \
+    sys_lib_search_path_spec | sys_lib_dlsearch_path_spec)
+      # Double-quote double-evaled strings.
+      eval "lt_$var=\\\"\`\$echo \"X\$$var\" | \$Xsed -e \"\$double_quote_subst\" -e \"\$sed_quote_subst\" -e \"\$delay_variable_subst\"\`\\\""
+      ;;
+    *)
+      eval "lt_$var=\\\"\`\$echo \"X\$$var\" | \$Xsed -e \"\$sed_quote_subst\"\`\\\""
+      ;;
+    esac
+  done
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
-$as_echo "$lt_cv_prog_compiler_rtti_exceptions" >&6; }
+  case $lt_echo in
+  *'\$0 --fallback-echo"')
+    lt_echo=`$echo "X$lt_echo" | $Xsed -e 's/\\\\\\\$0 --fallback-echo"$/$0 --fallback-echo"/'`
+    ;;
+  esac
 
-if test x"$lt_cv_prog_compiler_rtti_exceptions" = xyes; then
-    lt_prog_compiler_no_builtin_flag="$lt_prog_compiler_no_builtin_flag -fno-rtti -fno-exceptions"
-else
-    :
-fi
+cfgfile="${ofile}T"
+  trap "$rm \"$cfgfile\"; exit 1" 1 2 15
+  $rm -f "$cfgfile"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ofile" >&5
+$as_echo "$as_me: creating $ofile" >&6;}
 
-fi
+  cat <<__EOF__ >> "$cfgfile"
+#! $SHELL
 
+# `$echo "$cfgfile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
+# Generated automatically by $PROGRAM (GNU $PACKAGE $VERSION$TIMESTAMP)
+# NOTE: Changes made to this file will be lost: look at ltmain.sh.
+#
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001
+# Free Software Foundation, Inc.
+#
+# This file is part of GNU Libtool:
+# Originally by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
 
+# A sed program that does not truncate output.
+SED=$lt_SED
 
+# Sed that helps us avoid accidentally triggering echo(1) options like -n.
+Xsed="$SED -e 1s/^X//"
 
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
+# The names of the tagged configurations supported by this script.
+available_tags=
 
-  lt_prog_compiler_wl=
-lt_prog_compiler_pic=
-lt_prog_compiler_static=
+# ### BEGIN LIBTOOL CONFIG
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
-$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
 
-  if test "$GCC" = yes; then
-    lt_prog_compiler_wl='-Wl,'
-    lt_prog_compiler_static='-static'
+# Shell to use when invoking shell scripts.
+SHELL=$lt_SHELL
 
-    case $host_os in
-      aix*)
-      # All AIX code is PIC.
-      if test "$host_cpu" = ia64; then
-	# AIX 5 now supports IA64 processor
-	lt_prog_compiler_static='-Bstatic'
-      fi
-      ;;
+# Whether or not to build shared libraries.
+build_libtool_libs=$enable_shared
 
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            lt_prog_compiler_pic='-fPIC'
-        ;;
-      m68k)
-            # FIXME: we need at least 68020 code to build shared libraries, but
-            # adding the `-m68020' flag to GCC prevents building anything better,
-            # like `-m68040'.
-            lt_prog_compiler_pic='-m68020 -resident32 -malways-restore-a4'
-        ;;
-      esac
-      ;;
+# Whether or not to build static libraries.
+build_old_libs=$enable_static
 
-    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
-      # PIC is the default for these OSes.
-      ;;
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=$archive_cmds_need_lc
 
-    mingw* | cygwin* | pw32* | os2* | cegcc*)
-      # This hack is so that the source file can tell whether it is being
-      # built for inclusion in a dll (and should export symbols for example).
-      # Although the cygwin gcc ignores -fPIC, still need this for old-style
-      # (--disable-auto-import) libraries
-      lt_prog_compiler_pic='-DDLL_EXPORT'
-      ;;
+# Whether or not to disallow shared libs when runtime libs are static
+allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes
 
-    darwin* | rhapsody*)
-      # PIC is the default on this platform
-      # Common symbols not allowed in MH_DYLIB files
-      lt_prog_compiler_pic='-fno-common'
-      ;;
+# Whether or not to optimize for fast installation.
+fast_install=$enable_fast_install
 
-    hpux*)
-      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
-      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
-      # sets the default TLS model and affects inlining.
-      case $host_cpu in
-      hppa*64*)
-	# +Z the default
-	;;
-      *)
-	lt_prog_compiler_pic='-fPIC'
-	;;
-      esac
-      ;;
+# The host system.
+host_alias=$host_alias
+host=$host
+host_os=$host_os
 
-    interix[3-9]*)
-      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
-      # Instead, we relocate shared libraries at runtime.
-      ;;
+# The build system.
+build_alias=$build_alias
+build=$build
+build_os=$build_os
 
-    msdosdjgpp*)
-      # Just because we use GCC doesn't mean we suddenly get shared libraries
-      # on systems that don't support them.
-      lt_prog_compiler_can_build_shared=no
-      enable_shared=no
-      ;;
+# An echo program that does not interpret backslashes.
+echo=$lt_echo
 
-    *nto* | *qnx*)
-      # QNX uses GNU C++, but need to define -shared option too, otherwise
-      # it will coredump.
-      lt_prog_compiler_pic='-fPIC -shared'
-      ;;
+# The archiver.
+AR=$lt_AR
+AR_FLAGS=$lt_AR_FLAGS
 
-    sysv4*MP*)
-      if test -d /usr/nec; then
-	lt_prog_compiler_pic=-Kconform_pic
-      fi
-      ;;
+# A C compiler.
+LTCC=$lt_LTCC
 
-    *)
-      lt_prog_compiler_pic='-fPIC'
-      ;;
-    esac
-  else
-    # PORTME Check for flag to pass linker flags through the system compiler.
-    case $host_os in
-    aix*)
-      lt_prog_compiler_wl='-Wl,'
-      if test "$host_cpu" = ia64; then
-	# AIX 5 now supports IA64 processor
-	lt_prog_compiler_static='-Bstatic'
-      else
-	lt_prog_compiler_static='-bnso -bI:/lib/syscalls.exp'
-      fi
-      ;;
+# LTCC compiler flags.
+LTCFLAGS=$lt_LTCFLAGS
 
-    mingw* | cygwin* | pw32* | os2* | cegcc*)
-      # This hack is so that the source file can tell whether it is being
-      # built for inclusion in a dll (and should export symbols for example).
-      lt_prog_compiler_pic='-DDLL_EXPORT'
-      ;;
+# A language-specific compiler.
+CC=$lt_compiler
 
-    hpux9* | hpux10* | hpux11*)
-      lt_prog_compiler_wl='-Wl,'
-      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
-      # not for PA HP-UX.
-      case $host_cpu in
-      hppa*64*|ia64*)
-	# +Z the default
-	;;
-      *)
-	lt_prog_compiler_pic='+Z'
-	;;
-      esac
-      # Is there a better lt_prog_compiler_static that works with the bundled CC?
-      lt_prog_compiler_static='${wl}-a ${wl}archive'
-      ;;
+# Is the compiler the GNU C compiler?
+with_gcc=$GCC
 
-    irix5* | irix6* | nonstopux*)
-      lt_prog_compiler_wl='-Wl,'
-      # PIC (with -KPIC) is the default.
-      lt_prog_compiler_static='-non_shared'
-      ;;
+gcc_dir=\`gcc -print-file-name=. | $SED 's,/\.$,,'\`
+gcc_ver=\`gcc -dumpversion\`
 
-    linux* | k*bsd*-gnu)
-      case $cc_basename in
-      # old Intel for x86_64 which still supported -KPIC.
-      ecc*)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-KPIC'
-	lt_prog_compiler_static='-static'
-        ;;
-      # icc used to be incompatible with GCC.
-      # ICC 10 doesn't accept -KPIC any more.
-      icc* | ifort*)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-fPIC'
-	lt_prog_compiler_static='-static'
-        ;;
-      # Lahey Fortran 8.1.
-      lf95*)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='--shared'
-	lt_prog_compiler_static='--static'
-	;;
-      pgcc* | pgf77* | pgf90* | pgf95*)
-        # Portland Group compilers (*not* the Pentium gcc compiler,
-	# which looks to be a dead project)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-fpic'
-	lt_prog_compiler_static='-Bstatic'
-        ;;
-      ccc*)
-        lt_prog_compiler_wl='-Wl,'
-        # All Alpha code is PIC.
-        lt_prog_compiler_static='-non_shared'
-        ;;
-      xl*)
-	# IBM XL C 8.0/Fortran 10.1 on PPC
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-qpic'
-	lt_prog_compiler_static='-qstaticlink'
-	;;
-      *)
-	case `$CC -V 2>&1 | sed 5q` in
-	*Sun\ C*)
-	  # Sun C 5.9
-	  lt_prog_compiler_pic='-KPIC'
-	  lt_prog_compiler_static='-Bstatic'
-	  lt_prog_compiler_wl='-Wl,'
-	  ;;
-	*Sun\ F*)
-	  # Sun Fortran 8.3 passes all unrecognized flags to the linker
-	  lt_prog_compiler_pic='-KPIC'
-	  lt_prog_compiler_static='-Bstatic'
-	  lt_prog_compiler_wl=''
-	  ;;
-	esac
-	;;
-      esac
-      ;;
+# An ERE matcher.
+EGREP=$lt_EGREP
 
-    newsos6)
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
+# The linker used to build libraries.
+LD=$lt_LD
 
-    *nto* | *qnx*)
-      # QNX uses GNU C++, but need to define -shared option too, otherwise
-      # it will coredump.
-      lt_prog_compiler_pic='-fPIC -shared'
-      ;;
+# Whether we need hard or soft links.
+LN_S=$lt_LN_S
 
-    osf3* | osf4* | osf5*)
-      lt_prog_compiler_wl='-Wl,'
-      # All OSF/1 code is PIC.
-      lt_prog_compiler_static='-non_shared'
-      ;;
+# A BSD-compatible nm program.
+NM=$lt_NM
 
-    rdos*)
-      lt_prog_compiler_static='-non_shared'
-      ;;
+# A symbol stripping program
+STRIP=$lt_STRIP
 
-    solaris*)
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      case $cc_basename in
-      f77* | f90* | f95*)
-	lt_prog_compiler_wl='-Qoption ld ';;
-      *)
-	lt_prog_compiler_wl='-Wl,';;
-      esac
-      ;;
+# Used to examine libraries when file_magic_cmd begins "file"
+MAGIC_CMD=$MAGIC_CMD
 
-    sunos4*)
-      lt_prog_compiler_wl='-Qoption ld '
-      lt_prog_compiler_pic='-PIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
+# Used on cygwin: DLL creation program.
+DLLTOOL="$DLLTOOL"
 
-    sysv4 | sysv4.2uw2* | sysv4.3*)
-      lt_prog_compiler_wl='-Wl,'
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
+# Used on cygwin: object dumper.
+OBJDUMP="$OBJDUMP"
 
-    sysv4*MP*)
-      if test -d /usr/nec ;then
-	lt_prog_compiler_pic='-Kconform_pic'
-	lt_prog_compiler_static='-Bstatic'
-      fi
-      ;;
+# Used on cygwin: assembler.
+AS="$AS"
 
-    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
-      lt_prog_compiler_wl='-Wl,'
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
+# The name of the directory that contains temporary libtool files.
+objdir=$objdir
 
-    unicos*)
-      lt_prog_compiler_wl='-Wl,'
-      lt_prog_compiler_can_build_shared=no
-      ;;
+# How to create reloadable object files.
+reload_flag=$lt_reload_flag
+reload_cmds=$lt_reload_cmds
 
-    uts4*)
-      lt_prog_compiler_pic='-pic'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
+# How to pass a linker flag through the compiler.
+wl=$lt_lt_prog_compiler_wl
 
-    *)
-      lt_prog_compiler_can_build_shared=no
-      ;;
-    esac
-  fi
+# Object file suffix (normally "o").
+objext="$ac_objext"
 
-case $host_os in
-  # For platforms which do not support PIC, -DPIC is meaningless:
-  *djgpp*)
-    lt_prog_compiler_pic=
-    ;;
-  *)
-    lt_prog_compiler_pic="$lt_prog_compiler_pic -DPIC"
-    ;;
-esac
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic" >&5
-$as_echo "$lt_prog_compiler_pic" >&6; }
+# Old archive suffix (normally "a").
+libext="$libext"
 
+# Shared library suffix (normally ".so").
+shrext_cmds='$shrext_cmds'
 
+# Executable file suffix (normally "").
+exeext="$exeext"
 
+# Additional compiler flags for building library objects.
+pic_flag=$lt_lt_prog_compiler_pic
+pic_mode=$pic_mode
 
+# What is the maximum length of a command?
+max_cmd_len=$lt_cv_sys_max_cmd_len
 
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o=$lt_lt_cv_prog_compiler_c_o
 
-#
-# Check to make sure the PIC flag actually works.
-#
-if test -n "$lt_prog_compiler_pic"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic works" >&5
-$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic works... " >&6; }
-if test "${lt_cv_prog_compiler_pic_works+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_pic_works=no
-   ac_outfile=conftest.$ac_objext
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-   lt_compiler_flag="$lt_prog_compiler_pic -DPIC"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   # The option is referenced via a variable to avoid confusing sed.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8857: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>conftest.err)
-   ac_status=$?
-   cat conftest.err >&5
-   echo "$as_me:8861: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s "$ac_outfile"; then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings other than the usual output.
-     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
-     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_pic_works=yes
-     fi
-   fi
-   $RM conftest*
+# Must we lock files when doing compilation?
+need_locks=$lt_need_locks
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_works" >&5
-$as_echo "$lt_cv_prog_compiler_pic_works" >&6; }
+# Do we need the lib prefix for modules?
+need_lib_prefix=$need_lib_prefix
 
-if test x"$lt_cv_prog_compiler_pic_works" = xyes; then
-    case $lt_prog_compiler_pic in
-     "" | " "*) ;;
-     *) lt_prog_compiler_pic=" $lt_prog_compiler_pic" ;;
-     esac
-else
-    lt_prog_compiler_pic=
-     lt_prog_compiler_can_build_shared=no
-fi
+# Do we need a version for libraries?
+need_version=$need_version
 
-fi
+# Whether dlopen is supported.
+dlopen_support=$enable_dlopen
 
+# Whether dlopen of programs is supported.
+dlopen_self=$enable_dlopen_self
 
+# Whether dlopen of statically linked programs is supported.
+dlopen_self_static=$enable_dlopen_self_static
 
+# Compiler flag to prevent dynamic linking.
+link_static_flag=$lt_lt_prog_compiler_static
 
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag
 
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec=$lt_export_dynamic_flag_spec
 
-#
-# Check to make sure the static flag actually works.
-#
-wl=$lt_prog_compiler_wl eval lt_tmp_static_flag=\"$lt_prog_compiler_static\"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
-$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
-if test "${lt_cv_prog_compiler_static_works+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_static_works=no
-   save_LDFLAGS="$LDFLAGS"
-   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
-   echo "$lt_simple_link_test_code" > conftest.$ac_ext
-   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
-     # The linker can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     if test -s conftest.err; then
-       # Append any errors to the config.log.
-       cat conftest.err 1>&5
-       $ECHO "X$_lt_linker_boilerplate" | $Xsed -e '/^$/d' > conftest.exp
-       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-       if diff conftest.exp conftest.er2 >/dev/null; then
-         lt_cv_prog_compiler_static_works=yes
-       fi
-     else
-       lt_cv_prog_compiler_static_works=yes
-     fi
-   fi
-   $RM -r conftest*
-   LDFLAGS="$save_LDFLAGS"
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec=$lt_whole_archive_flag_spec
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_static_works" >&5
-$as_echo "$lt_cv_prog_compiler_static_works" >&6; }
+# Compiler flag to generate thread-safe objects.
+thread_safe_flag_spec=$lt_thread_safe_flag_spec
 
-if test x"$lt_cv_prog_compiler_static_works" = xyes; then
-    :
-else
-    lt_prog_compiler_static=
-fi
+# Library versioning type.
+version_type=$version_type
 
+# Format of library name prefix.
+libname_spec=$lt_libname_spec
 
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME.
+library_names_spec=$lt_library_names_spec
 
+# The coded name of the library, if different from the real name.
+soname_spec=$lt_soname_spec
 
+# Commands used to build and install an old-style archive.
+RANLIB=$lt_RANLIB
+old_archive_cmds=$lt_old_archive_cmds
+old_postinstall_cmds=$lt_old_postinstall_cmds
+old_postuninstall_cmds=$lt_old_postuninstall_cmds
 
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=$lt_old_archive_from_new_cmds
 
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
-$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
-if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_c_o=no
-   $RM -r conftest 2>/dev/null
-   mkdir conftest
-   cd conftest
-   mkdir out
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+# Commands used to build and install a shared archive.
+archive_cmds=$lt_archive_cmds
+archive_expsym_cmds=$lt_archive_expsym_cmds
+postinstall_cmds=$lt_postinstall_cmds
+postuninstall_cmds=$lt_postuninstall_cmds
 
-   lt_compiler_flag="-o out/conftest2.$ac_objext"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8962: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>out/conftest.err)
-   ac_status=$?
-   cat out/conftest.err >&5
-   echo "$as_me:8966: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s out/conftest2.$ac_objext
-   then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
-     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
-     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_c_o=yes
-     fi
-   fi
-   chmod u+w . 2>&5
-   $RM conftest*
-   # SGI C++ compiler will create directory out/ii_files/ for
-   # template instantiation
-   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
-   $RM out/* && rmdir out
-   cd ..
-   $RM -r conftest
-   $RM conftest*
+# Commands used to build a loadable module (assumed same as above if empty)
+module_cmds=$lt_module_cmds
+module_expsym_cmds=$lt_module_expsym_cmds
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
-$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
+# Commands to strip libraries.
+old_striplib=$lt_old_striplib
+striplib=$lt_striplib
 
+# Dependencies to place before the objects being linked to create a
+# shared library.
+predep_objects=\`echo $lt_predep_objects | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
+
+# Dependencies to place after the objects being linked to create a
+# shared library.
+postdep_objects=\`echo $lt_postdep_objects | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
 
+# Dependencies to place before the objects being linked to create a
+# shared library.
+predeps=$lt_predeps
 
+# Dependencies to place after the objects being linked to create a
+# shared library.
+postdeps=$lt_postdeps
 
+# The library search path used internally by the compiler when linking
+# a shared library.
+compiler_lib_search_path=\`echo $lt_compiler_lib_search_path | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
 
+# Method to check whether dependent libraries are shared objects.
+deplibs_check_method=$lt_deplibs_check_method
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
-$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
-if test "${lt_cv_prog_compiler_c_o+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_c_o=no
-   $RM -r conftest 2>/dev/null
-   mkdir conftest
-   cd conftest
-   mkdir out
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+# Command to use when deplibs_check_method == file_magic.
+file_magic_cmd=$lt_file_magic_cmd
 
-   lt_compiler_flag="-o out/conftest2.$ac_objext"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:9017: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>out/conftest.err)
-   ac_status=$?
-   cat out/conftest.err >&5
-   echo "$as_me:9021: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s out/conftest2.$ac_objext
-   then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
-     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
-     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_c_o=yes
-     fi
-   fi
-   chmod u+w . 2>&5
-   $RM conftest*
-   # SGI C++ compiler will create directory out/ii_files/ for
-   # template instantiation
-   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
-   $RM out/* && rmdir out
-   cd ..
-   $RM -r conftest
-   $RM conftest*
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=$lt_allow_undefined_flag
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
-$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
+# Flag that forces no undefined symbols.
+no_undefined_flag=$lt_no_undefined_flag
 
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds=$lt_finish_cmds
 
+# Same as above, but a single script fragment to be evaled but not shown.
+finish_eval=$lt_finish_eval
 
+# Take the output of nm and produce a listing of raw symbols and C names.
+global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe
 
-hard_links="nottested"
-if test "$lt_cv_prog_compiler_c_o" = no && test "$need_locks" != no; then
-  # do not overwrite the value of need_locks provided by the user
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
-$as_echo_n "checking if we can lock with hard links... " >&6; }
-  hard_links=yes
-  $RM conftest*
-  ln conftest.a conftest.b 2>/dev/null && hard_links=no
-  touch conftest.a
-  ln conftest.a conftest.b 2>&5 || hard_links=no
-  ln conftest.a conftest.b 2>/dev/null && hard_links=no
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
-$as_echo "$hard_links" >&6; }
-  if test "$hard_links" = no; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
-$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
-    need_locks=warn
-  fi
-else
-  need_locks=no
-fi
+# Transform the output of nm in a proper C declaration
+global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl
 
+# Transform the output of nm in a C name address pair
+global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address
 
+# This is the shared library runtime path variable.
+runpath_var=$runpath_var
 
+# This is the shared library path variable.
+shlibpath_var=$shlibpath_var
 
+# Is shlibpath searched before the hard-coded library search path?
+shlibpath_overrides_runpath=$shlibpath_overrides_runpath
 
+# How to hardcode a shared library path into an executable.
+hardcode_action=$hardcode_action
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
-$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
+# Whether we should hardcode library paths into libraries.
+hardcode_into_libs=$hardcode_into_libs
 
-  runpath_var=
-  allow_undefined_flag=
-  always_export_symbols=no
-  archive_cmds=
-  archive_expsym_cmds=
-  compiler_needs_object=no
-  enable_shared_with_static_runtimes=no
-  export_dynamic_flag_spec=
-  export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
-  hardcode_automatic=no
-  hardcode_direct=no
-  hardcode_direct_absolute=no
-  hardcode_libdir_flag_spec=
-  hardcode_libdir_flag_spec_ld=
-  hardcode_libdir_separator=
-  hardcode_minus_L=no
-  hardcode_shlibpath_var=unsupported
-  inherit_rpath=no
-  link_all_deplibs=unknown
-  module_cmds=
-  module_expsym_cmds=
-  old_archive_from_new_cmds=
-  old_archive_from_expsyms_cmds=
-  thread_safe_flag_spec=
-  whole_archive_flag_spec=
-  # include_expsyms should be a list of space-separated symbols to be *always*
-  # included in the symbol list
-  include_expsyms=
-  # exclude_expsyms can be an extended regexp of symbols to exclude
-  # it will be wrapped by ` (' and `)$', so one must not match beginning or
-  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
-  # as well as any symbol that contains `d'.
-  exclude_expsyms='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
-  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
-  # platforms (ab)use it in PIC code, but their linkers get confused if
-  # the symbol is explicitly referenced.  Since portable code cannot
-  # rely on this symbol name, it's probably fine to never include it in
-  # preloaded symbol tables.
-  # Exclude shared library initialization/finalization symbols.
-  extract_expsyms_cmds=
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec
 
-  case $host_os in
-  cygwin* | mingw* | pw32* | cegcc*)
-    # FIXME: the MSVC++ port hasn't been tested in a loooong time
-    # When not using gcc, we currently assume that we are using
-    # Microsoft Visual C++.
-    if test "$GCC" != yes; then
-      with_gnu_ld=no
-    fi
-    ;;
-  interix*)
-    # we just hope/assume this is gcc and not c89 (= MSVC++)
-    with_gnu_ld=yes
-    ;;
-  openbsd*)
-    with_gnu_ld=no
-    ;;
-  esac
+# If ld is used when linking, flag to hardcode \$libdir into
+# a binary during linking. This must work even if \$libdir does
+# not exist.
+hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld
 
-  ld_shlibs=yes
-  if test "$with_gnu_ld" = yes; then
-    # If archive_cmds runs LD, not CC, wlarc should be empty
-    wlarc='${wl}'
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator=$lt_hardcode_libdir_separator
 
-    # Set some defaults for GNU ld with shared library support. These
-    # are reset later if shared libraries are not supported. Putting them
-    # here allows them to be overridden if necessary.
-    runpath_var=LD_RUN_PATH
-    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-    export_dynamic_flag_spec='${wl}--export-dynamic'
-    # ancient GNU ld didn't support --whole-archive et. al.
-    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
-      whole_archive_flag_spec="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
-    else
-      whole_archive_flag_spec=
-    fi
-    supports_anon_versioning=no
-    case `$LD -v 2>&1` in
-      *\ [01].* | *\ 2.[0-9].* | *\ 2.10.*) ;; # catch versions < 2.11
-      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
-      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
-      *\ 2.11.*) ;; # other 2.11 versions
-      *) supports_anon_versioning=yes ;;
-    esac
+# Set to yes if using DIR/libNAME${shared_ext} during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct=$hardcode_direct
 
-    # See if GNU ld supports shared libraries.
-    case $host_os in
-    aix[3-9]*)
-      # On AIX/PPC, the GNU linker is very broken
-      if test "$host_cpu" != ia64; then
-	ld_shlibs=no
-	cat <<_LT_EOF 1>&2
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L=$hardcode_minus_L
 
-*** Warning: the GNU linker, at least up to release 2.9.1, is reported
-*** to be unable to reliably create shared libraries on AIX.
-*** Therefore, libtool is disabling shared libraries support.  If you
-*** really care for shared libraries, you may want to modify your PATH
-*** so that a non-GNU linker is found, and then restart.
+# Set to yes if using SHLIBPATH_VAR=DIR during linking hardcodes DIR into
+# the resulting binary.
+hardcode_shlibpath_var=$hardcode_shlibpath_var
 
-_LT_EOF
-      fi
-      ;;
+# Set to yes if building a shared library automatically hardcodes DIR into the library
+# and all subsequent libraries and executables linked against it.
+hardcode_automatic=$hardcode_automatic
 
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-            archive_expsym_cmds=''
-        ;;
-      m68k)
-            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
-            hardcode_libdir_flag_spec='-L$libdir'
-            hardcode_minus_L=yes
-        ;;
-      esac
-      ;;
+# Variables whose values should be saved in libtool wrapper scripts and
+# restored at relink time.
+variables_saved_for_relink="$variables_saved_for_relink"
 
-    beos*)
-      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	allow_undefined_flag=unsupported
-	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
-	# support --undefined.  This deserves some investigation.  FIXME
-	archive_cmds='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=$link_all_deplibs
 
-    cygwin* | mingw* | pw32* | cegcc*)
-      # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
-      # as there is no search path for DLLs.
-      hardcode_libdir_flag_spec='-L$libdir'
-      allow_undefined_flag=unsupported
-      always_export_symbols=no
-      enable_shared_with_static_runtimes=yes
-      export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1 DATA/'\'' | $SED -e '\''/^[AITW][ ]/s/.*[ ]//'\'' | sort | uniq > $export_symbols'
+# Compile-time system search path for libraries
+sys_lib_search_path_spec=\`echo $lt_sys_lib_search_path_spec | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
 
-      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
-        archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-	# If the export-symbols file already is a .def file (1st line
-	# is EXPORTS), use it as is; otherwise, prepend...
-	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	  cp $export_symbols $output_objdir/$soname.def;
-	else
-	  echo EXPORTS > $output_objdir/$soname.def;
-	  cat $export_symbols >> $output_objdir/$soname.def;
-	fi~
-	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
+# Run-time system search path for libraries
+sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
 
-    interix[3-9]*)
-      hardcode_direct=no
-      hardcode_shlibpath_var=no
-      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-      export_dynamic_flag_spec='${wl}-E'
-      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
-      # Instead, shared libraries are loaded at an image base (0x10000000 by
-      # default) and relocated if they conflict, which is a slow very memory
-      # consuming and fragmenting process.  To avoid this, we pick a random,
-      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
-      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
-      archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-      archive_expsym_cmds='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-      ;;
+# Fix the shell variable \$srcfile for the compiler.
+fix_srcfile_path="$fix_srcfile_path"
 
-    gnu* | linux* | tpf* | k*bsd*-gnu)
-      tmp_diet=no
-      if test "$host_os" = linux-dietlibc; then
-	case $cc_basename in
-	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
-	esac
-      fi
-      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
-	 && test "$tmp_diet" = no
-      then
-	tmp_addflag=
-	tmp_sharedflag='-shared'
-	case $cc_basename,$host_cpu in
-        pgcc*)				# Portland Group C compiler
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
-	  tmp_addflag=' $pic_flag'
-	  ;;
-	pgf77* | pgf90* | pgf95*)	# Portland Group f77 and f90 compilers
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
-	  tmp_addflag=' $pic_flag -Mnomain' ;;
-	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
-	  tmp_addflag=' -i_dynamic' ;;
-	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
-	  tmp_addflag=' -i_dynamic -nofor_main' ;;
-	ifc* | ifort*)			# Intel Fortran compiler
-	  tmp_addflag=' -nofor_main' ;;
-	lf95*)				# Lahey Fortran 8.1
-	  whole_archive_flag_spec=
-	  tmp_sharedflag='--shared' ;;
-	xl[cC]*)			# IBM XL C 8.0 on PPC (deal with xlf below)
-	  tmp_sharedflag='-qmkshrobj'
-	  tmp_addflag= ;;
-	esac
-	case `$CC -V 2>&1 | sed 5q` in
-	*Sun\ C*)			# Sun C 5.9
-	  whole_archive_flag_spec='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
-	  compiler_needs_object=yes
-	  tmp_sharedflag='-G' ;;
-	*Sun\ F*)			# Sun Fortran 8.3
-	  tmp_sharedflag='-G' ;;
-	esac
-	archive_cmds='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+# Set to yes if exported symbols are required.
+always_export_symbols=$always_export_symbols
 
-        if test "x$supports_anon_versioning" = xyes; then
-          archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
-	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-	    echo "local: *; };" >> $output_objdir/$libname.ver~
-	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
-        fi
+# The commands to list exported symbols.
+export_symbols_cmds=$lt_export_symbols_cmds
 
-	case $cc_basename in
-	xlf*)
-	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
-	  whole_archive_flag_spec='--whole-archive$convenience --no-whole-archive'
-	  hardcode_libdir_flag_spec=
-	  hardcode_libdir_flag_spec_ld='-rpath $libdir'
-	  archive_cmds='$LD -shared $libobjs $deplibs $compiler_flags -soname $soname -o $lib'
-	  if test "x$supports_anon_versioning" = xyes; then
-	    archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
-	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-	      echo "local: *; };" >> $output_objdir/$libname.ver~
-	      $LD -shared $libobjs $deplibs $compiler_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
-	  fi
-	  ;;
-	esac
-      else
-        ld_shlibs=no
-      fi
-      ;;
+# The commands to extract the exported symbol list from a shared archive.
+extract_expsyms_cmds=$lt_extract_expsyms_cmds
 
-    netbsd*)
-      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-	archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
-	wlarc=
-      else
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-      fi
-      ;;
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms=$lt_exclude_expsyms
 
-    solaris*)
-      if $LD -v 2>&1 | $GREP 'BFD 2\.8' > /dev/null; then
-	ld_shlibs=no
-	cat <<_LT_EOF 1>&2
+# Symbols that must always be exported.
+include_expsyms=$lt_include_expsyms
 
-*** Warning: The releases 2.8.* of the GNU linker cannot reliably
-*** create shared libraries on Solaris systems.  Therefore, libtool
-*** is disabling shared libraries support.  We urge you to upgrade GNU
-*** binutils to release 2.9.1 or newer.  Another option is to modify
-*** your PATH or compiler configuration so that the native linker is
-*** used, and then restart.
+# ### END LIBTOOL CONFIG
 
-_LT_EOF
-      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
+__EOF__
 
-    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
-      case `$LD -v 2>&1` in
-        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
-	ld_shlibs=no
-	cat <<_LT_EOF 1>&2
 
-*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
-*** reliably create shared libraries on SCO systems.  Therefore, libtool
-*** is disabling shared libraries support.  We urge you to upgrade GNU
-*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
-*** your PATH or compiler configuration so that the native linker is
-*** used, and then restart.
+  case $host_os in
+  aix3*)
+    cat <<\EOF >> "$cfgfile"
 
-_LT_EOF
-	;;
-	*)
-	  # For security reasons, it is highly recommended that you always
-	  # use absolute paths for naming shared libraries, and exclude the
-	  # DT_RUNPATH tag from executables and libraries.  But doing so
-	  # requires that you compile everything twice, which is a pain.
-	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-	    archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	    archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-	  else
-	    ld_shlibs=no
-	  fi
-	;;
-      esac
-      ;;
+# AIX sometimes has problems with the GCC collect2 program.  For some
+# reason, if we set the COLLECT_NAMES environment variable, the problems
+# vanish in a puff of smoke.
+if test "X${COLLECT_NAMES+set}" != Xset; then
+  COLLECT_NAMES=
+  export COLLECT_NAMES
+fi
+EOF
+    ;;
+  esac
 
-    sunos4*)
-      archive_cmds='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-      wlarc=
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
+  # We use sed instead of cat because bash on DJGPP gets confused if
+  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
+  # text mode, it properly converts lines to CR/LF.  This bash problem
+  # is reportedly fixed, but why not run on old versions too?
+  sed '$q' "$ltmain" >> "$cfgfile" || (rm -f "$cfgfile"; exit 1)
 
-    *)
-      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
-    esac
+  mv -f "$cfgfile" "$ofile" || \
+    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
+  chmod +x "$ofile"
 
-    if test "$ld_shlibs" = no; then
-      runpath_var=
-      hardcode_libdir_flag_spec=
-      export_dynamic_flag_spec=
-      whole_archive_flag_spec=
-    fi
-  else
-    # PORTME fill in a description of your system's linker (not GNU ld)
-    case $host_os in
-    aix3*)
-      allow_undefined_flag=unsupported
-      always_export_symbols=yes
-      archive_expsym_cmds='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
-      # Note: this linker hardcodes the directories in LIBPATH if there
-      # are no directories specified by -L.
-      hardcode_minus_L=yes
-      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
-	# Neither direct hardcoding nor static linking is supported with a
-	# broken collect2.
-	hardcode_direct=unsupported
-      fi
-      ;;
+else
+  # If there is no Makefile yet, we rely on a make rule to execute
+  # `config.status --recheck' to rerun these tests and create the
+  # libtool script then.
+  ltmain_in=`echo $ltmain | sed -e 's/\.sh$/.in/'`
+  if test -f "$ltmain_in"; then
+    test -f Makefile && make "$ltmain"
+  fi
+fi
 
-    aix[4-9]*)
-      if test "$host_cpu" = ia64; then
-	# On IA64, the linker does run time linking by default, so we don't
-	# have to do anything special.
-	aix_use_runtimelinking=no
-	exp_sym_flag='-Bexport'
-	no_entry_flag=""
-      else
-	# If we're using GNU nm, then we don't want the "-C" option.
-	# -C means demangle to AIX nm, but means don't demangle with GNU nm
-	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
-	  export_symbols_cmds='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
-	else
-	  export_symbols_cmds='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
-	fi
-	aix_use_runtimelinking=no
 
-	# Test if we are trying to use run time linking or normal
-	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
-	# need to do runtime linking.
-	case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
-	  for ld_flag in $LDFLAGS; do
-	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
-	    aix_use_runtimelinking=yes
-	    break
-	  fi
-	  done
-	  ;;
-	esac
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
 
-	exp_sym_flag='-bexport'
-	no_entry_flag='-bnoentry'
-      fi
+CC="$lt_save_CC"
 
-      # When large executables or shared objects are built, AIX ld can
-      # have problems creating the table of contents.  If linking a library
-      # or program results in "error TOC overflow" add -mminimal-toc to
-      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
-      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
 
-      archive_cmds=''
-      hardcode_direct=yes
-      hardcode_direct_absolute=yes
-      hardcode_libdir_separator=':'
-      link_all_deplibs=yes
-      file_list_spec='${wl}-f,'
+# Check whether --with-tags was given.
+if test "${with_tags+set}" = set; then :
+  withval=$with_tags; tagnames="$withval"
+fi
 
-      if test "$GCC" = yes; then
-	case $host_os in aix4.[012]|aix4.[012].*)
-	# We only want to do this on AIX 4.2 and lower, the check
-	# below for broken collect2 doesn't work under 4.3+
-	  collect2name=`${CC} -print-prog-name=collect2`
-	  if test -f "$collect2name" &&
-	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
-	  then
-	  # We have reworked collect2
-	  :
-	  else
-	  # We have old collect2
-	  hardcode_direct=unsupported
-	  # It fails to find uninstalled libraries when the uninstalled
-	  # path is not listed in the libpath.  Setting hardcode_minus_L
-	  # to unsupported forces relinking
-	  hardcode_minus_L=yes
-	  hardcode_libdir_flag_spec='-L$libdir'
-	  hardcode_libdir_separator=
-	  fi
-	  ;;
-	esac
-	shared_flag='-shared'
-	if test "$aix_use_runtimelinking" = yes; then
-	  shared_flag="$shared_flag "'${wl}-G'
-	fi
-      else
-	# not using gcc
-	if test "$host_cpu" = ia64; then
-	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
-	# chokes on -Wl,-G. The following line is correct:
-	  shared_flag='-G'
-	else
-	  if test "$aix_use_runtimelinking" = yes; then
-	    shared_flag='${wl}-G'
-	  else
-	    shared_flag='${wl}-bM:SRE'
-	  fi
-	fi
-      fi
 
-      export_dynamic_flag_spec='${wl}-bexpall'
-      # It seems that -bexpall does not export symbols beginning with
-      # underscore (_), so it is better to generate a list of symbols to export.
-      always_export_symbols=yes
-      if test "$aix_use_runtimelinking" = yes; then
-	# Warning - without using the other runtime loading flags (-brtl),
-	# -berok will link without error, but may produce a broken library.
-	allow_undefined_flag='-berok'
-        # Determine the default libpath from the value encoded in an
-        # empty executable.
-        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+if test -f "$ltmain" && test -n "$tagnames"; then
+  if test ! -f "${ofile}"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: output file \`$ofile' does not exist" >&5
+$as_echo "$as_me: WARNING: output file \`$ofile' does not exist" >&2;}
+  fi
 
-int
-main ()
-{
+  if test -z "$LTCC"; then
+    eval "`$SHELL ${ofile} --config | grep '^LTCC='`"
+    if test -z "$LTCC"; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: output file \`$ofile' does not look like a libtool script" >&5
+$as_echo "$as_me: WARNING: output file \`$ofile' does not look like a libtool script" >&2;}
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using \`LTCC=$LTCC', extracted from \`$ofile'" >&5
+$as_echo "$as_me: WARNING: using \`LTCC=$LTCC', extracted from \`$ofile'" >&2;}
+    fi
+  fi
+  if test -z "$LTCFLAGS"; then
+    eval "`$SHELL ${ofile} --config | grep '^LTCFLAGS='`"
+  fi
 
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
+  # Extract list of available tagged configurations in $ofile.
+  # Note that this assumes the entire list is on one line.
+  available_tags=`grep "^available_tags=" "${ofile}" | $SED -e 's/available_tags=\(.*$\)/\1/' -e 's/\"//g'`
 
-lt_aix_libpath_sed='
-    /Import File Strings/,/^$/ {
-	/^0/ {
-	    s/^0  *\(.*\)$/\1/
-	    p
-	}
-    }'
-aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-# Check for a 64-bit object if we didn't find anything.
-if test -z "$aix_libpath"; then
-  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+  lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+  for tagname in $tagnames; do
+    IFS="$lt_save_ifs"
+    # Check whether tagname contains only valid characters
+    case `$echo "X$tagname" | $Xsed -e 's:[-_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890,/]::g'` in
+    "") ;;
+    *)  as_fn_error "invalid tag name: $tagname" "$LINENO" 5
+	;;
+    esac
 
-        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
-        archive_expsym_cmds='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then $ECHO "X${wl}${allow_undefined_flag}" | $Xsed; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
-      else
-	if test "$host_cpu" = ia64; then
-	  hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
-	  allow_undefined_flag="-z nodefs"
-	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
-	else
-	 # Determine the default libpath from the value encoded in an
-	 # empty executable.
-	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+    if grep "^# ### BEGIN LIBTOOL TAG CONFIG: $tagname$" < "${ofile}" > /dev/null
+    then
+      as_fn_error "tag name \"$tagname\" already exists" "$LINENO" 5
+    fi
 
-int
-main ()
-{
+    # Update the list of available tags.
+    if test -n "$tagname"; then
+      echo appending configuration tag \"$tagname\" to $ofile
+
+      case $tagname in
+      CXX)
+	if test -n "$CXX" && ( test "X$CXX" != "Xno" &&
+	    ( (test "X$CXX" = "Xg++" && `g++ -v >/dev/null 2>&1` ) ||
+	    (test "X$CXX" != "Xg++"))) ; then
+	  ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
 
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
 
-lt_aix_libpath_sed='
-    /Import File Strings/,/^$/ {
-	/^0/ {
-	    s/^0  *\(.*\)$/\1/
-	    p
-	}
-    }'
-aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-# Check for a 64-bit object if we didn't find anything.
-if test -z "$aix_libpath"; then
-  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
 
-	 hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
-	  # Warning - without using the other run time loading flags,
-	  # -berok will link without error, but may produce a broken library.
-	  no_undefined_flag=' ${wl}-bernotok'
-	  allow_undefined_flag=' ${wl}-berok'
-	  # Exported symbols can be pulled into shared objects from archives
-	  whole_archive_flag_spec='$convenience'
-	  archive_cmds_need_lc=yes
-	  # This is similar to how AIX traditionally builds its shared libraries.
-	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
-	fi
-      fi
-      ;;
 
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-            archive_expsym_cmds=''
-        ;;
-      m68k)
-            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
-            hardcode_libdir_flag_spec='-L$libdir'
-            hardcode_minus_L=yes
-        ;;
-      esac
-      ;;
+archive_cmds_need_lc_CXX=no
+allow_undefined_flag_CXX=
+always_export_symbols_CXX=no
+archive_expsym_cmds_CXX=
+export_dynamic_flag_spec_CXX=
+hardcode_direct_CXX=no
+hardcode_libdir_flag_spec_CXX=
+hardcode_libdir_flag_spec_ld_CXX=
+hardcode_libdir_separator_CXX=
+hardcode_minus_L_CXX=no
+hardcode_shlibpath_var_CXX=unsupported
+hardcode_automatic_CXX=no
+module_cmds_CXX=
+module_expsym_cmds_CXX=
+link_all_deplibs_CXX=unknown
+old_archive_cmds_CXX=$old_archive_cmds
+no_undefined_flag_CXX=
+whole_archive_flag_spec_CXX=
+enable_shared_with_static_runtimes_CXX=no
 
-    bsdi[45]*)
-      export_dynamic_flag_spec=-rdynamic
-      ;;
-
-    cygwin* | mingw* | pw32* | cegcc*)
-      # When not using gcc, we currently assume that we are using
-      # Microsoft Visual C++.
-      # hardcode_libdir_flag_spec is actually meaningless, as there is
-      # no search path for DLLs.
-      hardcode_libdir_flag_spec=' '
-      allow_undefined_flag=unsupported
-      # Tell ltmain to make .lib files, not .a files.
-      libext=lib
-      # Tell ltmain to make .dll files, not .so files.
-      shrext_cmds=".dll"
-      # FIXME: Setting linknames here is a bad hack.
-      archive_cmds='$CC -o $lib $libobjs $compiler_flags `$ECHO "X$deplibs" | $Xsed -e '\''s/ -lc$//'\''` -link -dll~linknames='
-      # The linker will automatically build a .lib file if we build a DLL.
-      old_archive_from_new_cmds='true'
-      # FIXME: Should let the user specify the lib program.
-      old_archive_cmds='lib -OUT:$oldlib$oldobjs$old_deplibs'
-      fix_srcfile_path='`cygpath -w "$srcfile"`'
-      enable_shared_with_static_runtimes=yes
-      ;;
-
-    darwin* | rhapsody*)
-
-
-  archive_cmds_need_lc=no
-  hardcode_direct=no
-  hardcode_automatic=yes
-  hardcode_shlibpath_var=unsupported
-  whole_archive_flag_spec=''
-  link_all_deplibs=yes
-  allow_undefined_flag="$_lt_dar_allow_undefined"
-  case $cc_basename in
-     ifort*) _lt_dar_can_shared=yes ;;
-     *) _lt_dar_can_shared=$GCC ;;
-  esac
-  if test "$_lt_dar_can_shared" = "yes"; then
-    output_verbose_link_cmd=echo
-    archive_cmds="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
-    module_cmds="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
-    archive_expsym_cmds="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
-    module_expsym_cmds="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
-
-  else
-  ld_shlibs=no
-  fi
-
-      ;;
+# Dependencies to place before and after the object being linked:
+predep_objects_CXX=
+postdep_objects_CXX=
+predeps_CXX=
+postdeps_CXX=
+compiler_lib_search_path_CXX=
 
-    dgux*)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_shlibpath_var=no
-      ;;
+# Source file extension for C++ test sources.
+ac_ext=cpp
 
-    freebsd1*)
-      ld_shlibs=no
-      ;;
+# Object file extension for compiled C++ test sources.
+objext=o
+objext_CXX=$objext
 
-    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
-    # support.  Future versions do this automatically, but an explicit c++rt0.o
-    # does not break anything, and helps significantly (at the cost of a little
-    # extra space).
-    freebsd2.2*)
-      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="int some_variable = 0;\n"
 
-    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
-      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_direct=yes
-      hardcode_minus_L=yes
-      hardcode_shlibpath_var=no
-      ;;
+# Code to be used in simple link tests
+lt_simple_link_test_code='int main(int, char *[]) { return(0); }\n'
 
-    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
-    freebsd* | dragonfly*)
-      archive_cmds='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
+# ltmain only uses $CC for tagged configurations so make sure $CC is set.
 
-    hpux9*)
-      if test "$GCC" = yes; then
-	archive_cmds='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
-      else
-	archive_cmds='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
-      fi
-      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-      hardcode_libdir_separator=:
-      hardcode_direct=yes
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
 
-      # hardcode_minus_L: Not really in the search PATH,
-      # but as the default location of the library.
-      hardcode_minus_L=yes
-      export_dynamic_flag_spec='${wl}-E'
-      ;;
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
 
-    hpux10*)
-      if test "$GCC" = yes -a "$with_gnu_ld" = no; then
-	archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
-      fi
-      if test "$with_gnu_ld" = no; then
-	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-	hardcode_libdir_flag_spec_ld='+b $libdir'
-	hardcode_libdir_separator=:
-	hardcode_direct=yes
-	hardcode_direct_absolute=yes
-	export_dynamic_flag_spec='${wl}-E'
-	# hardcode_minus_L: Not really in the search PATH,
-	# but as the default location of the library.
-	hardcode_minus_L=yes
-      fi
-      ;;
+# Allow CC to be a program name with arguments.
+compiler=$CC
 
-    hpux11*)
-      if test "$GCC" = yes -a "$with_gnu_ld" = no; then
-	case $host_cpu in
-	hppa*64*)
-	  archive_cmds='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	ia64*)
-	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	*)
-	  archive_cmds='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	esac
-      else
-	case $host_cpu in
-	hppa*64*)
-	  archive_cmds='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	ia64*)
-	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	*)
-	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	esac
-      fi
-      if test "$with_gnu_ld" = no; then
-	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-	hardcode_libdir_separator=:
 
-	case $host_cpu in
-	hppa*64*|ia64*)
-	  hardcode_direct=no
-	  hardcode_shlibpath_var=no
-	  ;;
-	*)
-	  hardcode_direct=yes
-	  hardcode_direct_absolute=yes
-	  export_dynamic_flag_spec='${wl}-E'
+# save warnings/boilerplate of simple test code
+ac_outfile=conftest.$ac_objext
+printf "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$rm conftest*
 
-	  # hardcode_minus_L: Not really in the search PATH,
-	  # but as the default location of the library.
-	  hardcode_minus_L=yes
-	  ;;
-	esac
-      fi
-      ;;
+ac_outfile=conftest.$ac_objext
+printf "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$rm conftest*
 
-    irix5* | irix6* | nonstopux*)
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-	# Try to use the -exported_symbol ld option, if it does not
-	# work, assume that -exports_file does not work either and
-	# implicitly export all symbols.
-        save_LDFLAGS="$LDFLAGS"
-        LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
-        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int foo(void) {}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
 
+# Allow CC to be a program name with arguments.
+lt_save_CC=$CC
+lt_save_LD=$LD
+lt_save_GCC=$GCC
+GCC=$GXX
+lt_save_with_gnu_ld=$with_gnu_ld
+lt_save_path_LD=$lt_cv_path_LD
+if test -n "${lt_cv_prog_gnu_ldcxx+set}"; then
+  lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx
+else
+  $as_unset lt_cv_prog_gnu_ld
 fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-        LDFLAGS="$save_LDFLAGS"
-      else
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
-      fi
-      archive_cmds_need_lc='no'
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      inherit_rpath=yes
-      link_all_deplibs=yes
-      ;;
+if test -n "${lt_cv_path_LDCXX+set}"; then
+  lt_cv_path_LD=$lt_cv_path_LDCXX
+else
+  $as_unset lt_cv_path_LD
+fi
+test -z "${LDCXX+set}" || LD=$LDCXX
+CC=${CXX-"c++"}
+compiler=$CC
+compiler_CXX=$CC
+for cc_temp in $compiler""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$echo "X$cc_temp" | $Xsed -e 's%.*/%%' -e "s%^$host_alias-%%"`
 
-    netbsd*)
-      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
-      else
-	archive_cmds='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
-      fi
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
 
-    newsos6)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_direct=yes
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      hardcode_shlibpath_var=no
-      ;;
+# We don't want -fno-exception wen compiling C++ code, so set the
+# no_builtin_flag separately
+if test "$GXX" = yes; then
+  lt_prog_compiler_no_builtin_flag_CXX=' -fno-builtin'
+else
+  lt_prog_compiler_no_builtin_flag_CXX=
+fi
 
-    *nto* | *qnx*)
-      ;;
+if test "$GXX" = yes; then
+  # Set up default GNU C++ configuration
 
-    openbsd*)
-      if test -f /usr/libexec/ld.so; then
-	hardcode_direct=yes
-	hardcode_shlibpath_var=no
-	hardcode_direct_absolute=yes
-	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-	  archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
-	  hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-	  export_dynamic_flag_spec='${wl}-E'
-	else
-	  case $host_os in
-	   openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
-	     archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-	     hardcode_libdir_flag_spec='-R$libdir'
-	     ;;
-	   *)
-	     archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
-	     hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-	     ;;
-	  esac
-	fi
-      else
-	ld_shlibs=no
-      fi
-      ;;
 
-    os2*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_minus_L=yes
-      allow_undefined_flag=unsupported
-      archive_cmds='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~$ECHO DATA >> $output_objdir/$libname.def~$ECHO " SINGLE NONSHARED" >> $output_objdir/$libname.def~$ECHO EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
-      old_archive_from_new_cmds='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
-      ;;
+# Check whether --with-gnu-ld was given.
+if test "${with_gnu_ld+set}" = set; then :
+  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
+else
+  with_gnu_ld=no
+fi
 
-    osf3*)
-      if test "$GCC" = yes; then
-	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-      else
-	allow_undefined_flag=' -expect_unresolved \*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
-      fi
-      archive_cmds_need_lc='no'
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
+$as_echo_n "checking for ld used by $CC... " >&6; }
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [\\/]* | ?:[\\/]*)
+      re_direlt='/[^/][^/]*/\.\./'
+      # Canonicalize the pathname of ld
+      ac_prog=`echo $ac_prog| $SED 's%\\\\%/%g'`
+      while echo $ac_prog | grep "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`echo $ac_prog| $SED "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
       ;;
-
-    osf4* | osf5*)	# as osf3* with the addition of -msym flag
-      if test "$GCC" = yes; then
-	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-	hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      else
-	allow_undefined_flag=' -expect_unresolved \*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
-	archive_expsym_cmds='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
-	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
-
-	# Both c and cxx compiler support -rpath directly
-	hardcode_libdir_flag_spec='-rpath $libdir'
-      fi
-      archive_cmds_need_lc='no'
-      hardcode_libdir_separator=:
-      ;;
-
-    solaris*)
-      no_undefined_flag=' -z defs'
-      if test "$GCC" = yes; then
-	wlarc='${wl}'
-	archive_cmds='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
-      else
-	case `$CC -V 2>&1` in
-	*"Compilers 5.0"*)
-	  wlarc=''
-	  archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
-	  ;;
-	*)
-	  wlarc='${wl}'
-	  archive_cmds='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
-	  ;;
-	esac
-      fi
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_shlibpath_var=no
-      case $host_os in
-      solaris2.[0-5] | solaris2.[0-5].*) ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
+$as_echo_n "checking for GNU ld... " >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for non-GNU ld" >&5
+$as_echo_n "checking for non-GNU ld... " >&6; }
+fi
+if test "${lt_cv_path_LD+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$LD"; then
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      lt_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some variants of GNU ld only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break
+	;;
       *)
-	# The compiler driver will combine and reorder linker options,
-	# but understands `-z linker_flag'.  GCC discards it without `$wl',
-	# but is careful enough not to reorder.
-	# Supported since Solaris 2.6 (maybe 2.5.1?)
-	if test "$GCC" = yes; then
-	  whole_archive_flag_spec='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
-	else
-	  whole_archive_flag_spec='-z allextract$convenience -z defaultextract'
-	fi
+	test "$with_gnu_ld" != yes && break
 	;;
       esac
-      link_all_deplibs=yes
-      ;;
+    fi
+  done
+  IFS="$lt_save_ifs"
+else
+  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+fi
+fi
 
-    sunos4*)
-      if test "x$host_vendor" = xsequent; then
-	# Use $CC to link under sequent, because it throws in some extra .o
-	# files that make .init and .fini sections work.
-	archive_cmds='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
-      fi
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_direct=yes
-      hardcode_minus_L=yes
-      hardcode_shlibpath_var=no
-      ;;
+LD="$lt_cv_path_LD"
+if test -n "$LD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
+$as_echo "$LD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+test -z "$LD" && as_fn_error "no acceptable ld found in \$PATH" "$LINENO" 5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
+$as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
+if test "${lt_cv_prog_gnu_ld+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  # I'd rather use --version here, but apparently some GNU lds only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  lt_cv_prog_gnu_ld=yes
+  ;;
+*)
+  lt_cv_prog_gnu_ld=no
+  ;;
+esac
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_gnu_ld" >&5
+$as_echo "$lt_cv_prog_gnu_ld" >&6; }
+with_gnu_ld=$lt_cv_prog_gnu_ld
 
-    sysv4)
-      case $host_vendor in
-	sni)
-	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	  hardcode_direct=yes # is this really true???
-	;;
-	siemens)
-	  ## LD is ld it makes a PLAMLIB
-	  ## CC just makes a GrossModule.
-	  archive_cmds='$LD -G -o $lib $libobjs $deplibs $linker_flags'
-	  reload_cmds='$CC -r -o $output$reload_objs'
-	  hardcode_direct=no
-        ;;
-	motorola)
-	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	  hardcode_direct=no #Motorola manual says yes, but my tests say they lie
-	;;
-      esac
-      runpath_var='LD_RUN_PATH'
-      hardcode_shlibpath_var=no
-      ;;
 
-    sysv4.3*)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_shlibpath_var=no
-      export_dynamic_flag_spec='-Bexport'
-      ;;
 
-    sysv4*MP*)
-      if test -d /usr/nec; then
-	archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	hardcode_shlibpath_var=no
-	runpath_var=LD_RUN_PATH
-	hardcode_runpath_var=yes
-	ld_shlibs=yes
-      fi
-      ;;
+  # Check if GNU C++ uses GNU ld as the underlying linker, since the
+  # archiving commands below assume that GNU ld is being used.
+  if test "$with_gnu_ld" = yes; then
+    archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+    archive_expsym_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
 
-    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
-      no_undefined_flag='${wl}-z,text'
-      archive_cmds_need_lc=no
-      hardcode_shlibpath_var=no
-      runpath_var='LD_RUN_PATH'
+    hardcode_libdir_flag_spec_CXX='${wl}--rpath ${wl}$libdir'
+    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
 
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      fi
-      ;;
+    # If archive_cmds runs LD, not CC, wlarc should be empty
+    # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to
+    #     investigate it a little bit more. (MM)
+    wlarc='${wl}'
 
-    sysv5* | sco3.2v5* | sco5v6*)
-      # Note: We can NOT use -z defs as we might desire, because we do not
-      # link with -lc, and that would cause any symbols used from libc to
-      # always be unresolved, which means just about no library would
-      # ever link correctly.  If we're not using GNU ld we use -z text
-      # though, which does catch some bad symbols but isn't as heavy-handed
-      # as -z defs.
-      no_undefined_flag='${wl}-z,text'
-      allow_undefined_flag='${wl}-z,nodefs'
-      archive_cmds_need_lc=no
-      hardcode_shlibpath_var=no
-      hardcode_libdir_flag_spec='${wl}-R,$libdir'
-      hardcode_libdir_separator=':'
-      link_all_deplibs=yes
-      export_dynamic_flag_spec='${wl}-Bexport'
-      runpath_var='LD_RUN_PATH'
+    # ancient GNU ld didn't support --whole-archive et. al.
+    if eval "`$CC -print-prog-name=ld` --help 2>&1" | \
+	grep 'no-whole-archive' > /dev/null; then
+      whole_archive_flag_spec_CXX="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+    else
+      whole_archive_flag_spec_CXX=
+    fi
+  else
+    with_gnu_ld=no
+    wlarc=
 
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      fi
-      ;;
+    # A generic and very simple default shared library creation
+    # command for GNU C++ for the case where it uses the native
+    # linker, instead of GNU ld.  If possible, this setting should
+    # overridden to take advantage of the native linker features on
+    # the platform it is being used on.
+    archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
+  fi
 
-    uts4*)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_shlibpath_var=no
-      ;;
+  # Commands to make compiler produce verbose output that lists
+  # what "hidden" libraries, object files and flags are used when
+  # linking a shared library.
+  output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | grep "\-L"'
 
-    *)
-      ld_shlibs=no
-      ;;
-    esac
+else
+  GXX=no
+  with_gnu_ld=no
+  wlarc=
+fi
 
-    if test x$host_vendor = xsni; then
-      case $host in
-      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
-	export_dynamic_flag_spec='${wl}-Blargedynsym'
+# PORTME: fill in a description of your system's C++ link characteristics
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
+ld_shlibs_CXX=yes
+case $host_os in
+  aix3*)
+    # FIXME: insert proper C++ library support
+    ld_shlibs_CXX=no
+    ;;
+  aix4* | aix5*)
+    if test "$host_cpu" = ia64; then
+      # On IA64, the linker does run time linking by default, so we don't
+      # have to do anything special.
+      aix_use_runtimelinking=no
+      exp_sym_flag='-Bexport'
+      no_entry_flag=""
+    else
+      aix_use_runtimelinking=no
+
+      # Test if we are trying to use run time linking or normal
+      # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+      # need to do runtime linking.
+      case $host_os in aix4.[23]|aix4.[23].*|aix5*)
+	for ld_flag in $LDFLAGS; do
+	  case $ld_flag in
+	  *-brtl*)
+	    aix_use_runtimelinking=yes
+	    break
+	    ;;
+	  esac
+	done
 	;;
       esac
-    fi
-  fi
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs" >&5
-$as_echo "$ld_shlibs" >&6; }
-test "$ld_shlibs" = no && can_build_shared=no
-
-with_gnu_ld=$with_gnu_ld
+      exp_sym_flag='-bexport'
+      no_entry_flag='-bnoentry'
+    fi
 
+    # When large executables or shared objects are built, AIX ld can
+    # have problems creating the table of contents.  If linking a library
+    # or program results in "error TOC overflow" add -mminimal-toc to
+    # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+    # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+    archive_cmds_CXX=''
+    hardcode_direct_CXX=yes
+    hardcode_libdir_separator_CXX=':'
+    link_all_deplibs_CXX=yes
 
+    if test "$GXX" = yes; then
+      case $host_os in aix4.[012]|aix4.[012].*)
+      # We only want to do this on AIX 4.2 and lower, the check
+      # below for broken collect2 doesn't work under 4.3+
+	collect2name=`${CC} -print-prog-name=collect2`
+	if test -f "$collect2name" && \
+	   strings "$collect2name" | grep resolve_lib_name >/dev/null
+	then
+	  # We have reworked collect2
+	  hardcode_direct_CXX=yes
+	else
+	  # We have old collect2
+	  hardcode_direct_CXX=unsupported
+	  # It fails to find uninstalled libraries when the uninstalled
+	  # path is not listed in the libpath.  Setting hardcode_minus_L
+	  # to unsupported forces relinking
+	  hardcode_minus_L_CXX=yes
+	  hardcode_libdir_flag_spec_CXX='-L$libdir'
+	  hardcode_libdir_separator_CXX=
+	fi
+	;;
+      esac
+      shared_flag='-shared'
+      if test "$aix_use_runtimelinking" = yes; then
+	shared_flag="$shared_flag "'${wl}-G'
+      fi
+    else
+      # not using gcc
+      if test "$host_cpu" = ia64; then
+	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	# chokes on -Wl,-G. The following line is correct:
+	shared_flag='-G'
+      else
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag='${wl}-G'
+	else
+	  shared_flag='${wl}-bM:SRE'
+	fi
+      fi
+    fi
 
+    # It seems that -bexpall does not export symbols beginning with
+    # underscore (_), so it is better to generate a list of symbols to export.
+    always_export_symbols_CXX=yes
+    if test "$aix_use_runtimelinking" = yes; then
+      # Warning - without using the other runtime loading flags (-brtl),
+      # -berok will link without error, but may produce a broken library.
+      allow_undefined_flag_CXX='-berok'
+      # Determine the default libpath from the value encoded in an empty executable.
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
+int
+main ()
+{
 
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
 
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`; fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
 
+      hardcode_libdir_flag_spec_CXX='${wl}-blibpath:$libdir:'"$aix_libpath"
 
+      archive_expsym_cmds_CXX="\$CC"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then echo "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+     else
+      if test "$host_cpu" = ia64; then
+	hardcode_libdir_flag_spec_CXX='${wl}-R $libdir:/usr/lib:/lib'
+	allow_undefined_flag_CXX="-z nodefs"
+	archive_expsym_cmds_CXX="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+      else
+	# Determine the default libpath from the value encoded in an empty executable.
+	cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
+int
+main ()
+{
 
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
 
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`; fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
 
+	hardcode_libdir_flag_spec_CXX='${wl}-blibpath:$libdir:'"$aix_libpath"
+	# Warning - without using the other run time loading flags,
+	# -berok will link without error, but may produce a broken library.
+	no_undefined_flag_CXX=' ${wl}-bernotok'
+	allow_undefined_flag_CXX=' ${wl}-berok'
+	# Exported symbols can be pulled into shared objects from archives
+	whole_archive_flag_spec_CXX='$convenience'
+	archive_cmds_need_lc_CXX=yes
+	# This is similar to how AIX traditionally builds its shared libraries.
+	archive_expsym_cmds_CXX="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+      fi
+    fi
+    ;;
 
+  beos*)
+    if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+      allow_undefined_flag_CXX=unsupported
+      # Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+      # support --undefined.  This deserves some investigation.  FIXME
+      archive_cmds_CXX='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+    else
+      ld_shlibs_CXX=no
+    fi
+    ;;
 
+  chorus*)
+    case $cc_basename in
+      *)
+	# FIXME: insert proper C++ library support
+	ld_shlibs_CXX=no
+	;;
+    esac
+    ;;
 
-#
-# Do we need to explicitly link libc?
-#
-case "x$archive_cmds_need_lc" in
-x|xyes)
-  # Assume -lc should be added
-  archive_cmds_need_lc=yes
+  cygwin* | mingw* | pw32*)
+    # _LT_AC_TAGVAR(hardcode_libdir_flag_spec, CXX) is actually meaningless,
+    # as there is no search path for DLLs.
+    hardcode_libdir_flag_spec_CXX='-L$libdir'
+    allow_undefined_flag_CXX=unsupported
+    always_export_symbols_CXX=no
+    enable_shared_with_static_runtimes_CXX=yes
+
+    if $LD --help 2>&1 | grep 'auto-import' > /dev/null; then
+      archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+      # If the export-symbols file already is a .def file (1st line
+      # is EXPORTS), use it as is; otherwise, prepend...
+      archive_expsym_cmds_CXX='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	cp $export_symbols $output_objdir/$soname.def;
+      else
+	echo EXPORTS > $output_objdir/$soname.def;
+	cat $export_symbols >> $output_objdir/$soname.def;
+      fi~
+      $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+    else
+      ld_shlibs_CXX=no
+    fi
+  ;;
+      darwin* | rhapsody*)
+        case $host_os in
+        rhapsody* | darwin1.[012])
+         allow_undefined_flag_CXX='${wl}-undefined ${wl}suppress'
+         ;;
+       *) # Darwin 1.3 on
+         if test -z ${MACOSX_DEPLOYMENT_TARGET} ; then
+           allow_undefined_flag_CXX='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
+         else
+           case ${MACOSX_DEPLOYMENT_TARGET} in
+             10.[012])
+               allow_undefined_flag_CXX='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
+               ;;
+             10.*)
+               allow_undefined_flag_CXX='${wl}-undefined ${wl}dynamic_lookup'
+               ;;
+           esac
+         fi
+         ;;
+        esac
+      archive_cmds_need_lc_CXX=no
+      hardcode_direct_CXX=no
+      hardcode_automatic_CXX=yes
+      hardcode_shlibpath_var_CXX=unsupported
+      whole_archive_flag_spec_CXX=''
+      link_all_deplibs_CXX=yes
+
+    if test "$GXX" = yes ; then
+      lt_int_apple_cc_single_mod=no
+      output_verbose_link_cmd='echo'
+      if $CC -dumpspecs 2>&1 | $EGREP 'single_module' >/dev/null ; then
+       lt_int_apple_cc_single_mod=yes
+      fi
+      if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
+       archive_cmds_CXX='$CC -dynamiclib -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+      else
+          archive_cmds_CXX='$CC -r -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs~$CC -dynamiclib $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+        fi
+        module_cmds_CXX='$CC $allow_undefined_flag -o $lib -bundle $libobjs $deplibs$compiler_flags'
+        # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin lds
+          if test "X$lt_int_apple_cc_single_mod" = Xyes ; then
+            archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -dynamiclib -single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          else
+            archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -r -keep_private_externs -nostdlib -o ${lib}-master.o $libobjs~$CC -dynamiclib $allow_undefined_flag -o $lib ${lib}-master.o $deplibs $compiler_flags -install_name $rpath/$soname $verstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          fi
+            module_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC $allow_undefined_flag  -o $lib -bundle $libobjs $deplibs$compiler_flags~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+      else
+      case $cc_basename in
+        xlc*)
+         output_verbose_link_cmd='echo'
+          archive_cmds_CXX='$CC -qmkshrobj ${wl}-single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-install_name ${wl}`echo $rpath/$soname` $verstring'
+          module_cmds_CXX='$CC $allow_undefined_flag -o $lib -bundle $libobjs $deplibs$compiler_flags'
+          # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin lds
+          archive_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -qmkshrobj ${wl}-single_module $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-install_name ${wl}$rpath/$soname $verstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          module_expsym_cmds_CXX='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC $allow_undefined_flag  -o $lib -bundle $libobjs $deplibs$compiler_flags~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          ;;
+       *)
+         ld_shlibs_CXX=no
+          ;;
+      esac
+      fi
+        ;;
 
-  if test "$enable_shared" = yes && test "$GCC" = yes; then
-    case $archive_cmds in
-    *'~'*)
-      # FIXME: we may have to deal with multi-command sequences.
+  dgux*)
+    case $cc_basename in
+      ec++*)
+	# FIXME: insert proper C++ library support
+	ld_shlibs_CXX=no
+	;;
+      ghcx*)
+	# Green Hills C++ Compiler
+	# FIXME: insert proper C++ library support
+	ld_shlibs_CXX=no
+	;;
+      *)
+	# FIXME: insert proper C++ library support
+	ld_shlibs_CXX=no
+	;;
+    esac
+    ;;
+  freebsd[12]*)
+    # C++ shared libraries reported to be fairly broken before switch to ELF
+    ld_shlibs_CXX=no
+    ;;
+  freebsd-elf*)
+    archive_cmds_need_lc_CXX=no
+    ;;
+  freebsd* | kfreebsd*-gnu | dragonfly*)
+    # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF
+    # conventions
+    ld_shlibs_CXX=yes
+    ;;
+  gnu*)
+    ;;
+  hpux9*)
+    hardcode_libdir_flag_spec_CXX='${wl}+b ${wl}$libdir'
+    hardcode_libdir_separator_CXX=:
+    export_dynamic_flag_spec_CXX='${wl}-E'
+    hardcode_direct_CXX=yes
+    hardcode_minus_L_CXX=yes # Not in the search PATH,
+				# but as the default
+				# location of the library.
+
+    case $cc_basename in
+    CC*)
+      # FIXME: insert proper C++ library support
+      ld_shlibs_CXX=no
       ;;
-    '$CC '*)
-      # Test whether the compiler implicitly links with -lc since on some
-      # systems, -lgcc has to come before -lc. If gcc already passes -lc
-      # to ld, don't add -lc before -lgcc.
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
-$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
-      $RM conftest*
-      echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-
-      if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } 2>conftest.err; then
-        soname=conftest
-        lib=conftest
-        libobjs=conftest.$ac_objext
-        deplibs=
-        wl=$lt_prog_compiler_wl
-	pic_flag=$lt_prog_compiler_pic
-        compiler_flags=-v
-        linker_flags=-v
-        verstring=
-        output_objdir=.
-        libname=conftest
-        lt_save_allow_undefined_flag=$allow_undefined_flag
-        allow_undefined_flag=
-        if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\""; } >&5
-  (eval $archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-        then
-	  archive_cmds_need_lc=no
-        else
-	  archive_cmds_need_lc=yes
-        fi
-        allow_undefined_flag=$lt_save_allow_undefined_flag
+    aCC*)
+      archive_cmds_CXX='$rm $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      # Commands to make compiler produce verbose output that lists
+      # what "hidden" libraries, object files and flags are used when
+      # linking a shared library.
+      #
+      # There doesn't appear to be a way to prevent this compiler from
+      # explicitly linking system object files so we need to strip them
+      # from the output so that they don't get included in the library
+      # dependencies.
+      output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | grep "[-]L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; echo $list'
+      ;;
+    *)
+      if test "$GXX" = yes; then
+        archive_cmds_CXX='$rm $output_objdir/$soname~$CC -shared -nostdlib -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
       else
-        cat conftest.err 1>&5
+        # FIXME: insert proper C++ library support
+        ld_shlibs_CXX=no
       fi
-      $RM conftest*
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $archive_cmds_need_lc" >&5
-$as_echo "$archive_cmds_need_lc" >&6; }
       ;;
     esac
-  fi
-  ;;
-esac
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
+    ;;
+  hpux10*|hpux11*)
+    if test $with_gnu_ld = no; then
+      hardcode_libdir_flag_spec_CXX='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator_CXX=:
 
+      case $host_cpu in
+      hppa*64*|ia64*)
+	hardcode_libdir_flag_spec_ld_CXX='+b $libdir'
+        ;;
+      *)
+	export_dynamic_flag_spec_CXX='${wl}-E'
+        ;;
+      esac
+    fi
+    case $host_cpu in
+    hppa*64*|ia64*)
+      hardcode_direct_CXX=no
+      hardcode_shlibpath_var_CXX=no
+      ;;
+    *)
+      hardcode_direct_CXX=yes
+      hardcode_minus_L_CXX=yes # Not in the search PATH,
+					      # but as the default
+					      # location of the library.
+      ;;
+    esac
 
+    case $cc_basename in
+      CC*)
+	# FIXME: insert proper C++ library support
+	ld_shlibs_CXX=no
+	;;
+      aCC*)
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	  ;;
+	esac
+	# Commands to make compiler produce verbose output that lists
+	# what "hidden" libraries, object files and flags are used when
+	# linking a shared library.
+	#
+	# There doesn't appear to be a way to prevent this compiler from
+	# explicitly linking system object files so we need to strip them
+	# from the output so that they don't get included in the library
+	# dependencies.
+	output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | grep "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; echo $list'
+	;;
+      *)
+	if test "$GXX" = yes; then
+	  if test $with_gnu_ld = no; then
+	    case $host_cpu in
+	    hppa*64*)
+	      archive_cmds_CXX='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	      ;;
+	    ia64*)
+	      archive_cmds_CXX='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	      ;;
+	    *)
+	      archive_cmds_CXX='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	      ;;
+	    esac
+	  fi
+	else
+	  # FIXME: insert proper C++ library support
+	  ld_shlibs_CXX=no
+	fi
+	;;
+    esac
+    ;;
+  interix3*)
+    hardcode_direct_CXX=no
+    hardcode_shlibpath_var_CXX=no
+    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
+    export_dynamic_flag_spec_CXX='${wl}-E'
+    # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+    # Instead, shared libraries are loaded at an image base (0x10000000 by
+    # default) and relocated if they conflict, which is a slow very memory
+    # consuming and fragmenting process.  To avoid this, we pick a random,
+    # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+    # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+    archive_cmds_CXX='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+    archive_expsym_cmds_CXX='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+    ;;
+  irix5* | irix6*)
+    case $cc_basename in
+      CC*)
+	# SGI C++
+	archive_cmds_CXX='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+
+	# Archives containing C++ object files must be created using
+	# "CC -ar", where "CC" is the IRIX C++ compiler.  This is
+	# necessary to make sure instantiated templates are included
+	# in the archive.
+	old_archive_cmds_CXX='$CC -ar -WR,-u -o $oldlib $oldobjs'
+	;;
+      *)
+	if test "$GXX" = yes; then
+	  if test "$with_gnu_ld" = no; then
+	    archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	  else
+	    archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` -o $lib'
+	  fi
+	fi
+	link_all_deplibs_CXX=yes
+	;;
+    esac
+    hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+    hardcode_libdir_separator_CXX=:
+    ;;
+  linux*)
+    case $cc_basename in
+      KCC*)
+	# Kuck and Associates, Inc. (KAI) C++ Compiler
+
+	# KCC will only create a shared library if the output file
+	# ends with ".so" (or ".sl" for HP-UX), so rename the library
+	# to its proper name (with version) after linking.
+	archive_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+	archive_expsym_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib ${wl}-retain-symbols-file,$export_symbols; mv \$templib $lib'
+	# Commands to make compiler produce verbose output that lists
+	# what "hidden" libraries, object files and flags are used when
+	# linking a shared library.
+	#
+	# There doesn't appear to be a way to prevent this compiler from
+	# explicitly linking system object files so we need to strip them
+	# from the output so that they don't get included in the library
+	# dependencies.
+	output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | grep "ld"`; rm -f libconftest$shared_ext; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; echo $list'
+
+	hardcode_libdir_flag_spec_CXX='${wl}--rpath,$libdir'
+	export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
+
+	# Archives containing C++ object files must be created using
+	# "CC -Bstatic", where "CC" is the KAI C++ compiler.
+	old_archive_cmds_CXX='$CC -Bstatic -o $oldlib $oldobjs'
+	;;
+      icpc*)
+	# Intel C++
+	with_gnu_ld=yes
+	# version 8.0 and above of icpc choke on multiply defined symbols
+	# if we add $predep_objects and $postdep_objects, however 7.1 and
+	# earlier do not add the objects themselves.
+	case `$CC -V 2>&1` in
+	*"Version 7."*)
+  	  archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+  	  archive_expsym_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	  ;;
+	*)  # Version 8.0 or newer
+	  tmp_idyn=
+	  case $host_cpu in
+	    ia64*) tmp_idyn=' -i_dynamic';;
+	  esac
+  	  archive_cmds_CXX='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	  archive_expsym_cmds_CXX='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	  ;;
+	esac
+	archive_cmds_need_lc_CXX=no
+	hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
+	export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
+	whole_archive_flag_spec_CXX='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	;;
+      pgCC*)
+        # Portland Group C++ compiler
+	archive_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+  	archive_expsym_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+
+	hardcode_libdir_flag_spec_CXX='${wl}--rpath ${wl}$libdir'
+	export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
+	whole_archive_flag_spec_CXX='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $echo \"$new_convenience\"` ${wl}--no-whole-archive'
+        ;;
+      cxx*)
+	# Compaq C++
+	archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'
 
+	runpath_var=LD_RUN_PATH
+	hardcode_libdir_flag_spec_CXX='-rpath $libdir'
+	hardcode_libdir_separator_CXX=:
 
+	# Commands to make compiler produce verbose output that lists
+	# what "hidden" libraries, object files and flags are used when
+	# linking a shared library.
+	#
+	# There doesn't appear to be a way to prevent this compiler from
+	# explicitly linking system object files so we need to strip them
+	# from the output so that they don't get included in the library
+	# dependencies.
+	output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | grep "ld"`; templist=`echo $templist | $SED "s/\(^.*ld.*\)\( .*ld .*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; echo $list'
+	;;
+    esac
+    ;;
+  lynxos*)
+    # FIXME: insert proper C++ library support
+    ld_shlibs_CXX=no
+    ;;
+  m88k*)
+    # FIXME: insert proper C++ library support
+    ld_shlibs_CXX=no
+    ;;
+  mvs*)
+    case $cc_basename in
+      cxx*)
+	# FIXME: insert proper C++ library support
+	ld_shlibs_CXX=no
+	;;
+      *)
+	# FIXME: insert proper C++ library support
+	ld_shlibs_CXX=no
+	;;
+    esac
+    ;;
+  netbsd*)
+    if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
+      archive_cmds_CXX='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'
+      wlarc=
+      hardcode_libdir_flag_spec_CXX='-R$libdir'
+      hardcode_direct_CXX=yes
+      hardcode_shlibpath_var_CXX=no
+    fi
+    # Workaround some broken pre-1.5 toolchains
+    output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | grep conftest.$objext | $SED -e "s:-lgcc -lc -lgcc::"'
+    ;;
+  openbsd2*)
+    # C++ shared libraries are fairly broken
+    ld_shlibs_CXX=no
+    ;;
+  openbsd*)
+    hardcode_direct_CXX=yes
+    hardcode_shlibpath_var_CXX=no
+    archive_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
+    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
+    if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+      archive_expsym_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'
+      export_dynamic_flag_spec_CXX='${wl}-E'
+      whole_archive_flag_spec_CXX="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+    fi
+    output_verbose_link_cmd='echo'
+    ;;
+  osf3*)
+    case $cc_basename in
+      KCC*)
+	# Kuck and Associates, Inc. (KAI) C++ Compiler
+
+	# KCC will only create a shared library if the output file
+	# ends with ".so" (or ".sl" for HP-UX), so rename the library
+	# to its proper name (with version) after linking.
+	archive_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
 
+	hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
+	hardcode_libdir_separator_CXX=:
 
+	# Archives containing C++ object files must be created using
+	# "CC -Bstatic", where "CC" is the KAI C++ compiler.
+	old_archive_cmds_CXX='$CC -Bstatic -o $oldlib $oldobjs'
 
+	;;
+      RCC*)
+	# Rational C++ 2.4.1
+	# FIXME: insert proper C++ library support
+	ld_shlibs_CXX=no
+	;;
+      cxx*)
+	allow_undefined_flag_CXX=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds_CXX='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n "$verstring" && echo ${wl}-set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+
+	hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+	hardcode_libdir_separator_CXX=:
+
+	# Commands to make compiler produce verbose output that lists
+	# what "hidden" libraries, object files and flags are used when
+	# linking a shared library.
+	#
+	# There doesn't appear to be a way to prevent this compiler from
+	# explicitly linking system object files so we need to strip them
+	# from the output so that they don't get included in the library
+	# dependencies.
+	output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | grep "ld" | grep -v "ld:"`; templist=`echo $templist | $SED "s/\(^.*ld.*\)\( .*ld.*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; echo $list'
+	;;
+      *)
+	if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	  allow_undefined_flag_CXX=' ${wl}-expect_unresolved ${wl}\*'
+	  archive_cmds_CXX='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
 
+	  hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+	  hardcode_libdir_separator_CXX=:
 
+	  # Commands to make compiler produce verbose output that lists
+	  # what "hidden" libraries, object files and flags are used when
+	  # linking a shared library.
+	  output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | grep "\-L"'
 
+	else
+	  # FIXME: insert proper C++ library support
+	  ld_shlibs_CXX=no
+	fi
+	;;
+    esac
+    ;;
+  osf4* | osf5*)
+    case $cc_basename in
+      KCC*)
+	# Kuck and Associates, Inc. (KAI) C++ Compiler
+
+	# KCC will only create a shared library if the output file
+	# ends with ".so" (or ".sl" for HP-UX), so rename the library
+	# to its proper name (with version) after linking.
+	archive_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
 
+	hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
+	hardcode_libdir_separator_CXX=:
 
+	# Archives containing C++ object files must be created using
+	# the KAI C++ compiler.
+	old_archive_cmds_CXX='$CC -o $oldlib $oldobjs'
+	;;
+      RCC*)
+	# Rational C++ 2.4.1
+	# FIXME: insert proper C++ library support
+	ld_shlibs_CXX=no
+	;;
+      cxx*)
+	allow_undefined_flag_CXX=' -expect_unresolved \*'
+	archive_cmds_CXX='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_expsym_cmds_CXX='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done~
+	  echo "-hidden">> $lib.exp~
+	  $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname -Wl,-input -Wl,$lib.exp  `test -n "$verstring" && echo -set_version	$verstring` -update_registry ${output_objdir}/so_locations -o $lib~
+	  $rm $lib.exp'
+
+	hardcode_libdir_flag_spec_CXX='-rpath $libdir'
+	hardcode_libdir_separator_CXX=:
+
+	# Commands to make compiler produce verbose output that lists
+	# what "hidden" libraries, object files and flags are used when
+	# linking a shared library.
+	#
+	# There doesn't appear to be a way to prevent this compiler from
+	# explicitly linking system object files so we need to strip them
+	# from the output so that they don't get included in the library
+	# dependencies.
+	output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | grep "ld" | grep -v "ld:"`; templist=`echo $templist | $SED "s/\(^.*ld.*\)\( .*ld.*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; echo $list'
+	;;
+      *)
+	if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	  allow_undefined_flag_CXX=' ${wl}-expect_unresolved ${wl}\*'
+	 archive_cmds_CXX='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
 
+	  hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
+	  hardcode_libdir_separator_CXX=:
 
+	  # Commands to make compiler produce verbose output that lists
+	  # what "hidden" libraries, object files and flags are used when
+	  # linking a shared library.
+	  output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | grep "\-L"'
 
+	else
+	  # FIXME: insert proper C++ library support
+	  ld_shlibs_CXX=no
+	fi
+	;;
+    esac
+    ;;
+  psos*)
+    # FIXME: insert proper C++ library support
+    ld_shlibs_CXX=no
+    ;;
+  sunos4*)
+    case $cc_basename in
+      CC*)
+	# Sun C++ 4.x
+	# FIXME: insert proper C++ library support
+	ld_shlibs_CXX=no
+	;;
+      lcc*)
+	# Lucid
+	# FIXME: insert proper C++ library support
+	ld_shlibs_CXX=no
+	;;
+      *)
+	# FIXME: insert proper C++ library support
+	ld_shlibs_CXX=no
+	;;
+    esac
+    ;;
+  solaris*)
+    case $cc_basename in
+      CC*)
+	# Sun C++ 4.2, 5.x and Centerline C++
+        archive_cmds_need_lc_CXX=yes
+	no_undefined_flag_CXX=' -zdefs'
+	archive_cmds_CXX='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	archive_expsym_cmds_CXX='$echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~$echo "local: *; };" >> $lib.exp~
+	$CC -G${allow_undefined_flag}  ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$rm $lib.exp'
 
+	hardcode_libdir_flag_spec_CXX='-R$libdir'
+	hardcode_shlibpath_var_CXX=no
+	case $host_os in
+	  solaris2.[0-5] | solaris2.[0-5].*) ;;
+	  *)
+	    # The C++ compiler is used as linker so we must use $wl
+	    # flag to pass the commands to the underlying system
+	    # linker. We must also pass each convience library through
+	    # to the system linker between allextract/defaultextract.
+	    # The C++ compiler will combine linker options so we
+	    # cannot just pass the convience library names through
+	    # without $wl.
+	    # Supported since Solaris 2.6 (maybe 2.5.1?)
+	    whole_archive_flag_spec_CXX='${wl}-z ${wl}allextract`for conv in $convenience\"\"; do test -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $echo \"$new_convenience\"` ${wl}-z ${wl}defaultextract'
+	    ;;
+	esac
+	link_all_deplibs_CXX=yes
 
+	output_verbose_link_cmd='echo'
 
+	# Archives containing C++ object files must be created using
+	# "CC -xar", where "CC" is the Sun C++ compiler.  This is
+	# necessary to make sure instantiated templates are included
+	# in the archive.
+	old_archive_cmds_CXX='$CC -xar -o $oldlib $oldobjs'
+	;;
+      gcx*)
+	# Green Hills C++ Compiler
+	archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
 
+	# The C++ compiler must be used to create the archive.
+	old_archive_cmds_CXX='$CC $LDFLAGS -archive -o $oldlib $oldobjs'
+	;;
+      *)
+	# GNU C++ compiler with Solaris linker
+	if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	  no_undefined_flag_CXX=' ${wl}-z ${wl}defs'
+	  if $CC --version | grep -v '^2\.7' > /dev/null; then
+	    archive_cmds_CXX='$CC -shared -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	    archive_expsym_cmds_CXX='$echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~$echo "local: *; };" >> $lib.exp~
+		$CC -shared -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$rm $lib.exp'
 
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    output_verbose_link_cmd="$CC -shared $CFLAGS -v conftest.$objext 2>&1 | grep \"\-L\""
+	  else
+	    # g++ 2.7 appears to require `-G' NOT `-shared' on this
+	    # platform.
+	    archive_cmds_CXX='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	    archive_expsym_cmds_CXX='$echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~$echo "local: *; };" >> $lib.exp~
+		$CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$rm $lib.exp'
 
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    output_verbose_link_cmd="$CC -G $CFLAGS -v conftest.$objext 2>&1 | grep \"\-L\""
+	  fi
 
+	  hardcode_libdir_flag_spec_CXX='${wl}-R $wl$libdir'
+	fi
+	;;
+    esac
+    ;;
+  sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
+    no_undefined_flag_CXX='${wl}-z,text'
+    archive_cmds_need_lc_CXX=no
+    hardcode_shlibpath_var_CXX=no
+    runpath_var='LD_RUN_PATH'
+
+    case $cc_basename in
+      CC*)
+	archive_cmds_CXX='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds_CXX='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	;;
+      *)
+	archive_cmds_CXX='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds_CXX='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	;;
+    esac
+    ;;
+  sysv5* | sco3.2v5* | sco5v6*)
+    # Note: We can NOT use -z defs as we might desire, because we do not
+    # link with -lc, and that would cause any symbols used from libc to
+    # always be unresolved, which means just about no library would
+    # ever link correctly.  If we're not using GNU ld we use -z text
+    # though, which does catch some bad symbols but isn't as heavy-handed
+    # as -z defs.
+    # For security reasons, it is highly recommended that you always
+    # use absolute paths for naming shared libraries, and exclude the
+    # DT_RUNPATH tag from executables and libraries.  But doing so
+    # requires that you compile everything twice, which is a pain.
+    # So that behaviour is only enabled if SCOABSPATH is set to a
+    # non-empty value in the environment.  Most likely only useful for
+    # creating official distributions of packages.
+    # This is a hack until libtool officially supports absolute path
+    # names for shared libraries.
+    no_undefined_flag_CXX='${wl}-z,text'
+    allow_undefined_flag_CXX='${wl}-z,nodefs'
+    archive_cmds_need_lc_CXX=no
+    hardcode_shlibpath_var_CXX=no
+    hardcode_libdir_flag_spec_CXX='`test -z "$SCOABSPATH" && echo ${wl}-R,$libdir`'
+    hardcode_libdir_separator_CXX=':'
+    link_all_deplibs_CXX=yes
+    export_dynamic_flag_spec_CXX='${wl}-Bexport'
+    runpath_var='LD_RUN_PATH'
+
+    case $cc_basename in
+      CC*)
+	archive_cmds_CXX='$CC -G ${wl}-h,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds_CXX='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	;;
+      *)
+	archive_cmds_CXX='$CC -shared ${wl}-h,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds_CXX='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	;;
+    esac
+    ;;
+  tandem*)
+    case $cc_basename in
+      NCC*)
+	# NonStop-UX NCC 3.20
+	# FIXME: insert proper C++ library support
+	ld_shlibs_CXX=no
+	;;
+      *)
+	# FIXME: insert proper C++ library support
+	ld_shlibs_CXX=no
+	;;
+    esac
+    ;;
+  vxworks*)
+    # FIXME: insert proper C++ library support
+    ld_shlibs_CXX=no
+    ;;
+  *)
+    # FIXME: insert proper C++ library support
+    ld_shlibs_CXX=no
+    ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs_CXX" >&5
+$as_echo "$ld_shlibs_CXX" >&6; }
+test "$ld_shlibs_CXX" = no && can_build_shared=no
 
+GCC_CXX="$GXX"
+LD_CXX="$LD"
 
 
+cat > conftest.$ac_ext <<EOF
+class Foo
+{
+public:
+  Foo (void) { a = 0; }
+private:
+  int a;
+};
+EOF
 
+if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+  # Parse the compiler output and extract the necessary
+  # objects, libraries and library flags.
 
+  # Sentinel used to keep track of whether or not we are before
+  # the conftest object file.
+  pre_test_object_deps_done=no
 
+  # The `*' in the case matches for architectures that use `case' in
+  # $output_verbose_cmd can trigger glob expansion during the loop
+  # eval without this substitution.
+  output_verbose_link_cmd=`$echo "X$output_verbose_link_cmd" | $Xsed -e "$no_glob_subst"`
 
+  for p in `eval $output_verbose_link_cmd`; do
+    case $p in
 
+    -L* | -R* | -l*)
+       # Some compilers place space between "-{L,R}" and the path.
+       # Remove the space.
+       if test $p = "-L" \
+	  || test $p = "-R"; then
+	 prev=$p
+	 continue
+       else
+	 prev=
+       fi
 
+       if test "$pre_test_object_deps_done" = no; then
+	 case $p in
+	 -L* | -R*)
+	   # Internal compiler library paths should come after those
+	   # provided the user.  The postdeps already come after the
+	   # user supplied libs so there is no need to process them.
+	   if test -z "$compiler_lib_search_path_CXX"; then
+	     compiler_lib_search_path_CXX="${prev}${p}"
+	   else
+	     compiler_lib_search_path_CXX="${compiler_lib_search_path_CXX} ${prev}${p}"
+	   fi
+	   ;;
+	 # The "-l" case would never come before the object being
+	 # linked, so don't bother handling this case.
+	 esac
+       else
+	 if test -z "$postdeps_CXX"; then
+	   postdeps_CXX="${prev}${p}"
+	 else
+	   postdeps_CXX="${postdeps_CXX} ${prev}${p}"
+	 fi
+       fi
+       ;;
 
+    *.$objext)
+       # This assumes that the test object file only shows up
+       # once in the compiler output.
+       if test "$p" = "conftest.$objext"; then
+	 pre_test_object_deps_done=yes
+	 continue
+       fi
 
+       if test "$pre_test_object_deps_done" = no; then
+	 if test -z "$predep_objects_CXX"; then
+	   predep_objects_CXX="$p"
+	 else
+	   predep_objects_CXX="$predep_objects_CXX $p"
+	 fi
+       else
+	 if test -z "$postdep_objects_CXX"; then
+	   postdep_objects_CXX="$p"
+	 else
+	   postdep_objects_CXX="$postdep_objects_CXX $p"
+	 fi
+       fi
+       ;;
 
+    *) ;; # Ignore the rest.
 
+    esac
+  done
 
+  # Clean up.
+  rm -f a.out a.exe
+else
+  echo "libtool.m4: error: problem compiling CXX test program"
+fi
 
+$rm -f confest.$objext
 
+# PORTME: override above test on systems where it is broken
+case $host_os in
+interix3*)
+  # Interix 3.5 installs completely hosed .la files for C++, so rather than
+  # hack all around it, let's just trust "g++" to DTRT.
+  predep_objects_CXX=
+  postdep_objects_CXX=
+  postdeps_CXX=
+  ;;
 
+solaris*)
+  case $cc_basename in
+  CC*)
+    # Adding this requires a known-good setup of shared libraries for
+    # Sun compiler versions before 5.6, else PIC objects from an old
+    # archive will be linked into the output, leading to subtle bugs.
+    postdeps_CXX='-lCstd -lCrun'
+    ;;
+  esac
+  ;;
+esac
 
 
+case " $postdeps_CXX " in
+*" -lc "*) archive_cmds_need_lc_CXX=no ;;
+esac
 
+lt_prog_compiler_wl_CXX=
+lt_prog_compiler_pic_CXX=
+lt_prog_compiler_static_CXX=
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
+$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
-$as_echo_n "checking dynamic linker characteristics... " >&6; }
+  # C++ specific cases for pic, static, wl, etc.
+  if test "$GXX" = yes; then
+    lt_prog_compiler_wl_CXX='-Wl,'
+    lt_prog_compiler_static_CXX='-static'
 
-if test "$GCC" = yes; then
-  case $host_os in
-    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
-    *) lt_awk_arg="/^libraries:/" ;;
-  esac
-  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e "s,=/,/,g"`
-  if $ECHO "$lt_search_path_spec" | $GREP ';' >/dev/null ; then
-    # if the path contains ";" then we assume it to be the separator
-    # otherwise default to the standard path separator (i.e. ":") - it is
-    # assumed that no part of a normal pathname contains ";" but that should
-    # okay in the real world where ";" in dirpaths is itself problematic.
-    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED -e 's/;/ /g'`
-  else
-    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
-  fi
-  # Ok, now we have the path, separated by spaces, we can step through it
-  # and add multilib dir if necessary.
-  lt_tmp_lt_search_path_spec=
-  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
-  for lt_sys_path in $lt_search_path_spec; do
-    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
-      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
-    else
-      test -d "$lt_sys_path" && \
-	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
-    fi
-  done
-  lt_search_path_spec=`$ECHO $lt_tmp_lt_search_path_spec | awk '
-BEGIN {RS=" "; FS="/|\n";} {
-  lt_foo="";
-  lt_count=0;
-  for (lt_i = NF; lt_i > 0; lt_i--) {
-    if ($lt_i != "" && $lt_i != ".") {
-      if ($lt_i == "..") {
-        lt_count++;
-      } else {
-        if (lt_count == 0) {
-          lt_foo="/" $lt_i lt_foo;
-        } else {
-          lt_count--;
-        }
-      }
-    }
-  }
-  if (lt_foo != "") { lt_freq[lt_foo]++; }
-  if (lt_freq[lt_foo] == 1) { print lt_foo; }
-}'`
-  sys_lib_search_path_spec=`$ECHO $lt_search_path_spec`
-else
-  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
-fi
-library_names_spec=
-libname_spec='lib$name'
-soname_spec=
-shrext_cmds=".so"
-postinstall_cmds=
-postuninstall_cmds=
-finish_cmds=
-finish_eval=
-shlibpath_var=
-shlibpath_overrides_runpath=unknown
-version_type=none
-dynamic_linker="$host_os ld.so"
-sys_lib_dlsearch_path_spec="/lib /usr/lib"
-need_lib_prefix=unknown
-hardcode_into_libs=no
-
-# when you set need_version to no, make sure it does not cause -set_version
-# flags to be left without arguments
-need_version=unknown
-
-case $host_os in
-aix3*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
-  shlibpath_var=LIBPATH
-
-  # AIX 3 has no versioning support, so we append a major version to the name.
-  soname_spec='${libname}${release}${shared_ext}$major'
-  ;;
-
-aix[4-9]*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  hardcode_into_libs=yes
-  if test "$host_cpu" = ia64; then
-    # AIX 5 supports IA64
-    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
-    shlibpath_var=LD_LIBRARY_PATH
-  else
-    # With GCC up to 2.95.x, collect2 would create an import file
-    # for dependence libraries.  The import file would start with
-    # the line `#! .'.  This would cause the generated library to
-    # depend on `.', always an invalid library.  This was fixed in
-    # development snapshots of GCC prior to 3.0.
     case $host_os in
-      aix4 | aix4.[01] | aix4.[01].*)
-      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
-	   echo ' yes '
-	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
-	:
-      else
-	can_build_shared=no
+    aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static_CXX='-Bstatic'
       fi
       ;;
-    esac
-    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
-    # soname into executable. Probably we can add versioning support to
-    # collect2, so additional links can be useful in future.
-    if test "$aix_use_runtimelinking" = yes; then
-      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
-      # instead of lib<name>.a to let people know that these are not
-      # typical AIX shared libraries.
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    else
-      # We preserve .a as extension for shared libraries through AIX4.2
-      # and later when we are not doing run time linking.
-      library_names_spec='${libname}${release}.a $libname.a'
-      soname_spec='${libname}${release}${shared_ext}$major'
-    fi
-    shlibpath_var=LIBPATH
-  fi
-  ;;
-
-amigaos*)
-  case $host_cpu in
-  powerpc)
-    # Since July 2007 AmigaOS4 officially supports .so libraries.
-    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    ;;
-  m68k)
-    library_names_spec='$libname.ixlibrary $libname.a'
-    # Create ${libname}_ixlibrary.a entries in /sys/libs.
-    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$ECHO "X$lib" | $Xsed -e '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
-    ;;
-  esac
-  ;;
-
-beos*)
-  library_names_spec='${libname}${shared_ext}'
-  dynamic_linker="$host_os ld.so"
-  shlibpath_var=LIBRARY_PATH
-  ;;
-
-bsdi[45]*)
-  version_type=linux
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
-  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
-  # the default ld.so.conf also contains /usr/contrib/lib and
-  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
-  # libtool to hard-code these into programs
-  ;;
-
-cygwin* | mingw* | pw32* | cegcc*)
-  version_type=windows
-  shrext_cmds=".dll"
-  need_version=no
-  need_lib_prefix=no
-
-  case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
-    library_names_spec='$libname.dll.a'
-    # DLL is installed to $(libdir)/../bin by postinstall_cmds
-    postinstall_cmds='base_file=`basename \${file}`~
-      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
-      dldir=$destdir/`dirname \$dlpath`~
-      test -d \$dldir || mkdir -p \$dldir~
-      $install_prog $dir/$dlname \$dldir/$dlname~
-      chmod a+x \$dldir/$dlname~
-      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
-        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
-      fi'
-    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
-      dlpath=$dir/\$dldll~
-       $RM \$dlpath'
-    shlibpath_overrides_runpath=yes
-
-    case $host_os in
-    cygwin*)
-      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
-      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-      sys_lib_search_path_spec="/usr/lib /lib/w32api /lib /usr/local/lib"
+    amigaos*)
+      # FIXME: we need at least 68020 code to build shared libraries, but
+      # adding the `-m68020' flag to GCC prevents building anything better,
+      # like `-m68040'.
+      lt_prog_compiler_pic_CXX='-m68020 -resident32 -malways-restore-a4'
       ;;
-    mingw* | cegcc*)
-      # MinGW DLLs use traditional 'lib' prefix
-      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-      sys_lib_search_path_spec=`$CC -print-search-dirs | $GREP "^libraries:" | $SED -e "s/^libraries://" -e "s,=/,/,g"`
-      if $ECHO "$sys_lib_search_path_spec" | $GREP ';[c-zC-Z]:/' >/dev/null; then
-        # It is most probably a Windows format PATH printed by
-        # mingw gcc, but we are running on Cygwin. Gcc prints its search
-        # path with ; separators, and with drive letters. We can handle the
-        # drive letters (cygwin fileutils understands them), so leave them,
-        # especially as we might pass files found there to a mingw objdump,
-        # which wouldn't understand a cygwinified path. Ahh.
-        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
-      else
-        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+    beos* | cygwin* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+    mingw* | os2* | pw32*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_prog_compiler_pic_CXX='-DDLL_EXPORT'
+      ;;
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      lt_prog_compiler_pic_CXX='-fno-common'
+      ;;
+    *djgpp*)
+      # DJGPP does not support shared libraries at all
+      lt_prog_compiler_pic_CXX=
+      ;;
+    interix3*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	lt_prog_compiler_pic_CXX=-Kconform_pic
       fi
       ;;
-    pw32*)
-      # pw32 DLLs use 'pw' prefix rather than 'lib'
-      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+    hpux*)
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	;;
+      *)
+	lt_prog_compiler_pic_CXX='-fPIC'
+	;;
+      esac
+      ;;
+    *)
+      lt_prog_compiler_pic_CXX='-fPIC'
       ;;
     esac
-    ;;
-
-  *)
-    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
-    ;;
-  esac
-  dynamic_linker='Win32 ld.exe'
-  # FIXME: first we should search . and the directory the executable is in
-  shlibpath_var=PATH
-  ;;
-
-darwin* | rhapsody*)
-  dynamic_linker="$host_os dyld"
-  version_type=darwin
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
-  soname_spec='${libname}${release}${major}$shared_ext'
-  shlibpath_overrides_runpath=yes
-  shlibpath_var=DYLD_LIBRARY_PATH
-  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
-
-  sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/local/lib"
-  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
-  ;;
-
-dgux*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  ;;
-
-freebsd1*)
-  dynamic_linker=no
-  ;;
-
-freebsd* | dragonfly*)
-  # DragonFly does not have aout.  When/if they implement a new
-  # versioning mechanism, adjust this.
-  if test -x /usr/bin/objformat; then
-    objformat=`/usr/bin/objformat`
   else
     case $host_os in
-    freebsd[123]*) objformat=aout ;;
-    *) objformat=elf ;;
-    esac
-  fi
-  version_type=freebsd-$objformat
-  case $version_type in
-    freebsd-elf*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
-      need_version=no
-      need_lib_prefix=no
-      ;;
-    freebsd-*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
-      need_version=yes
-      ;;
-  esac
-  shlibpath_var=LD_LIBRARY_PATH
-  case $host_os in
-  freebsd2*)
-    shlibpath_overrides_runpath=yes
-    ;;
-  freebsd3.[01]* | freebsdelf3.[01]*)
-    shlibpath_overrides_runpath=yes
-    hardcode_into_libs=yes
-    ;;
-  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
-  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
-    shlibpath_overrides_runpath=no
-    hardcode_into_libs=yes
-    ;;
-  *) # from 4.6 on, and DragonFly
-    shlibpath_overrides_runpath=yes
-    hardcode_into_libs=yes
-    ;;
-  esac
-  ;;
-
-gnu*)
+      aix4* | aix5*)
+	# All AIX code is PIC.
+	if test "$host_cpu" = ia64; then
+	  # AIX 5 now supports IA64 processor
+	  lt_prog_compiler_static_CXX='-Bstatic'
+	else
+	  lt_prog_compiler_static_CXX='-bnso -bI:/lib/syscalls.exp'
+	fi
+	;;
+      chorus*)
+	case $cc_basename in
+	cxch68*)
+	  # Green Hills C++ Compiler
+	  # _LT_AC_TAGVAR(lt_prog_compiler_static, CXX)="--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a"
+	  ;;
+	esac
+	;;
+       darwin*)
+         # PIC is the default on this platform
+         # Common symbols not allowed in MH_DYLIB files
+         case $cc_basename in
+           xlc*)
+           lt_prog_compiler_pic_CXX='-qnocommon'
+           lt_prog_compiler_wl_CXX='-Wl,'
+           ;;
+         esac
+       ;;
+      dgux*)
+	case $cc_basename in
+	  ec++*)
+	    lt_prog_compiler_pic_CXX='-KPIC'
+	    ;;
+	  ghcx*)
+	    # Green Hills C++ Compiler
+	    lt_prog_compiler_pic_CXX='-pic'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      freebsd* | kfreebsd*-gnu | dragonfly*)
+	# FreeBSD uses GNU C++
+	;;
+      hpux9* | hpux10* | hpux11*)
+	case $cc_basename in
+	  CC*)
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_static_CXX='${wl}-a ${wl}archive'
+	    if test "$host_cpu" != ia64; then
+	      lt_prog_compiler_pic_CXX='+Z'
+	    fi
+	    ;;
+	  aCC*)
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_static_CXX='${wl}-a ${wl}archive'
+	    case $host_cpu in
+	    hppa*64*|ia64*)
+	      # +Z the default
+	      ;;
+	    *)
+	      lt_prog_compiler_pic_CXX='+Z'
+	      ;;
+	    esac
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      interix*)
+	# This is c89, which is MS Visual C++ (no shared libs)
+	# Anyone wants to do a port?
+	;;
+      irix5* | irix6* | nonstopux*)
+	case $cc_basename in
+	  CC*)
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_static_CXX='-non_shared'
+	    # CC pic flag -KPIC is the default.
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      linux*)
+	case $cc_basename in
+	  KCC*)
+	    # KAI C++ Compiler
+	    lt_prog_compiler_wl_CXX='--backend -Wl,'
+	    lt_prog_compiler_pic_CXX='-fPIC'
+	    ;;
+	  icpc* | ecpc*)
+	    # Intel C++
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_pic_CXX='-KPIC'
+	    lt_prog_compiler_static_CXX='-static'
+	    ;;
+	  pgCC*)
+	    # Portland Group C++ compiler.
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_pic_CXX='-fpic'
+	    lt_prog_compiler_static_CXX='-Bstatic'
+	    ;;
+	  cxx*)
+	    # Compaq C++
+	    # Make sure the PIC flag is empty.  It appears that all Alpha
+	    # Linux and Compaq Tru64 Unix objects are PIC.
+	    lt_prog_compiler_pic_CXX=
+	    lt_prog_compiler_static_CXX='-non_shared'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      lynxos*)
+	;;
+      m88k*)
+	;;
+      mvs*)
+	case $cc_basename in
+	  cxx*)
+	    lt_prog_compiler_pic_CXX='-W c,exportall'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      netbsd*)
+	;;
+      osf3* | osf4* | osf5*)
+	case $cc_basename in
+	  KCC*)
+	    lt_prog_compiler_wl_CXX='--backend -Wl,'
+	    ;;
+	  RCC*)
+	    # Rational C++ 2.4.1
+	    lt_prog_compiler_pic_CXX='-pic'
+	    ;;
+	  cxx*)
+	    # Digital/Compaq C++
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    # Make sure the PIC flag is empty.  It appears that all Alpha
+	    # Linux and Compaq Tru64 Unix objects are PIC.
+	    lt_prog_compiler_pic_CXX=
+	    lt_prog_compiler_static_CXX='-non_shared'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      psos*)
+	;;
+      solaris*)
+	case $cc_basename in
+	  CC*)
+	    # Sun C++ 4.2, 5.x and Centerline C++
+	    lt_prog_compiler_pic_CXX='-KPIC'
+	    lt_prog_compiler_static_CXX='-Bstatic'
+	    lt_prog_compiler_wl_CXX='-Qoption ld '
+	    ;;
+	  gcx*)
+	    # Green Hills C++ Compiler
+	    lt_prog_compiler_pic_CXX='-PIC'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      sunos4*)
+	case $cc_basename in
+	  CC*)
+	    # Sun C++ 4.x
+	    lt_prog_compiler_pic_CXX='-pic'
+	    lt_prog_compiler_static_CXX='-Bstatic'
+	    ;;
+	  lcc*)
+	    # Lucid
+	    lt_prog_compiler_pic_CXX='-pic'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      tandem*)
+	case $cc_basename in
+	  NCC*)
+	    # NonStop-UX NCC 3.20
+	    lt_prog_compiler_pic_CXX='-KPIC'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+	case $cc_basename in
+	  CC*)
+	    lt_prog_compiler_wl_CXX='-Wl,'
+	    lt_prog_compiler_pic_CXX='-KPIC'
+	    lt_prog_compiler_static_CXX='-Bstatic'
+	    ;;
+	esac
+	;;
+      vxworks*)
+	;;
+      *)
+	lt_prog_compiler_can_build_shared_CXX=no
+	;;
+    esac
+  fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic_CXX" >&5
+$as_echo "$lt_prog_compiler_pic_CXX" >&6; }
+
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$lt_prog_compiler_pic_CXX"; then
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic_CXX works" >&5
+$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic_CXX works... " >&6; }
+if test "${lt_prog_compiler_pic_works_CXX+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_prog_compiler_pic_works_CXX=no
+  ac_outfile=conftest.$ac_objext
+   printf "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$lt_prog_compiler_pic_CXX -DPIC"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:11900: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:11904: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_prog_compiler_pic_works_CXX=yes
+     fi
+   fi
+   $rm conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic_works_CXX" >&5
+$as_echo "$lt_prog_compiler_pic_works_CXX" >&6; }
+
+if test x"$lt_prog_compiler_pic_works_CXX" = xyes; then
+    case $lt_prog_compiler_pic_CXX in
+     "" | " "*) ;;
+     *) lt_prog_compiler_pic_CXX=" $lt_prog_compiler_pic_CXX" ;;
+     esac
+else
+    lt_prog_compiler_pic_CXX=
+     lt_prog_compiler_can_build_shared_CXX=no
+fi
+
+fi
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    lt_prog_compiler_pic_CXX=
+    ;;
+  *)
+    lt_prog_compiler_pic_CXX="$lt_prog_compiler_pic_CXX -DPIC"
+    ;;
+esac
+
+#
+# Check to make sure the static flag actually works.
+#
+wl=$lt_prog_compiler_wl_CXX eval lt_tmp_static_flag=\"$lt_prog_compiler_static_CXX\"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
+$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
+if test "${lt_prog_compiler_static_works_CXX+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_prog_compiler_static_works_CXX=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
+   printf "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&5
+       $echo "X$_lt_linker_boilerplate" | $Xsed -e '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         lt_prog_compiler_static_works_CXX=yes
+       fi
+     else
+       lt_prog_compiler_static_works_CXX=yes
+     fi
+   fi
+   $rm conftest*
+   LDFLAGS="$save_LDFLAGS"
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_static_works_CXX" >&5
+$as_echo "$lt_prog_compiler_static_works_CXX" >&6; }
+
+if test x"$lt_prog_compiler_static_works_CXX" = xyes; then
+    :
+else
+    lt_prog_compiler_static_CXX=
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o_CXX+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o_CXX=no
+   $rm -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   printf "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:12004: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:12008: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o_CXX=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $rm conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $rm out/ii_files/* && rmdir out/ii_files
+   $rm out/* && rmdir out
+   cd ..
+   rmdir conftest
+   $rm conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o_CXX" >&5
+$as_echo "$lt_cv_prog_compiler_c_o_CXX" >&6; }
+
+
+hard_links="nottested"
+if test "$lt_cv_prog_compiler_c_o_CXX" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
+$as_echo_n "checking if we can lock with hard links... " >&6; }
+  hard_links=yes
+  $rm conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
+$as_echo "$hard_links" >&6; }
+  if test "$hard_links" = no; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
+$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
+
+  export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  case $host_os in
+  aix4* | aix5*)
+    # If we're using GNU nm, then we don't want the "-C" option.
+    # -C means demangle to AIX nm, but means don't demangle with GNU nm
+    if $NM -V 2>&1 | grep 'GNU' > /dev/null; then
+      export_symbols_cmds_CXX='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$2 == "T") || (\$2 == "D") || (\$2 == "B")) && (substr(\$3,1,1) != ".")) { print \$3 } }'\'' | sort -u > $export_symbols'
+    else
+      export_symbols_cmds_CXX='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$2 == "T") || (\$2 == "D") || (\$2 == "B")) && (substr(\$3,1,1) != ".")) { print \$3 } }'\'' | sort -u > $export_symbols'
+    fi
+    ;;
+  pw32*)
+    export_symbols_cmds_CXX="$ltdll_cmds"
+  ;;
+  cygwin* | mingw*)
+    export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS] /s/.* \([^ ]*\)/\1 DATA/;/^.* __nm__/s/^.* __nm__\([^ ]*\) [^ ]*/\1 DATA/;/^I /d;/^[AITW] /s/.* //'\'' | sort | uniq > $export_symbols'
+  ;;
+  *)
+    export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  ;;
+  esac
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs_CXX" >&5
+$as_echo "$ld_shlibs_CXX" >&6; }
+test "$ld_shlibs_CXX" = no && can_build_shared=no
+
+#
+# Do we need to explicitly link libc?
+#
+case "x$archive_cmds_need_lc_CXX" in
+x|xyes)
+  # Assume -lc should be added
+  archive_cmds_need_lc_CXX=yes
+
+  if test "$enable_shared" = yes && test "$GCC" = yes; then
+    case $archive_cmds_CXX in
+    *'~'*)
+      # FIXME: we may have to deal with multi-command sequences.
+      ;;
+    '$CC '*)
+      # Test whether the compiler implicitly links with -lc since on some
+      # systems, -lgcc has to come before -lc. If gcc already passes -lc
+      # to ld, don't add -lc before -lgcc.
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
+$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
+      $rm conftest*
+      printf "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+      if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } 2>conftest.err; then
+        soname=conftest
+        lib=conftest
+        libobjs=conftest.$ac_objext
+        deplibs=
+        wl=$lt_prog_compiler_wl_CXX
+	pic_flag=$lt_prog_compiler_pic_CXX
+        compiler_flags=-v
+        linker_flags=-v
+        verstring=
+        output_objdir=.
+        libname=conftest
+        lt_save_allow_undefined_flag=$allow_undefined_flag_CXX
+        allow_undefined_flag_CXX=
+        if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds_CXX 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1\""; } >&5
+  (eval $archive_cmds_CXX 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+        then
+	  archive_cmds_need_lc_CXX=no
+        else
+	  archive_cmds_need_lc_CXX=yes
+        fi
+        allow_undefined_flag_CXX=$lt_save_allow_undefined_flag
+      else
+        cat conftest.err 1>&5
+      fi
+      $rm conftest*
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $archive_cmds_need_lc_CXX" >&5
+$as_echo "$archive_cmds_need_lc_CXX" >&6; }
+      ;;
+    esac
+  fi
+  ;;
+esac
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
+$as_echo_n "checking dynamic linker characteristics... " >&6; }
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+shrext_cmds=".so"
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+if test "$GCC" = yes; then
+  sys_lib_search_path_spec=`$CC -print-search-dirs | grep "^libraries:" | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+  if echo "$sys_lib_search_path_spec" | grep ';' >/dev/null ; then
+    # if the path contains ";" then we assume it to be the separator
+    # otherwise default to the standard path separator (i.e. ":") - it is
+    # assumed that no part of a normal pathname contains ";" but that should
+    # okay in the real world where ";" in dirpaths is itself problematic.
+    sys_lib_search_path_spec=`echo "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
+  else
+    sys_lib_search_path_spec=`echo "$sys_lib_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+  fi
+else
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+fi
+need_lib_prefix=unknown
+hardcode_into_libs=no
+
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+need_version=unknown
+
+case $host_os in
+aix3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  shlibpath_var=LIBPATH
+
+  # AIX 3 has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}${shared_ext}$major'
+  ;;
+
+aix4* | aix5*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[01] | aix4.[01].*)
+      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	   echo ' yes '
+	   echo '#endif'; } | ${CC} -E - | grep yes > /dev/null; then
+	:
+      else
+	can_build_shared=no
+      fi
+      ;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # soname into executable. Probably we can add versioning support to
+    # collect2, so additional links can be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}${shared_ext}$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  ;;
+
+amigaos*)
+  library_names_spec='$libname.ixlibrary $libname.a'
+  # Create ${libname}_ixlibrary.a entries in /sys/libs.
+  finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$echo "X$lib" | $Xsed -e '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $rm /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+  ;;
+
+beos*)
+  library_names_spec='${libname}${shared_ext}'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
+
+bsdi[45]*)
+  version_type=linux
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
+
+cygwin* | mingw* | pw32*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+
+  case $GCC,$host_os in
+  yes,cygwin* | yes,mingw* | yes,pw32*)
+    library_names_spec='$libname.dll.a'
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i;echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname~
+      chmod a+x \$dldir/$dlname'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $rm \$dlpath'
+    shlibpath_overrides_runpath=yes
+
+    case $host_os in
+    cygwin*)
+      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
+      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      sys_lib_search_path_spec="/usr/lib /lib/w32api /lib /usr/local/lib"
+      ;;
+    mingw*)
+      # MinGW DLLs use traditional 'lib' prefix
+      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      sys_lib_search_path_spec=`$CC -print-search-dirs | grep "^libraries:" | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+      if echo "$sys_lib_search_path_spec" | grep ';[c-zC-Z]:/' >/dev/null; then
+        # It is most probably a Windows format PATH printed by
+        # mingw gcc, but we are running on Cygwin. Gcc prints its search
+        # path with ; separators, and with drive letters. We can handle the
+        # drive letters (cygwin fileutils understands them), so leave them,
+        # especially as we might pass files found there to a mingw objdump,
+        # which wouldn't understand a cygwinified path. Ahh.
+        sys_lib_search_path_spec=`echo "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
+      else
+        sys_lib_search_path_spec=`echo "$sys_lib_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+      fi
+      ;;
+    pw32*)
+      # pw32 DLLs use 'pw' prefix rather than 'lib'
+      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    esac
+    ;;
+
+  *)
+    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    ;;
+  esac
+  dynamic_linker='Win32 ld.exe'
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
+
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${versuffix}$shared_ext ${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  soname_spec='${libname}${release}${major}$shared_ext'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
+  # Apple's gcc prints 'gcc -print-search-dirs' doesn't operate the same.
+  if test "$GCC" = yes; then
+    sys_lib_search_path_spec=`$CC -print-search-dirs | tr "\n" "$PATH_SEPARATOR" | sed -e 's/libraries:/@libraries:/' | tr "@" "\n" | grep "^libraries:" | sed -e "s/^libraries://" -e "s,=/,/,g" -e "s,$PATH_SEPARATOR, ,g" -e "s,.*,& /lib /usr/lib /usr/local/lib,g"`
+  else
+    sys_lib_search_path_spec='/lib /usr/lib /usr/local/lib'
+  fi
+  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
+  ;;
+
+dgux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+freebsd1*)
+  dynamic_linker=no
+  ;;
+
+kfreebsd*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='GNU ld.so'
+  ;;
+
+freebsd* | dragonfly*)
+  # DragonFly does not have aout.  When/if they implement a new
+  # versioning mechanism, adjust this.
+  if test -x /usr/bin/objformat; then
+    objformat=`/usr/bin/objformat`
+  else
+    case $host_os in
+    freebsd[123]*) objformat=aout ;;
+    *) objformat=elf ;;
+    esac
+  fi
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  freebsd3.[01]* | freebsdelf3.[01]*)
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
+  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  freebsd*) # from 4.6 on
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
+
+gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  ;;
+
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  case $host_cpu in
+  ia64*)
+    shrext_cmds='.so'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.so"
+    shlibpath_var=LD_LIBRARY_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    if test "X$HPUX_IA64_MODE" = X32; then
+      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+    else
+      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    fi
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+   hppa*64*)
+     shrext_cmds='.sl'
+     hardcode_into_libs=yes
+     dynamic_linker="$host_os dld.sl"
+     shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+     shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+     library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+     soname_spec='${libname}${release}${shared_ext}$major'
+     sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+     sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+     ;;
+   *)
+    shrext_cmds='.sl'
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=SHLIB_PATH
+    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    ;;
+  esac
+  # HP-UX runs *really* slowly unless shared libraries are mode 555.
+  postinstall_cmds='chmod 555 $lib'
+  ;;
+
+interix3*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)
+	if test "$lt_cv_prog_gnu_ld" = yes; then
+		version_type=linux
+	else
+		version_type=irix
+	fi ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
+      libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
+      libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
+      libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  hardcode_into_libs=yes
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux*oldld* | linux*aout* | linux*coff*)
+  dynamic_linker=no
+  ;;
+
+# This must be Linux ELF.
+linux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  # find out which ABI we are using
+  libsuff=
+  case "$host_cpu" in
+  x86_64*|s390x*|powerpc64*)
+    echo '#line 12540 "configure"' > conftest.$ac_ext
+    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+      case `/usr/bin/file conftest.$ac_objext` in
+      *64-bit*)
+        libsuff=64
+        sys_lib_search_path_spec="/lib${libsuff} /usr/lib${libsuff} /usr/local/lib${libsuff}"
+        ;;
+      esac
+    fi
+    rm -rf conftest*
+    ;;
+  esac
+
+  # Append ld.so.conf contents to the search path
+  if test -f /etc/ld.so.conf; then
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib${libsuff} /usr/lib${libsuff} $lt_ld_extra"
+  fi
+
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
+
+knetbsd*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='GNU ld.so'
+  ;;
+
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
+
+newsos6)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
+
+nto-qnx*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
+
+openbsd*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec="/usr/lib"
+  need_lib_prefix=no
+  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
+  case $host_os in
+    openbsd3.3 | openbsd3.3.*) need_version=yes ;;
+    *)                         need_version=no  ;;
+  esac
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case $host_os in
+      openbsd2.[89] | openbsd2.[89].*)
+	shlibpath_overrides_runpath=no
+	;;
+      *)
+	shlibpath_overrides_runpath=yes
+	;;
+      esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  ;;
+
+os2*)
+  libname_spec='$name'
+  shrext_cmds=".dll"
+  need_lib_prefix=no
+  library_names_spec='$libname${shared_ext} $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
+
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  ;;
+
+solaris*)
   version_type=linux
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
+
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
+
+sysv4 | sysv4.3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      export_dynamic_flag_spec='${wl}-Blargedynsym'
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
+
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux
+    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
+    soname_spec='$libname${shared_ext}.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  version_type=freebsd-elf
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
   soname_spec='${libname}${release}${shared_ext}$major'
   shlibpath_var=LD_LIBRARY_PATH
   hardcode_into_libs=yes
+  if test "$with_gnu_ld" = yes; then
+    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+    shlibpath_overrides_runpath=no
+  else
+    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    shlibpath_overrides_runpath=yes
+    case $host_os in
+      sco3.2v5*)
+        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
+	;;
+    esac
+  fi
+  sys_lib_dlsearch_path_spec='/usr/lib'
+  ;;
+
+uts4*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+*)
+  dynamic_linker=no
   ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
+$as_echo "$dynamic_linker" >&6; }
+test "$dynamic_linker" = no && can_build_shared=no
+
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
+$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
+hardcode_action_CXX=
+if test -n "$hardcode_libdir_flag_spec_CXX" || \
+   test -n "$runpath_var_CXX" || \
+   test "X$hardcode_automatic_CXX" = "Xyes" ; then
+
+  # We can hardcode non-existant directories.
+  if test "$hardcode_direct_CXX" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$_LT_AC_TAGVAR(hardcode_shlibpath_var, CXX)" != no &&
+     test "$hardcode_minus_L_CXX" != no; then
+    # Linking always hardcodes the temporary library directory.
+    hardcode_action_CXX=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    hardcode_action_CXX=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  hardcode_action_CXX=unsupported
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action_CXX" >&5
+$as_echo "$hardcode_action_CXX" >&6; }
+
+if test "$hardcode_action_CXX" = relink; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
+
+
+# The else clause should only fire when bootstrapping the
+# libtool distribution, otherwise you forgot to ship ltmain.sh
+# with your package, and you will get complaints that there are
+# no rules to generate ltmain.sh.
+if test -f "$ltmain"; then
+  # See if we are running on zsh, and set the options which allow our commands through
+  # without removal of \ escapes.
+  if test -n "${ZSH_VERSION+set}" ; then
+    setopt NO_GLOB_SUBST
+  fi
+  # Now quote all the things that may contain metacharacters while being
+  # careful not to overquote the AC_SUBSTed values.  We take copies of the
+  # variables and quote the copies for generation of the libtool script.
+  for var in echo old_CC old_CFLAGS AR AR_FLAGS EGREP RANLIB LN_S LTCC LTCFLAGS NM \
+    SED SHELL STRIP \
+    libname_spec library_names_spec soname_spec extract_expsyms_cmds \
+    old_striplib striplib file_magic_cmd finish_cmds finish_eval \
+    deplibs_check_method reload_flag reload_cmds need_locks \
+    lt_cv_sys_global_symbol_pipe lt_cv_sys_global_symbol_to_cdecl \
+    lt_cv_sys_global_symbol_to_c_name_address \
+    sys_lib_search_path_spec sys_lib_dlsearch_path_spec \
+    old_postinstall_cmds old_postuninstall_cmds \
+    compiler_CXX \
+    CC_CXX \
+    LD_CXX \
+    lt_prog_compiler_wl_CXX \
+    lt_prog_compiler_pic_CXX \
+    lt_prog_compiler_static_CXX \
+    lt_prog_compiler_no_builtin_flag_CXX \
+    export_dynamic_flag_spec_CXX \
+    thread_safe_flag_spec_CXX \
+    whole_archive_flag_spec_CXX \
+    enable_shared_with_static_runtimes_CXX \
+    old_archive_cmds_CXX \
+    old_archive_from_new_cmds_CXX \
+    predep_objects_CXX \
+    postdep_objects_CXX \
+    predeps_CXX \
+    postdeps_CXX \
+    compiler_lib_search_path_CXX \
+    archive_cmds_CXX \
+    archive_expsym_cmds_CXX \
+    postinstall_cmds_CXX \
+    postuninstall_cmds_CXX \
+    old_archive_from_expsyms_cmds_CXX \
+    allow_undefined_flag_CXX \
+    no_undefined_flag_CXX \
+    export_symbols_cmds_CXX \
+    hardcode_libdir_flag_spec_CXX \
+    hardcode_libdir_flag_spec_ld_CXX \
+    hardcode_libdir_separator_CXX \
+    hardcode_automatic_CXX \
+    module_cmds_CXX \
+    module_expsym_cmds_CXX \
+    lt_cv_prog_compiler_c_o_CXX \
+    exclude_expsyms_CXX \
+    include_expsyms_CXX; do
+
+    case $var in
+    old_archive_cmds_CXX | \
+    old_archive_from_new_cmds_CXX | \
+    archive_cmds_CXX | \
+    archive_expsym_cmds_CXX | \
+    module_cmds_CXX | \
+    module_expsym_cmds_CXX | \
+    old_archive_from_expsyms_cmds_CXX | \
+    export_symbols_cmds_CXX | \
+    extract_expsyms_cmds | reload_cmds | finish_cmds | \
+    postinstall_cmds | postuninstall_cmds | \
+    old_postinstall_cmds | old_postuninstall_cmds | \
+    sys_lib_search_path_spec | sys_lib_dlsearch_path_spec)
+      # Double-quote double-evaled strings.
+      eval "lt_$var=\\\"\`\$echo \"X\$$var\" | \$Xsed -e \"\$double_quote_subst\" -e \"\$sed_quote_subst\" -e \"\$delay_variable_subst\"\`\\\""
+      ;;
+    *)
+      eval "lt_$var=\\\"\`\$echo \"X\$$var\" | \$Xsed -e \"\$sed_quote_subst\"\`\\\""
+      ;;
+    esac
+  done
+
+  case $lt_echo in
+  *'\$0 --fallback-echo"')
+    lt_echo=`$echo "X$lt_echo" | $Xsed -e 's/\\\\\\\$0 --fallback-echo"$/$0 --fallback-echo"/'`
+    ;;
+  esac
+
+cfgfile="$ofile"
+
+  cat <<__EOF__ >> "$cfgfile"
+# ### BEGIN LIBTOOL TAG CONFIG: $tagname
+
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+
+# Shell to use when invoking shell scripts.
+SHELL=$lt_SHELL
+
+# Whether or not to build shared libraries.
+build_libtool_libs=$enable_shared
+
+# Whether or not to build static libraries.
+build_old_libs=$enable_static
+
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=$archive_cmds_need_lc_CXX
+
+# Whether or not to disallow shared libs when runtime libs are static
+allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes_CXX
+
+# Whether or not to optimize for fast installation.
+fast_install=$enable_fast_install
+
+# The host system.
+host_alias=$host_alias
+host=$host
+host_os=$host_os
+
+# The build system.
+build_alias=$build_alias
+build=$build
+build_os=$build_os
+
+# An echo program that does not interpret backslashes.
+echo=$lt_echo
+
+# The archiver.
+AR=$lt_AR
+AR_FLAGS=$lt_AR_FLAGS
+
+# A C compiler.
+LTCC=$lt_LTCC
+
+# LTCC compiler flags.
+LTCFLAGS=$lt_LTCFLAGS
+
+# A language-specific compiler.
+CC=$lt_compiler_CXX
+
+# Is the compiler the GNU C compiler?
+with_gcc=$GCC_CXX
+
+gcc_dir=\`gcc -print-file-name=. | $SED 's,/\.$,,'\`
+gcc_ver=\`gcc -dumpversion\`
+
+# An ERE matcher.
+EGREP=$lt_EGREP
+
+# The linker used to build libraries.
+LD=$lt_LD_CXX
+
+# Whether we need hard or soft links.
+LN_S=$lt_LN_S
+
+# A BSD-compatible nm program.
+NM=$lt_NM
+
+# A symbol stripping program
+STRIP=$lt_STRIP
+
+# Used to examine libraries when file_magic_cmd begins "file"
+MAGIC_CMD=$MAGIC_CMD
+
+# Used on cygwin: DLL creation program.
+DLLTOOL="$DLLTOOL"
+
+# Used on cygwin: object dumper.
+OBJDUMP="$OBJDUMP"
+
+# Used on cygwin: assembler.
+AS="$AS"
+
+# The name of the directory that contains temporary libtool files.
+objdir=$objdir
+
+# How to create reloadable object files.
+reload_flag=$lt_reload_flag
+reload_cmds=$lt_reload_cmds
+
+# How to pass a linker flag through the compiler.
+wl=$lt_lt_prog_compiler_wl_CXX
+
+# Object file suffix (normally "o").
+objext="$ac_objext"
+
+# Old archive suffix (normally "a").
+libext="$libext"
+
+# Shared library suffix (normally ".so").
+shrext_cmds='$shrext_cmds'
+
+# Executable file suffix (normally "").
+exeext="$exeext"
+
+# Additional compiler flags for building library objects.
+pic_flag=$lt_lt_prog_compiler_pic_CXX
+pic_mode=$pic_mode
+
+# What is the maximum length of a command?
+max_cmd_len=$lt_cv_sys_max_cmd_len
 
-hpux9* | hpux10* | hpux11*)
-  # Give a soname corresponding to the major version so that dld.sl refuses to
-  # link against other versions.
-  version_type=sunos
-  need_lib_prefix=no
-  need_version=no
-  case $host_cpu in
-  ia64*)
-    shrext_cmds='.so'
-    hardcode_into_libs=yes
-    dynamic_linker="$host_os dld.so"
-    shlibpath_var=LD_LIBRARY_PATH
-    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    if test "X$HPUX_IA64_MODE" = X32; then
-      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
-    else
-      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
-    fi
-    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
-    ;;
-  hppa*64*)
-    shrext_cmds='.sl'
-    hardcode_into_libs=yes
-    dynamic_linker="$host_os dld.sl"
-    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
-    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
-    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
-    ;;
-  *)
-    shrext_cmds='.sl'
-    dynamic_linker="$host_os dld.sl"
-    shlibpath_var=SHLIB_PATH
-    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    ;;
-  esac
-  # HP-UX runs *really* slowly unless shared libraries are mode 555.
-  postinstall_cmds='chmod 555 $lib'
-  ;;
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o=$lt_lt_cv_prog_compiler_c_o_CXX
 
-interix[3-9]*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  ;;
+# Must we lock files when doing compilation?
+need_locks=$lt_need_locks
 
-irix5* | irix6* | nonstopux*)
-  case $host_os in
-    nonstopux*) version_type=nonstopux ;;
-    *)
-	if test "$lt_cv_prog_gnu_ld" = yes; then
-		version_type=linux
-	else
-		version_type=irix
-	fi ;;
-  esac
-  need_lib_prefix=no
-  need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
-  case $host_os in
-  irix5* | nonstopux*)
-    libsuff= shlibsuff=
-    ;;
-  *)
-    case $LD in # libtool.m4 will add one of these switches to LD
-    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
-      libsuff= shlibsuff= libmagic=32-bit;;
-    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
-      libsuff=32 shlibsuff=N32 libmagic=N32;;
-    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
-      libsuff=64 shlibsuff=64 libmagic=64-bit;;
-    *) libsuff= shlibsuff= libmagic=never-match;;
-    esac
-    ;;
-  esac
-  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
-  shlibpath_overrides_runpath=no
-  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
-  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
-  hardcode_into_libs=yes
-  ;;
+# Do we need the lib prefix for modules?
+need_lib_prefix=$need_lib_prefix
 
-# No shared lib support for Linux oldld, aout, or coff.
-linux*oldld* | linux*aout* | linux*coff*)
-  dynamic_linker=no
-  ;;
+# Do we need a version for libraries?
+need_version=$need_version
 
-# This must be Linux ELF.
-linux* | k*bsd*-gnu)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  # Some binutils ld are patched to set DT_RUNPATH
-  save_LDFLAGS=$LDFLAGS
-  save_libdir=$libdir
-  eval "libdir=/foo; wl=\"$lt_prog_compiler_wl\"; \
-       LDFLAGS=\"\$LDFLAGS $hardcode_libdir_flag_spec\""
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+# Whether dlopen is supported.
+dlopen_support=$enable_dlopen
 
-int
-main ()
-{
+# Whether dlopen of programs is supported.
+dlopen_self=$enable_dlopen_self
 
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then :
-  shlibpath_overrides_runpath=yes
-fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-  LDFLAGS=$save_LDFLAGS
-  libdir=$save_libdir
+# Whether dlopen of statically linked programs is supported.
+dlopen_self_static=$enable_dlopen_self_static
+
+# Compiler flag to prevent dynamic linking.
+link_static_flag=$lt_lt_prog_compiler_static_CXX
+
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag_CXX
+
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec=$lt_export_dynamic_flag_spec_CXX
+
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec=$lt_whole_archive_flag_spec_CXX
+
+# Compiler flag to generate thread-safe objects.
+thread_safe_flag_spec=$lt_thread_safe_flag_spec_CXX
+
+# Library versioning type.
+version_type=$version_type
+
+# Format of library name prefix.
+libname_spec=$lt_libname_spec
+
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME.
+library_names_spec=$lt_library_names_spec
+
+# The coded name of the library, if different from the real name.
+soname_spec=$lt_soname_spec
+
+# Commands used to build and install an old-style archive.
+RANLIB=$lt_RANLIB
+old_archive_cmds=$lt_old_archive_cmds_CXX
+old_postinstall_cmds=$lt_old_postinstall_cmds
+old_postuninstall_cmds=$lt_old_postuninstall_cmds
+
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=$lt_old_archive_from_new_cmds_CXX
+
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds_CXX
+
+# Commands used to build and install a shared archive.
+archive_cmds=$lt_archive_cmds_CXX
+archive_expsym_cmds=$lt_archive_expsym_cmds_CXX
+postinstall_cmds=$lt_postinstall_cmds
+postuninstall_cmds=$lt_postuninstall_cmds
+
+# Commands used to build a loadable module (assumed same as above if empty)
+module_cmds=$lt_module_cmds_CXX
+module_expsym_cmds=$lt_module_expsym_cmds_CXX
+
+# Commands to strip libraries.
+old_striplib=$lt_old_striplib
+striplib=$lt_striplib
+
+# Dependencies to place before the objects being linked to create a
+# shared library.
+predep_objects=\`echo $lt_predep_objects_CXX | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
+
+# Dependencies to place after the objects being linked to create a
+# shared library.
+postdep_objects=\`echo $lt_postdep_objects_CXX | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
+
+# Dependencies to place before the objects being linked to create a
+# shared library.
+predeps=$lt_predeps_CXX
+
+# Dependencies to place after the objects being linked to create a
+# shared library.
+postdeps=$lt_postdeps_CXX
+
+# The library search path used internally by the compiler when linking
+# a shared library.
+compiler_lib_search_path=\`echo $lt_compiler_lib_search_path_CXX | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
+
+# Method to check whether dependent libraries are shared objects.
+deplibs_check_method=$lt_deplibs_check_method
+
+# Command to use when deplibs_check_method == file_magic.
+file_magic_cmd=$lt_file_magic_cmd
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=$lt_allow_undefined_flag_CXX
+
+# Flag that forces no undefined symbols.
+no_undefined_flag=$lt_no_undefined_flag_CXX
+
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds=$lt_finish_cmds
+
+# Same as above, but a single script fragment to be evaled but not shown.
+finish_eval=$lt_finish_eval
+
+# Take the output of nm and produce a listing of raw symbols and C names.
+global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe
+
+# Transform the output of nm in a proper C declaration
+global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl
+
+# Transform the output of nm in a C name address pair
+global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address
+
+# This is the shared library runtime path variable.
+runpath_var=$runpath_var
+
+# This is the shared library path variable.
+shlibpath_var=$shlibpath_var
+
+# Is shlibpath searched before the hard-coded library search path?
+shlibpath_overrides_runpath=$shlibpath_overrides_runpath
+
+# How to hardcode a shared library path into an executable.
+hardcode_action=$hardcode_action_CXX
+
+# Whether we should hardcode library paths into libraries.
+hardcode_into_libs=$hardcode_into_libs
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec_CXX
+
+# If ld is used when linking, flag to hardcode \$libdir into
+# a binary during linking. This must work even if \$libdir does
+# not exist.
+hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld_CXX
+
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator=$lt_hardcode_libdir_separator_CXX
+
+# Set to yes if using DIR/libNAME${shared_ext} during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct=$hardcode_direct_CXX
+
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L=$hardcode_minus_L_CXX
+
+# Set to yes if using SHLIBPATH_VAR=DIR during linking hardcodes DIR into
+# the resulting binary.
+hardcode_shlibpath_var=$hardcode_shlibpath_var_CXX
+
+# Set to yes if building a shared library automatically hardcodes DIR into the library
+# and all subsequent libraries and executables linked against it.
+hardcode_automatic=$hardcode_automatic_CXX
+
+# Variables whose values should be saved in libtool wrapper scripts and
+# restored at relink time.
+variables_saved_for_relink="$variables_saved_for_relink"
+
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=$link_all_deplibs_CXX
+
+# Compile-time system search path for libraries
+sys_lib_search_path_spec=\`echo $lt_sys_lib_search_path_spec | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
+
+# Run-time system search path for libraries
+sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
+
+# Fix the shell variable \$srcfile for the compiler.
+fix_srcfile_path="$fix_srcfile_path_CXX"
+
+# Set to yes if exported symbols are required.
+always_export_symbols=$always_export_symbols_CXX
+
+# The commands to list exported symbols.
+export_symbols_cmds=$lt_export_symbols_cmds_CXX
+
+# The commands to extract the exported symbol list from a shared archive.
+extract_expsyms_cmds=$lt_extract_expsyms_cmds
 
-  # This implies no fast_install, which is unacceptable.
-  # Some rework will be needed to allow for fast_install
-  # before this can be enabled.
-  hardcode_into_libs=yes
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms=$lt_exclude_expsyms_CXX
 
-  # Append ld.so.conf contents to the search path
-  if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
-    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
-  fi
+# Symbols that must always be exported.
+include_expsyms=$lt_include_expsyms_CXX
 
-  # We used to test for /lib/ld.so.1 and disable shared libraries on
-  # powerpc, because MkLinux only supported shared libraries with the
-  # GNU dynamic linker.  Since this was broken with cross compilers,
-  # most powerpc-linux boxes support dynamic linking these days and
-  # people can always --disable-shared, the test was removed, and we
-  # assume the GNU/Linux dynamic linker is in use.
-  dynamic_linker='GNU/Linux ld.so'
-  ;;
+# ### END LIBTOOL TAG CONFIG: $tagname
 
-netbsd*)
-  version_type=sunos
-  need_lib_prefix=no
-  need_version=no
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
-    dynamic_linker='NetBSD (a.out) ld.so'
-  else
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    dynamic_linker='NetBSD ld.elf_so'
+__EOF__
+
+
+else
+  # If there is no Makefile yet, we rely on a make rule to execute
+  # `config.status --recheck' to rerun these tests and create the
+  # libtool script then.
+  ltmain_in=`echo $ltmain | sed -e 's/\.sh$/.in/'`
+  if test -f "$ltmain_in"; then
+    test -f Makefile && make "$ltmain"
   fi
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  ;;
+fi
 
-newsos6)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  ;;
 
-*nto* | *qnx*)
-  version_type=qnx
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  dynamic_linker='ldqnx.so'
-  ;;
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
 
-openbsd*)
-  version_type=sunos
-  sys_lib_dlsearch_path_spec="/usr/lib"
-  need_lib_prefix=no
-  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
-  case $host_os in
-    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
-    *)				need_version=no  ;;
-  esac
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-    case $host_os in
-      openbsd2.[89] | openbsd2.[89].*)
-	shlibpath_overrides_runpath=no
-	;;
-      *)
-	shlibpath_overrides_runpath=yes
+CC=$lt_save_CC
+LDCXX=$LD
+LD=$lt_save_LD
+GCC=$lt_save_GCC
+with_gnu_ldcxx=$with_gnu_ld
+with_gnu_ld=$lt_save_with_gnu_ld
+lt_cv_path_LDCXX=$lt_cv_path_LD
+lt_cv_path_LD=$lt_save_path_LD
+lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld
+lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld
+
+	else
+	  tagname=""
+	fi
 	;;
-      esac
-  else
-    shlibpath_overrides_runpath=yes
-  fi
-  ;;
 
-os2*)
-  libname_spec='$name'
-  shrext_cmds=".dll"
-  need_lib_prefix=no
-  library_names_spec='$libname${shared_ext} $libname.a'
-  dynamic_linker='OS/2 ld.exe'
-  shlibpath_var=LIBPATH
-  ;;
+      F77)
+	if test -n "$F77" && test "X$F77" != "Xno"; then
 
-osf3* | osf4* | osf5*)
-  version_type=osf
-  need_lib_prefix=no
-  need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
-  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
-  ;;
+ac_ext=f
+ac_compile='$F77 -c $FFLAGS conftest.$ac_ext >&5'
+ac_link='$F77 -o conftest$ac_exeext $FFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_f77_compiler_gnu
+
+
+archive_cmds_need_lc_F77=no
+allow_undefined_flag_F77=
+always_export_symbols_F77=no
+archive_expsym_cmds_F77=
+export_dynamic_flag_spec_F77=
+hardcode_direct_F77=no
+hardcode_libdir_flag_spec_F77=
+hardcode_libdir_flag_spec_ld_F77=
+hardcode_libdir_separator_F77=
+hardcode_minus_L_F77=no
+hardcode_automatic_F77=no
+module_cmds_F77=
+module_expsym_cmds_F77=
+link_all_deplibs_F77=unknown
+old_archive_cmds_F77=$old_archive_cmds
+no_undefined_flag_F77=
+whole_archive_flag_spec_F77=
+enable_shared_with_static_runtimes_F77=no
 
-rdos*)
-  dynamic_linker=no
-  ;;
+# Source file extension for f77 test sources.
+ac_ext=f
 
-solaris*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  # ldd complains unless libraries are executable
-  postinstall_cmds='chmod +x $lib'
-  ;;
+# Object file extension for compiled f77 test sources.
+objext=o
+objext_F77=$objext
 
-sunos4*)
-  version_type=sunos
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  if test "$with_gnu_ld" = yes; then
-    need_lib_prefix=no
-  fi
-  need_version=yes
-  ;;
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="      subroutine t\n      return\n      end\n"
 
-sysv4 | sysv4.3*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  case $host_vendor in
-    sni)
-      shlibpath_overrides_runpath=no
-      need_lib_prefix=no
-      runpath_var=LD_RUN_PATH
-      ;;
-    siemens)
-      need_lib_prefix=no
-      ;;
-    motorola)
-      need_lib_prefix=no
-      need_version=no
-      shlibpath_overrides_runpath=no
-      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
-      ;;
+# Code to be used in simple link tests
+lt_simple_link_test_code="      program t\n      end\n"
+
+# ltmain only uses $CC for tagged configurations so make sure $CC is set.
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+
+
+# save warnings/boilerplate of simple test code
+ac_outfile=conftest.$ac_objext
+printf "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$rm conftest*
+
+ac_outfile=conftest.$ac_objext
+printf "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$rm conftest*
+
+
+# Allow CC to be a program name with arguments.
+lt_save_CC="$CC"
+CC=${F77-"f77"}
+compiler=$CC
+compiler_F77=$CC
+for cc_temp in $compiler""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
   esac
-  ;;
+done
+cc_basename=`$echo "X$cc_temp" | $Xsed -e 's%.*/%%' -e "s%^$host_alias-%%"`
 
-sysv4*MP*)
-  if test -d /usr/nec ;then
-    version_type=linux
-    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
-    soname_spec='$libname${shared_ext}.$major'
-    shlibpath_var=LD_LIBRARY_PATH
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if libtool supports shared libraries" >&5
+$as_echo_n "checking if libtool supports shared libraries... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $can_build_shared" >&5
+$as_echo "$can_build_shared" >&6; }
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build shared libraries" >&5
+$as_echo_n "checking whether to build shared libraries... " >&6; }
+test "$can_build_shared" = "no" && enable_shared=no
+
+# On AIX, shared libraries and static libraries use the same namespace, and
+# are all built from PIC.
+case $host_os in
+aix3*)
+  test "$enable_shared" = yes && enable_static=no
+  if test -n "$RANLIB"; then
+    archive_cmds="$archive_cmds~\$RANLIB \$lib"
+    postinstall_cmds='$RANLIB $lib'
   fi
   ;;
-
-sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
-  version_type=freebsd-elf
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  if test "$with_gnu_ld" = yes; then
-    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
-  else
-    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
-    case $host_os in
-      sco3.2v5*)
-        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
-	;;
-    esac
+aix4* | aix5*)
+  if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+    test "$enable_shared" = yes && enable_static=no
   fi
-  sys_lib_dlsearch_path_spec='/usr/lib'
   ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_shared" >&5
+$as_echo "$enable_shared" >&6; }
 
-tpf*)
-  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  ;;
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build static libraries" >&5
+$as_echo_n "checking whether to build static libraries... " >&6; }
+# Make sure either enable_shared or enable_static is yes.
+test "$enable_shared" = yes || enable_static=yes
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_static" >&5
+$as_echo "$enable_static" >&6; }
 
-uts4*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  ;;
+GCC_F77="$G77"
+LD_F77="$LD"
 
-*)
-  dynamic_linker=no
-  ;;
-esac
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
-$as_echo "$dynamic_linker" >&6; }
-test "$dynamic_linker" = no && can_build_shared=no
+lt_prog_compiler_wl_F77=
+lt_prog_compiler_pic_F77=
+lt_prog_compiler_static_F77=
 
-variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
-if test "$GCC" = yes; then
-  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
-fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
+$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
+
+  if test "$GCC" = yes; then
+    lt_prog_compiler_wl_F77='-Wl,'
+    lt_prog_compiler_static_F77='-static'
+
+    case $host_os in
+      aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static_F77='-Bstatic'
+      fi
+      ;;
 
-if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
-  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
-fi
-if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
-  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
-fi
+    amigaos*)
+      # FIXME: we need at least 68020 code to build shared libraries, but
+      # adding the `-m68020' flag to GCC prevents building anything better,
+      # like `-m68040'.
+      lt_prog_compiler_pic_F77='-m68020 -resident32 -malways-restore-a4'
+      ;;
 
+    beos* | cygwin* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
 
+    mingw* | pw32* | os2*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_prog_compiler_pic_F77='-DDLL_EXPORT'
+      ;;
 
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      lt_prog_compiler_pic_F77='-fno-common'
+      ;;
 
+    interix3*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
 
+    msdosdjgpp*)
+      # Just because we use GCC doesn't mean we suddenly get shared libraries
+      # on systems that don't support them.
+      lt_prog_compiler_can_build_shared_F77=no
+      enable_shared=no
+      ;;
 
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	lt_prog_compiler_pic_F77=-Kconform_pic
+      fi
+      ;;
 
+    hpux*)
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic_F77='-fPIC'
+	;;
+      esac
+      ;;
 
+    *)
+      lt_prog_compiler_pic_F77='-fPIC'
+      ;;
+    esac
+  else
+    # PORTME Check for flag to pass linker flags through the system compiler.
+    case $host_os in
+    aix*)
+      lt_prog_compiler_wl_F77='-Wl,'
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static_F77='-Bstatic'
+      else
+	lt_prog_compiler_static_F77='-bnso -bI:/lib/syscalls.exp'
+      fi
+      ;;
+      darwin*)
+        # PIC is the default on this platform
+        # Common symbols not allowed in MH_DYLIB files
+       case $cc_basename in
+         xlc*)
+         lt_prog_compiler_pic_F77='-qnocommon'
+         lt_prog_compiler_wl_F77='-Wl,'
+         ;;
+       esac
+       ;;
 
+    mingw* | pw32* | os2*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_prog_compiler_pic_F77='-DDLL_EXPORT'
+      ;;
 
+    hpux9* | hpux10* | hpux11*)
+      lt_prog_compiler_wl_F77='-Wl,'
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic_F77='+Z'
+	;;
+      esac
+      # Is there a better lt_prog_compiler_static that works with the bundled CC?
+      lt_prog_compiler_static_F77='${wl}-a ${wl}archive'
+      ;;
 
+    irix5* | irix6* | nonstopux*)
+      lt_prog_compiler_wl_F77='-Wl,'
+      # PIC (with -KPIC) is the default.
+      lt_prog_compiler_static_F77='-non_shared'
+      ;;
 
+    newsos6)
+      lt_prog_compiler_pic_F77='-KPIC'
+      lt_prog_compiler_static_F77='-Bstatic'
+      ;;
 
+    linux*)
+      case $cc_basename in
+      icc* | ecc*)
+	lt_prog_compiler_wl_F77='-Wl,'
+	lt_prog_compiler_pic_F77='-KPIC'
+	lt_prog_compiler_static_F77='-static'
+        ;;
+      pgcc* | pgf77* | pgf90* | pgf95*)
+        # Portland Group compilers (*not* the Pentium gcc compiler,
+	# which looks to be a dead project)
+	lt_prog_compiler_wl_F77='-Wl,'
+	lt_prog_compiler_pic_F77='-fpic'
+	lt_prog_compiler_static_F77='-Bstatic'
+        ;;
+      ccc*)
+        lt_prog_compiler_wl_F77='-Wl,'
+        # All Alpha code is PIC.
+        lt_prog_compiler_static_F77='-non_shared'
+        ;;
+      esac
+      ;;
 
+    osf3* | osf4* | osf5*)
+      lt_prog_compiler_wl_F77='-Wl,'
+      # All OSF/1 code is PIC.
+      lt_prog_compiler_static_F77='-non_shared'
+      ;;
 
+    solaris*)
+      lt_prog_compiler_pic_F77='-KPIC'
+      lt_prog_compiler_static_F77='-Bstatic'
+      case $cc_basename in
+      f77* | f90* | f95*)
+	lt_prog_compiler_wl_F77='-Qoption ld ';;
+      *)
+	lt_prog_compiler_wl_F77='-Wl,';;
+      esac
+      ;;
 
+    sunos4*)
+      lt_prog_compiler_wl_F77='-Qoption ld '
+      lt_prog_compiler_pic_F77='-PIC'
+      lt_prog_compiler_static_F77='-Bstatic'
+      ;;
 
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      lt_prog_compiler_wl_F77='-Wl,'
+      lt_prog_compiler_pic_F77='-KPIC'
+      lt_prog_compiler_static_F77='-Bstatic'
+      ;;
 
+    sysv4*MP*)
+      if test -d /usr/nec ;then
+	lt_prog_compiler_pic_F77='-Kconform_pic'
+	lt_prog_compiler_static_F77='-Bstatic'
+      fi
+      ;;
 
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      lt_prog_compiler_wl_F77='-Wl,'
+      lt_prog_compiler_pic_F77='-KPIC'
+      lt_prog_compiler_static_F77='-Bstatic'
+      ;;
 
+    unicos*)
+      lt_prog_compiler_wl_F77='-Wl,'
+      lt_prog_compiler_can_build_shared_F77=no
+      ;;
 
+    uts4*)
+      lt_prog_compiler_pic_F77='-pic'
+      lt_prog_compiler_static_F77='-Bstatic'
+      ;;
 
+    *)
+      lt_prog_compiler_can_build_shared_F77=no
+      ;;
+    esac
+  fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic_F77" >&5
+$as_echo "$lt_prog_compiler_pic_F77" >&6; }
 
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$lt_prog_compiler_pic_F77"; then
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic_F77 works" >&5
+$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic_F77 works... " >&6; }
+if test "${lt_prog_compiler_pic_works_F77+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_prog_compiler_pic_works_F77=no
+  ac_outfile=conftest.$ac_objext
+   printf "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$lt_prog_compiler_pic_F77"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:13598: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:13602: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_prog_compiler_pic_works_F77=yes
+     fi
+   fi
+   $rm conftest*
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic_works_F77" >&5
+$as_echo "$lt_prog_compiler_pic_works_F77" >&6; }
 
+if test x"$lt_prog_compiler_pic_works_F77" = xyes; then
+    case $lt_prog_compiler_pic_F77 in
+     "" | " "*) ;;
+     *) lt_prog_compiler_pic_F77=" $lt_prog_compiler_pic_F77" ;;
+     esac
+else
+    lt_prog_compiler_pic_F77=
+     lt_prog_compiler_can_build_shared_F77=no
+fi
 
+fi
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    lt_prog_compiler_pic_F77=
+    ;;
+  *)
+    lt_prog_compiler_pic_F77="$lt_prog_compiler_pic_F77"
+    ;;
+esac
 
+#
+# Check to make sure the static flag actually works.
+#
+wl=$lt_prog_compiler_wl_F77 eval lt_tmp_static_flag=\"$lt_prog_compiler_static_F77\"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
+$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
+if test "${lt_prog_compiler_static_works_F77+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_prog_compiler_static_works_F77=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
+   printf "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&5
+       $echo "X$_lt_linker_boilerplate" | $Xsed -e '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         lt_prog_compiler_static_works_F77=yes
+       fi
+     else
+       lt_prog_compiler_static_works_F77=yes
+     fi
+   fi
+   $rm conftest*
+   LDFLAGS="$save_LDFLAGS"
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_static_works_F77" >&5
+$as_echo "$lt_prog_compiler_static_works_F77" >&6; }
 
+if test x"$lt_prog_compiler_static_works_F77" = xyes; then
+    :
+else
+    lt_prog_compiler_static_F77=
+fi
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o_F77+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o_F77=no
+   $rm -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   printf "$lt_simple_compile_test_code" > conftest.$ac_ext
 
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:13702: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:13706: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o_F77=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $rm conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $rm out/ii_files/* && rmdir out/ii_files
+   $rm out/* && rmdir out
+   cd ..
+   rmdir conftest
+   $rm conftest*
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o_F77" >&5
+$as_echo "$lt_cv_prog_compiler_c_o_F77" >&6; }
 
 
+hard_links="nottested"
+if test "$lt_cv_prog_compiler_c_o_F77" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
+$as_echo_n "checking if we can lock with hard links... " >&6; }
+  hard_links=yes
+  $rm conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
+$as_echo "$hard_links" >&6; }
+  if test "$hard_links" = no; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
+$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
 
+  runpath_var=
+  allow_undefined_flag_F77=
+  enable_shared_with_static_runtimes_F77=no
+  archive_cmds_F77=
+  archive_expsym_cmds_F77=
+  old_archive_From_new_cmds_F77=
+  old_archive_from_expsyms_cmds_F77=
+  export_dynamic_flag_spec_F77=
+  whole_archive_flag_spec_F77=
+  thread_safe_flag_spec_F77=
+  hardcode_libdir_flag_spec_F77=
+  hardcode_libdir_flag_spec_ld_F77=
+  hardcode_libdir_separator_F77=
+  hardcode_direct_F77=no
+  hardcode_minus_L_F77=no
+  hardcode_shlibpath_var_F77=unsupported
+  link_all_deplibs_F77=unknown
+  hardcode_automatic_F77=no
+  module_cmds_F77=
+  module_expsym_cmds_F77=
+  always_export_symbols_F77=no
+  export_symbols_cmds_F77='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  # include_expsyms should be a list of space-separated symbols to be *always*
+  # included in the symbol list
+  include_expsyms_F77=
+  # exclude_expsyms can be an extended regexp of symbols to exclude
+  # it will be wrapped by ` (' and `)$', so one must not match beginning or
+  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
+  # as well as any symbol that contains `d'.
+  exclude_expsyms_F77="_GLOBAL_OFFSET_TABLE_"
+  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
+  # platforms (ab)use it in PIC code, but their linkers get confused if
+  # the symbol is explicitly referenced.  Since portable code cannot
+  # rely on this symbol name, it's probably fine to never include it in
+  # preloaded symbol tables.
+  extract_expsyms_cmds=
+  # Just being paranoid about ensuring that cc_basename is set.
+  for cc_temp in $compiler""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$echo "X$cc_temp" | $Xsed -e 's%.*/%%' -e "s%^$host_alias-%%"`
 
+  case $host_os in
+  cygwin* | mingw* | pw32*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+  esac
 
+  ld_shlibs_F77=yes
+  if test "$with_gnu_ld" = yes; then
+    # If archive_cmds runs LD, not CC, wlarc should be empty
+    wlarc='${wl}'
 
+    # Set some defaults for GNU ld with shared library support. These
+    # are reset later if shared libraries are not supported. Putting them
+    # here allows them to be overridden if necessary.
+    runpath_var=LD_RUN_PATH
+    hardcode_libdir_flag_spec_F77='${wl}--rpath ${wl}$libdir'
+    export_dynamic_flag_spec_F77='${wl}--export-dynamic'
+    # ancient GNU ld didn't support --whole-archive et. al.
+    if $LD --help 2>&1 | grep 'no-whole-archive' > /dev/null; then
+	whole_archive_flag_spec_F77="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+      else
+  	whole_archive_flag_spec_F77=
+    fi
+    supports_anon_versioning=no
+    case `$LD -v 2>/dev/null` in
+      *\ [01].* | *\ 2.[0-9].* | *\ 2.10.*) ;; # catch versions < 2.11
+      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
+      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
+      *\ 2.11.*) ;; # other 2.11 versions
+      *) supports_anon_versioning=yes ;;
+    esac
 
+    # See if GNU ld supports shared libraries.
+    case $host_os in
+    aix3* | aix4* | aix5*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+	ld_shlibs_F77=no
+	cat <<EOF 1>&2
 
+*** Warning: the GNU linker, at least up to release 2.9.1, is reported
+*** to be unable to reliably create shared libraries on AIX.
+*** Therefore, libtool is disabling shared libraries support.  If you
+*** really care for shared libraries, you may want to modify your PATH
+*** so that a non-GNU linker is found, and then restart.
 
+EOF
+      fi
+      ;;
 
+    amigaos*)
+      archive_cmds_F77='$rm $output_objdir/a2ixlibrary.data~$echo "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$echo "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$echo "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$echo "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+      hardcode_libdir_flag_spec_F77='-L$libdir'
+      hardcode_minus_L_F77=yes
+
+      # Samuel A. Falvo II <kc5tja@dolphin.openprojects.net> reports
+      # that the semantics of dynamic libraries on AmigaOS, at least up
+      # to version 4, is to share data among multiple programs linked
+      # with the same dynamic library.  Since this doesn't match the
+      # behavior of shared libraries on other platforms, we can't use
+      # them.
+      ld_shlibs_F77=no
+      ;;
 
+    beos*)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+	allow_undefined_flag_F77=unsupported
+	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	# support --undefined.  This deserves some investigation.  FIXME
+	archive_cmds_F77='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      else
+	ld_shlibs_F77=no
+      fi
+      ;;
 
+    cygwin* | mingw* | pw32*)
+      # _LT_AC_TAGVAR(hardcode_libdir_flag_spec, F77) is actually meaningless,
+      # as there is no search path for DLLs.
+      hardcode_libdir_flag_spec_F77='-L$libdir'
+      allow_undefined_flag_F77=unsupported
+      always_export_symbols_F77=no
+      enable_shared_with_static_runtimes_F77=yes
+      export_symbols_cmds_F77='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS] /s/.* \([^ ]*\)/\1 DATA/'\'' | $SED -e '\''/^[AITW] /s/.* //'\'' | sort | uniq > $export_symbols'
 
+      if $LD --help 2>&1 | grep 'auto-import' > /dev/null; then
+        archive_cmds_F77='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	# If the export-symbols file already is a .def file (1st line
+	# is EXPORTS), use it as is; otherwise, prepend...
+	archive_expsym_cmds_F77='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	  cp $export_symbols $output_objdir/$soname.def;
+	else
+	  echo EXPORTS > $output_objdir/$soname.def;
+	  cat $export_symbols >> $output_objdir/$soname.def;
+	fi~
+	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+      else
+	ld_shlibs_F77=no
+      fi
+      ;;
 
+    interix3*)
+      hardcode_direct_F77=no
+      hardcode_shlibpath_var_F77=no
+      hardcode_libdir_flag_spec_F77='${wl}-rpath,$libdir'
+      export_dynamic_flag_spec_F77='${wl}-E'
+      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+      # Instead, shared libraries are loaded at an image base (0x10000000 by
+      # default) and relocated if they conflict, which is a slow very memory
+      # consuming and fragmenting process.  To avoid this, we pick a random,
+      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+      archive_cmds_F77='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      archive_expsym_cmds_F77='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      ;;
 
+    linux*)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+	tmp_addflag=
+	case $cc_basename,$host_cpu in
+	pgcc*)				# Portland Group C compiler
+	  whole_archive_flag_spec_F77='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $echo \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag'
+	  ;;
+	pgf77* | pgf90* | pgf95*)	# Portland Group f77 and f90 compilers
+	  whole_archive_flag_spec_F77='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $echo \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag -Mnomain' ;;
+	ecc*,ia64* | icc*,ia64*)		# Intel C compiler on ia64
+	  tmp_addflag=' -i_dynamic' ;;
+	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
+	  tmp_addflag=' -i_dynamic -nofor_main' ;;
+	ifc* | ifort*)			# Intel Fortran compiler
+	  tmp_addflag=' -nofor_main' ;;
+	esac
+	archive_cmds_F77='$CC -shared'"$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
 
+	if test $supports_anon_versioning = yes; then
+	  archive_expsym_cmds_F77='$echo "{ global:" > $output_objdir/$libname.ver~
+  cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+  $echo "local: *; };" >> $output_objdir/$libname.ver~
+	  $CC -shared'"$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+	fi
+      else
+	ld_shlibs_F77=no
+      fi
+      ;;
 
+    netbsd*)
+      if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
+	archive_cmds_F77='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
+	wlarc=
+      else
+	archive_cmds_F77='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds_F77='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      fi
+      ;;
 
+    solaris*)
+      if $LD -v 2>&1 | grep 'BFD 2\.8' > /dev/null; then
+	ld_shlibs_F77=no
+	cat <<EOF 1>&2
 
+*** Warning: The releases 2.8.* of the GNU linker cannot reliably
+*** create shared libraries on Solaris systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.9.1 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
 
+EOF
+      elif $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+	archive_cmds_F77='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds_F77='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs_F77=no
+      fi
+      ;;
 
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
+	ld_shlibs_F77=no
+	cat <<_LT_EOF 1>&2
 
+*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
+*** reliably create shared libraries on SCO systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
 
+_LT_EOF
+	;;
+	*)
+	  if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+	    hardcode_libdir_flag_spec_F77='`test -z "$SCOABSPATH" && echo ${wl}-rpath,$libdir`'
+	    archive_cmds_F77='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib'
+	    archive_expsym_cmds_F77='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname,\${SCOABSPATH:+${install_libdir}/}$soname,-retain-symbols-file,$export_symbols -o $lib'
+	  else
+	    ld_shlibs_F77=no
+	  fi
+	;;
+      esac
+      ;;
 
+    sunos4*)
+      archive_cmds_F77='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      wlarc=
+      hardcode_direct_F77=yes
+      hardcode_shlibpath_var_F77=no
+      ;;
 
+    *)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+	archive_cmds_F77='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds_F77='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs_F77=no
+      fi
+      ;;
+    esac
 
+    if test "$ld_shlibs_F77" = no; then
+      runpath_var=
+      hardcode_libdir_flag_spec_F77=
+      export_dynamic_flag_spec_F77=
+      whole_archive_flag_spec_F77=
+    fi
+  else
+    # PORTME fill in a description of your system's linker (not GNU ld)
+    case $host_os in
+    aix3*)
+      allow_undefined_flag_F77=unsupported
+      always_export_symbols_F77=yes
+      archive_expsym_cmds_F77='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      hardcode_minus_L_F77=yes
+      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
+	# Neither direct hardcoding nor static linking is supported with a
+	# broken collect2.
+	hardcode_direct_F77=unsupported
+      fi
+      ;;
 
+    aix4* | aix5*)
+      if test "$host_cpu" = ia64; then
+	# On IA64, the linker does run time linking by default, so we don't
+	# have to do anything special.
+	aix_use_runtimelinking=no
+	exp_sym_flag='-Bexport'
+	no_entry_flag=""
+      else
+	# If we're using GNU nm, then we don't want the "-C" option.
+	# -C means demangle to AIX nm, but means don't demangle with GNU nm
+	if $NM -V 2>&1 | grep 'GNU' > /dev/null; then
+	  export_symbols_cmds_F77='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$2 == "T") || (\$2 == "D") || (\$2 == "B")) && (substr(\$3,1,1) != ".")) { print \$3 } }'\'' | sort -u > $export_symbols'
+	else
+	  export_symbols_cmds_F77='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$2 == "T") || (\$2 == "D") || (\$2 == "B")) && (substr(\$3,1,1) != ".")) { print \$3 } }'\'' | sort -u > $export_symbols'
+	fi
+	aix_use_runtimelinking=no
 
+	# Test if we are trying to use run time linking or normal
+	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
+	# need to do runtime linking.
+	case $host_os in aix4.[23]|aix4.[23].*|aix5*)
+	  for ld_flag in $LDFLAGS; do
+  	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+  	    aix_use_runtimelinking=yes
+  	    break
+  	  fi
+	  done
+	  ;;
+	esac
 
+	exp_sym_flag='-bexport'
+	no_entry_flag='-bnoentry'
+      fi
 
+      # When large executables or shared objects are built, AIX ld can
+      # have problems creating the table of contents.  If linking a library
+      # or program results in "error TOC overflow" add -mminimal-toc to
+      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
 
+      archive_cmds_F77=''
+      hardcode_direct_F77=yes
+      hardcode_libdir_separator_F77=':'
+      link_all_deplibs_F77=yes
 
+      if test "$GCC" = yes; then
+	case $host_os in aix4.[012]|aix4.[012].*)
+	# We only want to do this on AIX 4.2 and lower, the check
+	# below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" && \
+  	   strings "$collect2name" | grep resolve_lib_name >/dev/null
+	  then
+  	  # We have reworked collect2
+  	  hardcode_direct_F77=yes
+	  else
+  	  # We have old collect2
+  	  hardcode_direct_F77=unsupported
+  	  # It fails to find uninstalled libraries when the uninstalled
+  	  # path is not listed in the libpath.  Setting hardcode_minus_L
+  	  # to unsupported forces relinking
+  	  hardcode_minus_L_F77=yes
+  	  hardcode_libdir_flag_spec_F77='-L$libdir'
+  	  hardcode_libdir_separator_F77=
+	  fi
+	  ;;
+	esac
+	shared_flag='-shared'
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag="$shared_flag "'${wl}-G'
+	fi
+      else
+	# not using gcc
+	if test "$host_cpu" = ia64; then
+  	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+  	# chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+	else
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag='${wl}-G'
+	  else
+	    shared_flag='${wl}-bM:SRE'
+	  fi
+	fi
+      fi
 
+      # It seems that -bexpall does not export symbols beginning with
+      # underscore (_), so it is better to generate a list of symbols to export.
+      always_export_symbols_F77=yes
+      if test "$aix_use_runtimelinking" = yes; then
+	# Warning - without using the other runtime loading flags (-brtl),
+	# -berok will link without error, but may produce a broken library.
+	allow_undefined_flag_F77='-berok'
+       # Determine the default libpath from the value encoded in an empty executable.
+       cat > conftest.$ac_ext <<_ACEOF
+      program main
 
+      end
+_ACEOF
+if ac_fn_f77_try_link "$LINENO"; then :
 
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`; fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
 
+       hardcode_libdir_flag_spec_F77='${wl}-blibpath:$libdir:'"$aix_libpath"
+	archive_expsym_cmds_F77="\$CC"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then echo "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+       else
+	if test "$host_cpu" = ia64; then
+	  hardcode_libdir_flag_spec_F77='${wl}-R $libdir:/usr/lib:/lib'
+	  allow_undefined_flag_F77="-z nodefs"
+	  archive_expsym_cmds_F77="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	else
+	 # Determine the default libpath from the value encoded in an empty executable.
+	 cat > conftest.$ac_ext <<_ACEOF
+      program main
 
+      end
+_ACEOF
+if ac_fn_f77_try_link "$LINENO"; then :
 
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`; fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
 
+	 hardcode_libdir_flag_spec_F77='${wl}-blibpath:$libdir:'"$aix_libpath"
+	  # Warning - without using the other run time loading flags,
+	  # -berok will link without error, but may produce a broken library.
+	  no_undefined_flag_F77=' ${wl}-bernotok'
+	  allow_undefined_flag_F77=' ${wl}-berok'
+	  # Exported symbols can be pulled into shared objects from archives
+	  whole_archive_flag_spec_F77='$convenience'
+	  archive_cmds_need_lc_F77=yes
+	  # This is similar to how AIX traditionally builds its shared libraries.
+	  archive_expsym_cmds_F77="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	fi
+      fi
+      ;;
 
+    amigaos*)
+      archive_cmds_F77='$rm $output_objdir/a2ixlibrary.data~$echo "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$echo "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$echo "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$echo "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+      hardcode_libdir_flag_spec_F77='-L$libdir'
+      hardcode_minus_L_F77=yes
+      # see comment about different semantics on the GNU ld section
+      ld_shlibs_F77=no
+      ;;
 
+    bsdi[45]*)
+      export_dynamic_flag_spec_F77=-rdynamic
+      ;;
 
+    cygwin* | mingw* | pw32*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec_F77=' '
+      allow_undefined_flag_F77=unsupported
+      # Tell ltmain to make .lib files, not .a files.
+      libext=lib
+      # Tell ltmain to make .dll files, not .so files.
+      shrext_cmds=".dll"
+      # FIXME: Setting linknames here is a bad hack.
+      archive_cmds_F77='$CC -o $lib $libobjs $compiler_flags `echo "$deplibs" | $SED -e '\''s/ -lc$//'\''` -link -dll~linknames='
+      # The linker will automatically build a .lib file if we build a DLL.
+      old_archive_From_new_cmds_F77='true'
+      # FIXME: Should let the user specify the lib program.
+      old_archive_cmds_F77='lib /OUT:$oldlib$oldobjs$old_deplibs'
+      fix_srcfile_path_F77='`cygpath -w "$srcfile"`'
+      enable_shared_with_static_runtimes_F77=yes
+      ;;
 
+    darwin* | rhapsody*)
+      case $host_os in
+        rhapsody* | darwin1.[012])
+         allow_undefined_flag_F77='${wl}-undefined ${wl}suppress'
+         ;;
+       *) # Darwin 1.3 on
+         if test -z ${MACOSX_DEPLOYMENT_TARGET} ; then
+           allow_undefined_flag_F77='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
+         else
+           case ${MACOSX_DEPLOYMENT_TARGET} in
+             10.[012])
+               allow_undefined_flag_F77='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
+               ;;
+             10.*)
+               allow_undefined_flag_F77='${wl}-undefined ${wl}dynamic_lookup'
+               ;;
+           esac
+         fi
+         ;;
+      esac
+      archive_cmds_need_lc_F77=no
+      hardcode_direct_F77=no
+      hardcode_automatic_F77=yes
+      hardcode_shlibpath_var_F77=unsupported
+      whole_archive_flag_spec_F77=''
+      link_all_deplibs_F77=yes
+    if test "$GCC" = yes ; then
+    	output_verbose_link_cmd='echo'
+        archive_cmds_F77='$CC -dynamiclib $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+      module_cmds_F77='$CC $allow_undefined_flag -o $lib -bundle $libobjs $deplibs$compiler_flags'
+      # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin lds
+      archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -dynamiclib $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+      module_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC $allow_undefined_flag  -o $lib -bundle $libobjs $deplibs$compiler_flags~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+    else
+      case $cc_basename in
+        xlc*)
+         output_verbose_link_cmd='echo'
+         archive_cmds_F77='$CC -qmkshrobj $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-install_name ${wl}`echo $rpath/$soname` $verstring'
+         module_cmds_F77='$CC $allow_undefined_flag -o $lib -bundle $libobjs $deplibs$compiler_flags'
+          # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin lds
+         archive_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -qmkshrobj $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-install_name ${wl}$rpath/$soname $verstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          module_expsym_cmds_F77='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC $allow_undefined_flag  -o $lib -bundle $libobjs $deplibs$compiler_flags~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          ;;
+       *)
+         ld_shlibs_F77=no
+          ;;
+      esac
+    fi
+      ;;
 
+    dgux*)
+      archive_cmds_F77='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec_F77='-L$libdir'
+      hardcode_shlibpath_var_F77=no
+      ;;
 
+    freebsd1*)
+      ld_shlibs_F77=no
+      ;;
 
+    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+    # support.  Future versions do this automatically, but an explicit c++rt0.o
+    # does not break anything, and helps significantly (at the cost of a little
+    # extra space).
+    freebsd2.2*)
+      archive_cmds_F77='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
+      hardcode_libdir_flag_spec_F77='-R$libdir'
+      hardcode_direct_F77=yes
+      hardcode_shlibpath_var_F77=no
+      ;;
 
+    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
+    freebsd2*)
+      archive_cmds_F77='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct_F77=yes
+      hardcode_minus_L_F77=yes
+      hardcode_shlibpath_var_F77=no
+      ;;
 
+    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
+    freebsd* | kfreebsd*-gnu | dragonfly*)
+      archive_cmds_F77='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
+      hardcode_libdir_flag_spec_F77='-R$libdir'
+      hardcode_direct_F77=yes
+      hardcode_shlibpath_var_F77=no
+      ;;
 
+    hpux9*)
+      if test "$GCC" = yes; then
+	archive_cmds_F77='$rm $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      else
+	archive_cmds_F77='$rm $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      fi
+      hardcode_libdir_flag_spec_F77='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator_F77=:
+      hardcode_direct_F77=yes
 
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      hardcode_minus_L_F77=yes
+      export_dynamic_flag_spec_F77='${wl}-E'
+      ;;
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
-$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
-hardcode_action=
-if test -n "$hardcode_libdir_flag_spec" ||
-   test -n "$runpath_var" ||
-   test "X$hardcode_automatic" = "Xyes" ; then
+    hpux10*)
+      if test "$GCC" = yes -a "$with_gnu_ld" = no; then
+	archive_cmds_F77='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds_F77='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec_F77='${wl}+b ${wl}$libdir'
+	hardcode_libdir_separator_F77=:
 
-  # We can hardcode non-existent directories.
-  if test "$hardcode_direct" != no &&
-     # If the only mechanism to avoid hardcoding is shlibpath_var, we
-     # have to relink, otherwise we might link with an installed library
-     # when we should be linking with a yet-to-be-installed one
-     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, )" != no &&
-     test "$hardcode_minus_L" != no; then
-    # Linking always hardcodes the temporary library directory.
-    hardcode_action=relink
-  else
-    # We can link without hardcoding, and we can hardcode nonexisting dirs.
-    hardcode_action=immediate
-  fi
-else
-  # We cannot hardcode anything, or else we can only hardcode existing
-  # directories.
-  hardcode_action=unsupported
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action" >&5
-$as_echo "$hardcode_action" >&6; }
+	hardcode_direct_F77=yes
+	export_dynamic_flag_spec_F77='${wl}-E'
 
-if test "$hardcode_action" = relink ||
-   test "$inherit_rpath" = yes; then
-  # Fast installation is not supported
-  enable_fast_install=no
-elif test "$shlibpath_overrides_runpath" = yes ||
-     test "$enable_shared" = no; then
-  # Fast installation is not necessary
-  enable_fast_install=needless
-fi
+	# hardcode_minus_L: Not really in the search PATH,
+	# but as the default location of the library.
+	hardcode_minus_L_F77=yes
+      fi
+      ;;
 
+    hpux11*)
+      if test "$GCC" = yes -a "$with_gnu_ld" = no; then
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds_F77='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds_F77='$CC -shared ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds_F77='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      else
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds_F77='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds_F77='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds_F77='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec_F77='${wl}+b ${wl}$libdir'
+	hardcode_libdir_separator_F77=:
 
+	case $host_cpu in
+	hppa*64*|ia64*)
+	  hardcode_libdir_flag_spec_ld_F77='+b $libdir'
+	  hardcode_direct_F77=no
+	  hardcode_shlibpath_var_F77=no
+	  ;;
+	*)
+	  hardcode_direct_F77=yes
+	  export_dynamic_flag_spec_F77='${wl}-E'
 
+	  # hardcode_minus_L: Not really in the search PATH,
+	  # but as the default location of the library.
+	  hardcode_minus_L_F77=yes
+	  ;;
+	esac
+      fi
+      ;;
 
+    irix5* | irix6* | nonstopux*)
+      if test "$GCC" = yes; then
+	archive_cmds_F77='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	archive_cmds_F77='$LD -shared $libobjs $deplibs $linker_flags -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+	hardcode_libdir_flag_spec_ld_F77='-rpath $libdir'
+      fi
+      hardcode_libdir_flag_spec_F77='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator_F77=:
+      link_all_deplibs_F77=yes
+      ;;
 
+    netbsd*)
+      if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
+	archive_cmds_F77='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
+      else
+	archive_cmds_F77='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
+      fi
+      hardcode_libdir_flag_spec_F77='-R$libdir'
+      hardcode_direct_F77=yes
+      hardcode_shlibpath_var_F77=no
+      ;;
 
-  if test "x$enable_dlopen" != xyes; then
-  enable_dlopen=unknown
-  enable_dlopen_self=unknown
-  enable_dlopen_self_static=unknown
-else
-  lt_cv_dlopen=no
-  lt_cv_dlopen_libs=
+    newsos6)
+      archive_cmds_F77='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct_F77=yes
+      hardcode_libdir_flag_spec_F77='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator_F77=:
+      hardcode_shlibpath_var_F77=no
+      ;;
 
-  case $host_os in
-  beos*)
-    lt_cv_dlopen="load_add_on"
-    lt_cv_dlopen_libs=
-    lt_cv_dlopen_self=yes
-    ;;
+    openbsd*)
+      hardcode_direct_F77=yes
+      hardcode_shlibpath_var_F77=no
+      if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	archive_cmds_F77='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds_F77='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
+	hardcode_libdir_flag_spec_F77='${wl}-rpath,$libdir'
+	export_dynamic_flag_spec_F77='${wl}-E'
+      else
+       case $host_os in
+	 openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+	   archive_cmds_F77='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+	   hardcode_libdir_flag_spec_F77='-R$libdir'
+	   ;;
+	 *)
+	   archive_cmds_F77='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	   hardcode_libdir_flag_spec_F77='${wl}-rpath,$libdir'
+	   ;;
+       esac
+      fi
+      ;;
 
-  mingw* | pw32* | cegcc*)
-    lt_cv_dlopen="LoadLibrary"
-    lt_cv_dlopen_libs=
-    ;;
+    os2*)
+      hardcode_libdir_flag_spec_F77='-L$libdir'
+      hardcode_minus_L_F77=yes
+      allow_undefined_flag_F77=unsupported
+      archive_cmds_F77='$echo "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$echo "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~$echo DATA >> $output_objdir/$libname.def~$echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~$echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
+      old_archive_From_new_cmds_F77='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+      ;;
 
-  cygwin*)
-    lt_cv_dlopen="dlopen"
-    lt_cv_dlopen_libs=
-    ;;
+    osf3*)
+      if test "$GCC" = yes; then
+	allow_undefined_flag_F77=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds_F77='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	allow_undefined_flag_F77=' -expect_unresolved \*'
+	archive_cmds_F77='$LD -shared${allow_undefined_flag} $libobjs $deplibs $linker_flags -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+      fi
+      hardcode_libdir_flag_spec_F77='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator_F77=:
+      ;;
 
-  darwin*)
-  # if libdl is installed we need to link against it
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
-$as_echo_n "checking for dlopen in -ldl... " >&6; }
-if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldl  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+    osf4* | osf5*)	# as osf3* with the addition of -msym flag
+      if test "$GCC" = yes; then
+	allow_undefined_flag_F77=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds_F77='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	hardcode_libdir_flag_spec_F77='${wl}-rpath ${wl}$libdir'
+      else
+	allow_undefined_flag_F77=' -expect_unresolved \*'
+	archive_cmds_F77='$LD -shared${allow_undefined_flag} $libobjs $deplibs $linker_flags -msym -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_expsym_cmds_F77='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; echo "-hidden">> $lib.exp~
+	$LD -shared${allow_undefined_flag} -input $lib.exp $linker_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib~$rm $lib.exp'
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
-int
-main ()
-{
-return dlopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dl_dlopen=yes
-else
-  ac_cv_lib_dl_dlopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
-$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
-if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
-else
+	# Both c and cxx compiler support -rpath directly
+	hardcode_libdir_flag_spec_F77='-rpath $libdir'
+      fi
+      hardcode_libdir_separator_F77=:
+      ;;
 
-    lt_cv_dlopen="dyld"
-    lt_cv_dlopen_libs=
-    lt_cv_dlopen_self=yes
+    solaris*)
+      no_undefined_flag_F77=' -z text'
+      if test "$GCC" = yes; then
+	wlarc='${wl}'
+	archive_cmds_F77='$CC -shared ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds_F77='$echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~$echo "local: *; };" >> $lib.exp~
+	  $CC -shared ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$rm $lib.exp'
+      else
+	wlarc=''
+	archive_cmds_F77='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	archive_expsym_cmds_F77='$echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~$echo "local: *; };" >> $lib.exp~
+  	$LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$rm $lib.exp'
+      fi
+      hardcode_libdir_flag_spec_F77='-R$libdir'
+      hardcode_shlibpath_var_F77=no
+      case $host_os in
+      solaris2.[0-5] | solaris2.[0-5].*) ;;
+      *)
+ 	# The compiler driver will combine linker options so we
+ 	# cannot just pass the convience library names through
+ 	# without $wl, iff we do not link with $LD.
+ 	# Luckily, gcc supports the same syntax we need for Sun Studio.
+ 	# Supported since Solaris 2.6 (maybe 2.5.1?)
+ 	case $wlarc in
+ 	'')
+ 	  whole_archive_flag_spec_F77='-z allextract$convenience -z defaultextract' ;;
+ 	*)
+ 	  whole_archive_flag_spec_F77='${wl}-z ${wl}allextract`for conv in $convenience\"\"; do test -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $echo \"$new_convenience\"` ${wl}-z ${wl}defaultextract' ;;
+ 	esac ;;
+      esac
+      link_all_deplibs_F77=yes
+      ;;
 
-fi
+    sunos4*)
+      if test "x$host_vendor" = xsequent; then
+	# Use $CC to link under sequent, because it throws in some extra .o
+	# files that make .init and .fini sections work.
+	archive_cmds_F77='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds_F77='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      hardcode_libdir_flag_spec_F77='-L$libdir'
+      hardcode_direct_F77=yes
+      hardcode_minus_L_F77=yes
+      hardcode_shlibpath_var_F77=no
+      ;;
 
-    ;;
+    sysv4)
+      case $host_vendor in
+	sni)
+	  archive_cmds_F77='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct_F77=yes # is this really true???
+	;;
+	siemens)
+	  ## LD is ld it makes a PLAMLIB
+	  ## CC just makes a GrossModule.
+	  archive_cmds_F77='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+	  reload_cmds_F77='$CC -r -o $output$reload_objs'
+	  hardcode_direct_F77=no
+        ;;
+	motorola)
+	  archive_cmds_F77='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct_F77=no #Motorola manual says yes, but my tests say they lie
+	;;
+      esac
+      runpath_var='LD_RUN_PATH'
+      hardcode_shlibpath_var_F77=no
+      ;;
 
-  *)
-    ac_fn_c_check_func "$LINENO" "shl_load" "ac_cv_func_shl_load"
-if test "x$ac_cv_func_shl_load" = x""yes; then :
-  lt_cv_dlopen="shl_load"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shl_load in -ldld" >&5
-$as_echo_n "checking for shl_load in -ldld... " >&6; }
-if test "${ac_cv_lib_dld_shl_load+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldld  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+    sysv4.3*)
+      archive_cmds_F77='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_shlibpath_var_F77=no
+      export_dynamic_flag_spec_F77='-Bexport'
+      ;;
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char shl_load ();
-int
-main ()
-{
-return shl_load ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dld_shl_load=yes
-else
-  ac_cv_lib_dld_shl_load=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_shl_load" >&5
-$as_echo "$ac_cv_lib_dld_shl_load" >&6; }
-if test "x$ac_cv_lib_dld_shl_load" = x""yes; then :
-  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"
-else
-  ac_fn_c_check_func "$LINENO" "dlopen" "ac_cv_func_dlopen"
-if test "x$ac_cv_func_dlopen" = x""yes; then :
-  lt_cv_dlopen="dlopen"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
-$as_echo_n "checking for dlopen in -ldl... " >&6; }
-if test "${ac_cv_lib_dl_dlopen+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldl  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	archive_cmds_F77='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	hardcode_shlibpath_var_F77=no
+	runpath_var=LD_RUN_PATH
+	hardcode_runpath_var=yes
+	ld_shlibs_F77=yes
+      fi
+      ;;
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
-int
-main ()
-{
-return dlopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dl_dlopen=yes
-else
-  ac_cv_lib_dl_dlopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
-$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
-if test "x$ac_cv_lib_dl_dlopen" = x""yes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -lsvld" >&5
-$as_echo_n "checking for dlopen in -lsvld... " >&6; }
-if test "${ac_cv_lib_svld_dlopen+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lsvld  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7*)
+      no_undefined_flag_F77='${wl}-z,text'
+      archive_cmds_need_lc_F77=no
+      hardcode_shlibpath_var_F77=no
+      runpath_var='LD_RUN_PATH'
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
-int
-main ()
-{
-return dlopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_svld_dlopen=yes
-else
-  ac_cv_lib_svld_dlopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_svld_dlopen" >&5
-$as_echo "$ac_cv_lib_svld_dlopen" >&6; }
-if test "x$ac_cv_lib_svld_dlopen" = x""yes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dld_link in -ldld" >&5
-$as_echo_n "checking for dld_link in -ldld... " >&6; }
-if test "${ac_cv_lib_dld_dld_link+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldld  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+      if test "$GCC" = yes; then
+	archive_cmds_F77='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds_F77='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds_F77='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds_F77='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dld_link ();
-int
-main ()
-{
-return dld_link ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dld_dld_link=yes
+    sysv5* | sco3.2v5* | sco5v6*)
+      # Note: We can NOT use -z defs as we might desire, because we do not
+      # link with -lc, and that would cause any symbols used from libc to
+      # always be unresolved, which means just about no library would
+      # ever link correctly.  If we're not using GNU ld we use -z text
+      # though, which does catch some bad symbols but isn't as heavy-handed
+      # as -z defs.
+      no_undefined_flag_F77='${wl}-z,text'
+      allow_undefined_flag_F77='${wl}-z,nodefs'
+      archive_cmds_need_lc_F77=no
+      hardcode_shlibpath_var_F77=no
+      hardcode_libdir_flag_spec_F77='`test -z "$SCOABSPATH" && echo ${wl}-R,$libdir`'
+      hardcode_libdir_separator_F77=':'
+      link_all_deplibs_F77=yes
+      export_dynamic_flag_spec_F77='${wl}-Bexport'
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	archive_cmds_F77='$CC -shared ${wl}-h,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds_F77='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds_F77='$CC -G ${wl}-h,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds_F77='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    uts4*)
+      archive_cmds_F77='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec_F77='-L$libdir'
+      hardcode_shlibpath_var_F77=no
+      ;;
+
+    *)
+      ld_shlibs_F77=no
+      ;;
+    esac
+  fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs_F77" >&5
+$as_echo "$ld_shlibs_F77" >&6; }
+test "$ld_shlibs_F77" = no && can_build_shared=no
+
+#
+# Do we need to explicitly link libc?
+#
+case "x$archive_cmds_need_lc_F77" in
+x|xyes)
+  # Assume -lc should be added
+  archive_cmds_need_lc_F77=yes
+
+  if test "$enable_shared" = yes && test "$GCC" = yes; then
+    case $archive_cmds_F77 in
+    *'~'*)
+      # FIXME: we may have to deal with multi-command sequences.
+      ;;
+    '$CC '*)
+      # Test whether the compiler implicitly links with -lc since on some
+      # systems, -lgcc has to come before -lc. If gcc already passes -lc
+      # to ld, don't add -lc before -lgcc.
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
+$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
+      $rm conftest*
+      printf "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+      if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } 2>conftest.err; then
+        soname=conftest
+        lib=conftest
+        libobjs=conftest.$ac_objext
+        deplibs=
+        wl=$lt_prog_compiler_wl_F77
+	pic_flag=$lt_prog_compiler_pic_F77
+        compiler_flags=-v
+        linker_flags=-v
+        verstring=
+        output_objdir=.
+        libname=conftest
+        lt_save_allow_undefined_flag=$allow_undefined_flag_F77
+        allow_undefined_flag_F77=
+        if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds_F77 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1\""; } >&5
+  (eval $archive_cmds_F77 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+        then
+	  archive_cmds_need_lc_F77=no
+        else
+	  archive_cmds_need_lc_F77=yes
+        fi
+        allow_undefined_flag_F77=$lt_save_allow_undefined_flag
+      else
+        cat conftest.err 1>&5
+      fi
+      $rm conftest*
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $archive_cmds_need_lc_F77" >&5
+$as_echo "$archive_cmds_need_lc_F77" >&6; }
+      ;;
+    esac
+  fi
+  ;;
+esac
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
+$as_echo_n "checking dynamic linker characteristics... " >&6; }
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+shrext_cmds=".so"
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+if test "$GCC" = yes; then
+  sys_lib_search_path_spec=`$CC -print-search-dirs | grep "^libraries:" | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+  if echo "$sys_lib_search_path_spec" | grep ';' >/dev/null ; then
+    # if the path contains ";" then we assume it to be the separator
+    # otherwise default to the standard path separator (i.e. ":") - it is
+    # assumed that no part of a normal pathname contains ";" but that should
+    # okay in the real world where ";" in dirpaths is itself problematic.
+    sys_lib_search_path_spec=`echo "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
+  else
+    sys_lib_search_path_spec=`echo "$sys_lib_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+  fi
 else
-  ac_cv_lib_dld_dld_link=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_dld_link" >&5
-$as_echo "$ac_cv_lib_dld_dld_link" >&6; }
-if test "x$ac_cv_lib_dld_dld_link" = x""yes; then :
-  lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
 fi
+need_lib_prefix=unknown
+hardcode_into_libs=no
 
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+need_version=unknown
 
-fi
+case $host_os in
+aix3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  shlibpath_var=LIBPATH
 
+  # AIX 3 has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}${shared_ext}$major'
+  ;;
 
-fi
+aix4* | aix5*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[01] | aix4.[01].*)
+      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	   echo ' yes '
+	   echo '#endif'; } | ${CC} -E - | grep yes > /dev/null; then
+	:
+      else
+	can_build_shared=no
+      fi
+      ;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # soname into executable. Probably we can add versioning support to
+    # collect2, so additional links can be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}${shared_ext}$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  ;;
 
+amigaos*)
+  library_names_spec='$libname.ixlibrary $libname.a'
+  # Create ${libname}_ixlibrary.a entries in /sys/libs.
+  finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$echo "X$lib" | $Xsed -e '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $rm /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+  ;;
 
-fi
+beos*)
+  library_names_spec='${libname}${shared_ext}'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
 
+bsdi[45]*)
+  version_type=linux
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
 
-fi
+cygwin* | mingw* | pw32*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
 
+  case $GCC,$host_os in
+  yes,cygwin* | yes,mingw* | yes,pw32*)
+    library_names_spec='$libname.dll.a'
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i;echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname~
+      chmod a+x \$dldir/$dlname'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $rm \$dlpath'
+    shlibpath_overrides_runpath=yes
 
-fi
+    case $host_os in
+    cygwin*)
+      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
+      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      sys_lib_search_path_spec="/usr/lib /lib/w32api /lib /usr/local/lib"
+      ;;
+    mingw*)
+      # MinGW DLLs use traditional 'lib' prefix
+      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      sys_lib_search_path_spec=`$CC -print-search-dirs | grep "^libraries:" | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+      if echo "$sys_lib_search_path_spec" | grep ';[c-zC-Z]:/' >/dev/null; then
+        # It is most probably a Windows format PATH printed by
+        # mingw gcc, but we are running on Cygwin. Gcc prints its search
+        # path with ; separators, and with drive letters. We can handle the
+        # drive letters (cygwin fileutils understands them), so leave them,
+        # especially as we might pass files found there to a mingw objdump,
+        # which wouldn't understand a cygwinified path. Ahh.
+        sys_lib_search_path_spec=`echo "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
+      else
+        sys_lib_search_path_spec=`echo "$sys_lib_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+      fi
+      ;;
+    pw32*)
+      # pw32 DLLs use 'pw' prefix rather than 'lib'
+      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    esac
+    ;;
 
+  *)
+    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
     ;;
   esac
+  dynamic_linker='Win32 ld.exe'
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
 
-  if test "x$lt_cv_dlopen" != xno; then
-    enable_dlopen=yes
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${versuffix}$shared_ext ${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  soname_spec='${libname}${release}${major}$shared_ext'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
+  # Apple's gcc prints 'gcc -print-search-dirs' doesn't operate the same.
+  if test "$GCC" = yes; then
+    sys_lib_search_path_spec=`$CC -print-search-dirs | tr "\n" "$PATH_SEPARATOR" | sed -e 's/libraries:/@libraries:/' | tr "@" "\n" | grep "^libraries:" | sed -e "s/^libraries://" -e "s,=/,/,g" -e "s,$PATH_SEPARATOR, ,g" -e "s,.*,& /lib /usr/lib /usr/local/lib,g"`
   else
-    enable_dlopen=no
+    sys_lib_search_path_spec='/lib /usr/lib /usr/local/lib'
   fi
+  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
+  ;;
 
-  case $lt_cv_dlopen in
-  dlopen)
-    save_CPPFLAGS="$CPPFLAGS"
-    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
+dgux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
 
-    save_LDFLAGS="$LDFLAGS"
-    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
+freebsd1*)
+  dynamic_linker=no
+  ;;
 
-    save_LIBS="$LIBS"
-    LIBS="$lt_cv_dlopen_libs $LIBS"
+kfreebsd*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='GNU ld.so'
+  ;;
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program can dlopen itself" >&5
-$as_echo_n "checking whether a program can dlopen itself... " >&6; }
-if test "${lt_cv_dlopen_self+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  	  if test "$cross_compiling" = yes; then :
-  lt_cv_dlopen_self=cross
-else
-  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
-  lt_status=$lt_dlunknown
-  cat > conftest.$ac_ext <<_LT_EOF
-#line 11384 "configure"
-#include "confdefs.h"
+freebsd* | dragonfly*)
+  # DragonFly does not have aout.  When/if they implement a new
+  # versioning mechanism, adjust this.
+  if test -x /usr/bin/objformat; then
+    objformat=`/usr/bin/objformat`
+  else
+    case $host_os in
+    freebsd[123]*) objformat=aout ;;
+    *) objformat=elf ;;
+    esac
+  fi
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  freebsd3.[01]* | freebsdelf3.[01]*)
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
+  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  freebsd*) # from 4.6 on
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
 
-#if HAVE_DLFCN_H
-#include <dlfcn.h>
-#endif
+gnu*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  ;;
 
-#include <stdio.h>
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  case $host_cpu in
+  ia64*)
+    shrext_cmds='.so'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.so"
+    shlibpath_var=LD_LIBRARY_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    if test "X$HPUX_IA64_MODE" = X32; then
+      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+    else
+      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    fi
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+   hppa*64*)
+     shrext_cmds='.sl'
+     hardcode_into_libs=yes
+     dynamic_linker="$host_os dld.sl"
+     shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+     shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+     library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+     soname_spec='${libname}${release}${shared_ext}$major'
+     sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+     sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+     ;;
+   *)
+    shrext_cmds='.sl'
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=SHLIB_PATH
+    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    ;;
+  esac
+  # HP-UX runs *really* slowly unless shared libraries are mode 555.
+  postinstall_cmds='chmod 555 $lib'
+  ;;
 
-#ifdef RTLD_GLOBAL
-#  define LT_DLGLOBAL		RTLD_GLOBAL
-#else
-#  ifdef DL_GLOBAL
-#    define LT_DLGLOBAL		DL_GLOBAL
-#  else
-#    define LT_DLGLOBAL		0
-#  endif
-#endif
+interix3*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
 
-/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
-   find out it does not work in some platform. */
-#ifndef LT_DLLAZY_OR_NOW
-#  ifdef RTLD_LAZY
-#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
-#  else
-#    ifdef DL_LAZY
-#      define LT_DLLAZY_OR_NOW		DL_LAZY
-#    else
-#      ifdef RTLD_NOW
-#        define LT_DLLAZY_OR_NOW	RTLD_NOW
-#      else
-#        ifdef DL_NOW
-#          define LT_DLLAZY_OR_NOW	DL_NOW
-#        else
-#          define LT_DLLAZY_OR_NOW	0
-#        endif
-#      endif
-#    endif
-#  endif
-#endif
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)
+	if test "$lt_cv_prog_gnu_ld" = yes; then
+		version_type=linux
+	else
+		version_type=irix
+	fi ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
+      libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
+      libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
+      libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  hardcode_into_libs=yes
+  ;;
 
-void fnord() { int i=42;}
-int main ()
-{
-  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
-  int status = $lt_dlunknown;
+# No shared lib support for Linux oldld, aout, or coff.
+linux*oldld* | linux*aout* | linux*coff*)
+  dynamic_linker=no
+  ;;
 
-  if (self)
-    {
-      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
-      else if (dlsym( self,"_fnord")) status = $lt_dlneed_uscore;
-      /* dlclose (self); */
-    }
-  else
-    puts (dlerror ());
+# This must be Linux ELF.
+linux*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
 
-  return status;
-}
-_LT_EOF
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
-  (eval $ac_link) 2>&5
+  # find out which ABI we are using
+  libsuff=
+  case "$host_cpu" in
+  x86_64*|s390x*|powerpc64*)
+    echo '#line 15101 "configure"' > conftest.$ac_ext
+    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
   ac_status=$?
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
-    (./conftest; exit; ) >&5 2>/dev/null
-    lt_status=$?
-    case x$lt_status in
-      x$lt_dlno_uscore) lt_cv_dlopen_self=yes ;;
-      x$lt_dlneed_uscore) lt_cv_dlopen_self=yes ;;
-      x$lt_dlunknown|x*) lt_cv_dlopen_self=no ;;
-    esac
-  else :
-    # compilation failed
-    lt_cv_dlopen_self=no
-  fi
-fi
-rm -fr conftest*
-
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self" >&5
-$as_echo "$lt_cv_dlopen_self" >&6; }
+  test $ac_status = 0; }; then
+      case `/usr/bin/file conftest.$ac_objext` in
+      *64-bit*)
+        libsuff=64
+        sys_lib_search_path_spec="/lib${libsuff} /usr/lib${libsuff} /usr/local/lib${libsuff}"
+        ;;
+      esac
+    fi
+    rm -rf conftest*
+    ;;
+  esac
 
-    if test "x$lt_cv_dlopen_self" = xyes; then
-      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a statically linked program can dlopen itself" >&5
-$as_echo_n "checking whether a statically linked program can dlopen itself... " >&6; }
-if test "${lt_cv_dlopen_self_static+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  	  if test "$cross_compiling" = yes; then :
-  lt_cv_dlopen_self_static=cross
-else
-  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
-  lt_status=$lt_dlunknown
-  cat > conftest.$ac_ext <<_LT_EOF
-#line 11480 "configure"
-#include "confdefs.h"
+  # Append ld.so.conf contents to the search path
+  if test -f /etc/ld.so.conf; then
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib${libsuff} /usr/lib${libsuff} $lt_ld_extra"
+  fi
 
-#if HAVE_DLFCN_H
-#include <dlfcn.h>
-#endif
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
 
-#include <stdio.h>
+knetbsd*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='GNU ld.so'
+  ;;
 
-#ifdef RTLD_GLOBAL
-#  define LT_DLGLOBAL		RTLD_GLOBAL
-#else
-#  ifdef DL_GLOBAL
-#    define LT_DLGLOBAL		DL_GLOBAL
-#  else
-#    define LT_DLGLOBAL		0
-#  endif
-#endif
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
 
-/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
-   find out it does not work in some platform. */
-#ifndef LT_DLLAZY_OR_NOW
-#  ifdef RTLD_LAZY
-#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
-#  else
-#    ifdef DL_LAZY
-#      define LT_DLLAZY_OR_NOW		DL_LAZY
-#    else
-#      ifdef RTLD_NOW
-#        define LT_DLLAZY_OR_NOW	RTLD_NOW
-#      else
-#        ifdef DL_NOW
-#          define LT_DLLAZY_OR_NOW	DL_NOW
-#        else
-#          define LT_DLLAZY_OR_NOW	0
-#        endif
-#      endif
-#    endif
-#  endif
-#endif
+newsos6)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
 
-void fnord() { int i=42;}
-int main ()
-{
-  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
-  int status = $lt_dlunknown;
+nto-qnx*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
 
-  if (self)
-    {
-      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
-      else if (dlsym( self,"_fnord")) status = $lt_dlneed_uscore;
-      /* dlclose (self); */
-    }
+openbsd*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec="/usr/lib"
+  need_lib_prefix=no
+  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
+  case $host_os in
+    openbsd3.3 | openbsd3.3.*) need_version=yes ;;
+    *)                         need_version=no  ;;
+  esac
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case $host_os in
+      openbsd2.[89] | openbsd2.[89].*)
+	shlibpath_overrides_runpath=no
+	;;
+      *)
+	shlibpath_overrides_runpath=yes
+	;;
+      esac
   else
-    puts (dlerror ());
-
-  return status;
-}
-_LT_EOF
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
-    (./conftest; exit; ) >&5 2>/dev/null
-    lt_status=$?
-    case x$lt_status in
-      x$lt_dlno_uscore) lt_cv_dlopen_self_static=yes ;;
-      x$lt_dlneed_uscore) lt_cv_dlopen_self_static=yes ;;
-      x$lt_dlunknown|x*) lt_cv_dlopen_self_static=no ;;
-    esac
-  else :
-    # compilation failed
-    lt_cv_dlopen_self_static=no
+    shlibpath_overrides_runpath=yes
   fi
-fi
-rm -fr conftest*
+  ;;
 
+os2*)
+  libname_spec='$name'
+  shrext_cmds=".dll"
+  need_lib_prefix=no
+  library_names_spec='$libname${shared_ext} $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self_static" >&5
-$as_echo "$lt_cv_dlopen_self_static" >&6; }
-    fi
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  ;;
 
-    CPPFLAGS="$save_CPPFLAGS"
-    LDFLAGS="$save_LDFLAGS"
-    LIBS="$save_LIBS"
-    ;;
-  esac
+solaris*)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
 
-  case $lt_cv_dlopen_self in
-  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
-  *) enable_dlopen_self=unknown ;;
-  esac
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
 
-  case $lt_cv_dlopen_self_static in
-  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
-  *) enable_dlopen_self_static=unknown ;;
+sysv4 | sysv4.3*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      export_dynamic_flag_spec='${wl}-Blargedynsym'
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
   esac
-fi
-
+  ;;
 
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux
+    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
+    soname_spec='$libname${shared_ext}.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
 
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  version_type=freebsd-elf
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  hardcode_into_libs=yes
+  if test "$with_gnu_ld" = yes; then
+    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+    shlibpath_overrides_runpath=no
+  else
+    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    shlibpath_overrides_runpath=yes
+    case $host_os in
+      sco3.2v5*)
+        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
+	;;
+    esac
+  fi
+  sys_lib_dlsearch_path_spec='/usr/lib'
+  ;;
 
+uts4*)
+  version_type=linux
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
 
+*)
+  dynamic_linker=no
+  ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
+$as_echo "$dynamic_linker" >&6; }
+test "$dynamic_linker" = no && can_build_shared=no
 
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
+$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
+hardcode_action_F77=
+if test -n "$hardcode_libdir_flag_spec_F77" || \
+   test -n "$runpath_var_F77" || \
+   test "X$hardcode_automatic_F77" = "Xyes" ; then
 
+  # We can hardcode non-existant directories.
+  if test "$hardcode_direct_F77" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$_LT_AC_TAGVAR(hardcode_shlibpath_var, F77)" != no &&
+     test "$hardcode_minus_L_F77" != no; then
+    # Linking always hardcodes the temporary library directory.
+    hardcode_action_F77=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    hardcode_action_F77=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  hardcode_action_F77=unsupported
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action_F77" >&5
+$as_echo "$hardcode_action_F77" >&6; }
 
+if test "$hardcode_action_F77" = relink; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
 
 
+# The else clause should only fire when bootstrapping the
+# libtool distribution, otherwise you forgot to ship ltmain.sh
+# with your package, and you will get complaints that there are
+# no rules to generate ltmain.sh.
+if test -f "$ltmain"; then
+  # See if we are running on zsh, and set the options which allow our commands through
+  # without removal of \ escapes.
+  if test -n "${ZSH_VERSION+set}" ; then
+    setopt NO_GLOB_SUBST
+  fi
+  # Now quote all the things that may contain metacharacters while being
+  # careful not to overquote the AC_SUBSTed values.  We take copies of the
+  # variables and quote the copies for generation of the libtool script.
+  for var in echo old_CC old_CFLAGS AR AR_FLAGS EGREP RANLIB LN_S LTCC LTCFLAGS NM \
+    SED SHELL STRIP \
+    libname_spec library_names_spec soname_spec extract_expsyms_cmds \
+    old_striplib striplib file_magic_cmd finish_cmds finish_eval \
+    deplibs_check_method reload_flag reload_cmds need_locks \
+    lt_cv_sys_global_symbol_pipe lt_cv_sys_global_symbol_to_cdecl \
+    lt_cv_sys_global_symbol_to_c_name_address \
+    sys_lib_search_path_spec sys_lib_dlsearch_path_spec \
+    old_postinstall_cmds old_postuninstall_cmds \
+    compiler_F77 \
+    CC_F77 \
+    LD_F77 \
+    lt_prog_compiler_wl_F77 \
+    lt_prog_compiler_pic_F77 \
+    lt_prog_compiler_static_F77 \
+    lt_prog_compiler_no_builtin_flag_F77 \
+    export_dynamic_flag_spec_F77 \
+    thread_safe_flag_spec_F77 \
+    whole_archive_flag_spec_F77 \
+    enable_shared_with_static_runtimes_F77 \
+    old_archive_cmds_F77 \
+    old_archive_from_new_cmds_F77 \
+    predep_objects_F77 \
+    postdep_objects_F77 \
+    predeps_F77 \
+    postdeps_F77 \
+    compiler_lib_search_path_F77 \
+    archive_cmds_F77 \
+    archive_expsym_cmds_F77 \
+    postinstall_cmds_F77 \
+    postuninstall_cmds_F77 \
+    old_archive_from_expsyms_cmds_F77 \
+    allow_undefined_flag_F77 \
+    no_undefined_flag_F77 \
+    export_symbols_cmds_F77 \
+    hardcode_libdir_flag_spec_F77 \
+    hardcode_libdir_flag_spec_ld_F77 \
+    hardcode_libdir_separator_F77 \
+    hardcode_automatic_F77 \
+    module_cmds_F77 \
+    module_expsym_cmds_F77 \
+    lt_cv_prog_compiler_c_o_F77 \
+    exclude_expsyms_F77 \
+    include_expsyms_F77; do
+
+    case $var in
+    old_archive_cmds_F77 | \
+    old_archive_from_new_cmds_F77 | \
+    archive_cmds_F77 | \
+    archive_expsym_cmds_F77 | \
+    module_cmds_F77 | \
+    module_expsym_cmds_F77 | \
+    old_archive_from_expsyms_cmds_F77 | \
+    export_symbols_cmds_F77 | \
+    extract_expsyms_cmds | reload_cmds | finish_cmds | \
+    postinstall_cmds | postuninstall_cmds | \
+    old_postinstall_cmds | old_postuninstall_cmds | \
+    sys_lib_search_path_spec | sys_lib_dlsearch_path_spec)
+      # Double-quote double-evaled strings.
+      eval "lt_$var=\\\"\`\$echo \"X\$$var\" | \$Xsed -e \"\$double_quote_subst\" -e \"\$sed_quote_subst\" -e \"\$delay_variable_subst\"\`\\\""
+      ;;
+    *)
+      eval "lt_$var=\\\"\`\$echo \"X\$$var\" | \$Xsed -e \"\$sed_quote_subst\"\`\\\""
+      ;;
+    esac
+  done
 
+  case $lt_echo in
+  *'\$0 --fallback-echo"')
+    lt_echo=`$echo "X$lt_echo" | $Xsed -e 's/\\\\\\\$0 --fallback-echo"$/$0 --fallback-echo"/'`
+    ;;
+  esac
 
+cfgfile="$ofile"
 
+  cat <<__EOF__ >> "$cfgfile"
+# ### BEGIN LIBTOOL TAG CONFIG: $tagname
 
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
 
+# Shell to use when invoking shell scripts.
+SHELL=$lt_SHELL
 
-striplib=
-old_striplib=
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stripping libraries is possible" >&5
-$as_echo_n "checking whether stripping libraries is possible... " >&6; }
-if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
-  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
-  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-# FIXME - insert some real tests, host_os isn't really good enough
-  case $host_os in
-  darwin*)
-    if test -n "$STRIP" ; then
-      striplib="$STRIP -x"
-      old_striplib="$STRIP -S"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-    else
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-    fi
-    ;;
-  *)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-    ;;
-  esac
-fi
+# Whether or not to build shared libraries.
+build_libtool_libs=$enable_shared
 
+# Whether or not to build static libraries.
+build_old_libs=$enable_static
 
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=$archive_cmds_need_lc_F77
 
+# Whether or not to disallow shared libs when runtime libs are static
+allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes_F77
 
+# Whether or not to optimize for fast installation.
+fast_install=$enable_fast_install
 
+# The host system.
+host_alias=$host_alias
+host=$host
+host_os=$host_os
 
+# The build system.
+build_alias=$build_alias
+build=$build
+build_os=$build_os
 
+# An echo program that does not interpret backslashes.
+echo=$lt_echo
 
+# The archiver.
+AR=$lt_AR
+AR_FLAGS=$lt_AR_FLAGS
 
+# A C compiler.
+LTCC=$lt_LTCC
 
+# LTCC compiler flags.
+LTCFLAGS=$lt_LTCFLAGS
 
+# A language-specific compiler.
+CC=$lt_compiler_F77
 
-  # Report which library types will actually be built
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if libtool supports shared libraries" >&5
-$as_echo_n "checking if libtool supports shared libraries... " >&6; }
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $can_build_shared" >&5
-$as_echo "$can_build_shared" >&6; }
+# Is the compiler the GNU C compiler?
+with_gcc=$GCC_F77
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build shared libraries" >&5
-$as_echo_n "checking whether to build shared libraries... " >&6; }
-  test "$can_build_shared" = "no" && enable_shared=no
+gcc_dir=\`gcc -print-file-name=. | $SED 's,/\.$,,'\`
+gcc_ver=\`gcc -dumpversion\`
 
-  # On AIX, shared libraries and static libraries use the same namespace, and
-  # are all built from PIC.
-  case $host_os in
-  aix3*)
-    test "$enable_shared" = yes && enable_static=no
-    if test -n "$RANLIB"; then
-      archive_cmds="$archive_cmds~\$RANLIB \$lib"
-      postinstall_cmds='$RANLIB $lib'
-    fi
-    ;;
+# An ERE matcher.
+EGREP=$lt_EGREP
 
-  aix[4-9]*)
-    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
-      test "$enable_shared" = yes && enable_static=no
-    fi
-    ;;
-  esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_shared" >&5
-$as_echo "$enable_shared" >&6; }
+# The linker used to build libraries.
+LD=$lt_LD_F77
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build static libraries" >&5
-$as_echo_n "checking whether to build static libraries... " >&6; }
-  # Make sure either enable_shared or enable_static is yes.
-  test "$enable_shared" = yes || enable_static=yes
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_static" >&5
-$as_echo "$enable_static" >&6; }
+# Whether we need hard or soft links.
+LN_S=$lt_LN_S
 
+# A BSD-compatible nm program.
+NM=$lt_NM
 
+# A symbol stripping program
+STRIP=$lt_STRIP
 
+# Used to examine libraries when file_magic_cmd begins "file"
+MAGIC_CMD=$MAGIC_CMD
 
-fi
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+# Used on cygwin: DLL creation program.
+DLLTOOL="$DLLTOOL"
 
-CC="$lt_save_CC"
+# Used on cygwin: object dumper.
+OBJDUMP="$OBJDUMP"
 
+# Used on cygwin: assembler.
+AS="$AS"
 
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+# The name of the directory that contains temporary libtool files.
+objdir=$objdir
 
-archive_cmds_need_lc_CXX=no
-allow_undefined_flag_CXX=
-always_export_symbols_CXX=no
-archive_expsym_cmds_CXX=
-compiler_needs_object_CXX=no
-export_dynamic_flag_spec_CXX=
-hardcode_direct_CXX=no
-hardcode_direct_absolute_CXX=no
-hardcode_libdir_flag_spec_CXX=
-hardcode_libdir_flag_spec_ld_CXX=
-hardcode_libdir_separator_CXX=
-hardcode_minus_L_CXX=no
-hardcode_shlibpath_var_CXX=unsupported
-hardcode_automatic_CXX=no
-inherit_rpath_CXX=no
-module_cmds_CXX=
-module_expsym_cmds_CXX=
-link_all_deplibs_CXX=unknown
-old_archive_cmds_CXX=$old_archive_cmds
-no_undefined_flag_CXX=
-whole_archive_flag_spec_CXX=
-enable_shared_with_static_runtimes_CXX=no
+# How to create reloadable object files.
+reload_flag=$lt_reload_flag
+reload_cmds=$lt_reload_cmds
 
-# Source file extension for C++ test sources.
-ac_ext=cpp
+# How to pass a linker flag through the compiler.
+wl=$lt_lt_prog_compiler_wl_F77
 
-# Object file extension for compiled C++ test sources.
-objext=o
-objext_CXX=$objext
+# Object file suffix (normally "o").
+objext="$ac_objext"
 
-# No sense in running all these tests if we already determined that
-# the CXX compiler isn't working.  Some variables (like enable_shared)
-# are currently assumed to apply to all compilers on this platform,
-# and will be corrupted by setting them based on a non-working compiler.
-if test "$_lt_caught_CXX_error" != yes; then
-  # Code to be used in simple compile tests
-  lt_simple_compile_test_code="int some_variable = 0;"
+# Old archive suffix (normally "a").
+libext="$libext"
 
-  # Code to be used in simple link tests
-  lt_simple_link_test_code='int main(int, char *[]) { return(0); }'
+# Shared library suffix (normally ".so").
+shrext_cmds='$shrext_cmds'
 
-  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+# Executable file suffix (normally "").
+exeext="$exeext"
 
+# Additional compiler flags for building library objects.
+pic_flag=$lt_lt_prog_compiler_pic_F77
+pic_mode=$pic_mode
 
+# What is the maximum length of a command?
+max_cmd_len=$lt_cv_sys_max_cmd_len
 
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o=$lt_lt_cv_prog_compiler_c_o_F77
 
+# Must we lock files when doing compilation?
+need_locks=$lt_need_locks
 
+# Do we need the lib prefix for modules?
+need_lib_prefix=$need_lib_prefix
 
-# If no C compiler was specified, use CC.
-LTCC=${LTCC-"$CC"}
+# Do we need a version for libraries?
+need_version=$need_version
 
-# If no C compiler flags were specified, use CFLAGS.
-LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+# Whether dlopen is supported.
+dlopen_support=$enable_dlopen
 
-# Allow CC to be a program name with arguments.
-compiler=$CC
+# Whether dlopen of programs is supported.
+dlopen_self=$enable_dlopen_self
 
+# Whether dlopen of statically linked programs is supported.
+dlopen_self_static=$enable_dlopen_self_static
 
-  # save warnings/boilerplate of simple test code
-  ac_outfile=conftest.$ac_objext
-echo "$lt_simple_compile_test_code" >conftest.$ac_ext
-eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
-_lt_compiler_boilerplate=`cat conftest.err`
-$RM conftest*
+# Compiler flag to prevent dynamic linking.
+link_static_flag=$lt_lt_prog_compiler_static_F77
 
-  ac_outfile=conftest.$ac_objext
-echo "$lt_simple_link_test_code" >conftest.$ac_ext
-eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
-_lt_linker_boilerplate=`cat conftest.err`
-$RM -r conftest*
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag_F77
 
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec=$lt_export_dynamic_flag_spec_F77
 
-  # Allow CC to be a program name with arguments.
-  lt_save_CC=$CC
-  lt_save_LD=$LD
-  lt_save_GCC=$GCC
-  GCC=$GXX
-  lt_save_with_gnu_ld=$with_gnu_ld
-  lt_save_path_LD=$lt_cv_path_LD
-  if test -n "${lt_cv_prog_gnu_ldcxx+set}"; then
-    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx
-  else
-    $as_unset lt_cv_prog_gnu_ld
-  fi
-  if test -n "${lt_cv_path_LDCXX+set}"; then
-    lt_cv_path_LD=$lt_cv_path_LDCXX
-  else
-    $as_unset lt_cv_path_LD
-  fi
-  test -z "${LDCXX+set}" || LD=$LDCXX
-  CC=${CXX-"c++"}
-  compiler=$CC
-  compiler_CXX=$CC
-  for cc_temp in $compiler""; do
-  case $cc_temp in
-    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
-    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
-    \-*) ;;
-    *) break;;
-  esac
-done
-cc_basename=`$ECHO "X$cc_temp" | $Xsed -e 's%.*/%%' -e "s%^$host_alias-%%"`
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec=$lt_whole_archive_flag_spec_F77
 
+# Compiler flag to generate thread-safe objects.
+thread_safe_flag_spec=$lt_thread_safe_flag_spec_F77
 
-  if test -n "$compiler"; then
-    # We don't want -fno-exception when compiling C++ code, so set the
-    # no_builtin_flag separately
-    if test "$GXX" = yes; then
-      lt_prog_compiler_no_builtin_flag_CXX=' -fno-builtin'
-    else
-      lt_prog_compiler_no_builtin_flag_CXX=
-    fi
+# Library versioning type.
+version_type=$version_type
 
-    if test "$GXX" = yes; then
-      # Set up default GNU C++ configuration
+# Format of library name prefix.
+libname_spec=$lt_libname_spec
 
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME.
+library_names_spec=$lt_library_names_spec
 
+# The coded name of the library, if different from the real name.
+soname_spec=$lt_soname_spec
 
-# Check whether --with-gnu-ld was given.
-if test "${with_gnu_ld+set}" = set; then :
-  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
-else
-  with_gnu_ld=no
-fi
+# Commands used to build and install an old-style archive.
+RANLIB=$lt_RANLIB
+old_archive_cmds=$lt_old_archive_cmds_F77
+old_postinstall_cmds=$lt_old_postinstall_cmds
+old_postuninstall_cmds=$lt_old_postuninstall_cmds
 
-ac_prog=ld
-if test "$GCC" = yes; then
-  # Check if gcc -print-prog-name=ld gives a path.
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
-$as_echo_n "checking for ld used by $CC... " >&6; }
-  case $host in
-  *-*-mingw*)
-    # gcc leaves a trailing carriage return which upsets mingw
-    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
-  *)
-    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
-  esac
-  case $ac_prog in
-    # Accept absolute paths.
-    [\\/]* | ?:[\\/]*)
-      re_direlt='/[^/][^/]*/\.\./'
-      # Canonicalize the pathname of ld
-      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
-      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
-	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
-      done
-      test -z "$LD" && LD="$ac_prog"
-      ;;
-  "")
-    # If it fails, then pretend we aren't using GCC.
-    ac_prog=ld
-    ;;
-  *)
-    # If it is relative, then search for the first ld in PATH.
-    with_gnu_ld=unknown
-    ;;
-  esac
-elif test "$with_gnu_ld" = yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
-$as_echo_n "checking for GNU ld... " >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for non-GNU ld" >&5
-$as_echo_n "checking for non-GNU ld... " >&6; }
-fi
-if test "${lt_cv_path_LD+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$LD"; then
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-  for ac_dir in $PATH; do
-    IFS="$lt_save_ifs"
-    test -z "$ac_dir" && ac_dir=.
-    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
-      lt_cv_path_LD="$ac_dir/$ac_prog"
-      # Check to see if the program is GNU ld.  I'd rather use --version,
-      # but apparently some variants of GNU ld only accept -v.
-      # Break only if it was the GNU/non-GNU ld that we prefer.
-      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
-      *GNU* | *'with BFD'*)
-	test "$with_gnu_ld" != no && break
-	;;
-      *)
-	test "$with_gnu_ld" != yes && break
-	;;
-      esac
-    fi
-  done
-  IFS="$lt_save_ifs"
-else
-  lt_cv_path_LD="$LD" # Let the user override the test with a path.
-fi
-fi
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=$lt_old_archive_from_new_cmds_F77
 
-LD="$lt_cv_path_LD"
-if test -n "$LD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
-$as_echo "$LD" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-test -z "$LD" && as_fn_error "no acceptable ld found in \$PATH" "$LINENO" 5
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
-$as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
-if test "${lt_cv_prog_gnu_ld+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  # I'd rather use --version here, but apparently some GNU lds only accept -v.
-case `$LD -v 2>&1 </dev/null` in
-*GNU* | *'with BFD'*)
-  lt_cv_prog_gnu_ld=yes
-  ;;
-*)
-  lt_cv_prog_gnu_ld=no
-  ;;
-esac
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_gnu_ld" >&5
-$as_echo "$lt_cv_prog_gnu_ld" >&6; }
-with_gnu_ld=$lt_cv_prog_gnu_ld
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds_F77
 
+# Commands used to build and install a shared archive.
+archive_cmds=$lt_archive_cmds_F77
+archive_expsym_cmds=$lt_archive_expsym_cmds_F77
+postinstall_cmds=$lt_postinstall_cmds
+postuninstall_cmds=$lt_postuninstall_cmds
 
+# Commands used to build a loadable module (assumed same as above if empty)
+module_cmds=$lt_module_cmds_F77
+module_expsym_cmds=$lt_module_expsym_cmds_F77
 
+# Commands to strip libraries.
+old_striplib=$lt_old_striplib
+striplib=$lt_striplib
 
+# Dependencies to place before the objects being linked to create a
+# shared library.
+predep_objects=\`echo $lt_predep_objects_F77 | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
+
+# Dependencies to place after the objects being linked to create a
+# shared library.
+postdep_objects=\`echo $lt_postdep_objects_F77 | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
+
+# Dependencies to place before the objects being linked to create a
+# shared library.
+predeps=$lt_predeps_F77
+
+# Dependencies to place after the objects being linked to create a
+# shared library.
+postdeps=$lt_postdeps_F77
 
+# The library search path used internally by the compiler when linking
+# a shared library.
+compiler_lib_search_path=\`echo $lt_compiler_lib_search_path_F77 | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
 
+# Method to check whether dependent libraries are shared objects.
+deplibs_check_method=$lt_deplibs_check_method
 
-      # Check if GNU C++ uses GNU ld as the underlying linker, since the
-      # archiving commands below assume that GNU ld is being used.
-      if test "$with_gnu_ld" = yes; then
-        archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
-        archive_expsym_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-
-        hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
-        export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
-
-        # If archive_cmds runs LD, not CC, wlarc should be empty
-        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to
-        #     investigate it a little bit more. (MM)
-        wlarc='${wl}'
-
-        # ancient GNU ld didn't support --whole-archive et. al.
-        if eval "`$CC -print-prog-name=ld` --help 2>&1" |
-	  $GREP 'no-whole-archive' > /dev/null; then
-          whole_archive_flag_spec_CXX="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
-        else
-          whole_archive_flag_spec_CXX=
-        fi
-      else
-        with_gnu_ld=no
-        wlarc=
+# Command to use when deplibs_check_method == file_magic.
+file_magic_cmd=$lt_file_magic_cmd
 
-        # A generic and very simple default shared library creation
-        # command for GNU C++ for the case where it uses the native
-        # linker, instead of GNU ld.  If possible, this setting should
-        # overridden to take advantage of the native linker features on
-        # the platform it is being used on.
-        archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
-      fi
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=$lt_allow_undefined_flag_F77
 
-      # Commands to make compiler produce verbose output that lists
-      # what "hidden" libraries, object files and flags are used when
-      # linking a shared library.
-      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "\-L"'
+# Flag that forces no undefined symbols.
+no_undefined_flag=$lt_no_undefined_flag_F77
 
-    else
-      GXX=no
-      with_gnu_ld=no
-      wlarc=
-    fi
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds=$lt_finish_cmds
 
-    # PORTME: fill in a description of your system's C++ link characteristics
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
-$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
-    ld_shlibs_CXX=yes
-    case $host_os in
-      aix3*)
-        # FIXME: insert proper C++ library support
-        ld_shlibs_CXX=no
-        ;;
-      aix[4-9]*)
-        if test "$host_cpu" = ia64; then
-          # On IA64, the linker does run time linking by default, so we don't
-          # have to do anything special.
-          aix_use_runtimelinking=no
-          exp_sym_flag='-Bexport'
-          no_entry_flag=""
-        else
-          aix_use_runtimelinking=no
+# Same as above, but a single script fragment to be evaled but not shown.
+finish_eval=$lt_finish_eval
 
-          # Test if we are trying to use run time linking or normal
-          # AIX style linking. If -brtl is somewhere in LDFLAGS, we
-          # need to do runtime linking.
-          case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
-	    for ld_flag in $LDFLAGS; do
-	      case $ld_flag in
-	      *-brtl*)
-	        aix_use_runtimelinking=yes
-	        break
-	        ;;
-	      esac
-	    done
-	    ;;
-          esac
+# Take the output of nm and produce a listing of raw symbols and C names.
+global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe
 
-          exp_sym_flag='-bexport'
-          no_entry_flag='-bnoentry'
-        fi
+# Transform the output of nm in a proper C declaration
+global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl
 
-        # When large executables or shared objects are built, AIX ld can
-        # have problems creating the table of contents.  If linking a library
-        # or program results in "error TOC overflow" add -mminimal-toc to
-        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
-        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
-
-        archive_cmds_CXX=''
-        hardcode_direct_CXX=yes
-        hardcode_direct_absolute_CXX=yes
-        hardcode_libdir_separator_CXX=':'
-        link_all_deplibs_CXX=yes
-        file_list_spec_CXX='${wl}-f,'
-
-        if test "$GXX" = yes; then
-          case $host_os in aix4.[012]|aix4.[012].*)
-          # We only want to do this on AIX 4.2 and lower, the check
-          # below for broken collect2 doesn't work under 4.3+
-	  collect2name=`${CC} -print-prog-name=collect2`
-	  if test -f "$collect2name" &&
-	     strings "$collect2name" | $GREP resolve_lib_name >/dev/null
-	  then
-	    # We have reworked collect2
-	    :
-	  else
-	    # We have old collect2
-	    hardcode_direct_CXX=unsupported
-	    # It fails to find uninstalled libraries when the uninstalled
-	    # path is not listed in the libpath.  Setting hardcode_minus_L
-	    # to unsupported forces relinking
-	    hardcode_minus_L_CXX=yes
-	    hardcode_libdir_flag_spec_CXX='-L$libdir'
-	    hardcode_libdir_separator_CXX=
-	  fi
-          esac
-          shared_flag='-shared'
-	  if test "$aix_use_runtimelinking" = yes; then
-	    shared_flag="$shared_flag "'${wl}-G'
-	  fi
-        else
-          # not using gcc
-          if test "$host_cpu" = ia64; then
-	  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
-	  # chokes on -Wl,-G. The following line is correct:
-	  shared_flag='-G'
-          else
-	    if test "$aix_use_runtimelinking" = yes; then
-	      shared_flag='${wl}-G'
-	    else
-	      shared_flag='${wl}-bM:SRE'
-	    fi
-          fi
-        fi
+# Transform the output of nm in a C name address pair
+global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address
 
-        export_dynamic_flag_spec_CXX='${wl}-bexpall'
-        # It seems that -bexpall does not export symbols beginning with
-        # underscore (_), so it is better to generate a list of symbols to
-	# export.
-        always_export_symbols_CXX=yes
-        if test "$aix_use_runtimelinking" = yes; then
-          # Warning - without using the other runtime loading flags (-brtl),
-          # -berok will link without error, but may produce a broken library.
-          allow_undefined_flag_CXX='-berok'
-          # Determine the default libpath from the value encoded in an empty
-          # executable.
-          cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+# This is the shared library runtime path variable.
+runpath_var=$runpath_var
 
-int
-main ()
-{
+# This is the shared library path variable.
+shlibpath_var=$shlibpath_var
 
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
+# Is shlibpath searched before the hard-coded library search path?
+shlibpath_overrides_runpath=$shlibpath_overrides_runpath
 
-lt_aix_libpath_sed='
-    /Import File Strings/,/^$/ {
-	/^0/ {
-	    s/^0  *\(.*\)$/\1/
-	    p
-	}
-    }'
-aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-# Check for a 64-bit object if we didn't find anything.
-if test -z "$aix_libpath"; then
-  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+# How to hardcode a shared library path into an executable.
+hardcode_action=$hardcode_action_F77
 
-          hardcode_libdir_flag_spec_CXX='${wl}-blibpath:$libdir:'"$aix_libpath"
+# Whether we should hardcode library paths into libraries.
+hardcode_into_libs=$hardcode_into_libs
 
-          archive_expsym_cmds_CXX='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then $ECHO "X${wl}${allow_undefined_flag}" | $Xsed; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
-        else
-          if test "$host_cpu" = ia64; then
-	    hardcode_libdir_flag_spec_CXX='${wl}-R $libdir:/usr/lib:/lib'
-	    allow_undefined_flag_CXX="-z nodefs"
-	    archive_expsym_cmds_CXX="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
-          else
-	    # Determine the default libpath from the value encoded in an
-	    # empty executable.
-	    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec_F77
 
-int
-main ()
-{
+# If ld is used when linking, flag to hardcode \$libdir into
+# a binary during linking. This must work even if \$libdir does
+# not exist.
+hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld_F77
+
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator=$lt_hardcode_libdir_separator_F77
+
+# Set to yes if using DIR/libNAME${shared_ext} during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct=$hardcode_direct_F77
+
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L=$hardcode_minus_L_F77
+
+# Set to yes if using SHLIBPATH_VAR=DIR during linking hardcodes DIR into
+# the resulting binary.
+hardcode_shlibpath_var=$hardcode_shlibpath_var_F77
+
+# Set to yes if building a shared library automatically hardcodes DIR into the library
+# and all subsequent libraries and executables linked against it.
+hardcode_automatic=$hardcode_automatic_F77
 
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
+# Variables whose values should be saved in libtool wrapper scripts and
+# restored at relink time.
+variables_saved_for_relink="$variables_saved_for_relink"
 
-lt_aix_libpath_sed='
-    /Import File Strings/,/^$/ {
-	/^0/ {
-	    s/^0  *\(.*\)$/\1/
-	    p
-	}
-    }'
-aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-# Check for a 64-bit object if we didn't find anything.
-if test -z "$aix_libpath"; then
-  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=$link_all_deplibs_F77
 
-	    hardcode_libdir_flag_spec_CXX='${wl}-blibpath:$libdir:'"$aix_libpath"
-	    # Warning - without using the other run time loading flags,
-	    # -berok will link without error, but may produce a broken library.
-	    no_undefined_flag_CXX=' ${wl}-bernotok'
-	    allow_undefined_flag_CXX=' ${wl}-berok'
-	    # Exported symbols can be pulled into shared objects from archives
-	    whole_archive_flag_spec_CXX='$convenience'
-	    archive_cmds_need_lc_CXX=yes
-	    # This is similar to how AIX traditionally builds its shared
-	    # libraries.
-	    archive_expsym_cmds_CXX="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
-          fi
-        fi
-        ;;
+# Compile-time system search path for libraries
+sys_lib_search_path_spec=\`echo $lt_sys_lib_search_path_spec | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
 
-      beos*)
-	if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	  allow_undefined_flag_CXX=unsupported
-	  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc
-	  # support --undefined.  This deserves some investigation.  FIXME
-	  archive_cmds_CXX='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	else
-	  ld_shlibs_CXX=no
-	fi
-	;;
+# Run-time system search path for libraries
+sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
 
-      chorus*)
-        case $cc_basename in
-          *)
-	  # FIXME: insert proper C++ library support
-	  ld_shlibs_CXX=no
-	  ;;
-        esac
-        ;;
+# Fix the shell variable \$srcfile for the compiler.
+fix_srcfile_path="$fix_srcfile_path_F77"
 
-      cygwin* | mingw* | pw32* | cegcc*)
-        # _LT_TAGVAR(hardcode_libdir_flag_spec, CXX) is actually meaningless,
-        # as there is no search path for DLLs.
-        hardcode_libdir_flag_spec_CXX='-L$libdir'
-        allow_undefined_flag_CXX=unsupported
-        always_export_symbols_CXX=no
-        enable_shared_with_static_runtimes_CXX=yes
-
-        if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
-          archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-          # If the export-symbols file already is a .def file (1st line
-          # is EXPORTS), use it as is; otherwise, prepend...
-          archive_expsym_cmds_CXX='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	    cp $export_symbols $output_objdir/$soname.def;
-          else
-	    echo EXPORTS > $output_objdir/$soname.def;
-	    cat $export_symbols >> $output_objdir/$soname.def;
-          fi~
-          $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-        else
-          ld_shlibs_CXX=no
-        fi
-        ;;
-      darwin* | rhapsody*)
+# Set to yes if exported symbols are required.
+always_export_symbols=$always_export_symbols_F77
 
+# The commands to list exported symbols.
+export_symbols_cmds=$lt_export_symbols_cmds_F77
 
-  archive_cmds_need_lc_CXX=no
-  hardcode_direct_CXX=no
-  hardcode_automatic_CXX=yes
-  hardcode_shlibpath_var_CXX=unsupported
-  whole_archive_flag_spec_CXX=''
-  link_all_deplibs_CXX=yes
-  allow_undefined_flag_CXX="$_lt_dar_allow_undefined"
-  case $cc_basename in
-     ifort*) _lt_dar_can_shared=yes ;;
-     *) _lt_dar_can_shared=$GCC ;;
-  esac
-  if test "$_lt_dar_can_shared" = "yes"; then
-    output_verbose_link_cmd=echo
-    archive_cmds_CXX="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
-    module_cmds_CXX="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
-    archive_expsym_cmds_CXX="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
-    module_expsym_cmds_CXX="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
-       if test "$lt_cv_apple_cc_single_mod" != "yes"; then
-      archive_cmds_CXX="\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dsymutil}"
-      archive_expsym_cmds_CXX="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dar_export_syms}${_lt_dsymutil}"
-    fi
+# The commands to extract the exported symbol list from a shared archive.
+extract_expsyms_cmds=$lt_extract_expsyms_cmds
 
-  else
-  ld_shlibs_CXX=no
-  fi
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms=$lt_exclude_expsyms_F77
 
-	;;
+# Symbols that must always be exported.
+include_expsyms=$lt_include_expsyms_F77
 
-      dgux*)
-        case $cc_basename in
-          ec++*)
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-          ghcx*)
-	    # Green Hills C++ Compiler
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-          *)
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-        esac
-        ;;
+# ### END LIBTOOL TAG CONFIG: $tagname
 
-      freebsd[12]*)
-        # C++ shared libraries reported to be fairly broken before
-	# switch to ELF
-        ld_shlibs_CXX=no
-        ;;
+__EOF__
 
-      freebsd-elf*)
-        archive_cmds_need_lc_CXX=no
-        ;;
 
-      freebsd* | dragonfly*)
-        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF
-        # conventions
-        ld_shlibs_CXX=yes
-        ;;
+else
+  # If there is no Makefile yet, we rely on a make rule to execute
+  # `config.status --recheck' to rerun these tests and create the
+  # libtool script then.
+  ltmain_in=`echo $ltmain | sed -e 's/\.sh$/.in/'`
+  if test -f "$ltmain_in"; then
+    test -f Makefile && make "$ltmain"
+  fi
+fi
 
-      gnu*)
-        ;;
 
-      hpux9*)
-        hardcode_libdir_flag_spec_CXX='${wl}+b ${wl}$libdir'
-        hardcode_libdir_separator_CXX=:
-        export_dynamic_flag_spec_CXX='${wl}-E'
-        hardcode_direct_CXX=yes
-        hardcode_minus_L_CXX=yes # Not in the search PATH,
-				             # but as the default
-				             # location of the library.
-
-        case $cc_basename in
-          CC*)
-            # FIXME: insert proper C++ library support
-            ld_shlibs_CXX=no
-            ;;
-          aCC*)
-            archive_cmds_CXX='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
-            # Commands to make compiler produce verbose output that lists
-            # what "hidden" libraries, object files and flags are used when
-            # linking a shared library.
-            #
-            # There doesn't appear to be a way to prevent this compiler from
-            # explicitly linking system object files so we need to strip them
-            # from the output so that they don't get included in the library
-            # dependencies.
-            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
-            ;;
-          *)
-            if test "$GXX" = yes; then
-              archive_cmds_CXX='$RM $output_objdir/$soname~$CC -shared -nostdlib -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
-            else
-              # FIXME: insert proper C++ library support
-              ld_shlibs_CXX=no
-            fi
-            ;;
-        esac
-        ;;
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
 
-      hpux10*|hpux11*)
-        if test $with_gnu_ld = no; then
-	  hardcode_libdir_flag_spec_CXX='${wl}+b ${wl}$libdir'
-	  hardcode_libdir_separator_CXX=:
+CC="$lt_save_CC"
 
-          case $host_cpu in
-            hppa*64*|ia64*)
-              ;;
-            *)
-	      export_dynamic_flag_spec_CXX='${wl}-E'
-              ;;
-          esac
-        fi
-        case $host_cpu in
-          hppa*64*|ia64*)
-            hardcode_direct_CXX=no
-            hardcode_shlibpath_var_CXX=no
-            ;;
-          *)
-            hardcode_direct_CXX=yes
-            hardcode_direct_absolute_CXX=yes
-            hardcode_minus_L_CXX=yes # Not in the search PATH,
-					         # but as the default
-					         # location of the library.
-            ;;
-        esac
+	else
+	  tagname=""
+	fi
+	;;
 
-        case $cc_basename in
-          CC*)
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-          aCC*)
-	    case $host_cpu in
-	      hppa*64*)
-	        archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	        ;;
-	      ia64*)
-	        archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	        ;;
-	      *)
-	        archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	        ;;
-	    esac
-	    # Commands to make compiler produce verbose output that lists
-	    # what "hidden" libraries, object files and flags are used when
-	    # linking a shared library.
-	    #
-	    # There doesn't appear to be a way to prevent this compiler from
-	    # explicitly linking system object files so we need to strip them
-	    # from the output so that they don't get included in the library
-	    # dependencies.
-	    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
-	    ;;
-          *)
-	    if test "$GXX" = yes; then
-	      if test $with_gnu_ld = no; then
-	        case $host_cpu in
-	          hppa*64*)
-	            archive_cmds_CXX='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	            ;;
-	          ia64*)
-	            archive_cmds_CXX='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	            ;;
-	          *)
-	            archive_cmds_CXX='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	            ;;
-	        esac
-	      fi
-	    else
-	      # FIXME: insert proper C++ library support
-	      ld_shlibs_CXX=no
-	    fi
-	    ;;
-        esac
-        ;;
+      GCJ)
+	if test -n "$GCJ" && test "X$GCJ" != "Xno"; then
 
-      interix[3-9]*)
-	hardcode_direct_CXX=no
-	hardcode_shlibpath_var_CXX=no
-	hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
-	export_dynamic_flag_spec_CXX='${wl}-E'
-	# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
-	# Instead, shared libraries are loaded at an image base (0x10000000 by
-	# default) and relocated if they conflict, which is a slow very memory
-	# consuming and fragmenting process.  To avoid this, we pick a random,
-	# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
-	# time.  Moving up from 0x10000000 also allows more sbrk(2) space.
-	archive_cmds_CXX='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-	archive_expsym_cmds_CXX='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-	;;
-      irix5* | irix6*)
-        case $cc_basename in
-          CC*)
-	    # SGI C++
-	    archive_cmds_CXX='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
-
-	    # Archives containing C++ object files must be created using
-	    # "CC -ar", where "CC" is the IRIX C++ compiler.  This is
-	    # necessary to make sure instantiated templates are included
-	    # in the archive.
-	    old_archive_cmds_CXX='$CC -ar -WR,-u -o $oldlib $oldobjs'
-	    ;;
-          *)
-	    if test "$GXX" = yes; then
-	      if test "$with_gnu_ld" = no; then
-	        archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-	      else
-	        archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` -o $lib'
-	      fi
-	    fi
-	    link_all_deplibs_CXX=yes
-	    ;;
-        esac
-        hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
-        hardcode_libdir_separator_CXX=:
-        inherit_rpath_CXX=yes
-        ;;
 
-      linux* | k*bsd*-gnu)
-        case $cc_basename in
-          KCC*)
-	    # Kuck and Associates, Inc. (KAI) C++ Compiler
-
-	    # KCC will only create a shared library if the output file
-	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
-	    # to its proper name (with version) after linking.
-	    archive_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
-	    archive_expsym_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib ${wl}-retain-symbols-file,$export_symbols; mv \$templib $lib'
-	    # Commands to make compiler produce verbose output that lists
-	    # what "hidden" libraries, object files and flags are used when
-	    # linking a shared library.
-	    #
-	    # There doesn't appear to be a way to prevent this compiler from
-	    # explicitly linking system object files so we need to strip them
-	    # from the output so that they don't get included in the library
-	    # dependencies.
-	    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP "ld"`; rm -f libconftest$shared_ext; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
-
-	    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
-	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
-
-	    # Archives containing C++ object files must be created using
-	    # "CC -Bstatic", where "CC" is the KAI C++ compiler.
-	    old_archive_cmds_CXX='$CC -Bstatic -o $oldlib $oldobjs'
-	    ;;
-	  icpc* | ecpc* )
-	    # Intel C++
-	    with_gnu_ld=yes
-	    # version 8.0 and above of icpc choke on multiply defined symbols
-	    # if we add $predep_objects and $postdep_objects, however 7.1 and
-	    # earlier do not add the objects themselves.
-	    case `$CC -V 2>&1` in
-	      *"Version 7."*)
-	        archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
-		archive_expsym_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-		;;
-	      *)  # Version 8.0 or newer
-	        tmp_idyn=
-	        case $host_cpu in
-		  ia64*) tmp_idyn=' -i_dynamic';;
-		esac
-	        archive_cmds_CXX='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-		archive_expsym_cmds_CXX='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-		;;
-	    esac
-	    archive_cmds_need_lc_CXX=no
-	    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
-	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
-	    whole_archive_flag_spec_CXX='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
-	    ;;
-          pgCC* | pgcpp*)
-            # Portland Group C++ compiler
-	    case `$CC -V` in
-	    *pgCC\ [1-5]* | *pgcpp\ [1-5]*)
-	      prelink_cmds_CXX='tpldir=Template.dir~
-		rm -rf $tpldir~
-		$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~
-		compile_command="$compile_command `find $tpldir -name \*.o | $NL2SP`"'
-	      old_archive_cmds_CXX='tpldir=Template.dir~
-		rm -rf $tpldir~
-		$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~
-		$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \*.o | $NL2SP`~
-		$RANLIB $oldlib'
-	      archive_cmds_CXX='tpldir=Template.dir~
-		rm -rf $tpldir~
-		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
-		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
-	      archive_expsym_cmds_CXX='tpldir=Template.dir~
-		rm -rf $tpldir~
-		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
-		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
-	      ;;
-	    *) # Version 6 will use weak symbols
-	      archive_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
-	      archive_expsym_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
-	      ;;
-	    esac
+# Source file extension for Java test sources.
+ac_ext=java
 
-	    hardcode_libdir_flag_spec_CXX='${wl}--rpath ${wl}$libdir'
-	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
-	    whole_archive_flag_spec_CXX='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
-            ;;
-	  cxx*)
-	    # Compaq C++
-	    archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	    archive_expsym_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'
+# Object file extension for compiled Java test sources.
+objext=o
+objext_GCJ=$objext
 
-	    runpath_var=LD_RUN_PATH
-	    hardcode_libdir_flag_spec_CXX='-rpath $libdir'
-	    hardcode_libdir_separator_CXX=:
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="class foo {}\n"
 
-	    # Commands to make compiler produce verbose output that lists
-	    # what "hidden" libraries, object files and flags are used when
-	    # linking a shared library.
-	    #
-	    # There doesn't appear to be a way to prevent this compiler from
-	    # explicitly linking system object files so we need to strip them
-	    # from the output so that they don't get included in the library
-	    # dependencies.
-	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld"`; templist=`$ECHO "X$templist" | $Xsed -e "s/\(^.*ld.*\)\( .*ld .*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
-	    ;;
-	  xl*)
-	    # IBM XL 8.0 on PPC, with GNU ld
-	    hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
-	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
-	    archive_cmds_CXX='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	    if test "x$supports_anon_versioning" = xyes; then
-	      archive_expsym_cmds_CXX='echo "{ global:" > $output_objdir/$libname.ver~
-		cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-		echo "local: *; };" >> $output_objdir/$libname.ver~
-		$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
-	    fi
-	    ;;
-	  *)
-	    case `$CC -V 2>&1 | sed 5q` in
-	    *Sun\ C*)
-	      # Sun C++ 5.9
-	      no_undefined_flag_CXX=' -zdefs'
-	      archive_cmds_CXX='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	      archive_expsym_cmds_CXX='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'
-	      hardcode_libdir_flag_spec_CXX='-R$libdir'
-	      whole_archive_flag_spec_CXX='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; $ECHO \"$new_convenience\"` ${wl}--no-whole-archive'
-	      compiler_needs_object_CXX=yes
-
-	      # Not sure whether something based on
-	      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1
-	      # would be better.
-	      output_verbose_link_cmd='echo'
-
-	      # Archives containing C++ object files must be created using
-	      # "CC -xar", where "CC" is the Sun C++ compiler.  This is
-	      # necessary to make sure instantiated templates are included
-	      # in the archive.
-	      old_archive_cmds_CXX='$CC -xar -o $oldlib $oldobjs'
-	      ;;
-	    esac
-	    ;;
-	esac
-	;;
+# Code to be used in simple link tests
+lt_simple_link_test_code='public class conftest { public static void main(String[] argv) {}; }\n'
 
-      lynxos*)
-        # FIXME: insert proper C++ library support
-	ld_shlibs_CXX=no
-	;;
+# ltmain only uses $CC for tagged configurations so make sure $CC is set.
 
-      m88k*)
-        # FIXME: insert proper C++ library support
-        ld_shlibs_CXX=no
-	;;
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
 
-      mvs*)
-        case $cc_basename in
-          cxx*)
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-	  *)
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-	esac
-	;;
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
 
-      netbsd*)
-        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-	  archive_cmds_CXX='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'
-	  wlarc=
-	  hardcode_libdir_flag_spec_CXX='-R$libdir'
-	  hardcode_direct_CXX=yes
-	  hardcode_shlibpath_var_CXX=no
-	fi
-	# Workaround some broken pre-1.5 toolchains
-	output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e "s:-lgcc -lc -lgcc::"'
-	;;
+# Allow CC to be a program name with arguments.
+compiler=$CC
 
-      *nto* | *qnx*)
-        ld_shlibs_CXX=yes
-	;;
 
-      openbsd2*)
-        # C++ shared libraries are fairly broken
-	ld_shlibs_CXX=no
-	;;
+# save warnings/boilerplate of simple test code
+ac_outfile=conftest.$ac_objext
+printf "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$rm conftest*
 
-      openbsd*)
-	if test -f /usr/libexec/ld.so; then
-	  hardcode_direct_CXX=yes
-	  hardcode_shlibpath_var_CXX=no
-	  hardcode_direct_absolute_CXX=yes
-	  archive_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
-	  hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
-	  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-	    archive_expsym_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'
-	    export_dynamic_flag_spec_CXX='${wl}-E'
-	    whole_archive_flag_spec_CXX="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
-	  fi
-	  output_verbose_link_cmd=echo
-	else
-	  ld_shlibs_CXX=no
-	fi
-	;;
+ac_outfile=conftest.$ac_objext
+printf "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$rm conftest*
 
-      osf3* | osf4* | osf5*)
-        case $cc_basename in
-          KCC*)
-	    # Kuck and Associates, Inc. (KAI) C++ Compiler
-
-	    # KCC will only create a shared library if the output file
-	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
-	    # to its proper name (with version) after linking.
-	    archive_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo "$lib" | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
-
-	    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
-	    hardcode_libdir_separator_CXX=:
-
-	    # Archives containing C++ object files must be created using
-	    # the KAI C++ compiler.
-	    case $host in
-	      osf3*) old_archive_cmds_CXX='$CC -Bstatic -o $oldlib $oldobjs' ;;
-	      *) old_archive_cmds_CXX='$CC -o $oldlib $oldobjs' ;;
-	    esac
-	    ;;
-          RCC*)
-	    # Rational C++ 2.4.1
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-          cxx*)
-	    case $host in
-	      osf3*)
-	        allow_undefined_flag_CXX=' ${wl}-expect_unresolved ${wl}\*'
-	        archive_cmds_CXX='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n "$verstring" && $ECHO "X${wl}-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
-	        hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
-		;;
-	      *)
-	        allow_undefined_flag_CXX=' -expect_unresolved \*'
-	        archive_cmds_CXX='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'
-	        archive_expsym_cmds_CXX='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done~
-	          echo "-hidden">> $lib.exp~
-	          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n "$verstring" && $ECHO "X-set_version $verstring" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib~
-	          $RM $lib.exp'
-	        hardcode_libdir_flag_spec_CXX='-rpath $libdir'
-		;;
-	    esac
 
-	    hardcode_libdir_separator_CXX=:
+# Allow CC to be a program name with arguments.
+lt_save_CC="$CC"
+CC=${GCJ-"gcj"}
+compiler=$CC
+compiler_GCJ=$CC
+for cc_temp in $compiler""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$echo "X$cc_temp" | $Xsed -e 's%.*/%%' -e "s%^$host_alias-%%"`
 
-	    # Commands to make compiler produce verbose output that lists
-	    # what "hidden" libraries, object files and flags are used when
-	    # linking a shared library.
-	    #
-	    # There doesn't appear to be a way to prevent this compiler from
-	    # explicitly linking system object files so we need to strip them
-	    # from the output so that they don't get included in the library
-	    # dependencies.
-	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld" | $GREP -v "ld:"`; templist=`$ECHO "X$templist" | $Xsed -e "s/\(^.*ld.*\)\( .*ld.*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; $ECHO "X$list" | $Xsed'
-	    ;;
-	  *)
-	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
-	      allow_undefined_flag_CXX=' ${wl}-expect_unresolved ${wl}\*'
-	      case $host in
-	        osf3*)
-	          archive_cmds_CXX='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "X${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-		  ;;
-	        *)
-	          archive_cmds_CXX='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && $ECHO "${wl}-set_version ${wl}$verstring" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-		  ;;
-	      esac
-
-	      hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
-	      hardcode_libdir_separator_CXX=:
-
-	      # Commands to make compiler produce verbose output that lists
-	      # what "hidden" libraries, object files and flags are used when
-	      # linking a shared library.
-	      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "\-L"'
-
-	    else
-	      # FIXME: insert proper C++ library support
-	      ld_shlibs_CXX=no
-	    fi
-	    ;;
-        esac
-        ;;
 
-      psos*)
-        # FIXME: insert proper C++ library support
-        ld_shlibs_CXX=no
-        ;;
+# GCJ did not exist at the time GCC didn't implicitly link libc in.
+archive_cmds_need_lc_GCJ=no
 
-      sunos4*)
-        case $cc_basename in
-          CC*)
-	    # Sun C++ 4.x
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-          lcc*)
-	    # Lucid
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-          *)
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-        esac
-        ;;
+old_archive_cmds_GCJ=$old_archive_cmds
 
-      solaris*)
-        case $cc_basename in
-          CC*)
-	    # Sun C++ 4.2, 5.x and Centerline C++
-            archive_cmds_need_lc_CXX=yes
-	    no_undefined_flag_CXX=' -zdefs'
-	    archive_cmds_CXX='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	    archive_expsym_cmds_CXX='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
-
-	    hardcode_libdir_flag_spec_CXX='-R$libdir'
-	    hardcode_shlibpath_var_CXX=no
-	    case $host_os in
-	      solaris2.[0-5] | solaris2.[0-5].*) ;;
-	      *)
-		# The compiler driver will combine and reorder linker options,
-		# but understands `-z linker_flag'.
-	        # Supported since Solaris 2.6 (maybe 2.5.1?)
-		whole_archive_flag_spec_CXX='-z allextract$convenience -z defaultextract'
-	        ;;
-	    esac
-	    link_all_deplibs_CXX=yes
 
-	    output_verbose_link_cmd='echo'
+lt_prog_compiler_no_builtin_flag_GCJ=
 
-	    # Archives containing C++ object files must be created using
-	    # "CC -xar", where "CC" is the Sun C++ compiler.  This is
-	    # necessary to make sure instantiated templates are included
-	    # in the archive.
-	    old_archive_cmds_CXX='$CC -xar -o $oldlib $oldobjs'
-	    ;;
-          gcx*)
-	    # Green Hills C++ Compiler
-	    archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+if test "$GCC" = yes; then
+  lt_prog_compiler_no_builtin_flag_GCJ=' -fno-builtin'
 
-	    # The C++ compiler must be used to create the archive.
-	    old_archive_cmds_CXX='$CC $LDFLAGS -archive -o $oldlib $oldobjs'
-	    ;;
-          *)
-	    # GNU C++ compiler with Solaris linker
-	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
-	      no_undefined_flag_CXX=' ${wl}-z ${wl}defs'
-	      if $CC --version | $GREP -v '^2\.7' > /dev/null; then
-	        archive_cmds_CXX='$CC -shared -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
-	        archive_expsym_cmds_CXX='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-		  $CC -shared -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
-
-	        # Commands to make compiler produce verbose output that lists
-	        # what "hidden" libraries, object files and flags are used when
-	        # linking a shared library.
-	        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "\-L"'
-	      else
-	        # g++ 2.7 appears to require `-G' NOT `-shared' on this
-	        # platform.
-	        archive_cmds_CXX='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
-	        archive_expsym_cmds_CXX='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-		  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
-
-	        # Commands to make compiler produce verbose output that lists
-	        # what "hidden" libraries, object files and flags are used when
-	        # linking a shared library.
-	        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP "\-L"'
-	      fi
-
-	      hardcode_libdir_flag_spec_CXX='${wl}-R $wl$libdir'
-	      case $host_os in
-		solaris2.[0-5] | solaris2.[0-5].*) ;;
-		*)
-		  whole_archive_flag_spec_CXX='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
-		  ;;
-	      esac
-	    fi
-	    ;;
-        esac
-        ;;
 
-    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
-      no_undefined_flag_CXX='${wl}-z,text'
-      archive_cmds_need_lc_CXX=no
-      hardcode_shlibpath_var_CXX=no
-      runpath_var='LD_RUN_PATH'
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
+$as_echo_n "checking if $compiler supports -fno-rtti -fno-exceptions... " >&6; }
+if test "${lt_cv_prog_compiler_rtti_exceptions+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_rtti_exceptions=no
+  ac_outfile=conftest.$ac_objext
+   printf "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="-fno-rtti -fno-exceptions"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:15878: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:15882: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_rtti_exceptions=yes
+     fi
+   fi
+   $rm conftest*
 
-      case $cc_basename in
-        CC*)
-	  archive_cmds_CXX='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds_CXX='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	*)
-	  archive_cmds_CXX='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds_CXX='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-      esac
-      ;;
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
+$as_echo "$lt_cv_prog_compiler_rtti_exceptions" >&6; }
 
-      sysv5* | sco3.2v5* | sco5v6*)
-	# Note: We can NOT use -z defs as we might desire, because we do not
-	# link with -lc, and that would cause any symbols used from libc to
-	# always be unresolved, which means just about no library would
-	# ever link correctly.  If we're not using GNU ld we use -z text
-	# though, which does catch some bad symbols but isn't as heavy-handed
-	# as -z defs.
-	no_undefined_flag_CXX='${wl}-z,text'
-	allow_undefined_flag_CXX='${wl}-z,nodefs'
-	archive_cmds_need_lc_CXX=no
-	hardcode_shlibpath_var_CXX=no
-	hardcode_libdir_flag_spec_CXX='${wl}-R,$libdir'
-	hardcode_libdir_separator_CXX=':'
-	link_all_deplibs_CXX=yes
-	export_dynamic_flag_spec_CXX='${wl}-Bexport'
-	runpath_var='LD_RUN_PATH'
+if test x"$lt_cv_prog_compiler_rtti_exceptions" = xyes; then
+    lt_prog_compiler_no_builtin_flag_GCJ="$lt_prog_compiler_no_builtin_flag_GCJ -fno-rtti -fno-exceptions"
+else
+    :
+fi
 
-	case $cc_basename in
-          CC*)
-	    archive_cmds_CXX='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	    archive_expsym_cmds_CXX='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	    ;;
-	  *)
-	    archive_cmds_CXX='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	    archive_expsym_cmds_CXX='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	    ;;
-	esac
-      ;;
+fi
 
-      tandem*)
-        case $cc_basename in
-          NCC*)
-	    # NonStop-UX NCC 3.20
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-          *)
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-        esac
-        ;;
+lt_prog_compiler_wl_GCJ=
+lt_prog_compiler_pic_GCJ=
+lt_prog_compiler_static_GCJ=
 
-      vxworks*)
-        # FIXME: insert proper C++ library support
-        ld_shlibs_CXX=no
-        ;;
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
+$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
 
-      *)
-        # FIXME: insert proper C++ library support
-        ld_shlibs_CXX=no
-        ;;
-    esac
+  if test "$GCC" = yes; then
+    lt_prog_compiler_wl_GCJ='-Wl,'
+    lt_prog_compiler_static_GCJ='-static'
+
+    case $host_os in
+      aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static_GCJ='-Bstatic'
+      fi
+      ;;
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs_CXX" >&5
-$as_echo "$ld_shlibs_CXX" >&6; }
-    test "$ld_shlibs_CXX" = no && can_build_shared=no
+    amigaos*)
+      # FIXME: we need at least 68020 code to build shared libraries, but
+      # adding the `-m68020' flag to GCC prevents building anything better,
+      # like `-m68040'.
+      lt_prog_compiler_pic_GCJ='-m68020 -resident32 -malways-restore-a4'
+      ;;
 
-    GCC_CXX="$GXX"
-    LD_CXX="$LD"
+    beos* | cygwin* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
 
-    ## CAVEAT EMPTOR:
-    ## There is no encapsulation within the following macros, do not change
-    ## the running order or otherwise move them around unless you know exactly
-    ## what you are doing...
-    # Dependencies to place before and after the object being linked:
-predep_objects_CXX=
-postdep_objects_CXX=
-predeps_CXX=
-postdeps_CXX=
-compiler_lib_search_path_CXX=
+    mingw* | pw32* | os2*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_prog_compiler_pic_GCJ='-DDLL_EXPORT'
+      ;;
 
-cat > conftest.$ac_ext <<_LT_EOF
-class Foo
-{
-public:
-  Foo (void) { a = 0; }
-private:
-  int a;
-};
-_LT_EOF
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      lt_prog_compiler_pic_GCJ='-fno-common'
+      ;;
 
-if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  # Parse the compiler output and extract the necessary
-  # objects, libraries and library flags.
+    interix3*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
 
-  # Sentinel used to keep track of whether or not we are before
-  # the conftest object file.
-  pre_test_object_deps_done=no
+    msdosdjgpp*)
+      # Just because we use GCC doesn't mean we suddenly get shared libraries
+      # on systems that don't support them.
+      lt_prog_compiler_can_build_shared_GCJ=no
+      enable_shared=no
+      ;;
 
-  for p in `eval "$output_verbose_link_cmd"`; do
-    case $p in
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	lt_prog_compiler_pic_GCJ=-Kconform_pic
+      fi
+      ;;
 
-    -L* | -R* | -l*)
-       # Some compilers place space between "-{L,R}" and the path.
-       # Remove the space.
-       if test $p = "-L" ||
-          test $p = "-R"; then
-	 prev=$p
-	 continue
-       else
-	 prev=
-       fi
+    hpux*)
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic_GCJ='-fPIC'
+	;;
+      esac
+      ;;
 
-       if test "$pre_test_object_deps_done" = no; then
-	 case $p in
-	 -L* | -R*)
-	   # Internal compiler library paths should come after those
-	   # provided the user.  The postdeps already come after the
-	   # user supplied libs so there is no need to process them.
-	   if test -z "$compiler_lib_search_path_CXX"; then
-	     compiler_lib_search_path_CXX="${prev}${p}"
-	   else
-	     compiler_lib_search_path_CXX="${compiler_lib_search_path_CXX} ${prev}${p}"
-	   fi
-	   ;;
-	 # The "-l" case would never come before the object being
-	 # linked, so don't bother handling this case.
-	 esac
-       else
-	 if test -z "$postdeps_CXX"; then
-	   postdeps_CXX="${prev}${p}"
-	 else
-	   postdeps_CXX="${postdeps_CXX} ${prev}${p}"
-	 fi
-       fi
+    *)
+      lt_prog_compiler_pic_GCJ='-fPIC'
+      ;;
+    esac
+  else
+    # PORTME Check for flag to pass linker flags through the system compiler.
+    case $host_os in
+    aix*)
+      lt_prog_compiler_wl_GCJ='-Wl,'
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static_GCJ='-Bstatic'
+      else
+	lt_prog_compiler_static_GCJ='-bnso -bI:/lib/syscalls.exp'
+      fi
+      ;;
+      darwin*)
+        # PIC is the default on this platform
+        # Common symbols not allowed in MH_DYLIB files
+       case $cc_basename in
+         xlc*)
+         lt_prog_compiler_pic_GCJ='-qnocommon'
+         lt_prog_compiler_wl_GCJ='-Wl,'
+         ;;
+       esac
        ;;
 
-    *.$objext)
-       # This assumes that the test object file only shows up
-       # once in the compiler output.
-       if test "$p" = "conftest.$objext"; then
-	 pre_test_object_deps_done=yes
-	 continue
-       fi
+    mingw* | pw32* | os2*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_prog_compiler_pic_GCJ='-DDLL_EXPORT'
+      ;;
 
-       if test "$pre_test_object_deps_done" = no; then
-	 if test -z "$predep_objects_CXX"; then
-	   predep_objects_CXX="$p"
-	 else
-	   predep_objects_CXX="$predep_objects_CXX $p"
-	 fi
-       else
-	 if test -z "$postdep_objects_CXX"; then
-	   postdep_objects_CXX="$p"
-	 else
-	   postdep_objects_CXX="$postdep_objects_CXX $p"
-	 fi
-       fi
-       ;;
+    hpux9* | hpux10* | hpux11*)
+      lt_prog_compiler_wl_GCJ='-Wl,'
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic_GCJ='+Z'
+	;;
+      esac
+      # Is there a better lt_prog_compiler_static that works with the bundled CC?
+      lt_prog_compiler_static_GCJ='${wl}-a ${wl}archive'
+      ;;
 
-    *) ;; # Ignore the rest.
+    irix5* | irix6* | nonstopux*)
+      lt_prog_compiler_wl_GCJ='-Wl,'
+      # PIC (with -KPIC) is the default.
+      lt_prog_compiler_static_GCJ='-non_shared'
+      ;;
 
-    esac
-  done
+    newsos6)
+      lt_prog_compiler_pic_GCJ='-KPIC'
+      lt_prog_compiler_static_GCJ='-Bstatic'
+      ;;
 
-  # Clean up.
-  rm -f a.out a.exe
-else
-  echo "libtool.m4: error: problem compiling CXX test program"
-fi
+    linux*)
+      case $cc_basename in
+      icc* | ecc*)
+	lt_prog_compiler_wl_GCJ='-Wl,'
+	lt_prog_compiler_pic_GCJ='-KPIC'
+	lt_prog_compiler_static_GCJ='-static'
+        ;;
+      pgcc* | pgf77* | pgf90* | pgf95*)
+        # Portland Group compilers (*not* the Pentium gcc compiler,
+	# which looks to be a dead project)
+	lt_prog_compiler_wl_GCJ='-Wl,'
+	lt_prog_compiler_pic_GCJ='-fpic'
+	lt_prog_compiler_static_GCJ='-Bstatic'
+        ;;
+      ccc*)
+        lt_prog_compiler_wl_GCJ='-Wl,'
+        # All Alpha code is PIC.
+        lt_prog_compiler_static_GCJ='-non_shared'
+        ;;
+      esac
+      ;;
 
-$RM -f confest.$objext
+    osf3* | osf4* | osf5*)
+      lt_prog_compiler_wl_GCJ='-Wl,'
+      # All OSF/1 code is PIC.
+      lt_prog_compiler_static_GCJ='-non_shared'
+      ;;
 
-# PORTME: override above test on systems where it is broken
-case $host_os in
-interix[3-9]*)
-  # Interix 3.5 installs completely hosed .la files for C++, so rather than
-  # hack all around it, let's just trust "g++" to DTRT.
-  predep_objects_CXX=
-  postdep_objects_CXX=
-  postdeps_CXX=
-  ;;
+    solaris*)
+      lt_prog_compiler_pic_GCJ='-KPIC'
+      lt_prog_compiler_static_GCJ='-Bstatic'
+      case $cc_basename in
+      f77* | f90* | f95*)
+	lt_prog_compiler_wl_GCJ='-Qoption ld ';;
+      *)
+	lt_prog_compiler_wl_GCJ='-Wl,';;
+      esac
+      ;;
 
-linux*)
-  case `$CC -V 2>&1 | sed 5q` in
-  *Sun\ C*)
-    # Sun C++ 5.9
-
-    # The more standards-conforming stlport4 library is
-    # incompatible with the Cstd library. Avoid specifying
-    # it if it's in CXXFLAGS. Ignore libCrun as
-    # -library=stlport4 depends on it.
-    case " $CXX $CXXFLAGS " in
-    *" -library=stlport4 "*)
-      solaris_use_stlport4=yes
+    sunos4*)
+      lt_prog_compiler_wl_GCJ='-Qoption ld '
+      lt_prog_compiler_pic_GCJ='-PIC'
+      lt_prog_compiler_static_GCJ='-Bstatic'
       ;;
-    esac
 
-    if test "$solaris_use_stlport4" != yes; then
-      postdeps_CXX='-library=Cstd -library=Crun'
-    fi
-    ;;
-  esac
-  ;;
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      lt_prog_compiler_wl_GCJ='-Wl,'
+      lt_prog_compiler_pic_GCJ='-KPIC'
+      lt_prog_compiler_static_GCJ='-Bstatic'
+      ;;
 
-solaris*)
-  case $cc_basename in
-  CC*)
-    # The more standards-conforming stlport4 library is
-    # incompatible with the Cstd library. Avoid specifying
-    # it if it's in CXXFLAGS. Ignore libCrun as
-    # -library=stlport4 depends on it.
-    case " $CXX $CXXFLAGS " in
-    *" -library=stlport4 "*)
-      solaris_use_stlport4=yes
+    sysv4*MP*)
+      if test -d /usr/nec ;then
+	lt_prog_compiler_pic_GCJ='-Kconform_pic'
+	lt_prog_compiler_static_GCJ='-Bstatic'
+      fi
       ;;
-    esac
 
-    # Adding this requires a known-good setup of shared libraries for
-    # Sun compiler versions before 5.6, else PIC objects from an old
-    # archive will be linked into the output, leading to subtle bugs.
-    if test "$solaris_use_stlport4" != yes; then
-      postdeps_CXX='-library=Cstd -library=Crun'
-    fi
-    ;;
-  esac
-  ;;
-esac
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      lt_prog_compiler_wl_GCJ='-Wl,'
+      lt_prog_compiler_pic_GCJ='-KPIC'
+      lt_prog_compiler_static_GCJ='-Bstatic'
+      ;;
 
+    unicos*)
+      lt_prog_compiler_wl_GCJ='-Wl,'
+      lt_prog_compiler_can_build_shared_GCJ=no
+      ;;
 
-case " $postdeps_CXX " in
-*" -lc "*) archive_cmds_need_lc_CXX=no ;;
-esac
- compiler_lib_search_dirs_CXX=
-if test -n "${compiler_lib_search_path_CXX}"; then
- compiler_lib_search_dirs_CXX=`echo " ${compiler_lib_search_path_CXX}" | ${SED} -e 's! -L! !g' -e 's!^ !!'`
-fi
+    uts4*)
+      lt_prog_compiler_pic_GCJ='-pic'
+      lt_prog_compiler_static_GCJ='-Bstatic'
+      ;;
+
+    *)
+      lt_prog_compiler_can_build_shared_GCJ=no
+      ;;
+    esac
+  fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic_GCJ" >&5
+$as_echo "$lt_prog_compiler_pic_GCJ" >&6; }
 
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$lt_prog_compiler_pic_GCJ"; then
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic_GCJ works" >&5
+$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic_GCJ works... " >&6; }
+if test "${lt_prog_compiler_pic_works_GCJ+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_prog_compiler_pic_works_GCJ=no
+  ac_outfile=conftest.$ac_objext
+   printf "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$lt_prog_compiler_pic_GCJ"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:16146: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:16150: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_prog_compiler_pic_works_GCJ=yes
+     fi
+   fi
+   $rm conftest*
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic_works_GCJ" >&5
+$as_echo "$lt_prog_compiler_pic_works_GCJ" >&6; }
 
+if test x"$lt_prog_compiler_pic_works_GCJ" = xyes; then
+    case $lt_prog_compiler_pic_GCJ in
+     "" | " "*) ;;
+     *) lt_prog_compiler_pic_GCJ=" $lt_prog_compiler_pic_GCJ" ;;
+     esac
+else
+    lt_prog_compiler_pic_GCJ=
+     lt_prog_compiler_can_build_shared_GCJ=no
+fi
 
+fi
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    lt_prog_compiler_pic_GCJ=
+    ;;
+  *)
+    lt_prog_compiler_pic_GCJ="$lt_prog_compiler_pic_GCJ"
+    ;;
+esac
 
+#
+# Check to make sure the static flag actually works.
+#
+wl=$lt_prog_compiler_wl_GCJ eval lt_tmp_static_flag=\"$lt_prog_compiler_static_GCJ\"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
+$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
+if test "${lt_prog_compiler_static_works_GCJ+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_prog_compiler_static_works_GCJ=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
+   printf "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&5
+       $echo "X$_lt_linker_boilerplate" | $Xsed -e '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         lt_prog_compiler_static_works_GCJ=yes
+       fi
+     else
+       lt_prog_compiler_static_works_GCJ=yes
+     fi
+   fi
+   $rm conftest*
+   LDFLAGS="$save_LDFLAGS"
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_static_works_GCJ" >&5
+$as_echo "$lt_prog_compiler_static_works_GCJ" >&6; }
 
+if test x"$lt_prog_compiler_static_works_GCJ" = xyes; then
+    :
+else
+    lt_prog_compiler_static_GCJ=
+fi
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if test "${lt_cv_prog_compiler_c_o_GCJ+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o_GCJ=no
+   $rm -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   printf "$lt_simple_compile_test_code" > conftest.$ac_ext
 
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:16250: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:16254: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o_GCJ=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $rm conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $rm out/ii_files/* && rmdir out/ii_files
+   $rm out/* && rmdir out
+   cd ..
+   rmdir conftest
+   $rm conftest*
 
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o_GCJ" >&5
+$as_echo "$lt_cv_prog_compiler_c_o_GCJ" >&6; }
 
 
+hard_links="nottested"
+if test "$lt_cv_prog_compiler_c_o_GCJ" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
+$as_echo_n "checking if we can lock with hard links... " >&6; }
+  hard_links=yes
+  $rm conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
+$as_echo "$hard_links" >&6; }
+  if test "$hard_links" = no; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
+$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
 
+  runpath_var=
+  allow_undefined_flag_GCJ=
+  enable_shared_with_static_runtimes_GCJ=no
+  archive_cmds_GCJ=
+  archive_expsym_cmds_GCJ=
+  old_archive_From_new_cmds_GCJ=
+  old_archive_from_expsyms_cmds_GCJ=
+  export_dynamic_flag_spec_GCJ=
+  whole_archive_flag_spec_GCJ=
+  thread_safe_flag_spec_GCJ=
+  hardcode_libdir_flag_spec_GCJ=
+  hardcode_libdir_flag_spec_ld_GCJ=
+  hardcode_libdir_separator_GCJ=
+  hardcode_direct_GCJ=no
+  hardcode_minus_L_GCJ=no
+  hardcode_shlibpath_var_GCJ=unsupported
+  link_all_deplibs_GCJ=unknown
+  hardcode_automatic_GCJ=no
+  module_cmds_GCJ=
+  module_expsym_cmds_GCJ=
+  always_export_symbols_GCJ=no
+  export_symbols_cmds_GCJ='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  # include_expsyms should be a list of space-separated symbols to be *always*
+  # included in the symbol list
+  include_expsyms_GCJ=
+  # exclude_expsyms can be an extended regexp of symbols to exclude
+  # it will be wrapped by ` (' and `)$', so one must not match beginning or
+  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
+  # as well as any symbol that contains `d'.
+  exclude_expsyms_GCJ="_GLOBAL_OFFSET_TABLE_"
+  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
+  # platforms (ab)use it in PIC code, but their linkers get confused if
+  # the symbol is explicitly referenced.  Since portable code cannot
+  # rely on this symbol name, it's probably fine to never include it in
+  # preloaded symbol tables.
+  extract_expsyms_cmds=
+  # Just being paranoid about ensuring that cc_basename is set.
+  for cc_temp in $compiler""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$echo "X$cc_temp" | $Xsed -e 's%.*/%%' -e "s%^$host_alias-%%"`
 
+  case $host_os in
+  cygwin* | mingw* | pw32*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+  esac
 
+  ld_shlibs_GCJ=yes
+  if test "$with_gnu_ld" = yes; then
+    # If archive_cmds runs LD, not CC, wlarc should be empty
+    wlarc='${wl}'
 
+    # Set some defaults for GNU ld with shared library support. These
+    # are reset later if shared libraries are not supported. Putting them
+    # here allows them to be overridden if necessary.
+    runpath_var=LD_RUN_PATH
+    hardcode_libdir_flag_spec_GCJ='${wl}--rpath ${wl}$libdir'
+    export_dynamic_flag_spec_GCJ='${wl}--export-dynamic'
+    # ancient GNU ld didn't support --whole-archive et. al.
+    if $LD --help 2>&1 | grep 'no-whole-archive' > /dev/null; then
+	whole_archive_flag_spec_GCJ="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+      else
+  	whole_archive_flag_spec_GCJ=
+    fi
+    supports_anon_versioning=no
+    case `$LD -v 2>/dev/null` in
+      *\ [01].* | *\ 2.[0-9].* | *\ 2.10.*) ;; # catch versions < 2.11
+      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
+      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
+      *\ 2.11.*) ;; # other 2.11 versions
+      *) supports_anon_versioning=yes ;;
+    esac
 
+    # See if GNU ld supports shared libraries.
+    case $host_os in
+    aix3* | aix4* | aix5*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+	ld_shlibs_GCJ=no
+	cat <<EOF 1>&2
 
+*** Warning: the GNU linker, at least up to release 2.9.1, is reported
+*** to be unable to reliably create shared libraries on AIX.
+*** Therefore, libtool is disabling shared libraries support.  If you
+*** really care for shared libraries, you may want to modify your PATH
+*** so that a non-GNU linker is found, and then restart.
 
+EOF
+      fi
+      ;;
 
+    amigaos*)
+      archive_cmds_GCJ='$rm $output_objdir/a2ixlibrary.data~$echo "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$echo "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$echo "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$echo "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+      hardcode_libdir_flag_spec_GCJ='-L$libdir'
+      hardcode_minus_L_GCJ=yes
+
+      # Samuel A. Falvo II <kc5tja@dolphin.openprojects.net> reports
+      # that the semantics of dynamic libraries on AmigaOS, at least up
+      # to version 4, is to share data among multiple programs linked
+      # with the same dynamic library.  Since this doesn't match the
+      # behavior of shared libraries on other platforms, we can't use
+      # them.
+      ld_shlibs_GCJ=no
+      ;;
 
+    beos*)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+	allow_undefined_flag_GCJ=unsupported
+	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	# support --undefined.  This deserves some investigation.  FIXME
+	archive_cmds_GCJ='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      else
+	ld_shlibs_GCJ=no
+      fi
+      ;;
 
+    cygwin* | mingw* | pw32*)
+      # _LT_AC_TAGVAR(hardcode_libdir_flag_spec, GCJ) is actually meaningless,
+      # as there is no search path for DLLs.
+      hardcode_libdir_flag_spec_GCJ='-L$libdir'
+      allow_undefined_flag_GCJ=unsupported
+      always_export_symbols_GCJ=no
+      enable_shared_with_static_runtimes_GCJ=yes
+      export_symbols_cmds_GCJ='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS] /s/.* \([^ ]*\)/\1 DATA/'\'' | $SED -e '\''/^[AITW] /s/.* //'\'' | sort | uniq > $export_symbols'
 
+      if $LD --help 2>&1 | grep 'auto-import' > /dev/null; then
+        archive_cmds_GCJ='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	# If the export-symbols file already is a .def file (1st line
+	# is EXPORTS), use it as is; otherwise, prepend...
+	archive_expsym_cmds_GCJ='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	  cp $export_symbols $output_objdir/$soname.def;
+	else
+	  echo EXPORTS > $output_objdir/$soname.def;
+	  cat $export_symbols >> $output_objdir/$soname.def;
+	fi~
+	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+      else
+	ld_shlibs_GCJ=no
+      fi
+      ;;
 
+    interix3*)
+      hardcode_direct_GCJ=no
+      hardcode_shlibpath_var_GCJ=no
+      hardcode_libdir_flag_spec_GCJ='${wl}-rpath,$libdir'
+      export_dynamic_flag_spec_GCJ='${wl}-E'
+      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+      # Instead, shared libraries are loaded at an image base (0x10000000 by
+      # default) and relocated if they conflict, which is a slow very memory
+      # consuming and fragmenting process.  To avoid this, we pick a random,
+      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+      archive_cmds_GCJ='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      archive_expsym_cmds_GCJ='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      ;;
 
+    linux*)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+	tmp_addflag=
+	case $cc_basename,$host_cpu in
+	pgcc*)				# Portland Group C compiler
+	  whole_archive_flag_spec_GCJ='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $echo \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag'
+	  ;;
+	pgf77* | pgf90* | pgf95*)	# Portland Group f77 and f90 compilers
+	  whole_archive_flag_spec_GCJ='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $echo \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag -Mnomain' ;;
+	ecc*,ia64* | icc*,ia64*)		# Intel C compiler on ia64
+	  tmp_addflag=' -i_dynamic' ;;
+	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
+	  tmp_addflag=' -i_dynamic -nofor_main' ;;
+	ifc* | ifort*)			# Intel Fortran compiler
+	  tmp_addflag=' -nofor_main' ;;
+	esac
+	archive_cmds_GCJ='$CC -shared'"$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
 
+	if test $supports_anon_versioning = yes; then
+	  archive_expsym_cmds_GCJ='$echo "{ global:" > $output_objdir/$libname.ver~
+  cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+  $echo "local: *; };" >> $output_objdir/$libname.ver~
+	  $CC -shared'"$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+	fi
+      else
+	ld_shlibs_GCJ=no
+      fi
+      ;;
 
-    lt_prog_compiler_wl_CXX=
-lt_prog_compiler_pic_CXX=
-lt_prog_compiler_static_CXX=
+    netbsd*)
+      if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
+	archive_cmds_GCJ='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
+	wlarc=
+      else
+	archive_cmds_GCJ='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds_GCJ='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      fi
+      ;;
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
-$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
+    solaris*)
+      if $LD -v 2>&1 | grep 'BFD 2\.8' > /dev/null; then
+	ld_shlibs_GCJ=no
+	cat <<EOF 1>&2
 
-  # C++ specific cases for pic, static, wl, etc.
-  if test "$GXX" = yes; then
-    lt_prog_compiler_wl_CXX='-Wl,'
-    lt_prog_compiler_static_CXX='-static'
+*** Warning: The releases 2.8.* of the GNU linker cannot reliably
+*** create shared libraries on Solaris systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.9.1 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
 
-    case $host_os in
-    aix*)
-      # All AIX code is PIC.
-      if test "$host_cpu" = ia64; then
-	# AIX 5 now supports IA64 processor
-	lt_prog_compiler_static_CXX='-Bstatic'
+EOF
+      elif $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+	archive_cmds_GCJ='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds_GCJ='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs_GCJ=no
       fi
       ;;
 
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            lt_prog_compiler_pic_CXX='-fPIC'
-        ;;
-      m68k)
-            # FIXME: we need at least 68020 code to build shared libraries, but
-            # adding the `-m68020' flag to GCC prevents building anything better,
-            # like `-m68040'.
-            lt_prog_compiler_pic_CXX='-m68020 -resident32 -malways-restore-a4'
-        ;;
-      esac
-      ;;
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
+	ld_shlibs_GCJ=no
+	cat <<_LT_EOF 1>&2
 
-    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
-      # PIC is the default for these OSes.
-      ;;
-    mingw* | cygwin* | os2* | pw32* | cegcc*)
-      # This hack is so that the source file can tell whether it is being
-      # built for inclusion in a dll (and should export symbols for example).
-      # Although the cygwin gcc ignores -fPIC, still need this for old-style
-      # (--disable-auto-import) libraries
-      lt_prog_compiler_pic_CXX='-DDLL_EXPORT'
-      ;;
-    darwin* | rhapsody*)
-      # PIC is the default on this platform
-      # Common symbols not allowed in MH_DYLIB files
-      lt_prog_compiler_pic_CXX='-fno-common'
-      ;;
-    *djgpp*)
-      # DJGPP does not support shared libraries at all
-      lt_prog_compiler_pic_CXX=
-      ;;
-    interix[3-9]*)
-      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
-      # Instead, we relocate shared libraries at runtime.
-      ;;
-    sysv4*MP*)
-      if test -d /usr/nec; then
-	lt_prog_compiler_pic_CXX=-Kconform_pic
-      fi
-      ;;
-    hpux*)
-      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
-      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
-      # sets the default TLS model and affects inlining.
-      case $host_cpu in
-      hppa*64*)
+*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
+*** reliably create shared libraries on SCO systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
 	;;
-      *)
-	lt_prog_compiler_pic_CXX='-fPIC'
+	*)
+	  if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+	    hardcode_libdir_flag_spec_GCJ='`test -z "$SCOABSPATH" && echo ${wl}-rpath,$libdir`'
+	    archive_cmds_GCJ='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib'
+	    archive_expsym_cmds_GCJ='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname,\${SCOABSPATH:+${install_libdir}/}$soname,-retain-symbols-file,$export_symbols -o $lib'
+	  else
+	    ld_shlibs_GCJ=no
+	  fi
 	;;
       esac
       ;;
-    *qnx* | *nto*)
-      # QNX uses GNU C++, but need to define -shared option too, otherwise
-      # it will coredump.
-      lt_prog_compiler_pic_CXX='-fPIC -shared'
+
+    sunos4*)
+      archive_cmds_GCJ='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      wlarc=
+      hardcode_direct_GCJ=yes
+      hardcode_shlibpath_var_GCJ=no
       ;;
+
     *)
-      lt_prog_compiler_pic_CXX='-fPIC'
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+	archive_cmds_GCJ='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds_GCJ='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs_GCJ=no
+      fi
       ;;
     esac
+
+    if test "$ld_shlibs_GCJ" = no; then
+      runpath_var=
+      hardcode_libdir_flag_spec_GCJ=
+      export_dynamic_flag_spec_GCJ=
+      whole_archive_flag_spec_GCJ=
+    fi
   else
+    # PORTME fill in a description of your system's linker (not GNU ld)
     case $host_os in
-      aix[4-9]*)
-	# All AIX code is PIC.
-	if test "$host_cpu" = ia64; then
-	  # AIX 5 now supports IA64 processor
-	  lt_prog_compiler_static_CXX='-Bstatic'
+    aix3*)
+      allow_undefined_flag_GCJ=unsupported
+      always_export_symbols_GCJ=yes
+      archive_expsym_cmds_GCJ='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      hardcode_minus_L_GCJ=yes
+      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
+	# Neither direct hardcoding nor static linking is supported with a
+	# broken collect2.
+	hardcode_direct_GCJ=unsupported
+      fi
+      ;;
+
+    aix4* | aix5*)
+      if test "$host_cpu" = ia64; then
+	# On IA64, the linker does run time linking by default, so we don't
+	# have to do anything special.
+	aix_use_runtimelinking=no
+	exp_sym_flag='-Bexport'
+	no_entry_flag=""
+      else
+	# If we're using GNU nm, then we don't want the "-C" option.
+	# -C means demangle to AIX nm, but means don't demangle with GNU nm
+	if $NM -V 2>&1 | grep 'GNU' > /dev/null; then
+	  export_symbols_cmds_GCJ='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$2 == "T") || (\$2 == "D") || (\$2 == "B")) && (substr(\$3,1,1) != ".")) { print \$3 } }'\'' | sort -u > $export_symbols'
 	else
-	  lt_prog_compiler_static_CXX='-bnso -bI:/lib/syscalls.exp'
+	  export_symbols_cmds_GCJ='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$2 == "T") || (\$2 == "D") || (\$2 == "B")) && (substr(\$3,1,1) != ".")) { print \$3 } }'\'' | sort -u > $export_symbols'
 	fi
-	;;
-      chorus*)
-	case $cc_basename in
-	cxch68*)
-	  # Green Hills C++ Compiler
-	  # _LT_TAGVAR(lt_prog_compiler_static, CXX)="--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a"
+	aix_use_runtimelinking=no
+
+	# Test if we are trying to use run time linking or normal
+	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
+	# need to do runtime linking.
+	case $host_os in aix4.[23]|aix4.[23].*|aix5*)
+	  for ld_flag in $LDFLAGS; do
+  	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+  	    aix_use_runtimelinking=yes
+  	    break
+  	  fi
+	  done
 	  ;;
 	esac
-	;;
-      dgux*)
-	case $cc_basename in
-	  ec++*)
-	    lt_prog_compiler_pic_CXX='-KPIC'
-	    ;;
-	  ghcx*)
-	    # Green Hills C++ Compiler
-	    lt_prog_compiler_pic_CXX='-pic'
-	    ;;
-	  *)
-	    ;;
-	esac
-	;;
-      freebsd* | dragonfly*)
-	# FreeBSD uses GNU C++
-	;;
-      hpux9* | hpux10* | hpux11*)
-	case $cc_basename in
-	  CC*)
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_static_CXX='${wl}-a ${wl}archive'
-	    if test "$host_cpu" != ia64; then
-	      lt_prog_compiler_pic_CXX='+Z'
-	    fi
-	    ;;
-	  aCC*)
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_static_CXX='${wl}-a ${wl}archive'
-	    case $host_cpu in
-	    hppa*64*|ia64*)
-	      # +Z the default
-	      ;;
-	    *)
-	      lt_prog_compiler_pic_CXX='+Z'
-	      ;;
-	    esac
-	    ;;
-	  *)
-	    ;;
-	esac
-	;;
-      interix*)
-	# This is c89, which is MS Visual C++ (no shared libs)
-	# Anyone wants to do a port?
-	;;
-      irix5* | irix6* | nonstopux*)
-	case $cc_basename in
-	  CC*)
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_static_CXX='-non_shared'
-	    # CC pic flag -KPIC is the default.
-	    ;;
-	  *)
-	    ;;
-	esac
-	;;
-      linux* | k*bsd*-gnu)
-	case $cc_basename in
-	  KCC*)
-	    # KAI C++ Compiler
-	    lt_prog_compiler_wl_CXX='--backend -Wl,'
-	    lt_prog_compiler_pic_CXX='-fPIC'
-	    ;;
-	  ecpc* )
-	    # old Intel C++ for x86_64 which still supported -KPIC.
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_pic_CXX='-KPIC'
-	    lt_prog_compiler_static_CXX='-static'
-	    ;;
-	  icpc* )
-	    # Intel C++, used to be incompatible with GCC.
-	    # ICC 10 doesn't accept -KPIC any more.
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_pic_CXX='-fPIC'
-	    lt_prog_compiler_static_CXX='-static'
-	    ;;
-	  pgCC* | pgcpp*)
-	    # Portland Group C++ compiler
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_pic_CXX='-fpic'
-	    lt_prog_compiler_static_CXX='-Bstatic'
-	    ;;
-	  cxx*)
-	    # Compaq C++
-	    # Make sure the PIC flag is empty.  It appears that all Alpha
-	    # Linux and Compaq Tru64 Unix objects are PIC.
-	    lt_prog_compiler_pic_CXX=
-	    lt_prog_compiler_static_CXX='-non_shared'
-	    ;;
-	  xlc* | xlC*)
-	    # IBM XL 8.0 on PPC
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_pic_CXX='-qpic'
-	    lt_prog_compiler_static_CXX='-qstaticlink'
-	    ;;
-	  *)
-	    case `$CC -V 2>&1 | sed 5q` in
-	    *Sun\ C*)
-	      # Sun C++ 5.9
-	      lt_prog_compiler_pic_CXX='-KPIC'
-	      lt_prog_compiler_static_CXX='-Bstatic'
-	      lt_prog_compiler_wl_CXX='-Qoption ld '
-	      ;;
-	    esac
-	    ;;
-	esac
-	;;
-      lynxos*)
-	;;
-      m88k*)
-	;;
-      mvs*)
-	case $cc_basename in
-	  cxx*)
-	    lt_prog_compiler_pic_CXX='-W c,exportall'
-	    ;;
-	  *)
-	    ;;
-	esac
-	;;
-      netbsd*)
-	;;
-      *qnx* | *nto*)
-        # QNX uses GNU C++, but need to define -shared option too, otherwise
-        # it will coredump.
-        lt_prog_compiler_pic_CXX='-fPIC -shared'
-        ;;
-      osf3* | osf4* | osf5*)
-	case $cc_basename in
-	  KCC*)
-	    lt_prog_compiler_wl_CXX='--backend -Wl,'
-	    ;;
-	  RCC*)
-	    # Rational C++ 2.4.1
-	    lt_prog_compiler_pic_CXX='-pic'
-	    ;;
-	  cxx*)
-	    # Digital/Compaq C++
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    # Make sure the PIC flag is empty.  It appears that all Alpha
-	    # Linux and Compaq Tru64 Unix objects are PIC.
-	    lt_prog_compiler_pic_CXX=
-	    lt_prog_compiler_static_CXX='-non_shared'
-	    ;;
-	  *)
-	    ;;
-	esac
-	;;
-      psos*)
-	;;
-      solaris*)
-	case $cc_basename in
-	  CC*)
-	    # Sun C++ 4.2, 5.x and Centerline C++
-	    lt_prog_compiler_pic_CXX='-KPIC'
-	    lt_prog_compiler_static_CXX='-Bstatic'
-	    lt_prog_compiler_wl_CXX='-Qoption ld '
-	    ;;
-	  gcx*)
-	    # Green Hills C++ Compiler
-	    lt_prog_compiler_pic_CXX='-PIC'
-	    ;;
-	  *)
-	    ;;
-	esac
-	;;
-      sunos4*)
-	case $cc_basename in
-	  CC*)
-	    # Sun C++ 4.x
-	    lt_prog_compiler_pic_CXX='-pic'
-	    lt_prog_compiler_static_CXX='-Bstatic'
-	    ;;
-	  lcc*)
-	    # Lucid
-	    lt_prog_compiler_pic_CXX='-pic'
-	    ;;
-	  *)
-	    ;;
-	esac
-	;;
-      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
-	case $cc_basename in
-	  CC*)
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_pic_CXX='-KPIC'
-	    lt_prog_compiler_static_CXX='-Bstatic'
-	    ;;
-	esac
-	;;
-      tandem*)
-	case $cc_basename in
-	  NCC*)
-	    # NonStop-UX NCC 3.20
-	    lt_prog_compiler_pic_CXX='-KPIC'
-	    ;;
-	  *)
-	    ;;
-	esac
-	;;
-      vxworks*)
-	;;
-      *)
-	lt_prog_compiler_can_build_shared_CXX=no
-	;;
-    esac
-  fi
 
-case $host_os in
-  # For platforms which do not support PIC, -DPIC is meaningless:
-  *djgpp*)
-    lt_prog_compiler_pic_CXX=
-    ;;
-  *)
-    lt_prog_compiler_pic_CXX="$lt_prog_compiler_pic_CXX -DPIC"
-    ;;
-esac
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_prog_compiler_pic_CXX" >&5
-$as_echo "$lt_prog_compiler_pic_CXX" >&6; }
+	exp_sym_flag='-bexport'
+	no_entry_flag='-bnoentry'
+      fi
+
+      # When large executables or shared objects are built, AIX ld can
+      # have problems creating the table of contents.  If linking a library
+      # or program results in "error TOC overflow" add -mminimal-toc to
+      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
 
+      archive_cmds_GCJ=''
+      hardcode_direct_GCJ=yes
+      hardcode_libdir_separator_GCJ=':'
+      link_all_deplibs_GCJ=yes
 
+      if test "$GCC" = yes; then
+	case $host_os in aix4.[012]|aix4.[012].*)
+	# We only want to do this on AIX 4.2 and lower, the check
+	# below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" && \
+  	   strings "$collect2name" | grep resolve_lib_name >/dev/null
+	  then
+  	  # We have reworked collect2
+  	  hardcode_direct_GCJ=yes
+	  else
+  	  # We have old collect2
+  	  hardcode_direct_GCJ=unsupported
+  	  # It fails to find uninstalled libraries when the uninstalled
+  	  # path is not listed in the libpath.  Setting hardcode_minus_L
+  	  # to unsupported forces relinking
+  	  hardcode_minus_L_GCJ=yes
+  	  hardcode_libdir_flag_spec_GCJ='-L$libdir'
+  	  hardcode_libdir_separator_GCJ=
+	  fi
+	  ;;
+	esac
+	shared_flag='-shared'
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag="$shared_flag "'${wl}-G'
+	fi
+      else
+	# not using gcc
+	if test "$host_cpu" = ia64; then
+  	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+  	# chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+	else
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag='${wl}-G'
+	  else
+	    shared_flag='${wl}-bM:SRE'
+	  fi
+	fi
+      fi
 
-#
-# Check to make sure the PIC flag actually works.
-#
-if test -n "$lt_prog_compiler_pic_CXX"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic_CXX works" >&5
-$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic_CXX works... " >&6; }
-if test "${lt_cv_prog_compiler_pic_works_CXX+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_pic_works_CXX=no
-   ac_outfile=conftest.$ac_objext
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-   lt_compiler_flag="$lt_prog_compiler_pic_CXX -DPIC"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   # The option is referenced via a variable to avoid confusing sed.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:13436: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>conftest.err)
-   ac_status=$?
-   cat conftest.err >&5
-   echo "$as_me:13440: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s "$ac_outfile"; then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings other than the usual output.
-     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
-     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_pic_works_CXX=yes
-     fi
-   fi
-   $RM conftest*
+      # It seems that -bexpall does not export symbols beginning with
+      # underscore (_), so it is better to generate a list of symbols to export.
+      always_export_symbols_GCJ=yes
+      if test "$aix_use_runtimelinking" = yes; then
+	# Warning - without using the other runtime loading flags (-brtl),
+	# -berok will link without error, but may produce a broken library.
+	allow_undefined_flag_GCJ='-berok'
+       # Determine the default libpath from the value encoded in an empty executable.
+       cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_works_CXX" >&5
-$as_echo "$lt_cv_prog_compiler_pic_works_CXX" >&6; }
+int
+main ()
+{
 
-if test x"$lt_cv_prog_compiler_pic_works_CXX" = xyes; then
-    case $lt_prog_compiler_pic_CXX in
-     "" | " "*) ;;
-     *) lt_prog_compiler_pic_CXX=" $lt_prog_compiler_pic_CXX" ;;
-     esac
-else
-    lt_prog_compiler_pic_CXX=
-     lt_prog_compiler_can_build_shared_CXX=no
-fi
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
 
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`; fi
 fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
 
+       hardcode_libdir_flag_spec_GCJ='${wl}-blibpath:$libdir:'"$aix_libpath"
+	archive_expsym_cmds_GCJ="\$CC"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then echo "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+       else
+	if test "$host_cpu" = ia64; then
+	  hardcode_libdir_flag_spec_GCJ='${wl}-R $libdir:/usr/lib:/lib'
+	  allow_undefined_flag_GCJ="-z nodefs"
+	  archive_expsym_cmds_GCJ="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	else
+	 # Determine the default libpath from the value encoded in an empty executable.
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
+int
+main ()
+{
 
-#
-# Check to make sure the static flag actually works.
-#
-wl=$lt_prog_compiler_wl_CXX eval lt_tmp_static_flag=\"$lt_prog_compiler_static_CXX\"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
-$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
-if test "${lt_cv_prog_compiler_static_works_CXX+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_static_works_CXX=no
-   save_LDFLAGS="$LDFLAGS"
-   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
-   echo "$lt_simple_link_test_code" > conftest.$ac_ext
-   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
-     # The linker can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     if test -s conftest.err; then
-       # Append any errors to the config.log.
-       cat conftest.err 1>&5
-       $ECHO "X$_lt_linker_boilerplate" | $Xsed -e '/^$/d' > conftest.exp
-       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-       if diff conftest.exp conftest.er2 >/dev/null; then
-         lt_cv_prog_compiler_static_works_CXX=yes
-       fi
-     else
-       lt_cv_prog_compiler_static_works_CXX=yes
-     fi
-   fi
-   $RM -r conftest*
-   LDFLAGS="$save_LDFLAGS"
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
 
+aix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+# Check for a 64-bit object if we didn't find anything.
+if test -z "$aix_libpath"; then aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`; fi
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_static_works_CXX" >&5
-$as_echo "$lt_cv_prog_compiler_static_works_CXX" >&6; }
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+if test -z "$aix_libpath"; then aix_libpath="/usr/lib:/lib"; fi
 
-if test x"$lt_cv_prog_compiler_static_works_CXX" = xyes; then
-    :
-else
-    lt_prog_compiler_static_CXX=
-fi
+	 hardcode_libdir_flag_spec_GCJ='${wl}-blibpath:$libdir:'"$aix_libpath"
+	  # Warning - without using the other run time loading flags,
+	  # -berok will link without error, but may produce a broken library.
+	  no_undefined_flag_GCJ=' ${wl}-bernotok'
+	  allow_undefined_flag_GCJ=' ${wl}-berok'
+	  # Exported symbols can be pulled into shared objects from archives
+	  whole_archive_flag_spec_GCJ='$convenience'
+	  archive_cmds_need_lc_GCJ=yes
+	  # This is similar to how AIX traditionally builds its shared libraries.
+	  archive_expsym_cmds_GCJ="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	fi
+      fi
+      ;;
 
+    amigaos*)
+      archive_cmds_GCJ='$rm $output_objdir/a2ixlibrary.data~$echo "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$echo "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$echo "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$echo "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+      hardcode_libdir_flag_spec_GCJ='-L$libdir'
+      hardcode_minus_L_GCJ=yes
+      # see comment about different semantics on the GNU ld section
+      ld_shlibs_GCJ=no
+      ;;
 
+    bsdi[45]*)
+      export_dynamic_flag_spec_GCJ=-rdynamic
+      ;;
 
+    cygwin* | mingw* | pw32*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec_GCJ=' '
+      allow_undefined_flag_GCJ=unsupported
+      # Tell ltmain to make .lib files, not .a files.
+      libext=lib
+      # Tell ltmain to make .dll files, not .so files.
+      shrext_cmds=".dll"
+      # FIXME: Setting linknames here is a bad hack.
+      archive_cmds_GCJ='$CC -o $lib $libobjs $compiler_flags `echo "$deplibs" | $SED -e '\''s/ -lc$//'\''` -link -dll~linknames='
+      # The linker will automatically build a .lib file if we build a DLL.
+      old_archive_From_new_cmds_GCJ='true'
+      # FIXME: Should let the user specify the lib program.
+      old_archive_cmds_GCJ='lib /OUT:$oldlib$oldobjs$old_deplibs'
+      fix_srcfile_path_GCJ='`cygpath -w "$srcfile"`'
+      enable_shared_with_static_runtimes_GCJ=yes
+      ;;
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
-$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
-if test "${lt_cv_prog_compiler_c_o_CXX+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_c_o_CXX=no
-   $RM -r conftest 2>/dev/null
-   mkdir conftest
-   cd conftest
-   mkdir out
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+    darwin* | rhapsody*)
+      case $host_os in
+        rhapsody* | darwin1.[012])
+         allow_undefined_flag_GCJ='${wl}-undefined ${wl}suppress'
+         ;;
+       *) # Darwin 1.3 on
+         if test -z ${MACOSX_DEPLOYMENT_TARGET} ; then
+           allow_undefined_flag_GCJ='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
+         else
+           case ${MACOSX_DEPLOYMENT_TARGET} in
+             10.[012])
+               allow_undefined_flag_GCJ='${wl}-flat_namespace ${wl}-undefined ${wl}suppress'
+               ;;
+             10.*)
+               allow_undefined_flag_GCJ='${wl}-undefined ${wl}dynamic_lookup'
+               ;;
+           esac
+         fi
+         ;;
+      esac
+      archive_cmds_need_lc_GCJ=no
+      hardcode_direct_GCJ=no
+      hardcode_automatic_GCJ=yes
+      hardcode_shlibpath_var_GCJ=unsupported
+      whole_archive_flag_spec_GCJ=''
+      link_all_deplibs_GCJ=yes
+    if test "$GCC" = yes ; then
+    	output_verbose_link_cmd='echo'
+        archive_cmds_GCJ='$CC -dynamiclib $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring'
+      module_cmds_GCJ='$CC $allow_undefined_flag -o $lib -bundle $libobjs $deplibs$compiler_flags'
+      # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin lds
+      archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -dynamiclib $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+      module_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC $allow_undefined_flag  -o $lib -bundle $libobjs $deplibs$compiler_flags~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+    else
+      case $cc_basename in
+        xlc*)
+         output_verbose_link_cmd='echo'
+         archive_cmds_GCJ='$CC -qmkshrobj $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-install_name ${wl}`echo $rpath/$soname` $verstring'
+         module_cmds_GCJ='$CC $allow_undefined_flag -o $lib -bundle $libobjs $deplibs$compiler_flags'
+          # Don't fix this by using the ld -exported_symbols_list flag, it doesn't exist in older darwin lds
+         archive_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -qmkshrobj $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-install_name ${wl}$rpath/$soname $verstring~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          module_expsym_cmds_GCJ='sed -e "s,#.*,," -e "s,^[    ]*,," -e "s,^\(..*\),_&," < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC $allow_undefined_flag  -o $lib -bundle $libobjs $deplibs$compiler_flags~nmedit -s $output_objdir/${libname}-symbols.expsym ${lib}'
+          ;;
+       *)
+         ld_shlibs_GCJ=no
+          ;;
+      esac
+    fi
+      ;;
 
-   lt_compiler_flag="-o out/conftest2.$ac_objext"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:13535: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>out/conftest.err)
-   ac_status=$?
-   cat out/conftest.err >&5
-   echo "$as_me:13539: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s out/conftest2.$ac_objext
-   then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
-     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
-     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_c_o_CXX=yes
-     fi
-   fi
-   chmod u+w . 2>&5
-   $RM conftest*
-   # SGI C++ compiler will create directory out/ii_files/ for
-   # template instantiation
-   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
-   $RM out/* && rmdir out
-   cd ..
-   $RM -r conftest
-   $RM conftest*
+    dgux*)
+      archive_cmds_GCJ='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec_GCJ='-L$libdir'
+      hardcode_shlibpath_var_GCJ=no
+      ;;
+
+    freebsd1*)
+      ld_shlibs_GCJ=no
+      ;;
+
+    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+    # support.  Future versions do this automatically, but an explicit c++rt0.o
+    # does not break anything, and helps significantly (at the cost of a little
+    # extra space).
+    freebsd2.2*)
+      archive_cmds_GCJ='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
+      hardcode_libdir_flag_spec_GCJ='-R$libdir'
+      hardcode_direct_GCJ=yes
+      hardcode_shlibpath_var_GCJ=no
+      ;;
+
+    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
+    freebsd2*)
+      archive_cmds_GCJ='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct_GCJ=yes
+      hardcode_minus_L_GCJ=yes
+      hardcode_shlibpath_var_GCJ=no
+      ;;
+
+    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
+    freebsd* | kfreebsd*-gnu | dragonfly*)
+      archive_cmds_GCJ='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'
+      hardcode_libdir_flag_spec_GCJ='-R$libdir'
+      hardcode_direct_GCJ=yes
+      hardcode_shlibpath_var_GCJ=no
+      ;;
+
+    hpux9*)
+      if test "$GCC" = yes; then
+	archive_cmds_GCJ='$rm $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      else
+	archive_cmds_GCJ='$rm $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      fi
+      hardcode_libdir_flag_spec_GCJ='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator_GCJ=:
+      hardcode_direct_GCJ=yes
+
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      hardcode_minus_L_GCJ=yes
+      export_dynamic_flag_spec_GCJ='${wl}-E'
+      ;;
+
+    hpux10*)
+      if test "$GCC" = yes -a "$with_gnu_ld" = no; then
+	archive_cmds_GCJ='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds_GCJ='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec_GCJ='${wl}+b ${wl}$libdir'
+	hardcode_libdir_separator_GCJ=:
+
+	hardcode_direct_GCJ=yes
+	export_dynamic_flag_spec_GCJ='${wl}-E'
+
+	# hardcode_minus_L: Not really in the search PATH,
+	# but as the default location of the library.
+	hardcode_minus_L_GCJ=yes
+      fi
+      ;;
+
+    hpux11*)
+      if test "$GCC" = yes -a "$with_gnu_ld" = no; then
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds_GCJ='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds_GCJ='$CC -shared ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds_GCJ='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      else
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds_GCJ='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds_GCJ='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds_GCJ='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec_GCJ='${wl}+b ${wl}$libdir'
+	hardcode_libdir_separator_GCJ=:
+
+	case $host_cpu in
+	hppa*64*|ia64*)
+	  hardcode_libdir_flag_spec_ld_GCJ='+b $libdir'
+	  hardcode_direct_GCJ=no
+	  hardcode_shlibpath_var_GCJ=no
+	  ;;
+	*)
+	  hardcode_direct_GCJ=yes
+	  export_dynamic_flag_spec_GCJ='${wl}-E'
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o_CXX" >&5
-$as_echo "$lt_cv_prog_compiler_c_o_CXX" >&6; }
+	  # hardcode_minus_L: Not really in the search PATH,
+	  # but as the default location of the library.
+	  hardcode_minus_L_GCJ=yes
+	  ;;
+	esac
+      fi
+      ;;
 
+    irix5* | irix6* | nonstopux*)
+      if test "$GCC" = yes; then
+	archive_cmds_GCJ='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	archive_cmds_GCJ='$LD -shared $libobjs $deplibs $linker_flags -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+	hardcode_libdir_flag_spec_ld_GCJ='-rpath $libdir'
+      fi
+      hardcode_libdir_flag_spec_GCJ='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator_GCJ=:
+      link_all_deplibs_GCJ=yes
+      ;;
 
+    netbsd*)
+      if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
+	archive_cmds_GCJ='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
+      else
+	archive_cmds_GCJ='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
+      fi
+      hardcode_libdir_flag_spec_GCJ='-R$libdir'
+      hardcode_direct_GCJ=yes
+      hardcode_shlibpath_var_GCJ=no
+      ;;
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
-$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
-if test "${lt_cv_prog_compiler_c_o_CXX+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_c_o_CXX=no
-   $RM -r conftest 2>/dev/null
-   mkdir conftest
-   cd conftest
-   mkdir out
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+    newsos6)
+      archive_cmds_GCJ='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct_GCJ=yes
+      hardcode_libdir_flag_spec_GCJ='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator_GCJ=:
+      hardcode_shlibpath_var_GCJ=no
+      ;;
 
-   lt_compiler_flag="-o out/conftest2.$ac_objext"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:13587: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>out/conftest.err)
-   ac_status=$?
-   cat out/conftest.err >&5
-   echo "$as_me:13591: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s out/conftest2.$ac_objext
-   then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     $ECHO "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
-     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
-     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_c_o_CXX=yes
-     fi
-   fi
-   chmod u+w . 2>&5
-   $RM conftest*
-   # SGI C++ compiler will create directory out/ii_files/ for
-   # template instantiation
-   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
-   $RM out/* && rmdir out
-   cd ..
-   $RM -r conftest
-   $RM conftest*
+    openbsd*)
+      hardcode_direct_GCJ=yes
+      hardcode_shlibpath_var_GCJ=no
+      if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	archive_cmds_GCJ='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds_GCJ='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
+	hardcode_libdir_flag_spec_GCJ='${wl}-rpath,$libdir'
+	export_dynamic_flag_spec_GCJ='${wl}-E'
+      else
+       case $host_os in
+	 openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+	   archive_cmds_GCJ='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+	   hardcode_libdir_flag_spec_GCJ='-R$libdir'
+	   ;;
+	 *)
+	   archive_cmds_GCJ='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	   hardcode_libdir_flag_spec_GCJ='${wl}-rpath,$libdir'
+	   ;;
+       esac
+      fi
+      ;;
 
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o_CXX" >&5
-$as_echo "$lt_cv_prog_compiler_c_o_CXX" >&6; }
+    os2*)
+      hardcode_libdir_flag_spec_GCJ='-L$libdir'
+      hardcode_minus_L_GCJ=yes
+      allow_undefined_flag_GCJ=unsupported
+      archive_cmds_GCJ='$echo "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$echo "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~$echo DATA >> $output_objdir/$libname.def~$echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~$echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
+      old_archive_From_new_cmds_GCJ='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+      ;;
 
+    osf3*)
+      if test "$GCC" = yes; then
+	allow_undefined_flag_GCJ=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds_GCJ='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	allow_undefined_flag_GCJ=' -expect_unresolved \*'
+	archive_cmds_GCJ='$LD -shared${allow_undefined_flag} $libobjs $deplibs $linker_flags -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+      fi
+      hardcode_libdir_flag_spec_GCJ='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator_GCJ=:
+      ;;
 
+    osf4* | osf5*)	# as osf3* with the addition of -msym flag
+      if test "$GCC" = yes; then
+	allow_undefined_flag_GCJ=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds_GCJ='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && echo ${wl}-set_version ${wl}$verstring` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	hardcode_libdir_flag_spec_GCJ='${wl}-rpath ${wl}$libdir'
+      else
+	allow_undefined_flag_GCJ=' -expect_unresolved \*'
+	archive_cmds_GCJ='$LD -shared${allow_undefined_flag} $libobjs $deplibs $linker_flags -msym -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_expsym_cmds_GCJ='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; echo "-hidden">> $lib.exp~
+	$LD -shared${allow_undefined_flag} -input $lib.exp $linker_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && echo -set_version $verstring` -update_registry ${output_objdir}/so_locations -o $lib~$rm $lib.exp'
 
+	# Both c and cxx compiler support -rpath directly
+	hardcode_libdir_flag_spec_GCJ='-rpath $libdir'
+      fi
+      hardcode_libdir_separator_GCJ=:
+      ;;
 
-hard_links="nottested"
-if test "$lt_cv_prog_compiler_c_o_CXX" = no && test "$need_locks" != no; then
-  # do not overwrite the value of need_locks provided by the user
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
-$as_echo_n "checking if we can lock with hard links... " >&6; }
-  hard_links=yes
-  $RM conftest*
-  ln conftest.a conftest.b 2>/dev/null && hard_links=no
-  touch conftest.a
-  ln conftest.a conftest.b 2>&5 || hard_links=no
-  ln conftest.a conftest.b 2>/dev/null && hard_links=no
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
-$as_echo "$hard_links" >&6; }
-  if test "$hard_links" = no; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
-$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
-    need_locks=warn
-  fi
-else
-  need_locks=no
-fi
+    solaris*)
+      no_undefined_flag_GCJ=' -z text'
+      if test "$GCC" = yes; then
+	wlarc='${wl}'
+	archive_cmds_GCJ='$CC -shared ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds_GCJ='$echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~$echo "local: *; };" >> $lib.exp~
+	  $CC -shared ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$rm $lib.exp'
+      else
+	wlarc=''
+	archive_cmds_GCJ='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	archive_expsym_cmds_GCJ='$echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~$echo "local: *; };" >> $lib.exp~
+  	$LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$rm $lib.exp'
+      fi
+      hardcode_libdir_flag_spec_GCJ='-R$libdir'
+      hardcode_shlibpath_var_GCJ=no
+      case $host_os in
+      solaris2.[0-5] | solaris2.[0-5].*) ;;
+      *)
+ 	# The compiler driver will combine linker options so we
+ 	# cannot just pass the convience library names through
+ 	# without $wl, iff we do not link with $LD.
+ 	# Luckily, gcc supports the same syntax we need for Sun Studio.
+ 	# Supported since Solaris 2.6 (maybe 2.5.1?)
+ 	case $wlarc in
+ 	'')
+ 	  whole_archive_flag_spec_GCJ='-z allextract$convenience -z defaultextract' ;;
+ 	*)
+ 	  whole_archive_flag_spec_GCJ='${wl}-z ${wl}allextract`for conv in $convenience\"\"; do test -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; $echo \"$new_convenience\"` ${wl}-z ${wl}defaultextract' ;;
+ 	esac ;;
+      esac
+      link_all_deplibs_GCJ=yes
+      ;;
 
+    sunos4*)
+      if test "x$host_vendor" = xsequent; then
+	# Use $CC to link under sequent, because it throws in some extra .o
+	# files that make .init and .fini sections work.
+	archive_cmds_GCJ='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds_GCJ='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      hardcode_libdir_flag_spec_GCJ='-L$libdir'
+      hardcode_direct_GCJ=yes
+      hardcode_minus_L_GCJ=yes
+      hardcode_shlibpath_var_GCJ=no
+      ;;
 
+    sysv4)
+      case $host_vendor in
+	sni)
+	  archive_cmds_GCJ='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct_GCJ=yes # is this really true???
+	;;
+	siemens)
+	  ## LD is ld it makes a PLAMLIB
+	  ## CC just makes a GrossModule.
+	  archive_cmds_GCJ='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+	  reload_cmds_GCJ='$CC -r -o $output$reload_objs'
+	  hardcode_direct_GCJ=no
+        ;;
+	motorola)
+	  archive_cmds_GCJ='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct_GCJ=no #Motorola manual says yes, but my tests say they lie
+	;;
+      esac
+      runpath_var='LD_RUN_PATH'
+      hardcode_shlibpath_var_GCJ=no
+      ;;
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
-$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
+    sysv4.3*)
+      archive_cmds_GCJ='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_shlibpath_var_GCJ=no
+      export_dynamic_flag_spec_GCJ='-Bexport'
+      ;;
 
-  export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
-  case $host_os in
-  aix[4-9]*)
-    # If we're using GNU nm, then we don't want the "-C" option.
-    # -C means demangle to AIX nm, but means don't demangle with GNU nm
-    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
-      export_symbols_cmds_CXX='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
-    else
-      export_symbols_cmds_CXX='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
-    fi
-    ;;
-  pw32*)
-    export_symbols_cmds_CXX="$ltdll_cmds"
-  ;;
-  cygwin* | mingw* | cegcc*)
-    export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1 DATA/;/^.*[ ]__nm__/s/^.*[ ]__nm__\([^ ]*\)[ ][^ ]*/\1 DATA/;/^I[ ]/d;/^[AITW][ ]/s/.* //'\'' | sort | uniq > $export_symbols'
-  ;;
-  *)
-    export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
-  ;;
-  esac
-  exclude_expsyms_CXX='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	archive_cmds_GCJ='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	hardcode_shlibpath_var_GCJ=no
+	runpath_var=LD_RUN_PATH
+	hardcode_runpath_var=yes
+	ld_shlibs_GCJ=yes
+      fi
+      ;;
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs_CXX" >&5
-$as_echo "$ld_shlibs_CXX" >&6; }
-test "$ld_shlibs_CXX" = no && can_build_shared=no
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7*)
+      no_undefined_flag_GCJ='${wl}-z,text'
+      archive_cmds_need_lc_GCJ=no
+      hardcode_shlibpath_var_GCJ=no
+      runpath_var='LD_RUN_PATH'
 
-with_gnu_ld_CXX=$with_gnu_ld
+      if test "$GCC" = yes; then
+	archive_cmds_GCJ='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds_GCJ='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds_GCJ='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds_GCJ='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
 
+    sysv5* | sco3.2v5* | sco5v6*)
+      # Note: We can NOT use -z defs as we might desire, because we do not
+      # link with -lc, and that would cause any symbols used from libc to
+      # always be unresolved, which means just about no library would
+      # ever link correctly.  If we're not using GNU ld we use -z text
+      # though, which does catch some bad symbols but isn't as heavy-handed
+      # as -z defs.
+      no_undefined_flag_GCJ='${wl}-z,text'
+      allow_undefined_flag_GCJ='${wl}-z,nodefs'
+      archive_cmds_need_lc_GCJ=no
+      hardcode_shlibpath_var_GCJ=no
+      hardcode_libdir_flag_spec_GCJ='`test -z "$SCOABSPATH" && echo ${wl}-R,$libdir`'
+      hardcode_libdir_separator_GCJ=':'
+      link_all_deplibs_GCJ=yes
+      export_dynamic_flag_spec_GCJ='${wl}-Bexport'
+      runpath_var='LD_RUN_PATH'
 
+      if test "$GCC" = yes; then
+	archive_cmds_GCJ='$CC -shared ${wl}-h,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds_GCJ='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds_GCJ='$CC -G ${wl}-h,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds_GCJ='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,\${SCOABSPATH:+${install_libdir}/}$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
 
+    uts4*)
+      archive_cmds_GCJ='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec_GCJ='-L$libdir'
+      hardcode_shlibpath_var_GCJ=no
+      ;;
 
+    *)
+      ld_shlibs_GCJ=no
+      ;;
+    esac
+  fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs_GCJ" >&5
+$as_echo "$ld_shlibs_GCJ" >&6; }
+test "$ld_shlibs_GCJ" = no && can_build_shared=no
 
 #
 # Do we need to explicitly link libc?
 #
-case "x$archive_cmds_need_lc_CXX" in
+case "x$archive_cmds_need_lc_GCJ" in
 x|xyes)
   # Assume -lc should be added
-  archive_cmds_need_lc_CXX=yes
+  archive_cmds_need_lc_GCJ=yes
 
   if test "$enable_shared" = yes && test "$GCC" = yes; then
-    case $archive_cmds_CXX in
+    case $archive_cmds_GCJ in
     *'~'*)
       # FIXME: we may have to deal with multi-command sequences.
       ;;
@@ -13696,8 +17222,8 @@
       # to ld, don't add -lc before -lgcc.
       { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
 $as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
-      $RM conftest*
-      echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+      $rm conftest*
+      printf "$lt_simple_compile_test_code" > conftest.$ac_ext
 
       if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
   (eval $ac_compile) 2>&5
@@ -13708,104 +17234,40 @@
         lib=conftest
         libobjs=conftest.$ac_objext
         deplibs=
-        wl=$lt_prog_compiler_wl_CXX
-	pic_flag=$lt_prog_compiler_pic_CXX
+        wl=$lt_prog_compiler_wl_GCJ
+	pic_flag=$lt_prog_compiler_pic_GCJ
         compiler_flags=-v
         linker_flags=-v
         verstring=
         output_objdir=.
         libname=conftest
-        lt_save_allow_undefined_flag=$allow_undefined_flag_CXX
-        allow_undefined_flag_CXX=
-        if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds_CXX 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\""; } >&5
-  (eval $archive_cmds_CXX 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1) 2>&5
+        lt_save_allow_undefined_flag=$allow_undefined_flag_GCJ
+        allow_undefined_flag_GCJ=
+        if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds_GCJ 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1\""; } >&5
+  (eval $archive_cmds_GCJ 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1) 2>&5
   ac_status=$?
   $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
   test $ac_status = 0; }
         then
-	  archive_cmds_need_lc_CXX=no
+	  archive_cmds_need_lc_GCJ=no
         else
-	  archive_cmds_need_lc_CXX=yes
+	  archive_cmds_need_lc_GCJ=yes
         fi
-        allow_undefined_flag_CXX=$lt_save_allow_undefined_flag
+        allow_undefined_flag_GCJ=$lt_save_allow_undefined_flag
       else
         cat conftest.err 1>&5
       fi
-      $RM conftest*
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $archive_cmds_need_lc_CXX" >&5
-$as_echo "$archive_cmds_need_lc_CXX" >&6; }
+      $rm conftest*
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: $archive_cmds_need_lc_GCJ" >&5
+$as_echo "$archive_cmds_need_lc_GCJ" >&6; }
       ;;
     esac
   fi
   ;;
-esac
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
+esac
 
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
 $as_echo_n "checking dynamic linker characteristics... " >&6; }
-
 library_names_spec=
 libname_spec='lib$name'
 soname_spec=
@@ -13819,6 +17281,20 @@
 version_type=none
 dynamic_linker="$host_os ld.so"
 sys_lib_dlsearch_path_spec="/lib /usr/lib"
+if test "$GCC" = yes; then
+  sys_lib_search_path_spec=`$CC -print-search-dirs | grep "^libraries:" | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+  if echo "$sys_lib_search_path_spec" | grep ';' >/dev/null ; then
+    # if the path contains ";" then we assume it to be the separator
+    # otherwise default to the standard path separator (i.e. ":") - it is
+    # assumed that no part of a normal pathname contains ";" but that should
+    # okay in the real world where ";" in dirpaths is itself problematic.
+    sys_lib_search_path_spec=`echo "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
+  else
+    sys_lib_search_path_spec=`echo "$sys_lib_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+  fi
+else
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+fi
 need_lib_prefix=unknown
 hardcode_into_libs=no
 
@@ -13836,7 +17312,7 @@
   soname_spec='${libname}${release}${shared_ext}$major'
   ;;
 
-aix[4-9]*)
+aix4* | aix5*)
   version_type=linux
   need_lib_prefix=no
   need_version=no
@@ -13855,7 +17331,7 @@
       aix4 | aix4.[01] | aix4.[01].*)
       if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
 	   echo ' yes '
-	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	   echo '#endif'; } | ${CC} -E - | grep yes > /dev/null; then
 	:
       else
 	can_build_shared=no
@@ -13881,18 +17357,9 @@
   ;;
 
 amigaos*)
-  case $host_cpu in
-  powerpc)
-    # Since July 2007 AmigaOS4 officially supports .so libraries.
-    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    ;;
-  m68k)
-    library_names_spec='$libname.ixlibrary $libname.a'
-    # Create ${libname}_ixlibrary.a entries in /sys/libs.
-    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$ECHO "X$lib" | $Xsed -e '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
-    ;;
-  esac
+  library_names_spec='$libname.ixlibrary $libname.a'
+  # Create ${libname}_ixlibrary.a entries in /sys/libs.
+  finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$echo "X$lib" | $Xsed -e '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $rm /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
   ;;
 
 beos*)
@@ -13915,28 +17382,25 @@
   # libtool to hard-code these into programs
   ;;
 
-cygwin* | mingw* | pw32* | cegcc*)
+cygwin* | mingw* | pw32*)
   version_type=windows
   shrext_cmds=".dll"
   need_version=no
   need_lib_prefix=no
 
   case $GCC,$host_os in
-  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)
+  yes,cygwin* | yes,mingw* | yes,pw32*)
     library_names_spec='$libname.dll.a'
     # DLL is installed to $(libdir)/../bin by postinstall_cmds
     postinstall_cmds='base_file=`basename \${file}`~
-      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i;echo \$dlname'\''`~
       dldir=$destdir/`dirname \$dlpath`~
       test -d \$dldir || mkdir -p \$dldir~
       $install_prog $dir/$dlname \$dldir/$dlname~
-      chmod a+x \$dldir/$dlname~
-      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
-        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
-      fi'
+      chmod a+x \$dldir/$dlname'
     postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
       dlpath=$dir/\$dldll~
-       $RM \$dlpath'
+       $rm \$dlpath'
     shlibpath_overrides_runpath=yes
 
     case $host_os in
@@ -13945,20 +17409,20 @@
       soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
       sys_lib_search_path_spec="/usr/lib /lib/w32api /lib /usr/local/lib"
       ;;
-    mingw* | cegcc*)
+    mingw*)
       # MinGW DLLs use traditional 'lib' prefix
       soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-      sys_lib_search_path_spec=`$CC -print-search-dirs | $GREP "^libraries:" | $SED -e "s/^libraries://" -e "s,=/,/,g"`
-      if $ECHO "$sys_lib_search_path_spec" | $GREP ';[c-zC-Z]:/' >/dev/null; then
+      sys_lib_search_path_spec=`$CC -print-search-dirs | grep "^libraries:" | $SED -e "s/^libraries://" -e "s,=/,/,g"`
+      if echo "$sys_lib_search_path_spec" | grep ';[c-zC-Z]:/' >/dev/null; then
         # It is most probably a Windows format PATH printed by
         # mingw gcc, but we are running on Cygwin. Gcc prints its search
         # path with ; separators, and with drive letters. We can handle the
         # drive letters (cygwin fileutils understands them), so leave them,
         # especially as we might pass files found there to a mingw objdump,
         # which wouldn't understand a cygwinified path. Ahh.
-        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
+        sys_lib_search_path_spec=`echo "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
       else
-        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
+        sys_lib_search_path_spec=`echo "$sys_lib_search_path_spec" | $SED  -e "s/$PATH_SEPARATOR/ /g"`
       fi
       ;;
     pw32*)
@@ -13982,12 +17446,17 @@
   version_type=darwin
   need_lib_prefix=no
   need_version=no
-  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  library_names_spec='${libname}${release}${versuffix}$shared_ext ${libname}${release}${major}$shared_ext ${libname}$shared_ext'
   soname_spec='${libname}${release}${major}$shared_ext'
   shlibpath_overrides_runpath=yes
   shlibpath_var=DYLD_LIBRARY_PATH
   shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
-
+  # Apple's gcc prints 'gcc -print-search-dirs' doesn't operate the same.
+  if test "$GCC" = yes; then
+    sys_lib_search_path_spec=`$CC -print-search-dirs | tr "\n" "$PATH_SEPARATOR" | sed -e 's/libraries:/@libraries:/' | tr "@" "\n" | grep "^libraries:" | sed -e "s/^libraries://" -e "s,=/,/,g" -e "s,$PATH_SEPARATOR, ,g" -e "s,.*,& /lib /usr/lib /usr/local/lib,g"`
+  else
+    sys_lib_search_path_spec='/lib /usr/lib /usr/local/lib'
+  fi
   sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
   ;;
 
@@ -14004,6 +17473,18 @@
   dynamic_linker=no
   ;;
 
+kfreebsd*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='GNU ld.so'
+  ;;
+
 freebsd* | dragonfly*)
   # DragonFly does not have aout.  When/if they implement a new
   # versioning mechanism, adjust this.
@@ -14041,7 +17522,7 @@
     shlibpath_overrides_runpath=no
     hardcode_into_libs=yes
     ;;
-  *) # from 4.6 on, and DragonFly
+  freebsd*) # from 4.6 on
     shlibpath_overrides_runpath=yes
     hardcode_into_libs=yes
     ;;
@@ -14080,18 +17561,18 @@
     fi
     sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
     ;;
-  hppa*64*)
-    shrext_cmds='.sl'
-    hardcode_into_libs=yes
-    dynamic_linker="$host_os dld.sl"
-    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
-    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
-    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
-    ;;
-  *)
+   hppa*64*)
+     shrext_cmds='.sl'
+     hardcode_into_libs=yes
+     dynamic_linker="$host_os dld.sl"
+     shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+     shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+     library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+     soname_spec='${libname}${release}${shared_ext}$major'
+     sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+     sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+     ;;
+   *)
     shrext_cmds='.sl'
     dynamic_linker="$host_os dld.sl"
     shlibpath_var=SHLIB_PATH
@@ -14104,7 +17585,7 @@
   postinstall_cmds='chmod 555 $lib'
   ;;
 
-interix[3-9]*)
+interix3*)
   version_type=linux
   need_lib_prefix=no
   need_version=no
@@ -14159,7 +17640,7 @@
   ;;
 
 # This must be Linux ELF.
-linux* | k*bsd*-gnu)
+linux*)
   version_type=linux
   need_lib_prefix=no
   need_version=no
@@ -14168,41 +17649,36 @@
   finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
   shlibpath_var=LD_LIBRARY_PATH
   shlibpath_overrides_runpath=no
-  # Some binutils ld are patched to set DT_RUNPATH
-  save_LDFLAGS=$LDFLAGS
-  save_libdir=$libdir
-  eval "libdir=/foo; wl=\"$lt_prog_compiler_wl_CXX\"; \
-       LDFLAGS=\"\$LDFLAGS $hardcode_libdir_flag_spec_CXX\""
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then :
-  shlibpath_overrides_runpath=yes
-fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-  LDFLAGS=$save_LDFLAGS
-  libdir=$save_libdir
-
   # This implies no fast_install, which is unacceptable.
   # Some rework will be needed to allow for fast_install
   # before this can be enabled.
   hardcode_into_libs=yes
 
+  # find out which ABI we are using
+  libsuff=
+  case "$host_cpu" in
+  x86_64*|s390x*|powerpc64*)
+    echo '#line 17661 "configure"' > conftest.$ac_ext
+    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+      case `/usr/bin/file conftest.$ac_objext` in
+      *64-bit*)
+        libsuff=64
+        sys_lib_search_path_spec="/lib${libsuff} /usr/lib${libsuff} /usr/local/lib${libsuff}"
+        ;;
+      esac
+    fi
+    rm -rf conftest*
+    ;;
+  esac
+
   # Append ld.so.conf contents to the search path
   if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
-    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib${libsuff} /usr/lib${libsuff} $lt_ld_extra"
   fi
 
   # We used to test for /lib/ld.so.1 and disable shared libraries on
@@ -14214,11 +17690,23 @@
   dynamic_linker='GNU/Linux ld.so'
   ;;
 
+knetbsd*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='GNU ld.so'
+  ;;
+
 netbsd*)
   version_type=sunos
   need_lib_prefix=no
   need_version=no
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+  if echo __ELF__ | $CC -E - | grep __ELF__ >/dev/null; then
     library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
     finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
     dynamic_linker='NetBSD (a.out) ld.so'
@@ -14239,16 +17727,14 @@
   shlibpath_overrides_runpath=yes
   ;;
 
-*nto* | *qnx*)
-  version_type=qnx
+nto-qnx*)
+  version_type=linux
   need_lib_prefix=no
   need_version=no
   library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
   soname_spec='${libname}${release}${shared_ext}$major'
   shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  dynamic_linker='ldqnx.so'
+  shlibpath_overrides_runpath=yes
   ;;
 
 openbsd*)
@@ -14257,13 +17743,13 @@
   need_lib_prefix=no
   # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
   case $host_os in
-    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
-    *)				need_version=no  ;;
+    openbsd3.3 | openbsd3.3.*) need_version=yes ;;
+    *)                         need_version=no  ;;
   esac
   library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
   finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
   shlibpath_var=LD_LIBRARY_PATH
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
     case $host_os in
       openbsd2.[89] | openbsd2.[89].*)
 	shlibpath_overrides_runpath=no
@@ -14297,10 +17783,6 @@
   sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
   ;;
 
-rdos*)
-  dynamic_linker=no
-  ;;
-
 solaris*)
   version_type=linux
   need_lib_prefix=no
@@ -14335,6 +17817,7 @@
     sni)
       shlibpath_overrides_runpath=no
       need_lib_prefix=no
+      export_dynamic_flag_spec='${wl}-Blargedynsym'
       runpath_var=LD_RUN_PATH
       ;;
     siemens)
@@ -14365,12 +17848,13 @@
   library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
   soname_spec='${libname}${release}${shared_ext}$major'
   shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
   hardcode_into_libs=yes
   if test "$with_gnu_ld" = yes; then
     sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+    shlibpath_overrides_runpath=no
   else
     sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    shlibpath_overrides_runpath=yes
     case $host_os in
       sco3.2v5*)
         sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
@@ -14380,17 +17864,6 @@
   sys_lib_dlsearch_path_spec='/usr/lib'
   ;;
 
-tpf*)
-  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  ;;
-
 uts4*)
   version_type=linux
   library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
@@ -14411,78 +17884,35 @@
   variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
 fi
 
-if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
-  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
-fi
-if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
-  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
 $as_echo_n "checking how to hardcode library paths into programs... " >&6; }
-hardcode_action_CXX=
-if test -n "$hardcode_libdir_flag_spec_CXX" ||
-   test -n "$runpath_var_CXX" ||
-   test "X$hardcode_automatic_CXX" = "Xyes" ; then
+hardcode_action_GCJ=
+if test -n "$hardcode_libdir_flag_spec_GCJ" || \
+   test -n "$runpath_var_GCJ" || \
+   test "X$hardcode_automatic_GCJ" = "Xyes" ; then
 
-  # We can hardcode non-existent directories.
-  if test "$hardcode_direct_CXX" != no &&
+  # We can hardcode non-existant directories.
+  if test "$hardcode_direct_GCJ" != no &&
      # If the only mechanism to avoid hardcoding is shlibpath_var, we
      # have to relink, otherwise we might link with an installed library
      # when we should be linking with a yet-to-be-installed one
-     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, CXX)" != no &&
-     test "$hardcode_minus_L_CXX" != no; then
+     ## test "$_LT_AC_TAGVAR(hardcode_shlibpath_var, GCJ)" != no &&
+     test "$hardcode_minus_L_GCJ" != no; then
     # Linking always hardcodes the temporary library directory.
-    hardcode_action_CXX=relink
+    hardcode_action_GCJ=relink
   else
     # We can link without hardcoding, and we can hardcode nonexisting dirs.
-    hardcode_action_CXX=immediate
+    hardcode_action_GCJ=immediate
   fi
 else
   # We cannot hardcode anything, or else we can only hardcode existing
   # directories.
-  hardcode_action_CXX=unsupported
+  hardcode_action_GCJ=unsupported
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action_CXX" >&5
-$as_echo "$hardcode_action_CXX" >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action_GCJ" >&5
+$as_echo "$hardcode_action_GCJ" >&6; }
 
-if test "$hardcode_action_CXX" = relink ||
-   test "$inherit_rpath_CXX" = yes; then
+if test "$hardcode_action_GCJ" = relink; then
   # Fast installation is not supported
   enable_fast_install=no
 elif test "$shlibpath_overrides_runpath" = yes ||
@@ -14492,1467 +17922,1011 @@
 fi
 
 
+# The else clause should only fire when bootstrapping the
+# libtool distribution, otherwise you forgot to ship ltmain.sh
+# with your package, and you will get complaints that there are
+# no rules to generate ltmain.sh.
+if test -f "$ltmain"; then
+  # See if we are running on zsh, and set the options which allow our commands through
+  # without removal of \ escapes.
+  if test -n "${ZSH_VERSION+set}" ; then
+    setopt NO_GLOB_SUBST
+  fi
+  # Now quote all the things that may contain metacharacters while being
+  # careful not to overquote the AC_SUBSTed values.  We take copies of the
+  # variables and quote the copies for generation of the libtool script.
+  for var in echo old_CC old_CFLAGS AR AR_FLAGS EGREP RANLIB LN_S LTCC LTCFLAGS NM \
+    SED SHELL STRIP \
+    libname_spec library_names_spec soname_spec extract_expsyms_cmds \
+    old_striplib striplib file_magic_cmd finish_cmds finish_eval \
+    deplibs_check_method reload_flag reload_cmds need_locks \
+    lt_cv_sys_global_symbol_pipe lt_cv_sys_global_symbol_to_cdecl \
+    lt_cv_sys_global_symbol_to_c_name_address \
+    sys_lib_search_path_spec sys_lib_dlsearch_path_spec \
+    old_postinstall_cmds old_postuninstall_cmds \
+    compiler_GCJ \
+    CC_GCJ \
+    LD_GCJ \
+    lt_prog_compiler_wl_GCJ \
+    lt_prog_compiler_pic_GCJ \
+    lt_prog_compiler_static_GCJ \
+    lt_prog_compiler_no_builtin_flag_GCJ \
+    export_dynamic_flag_spec_GCJ \
+    thread_safe_flag_spec_GCJ \
+    whole_archive_flag_spec_GCJ \
+    enable_shared_with_static_runtimes_GCJ \
+    old_archive_cmds_GCJ \
+    old_archive_from_new_cmds_GCJ \
+    predep_objects_GCJ \
+    postdep_objects_GCJ \
+    predeps_GCJ \
+    postdeps_GCJ \
+    compiler_lib_search_path_GCJ \
+    archive_cmds_GCJ \
+    archive_expsym_cmds_GCJ \
+    postinstall_cmds_GCJ \
+    postuninstall_cmds_GCJ \
+    old_archive_from_expsyms_cmds_GCJ \
+    allow_undefined_flag_GCJ \
+    no_undefined_flag_GCJ \
+    export_symbols_cmds_GCJ \
+    hardcode_libdir_flag_spec_GCJ \
+    hardcode_libdir_flag_spec_ld_GCJ \
+    hardcode_libdir_separator_GCJ \
+    hardcode_automatic_GCJ \
+    module_cmds_GCJ \
+    module_expsym_cmds_GCJ \
+    lt_cv_prog_compiler_c_o_GCJ \
+    exclude_expsyms_GCJ \
+    include_expsyms_GCJ; do
+
+    case $var in
+    old_archive_cmds_GCJ | \
+    old_archive_from_new_cmds_GCJ | \
+    archive_cmds_GCJ | \
+    archive_expsym_cmds_GCJ | \
+    module_cmds_GCJ | \
+    module_expsym_cmds_GCJ | \
+    old_archive_from_expsyms_cmds_GCJ | \
+    export_symbols_cmds_GCJ | \
+    extract_expsyms_cmds | reload_cmds | finish_cmds | \
+    postinstall_cmds | postuninstall_cmds | \
+    old_postinstall_cmds | old_postuninstall_cmds | \
+    sys_lib_search_path_spec | sys_lib_dlsearch_path_spec)
+      # Double-quote double-evaled strings.
+      eval "lt_$var=\\\"\`\$echo \"X\$$var\" | \$Xsed -e \"\$double_quote_subst\" -e \"\$sed_quote_subst\" -e \"\$delay_variable_subst\"\`\\\""
+      ;;
+    *)
+      eval "lt_$var=\\\"\`\$echo \"X\$$var\" | \$Xsed -e \"\$sed_quote_subst\"\`\\\""
+      ;;
+    esac
+  done
 
+  case $lt_echo in
+  *'\$0 --fallback-echo"')
+    lt_echo=`$echo "X$lt_echo" | $Xsed -e 's/\\\\\\\$0 --fallback-echo"$/$0 --fallback-echo"/'`
+    ;;
+  esac
 
+cfgfile="$ofile"
 
+  cat <<__EOF__ >> "$cfgfile"
+# ### BEGIN LIBTOOL TAG CONFIG: $tagname
 
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
 
-  fi # test -n "$compiler"
-
-  CC=$lt_save_CC
-  LDCXX=$LD
-  LD=$lt_save_LD
-  GCC=$lt_save_GCC
-  with_gnu_ld=$lt_save_with_gnu_ld
-  lt_cv_path_LDCXX=$lt_cv_path_LD
-  lt_cv_path_LD=$lt_save_path_LD
-  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld
-  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld
-fi # test "$_lt_caught_CXX_error" != yes
-
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-
-
-
-
-
-
-
-
-
-
-
-
-
-        ac_config_commands="$ac_config_commands libtool"
-
-
-
-
-# Only expand once:
-
-
-
-
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for 64-bit OS" >&5
-$as_echo_n "checking for 64-bit OS... " >&6; }
-if test "$cross_compiling" = yes; then :
-  result="maybe"
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
- int main () {
-    if (sizeof(long) == 8) { return 0; } return 1; }
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-  result="yes"
-else
-  result="no"
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $result" >&5
-$as_echo "$result" >&6; }
-if test "$result" = "yes"; then
-
-$as_echo "#define HAVE_64BIT_OS 1" >>confdefs.h
+# Shell to use when invoking shell scripts.
+SHELL=$lt_SHELL
 
-fi
+# Whether or not to build shared libraries.
+build_libtool_libs=$enable_shared
 
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+# Whether or not to build static libraries.
+build_old_libs=$enable_static
 
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=$archive_cmds_need_lc_GCJ
 
+# Whether or not to disallow shared libs when runtime libs are static
+allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes_GCJ
 
-# Check whether --enable-python_module was given.
-if test "${enable_python_module+set}" = set; then :
-  enableval=$enable_python_module;  PYTHON_MODULE="$enableval"
+# Whether or not to optimize for fast installation.
+fast_install=$enable_fast_install
 
-fi
+# The host system.
+host_alias=$host_alias
+host=$host
+host_os=$host_os
 
+# The build system.
+build_alias=$build_alias
+build=$build
+build_os=$build_os
 
-if test "x$PYTHON_MODULE" = "xyes"; then
+# An echo program that does not interpret backslashes.
+echo=$lt_echo
 
-$as_echo "#define PYTHON_MODULE 1" >>confdefs.h
+# The archiver.
+AR=$lt_AR
+AR_FLAGS=$lt_AR_FLAGS
 
-fi
- if test "x$PYTHON_MODULE" = "xyes"; then
-  BUILDASLIBRARY_TRUE=
-  BUILDASLIBRARY_FALSE='#'
-else
-  BUILDASLIBRARY_TRUE='#'
-  BUILDASLIBRARY_FALSE=
-fi
+# A C compiler.
+LTCC=$lt_LTCC
 
+# LTCC compiler flags.
+LTCFLAGS=$lt_LTCFLAGS
 
+# A language-specific compiler.
+CC=$lt_compiler_GCJ
 
-for ac_func in malloc_zone_statistics sbrk mallinfo
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_cxx_check_func "$LINENO" "$ac_func" "$as_ac_var"
-eval as_val=\$$as_ac_var
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
+# Is the compiler the GNU C compiler?
+with_gcc=$GCC_GCJ
 
-fi
-done
+gcc_dir=\`gcc -print-file-name=. | $SED 's,/\.$,,'\`
+gcc_ver=\`gcc -dumpversion\`
 
+# An ERE matcher.
+EGREP=$lt_EGREP
 
-for ac_header in malloc.h malloc/malloc.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+# The linker used to build libraries.
+LD=$lt_LD_GCJ
 
-fi
+# Whether we need hard or soft links.
+LN_S=$lt_LN_S
 
-done
+# A BSD-compatible nm program.
+NM=$lt_NM
 
+# A symbol stripping program
+STRIP=$lt_STRIP
 
-for ac_header in locale.h
-do :
-  ac_fn_cxx_check_header_mongrel "$LINENO" "locale.h" "ac_cv_header_locale_h" "$ac_includes_default"
-if test "x$ac_cv_header_locale_h" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LOCALE_H 1
-_ACEOF
+# Used to examine libraries when file_magic_cmd begins "file"
+MAGIC_CMD=$MAGIC_CMD
 
-fi
+# Used on cygwin: DLL creation program.
+DLLTOOL="$DLLTOOL"
 
-done
+# Used on cygwin: object dumper.
+OBJDUMP="$OBJDUMP"
 
+# Used on cygwin: assembler.
+AS="$AS"
 
-for ac_func in nexttoward
-do :
-  ac_fn_cxx_check_func "$LINENO" "nexttoward" "ac_cv_func_nexttoward"
-if test "x$ac_cv_func_nexttoward" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_NEXTTOWARD 1
-_ACEOF
+# The name of the directory that contains temporary libtool files.
+objdir=$objdir
 
-fi
-done
+# How to create reloadable object files.
+reload_flag=$lt_reload_flag
+reload_cmds=$lt_reload_cmds
 
+# How to pass a linker flag through the compiler.
+wl=$lt_lt_prog_compiler_wl_GCJ
 
+# Object file suffix (normally "o").
+objext="$ac_objext"
 
+# Old archive suffix (normally "a").
+libext="$libext"
 
-# Check whether --with-ncursesdir was given.
-if test "${with_ncursesdir+set}" = set; then :
-  withval=$with_ncursesdir;  LIBS="$LIBS -L$withval/lib"
-         INCLUDES="$INCLUDES -I$withval/include"
+# Shared library suffix (normally ".so").
+shrext_cmds='$shrext_cmds'
 
-fi
+# Executable file suffix (normally "").
+exeext="$exeext"
 
+# Additional compiler flags for building library objects.
+pic_flag=$lt_lt_prog_compiler_pic_GCJ
+pic_mode=$pic_mode
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for initscr in -lncurses" >&5
-$as_echo_n "checking for initscr in -lncurses... " >&6; }
-if test "${ac_cv_lib_ncurses_initscr+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lncurses  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+# What is the maximum length of a command?
+max_cmd_len=$lt_cv_sys_max_cmd_len
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char initscr ();
-int
-main ()
-{
-return initscr ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_ncurses_initscr=yes
-else
-  ac_cv_lib_ncurses_initscr=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ncurses_initscr" >&5
-$as_echo "$ac_cv_lib_ncurses_initscr" >&6; }
-if test "x$ac_cv_lib_ncurses_initscr" = x""yes; then :
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o=$lt_lt_cv_prog_compiler_c_o_GCJ
 
-$as_echo "#define HAVE_LIBNCURSES 1" >>confdefs.h
+# Must we lock files when doing compilation?
+need_locks=$lt_need_locks
 
-  LIBS="-lncurses $LIBS"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for initscr in -lcurses" >&5
-$as_echo_n "checking for initscr in -lcurses... " >&6; }
-if test "${ac_cv_lib_curses_initscr+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lcurses  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+# Do we need the lib prefix for modules?
+need_lib_prefix=$need_lib_prefix
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char initscr ();
-int
-main ()
-{
-return initscr ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_curses_initscr=yes
-else
-  ac_cv_lib_curses_initscr=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_curses_initscr" >&5
-$as_echo "$ac_cv_lib_curses_initscr" >&6; }
-if test "x$ac_cv_lib_curses_initscr" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBCURSES 1
-_ACEOF
+# Do we need a version for libraries?
+need_version=$need_version
 
-  LIBS="-lcurses $LIBS"
+# Whether dlopen is supported.
+dlopen_support=$enable_dlopen
 
-fi
+# Whether dlopen of programs is supported.
+dlopen_self=$enable_dlopen_self
 
-fi
+# Whether dlopen of statically linked programs is supported.
+dlopen_self_static=$enable_dlopen_self_static
 
+# Compiler flag to prevent dynamic linking.
+link_static_flag=$lt_lt_prog_compiler_static_GCJ
 
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag_GCJ
 
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec=$lt_export_dynamic_flag_spec_GCJ
 
-# Check whether --with-readlinedir was given.
-if test "${with_readlinedir+set}" = set; then :
-  withval=$with_readlinedir;  with_readlinedir="$withval"
-fi
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec=$lt_whole_archive_flag_spec_GCJ
 
+# Compiler flag to generate thread-safe objects.
+thread_safe_flag_spec=$lt_thread_safe_flag_spec_GCJ
 
-if test "x$with_readlinedir" != "xno"; then
+# Library versioning type.
+version_type=$version_type
 
-  if test "x$with_readlinedir" != "xyes"; then
-    LIBS="-L$with_readlinedir/lib -L$with_readlinedir $LIBS -lreadline"
-    INCLUDES="$INCLUDES -I$with_readlinedir/include -I$with_readlinedir"
-  else
-    LIBS="$LIBS -lreadline"
-  fi
+# Format of library name prefix.
+libname_spec=$lt_libname_spec
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for stifle_history in -lreadline" >&5
-$as_echo_n "checking for stifle_history in -lreadline... " >&6; }
-if test "${ac_cv_lib_readline_stifle_history+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lreadline  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME.
+library_names_spec=$lt_library_names_spec
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char stifle_history ();
-int
-main ()
-{
-return stifle_history ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_readline_stifle_history=yes
-else
-  ac_cv_lib_readline_stifle_history=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_readline_stifle_history" >&5
-$as_echo "$ac_cv_lib_readline_stifle_history" >&6; }
-if test "x$ac_cv_lib_readline_stifle_history" = x""yes; then :
+# The coded name of the library, if different from the real name.
+soname_spec=$lt_soname_spec
 
-$as_echo "#define HAVE_LIBREADLINE 1" >>confdefs.h
+# Commands used to build and install an old-style archive.
+RANLIB=$lt_RANLIB
+old_archive_cmds=$lt_old_archive_cmds_GCJ
+old_postinstall_cmds=$lt_old_postinstall_cmds
+old_postuninstall_cmds=$lt_old_postuninstall_cmds
 
-else
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=$lt_old_archive_from_new_cmds_GCJ
 
-	echo ""
-	echo "Error! GNU readline was not found."
-	echo "       Use --with-readlinedir=no to expicitely disable it"
-	echo "       Check the README or use configure --help for other libraries needed"
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds_GCJ
 
-	exit -1
+# Commands used to build and install a shared archive.
+archive_cmds=$lt_archive_cmds_GCJ
+archive_expsym_cmds=$lt_archive_expsym_cmds_GCJ
+postinstall_cmds=$lt_postinstall_cmds
+postuninstall_cmds=$lt_postuninstall_cmds
 
-fi
+# Commands used to build a loadable module (assumed same as above if empty)
+module_cmds=$lt_module_cmds_GCJ
+module_expsym_cmds=$lt_module_expsym_cmds_GCJ
 
+# Commands to strip libraries.
+old_striplib=$lt_old_striplib
+striplib=$lt_striplib
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for rl_get_screen_size in -lreadline" >&5
-$as_echo_n "checking for rl_get_screen_size in -lreadline... " >&6; }
-if test "${ac_cv_lib_readline_rl_get_screen_size+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lreadline  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+# Dependencies to place before the objects being linked to create a
+# shared library.
+predep_objects=\`echo $lt_predep_objects_GCJ | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
+
+# Dependencies to place after the objects being linked to create a
+# shared library.
+postdep_objects=\`echo $lt_postdep_objects_GCJ | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
+
+# Dependencies to place before the objects being linked to create a
+# shared library.
+predeps=$lt_predeps_GCJ
+
+# Dependencies to place after the objects being linked to create a
+# shared library.
+postdeps=$lt_postdeps_GCJ
+
+# The library search path used internally by the compiler when linking
+# a shared library.
+compiler_lib_search_path=\`echo $lt_compiler_lib_search_path_GCJ | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
+
+# Method to check whether dependent libraries are shared objects.
+deplibs_check_method=$lt_deplibs_check_method
+
+# Command to use when deplibs_check_method == file_magic.
+file_magic_cmd=$lt_file_magic_cmd
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=$lt_allow_undefined_flag_GCJ
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char rl_get_screen_size ();
-int
-main ()
-{
-return rl_get_screen_size ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_readline_rl_get_screen_size=yes
-else
-  ac_cv_lib_readline_rl_get_screen_size=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_readline_rl_get_screen_size" >&5
-$as_echo "$ac_cv_lib_readline_rl_get_screen_size" >&6; }
-if test "x$ac_cv_lib_readline_rl_get_screen_size" = x""yes; then :
+# Flag that forces no undefined symbols.
+no_undefined_flag=$lt_no_undefined_flag_GCJ
 
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds=$lt_finish_cmds
 
-$as_echo "#define RL_GET_SCREEN_SIZE 1" >>confdefs.h
+# Same as above, but a single script fragment to be evaled but not shown.
+finish_eval=$lt_finish_eval
 
-else
+# Take the output of nm and produce a listing of raw symbols and C names.
+global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe
 
-	echo ""
-	echo "Warning! Older GNU readline without 'rl_get_screen_size' was found."
-	echo "         For resized terminals the size might not be updated correctly"
-	echo "         If this is a problem please install a recent version of readline"
+# Transform the output of nm in a proper C declaration
+global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl
 
-fi
+# Transform the output of nm in a C name address pair
+global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address
 
+# This is the shared library runtime path variable.
+runpath_var=$runpath_var
 
-fi
+# This is the shared library path variable.
+shlibpath_var=$shlibpath_var
 
+# Is shlibpath searched before the hard-coded library search path?
+shlibpath_overrides_runpath=$shlibpath_overrides_runpath
 
+# How to hardcode a shared library path into an executable.
+hardcode_action=$hardcode_action_GCJ
 
-# Check whether --with-zlibdir was given.
-if test "${with_zlibdir+set}" = set; then :
-  withval=$with_zlibdir; with_zlib="$withval"
-fi
+# Whether we should hardcode library paths into libraries.
+hardcode_into_libs=$hardcode_into_libs
 
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec_GCJ
 
-if test "x$with_zlib" = "x"; then
-  with_zlib=yes
-fi
+# If ld is used when linking, flag to hardcode \$libdir into
+# a binary during linking. This must work even if \$libdir does
+# not exist.
+hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld_GCJ
+
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator=$lt_hardcode_libdir_separator_GCJ
+
+# Set to yes if using DIR/libNAME${shared_ext} during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct=$hardcode_direct_GCJ
+
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L=$hardcode_minus_L_GCJ
+
+# Set to yes if using SHLIBPATH_VAR=DIR during linking hardcodes DIR into
+# the resulting binary.
+hardcode_shlibpath_var=$hardcode_shlibpath_var_GCJ
+
+# Set to yes if building a shared library automatically hardcodes DIR into the library
+# and all subsequent libraries and executables linked against it.
+hardcode_automatic=$hardcode_automatic_GCJ
 
-if test "x$with_zlib" = "xno"; then
-	echo ""
-	echo "Error! ZLIB library is obligatory."
-        exit -1
-fi
+# Variables whose values should be saved in libtool wrapper scripts and
+# restored at relink time.
+variables_saved_for_relink="$variables_saved_for_relink"
 
-if test "x$with_zlib" != "xyes"; then
-    LIBS="$LIBS -L$with_zlib/lib -lz"
-    INCLUDES="$INCLUDES -I$with_zlib/include"
-else
-    LIBS="$LIBS -lz"
-fi
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=$link_all_deplibs_GCJ
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for gzopen in -lz" >&5
-$as_echo_n "checking for gzopen in -lz... " >&6; }
-if test "${ac_cv_lib_z_gzopen+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lz  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+# Compile-time system search path for libraries
+sys_lib_search_path_spec=\`echo $lt_sys_lib_search_path_spec | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char gzopen ();
-int
-main ()
-{
-return gzopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_z_gzopen=yes
-else
-  ac_cv_lib_z_gzopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_z_gzopen" >&5
-$as_echo "$ac_cv_lib_z_gzopen" >&6; }
-if test "x$ac_cv_lib_z_gzopen" = x""yes; then :
+# Run-time system search path for libraries
+sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
 
-$as_echo "#define HAVE_LIBZ 1" >>confdefs.h
+# Fix the shell variable \$srcfile for the compiler.
+fix_srcfile_path="$fix_srcfile_path_GCJ"
 
-else
+# Set to yes if exported symbols are required.
+always_export_symbols=$always_export_symbols_GCJ
 
- 	echo ""
- 	echo "Error! zlib library is required but was not found"
- 	echo "       Use --with-zlibdir=DIR to specify the zlib directory tree"
- 	exit -1
+# The commands to list exported symbols.
+export_symbols_cmds=$lt_export_symbols_cmds_GCJ
 
-fi
+# The commands to extract the exported symbol list from a shared archive.
+extract_expsyms_cmds=$lt_extract_expsyms_cmds
+
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms=$lt_exclude_expsyms_GCJ
 
+# Symbols that must always be exported.
+include_expsyms=$lt_include_expsyms_GCJ
 
+# ### END LIBTOOL TAG CONFIG: $tagname
 
+__EOF__
 
 
-# Check whether --with-openmp was given.
-if test "${with_openmp+set}" = set; then :
-  withval=$with_openmp; with_openmp="$withval"
+else
+  # If there is no Makefile yet, we rely on a make rule to execute
+  # `config.status --recheck' to rerun these tests and create the
+  # libtool script then.
+  ltmain_in=`echo $ltmain | sed -e 's/\.sh$/.in/'`
+  if test -f "$ltmain_in"; then
+    test -f Makefile && make "$ltmain"
+  fi
 fi
 
 
-if test "x$with_openmp" = "x"; then
-   for ac_header in "omp.h"
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-eval as_val=\$$as_ac_Header
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
 
-     with_openmp=yes
-     echo ""
-     echo "OpenMP enabled (omp.h file was found)."
-     echo "Try --with-openmp=no if your compiler does not support it (e.g. GCC < 4.2)"
-     echo "The warnings about unsigned iteration variable can be ignored."
-     echo "See the README for details."
-     echo ""
+CC="$lt_save_CC"
 
-else
+	else
+	  tagname=""
+	fi
+	;;
 
-     with_openmp=no
-     echo ""
-     echo "OpenMP disabled (omp.h file was not found)."
-     echo "Try --with-openmp=yes if your compiler does support it (e.g. GCC >= 4.2)"
-     echo ""
+      RC)
 
-fi
 
-done
+# Source file extension for RC test sources.
+ac_ext=rc
 
-fi
+# Object file extension for compiled RC test sources.
+objext=o
+objext_RC=$objext
 
-if test "x$with_openmp" != "xno"; then
-	CPPFLAGS="$CPPFLAGS -fopenmp"
-	LDFLAGS="$LDFLAGS -fopenmp"
-fi
+# Code to be used in simple compile tests
+lt_simple_compile_test_code='sample MENU { MENUITEM "&Soup", 100, CHECKED }\n'
 
+# Code to be used in simple link tests
+lt_simple_link_test_code="$lt_simple_compile_test_code"
 
+# ltmain only uses $CC for tagged configurations so make sure $CC is set.
 
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
 
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
 
+# Allow CC to be a program name with arguments.
+compiler=$CC
 
-# Check whether --with-gsldir was given.
-if test "${with_gsldir+set}" = set; then :
-  withval=$with_gsldir; with_gsl="$withval"
-fi
 
+# save warnings/boilerplate of simple test code
+ac_outfile=conftest.$ac_objext
+printf "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$rm conftest*
 
-if test "x$with_gsl" = "x"; then
-  with_gsl=yes
-fi
+ac_outfile=conftest.$ac_objext
+printf "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$rm conftest*
 
-if test "x$with_gsl" = "xno"; then
-	echo ""
-	echo "Error! Gnu Scientific Library (1.7 or higher) is mandatory"
-        exit -1
-fi
 
-if test "x$with_gsl" != "xyes"; then
-    LIBS="$LIBS -L$with_gsl/lib -lgsl -lgslcblas"
-    INCLUDES="$INCLUDES -I$with_gsl/include"
-else
-    LIBS="$LIBS -lgsl -lgslcblas"
-fi
+# Allow CC to be a program name with arguments.
+lt_save_CC="$CC"
+CC=${RC-"windres"}
+compiler=$CC
+compiler_RC=$CC
+for cc_temp in $compiler""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$echo "X$cc_temp" | $Xsed -e 's%.*/%%' -e "s%^$host_alias-%%"`
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for gsl_ran_binomial_knuth in -lgsl" >&5
-$as_echo_n "checking for gsl_ran_binomial_knuth in -lgsl... " >&6; }
-if test "${ac_cv_lib_gsl_gsl_ran_binomial_knuth+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lgsl  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+lt_cv_prog_compiler_c_o_RC=yes
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char gsl_ran_binomial_knuth ();
-int
-main ()
-{
-return gsl_ran_binomial_knuth ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_gsl_gsl_ran_binomial_knuth=yes
-else
-  ac_cv_lib_gsl_gsl_ran_binomial_knuth=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gsl_gsl_ran_binomial_knuth" >&5
-$as_echo "$ac_cv_lib_gsl_gsl_ran_binomial_knuth" >&6; }
-if test "x$ac_cv_lib_gsl_gsl_ran_binomial_knuth" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBGSL 1
-_ACEOF
+# The else clause should only fire when bootstrapping the
+# libtool distribution, otherwise you forgot to ship ltmain.sh
+# with your package, and you will get complaints that there are
+# no rules to generate ltmain.sh.
+if test -f "$ltmain"; then
+  # See if we are running on zsh, and set the options which allow our commands through
+  # without removal of \ escapes.
+  if test -n "${ZSH_VERSION+set}" ; then
+    setopt NO_GLOB_SUBST
+  fi
+  # Now quote all the things that may contain metacharacters while being
+  # careful not to overquote the AC_SUBSTed values.  We take copies of the
+  # variables and quote the copies for generation of the libtool script.
+  for var in echo old_CC old_CFLAGS AR AR_FLAGS EGREP RANLIB LN_S LTCC LTCFLAGS NM \
+    SED SHELL STRIP \
+    libname_spec library_names_spec soname_spec extract_expsyms_cmds \
+    old_striplib striplib file_magic_cmd finish_cmds finish_eval \
+    deplibs_check_method reload_flag reload_cmds need_locks \
+    lt_cv_sys_global_symbol_pipe lt_cv_sys_global_symbol_to_cdecl \
+    lt_cv_sys_global_symbol_to_c_name_address \
+    sys_lib_search_path_spec sys_lib_dlsearch_path_spec \
+    old_postinstall_cmds old_postuninstall_cmds \
+    compiler_RC \
+    CC_RC \
+    LD_RC \
+    lt_prog_compiler_wl_RC \
+    lt_prog_compiler_pic_RC \
+    lt_prog_compiler_static_RC \
+    lt_prog_compiler_no_builtin_flag_RC \
+    export_dynamic_flag_spec_RC \
+    thread_safe_flag_spec_RC \
+    whole_archive_flag_spec_RC \
+    enable_shared_with_static_runtimes_RC \
+    old_archive_cmds_RC \
+    old_archive_from_new_cmds_RC \
+    predep_objects_RC \
+    postdep_objects_RC \
+    predeps_RC \
+    postdeps_RC \
+    compiler_lib_search_path_RC \
+    archive_cmds_RC \
+    archive_expsym_cmds_RC \
+    postinstall_cmds_RC \
+    postuninstall_cmds_RC \
+    old_archive_from_expsyms_cmds_RC \
+    allow_undefined_flag_RC \
+    no_undefined_flag_RC \
+    export_symbols_cmds_RC \
+    hardcode_libdir_flag_spec_RC \
+    hardcode_libdir_flag_spec_ld_RC \
+    hardcode_libdir_separator_RC \
+    hardcode_automatic_RC \
+    module_cmds_RC \
+    module_expsym_cmds_RC \
+    lt_cv_prog_compiler_c_o_RC \
+    exclude_expsyms_RC \
+    include_expsyms_RC; do
+
+    case $var in
+    old_archive_cmds_RC | \
+    old_archive_from_new_cmds_RC | \
+    archive_cmds_RC | \
+    archive_expsym_cmds_RC | \
+    module_cmds_RC | \
+    module_expsym_cmds_RC | \
+    old_archive_from_expsyms_cmds_RC | \
+    export_symbols_cmds_RC | \
+    extract_expsyms_cmds | reload_cmds | finish_cmds | \
+    postinstall_cmds | postuninstall_cmds | \
+    old_postinstall_cmds | old_postuninstall_cmds | \
+    sys_lib_search_path_spec | sys_lib_dlsearch_path_spec)
+      # Double-quote double-evaled strings.
+      eval "lt_$var=\\\"\`\$echo \"X\$$var\" | \$Xsed -e \"\$double_quote_subst\" -e \"\$sed_quote_subst\" -e \"\$delay_variable_subst\"\`\\\""
+      ;;
+    *)
+      eval "lt_$var=\\\"\`\$echo \"X\$$var\" | \$Xsed -e \"\$sed_quote_subst\"\`\\\""
+      ;;
+    esac
+  done
+
+  case $lt_echo in
+  *'\$0 --fallback-echo"')
+    lt_echo=`$echo "X$lt_echo" | $Xsed -e 's/\\\\\\\$0 --fallback-echo"$/$0 --fallback-echo"/'`
+    ;;
+  esac
 
-  LIBS="-lgsl $LIBS"
+cfgfile="$ofile"
 
-else
+  cat <<__EOF__ >> "$cfgfile"
+# ### BEGIN LIBTOOL TAG CONFIG: $tagname
 
-	echo ""
-	echo "Error! Gnu Scientific Library (1.7 or higher) is mandatory"
-        exit -1
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
 
-fi
+# Shell to use when invoking shell scripts.
+SHELL=$lt_SHELL
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for cblas_drot in -lgslcblas" >&5
-$as_echo_n "checking for cblas_drot in -lgslcblas... " >&6; }
-if test "${ac_cv_lib_gslcblas_cblas_drot+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lgslcblas  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+# Whether or not to build shared libraries.
+build_libtool_libs=$enable_shared
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char cblas_drot ();
-int
-main ()
-{
-return cblas_drot ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_gslcblas_cblas_drot=yes
-else
-  ac_cv_lib_gslcblas_cblas_drot=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gslcblas_cblas_drot" >&5
-$as_echo "$ac_cv_lib_gslcblas_cblas_drot" >&6; }
-if test "x$ac_cv_lib_gslcblas_cblas_drot" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBGSLCBLAS 1
-_ACEOF
+# Whether or not to build static libraries.
+build_old_libs=$enable_static
 
-  LIBS="-lgslcblas $LIBS"
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=$archive_cmds_need_lc_RC
 
-else
+# Whether or not to disallow shared libs when runtime libs are static
+allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes_RC
 
-	echo ""
-	echo "Error! libgslcblas (part of GSL) is mandatory"
-        exit -1
+# Whether or not to optimize for fast installation.
+fast_install=$enable_fast_install
 
-fi
+# The host system.
+host_alias=$host_alias
+host=$host
+host_os=$host_os
 
+# The build system.
+build_alias=$build_alias
+build=$build
+build_os=$build_os
 
+# An echo program that does not interpret backslashes.
+echo=$lt_echo
 
+# The archiver.
+AR=$lt_AR
+AR_FLAGS=$lt_AR_FLAGS
 
-# Check whether --with-plplotdir was given.
-if test "${with_plplotdir+set}" = set; then :
-  withval=$with_plplotdir; with_plplot="$withval"
-fi
+# A C compiler.
+LTCC=$lt_LTCC
 
+# LTCC compiler flags.
+LTCFLAGS=$lt_LTCFLAGS
 
-if test "x$with_plplot" = "x"; then
-  with_plplot=yes
-fi
+# A language-specific compiler.
+CC=$lt_compiler_RC
 
-if test "x$with_plplot" = "xno"; then
-	echo ""
-	echo "Error! PLPLOT library is mandatory."
-        exit -1
-fi
+# Is the compiler the GNU C compiler?
+with_gcc=$GCC_RC
 
-OLDPLPLOT="no"
-# Check whether --enable-oldplplot was given.
-if test "${enable_oldplplot+set}" = set; then :
-  enableval=$enable_oldplplot;  OLDPLPLOT="$enableval"
+gcc_dir=\`gcc -print-file-name=. | $SED 's,/\.$,,'\`
+gcc_ver=\`gcc -dumpversion\`
 
-fi
+# An ERE matcher.
+EGREP=$lt_EGREP
 
+# The linker used to build libraries.
+LD=$lt_LD_RC
 
-if test "x$OLDPLPLOT" = "xyes"; then
+# Whether we need hard or soft links.
+LN_S=$lt_LN_S
 
-$as_echo "#define HAVE_OLDPLPLOT 1" >>confdefs.h
+# A BSD-compatible nm program.
+NM=$lt_NM
 
-fi
+# A symbol stripping program
+STRIP=$lt_STRIP
 
-if test "x$with_plplot" != "xyes"; then
-    LIBS="$LIBS -L$with_plplot/lib -lplplotd -lplplotcxxd"
-    INCLUDES="$INCLUDES -I$with_plplot/include"
-else
-    LIBS="$LIBS -lplplotd -lplplotcxxd"
-fi
+# Used to examine libraries when file_magic_cmd begins "file"
+MAGIC_CMD=$MAGIC_CMD
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for plsexit in -lplplotcxxd" >&5
-$as_echo_n "checking for plsexit in -lplplotcxxd... " >&6; }
-if test "${ac_cv_lib_plplotcxxd_plsexit+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lplplotcxxd  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+# Used on cygwin: DLL creation program.
+DLLTOOL="$DLLTOOL"
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char plsexit ();
-int
-main ()
-{
-return plsexit ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_plplotcxxd_plsexit=yes
-else
-  ac_cv_lib_plplotcxxd_plsexit=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_plplotcxxd_plsexit" >&5
-$as_echo "$ac_cv_lib_plplotcxxd_plsexit" >&6; }
-if test "x$ac_cv_lib_plplotcxxd_plsexit" = x""yes; then :
+# Used on cygwin: object dumper.
+OBJDUMP="$OBJDUMP"
 
-$as_echo "#define HAVE_LIBPLPLOTCXXD 1" >>confdefs.h
+# Used on cygwin: assembler.
+AS="$AS"
 
-else
+# The name of the directory that contains temporary libtool files.
+objdir=$objdir
 
-	echo ""
-	echo "Error! plplot library is required but was not found"
-	echo "       Use --with-plplot=DIR to specify the plplot directory tree"
-	exit -1
+# How to create reloadable object files.
+reload_flag=$lt_reload_flag
+reload_cmds=$lt_reload_cmds
 
-fi
+# How to pass a linker flag through the compiler.
+wl=$lt_lt_prog_compiler_wl_RC
 
+# Object file suffix (normally "o").
+objext="$ac_objext"
 
+# Old archive suffix (normally "a").
+libext="$libext"
 
+# Shared library suffix (normally ".so").
+shrext_cmds='$shrext_cmds'
 
-# Check whether --with-wxWidgets was given.
-if test "${with_wxWidgets+set}" = set; then :
-  withval=$with_wxWidgets; with_wxWidgets="$withval"
-fi
+# Executable file suffix (normally "").
+exeext="$exeext"
 
+# Additional compiler flags for building library objects.
+pic_flag=$lt_lt_prog_compiler_pic_RC
+pic_mode=$pic_mode
 
-if test "x$with_wxWidgets" != "xno"; then
+# What is the maximum length of a command?
+max_cmd_len=$lt_cv_sys_max_cmd_len
 
-  if test "x$with_wxWidgets" = "xyes"; then
-    # Extract the first word of "wx-config", so it can be a program name with args.
-set dummy wx-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_wxConfig+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $wxConfig in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_wxConfig="$wxConfig" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_wxConfig="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o=$lt_lt_cv_prog_compiler_c_o_RC
 
-  test -z "$ac_cv_path_wxConfig" && ac_cv_path_wxConfig="no"
-  ;;
-esac
-fi
-wxConfig=$ac_cv_path_wxConfig
-if test -n "$wxConfig"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $wxConfig" >&5
-$as_echo "$wxConfig" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
+# Must we lock files when doing compilation?
+need_locks=$lt_need_locks
 
+# Do we need the lib prefix for modules?
+need_lib_prefix=$need_lib_prefix
 
-  else
-    # Extract the first word of "wx-config", so it can be a program name with args.
-set dummy wx-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_wxConfig+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $wxConfig in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_wxConfig="$wxConfig" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in "$with_wxWidgets/bin"
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_wxConfig="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
+# Do we need a version for libraries?
+need_version=$need_version
 
-  test -z "$ac_cv_path_wxConfig" && ac_cv_path_wxConfig="no"
-  ;;
-esac
-fi
-wxConfig=$ac_cv_path_wxConfig
-if test -n "$wxConfig"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $wxConfig" >&5
-$as_echo "$wxConfig" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
+# Whether dlopen is supported.
+dlopen_support=$enable_dlopen
 
+# Whether dlopen of programs is supported.
+dlopen_self=$enable_dlopen_self
 
-  fi
+# Whether dlopen of statically linked programs is supported.
+dlopen_self_static=$enable_dlopen_self_static
 
-  if test "x$wxConfig" = "xno"; then
-    as_fn_error "wxWidgets are required but were not found (wx-config program not found)
-      Use --with-wxWidgets=DIR to specify the wxWidgets directory tree
-      Use --with-wxWidgets=no  to not use it
-    " "$LINENO" 5
-  else
-    LIBS="$LIBS `wx-config --libs`"
-    INCLUDES="$INCLUDES `wx-config --cxxflags`"
-              fi
+# Compiler flag to prevent dynamic linking.
+link_static_flag=$lt_lt_prog_compiler_static_RC
 
-  tmp="`wx-config --basename`-`wx-config --release`"
-  as_ac_Lib=`$as_echo "ac_cv_lib_$tmp''_wxFatalSignalHandler" | $as_tr_sh`
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for wxFatalSignalHandler in -l$tmp" >&5
-$as_echo_n "checking for wxFatalSignalHandler in -l$tmp... " >&6; }
-if { as_var=$as_ac_Lib; eval "test \"\${$as_var+set}\" = set"; }; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-l$tmp  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag_RC
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char wxFatalSignalHandler ();
-int
-main ()
-{
-return wxFatalSignalHandler ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  eval "$as_ac_Lib=yes"
-else
-  eval "$as_ac_Lib=no"
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-eval ac_res=\$$as_ac_Lib
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-eval as_val=\$$as_ac_Lib
-   if test "x$as_val" = x""yes; then :
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec=$lt_export_dynamic_flag_spec_RC
 
-$as_echo "#define HAVE_LIBWXWIDGETS 1" >>confdefs.h
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec=$lt_whole_archive_flag_spec_RC
 
-else
+# Compiler flag to generate thread-safe objects.
+thread_safe_flag_spec=$lt_thread_safe_flag_spec_RC
 
-            tmp="`wx-config --basename --toolkit=base`-`wx-config --release`"
-      as_ac_Lib=`$as_echo "ac_cv_lib_$tmp''_wxInteger_compare" | $as_tr_sh`
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for wxInteger_compare in -l$tmp" >&5
-$as_echo_n "checking for wxInteger_compare in -l$tmp... " >&6; }
-if { as_var=$as_ac_Lib; eval "test \"\${$as_var+set}\" = set"; }; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-l$tmp  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+# Library versioning type.
+version_type=$version_type
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char wxInteger_compare ();
-int
-main ()
-{
-return wxInteger_compare ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  eval "$as_ac_Lib=yes"
-else
-  eval "$as_ac_Lib=no"
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-eval ac_res=\$$as_ac_Lib
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-eval as_val=\$$as_ac_Lib
-   if test "x$as_val" = x""yes; then :
-  $as_echo "#define HAVE_LIBWXWIDGETS 1" >>confdefs.h
+# Format of library name prefix.
+libname_spec=$lt_libname_spec
 
-else
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME.
+library_names_spec=$lt_library_names_spec
 
-        echo ""
-        echo "Error! wxWidgets version 2.8 or later is required but was not found"
-        echo "       Use --with-wxWidgets=DIR to specify the wxWidgets directory tree"
-        echo "       Use --with-wxWidgets=no  to not use it"
-        echo "       Check the README or use configure --help for other libraries needed"
-        echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-        exit -1
+# The coded name of the library, if different from the real name.
+soname_spec=$lt_soname_spec
 
-fi
+# Commands used to build and install an old-style archive.
+RANLIB=$lt_RANLIB
+old_archive_cmds=$lt_old_archive_cmds_RC
+old_postinstall_cmds=$lt_old_postinstall_cmds
+old_postuninstall_cmds=$lt_old_postuninstall_cmds
 
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=$lt_old_archive_from_new_cmds_RC
 
-fi
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds_RC
 
-fi
+# Commands used to build and install a shared archive.
+archive_cmds=$lt_archive_cmds_RC
+archive_expsym_cmds=$lt_archive_expsym_cmds_RC
+postinstall_cmds=$lt_postinstall_cmds
+postuninstall_cmds=$lt_postuninstall_cmds
 
+# Commands used to build a loadable module (assumed same as above if empty)
+module_cmds=$lt_module_cmds_RC
+module_expsym_cmds=$lt_module_expsym_cmds_RC
 
+# Commands to strip libraries.
+old_striplib=$lt_old_striplib
+striplib=$lt_striplib
 
-# Check whether --with-Magick was given.
-if test "${with_Magick+set}" = set; then :
-  withval=$with_Magick; with_Magick="$withval"
-fi
+# Dependencies to place before the objects being linked to create a
+# shared library.
+predep_objects=\`echo $lt_predep_objects_RC | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
+
+# Dependencies to place after the objects being linked to create a
+# shared library.
+postdep_objects=\`echo $lt_postdep_objects_RC | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
+
+# Dependencies to place before the objects being linked to create a
+# shared library.
+predeps=$lt_predeps_RC
+
+# Dependencies to place after the objects being linked to create a
+# shared library.
+postdeps=$lt_postdeps_RC
 
+# The library search path used internally by the compiler when linking
+# a shared library.
+compiler_lib_search_path=\`echo $lt_compiler_lib_search_path_RC | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
 
-if test "x$with_Magick" != "xno"; then
-  if test "x$with_Magick" = "xyes"; then
-    # Extract the first word of "Magick++-config", so it can be a program name with args.
-set dummy Magick++-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_MagickConfig+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $MagickConfig in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_MagickConfig="$MagickConfig" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_MagickConfig="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
+# Method to check whether dependent libraries are shared objects.
+deplibs_check_method=$lt_deplibs_check_method
 
-  test -z "$ac_cv_path_MagickConfig" && ac_cv_path_MagickConfig="no"
-  ;;
-esac
-fi
-MagickConfig=$ac_cv_path_MagickConfig
-if test -n "$MagickConfig"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MagickConfig" >&5
-$as_echo "$MagickConfig" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
+# Command to use when deplibs_check_method == file_magic.
+file_magic_cmd=$lt_file_magic_cmd
 
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=$lt_allow_undefined_flag_RC
 
-  else
-    # Extract the first word of "Magick++-config", so it can be a program name with args.
-set dummy Magick++-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_MagickConfig+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $MagickConfig in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_MagickConfig="$MagickConfig" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in "$with_Magick/bin"
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_MagickConfig="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
+# Flag that forces no undefined symbols.
+no_undefined_flag=$lt_no_undefined_flag_RC
 
-  test -z "$ac_cv_path_MagickConfig" && ac_cv_path_MagickConfig="no"
-  ;;
-esac
-fi
-MagickConfig=$ac_cv_path_MagickConfig
-if test -n "$MagickConfig"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MagickConfig" >&5
-$as_echo "$MagickConfig" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds=$lt_finish_cmds
 
+# Same as above, but a single script fragment to be evaled but not shown.
+finish_eval=$lt_finish_eval
 
-  fi
+# Take the output of nm and produce a listing of raw symbols and C names.
+global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe
 
-  if test "x$MagickConfig" = "xno"; then
-    as_fn_error "ImageMagick is required but was not found (Magick++-config program not found)
-      Use --with-Magick=DIR to specify the ImageMagick directory tree
-      Use --with-Magick=no  to not use it
-    " "$LINENO" 5
-  else
-    LIBS="$LIBS `$MagickConfig --libs`"
-    INCLUDES="$INCLUDES `$MagickConfig --cppflags`"
-    LDFLAGS="$LDFLAGS `$MagickConfig --ldflags`"
-  fi
+# Transform the output of nm in a proper C declaration
+global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GetMagickVersion in -lMagick++" >&5
-$as_echo_n "checking for GetMagickVersion in -lMagick++... " >&6; }
-if test "${ac_cv_lib_Magickpp_GetMagickVersion+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lMagick++  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
+# Transform the output of nm in a C name address pair
+global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char GetMagickVersion ();
-int
-main ()
-{
-return GetMagickVersion ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_Magickpp_GetMagickVersion=yes
-else
-  ac_cv_lib_Magickpp_GetMagickVersion=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Magickpp_GetMagickVersion" >&5
-$as_echo "$ac_cv_lib_Magickpp_GetMagickVersion" >&6; }
-if test "x$ac_cv_lib_Magickpp_GetMagickVersion" = x""yes; then :
+# This is the shared library runtime path variable.
+runpath_var=$runpath_var
+
+# This is the shared library path variable.
+shlibpath_var=$shlibpath_var
 
-$as_echo "#define USE_MAGICK 1" >>confdefs.h
+# Is shlibpath searched before the hard-coded library search path?
+shlibpath_overrides_runpath=$shlibpath_overrides_runpath
 
-else
+# How to hardcode a shared library path into an executable.
+hardcode_action=$hardcode_action_RC
 
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking if adding X library path helps" >&5
-$as_echo_n "checking if adding X library path helps... " >&6; }
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: ?" >&5
-$as_echo "?" >&6; }
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for X" >&5
-$as_echo_n "checking for X... " >&6; }
+# Whether we should hardcode library paths into libraries.
+hardcode_into_libs=$hardcode_into_libs
 
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec_RC
 
-# Check whether --with-x was given.
-if test "${with_x+set}" = set; then :
-  withval=$with_x;
-fi
+# If ld is used when linking, flag to hardcode \$libdir into
+# a binary during linking. This must work even if \$libdir does
+# not exist.
+hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld_RC
+
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator=$lt_hardcode_libdir_separator_RC
+
+# Set to yes if using DIR/libNAME${shared_ext} during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct=$hardcode_direct_RC
+
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L=$hardcode_minus_L_RC
+
+# Set to yes if using SHLIBPATH_VAR=DIR during linking hardcodes DIR into
+# the resulting binary.
+hardcode_shlibpath_var=$hardcode_shlibpath_var_RC
+
+# Set to yes if building a shared library automatically hardcodes DIR into the library
+# and all subsequent libraries and executables linked against it.
+hardcode_automatic=$hardcode_automatic_RC
 
-# $have_x is `yes', `no', `disabled', or empty when we do not yet know.
-if test "x$with_x" = xno; then
-  # The user explicitly disabled X.
-  have_x=disabled
-else
-  case $x_includes,$x_libraries in #(
-    *\'*) as_fn_error "cannot use X directory names containing '" "$LINENO" 5;; #(
-    *,NONE | NONE,*) if test "${ac_cv_have_x+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  # One or both of the vars are not set, and there is no cached value.
-ac_x_includes=no ac_x_libraries=no
-rm -f -r conftest.dir
-if mkdir conftest.dir; then
-  cd conftest.dir
-  cat >Imakefile <<'_ACEOF'
-incroot:
-	@echo incroot='${INCROOT}'
-usrlibdir:
-	@echo usrlibdir='${USRLIBDIR}'
-libdir:
-	@echo libdir='${LIBDIR}'
-_ACEOF
-  if (export CC; ${XMKMF-xmkmf}) >/dev/null 2>/dev/null && test -f Makefile; then
-    # GNU make sometimes prints "make[1]: Entering...", which would confuse us.
-    for ac_var in incroot usrlibdir libdir; do
-      eval "ac_im_$ac_var=\`\${MAKE-make} $ac_var 2>/dev/null | sed -n 's/^$ac_var=//p'\`"
-    done
-    # Open Windows xmkmf reportedly sets LIBDIR instead of USRLIBDIR.
-    for ac_extension in a so sl dylib la dll; do
-      if test ! -f "$ac_im_usrlibdir/libX11.$ac_extension" &&
-	 test -f "$ac_im_libdir/libX11.$ac_extension"; then
-	ac_im_usrlibdir=$ac_im_libdir; break
-      fi
-    done
-    # Screen out bogus values from the imake configuration.  They are
-    # bogus both because they are the default anyway, and because
-    # using them would break gcc on systems where it needs fixed includes.
-    case $ac_im_incroot in
-	/usr/include) ac_x_includes= ;;
-	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes=$ac_im_incroot;;
-    esac
-    case $ac_im_usrlibdir in
-	/usr/lib | /usr/lib64 | /lib | /lib64) ;;
-	*) test -d "$ac_im_usrlibdir" && ac_x_libraries=$ac_im_usrlibdir ;;
-    esac
-  fi
-  cd ..
-  rm -f -r conftest.dir
-fi
+# Variables whose values should be saved in libtool wrapper scripts and
+# restored at relink time.
+variables_saved_for_relink="$variables_saved_for_relink"
 
-# Standard set of common directories for X headers.
-# Check X11 before X11Rn because it is often a symlink to the current release.
-ac_x_header_dirs='
-/usr/X11/include
-/usr/X11R7/include
-/usr/X11R6/include
-/usr/X11R5/include
-/usr/X11R4/include
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=$link_all_deplibs_RC
 
-/usr/include/X11
-/usr/include/X11R7
-/usr/include/X11R6
-/usr/include/X11R5
-/usr/include/X11R4
+# Compile-time system search path for libraries
+sys_lib_search_path_spec=\`echo $lt_sys_lib_search_path_spec | \$SED -e "s@\${gcc_dir}@\\\${gcc_dir}@g;s@\${gcc_ver}@\\\${gcc_ver}@g"\`
 
-/usr/local/X11/include
-/usr/local/X11R7/include
-/usr/local/X11R6/include
-/usr/local/X11R5/include
-/usr/local/X11R4/include
+# Run-time system search path for libraries
+sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
 
-/usr/local/include/X11
-/usr/local/include/X11R7
-/usr/local/include/X11R6
-/usr/local/include/X11R5
-/usr/local/include/X11R4
+# Fix the shell variable \$srcfile for the compiler.
+fix_srcfile_path="$fix_srcfile_path_RC"
 
-/usr/X386/include
-/usr/x386/include
-/usr/XFree86/include/X11
+# Set to yes if exported symbols are required.
+always_export_symbols=$always_export_symbols_RC
 
-/usr/include
-/usr/local/include
-/usr/unsupported/include
-/usr/athena/include
-/usr/local/x11r5/include
-/usr/lpp/Xamples/include
+# The commands to list exported symbols.
+export_symbols_cmds=$lt_export_symbols_cmds_RC
+
+# The commands to extract the exported symbol list from a shared archive.
+extract_expsyms_cmds=$lt_extract_expsyms_cmds
+
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms=$lt_exclude_expsyms_RC
+
+# Symbols that must always be exported.
+include_expsyms=$lt_include_expsyms_RC
+
+# ### END LIBTOOL TAG CONFIG: $tagname
+
+__EOF__
 
-/usr/openwin/include
-/usr/openwin/share/include'
 
-if test "$ac_x_includes" = no; then
-  # Guess where to find include files, by looking for Xlib.h.
-  # First, try using that file with no special directory specified.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <X11/Xlib.h>
-_ACEOF
-if ac_fn_cxx_try_cpp "$LINENO"; then :
-  # We can compile using X headers with no special include directory.
-ac_x_includes=
 else
-  for ac_dir in $ac_x_header_dirs; do
-  if test -r "$ac_dir/X11/Xlib.h"; then
-    ac_x_includes=$ac_dir
-    break
+  # If there is no Makefile yet, we rely on a make rule to execute
+  # `config.status --recheck' to rerun these tests and create the
+  # libtool script then.
+  ltmain_in=`echo $ltmain | sed -e 's/\.sh$/.in/'`
+  if test -f "$ltmain_in"; then
+    test -f Makefile && make "$ltmain"
   fi
-done
 fi
-rm -f conftest.err conftest.$ac_ext
-fi # $ac_x_includes = no
 
-if test "$ac_x_libraries" = no; then
-  # Check for the libraries.
-  # See if we find them without any special options.
-  # Don't add to $LIBS permanently.
-  ac_save_LIBS=$LIBS
-  LIBS="-lX11 $LIBS"
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <X11/Xlib.h>
-int
-main ()
-{
-XrmInitialize ()
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  LIBS=$ac_save_LIBS
-# We can link X programs with no special library path.
-ac_x_libraries=
-else
-  LIBS=$ac_save_LIBS
-for ac_dir in `$as_echo "$ac_x_includes $ac_x_header_dirs" | sed s/include/lib/g`
-do
-  # Don't even attempt the hair of trying to link an X program!
-  for ac_extension in a so sl dylib la dll; do
-    if test -r "$ac_dir/libX11.$ac_extension"; then
-      ac_x_libraries=$ac_dir
-      break 2
+
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+CC="$lt_save_CC"
+
+	;;
+
+      *)
+	as_fn_error "Unsupported tag name: $tagname" "$LINENO" 5
+	;;
+      esac
+
+      # Append the new tag name to the list of available tags.
+      if test -n "$tagname" ; then
+      available_tags="$available_tags $tagname"
+    fi
     fi
   done
-done
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-fi # $ac_x_libraries = no
+  IFS="$lt_save_ifs"
 
-case $ac_x_includes,$ac_x_libraries in #(
-  no,* | *,no | *\'*)
-    # Didn't find X, or a directory has "'" in its name.
-    ac_cv_have_x="have_x=no";; #(
-  *)
-    # Record where we found X for the cache.
-    ac_cv_have_x="have_x=yes\
-	ac_x_includes='$ac_x_includes'\
-	ac_x_libraries='$ac_x_libraries'"
-esac
+  # Now substitute the updated list of available tags.
+  if eval "sed -e 's/^available_tags=.*\$/available_tags=\"$available_tags\"/' \"$ofile\" > \"${ofile}T\""; then
+    mv "${ofile}T" "$ofile"
+    chmod +x "$ofile"
+  else
+    rm -f "${ofile}T"
+    as_fn_error "unable to update list of available tagged configurations." "$LINENO" 5
+  fi
 fi
-;; #(
-    *) have_x=yes;;
-  esac
-  eval "$ac_cv_have_x"
-fi # $with_x != no
 
-if test "$have_x" != yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $have_x" >&5
-$as_echo "$have_x" >&6; }
-  no_x=yes
-else
-  # If each of the values was on the command line, it overrides each guess.
-  test "x$x_includes" = xNONE && x_includes=$ac_x_includes
-  test "x$x_libraries" = xNONE && x_libraries=$ac_x_libraries
-  # Update the cache value to reflect the command line values.
-  ac_cv_have_x="have_x=yes\
-	ac_x_includes='$x_includes'\
-	ac_x_libraries='$x_libraries'"
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: libraries $x_libraries, headers $x_includes" >&5
-$as_echo "libraries $x_libraries, headers $x_includes" >&6; }
-fi
 
-      LDFLAGS="$LDFLAGS -L$x_libraries"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GetMagickReleaseDate in -lMagick++" >&5
-$as_echo_n "checking for GetMagickReleaseDate in -lMagick++... " >&6; }
-if test "${ac_cv_lib_Magickpp_GetMagickReleaseDate+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lMagick++  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char GetMagickReleaseDate ();
-int
-main ()
-{
-return GetMagickReleaseDate ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_Magickpp_GetMagickReleaseDate=yes
-else
-  ac_cv_lib_Magickpp_GetMagickReleaseDate=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Magickpp_GetMagickReleaseDate" >&5
-$as_echo "$ac_cv_lib_Magickpp_GetMagickReleaseDate" >&6; }
-if test "x$ac_cv_lib_Magickpp_GetMagickReleaseDate" = x""yes; then :
-  $as_echo "#define USE_MAGICK 1" >>confdefs.h
+# This can be used to rebuild libtool when needed
+LIBTOOL_DEPS="$ac_aux_dir/ltmain.sh"
 
-else
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
 
-        echo ""
-        echo "Error! ImageMagick version 5.5.7 or later is required but was not found"
-        echo "       Use --with-Magick=DIR to specify the ImageMagick directory tree"
-        echo "       Use --with-Magick=no  to not use it"
-        echo "       Check the README or use configure --help for other libraries needed"
-        echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-        exit -1
+# Prevent multiple expansion
 
-fi
 
 
 
-fi
 
-fi
 
 
 
-# Check whether --with-netcdf was given.
-if test "${with_netcdf+set}" = set; then :
-  withval=$with_netcdf; with_netcdf="$withval"
-fi
 
 
-if test "x$with_netcdf" != "xno"; then
 
-  if test "x$with_netcdf" = "xyes"; then
-    # Extract the first word of "nc-config", so it can be a program name with args.
-set dummy nc-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_nc_config+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $nc_config in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_nc_config="$nc_config" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_nc_config="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
 
-  test -z "$ac_cv_path_nc_config" && ac_cv_path_nc_config="no"
-  ;;
-esac
-fi
-nc_config=$ac_cv_path_nc_config
-if test -n "$nc_config"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $nc_config" >&5
-$as_echo "$nc_config" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
 
 
-  else
-    # Extract the first word of "nc-config", so it can be a program name with args.
-set dummy nc-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if test "${ac_cv_path_nc_config+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $nc_config in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_nc_config="$nc_config" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in "$with_netcdf/bin"
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_nc_config="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
 
-  test -z "$ac_cv_path_nc_config" && ac_cv_path_nc_config="no"
-  ;;
-esac
-fi
-nc_config=$ac_cv_path_nc_config
-if test -n "$nc_config"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $nc_config" >&5
-$as_echo "$nc_config" >&6; }
+
+
+
+
+
+
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for 64-bit OS" >&5
+$as_echo_n "checking for 64-bit OS... " >&6; }
+if test "$cross_compiling" = yes; then :
+  result="maybe"
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+ int main () {
+    if (sizeof(long) == 8) { return 0; } return 1; }
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  result="yes"
+else
+  result="no"
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $result" >&5
+$as_echo "$result" >&6; }
+if test "$result" = "yes"; then
 
-  fi
+$as_echo "#define HAVE_64BIT_OS 1" >>confdefs.h
 
-  if test "x$nc_config" != "xno"; then
-    LIBS="$LIBS `$nc_config --libs`"
-    INCLUDES="$INCLUDES `$nc_config --cflags`"
-    ncdfincdir="`$nc_config --prefix`/include"
-  else
-    if test "x$with_netcdf" != "xyes"; then
-	LIBS="$LIBS -L$with_netcdf/lib -lnetcdf"
-	ncdfincdir="$with_netcdf/include"
-    else
-	LIBS="$LIBS -L/usr/lib/netcdf-3 -lnetcdf"
-        ncdfincdir="/usr/include/netcdf-3"
-    fi
-    INCLUDES="$INCLUDES -I$ncdfincdir"
-  fi
+fi
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for nc_open in -lnetcdf" >&5
-$as_echo_n "checking for nc_open in -lnetcdf... " >&6; }
-if test "${ac_cv_lib_netcdf_nc_open+set}" = set; then :
+ac_ext=cpp
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing dlopen" >&5
+$as_echo_n "checking for library containing dlopen... " >&6; }
+if test "${ac_cv_search_dlopen+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lnetcdf  $LIBS"
+  ac_func_search_save_LIBS=$LIBS
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -15962,56 +18936,91 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char nc_open ();
+char dlopen ();
 int
 main ()
 {
-return nc_open ();
+return dlopen ();
   ;
   return 0;
 }
 _ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_netcdf_nc_open=yes
-else
-  ac_cv_lib_netcdf_nc_open=no
+for ac_lib in '' dl; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_search_dlopen=$ac_res
 fi
 rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
+    conftest$ac_exeext
+  if test "${ac_cv_search_dlopen+set}" = set; then :
+  break
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_netcdf_nc_open" >&5
-$as_echo "$ac_cv_lib_netcdf_nc_open" >&6; }
-if test "x$ac_cv_lib_netcdf_nc_open" = x""yes; then :
-
-$as_echo "#define USE_NETCDF 1" >>confdefs.h
+done
+if test "${ac_cv_search_dlopen+set}" = set; then :
 
 else
+  ac_cv_search_dlopen=no
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_dlopen" >&5
+$as_echo "$ac_cv_search_dlopen" >&6; }
+ac_res=$ac_cv_search_dlopen
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
 
-    echo ""
-    echo "Error! netCDF version 3.5.1 or later is required but was not found"
-    echo "       Use --with-netcdf=DIR to specify the netcdf directory tree"
-    echo "       Use --with-netcdf=no  to not use it"
-    echo "       Check the README or use configure --help for other libraries needed"
-    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-    exit -1
+fi
 
+if test x"$ac_cv_search_dlopen" = x-ldl; then
+LIBS="$LIBS -ldl"
 fi
 
 
-  for ac_header in "netcdfcpp.h"
+# Check whether --enable-python_module was given.
+if test "${enable_python_module+set}" = set; then :
+  enableval=$enable_python_module;  PYTHON_MODULE="$enableval"
+
+fi
+
+
+if test "x$PYTHON_MODULE" = "xyes"; then
+
+$as_echo "#define PYTHON_MODULE 1" >>confdefs.h
+
+fi
+
+
+if test "x$PYTHON_MODULE" = "xyes"; then
+  BUILDASLIBRARY_TRUE=
+  BUILDASLIBRARY_FALSE='#'
+else
+  BUILDASLIBRARY_TRUE='#'
+  BUILDASLIBRARY_FALSE=
+fi
+
+
+
+for ac_func in malloc_zone_statistics sbrk mallinfo
 do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-eval as_val=\$$as_ac_Header
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_cxx_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
    if test "x$as_val" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
 
-else
+fi
+done
 
-    for ac_header in "$ncdfincdir/netcdfcpp.h"
+
+for ac_header in malloc.h malloc/malloc.h
 do :
   as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
 ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
@@ -16021,58 +19030,53 @@
 #define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
 
-else
-
-      echo ""
-      echo "Error! netCDF installation seems not to be usable"
-      echo "       This suggests a conflicting netCDF-HDF4 installation, e.g."
-      echo "       - uninstalling HDF4 after installation of netCDF"
-      echo "       - installing netCDF before HDF4"
-      exit -1
-
 fi
 
 done
 
 
+for ac_header in locale.h
+do :
+  ac_fn_cxx_check_header_mongrel "$LINENO" "locale.h" "ac_cv_header_locale_h" "$ac_includes_default"
+if test "x$ac_cv_header_locale_h" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LOCALE_H 1
+_ACEOF
+
 fi
 
 done
 
 
-fi
+for ac_func in nexttoward
+do :
+  ac_fn_cxx_check_func "$LINENO" "nexttoward" "ac_cv_func_nexttoward"
+if test "x$ac_cv_func_nexttoward" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_NEXTTOWARD 1
+_ACEOF
 
+fi
+done
 
 
-# Check whether --with-hdf was given.
-if test "${with_hdf+set}" = set; then :
-  withval=$with_hdf; with_hdf="$withval"
-fi
 
 
-if test "x$with_hdf" != "xno"; then
+# Check whether --with-ncursesdir was given.
+if test "${with_ncursesdir+set}" = set; then :
+  withval=$with_ncursesdir;  LIBS="$LIBS -L$withval/lib"
+         INCLUDES="$INCLUDES -I$withval/include"
 
-  # on Debian the no-netcdf flavour of HDF4 libraries has an alt-suffixed naming
-  _LIBS=$LIBS
-  _INCLUDES=$INCLUDES
-  for sfx in "dfalt" "df"; do
+fi
 
-    if test "x$with_hdf" != "xyes"; then
-      LIBS="$_LIBS -L$with_hdf/lib -L$with_hdf/lib/hdf -lmfh$sfx -l$sfx -ljpeg -lz"
-      INCLUDES="$_INCLUDES -I$with_hdf/include -I$with_hdf/include/hdf"
-    else
-      LIBS="$_LIBS -L/usr/lib/hdf -lmfh$sfx -l$sfx -ljpeg -lz"
-      INCLUDES="$_INCLUDES -I/usr/include/hdf"
-    fi
 
-    as_ac_Lib=`$as_echo "ac_cv_lib_$sfx''_Hopen" | $as_tr_sh`
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Hopen in -l$sfx" >&5
-$as_echo_n "checking for Hopen in -l$sfx... " >&6; }
-if { as_var=$as_ac_Lib; eval "test \"\${$as_var+set}\" = set"; }; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for initscr in -lncurses" >&5
+$as_echo_n "checking for initscr in -lncurses... " >&6; }
+if test "${ac_cv_lib_ncurses_initscr+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-l$sfx  $LIBS"
+LIBS="-lncurses  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -16082,44 +19086,39 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char Hopen ();
+char initscr ();
 int
 main ()
 {
-return Hopen ();
+return initscr ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_cxx_try_link "$LINENO"; then :
-  eval "$as_ac_Lib=yes"
+  ac_cv_lib_ncurses_initscr=yes
 else
-  eval "$as_ac_Lib=no"
+  ac_cv_lib_ncurses_initscr=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-eval ac_res=\$$as_ac_Lib
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-eval as_val=\$$as_ac_Lib
-   if test "x$as_val" = x""yes; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ncurses_initscr" >&5
+$as_echo "$ac_cv_lib_ncurses_initscr" >&6; }
+if test "x$ac_cv_lib_ncurses_initscr" = x""yes; then :
 
-$as_echo "#define USE_HDF 1" >>confdefs.h
+$as_echo "#define HAVE_LIBNCURSES 1" >>confdefs.h
 
+  LIBS="-lncurses $LIBS"
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if linking with SZIP helps" >&5
-$as_echo_n "checking if linking with SZIP helps... " >&6; }
-      echo ""
-      as_ac_Lib=`$as_echo "ac_cv_lib_$sfx''_Hclose" | $as_tr_sh`
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Hclose in -l$sfx" >&5
-$as_echo_n "checking for Hclose in -l$sfx... " >&6; }
-if { as_var=$as_ac_Lib; eval "test \"\${$as_var+set}\" = set"; }; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for initscr in -lcurses" >&5
+$as_echo_n "checking for initscr in -lcurses... " >&6; }
+if test "${ac_cv_lib_curses_initscr+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-l$sfx -lsz $LIBS"
+LIBS="-lcurses  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -16129,63 +19128,62 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char Hclose ();
+char initscr ();
 int
 main ()
 {
-return Hclose ();
+return initscr ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_cxx_try_link "$LINENO"; then :
-  eval "$as_ac_Lib=yes"
+  ac_cv_lib_curses_initscr=yes
 else
-  eval "$as_ac_Lib=no"
+  ac_cv_lib_curses_initscr=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-eval ac_res=\$$as_ac_Lib
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-eval as_val=\$$as_ac_Lib
-   if test "x$as_val" = x""yes; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_curses_initscr" >&5
+$as_echo "$ac_cv_lib_curses_initscr" >&6; }
+if test "x$ac_cv_lib_curses_initscr" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBCURSES 1
+_ACEOF
 
-        LIBS="$LIBS -lsz"
+  LIBS="-lcurses $LIBS"
 
-$as_echo "#define USE_HDF 1" >>confdefs.h
+fi
+
+fi
 
 
-else
 
-        if test $sfx != "dfalt"; then
-          echo ""
-          echo "Error! HDF4 libraries were not found"
-          echo "       Use --with-hdf=DIR to specify the HDF directory tree"
-          echo "       Use --with-hdf=no  to not use it"
-          echo "       Check the README or use configure --help for other libraries needed"
-          echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-          exit -1
-        else
-          continue # switchng to non-alt-suffixed naming
-        fi
 
+# Check whether --with-readlinedir was given.
+if test "${with_readlinedir+set}" = set; then :
+  withval=$with_readlinedir;  with_readlinedir="$withval"
 fi
 
 
-fi
+if test "x$with_readlinedir" != "xno"; then
 
+  if test "x$with_readlinedir" != "xyes"; then
+    LIBS="-L$with_readlinedir/lib -L$with_readlinedir $LIBS -lreadline"
+    INCLUDES="$INCLUDES -I$with_readlinedir/include -I$with_readlinedir"
+  else
+    LIBS="$LIBS -lreadline"
+  fi
 
-    as_ac_Lib=`$as_echo "ac_cv_lib_mfh$sfx''_SDstart" | $as_tr_sh`
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for SDstart in -lmfh$sfx" >&5
-$as_echo_n "checking for SDstart in -lmfh$sfx... " >&6; }
-if { as_var=$as_ac_Lib; eval "test \"\${$as_var+set}\" = set"; }; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for stifle_history in -lreadline" >&5
+$as_echo_n "checking for stifle_history in -lreadline... " >&6; }
+if test "${ac_cv_lib_readline_stifle_history+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lmfh$sfx  $LIBS"
+LIBS="-lreadline  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -16195,55 +19193,49 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char SDstart ();
+char stifle_history ();
 int
 main ()
 {
-return SDstart ();
+return stifle_history ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_cxx_try_link "$LINENO"; then :
-  eval "$as_ac_Lib=yes"
+  ac_cv_lib_readline_stifle_history=yes
 else
-  eval "$as_ac_Lib=no"
+  ac_cv_lib_readline_stifle_history=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-eval ac_res=\$$as_ac_Lib
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-eval as_val=\$$as_ac_Lib
-   if test "x$as_val" = x""yes; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_readline_stifle_history" >&5
+$as_echo "$ac_cv_lib_readline_stifle_history" >&6; }
+if test "x$ac_cv_lib_readline_stifle_history" = x""yes; then :
 
-$as_echo "#define USE_HDF 1" >>confdefs.h
+$as_echo "#define HAVE_LIBREADLINE 1" >>confdefs.h
 
 else
 
-      echo ""
-      echo "Error! HDF4 libraries were not found"
-      echo "       Use --with-hdf=DIR to specify the HDF directory tree"
-      echo "       Use --with-hdf=no  to not use it"
-      echo "       Check the README or use configure --help for other libraries needed"
-      echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-      exit -1
+	echo ""
+	echo "Error! GNU readline was not found."
+	echo "       Use --with-readlinedir=no to expicitely disable it"
+	echo "       Check the README or use configure --help for other libraries needed"
+
+	exit -1
 
 fi
 
 
-    # checking if HDF4 was compiled with the '--disable-netcdf' option
-    if test "x$with_netcdf" != "xno"; then
-      as_ac_Lib=`$as_echo "ac_cv_lib_mfh$sfx''_sd_nccreate" | $as_tr_sh`
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sd_nccreate in -lmfh$sfx" >&5
-$as_echo_n "checking for sd_nccreate in -lmfh$sfx... " >&6; }
-if { as_var=$as_ac_Lib; eval "test \"\${$as_var+set}\" = set"; }; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for rl_get_screen_size in -lreadline" >&5
+$as_echo_n "checking for rl_get_screen_size in -lreadline... " >&6; }
+if test "${ac_cv_lib_readline_rl_get_screen_size+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lmfh$sfx  $LIBS"
+LIBS="-lreadline  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -16253,122 +19245,75 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char sd_nccreate ();
+char rl_get_screen_size ();
 int
 main ()
 {
-return sd_nccreate ();
+return rl_get_screen_size ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_cxx_try_link "$LINENO"; then :
-  eval "$as_ac_Lib=yes"
+  ac_cv_lib_readline_rl_get_screen_size=yes
 else
-  eval "$as_ac_Lib=no"
+  ac_cv_lib_readline_rl_get_screen_size=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-eval ac_res=\$$as_ac_Lib
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-eval as_val=\$$as_ac_Lib
-   if test "x$as_val" = x""yes; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_LIBmfh$sfx" | $as_tr_cpp` 1
-_ACEOF
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_readline_rl_get_screen_size" >&5
+$as_echo "$ac_cv_lib_readline_rl_get_screen_size" >&6; }
+if test "x$ac_cv_lib_readline_rl_get_screen_size" = x""yes; then :
 
-  LIBS="-lmfh$sfx $LIBS"
+
+$as_echo "#define RL_GET_SCREEN_SIZE 1" >>confdefs.h
 
 else
 
-        echo ""
-        echo "Error! HDF4 needs to be configured with the --disable-netcdf option"
-        echo "       in order to be used with the original netCDF library"
-        echo "       (-alt suffixed HDF4 packages in case of Debian)"
-        echo "       Check the INSTALL file of the HDF4 package for details"
-        exit -1
+	echo ""
+	echo "Warning! Older GNU readline without 'rl_get_screen_size' was found."
+	echo "         For resized terminals the size might not be updated correctly"
+	echo "         If this is a problem please install a recent version of readline"
 
 fi
 
-    fi
-
-    # all went OK with the alt-suffixed naming -> skipping tests for the non-alt-suffixed naming
-    if test $sfx == "dfalt"; then break; fi
 
-  done
 fi
 
 
 
-# Check whether --with-hdf5 was given.
-if test "${with_hdf5+set}" = set; then :
-  withval=$with_hdf5; with_hdf5="$withval"
+# Check whether --with-zlibdir was given.
+if test "${with_zlibdir+set}" = set; then :
+  withval=$with_zlibdir; with_zlib="$withval"
 fi
 
 
-if test "x$with_hdf5" != "xno"; then
-  if test "x$with_hdf5" != "xyes"; then
-    LIBS="$LIBS -L$with_hdf5/lib -L$with_hdf5/lib/hdf -L$with_hdf5/lib/hdf5 -lhdf5"
-    INCLUDES="$INCLUDES -I$with_hdf5/include -I$with_hdf5/include/hdf -I$with_hdf5/include/hdf5"
-  else
-    INCLUDES="$INCLUDES -I/usr/include/hdf -I/usr/include/hdf5"
-    LIBS="$LIBS -L/usr/lib/hdf -L/usr/lib/hdf5 -lhdf5"
-  fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for H5Fopen in -lhdf5" >&5
-$as_echo_n "checking for H5Fopen in -lhdf5... " >&6; }
-if test "${ac_cv_lib_hdf5_H5Fopen+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lhdf5  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char H5Fopen ();
-int
-main ()
-{
-return H5Fopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_hdf5_H5Fopen=yes
-else
-  ac_cv_lib_hdf5_H5Fopen=no
+if test "x$with_zlib" = "x"; then
+  with_zlib=yes
 fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
+
+if test "x$with_zlib" = "xno"; then
+	echo ""
+	echo "Error! ZLIB library is obligatory."
+        exit -1
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_hdf5_H5Fopen" >&5
-$as_echo "$ac_cv_lib_hdf5_H5Fopen" >&6; }
-if test "x$ac_cv_lib_hdf5_H5Fopen" = x""yes; then :
 
-$as_echo "#define USE_HDF5 1" >>confdefs.h
+if test "x$with_zlib" != "xyes"; then
+    LIBS="$LIBS -L$with_zlib/lib -lz"
+    INCLUDES="$INCLUDES -I$with_zlib/include"
+else
+    LIBS="$LIBS -lz"
+fi
 
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if linking with SZIP helps" >&5
-$as_echo_n "checking if linking with SZIP helps... " >&6; }
-    echo ""
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for H5Fclose in -lhdf5" >&5
-$as_echo_n "checking for H5Fclose in -lhdf5... " >&6; }
-if test "${ac_cv_lib_hdf5_H5Fclose+set}" = set; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for gzopen in -lz" >&5
+$as_echo_n "checking for gzopen in -lz... " >&6; }
+if test "${ac_cv_lib_z_gzopen+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lhdf5 -lsz $LIBS"
+LIBS="-lz  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -16378,73 +19323,122 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char H5Fclose ();
+char gzopen ();
 int
 main ()
 {
-return H5Fclose ();
+return gzopen ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_hdf5_H5Fclose=yes
+  ac_cv_lib_z_gzopen=yes
 else
-  ac_cv_lib_hdf5_H5Fclose=no
+  ac_cv_lib_z_gzopen=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_hdf5_H5Fclose" >&5
-$as_echo "$ac_cv_lib_hdf5_H5Fclose" >&6; }
-if test "x$ac_cv_lib_hdf5_H5Fclose" = x""yes; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_z_gzopen" >&5
+$as_echo "$ac_cv_lib_z_gzopen" >&6; }
+if test "x$ac_cv_lib_z_gzopen" = x""yes; then :
 
-      LIBS="$LIBS -lsz"
+$as_echo "#define HAVE_LIBZ 1" >>confdefs.h
+
+else
+
+ 	echo ""
+ 	echo "Error! zlib library is required but was not found"
+ 	echo "       Use --with-zlibdir=DIR to specify the zlib directory tree"
+ 	exit -1
+
+fi
+
+
+
+
+
+# Check whether --with-openmp was given.
+if test "${with_openmp+set}" = set; then :
+  withval=$with_openmp; with_openmp="$withval"
+fi
 
-$as_echo "#define USE_HDF5 1" >>confdefs.h
 
+openmp_autodetected=no
+if test "x$with_openmp" = "x"; then
+   for ac_header in "omp.h"
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+eval as_val=\$$as_ac_Header
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+     with_openmp=yes
+     openmp_autodetected=yes
+     echo ""
+     echo "OpenMP enabled (omp.h file was found)."
+     echo "Try --with-openmp=no if your compiler does not support it (e.g. GCC < 4.2)"
+     echo ""
 
 else
 
-    echo ""
-    echo "Error! HDF version 5 is required but was not found"
-    echo "       Use --with-hdf5=DIR to specify the HDF5 directory tree"
-    echo "       Use --with-hdf5=no  to not use it"
-    echo "       Check the README or use configure --help for other libraries needed"
-    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-    exit -1
+     with_openmp=no
+     echo ""
+     echo "OpenMP disabled (omp.h file was not found)."
+     echo "Try --with-openmp=yes if your compiler does support it (e.g. GCC >= 4.2)"
+     echo ""
 
 fi
 
+done
+
 fi
 
+if test "x$with_openmp" != "xno"; then
+	CPPFLAGS="$CPPFLAGS -fopenmp"
+	LDFLAGS="$LDFLAGS -fopenmp"
 fi
 
 
 
-# Check whether --with-fftw was given.
-if test "${with_fftw+set}" = set; then :
-  withval=$with_fftw; with_fftw="$withval"
+
+
+
+# Check whether --with-gsldir was given.
+if test "${with_gsldir+set}" = set; then :
+  withval=$with_gsldir; with_gsl="$withval"
 fi
 
 
-if test "x$with_fftw" != "xno"; then
-  if test "x$with_fftw" != "xyes"; then
-    LIBS="$LIBS -L$with_fftw/lib -lfftw3"
-    INCLUDES="$INCLUDES -I$with_fftw/include"
-  else
-    INCLUDES="$INCLUDES -I/usr/include"
-    LIBS="$LIBS -lfftw3"
-  fi
+if test "x$with_gsl" = "x"; then
+  with_gsl=yes
+fi
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fftw_malloc in -lfftw3" >&5
-$as_echo_n "checking for fftw_malloc in -lfftw3... " >&6; }
-if test "${ac_cv_lib_fftw3_fftw_malloc+set}" = set; then :
+if test "x$with_gsl" = "xno"; then
+	echo ""
+	echo "Error! Gnu Scientific Library (1.7 or higher) is mandatory"
+        exit -1
+fi
+
+if test "x$with_gsl" != "xyes"; then
+    LIBS="$LIBS -L$with_gsl/lib -lgsl -lgslcblas"
+    INCLUDES="$INCLUDES -I$with_gsl/include"
+else
+    LIBS="$LIBS -lgsl -lgslcblas"
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for gsl_ran_binomial_knuth in -lgsl" >&5
+$as_echo_n "checking for gsl_ran_binomial_knuth in -lgsl... " >&6; }
+if test "${ac_cv_lib_gsl_gsl_ran_binomial_knuth+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lfftw3  $LIBS"
+LIBS="-lgsl  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -16454,60 +19448,48 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char fftw_malloc ();
+char gsl_ran_binomial_knuth ();
 int
 main ()
 {
-return fftw_malloc ();
+return gsl_ran_binomial_knuth ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_fftw3_fftw_malloc=yes
+  ac_cv_lib_gsl_gsl_ran_binomial_knuth=yes
 else
-  ac_cv_lib_fftw3_fftw_malloc=no
+  ac_cv_lib_gsl_gsl_ran_binomial_knuth=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_fftw3_fftw_malloc" >&5
-$as_echo "$ac_cv_lib_fftw3_fftw_malloc" >&6; }
-if test "x$ac_cv_lib_fftw3_fftw_malloc" = x""yes; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gsl_gsl_ran_binomial_knuth" >&5
+$as_echo "$ac_cv_lib_gsl_gsl_ran_binomial_knuth" >&6; }
+if test "x$ac_cv_lib_gsl_gsl_ran_binomial_knuth" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBGSL 1
+_ACEOF
 
-$as_echo "#define USE_FFTW 1" >>confdefs.h
+  LIBS="-lgsl $LIBS"
 
 else
 
-    echo ""
-    echo "Error! FFTW3 version 3 is required but was not found"
-    echo "       Use --with-fftw=DIR to specify the FFTW directory tree"
-    echo "       Use --with-fftw=no  to not use it"
-    echo "       Check the README or use configure --help for other libraries needed"
-    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-    exit -1
-
-fi
+	echo ""
+	echo "Error! Gnu Scientific Library (1.7 or higher) is mandatory"
+        exit -1
 
 fi
 
-if test "x$with_fftw" != "xno"; then
-  if test "x$with_fftw" != "xyes"; then
-    LIBS="$LIBS -L$with_fftw/lib -lfftw3f"
-    INCLUDES="$INCLUDES -I$with_fftw/include"
-  else
-    INCLUDES="$INCLUDES -I/usr/include"
-    LIBS="$LIBS -lfftw3f"
-  fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fftwf_malloc in -lfftw3f" >&5
-$as_echo_n "checking for fftwf_malloc in -lfftw3f... " >&6; }
-if test "${ac_cv_lib_fftw3f_fftwf_malloc+set}" = set; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for cblas_drot in -lgslcblas" >&5
+$as_echo_n "checking for cblas_drot in -lgslcblas... " >&6; }
+if test "${ac_cv_lib_gslcblas_cblas_drot+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lfftw3f  $LIBS"
+LIBS="-lgslcblas  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -16517,68 +19499,89 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char fftwf_malloc ();
+char cblas_drot ();
 int
 main ()
 {
-return fftwf_malloc ();
+return cblas_drot ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_fftw3f_fftwf_malloc=yes
+  ac_cv_lib_gslcblas_cblas_drot=yes
 else
-  ac_cv_lib_fftw3f_fftwf_malloc=no
+  ac_cv_lib_gslcblas_cblas_drot=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_fftw3f_fftwf_malloc" >&5
-$as_echo "$ac_cv_lib_fftw3f_fftwf_malloc" >&6; }
-if test "x$ac_cv_lib_fftw3f_fftwf_malloc" = x""yes; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gslcblas_cblas_drot" >&5
+$as_echo "$ac_cv_lib_gslcblas_cblas_drot" >&6; }
+if test "x$ac_cv_lib_gslcblas_cblas_drot" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBGSLCBLAS 1
+_ACEOF
 
-$as_echo "#define USE_FFTW 1" >>confdefs.h
+  LIBS="-lgslcblas $LIBS"
 
 else
 
-    echo ""
-    echo "Error! FFTW3F version 3 is required but was not found"
-    echo "       Use --with-fftw=DIR to specify the FFTW directory tree"
-    echo "       Use --with-fftw=no  to not use it"
-    echo "       Check the README or use configure --help for other libraries needed"
-    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-    exit -1
+	echo ""
+	echo "Error! libgslcblas (part of GSL) is mandatory"
+        exit -1
 
 fi
 
+
+
+
+# Check whether --with-plplotdir was given.
+if test "${with_plplotdir+set}" = set; then :
+  withval=$with_plplotdir; with_plplot="$withval"
 fi
 
 
+if test "x$with_plplot" = "x"; then
+  with_plplot=yes
+fi
 
-# Check whether --with-libproj4 was given.
-if test "${with_libproj4+set}" = set; then :
-  withval=$with_libproj4; with_libproj4="$withval"
+if test "x$with_plplot" = "xno"; then
+	echo ""
+	echo "Error! PLPLOT library is mandatory."
+        exit -1
 fi
 
+OLDPLPLOT="no"
+# Check whether --enable-oldplplot was given.
+if test "${enable_oldplplot+set}" = set; then :
+  enableval=$enable_oldplplot;  OLDPLPLOT="$enableval"
 
-if test "x$with_libproj4" != "xno"; then
-  if test "x$with_libproj4" != "xyes"; then
-    LIBS="$LIBS -L$with_libproj4/lib -lproj4"
-    INCLUDES="$INCLUDES -I$with_libproj4/include"
-  else
-    INCLUDES="$INCLUDES -I/usr/include"
-    LIBS="$LIBS -lproj4"
-  fi
+fi
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for proj_init in -lproj4" >&5
-$as_echo_n "checking for proj_init in -lproj4... " >&6; }
-if test "${ac_cv_lib_proj4_proj_init+set}" = set; then :
+
+if test "x$OLDPLPLOT" = "xyes"; then
+
+$as_echo "#define HAVE_OLDPLPLOT 1" >>confdefs.h
+
+fi
+
+if test "x$with_plplot" != "xyes"; then
+    LIBS="$LIBS -L$with_plplot/lib -lplplotd -lplplotcxxd"
+    INCLUDES="$INCLUDES -I$with_plplot/include"
+else
+    LIBS="$LIBS -lplplotd -lplplotcxxd"
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for plsexit in -lplplotcxxd" >&5
+$as_echo_n "checking for plsexit in -lplplotcxxd... " >&6; }
+if test "${ac_cv_lib_plplotcxxd_plsexit+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lproj4  $LIBS"
+LIBS="-lplplotcxxd  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -16588,40 +19591,49 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char proj_init ();
+char plsexit ();
 int
 main ()
 {
-return proj_init ();
+return plsexit ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_proj4_proj_init=yes
+  ac_cv_lib_plplotcxxd_plsexit=yes
 else
-  ac_cv_lib_proj4_proj_init=no
+  ac_cv_lib_plplotcxxd_plsexit=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_proj4_proj_init" >&5
-$as_echo "$ac_cv_lib_proj4_proj_init" >&6; }
-if test "x$ac_cv_lib_proj4_proj_init" = x""yes; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_plplotcxxd_plsexit" >&5
+$as_echo "$ac_cv_lib_plplotcxxd_plsexit" >&6; }
+if test "x$ac_cv_lib_plplotcxxd_plsexit" = x""yes; then :
 
-$as_echo "#define USE_LIBPROJ4 1" >>confdefs.h
+$as_echo "#define HAVE_LIBPLPLOTCXXD 1" >>confdefs.h
+
+else
+
+	echo ""
+	echo "Error! plplot library is required but was not found"
+	echo "       Use --with-plplot=DIR to specify the plplot directory tree"
+	exit -1
 
 fi
 
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for proj_init in -lproj4" >&5
-$as_echo_n "checking for proj_init in -lproj4... " >&6; }
-if test "${ac_cv_lib_proj4_proj_init+set}" = set; then :
+if test "x$with_Magick" != "xno"; then
+  # https://sourceforge.net/tracker/index.php?func=detail&aid=2974380&group_id=97659&atid=618683
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for plGetDrvDir in -lplplotd" >&5
+$as_echo_n "checking for plGetDrvDir in -lplplotd... " >&6; }
+if test "${ac_cv_lib_plplotd_plGetDrvDir+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lproj4  $LIBS"
+LIBS="-lplplotd  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -16631,40 +19643,283 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char proj_init ();
+char plGetDrvDir ();
 int
 main ()
 {
-return proj_init ();
+return plGetDrvDir ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_proj4_proj_init=yes
+  ac_cv_lib_plplotd_plGetDrvDir=yes
 else
-  ac_cv_lib_proj4_proj_init=no
+  ac_cv_lib_plplotd_plGetDrvDir=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_proj4_proj_init" >&5
-$as_echo "$ac_cv_lib_proj4_proj_init" >&6; }
-if test "x$ac_cv_lib_proj4_proj_init" = x""yes; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_plplotd_plGetDrvDir" >&5
+$as_echo "$ac_cv_lib_plplotd_plGetDrvDir" >&6; }
+if test "x$ac_cv_lib_plplotd_plGetDrvDir" = x""yes; then :
 
-$as_echo "#define USE_LIBPROJ4_NEW 1" >>confdefs.h
+    echo ""
+    echo "Warning! Dynamic drivers have to be disabled in plplot"
+    echo "         to make plplot work with ImageMagic:"
+    echo "         - use the -DENABLE_DYNDRIVERS=OFF cmake option when"
+    echo "           compiling plplot to disable dynamic drivers in plplot, or"
+    echo "         - use --with-Magick=no here to not use ImageMagick in GDL."
+    echo ""
+
+fi
+
+fi
+
+
+
+
+# Check whether --with-wxWidgets was given.
+if test "${with_wxWidgets+set}" = set; then :
+  withval=$with_wxWidgets; with_wxWidgets="$withval"
+fi
+
+
+if test "x$with_wxWidgets" != "xno"; then
+
+  if test "x$with_wxWidgets" = "xyes"; then
+    # Extract the first word of "wx-config", so it can be a program name with args.
+set dummy wx-config; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_path_wxConfig+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $wxConfig in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_wxConfig="$wxConfig" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_wxConfig="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
+  test -z "$ac_cv_path_wxConfig" && ac_cv_path_wxConfig="no"
+  ;;
+esac
+fi
+wxConfig=$ac_cv_path_wxConfig
+if test -n "$wxConfig"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $wxConfig" >&5
+$as_echo "$wxConfig" >&6; }
 else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
 
 
-     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pj_init in -lproj4" >&5
-$as_echo_n "checking for pj_init in -lproj4... " >&6; }
-if test "${ac_cv_lib_proj4_pj_init+set}" = set; then :
+  else
+    # Extract the first word of "wx-config", so it can be a program name with args.
+set dummy wx-config; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_path_wxConfig+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $wxConfig in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_wxConfig="$wxConfig" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in "$with_wxWidgets/bin"
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_wxConfig="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_wxConfig" && ac_cv_path_wxConfig="no"
+  ;;
+esac
+fi
+wxConfig=$ac_cv_path_wxConfig
+if test -n "$wxConfig"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $wxConfig" >&5
+$as_echo "$wxConfig" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+
+  if test "x$wxConfig" = "xno"; then
+    as_fn_error "wxWidgets are required but were not found (wx-config program not found)
+      Use --with-wxWidgets=DIR to specify the wxWidgets directory tree
+      Use --with-wxWidgets=no  to not use it
+    " "$LINENO" 5
+  else
+    LIBS="$LIBS `wx-config --libs`"
+    INCLUDES="$INCLUDES `wx-config --cxxflags`"
+              fi
+
+
+$as_echo "#define HAVE_LIBWXWIDGETS 1" >>confdefs.h
+
+
+  # SA: the code below worked for me on Ubuntu and Macports... but it does not work e.g. on Fedora
+  #
+  #tmp="`wx-config --basename`-`wx-config --release`"
+  #AC_CHECK_LIB($tmp, wxFatalSignalHandler,
+  #  [AC_DEFINE([HAVE_LIBWXWIDGETS], [1], [wxWidgets library])], [
+  #    dnl SA: handling the multi-port wxWidgets installation case
+  #    tmp="`wx-config --basename --toolkit=base`-`wx-config --release`"
+  #    AC_CHECK_LIB($tmp, wxInteger_compare, [AC_DEFINE([HAVE_LIBWXWIDGETS], [1])], [
+  #      echo ""
+  #      echo "Error! wxWidgets version 2.8 or later is required but was not found"
+  #      echo "       Use --with-wxWidgets=DIR to specify the wxWidgets directory tree"
+  #      echo "       Use --with-wxWidgets=no  to not use it"
+  #      echo "       Check the README or use configure --help for other libraries needed"
+  #      echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
+  #      exit -1
+  #    ])
+  #])
+fi
+
+
+
+# Check whether --with-Magick was given.
+if test "${with_Magick+set}" = set; then :
+  withval=$with_Magick; with_Magick="$withval"
+fi
+
+
+if test "x$with_Magick" != "xno"; then
+  if test "x$with_Magick" = "xyes"; then
+    # Extract the first word of "Magick++-config", so it can be a program name with args.
+set dummy Magick++-config; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_path_MagickConfig+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $MagickConfig in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_MagickConfig="$MagickConfig" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_MagickConfig="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_MagickConfig" && ac_cv_path_MagickConfig="no"
+  ;;
+esac
+fi
+MagickConfig=$ac_cv_path_MagickConfig
+if test -n "$MagickConfig"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MagickConfig" >&5
+$as_echo "$MagickConfig" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  else
+    # Extract the first word of "Magick++-config", so it can be a program name with args.
+set dummy Magick++-config; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_path_MagickConfig+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $MagickConfig in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_MagickConfig="$MagickConfig" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in "$with_Magick/bin"
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_MagickConfig="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_MagickConfig" && ac_cv_path_MagickConfig="no"
+  ;;
+esac
+fi
+MagickConfig=$ac_cv_path_MagickConfig
+if test -n "$MagickConfig"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MagickConfig" >&5
+$as_echo "$MagickConfig" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+
+  if test "x$MagickConfig" = "xno"; then
+    as_fn_error "ImageMagick is required but was not found (Magick++-config program not found)
+      Use --with-Magick=DIR to specify the ImageMagick directory tree
+      Use --with-Magick=no  to not use it
+    " "$LINENO" 5
+  else
+    LIBS="$LIBS `$MagickConfig --libs`"
+    INCLUDES="$INCLUDES `$MagickConfig --cppflags`"
+    LDFLAGS="$LDFLAGS `$MagickConfig --ldflags`"
+  fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GetMagickVersion in -lMagick++" >&5
+$as_echo_n "checking for GetMagickVersion in -lMagick++... " >&6; }
+if test "${ac_cv_lib_Magickpp_GetMagickVersion+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lproj4  $LIBS"
+LIBS="-lMagick++  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -16674,71 +19929,237 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char pj_init ();
+char GetMagickVersion ();
 int
 main ()
 {
-return pj_init ();
+return GetMagickVersion ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_proj4_pj_init=yes
+  ac_cv_lib_Magickpp_GetMagickVersion=yes
 else
-  ac_cv_lib_proj4_pj_init=no
+  ac_cv_lib_Magickpp_GetMagickVersion=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_proj4_pj_init" >&5
-$as_echo "$ac_cv_lib_proj4_pj_init" >&6; }
-if test "x$ac_cv_lib_proj4_pj_init" = x""yes; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Magickpp_GetMagickVersion" >&5
+$as_echo "$ac_cv_lib_Magickpp_GetMagickVersion" >&6; }
+if test "x$ac_cv_lib_Magickpp_GetMagickVersion" = x""yes; then :
 
-$as_echo "#define USE_LIBPROJ4 1" >>confdefs.h
+$as_echo "#define USE_MAGICK 1" >>confdefs.h
 
 else
 
-       echo ""
-       echo "Error! LIBPROJ4 is required but was not found"
-       echo "       Use --with-libproj4=DIR to specify the LIBPROJ4 directory tree"
-       echo "       Use --with-libproj4=no  to not use it"
-       echo "       Check the README or use configure --help for other libraries needed"
-       echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-       exit -1
-
-fi
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking if adding X library path helps" >&5
+$as_echo_n "checking if adding X library path helps... " >&6; }
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: ?" >&5
+$as_echo "?" >&6; }
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for X" >&5
+$as_echo_n "checking for X... " >&6; }
 
 
+# Check whether --with-x was given.
+if test "${with_x+set}" = set; then :
+  withval=$with_x;
 fi
 
+# $have_x is `yes', `no', `disabled', or empty when we do not yet know.
+if test "x$with_x" = xno; then
+  # The user explicitly disabled X.
+  have_x=disabled
+else
+  case $x_includes,$x_libraries in #(
+    *\'*) as_fn_error "cannot use X directory names containing '" "$LINENO" 5;; #(
+    *,NONE | NONE,*) if test "${ac_cv_have_x+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  # One or both of the vars are not set, and there is no cached value.
+ac_x_includes=no ac_x_libraries=no
+rm -f -r conftest.dir
+if mkdir conftest.dir; then
+  cd conftest.dir
+  cat >Imakefile <<'_ACEOF'
+incroot:
+	@echo incroot='${INCROOT}'
+usrlibdir:
+	@echo usrlibdir='${USRLIBDIR}'
+libdir:
+	@echo libdir='${LIBDIR}'
+_ACEOF
+  if (export CC; ${XMKMF-xmkmf}) >/dev/null 2>/dev/null && test -f Makefile; then
+    # GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+    for ac_var in incroot usrlibdir libdir; do
+      eval "ac_im_$ac_var=\`\${MAKE-make} $ac_var 2>/dev/null | sed -n 's/^$ac_var=//p'\`"
+    done
+    # Open Windows xmkmf reportedly sets LIBDIR instead of USRLIBDIR.
+    for ac_extension in a so sl dylib la dll; do
+      if test ! -f "$ac_im_usrlibdir/libX11.$ac_extension" &&
+	 test -f "$ac_im_libdir/libX11.$ac_extension"; then
+	ac_im_usrlibdir=$ac_im_libdir; break
+      fi
+    done
+    # Screen out bogus values from the imake configuration.  They are
+    # bogus both because they are the default anyway, and because
+    # using them would break gcc on systems where it needs fixed includes.
+    case $ac_im_incroot in
+	/usr/include) ac_x_includes= ;;
+	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes=$ac_im_incroot;;
+    esac
+    case $ac_im_usrlibdir in
+	/usr/lib | /usr/lib64 | /lib | /lib64) ;;
+	*) test -d "$ac_im_usrlibdir" && ac_x_libraries=$ac_im_usrlibdir ;;
+    esac
+  fi
+  cd ..
+  rm -f -r conftest.dir
 fi
 
+# Standard set of common directories for X headers.
+# Check X11 before X11Rn because it is often a symlink to the current release.
+ac_x_header_dirs='
+/usr/X11/include
+/usr/X11R7/include
+/usr/X11R6/include
+/usr/X11R5/include
+/usr/X11R4/include
+
+/usr/include/X11
+/usr/include/X11R7
+/usr/include/X11R6
+/usr/include/X11R5
+/usr/include/X11R4
 
+/usr/local/X11/include
+/usr/local/X11R7/include
+/usr/local/X11R6/include
+/usr/local/X11R5/include
+/usr/local/X11R4/include
 
-# Check whether --with-mpich was given.
-if test "${with_mpich+set}" = set; then :
-  withval=$with_mpich; with_mpich="$withval"
-fi
+/usr/local/include/X11
+/usr/local/include/X11R7
+/usr/local/include/X11R6
+/usr/local/include/X11R5
+/usr/local/include/X11R4
 
+/usr/X386/include
+/usr/x386/include
+/usr/XFree86/include/X11
 
-if test "x$with_mpich" != "xno"; then
-  if test "x$with_mpich" != "xyes"; then
-    LIBS="$LIBS -L$with_mpich/lib -lmpich"
-    INCLUDES="$INCLUDES -I$with_mpich/include"
-  else
-    INCLUDES="$INCLUDES -I/usr/include"
-    LIBS="$LIBS -lmpich"
+/usr/include
+/usr/local/include
+/usr/unsupported/include
+/usr/athena/include
+/usr/local/x11r5/include
+/usr/lpp/Xamples/include
+
+/usr/openwin/include
+/usr/openwin/share/include'
+
+if test "$ac_x_includes" = no; then
+  # Guess where to find include files, by looking for Xlib.h.
+  # First, try using that file with no special directory specified.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+_ACEOF
+if ac_fn_cxx_try_cpp "$LINENO"; then :
+  # We can compile using X headers with no special include directory.
+ac_x_includes=
+else
+  for ac_dir in $ac_x_header_dirs; do
+  if test -r "$ac_dir/X11/Xlib.h"; then
+    ac_x_includes=$ac_dir
+    break
   fi
+done
+fi
+rm -f conftest.err conftest.$ac_ext
+fi # $ac_x_includes = no
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for MPI_Init in -lmpich" >&5
-$as_echo_n "checking for MPI_Init in -lmpich... " >&6; }
-if test "${ac_cv_lib_mpich_MPI_Init+set}" = set; then :
+if test "$ac_x_libraries" = no; then
+  # Check for the libraries.
+  # See if we find them without any special options.
+  # Don't add to $LIBS permanently.
+  ac_save_LIBS=$LIBS
+  LIBS="-lX11 $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+int
+main ()
+{
+XrmInitialize ()
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  LIBS=$ac_save_LIBS
+# We can link X programs with no special library path.
+ac_x_libraries=
+else
+  LIBS=$ac_save_LIBS
+for ac_dir in `$as_echo "$ac_x_includes $ac_x_header_dirs" | sed s/include/lib/g`
+do
+  # Don't even attempt the hair of trying to link an X program!
+  for ac_extension in a so sl dylib la dll; do
+    if test -r "$ac_dir/libX11.$ac_extension"; then
+      ac_x_libraries=$ac_dir
+      break 2
+    fi
+  done
+done
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi # $ac_x_libraries = no
+
+case $ac_x_includes,$ac_x_libraries in #(
+  no,* | *,no | *\'*)
+    # Didn't find X, or a directory has "'" in its name.
+    ac_cv_have_x="have_x=no";; #(
+  *)
+    # Record where we found X for the cache.
+    ac_cv_have_x="have_x=yes\
+	ac_x_includes='$ac_x_includes'\
+	ac_x_libraries='$ac_x_libraries'"
+esac
+fi
+;; #(
+    *) have_x=yes;;
+  esac
+  eval "$ac_cv_have_x"
+fi # $with_x != no
+
+if test "$have_x" != yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $have_x" >&5
+$as_echo "$have_x" >&6; }
+  no_x=yes
+else
+  # If each of the values was on the command line, it overrides each guess.
+  test "x$x_includes" = xNONE && x_includes=$ac_x_includes
+  test "x$x_libraries" = xNONE && x_libraries=$ac_x_libraries
+  # Update the cache value to reflect the command line values.
+  ac_cv_have_x="have_x=yes\
+	ac_x_includes='$x_includes'\
+	ac_x_libraries='$x_libraries'"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: libraries $x_libraries, headers $x_includes" >&5
+$as_echo "libraries $x_libraries, headers $x_includes" >&6; }
+fi
+
+      LDFLAGS="$LDFLAGS -L$x_libraries"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GetMagickReleaseDate in -lMagick++" >&5
+$as_echo_n "checking for GetMagickReleaseDate in -lMagick++... " >&6; }
+if test "${ac_cv_lib_Magickpp_GetMagickReleaseDate+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lmpich  $LIBS"
+LIBS="-lMagick++  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -16748,39 +20169,42 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char MPI_Init ();
+char GetMagickReleaseDate ();
 int
 main ()
 {
-return MPI_Init ();
+return GetMagickReleaseDate ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_mpich_MPI_Init=yes
+  ac_cv_lib_Magickpp_GetMagickReleaseDate=yes
 else
-  ac_cv_lib_mpich_MPI_Init=no
+  ac_cv_lib_Magickpp_GetMagickReleaseDate=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_mpich_MPI_Init" >&5
-$as_echo "$ac_cv_lib_mpich_MPI_Init" >&6; }
-if test "x$ac_cv_lib_mpich_MPI_Init" = x""yes; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Magickpp_GetMagickReleaseDate" >&5
+$as_echo "$ac_cv_lib_Magickpp_GetMagickReleaseDate" >&6; }
+if test "x$ac_cv_lib_Magickpp_GetMagickReleaseDate" = x""yes; then :
+  $as_echo "#define USE_MAGICK 1" >>confdefs.h
+
+else
+
+        echo ""
+        echo "Error! ImageMagick version 5.5.7 or later is required but was not found"
+        echo "       Use --with-Magick=DIR to specify the ImageMagick directory tree"
+        echo "       Use --with-Magick=no  to not use it"
+        echo "       Check the README or use configure --help for other libraries needed"
+        echo "       (--with-xxxdir = mandatory, --with-xxx = optional (--with-xxx=no to disable))"
+        exit -1
 
-$as_echo "#define USE_MPI 1" >>confdefs.h
+fi
 
-else
 
-    echo ""
-    echo "Error! MPICH is required but was not found"
-    echo "       Use --with-mpich=DIR to specify the MPICH directory tree"
-    echo "       Use --with-mpich=no  to not use it"
-    echo "       Check the README or use configure --help for other libraries needed"
-    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-    exit -1
 
 fi
 
@@ -16788,52 +20212,122 @@
 
 
 
-# Check whether --with-python was given.
-if test "${with_python+set}" = set; then :
-  withval=$with_python; with_python="$withval"
+# Check whether --with-netcdf was given.
+if test "${with_netcdf+set}" = set; then :
+  withval=$with_netcdf; with_netcdf="$withval"
 fi
 
 
-if test "x$with_python" != "xno"; then
+if test "x$with_netcdf" != "xno"; then
 
-    # Check whether --enable-python_version was given.
-if test "${enable_python_version+set}" = set; then :
-  enableval=$enable_python_version;  PYTHON_VERSION="$enableval"
+  if test "x$with_netcdf" = "xyes"; then
+    # Extract the first word of "nc-config", so it can be a program name with args.
+set dummy nc-config; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_path_nc_config+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $nc_config in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_nc_config="$nc_config" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_nc_config="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
 
+  test -z "$ac_cv_path_nc_config" && ac_cv_path_nc_config="no"
+  ;;
+esac
+fi
+nc_config=$ac_cv_path_nc_config
+if test -n "$nc_config"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $nc_config" >&5
+$as_echo "$nc_config" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
 fi
 
 
-  if test "x$PYTHON_VERSION" = "x"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for Python version" >&5
-$as_echo_n "checking for Python version... " >&6; }
-    queryfile=$ac_confdir/query_version.py
-    echo "# tmp file auto (re)generated by GDL configure. Please delete" > $queryfile
-    echo import sys >> $queryfile
-    echo print \'%s.%s\' % sys.version_info\[0:2\] >> $queryfile
-    PYTHON_VERSION=`python $queryfile`
-    rm $queryfile
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PYTHON_VERSION" >&5
-$as_echo "$PYTHON_VERSION" >&6; }
+  else
+    # Extract the first word of "nc-config", so it can be a program name with args.
+set dummy nc-config; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_path_nc_config+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $nc_config in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_nc_config="$nc_config" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in "$with_netcdf/bin"
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_nc_config="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
   fi
+done
+  done
+IFS=$as_save_IFS
 
-  if test "x$with_python" != "xyes"; then
-    LIBS="$LIBS -L$with_python/lib"
-    LIBS="$LIBS -L$with_python/lib/python$PYTHON_VERSION/config -lpython$PYTHON_VERSION"
-    PYTHON_INCLUDES="$with_python/include/python$PYTHON_VERSION"
+  test -z "$ac_cv_path_nc_config" && ac_cv_path_nc_config="no"
+  ;;
+esac
+fi
+nc_config=$ac_cv_path_nc_config
+if test -n "$nc_config"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $nc_config" >&5
+$as_echo "$nc_config" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+
+  if test "x$nc_config" != "xno"; then
+    LIBS="$LIBS `$nc_config --libs`"
+    INCLUDES="$INCLUDES `$nc_config --cflags`"
+    ncdfincdir="`$nc_config --prefix`/include"
   else
-    LIBS="$LIBS -lpython$PYTHON_VERSION"
-    PYTHON_INCLUDES="/usr/include/python$PYTHON_VERSION"
+    if test "x$with_netcdf" != "xyes"; then
+	LIBS="$LIBS -L$with_netcdf/lib -lnetcdf"
+	ncdfincdir="$with_netcdf/include"
+    else
+	LIBS="$LIBS -L/usr/lib/netcdf-3 -lnetcdf"
+        ncdfincdir="/usr/include/netcdf-3"
+    fi
+    INCLUDES="$INCLUDES -I$ncdfincdir"
   fi
-  INCLUDES="$INCLUDES -I$PYTHON_INCLUDES"
 
-  as_ac_Lib=`$as_echo "ac_cv_lib_python$PYTHON_VERSION''_Py_Initialize" | $as_tr_sh`
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Py_Initialize in -lpython$PYTHON_VERSION" >&5
-$as_echo_n "checking for Py_Initialize in -lpython$PYTHON_VERSION... " >&6; }
-if { as_var=$as_ac_Lib; eval "test \"\${$as_var+set}\" = set"; }; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for nc_open in -lnetcdf" >&5
+$as_echo_n "checking for nc_open in -lnetcdf... " >&6; }
+if test "${ac_cv_lib_netcdf_nc_open+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lpython$PYTHON_VERSION  $LIBS"
+LIBS="-lnetcdf  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -16843,107 +20337,117 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char Py_Initialize ();
+char nc_open ();
 int
 main ()
 {
-return Py_Initialize ();
+return nc_open ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_cxx_try_link "$LINENO"; then :
-  eval "$as_ac_Lib=yes"
+  ac_cv_lib_netcdf_nc_open=yes
 else
-  eval "$as_ac_Lib=no"
+  ac_cv_lib_netcdf_nc_open=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-eval ac_res=\$$as_ac_Lib
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-eval as_val=\$$as_ac_Lib
-   if test "x$as_val" = x""yes; then :
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_netcdf_nc_open" >&5
+$as_echo "$ac_cv_lib_netcdf_nc_open" >&6; }
+if test "x$ac_cv_lib_netcdf_nc_open" = x""yes; then :
 
-$as_echo "#define USE_PYTHON 1" >>confdefs.h
+$as_echo "#define USE_NETCDF 1" >>confdefs.h
 
 else
 
-
     echo ""
-    echo "Error! Python version $PYTHON_VERSION is required but was not found"
-    echo "       Use --with-python=DIR to specify the python directory tree"
-    echo "       Use --with-python=no  to not use it"
+    echo "Error! netCDF version 3.5.1 or later is required but was not found"
+    echo "       Use --with-netcdf=DIR to specify the netcdf directory tree"
+    echo "       Use --with-netcdf=no  to not use it"
+    echo "       Check the README or use configure --help for other libraries needed"
+    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
     exit -1
 
 fi
 
 
-  as_ac_Header=`$as_echo "ac_cv_header_$PYTHON_INCLUDES/Python.h" | $as_tr_sh`
-ac_fn_cxx_check_header_mongrel "$LINENO" "$PYTHON_INCLUDES/Python.h" "$as_ac_Header" "$ac_includes_default"
+  for ac_header in "netcdfcpp.h"
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
 eval as_val=\$$as_ac_Header
    if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
 
 else
 
-    echo ""
-    echo "Error! Python header file not found (missing '-devel' package?)"
-    echo "  Use --with-python=no to disable Python support"
-    exit -1
-
-fi
-
-
-
-  OLDCXXFLAGS=$CXXFLAGS
-  CXXFLAGS="$CXXFLAGS -I$PYTHON_INCLUDES"
-  as_ac_Header=`$as_echo "ac_cv_header_$PYTHON_INCLUDES/numarray/libnumarray.h" | $as_tr_sh`
-ac_fn_cxx_check_header_compile "$LINENO" "$PYTHON_INCLUDES/numarray/libnumarray.h" "$as_ac_Header" "#include <Python.h>
-"
+    for ac_header in "$ncdfincdir/netcdfcpp.h"
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
 eval as_val=\$$as_ac_Header
    if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
 
 else
 
-    echo ""
-    echo "Error! Python numarray package was not found"
-    echo "  Use --with-python=no to disable Python support"
-    exit -1
+      echo ""
+      echo "Error! netCDF installation seems not to be usable"
+      echo "       This suggests a conflicting netCDF-HDF4 installation, e.g."
+      echo "       - uninstalling HDF4 after installation of netCDF"
+      echo "       - installing netCDF before HDF4"
+      exit -1
 
 fi
 
+done
 
-  CXXFLAGS=$OLDCXXFLAGS
-  unset OLDCXXFLAGS
 
 fi
 
+done
 
 
-# Check whether --with-udunits was given.
-if test "${with_udunits+set}" = set; then :
-  withval=$with_udunits; with_udunits="$withval"
 fi
 
 
-if test "x$with_udunits" != "xno"; then
-  if test "x$with_udunits" != "xyes"; then
-    LIBS="$LIBS -L$with_udunits/lib -ludunits2"
-    INCLUDES="$INCLUDES -I$with_udunits/include"
-  else
-    INCLUDES="$INCLUDES -I/usr/include"
-    LIBS="$LIBS -ludunits2"
-  fi
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_get_unit_by_name in -ludunits2" >&5
-$as_echo_n "checking for ut_get_unit_by_name in -ludunits2... " >&6; }
-if test "${ac_cv_lib_udunits2_ut_get_unit_by_name+set}" = set; then :
+# Check whether --with-hdf was given.
+if test "${with_hdf+set}" = set; then :
+  withval=$with_hdf; with_hdf="$withval"
+fi
+
+
+if test "x$with_hdf" != "xno"; then
+
+  # on Debian the no-netcdf flavour of HDF4 libraries has an alt-suffixed naming
+  _LIBS=$LIBS
+  _INCLUDES=$INCLUDES
+  for sfx in "dfalt" "df"; do
+
+    if test "x$with_hdf" != "xyes"; then
+      LIBS="$_LIBS -L$with_hdf/lib -L$with_hdf/lib/hdf -lmfh$sfx -l$sfx -ljpeg -lz"
+      INCLUDES="$_INCLUDES -I$with_hdf/include -I$with_hdf/include/hdf"
+    else
+      LIBS="$_LIBS -L/usr/lib/hdf -lmfh$sfx -l$sfx -ljpeg -lz"
+      INCLUDES="$_INCLUDES -I/usr/include/hdf"
+    fi
+
+    as_ac_Lib=`$as_echo "ac_cv_lib_$sfx''_Hopen" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Hopen in -l$sfx" >&5
+$as_echo_n "checking for Hopen in -l$sfx... " >&6; }
+if { as_var=$as_ac_Lib; eval "test \"\${$as_var+set}\" = set"; }; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-ludunits2  $LIBS"
+LIBS="-l$sfx  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -16953,69 +20457,44 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char ut_get_unit_by_name ();
+char Hopen ();
 int
 main ()
 {
-return ut_get_unit_by_name ();
+return Hopen ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_udunits2_ut_get_unit_by_name=yes
+  eval "$as_ac_Lib=yes"
 else
-  ac_cv_lib_udunits2_ut_get_unit_by_name=no
+  eval "$as_ac_Lib=no"
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_udunits2_ut_get_unit_by_name" >&5
-$as_echo "$ac_cv_lib_udunits2_ut_get_unit_by_name" >&6; }
-if test "x$ac_cv_lib_udunits2_ut_get_unit_by_name" = x""yes; then :
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+eval as_val=\$$as_ac_Lib
+   if test "x$as_val" = x""yes; then :
 
-$as_echo "#define USE_UDUNITS 1" >>confdefs.h
+$as_echo "#define USE_HDF 1" >>confdefs.h
 
 else
-
-    echo ""
-    echo "Error! UDUNITS-2 is required but was not found"
-    echo "       Use --with-udunits=DIR to specify the UDUNITS-2 directory tree"
-    echo "       Use --with-udunits=no  to not use it"
-    echo "       Check the README or use configure --help for other libraries needed"
-    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-    exit -1
-
-fi
-
-fi
-
-
-
-
-# Check whether --with-grib was given.
-if test "${with_grib+set}" = set; then :
-  withval=$with_grib; with_grib="$withval"
-fi
-
-
-if test "x$with_grib" != "xno"; then
-  if test "x$with_grib" != "xyes"; then
-    LIBS="$LIBS -L$with_grib/lib -lgrib_api"
-    INCLUDES="$INCLUDES -I$with_grib/include"
-  else
-    INCLUDES="$INCLUDES -I/usr/include"
-    LIBS="$LIBS -lgrib_api"
-  fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for grib_handle_new_from_file in -lgrib_api" >&5
-$as_echo_n "checking for grib_handle_new_from_file in -lgrib_api... " >&6; }
-if test "${ac_cv_lib_grib_api_grib_handle_new_from_file+set}" = set; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if linking with SZIP helps" >&5
+$as_echo_n "checking if linking with SZIP helps... " >&6; }
+      echo ""
+      as_ac_Lib=`$as_echo "ac_cv_lib_$sfx''_Hclose" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Hclose in -l$sfx" >&5
+$as_echo_n "checking for Hclose in -l$sfx... " >&6; }
+if { as_var=$as_ac_Lib; eval "test \"\${$as_var+set}\" = set"; }; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lgrib_api  $LIBS"
+LIBS="-l$sfx -lsz $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -17025,41 +20504,63 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char grib_handle_new_from_file ();
+char Hclose ();
 int
 main ()
 {
-return grib_handle_new_from_file ();
+return Hclose ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_grib_api_grib_handle_new_from_file=yes
+  eval "$as_ac_Lib=yes"
 else
-  ac_cv_lib_grib_api_grib_handle_new_from_file=no
+  eval "$as_ac_Lib=no"
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_grib_api_grib_handle_new_from_file" >&5
-$as_echo "$ac_cv_lib_grib_api_grib_handle_new_from_file" >&6; }
-if test "x$ac_cv_lib_grib_api_grib_handle_new_from_file" = x""yes; then :
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+eval as_val=\$$as_ac_Lib
+   if test "x$as_val" = x""yes; then :
+
+        LIBS="$LIBS -lsz"
+
+$as_echo "#define USE_HDF 1" >>confdefs.h
 
-$as_echo "#define USE_GRIB 1" >>confdefs.h
 
 else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if linking with Jasper helps" >&5
-$as_echo_n "checking if linking with Jasper helps... " >&6; }
-    echo ""
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for grib_handle_clone in -lgrib_api" >&5
-$as_echo_n "checking for grib_handle_clone in -lgrib_api... " >&6; }
-if test "${ac_cv_lib_grib_api_grib_handle_clone+set}" = set; then :
+
+        if test $sfx != "dfalt"; then
+          echo ""
+          echo "Error! HDF4 libraries were not found"
+          echo "       Use --with-hdf=DIR to specify the HDF directory tree"
+          echo "       Use --with-hdf=no  to not use it"
+          echo "       Check the README or use configure --help for other libraries needed"
+          echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
+          exit -1
+        else
+          continue # switchng to non-alt-suffixed naming
+        fi
+
+fi
+
+
+fi
+
+
+    as_ac_Lib=`$as_echo "ac_cv_lib_mfh$sfx''_SDstart" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for SDstart in -lmfh$sfx" >&5
+$as_echo_n "checking for SDstart in -lmfh$sfx... " >&6; }
+if { as_var=$as_ac_Lib; eval "test \"\${$as_var+set}\" = set"; }; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lgrib_api -ljasper $LIBS"
+LIBS="-lmfh$sfx  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -17069,39 +20570,38 @@
 #ifdef __cplusplus
 extern "C"
 #endif
-char grib_handle_clone ();
+char SDstart ();
 int
 main ()
 {
-return grib_handle_clone ();
+return SDstart ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_grib_api_grib_handle_clone=yes
+  eval "$as_ac_Lib=yes"
 else
-  ac_cv_lib_grib_api_grib_handle_clone=no
+  eval "$as_ac_Lib=no"
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_grib_api_grib_handle_clone" >&5
-$as_echo "$ac_cv_lib_grib_api_grib_handle_clone" >&6; }
-if test "x$ac_cv_lib_grib_api_grib_handle_clone" = x""yes; then :
-
-      LIBS="$LIBS -ljasper"
-
-$as_echo "#define USE_GRIB 1" >>confdefs.h
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+eval as_val=\$$as_ac_Lib
+   if test "x$as_val" = x""yes; then :
 
+$as_echo "#define USE_HDF 1" >>confdefs.h
 
 else
 
       echo ""
-      echo "Error! GRIB is required but was not found"
-      echo "       Use --with-grib=DIR to specify the GRIB directory tree"
-      echo "       Use --with-grib=no  to not use it"
+      echo "Error! HDF4 libraries were not found"
+      echo "       Use --with-hdf=DIR to specify the HDF directory tree"
+      echo "       Use --with-hdf=no  to not use it"
       echo "       Check the README or use configure --help for other libraries needed"
       echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
       exit -1
@@ -17109,2721 +20609,2806 @@
 fi
 
 
-fi
-
-
-fi
-
-
-
-
-
-  prefix_NONE=
-  exec_prefix_NONE=
-  test "x$prefix" = xNONE && prefix_NONE=yes && prefix=$ac_default_prefix
-  test "x$exec_prefix" = xNONE && exec_prefix_NONE=yes && exec_prefix=$prefix
-  eval ac_define_dir="\"$exec_prefix\""
-  eval ac_define_dir="\"$ac_define_dir\""
-  EXEC_PREFIX="$ac_define_dir"
-
-
-cat >>confdefs.h <<_ACEOF
-#define EXEC_PREFIX "$ac_define_dir"
-_ACEOF
-
-  test "$prefix_NONE" && prefix=NONE
-  test "$exec_prefix_NONE" && exec_prefix=NONE
-
-#AC_DEFINE([EXEC_PREFIX],[\"`echo ${exec_prefix}`\"],[GDL installation directory])
-
-  prefix_NONE=
-  exec_prefix_NONE=
-  test "x$prefix" = xNONE && prefix_NONE=yes && prefix=$ac_default_prefix
-  test "x$exec_prefix" = xNONE && exec_prefix_NONE=yes && exec_prefix=$prefix
-  eval ac_define_dir="\"$datadir/$datasubdir\""
-  eval ac_define_dir="\"$ac_define_dir\""
-  GDLDATADIR="$ac_define_dir"
-
-
-cat >>confdefs.h <<_ACEOF
-#define GDLDATADIR "$ac_define_dir"
-_ACEOF
-
-  test "$prefix_NONE" && prefix=NONE
-  test "$exec_prefix_NONE" && exec_prefix=NONE
-
-
-
-DARWIN="no"
-
-case "${host}" in
-  powerpc-*-darwin* )
-        LDFLAGS="$LDFLAGS -bind_at_load"
-    DARWIN="yes"
-        ;;
-
-  powerpc*-*-linux* )
-    LDFLAGS="$LDFLAGS -rdynamic"
-    ;;
-
-  *linux*)
-                    LDFLAGS="$LDFLAGS -rdynamic -z muldefs"
-    ;;
-
-  *solaris* )
-    LIBS="$LIBS -lsocket -lnsl"
-    ;;
-
-esac
-
-case "${host}" in
-
-  *darwin6*)
-
-$as_echo "#define OLD_DARWIN 1" >>confdefs.h
-
-    ;;
-  *darwin7*)
-
-$as_echo "#define OLD_DARWIN 1" >>confdefs.h
-
-    ;;
-  *darwin8.8*)
-        ;;
-  *darwin8.9*)
-        ;;
-  *darwin8.10*)
-        ;;
-  *darwin8.11*)
-        ;;
-  *darwin8.12*)
-        ;;
-  *darwin8.13*)
-        ;;
-  *darwin8.14*)
-        ;;
-  *darwin8.15*)
-        ;;
-  *darwin9*)
-        ;;
-  *darwin8*)
+    # checking if HDF4 was compiled with the '--disable-netcdf' option
+    if test "x$with_netcdf" != "xno"; then
+      as_ac_Lib=`$as_echo "ac_cv_lib_mfh$sfx''_sd_nccreate" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sd_nccreate in -lmfh$sfx" >&5
+$as_echo_n "checking for sd_nccreate in -lmfh$sfx... " >&6; }
+if { as_var=$as_ac_Lib; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lmfh$sfx  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-$as_echo "#define OLD_DARWIN 1" >>confdefs.h
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char sd_nccreate ();
+int
+main ()
+{
+return sd_nccreate ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  eval "$as_ac_Lib=yes"
+else
+  eval "$as_ac_Lib=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+eval as_val=\$$as_ac_Lib
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_LIBmfh$sfx" | $as_tr_cpp` 1
+_ACEOF
 
-    ;;
-esac
+  LIBS="-lmfh$sfx $LIBS"
 
- if test "x$DARWIN" = "xyes"; then
-  DARWIN_TRUE=
-  DARWIN_FALSE='#'
 else
-  DARWIN_TRUE='#'
-  DARWIN_FALSE=
-fi
 
+        echo ""
+        echo "Error! HDF4 needs to be configured with the --disable-netcdf option"
+        echo "       in order to be used with the original netCDF library"
+        echo "       (-alt suffixed HDF4 packages in case of Debian)"
+        echo "       Check the INSTALL file of the HDF4 package for details"
+        exit -1
 
+fi
 
-EXT_LIBS="$EXT_LIBS $LIBS"
-EXT_INCLUDES="$EXT_INCLUDES $INCLUDES"
+    fi
 
+    # all went OK with the alt-suffixed naming -> skipping tests for the non-alt-suffixed naming
+    if test $sfx == "dfalt"; then break; fi
 
+  done
+fi
 
 
 
+# Check whether --with-hdf5 was given.
+if test "${with_hdf5+set}" = set; then :
+  withval=$with_hdf5; with_hdf5="$withval"
+fi
 
-case ${INSTALL} in
-  /* ) # Absolute
-     ;;
-  ?:* ) # Drive letter, considered as absolute.
-     ;;
-  *)
-     INSTALL=`pwd`/${INSTALL} ;;
-esac
 
-case "${host}" in
+if test "x$with_hdf5" != "xno"; then
+  if test "x$with_hdf5" != "xyes"; then
+    LIBS="$LIBS -L$with_hdf5/lib -L$with_hdf5/lib/hdf -L$with_hdf5/lib/hdf5 -lhdf5"
+    INCLUDES="$INCLUDES -I$with_hdf5/include -I$with_hdf5/include/hdf -I$with_hdf5/include/hdf5"
+  else
+    INCLUDES="$INCLUDES -I/usr/include/hdf -I/usr/include/hdf5"
+    LIBS="$LIBS -L/usr/lib/hdf -L/usr/lib/hdf5 -lhdf5"
+  fi
 
-                *-*-darwin* )
-        INSTALL_PROGRAM="cp -fp"
-        INSTALL_DATA="cp -fp"
-        ;;
-    *)
-        ;;
-esac
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for H5Fopen in -lhdf5" >&5
+$as_echo_n "checking for H5Fopen in -lhdf5... " >&6; }
+if test "${ac_cv_lib_hdf5_H5Fopen+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lhdf5  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char H5Fopen ();
+int
+main ()
+{
+return H5Fopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_hdf5_H5Fopen=yes
+else
+  ac_cv_lib_hdf5_H5Fopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_hdf5_H5Fopen" >&5
+$as_echo "$ac_cv_lib_hdf5_H5Fopen" >&6; }
+if test "x$ac_cv_lib_hdf5_H5Fopen" = x""yes; then :
 
+$as_echo "#define USE_HDF5 1" >>confdefs.h
 
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if linking with SZIP helps" >&5
+$as_echo_n "checking if linking with SZIP helps... " >&6; }
+    echo ""
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for H5Fclose in -lhdf5" >&5
+$as_echo_n "checking for H5Fclose in -lhdf5... " >&6; }
+if test "${ac_cv_lib_hdf5_H5Fclose+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lhdf5 -lsz $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char H5Fclose ();
+int
+main ()
+{
+return H5Fclose ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_hdf5_H5Fclose=yes
+else
+  ac_cv_lib_hdf5_H5Fclose=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_hdf5_H5Fclose" >&5
+$as_echo "$ac_cv_lib_hdf5_H5Fclose" >&6; }
+if test "x$ac_cv_lib_hdf5_H5Fclose" = x""yes; then :
 
+      LIBS="$LIBS -lsz"
 
-ac_config_files="$ac_config_files Makefile src/Makefile src/antlr/Makefile src/pro/Makefile src/pro/dicom/Makefile testsuite/Makefile doc/Makefile"
+$as_echo "#define USE_HDF5 1" >>confdefs.h
 
-cat >confcache <<\_ACEOF
-# This file is a shell script that caches the results of configure
-# tests run on this system so they can be shared between configure
-# scripts and configure runs, see configure's option --config-cache.
-# It is not useful on other systems.  If it contains results you don't
-# want to keep, you may remove or edit it.
-#
-# config.status only pays attention to the cache file if you give it
-# the --recheck option to rerun configure.
-#
-# `ac_cv_env_foo' variables (set or unset) will be overridden when
-# loading this file, other *unset* `ac_cv_foo' will be assigned the
-# following values.
 
-_ACEOF
+else
 
-# The following way of writing the cache mishandles newlines in values,
-# but we know of no workaround that is simple, portable, and efficient.
-# So, we kill variables containing newlines.
-# Ultrix sh set writes to stderr and can't be redirected directly,
-# and sets the high bit in the cache file unless we assign to the vars.
-(
-  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
-    eval ac_val=\$$ac_var
-    case $ac_val in #(
-    *${as_nl}*)
-      case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
-$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
-      esac
-      case $ac_var in #(
-      _ | IFS | as_nl) ;; #(
-      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
-      *) { eval $ac_var=; unset $ac_var;} ;;
-      esac ;;
-    esac
-  done
+    echo ""
+    echo "Error! HDF version 5 is required but was not found"
+    echo "       Use --with-hdf5=DIR to specify the HDF5 directory tree"
+    echo "       Use --with-hdf5=no  to not use it"
+    echo "       Check the README or use configure --help for other libraries needed"
+    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
+    exit -1
 
-  (set) 2>&1 |
-    case $as_nl`(ac_space=' '; set) 2>&1` in #(
-    *${as_nl}ac_space=\ *)
-      # `set' does not quote correctly, so add quotes: double-quote
-      # substitution turns \\\\ into \\, and sed turns \\ into \.
-      sed -n \
-	"s/'/'\\\\''/g;
-	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
-      ;; #(
-    *)
-      # `set' quotes correctly as required by POSIX, so do not add quotes.
-      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
-      ;;
-    esac |
-    sort
-) |
-  sed '
-     /^ac_cv_env_/b end
-     t clear
-     :clear
-     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
-     t end
-     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
-     :end' >>confcache
-if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
-  if test -w "$cache_file"; then
-    test "x$cache_file" != "x/dev/null" &&
-      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
-$as_echo "$as_me: updating cache $cache_file" >&6;}
-    cat confcache >$cache_file
-  else
-    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
-$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
-  fi
 fi
-rm -f confcache
-
-test "x$prefix" = xNONE && prefix=$ac_default_prefix
-# Let make expand exec_prefix.
-test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
 
-DEFS=-DHAVE_CONFIG_H
+fi
 
-ac_libobjs=
-ac_ltlibobjs=
-for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
-  # 1. Remove the extension, and $U if already installed.
-  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
-  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
-  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
-  #    will be set to the directory where LIBOBJS objects are built.
-  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
-  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
-done
-LIBOBJS=$ac_libobjs
+fi
 
-LTLIBOBJS=$ac_ltlibobjs
 
+if test "x$with_fftw" = "xauto"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fftw_malloc in -lfftw3" >&5
+$as_echo_n "checking for fftw_malloc in -lfftw3... " >&6; }
+if test "${ac_cv_lib_fftw3_fftw_malloc+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lfftw3  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
- if test -n "$EXEEXT"; then
-  am__EXEEXT_TRUE=
-  am__EXEEXT_FALSE='#'
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char fftw_malloc ();
+int
+main ()
+{
+return fftw_malloc ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_fftw3_fftw_malloc=yes
 else
-  am__EXEEXT_TRUE='#'
-  am__EXEEXT_FALSE=
+  ac_cv_lib_fftw3_fftw_malloc=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_fftw3_fftw_malloc" >&5
+$as_echo "$ac_cv_lib_fftw3_fftw_malloc" >&6; }
+if test "x$ac_cv_lib_fftw3_fftw_malloc" = x""yes; then :
 
-if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
-  as_fn_error "conditional \"AMDEP\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fftwf_malloc in -lfftw3f" >&5
+$as_echo_n "checking for fftwf_malloc in -lfftw3f... " >&6; }
+if test "${ac_cv_lib_fftw3f_fftwf_malloc+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lfftw3f  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char fftwf_malloc ();
+int
+main ()
+{
+return fftwf_malloc ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_fftw3f_fftwf_malloc=yes
+else
+  ac_cv_lib_fftw3f_fftwf_malloc=no
 fi
-if test -z "${am__fastdepCXX_TRUE}" && test -z "${am__fastdepCXX_FALSE}"; then
-  as_fn_error "conditional \"am__fastdepCXX\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
-if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
-  as_fn_error "conditional \"am__fastdepCC\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_fftw3f_fftwf_malloc" >&5
+$as_echo "$ac_cv_lib_fftw3f_fftwf_malloc" >&6; }
+if test "x$ac_cv_lib_fftw3f_fftwf_malloc" = x""yes; then :
+  with_fftw=yes
+else
+  with_fftw=no
 fi
-if test -z "${am__fastdepCXX_TRUE}" && test -z "${am__fastdepCXX_FALSE}"; then
-  as_fn_error "conditional \"am__fastdepCXX\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
+
+
+else
+  with_fftw=no
 fi
-if test -z "${BUILDASLIBRARY_TRUE}" && test -z "${BUILDASLIBRARY_FALSE}"; then
-  as_fn_error "conditional \"BUILDASLIBRARY\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
+
 fi
-if test -z "${DARWIN_TRUE}" && test -z "${DARWIN_FALSE}"; then
-  as_fn_error "conditional \"DARWIN\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
+
+
+# Check whether --with-fftw was given.
+if test "${with_fftw+set}" = set; then :
+  withval=$with_fftw; with_fftw="$withval"
 fi
 
-: ${CONFIG_STATUS=./config.status}
-ac_write_fail=0
-ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files $CONFIG_STATUS"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
-$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
-as_write_fail=0
-cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
-#! $SHELL
-# Generated by $as_me.
-# Run this file to recreate the current configuration.
-# Compiler output produced by configure, useful for debugging
-# configure, is in config.log if it exists.
 
-debug=false
-ac_cs_recheck=false
-ac_cs_silent=false
+if test "x$with_fftw" != "xno"; then
+  if test "x$with_fftw" != "xyes"; then
+    LIBS="$LIBS -L$with_fftw/lib -lfftw3"
+    INCLUDES="$INCLUDES -I$with_fftw/include"
+  else
+    INCLUDES="$INCLUDES -I/usr/include"
+    LIBS="$LIBS -lfftw3"
+  fi
 
-SHELL=\${CONFIG_SHELL-$SHELL}
-export SHELL
-_ASEOF
-cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
-## -------------------- ##
-## M4sh Initialization. ##
-## -------------------- ##
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fftw_malloc in -lfftw3" >&5
+$as_echo_n "checking for fftw_malloc in -lfftw3... " >&6; }
+if test "${ac_cv_lib_fftw3_fftw_malloc+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lfftw3  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-# Be more Bourne compatible
-DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char fftw_malloc ();
+int
+main ()
+{
+return fftw_malloc ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_fftw3_fftw_malloc=yes
 else
-  case `(set -o) 2>/dev/null` in #(
-  *posix*) :
-    set -o posix ;; #(
-  *) :
-     ;;
-esac
+  ac_cv_lib_fftw3_fftw_malloc=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_fftw3_fftw_malloc" >&5
+$as_echo "$ac_cv_lib_fftw3_fftw_malloc" >&6; }
+if test "x$ac_cv_lib_fftw3_fftw_malloc" = x""yes; then :
 
+$as_echo "#define USE_FFTW 1" >>confdefs.h
 
-as_nl='
-'
-export as_nl
-# Printing a long string crashes Solaris 7 /usr/bin/printf.
-as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-# Prefer a ksh shell builtin over an external printf program on Solaris,
-# but without wasting forks for bash or zsh.
-if test -z "$BASH_VERSION$ZSH_VERSION" \
-    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='print -r --'
-  as_echo_n='print -rn --'
-elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='printf %s\n'
-  as_echo_n='printf %s'
 else
-  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
-    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
-    as_echo_n='/usr/ucb/echo -n'
+
+    echo ""
+    echo "Error! FFTW3 version 3 is required but was not found"
+    echo "       Use --with-fftw=DIR to specify the FFTW directory tree"
+    echo "       Use --with-fftw=no  to not use it"
+    echo "       Check the README or use configure --help for other libraries needed"
+    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
+    exit -1
+
+fi
+
+fi
+
+if test "x$with_fftw" != "xno"; then
+  if test "x$with_fftw" != "xyes"; then
+    LIBS="$LIBS -L$with_fftw/lib -lfftw3f"
+    INCLUDES="$INCLUDES -I$with_fftw/include"
   else
-    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
-    as_echo_n_body='eval
-      arg=$1;
-      case $arg in #(
-      *"$as_nl"*)
-	expr "X$arg" : "X\\(.*\\)$as_nl";
-	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
-      esac;
-      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
-    '
-    export as_echo_n_body
-    as_echo_n='sh -c $as_echo_n_body as_echo'
+    INCLUDES="$INCLUDES -I/usr/include"
+    LIBS="$LIBS -lfftw3f"
   fi
-  export as_echo_body
-  as_echo='sh -c $as_echo_body as_echo'
-fi
 
-# The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
-  PATH_SEPARATOR=:
-  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
-    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
-      PATH_SEPARATOR=';'
-  }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fftwf_malloc in -lfftw3f" >&5
+$as_echo_n "checking for fftwf_malloc in -lfftw3f... " >&6; }
+if test "${ac_cv_lib_fftw3f_fftwf_malloc+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lfftw3f  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char fftwf_malloc ();
+int
+main ()
+{
+return fftwf_malloc ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_fftw3f_fftwf_malloc=yes
+else
+  ac_cv_lib_fftw3f_fftwf_malloc=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_fftw3f_fftwf_malloc" >&5
+$as_echo "$ac_cv_lib_fftw3f_fftwf_malloc" >&6; }
+if test "x$ac_cv_lib_fftw3f_fftwf_malloc" = x""yes; then :
 
+$as_echo "#define USE_FFTW 1" >>confdefs.h
 
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-IFS=" ""	$as_nl"
+else
 
-# Find who we are.  Look in the path if we contain no directory separator.
-case $0 in #((
-  *[\\/]* ) as_myself=$0 ;;
-  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-  done
-IFS=$as_save_IFS
+    echo ""
+    echo "Error! FFTW3F version 3 is required but was not found"
+    echo "       Use --with-fftw=DIR to specify the FFTW directory tree"
+    echo "       Use --with-fftw=no  to not use it"
+    echo "       Check the README or use configure --help for other libraries needed"
+    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
+    exit -1
 
-     ;;
-esac
-# We did not find ourselves, most probably we were run as `sh COMMAND'
-# in which case we are not to be found in the path.
-if test "x$as_myself" = x; then
-  as_myself=$0
 fi
-if test ! -f "$as_myself"; then
-  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  exit 1
+
 fi
 
-# Unset variables that we do not need and which cause bugs (e.g. in
-# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
-# suppresses any "Segmentation fault" message there.  '((' could
-# trigger a bug in pdksh 5.2.14.
-for as_var in BASH_ENV ENV MAIL MAILPATH
-do eval test x\${$as_var+set} = xset \
-  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
-done
-PS1='$ '
-PS2='> '
-PS4='+ '
 
-# NLS nuisances.
-LC_ALL=C
-export LC_ALL
-LANGUAGE=C
-export LANGUAGE
 
-# CDPATH.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+# Check whether --with-libproj4 was given.
+if test "${with_libproj4+set}" = set; then :
+  withval=$with_libproj4; with_libproj4="$withval"
+fi
 
 
-# as_fn_error ERROR [LINENO LOG_FD]
-# ---------------------------------
-# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
-# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with status $?, using 1 if that was 0.
-as_fn_error ()
-{
-  as_status=$?; test $as_status -eq 0 && as_status=1
-  if test "$3"; then
-    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+if test "x$with_libproj4" != "xno"; then
+  if test "x$with_libproj4" != "xyes"; then
+    LIBS="$LIBS -L$with_libproj4/lib -lproj4"
+    INCLUDES="$INCLUDES -I$with_libproj4/include"
+  else
+    INCLUDES="$INCLUDES -I/usr/include"
+    LIBS="$LIBS -lproj4"
   fi
-  $as_echo "$as_me: error: $1" >&2
-  as_fn_exit $as_status
-} # as_fn_error
 
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for proj_init in -lproj4" >&5
+$as_echo_n "checking for proj_init in -lproj4... " >&6; }
+if test "${ac_cv_lib_proj4_proj_init+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lproj4  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-# as_fn_set_status STATUS
-# -----------------------
-# Set $? to STATUS, without forking.
-as_fn_set_status ()
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char proj_init ();
+int
+main ()
 {
-  return $1
-} # as_fn_set_status
+return proj_init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_proj4_proj_init=yes
+else
+  ac_cv_lib_proj4_proj_init=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_proj4_proj_init" >&5
+$as_echo "$ac_cv_lib_proj4_proj_init" >&6; }
+if test "x$ac_cv_lib_proj4_proj_init" = x""yes; then :
 
-# as_fn_exit STATUS
-# -----------------
-# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
-as_fn_exit ()
-{
-  set +e
-  as_fn_set_status $1
-  exit $1
-} # as_fn_exit
+$as_echo "#define USE_LIBPROJ4 1" >>confdefs.h
 
-# as_fn_unset VAR
-# ---------------
-# Portably unset VAR.
-as_fn_unset ()
+fi
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for proj_init in -lproj4" >&5
+$as_echo_n "checking for proj_init in -lproj4... " >&6; }
+if test "${ac_cv_lib_proj4_proj_init+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lproj4  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char proj_init ();
+int
+main ()
 {
-  { eval $1=; unset $1;}
+return proj_init ();
+  ;
+  return 0;
 }
-as_unset=as_fn_unset
-# as_fn_append VAR VALUE
-# ----------------------
-# Append the text in VALUE to the end of the definition contained in VAR. Take
-# advantage of any shell optimizations that allow amortized linear growth over
-# repeated appends, instead of the typical quadratic growth present in naive
-# implementations.
-if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
-  eval 'as_fn_append ()
-  {
-    eval $1+=\$2
-  }'
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_proj4_proj_init=yes
 else
-  as_fn_append ()
-  {
-    eval $1=\$$1\$2
-  }
-fi # as_fn_append
+  ac_cv_lib_proj4_proj_init=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_proj4_proj_init" >&5
+$as_echo "$ac_cv_lib_proj4_proj_init" >&6; }
+if test "x$ac_cv_lib_proj4_proj_init" = x""yes; then :
+
+$as_echo "#define USE_LIBPROJ4_NEW 1" >>confdefs.h
 
-# as_fn_arith ARG...
-# ------------------
-# Perform arithmetic evaluation on the ARGs, and store the result in the
-# global $as_val. Take advantage of shells that can avoid forks. The arguments
-# must be portable across $(()) and expr.
-if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
-  eval 'as_fn_arith ()
-  {
-    as_val=$(( $* ))
-  }'
 else
-  as_fn_arith ()
-  {
-    as_val=`expr "$@" || test $? -eq 1`
-  }
-fi # as_fn_arith
 
 
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
+     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pj_init in -lproj4" >&5
+$as_echo_n "checking for pj_init in -lproj4... " >&6; }
+if test "${ac_cv_lib_proj4_pj_init+set}" = set; then :
+  $as_echo_n "(cached) " >&6
 else
-  as_expr=false
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lproj4  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char pj_init ();
+int
+main ()
+{
+return pj_init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_proj4_pj_init=yes
+else
+  ac_cv_lib_proj4_pj_init=no
 fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_proj4_pj_init" >&5
+$as_echo "$ac_cv_lib_proj4_pj_init" >&6; }
+if test "x$ac_cv_lib_proj4_pj_init" = x""yes; then :
+
+$as_echo "#define USE_LIBPROJ4 1" >>confdefs.h
 
-if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
-  as_basename=basename
 else
-  as_basename=false
+
+       echo ""
+       echo "Error! LIBPROJ4 is required but was not found"
+       echo "       Use --with-libproj4=DIR to specify the LIBPROJ4 directory tree"
+       echo "       Use --with-libproj4=no  to not use it"
+       echo "       Check the README or use configure --help for other libraries needed"
+       echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
+       exit -1
+
 fi
 
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
+
 fi
 
-as_me=`$as_basename -- "$0" ||
-$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X/"$0" |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
+fi
 
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
 
-ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in #(((((
--n*)
-  case `echo 'xy\c'` in
-  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  xy)  ECHO_C='\c';;
-  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
-       ECHO_T='	';;
-  esac;;
-*)
-  ECHO_N='-n';;
-esac
 
-rm -f conf$$ conf$$.exe conf$$.file
-if test -d conf$$.dir; then
-  rm -f conf$$.dir/conf$$.file
-else
-  rm -f conf$$.dir
-  mkdir conf$$.dir 2>/dev/null
+# Check whether --with-mpich was given.
+if test "${with_mpich+set}" = set; then :
+  withval=$with_mpich; with_mpich="$withval"
 fi
-if (echo >conf$$.file) 2>/dev/null; then
-  if ln -s conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s='ln -s'
-    # ... but there are two gotchas:
-    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
-    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
-    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
-  elif ln conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s=ln
+
+
+if test "x$with_mpich" != "xno"; then
+  if test "x$with_mpich" != "xyes"; then
+    LIBS="$LIBS -L$with_mpich/lib -lmpich"
+    INCLUDES="$INCLUDES -I$with_mpich/include"
   else
-    as_ln_s='cp -p'
+    INCLUDES="$INCLUDES -I/usr/include"
+    LIBS="$LIBS -lmpich"
   fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for MPI_Init in -lmpich" >&5
+$as_echo_n "checking for MPI_Init in -lmpich... " >&6; }
+if test "${ac_cv_lib_mpich_MPI_Init+set}" = set; then :
+  $as_echo_n "(cached) " >&6
 else
-  as_ln_s='cp -p'
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lmpich  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char MPI_Init ();
+int
+main ()
+{
+return MPI_Init ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_mpich_MPI_Init=yes
+else
+  ac_cv_lib_mpich_MPI_Init=no
 fi
-rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
-rmdir conf$$.dir 2>/dev/null
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_mpich_MPI_Init" >&5
+$as_echo "$ac_cv_lib_mpich_MPI_Init" >&6; }
+if test "x$ac_cv_lib_mpich_MPI_Init" = x""yes; then :
 
+$as_echo "#define USE_MPI 1" >>confdefs.h
 
-# as_fn_mkdir_p
-# -------------
-# Create "$as_dir" as a directory, including parents if necessary.
-as_fn_mkdir_p ()
-{
+else
 
-  case $as_dir in #(
-  -*) as_dir=./$as_dir;;
-  esac
-  test -d "$as_dir" || eval $as_mkdir_p || {
-    as_dirs=
-    while :; do
-      case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
-      *) as_qdir=$as_dir;;
-      esac
-      as_dirs="'$as_qdir' $as_dirs"
-      as_dir=`$as_dirname -- "$as_dir" ||
-$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_dir" : 'X\(//\)[^/]' \| \
-	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      test -d "$as_dir" && break
-    done
-    test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
+    echo ""
+    echo "Error! MPICH is required but was not found"
+    echo "       Use --with-mpich=DIR to specify the MPICH directory tree"
+    echo "       Use --with-mpich=no  to not use it"
+    echo "       Check the README or use configure --help for other libraries needed"
+    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
+    exit -1
 
+fi
 
-} # as_fn_mkdir_p
-if mkdir -p . 2>/dev/null; then
-  as_mkdir_p='mkdir -p "$as_dir"'
-else
-  test -d ./-p && rmdir ./-p
-  as_mkdir_p=false
 fi
 
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
+
+
+# Check whether --with-python was given.
+if test "${with_python+set}" = set; then :
+  withval=$with_python; with_python="$withval"
 fi
-as_executable_p=$as_test_x
 
-# Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
 
-# Sed expression to map a string onto a valid variable name.
-as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+if test "x$with_python" != "xno"; then
 
+    # Check whether --enable-python_version was given.
+if test "${enable_python_version+set}" = set; then :
+  enableval=$enable_python_version;  PYTHON_VERSION="$enableval"
 
-exec 6>&1
-## ----------------------------------- ##
-## Main body of $CONFIG_STATUS script. ##
-## ----------------------------------- ##
-_ASEOF
-test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
+fi
 
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-# Save the log message, to keep $0 and so on meaningful, and to
-# report actual input values of CONFIG_FILES etc. instead of their
-# values after options handling.
-ac_log="
-This file was extended by gdl $as_me 0.9rc4, which was
-generated by GNU Autoconf 2.65.  Invocation command line was
 
-  CONFIG_FILES    = $CONFIG_FILES
-  CONFIG_HEADERS  = $CONFIG_HEADERS
-  CONFIG_LINKS    = $CONFIG_LINKS
-  CONFIG_COMMANDS = $CONFIG_COMMANDS
-  $ $0 $@
+  if test "x$PYTHON_VERSION" = "x"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for Python version" >&5
+$as_echo_n "checking for Python version... " >&6; }
+    queryfile=$ac_confdir/query_version.py
+    echo "# tmp file auto (re)generated by GDL configure. Please delete" > $queryfile
+    echo import sys >> $queryfile
+    echo print \'%s.%s\' % sys.version_info\[0:2\] >> $queryfile
+    PYTHON_VERSION=`python $queryfile`
+    rm $queryfile
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PYTHON_VERSION" >&5
+$as_echo "$PYTHON_VERSION" >&6; }
+  fi
+
+  if test "x$with_python" != "xyes"; then
+    LIBS="$LIBS -L$with_python/lib"
+    LIBS="$LIBS -L$with_python/lib/python$PYTHON_VERSION/config -lpython$PYTHON_VERSION"
+    PYTHON_INCLUDES="$with_python/include/python$PYTHON_VERSION"
+  else
+    LIBS="$LIBS -lpython$PYTHON_VERSION"
+    PYTHON_INCLUDES="/usr/include/python$PYTHON_VERSION"
+  fi
+  INCLUDES="$INCLUDES -I$PYTHON_INCLUDES"
 
-on `(hostname || uname -n) 2>/dev/null | sed 1q`
-"
+  as_ac_Lib=`$as_echo "ac_cv_lib_python$PYTHON_VERSION''_Py_Initialize" | $as_tr_sh`
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Py_Initialize in -lpython$PYTHON_VERSION" >&5
+$as_echo_n "checking for Py_Initialize in -lpython$PYTHON_VERSION... " >&6; }
+if { as_var=$as_ac_Lib; eval "test \"\${$as_var+set}\" = set"; }; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpython$PYTHON_VERSION  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char Py_Initialize ();
+int
+main ()
+{
+return Py_Initialize ();
+  ;
+  return 0;
+}
 _ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  eval "$as_ac_Lib=yes"
+else
+  eval "$as_ac_Lib=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+eval ac_res=\$$as_ac_Lib
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+eval as_val=\$$as_ac_Lib
+   if test "x$as_val" = x""yes; then :
 
-case $ac_config_files in *"
-"*) set x $ac_config_files; shift; ac_config_files=$*;;
-esac
-
-case $ac_config_headers in *"
-"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
-esac
+$as_echo "#define USE_PYTHON 1" >>confdefs.h
 
+else
 
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-# Files that config.status was made for.
-config_files="$ac_config_files"
-config_headers="$ac_config_headers"
-config_commands="$ac_config_commands"
 
-_ACEOF
+    echo ""
+    echo "Error! Python version $PYTHON_VERSION is required but was not found"
+    echo "       Use --with-python=DIR to specify the python directory tree"
+    echo "       Use --with-python=no  to not use it"
+    exit -1
 
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-ac_cs_usage="\
-\`$as_me' instantiates files and other configuration actions
-from templates according to the current configuration.  Unless the files
-and actions are specified as TAGs, all are instantiated by default.
+fi
 
-Usage: $0 [OPTION]... [TAG]...
 
-  -h, --help       print this help, then exit
-  -V, --version    print version number and configuration settings, then exit
-      --config     print configuration, then exit
-  -q, --quiet, --silent
-                   do not print progress messages
-  -d, --debug      don't remove temporary files
-      --recheck    update $as_me by reconfiguring in the same conditions
-      --file=FILE[:TEMPLATE]
-                   instantiate the configuration file FILE
-      --header=FILE[:TEMPLATE]
-                   instantiate the configuration header FILE
+  as_ac_Header=`$as_echo "ac_cv_header_$PYTHON_INCLUDES/Python.h" | $as_tr_sh`
+ac_fn_cxx_check_header_mongrel "$LINENO" "$PYTHON_INCLUDES/Python.h" "$as_ac_Header" "$ac_includes_default"
+eval as_val=\$$as_ac_Header
+   if test "x$as_val" = x""yes; then :
 
-Configuration files:
-$config_files
+else
 
-Configuration headers:
-$config_headers
+    echo ""
+    echo "Error! Python header file not found (missing '-devel' package?)"
+    echo "  Use --with-python=no to disable Python support"
+    exit -1
 
-Configuration commands:
-$config_commands
+fi
 
-Report bugs to the package provider."
 
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
-ac_cs_version="\\
-gdl config.status 0.9rc4
-configured by $0, generated by GNU Autoconf 2.65,
-  with options \\"\$ac_cs_config\\"
 
-Copyright (C) 2009 Free Software Foundation, Inc.
-This config.status script is free software; the Free Software Foundation
-gives unlimited permission to copy, distribute and modify it."
+  OLDCXXFLAGS=$CXXFLAGS
+  CXXFLAGS="$CXXFLAGS -I$PYTHON_INCLUDES"
+  as_ac_Header=`$as_echo "ac_cv_header_$PYTHON_INCLUDES/numarray/libnumarray.h" | $as_tr_sh`
+ac_fn_cxx_check_header_compile "$LINENO" "$PYTHON_INCLUDES/numarray/libnumarray.h" "$as_ac_Header" "#include <Python.h>
+"
+eval as_val=\$$as_ac_Header
+   if test "x$as_val" = x""yes; then :
 
-ac_pwd='$ac_pwd'
-srcdir='$srcdir'
-INSTALL='$INSTALL'
-MKDIR_P='$MKDIR_P'
-AWK='$AWK'
-test -n "\$AWK" || AWK=awk
-_ACEOF
+else
 
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-# The default lists apply if the user does not specify any file.
-ac_need_defaults=:
-while test $# != 0
-do
-  case $1 in
-  --*=*)
-    ac_option=`expr "X$1" : 'X\([^=]*\)='`
-    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
-    ac_shift=:
-    ;;
-  *)
-    ac_option=$1
-    ac_optarg=$2
-    ac_shift=shift
-    ;;
-  esac
+    echo ""
+    echo "Error! Python numarray package was not found"
+    echo "  Use --with-python=no to disable Python support"
+    exit -1
 
-  case $ac_option in
-  # Handling of the options.
-  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
-    ac_cs_recheck=: ;;
-  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
-    $as_echo "$ac_cs_version"; exit ;;
-  --config | --confi | --conf | --con | --co | --c )
-    $as_echo "$ac_cs_config"; exit ;;
-  --debug | --debu | --deb | --de | --d | -d )
-    debug=: ;;
-  --file | --fil | --fi | --f )
-    $ac_shift
-    case $ac_optarg in
-    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    esac
-    as_fn_append CONFIG_FILES " '$ac_optarg'"
-    ac_need_defaults=false;;
-  --header | --heade | --head | --hea )
-    $ac_shift
-    case $ac_optarg in
-    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    esac
-    as_fn_append CONFIG_HEADERS " '$ac_optarg'"
-    ac_need_defaults=false;;
-  --he | --h)
-    # Conflict between --help and --header
-    as_fn_error "ambiguous option: \`$1'
-Try \`$0 --help' for more information.";;
-  --help | --hel | -h )
-    $as_echo "$ac_cs_usage"; exit ;;
-  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-  | -silent | --silent | --silen | --sile | --sil | --si | --s)
-    ac_cs_silent=: ;;
+fi
 
-  # This is an error.
-  -*) as_fn_error "unrecognized option: \`$1'
-Try \`$0 --help' for more information." ;;
 
-  *) as_fn_append ac_config_targets " $1"
-     ac_need_defaults=false ;;
+  CXXFLAGS=$OLDCXXFLAGS
+  unset OLDCXXFLAGS
 
-  esac
-  shift
-done
+fi
 
-ac_configure_extra_args=
 
-if $ac_cs_silent; then
-  exec 6>/dev/null
-  ac_configure_extra_args="$ac_configure_extra_args --silent"
-fi
 
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-if \$ac_cs_recheck; then
-  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
-  shift
-  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
-  CONFIG_SHELL='$SHELL'
-  export CONFIG_SHELL
-  exec "\$@"
+# Check whether --with-udunits was given.
+if test "${with_udunits+set}" = set; then :
+  withval=$with_udunits; with_udunits="$withval"
 fi
 
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-exec 5>>config.log
-{
-  echo
-  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
-## Running $as_me. ##
-_ASBOX
-  $as_echo "$ac_log"
-} >&5
 
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-#
-# INIT-COMMANDS
-#
-AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
+if test "x$with_udunits" != "xno"; then
+  if test "x$with_udunits" != "xyes"; then
+    LIBS="$LIBS -L$with_udunits/lib -ludunits2"
+    INCLUDES="$INCLUDES -I$with_udunits/include"
+  else
+    INCLUDES="$INCLUDES -I/usr/include"
+    LIBS="$LIBS -ludunits2"
+  fi
 
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_get_unit_by_name in -ludunits2" >&5
+$as_echo_n "checking for ut_get_unit_by_name in -ludunits2... " >&6; }
+if test "${ac_cv_lib_udunits2_ut_get_unit_by_name+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ludunits2  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-# The HP-UX ksh and POSIX shell print the target directory to stdout
-# if CDPATH is set.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char ut_get_unit_by_name ();
+int
+main ()
+{
+return ut_get_unit_by_name ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_udunits2_ut_get_unit_by_name=yes
+else
+  ac_cv_lib_udunits2_ut_get_unit_by_name=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_udunits2_ut_get_unit_by_name" >&5
+$as_echo "$ac_cv_lib_udunits2_ut_get_unit_by_name" >&6; }
+if test "x$ac_cv_lib_udunits2_ut_get_unit_by_name" = x""yes; then :
 
-sed_quote_subst='$sed_quote_subst'
-double_quote_subst='$double_quote_subst'
-delay_variable_subst='$delay_variable_subst'
-macro_version='`$ECHO "X$macro_version" | $Xsed -e "$delay_single_quote_subst"`'
-macro_revision='`$ECHO "X$macro_revision" | $Xsed -e "$delay_single_quote_subst"`'
-enable_shared='`$ECHO "X$enable_shared" | $Xsed -e "$delay_single_quote_subst"`'
-enable_static='`$ECHO "X$enable_static" | $Xsed -e "$delay_single_quote_subst"`'
-pic_mode='`$ECHO "X$pic_mode" | $Xsed -e "$delay_single_quote_subst"`'
-enable_fast_install='`$ECHO "X$enable_fast_install" | $Xsed -e "$delay_single_quote_subst"`'
-host_alias='`$ECHO "X$host_alias" | $Xsed -e "$delay_single_quote_subst"`'
-host='`$ECHO "X$host" | $Xsed -e "$delay_single_quote_subst"`'
-host_os='`$ECHO "X$host_os" | $Xsed -e "$delay_single_quote_subst"`'
-build_alias='`$ECHO "X$build_alias" | $Xsed -e "$delay_single_quote_subst"`'
-build='`$ECHO "X$build" | $Xsed -e "$delay_single_quote_subst"`'
-build_os='`$ECHO "X$build_os" | $Xsed -e "$delay_single_quote_subst"`'
-SED='`$ECHO "X$SED" | $Xsed -e "$delay_single_quote_subst"`'
-Xsed='`$ECHO "X$Xsed" | $Xsed -e "$delay_single_quote_subst"`'
-GREP='`$ECHO "X$GREP" | $Xsed -e "$delay_single_quote_subst"`'
-EGREP='`$ECHO "X$EGREP" | $Xsed -e "$delay_single_quote_subst"`'
-FGREP='`$ECHO "X$FGREP" | $Xsed -e "$delay_single_quote_subst"`'
-LD='`$ECHO "X$LD" | $Xsed -e "$delay_single_quote_subst"`'
-NM='`$ECHO "X$NM" | $Xsed -e "$delay_single_quote_subst"`'
-LN_S='`$ECHO "X$LN_S" | $Xsed -e "$delay_single_quote_subst"`'
-max_cmd_len='`$ECHO "X$max_cmd_len" | $Xsed -e "$delay_single_quote_subst"`'
-ac_objext='`$ECHO "X$ac_objext" | $Xsed -e "$delay_single_quote_subst"`'
-exeext='`$ECHO "X$exeext" | $Xsed -e "$delay_single_quote_subst"`'
-lt_unset='`$ECHO "X$lt_unset" | $Xsed -e "$delay_single_quote_subst"`'
-lt_SP2NL='`$ECHO "X$lt_SP2NL" | $Xsed -e "$delay_single_quote_subst"`'
-lt_NL2SP='`$ECHO "X$lt_NL2SP" | $Xsed -e "$delay_single_quote_subst"`'
-reload_flag='`$ECHO "X$reload_flag" | $Xsed -e "$delay_single_quote_subst"`'
-reload_cmds='`$ECHO "X$reload_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-OBJDUMP='`$ECHO "X$OBJDUMP" | $Xsed -e "$delay_single_quote_subst"`'
-deplibs_check_method='`$ECHO "X$deplibs_check_method" | $Xsed -e "$delay_single_quote_subst"`'
-file_magic_cmd='`$ECHO "X$file_magic_cmd" | $Xsed -e "$delay_single_quote_subst"`'
-AR='`$ECHO "X$AR" | $Xsed -e "$delay_single_quote_subst"`'
-AR_FLAGS='`$ECHO "X$AR_FLAGS" | $Xsed -e "$delay_single_quote_subst"`'
-STRIP='`$ECHO "X$STRIP" | $Xsed -e "$delay_single_quote_subst"`'
-RANLIB='`$ECHO "X$RANLIB" | $Xsed -e "$delay_single_quote_subst"`'
-old_postinstall_cmds='`$ECHO "X$old_postinstall_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-old_postuninstall_cmds='`$ECHO "X$old_postuninstall_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-old_archive_cmds='`$ECHO "X$old_archive_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-CC='`$ECHO "X$CC" | $Xsed -e "$delay_single_quote_subst"`'
-CFLAGS='`$ECHO "X$CFLAGS" | $Xsed -e "$delay_single_quote_subst"`'
-compiler='`$ECHO "X$compiler" | $Xsed -e "$delay_single_quote_subst"`'
-GCC='`$ECHO "X$GCC" | $Xsed -e "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_pipe='`$ECHO "X$lt_cv_sys_global_symbol_pipe" | $Xsed -e "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_to_cdecl='`$ECHO "X$lt_cv_sys_global_symbol_to_cdecl" | $Xsed -e "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_to_c_name_address='`$ECHO "X$lt_cv_sys_global_symbol_to_c_name_address" | $Xsed -e "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='`$ECHO "X$lt_cv_sys_global_symbol_to_c_name_address_lib_prefix" | $Xsed -e "$delay_single_quote_subst"`'
-objdir='`$ECHO "X$objdir" | $Xsed -e "$delay_single_quote_subst"`'
-SHELL='`$ECHO "X$SHELL" | $Xsed -e "$delay_single_quote_subst"`'
-ECHO='`$ECHO "X$ECHO" | $Xsed -e "$delay_single_quote_subst"`'
-MAGIC_CMD='`$ECHO "X$MAGIC_CMD" | $Xsed -e "$delay_single_quote_subst"`'
-lt_prog_compiler_no_builtin_flag='`$ECHO "X$lt_prog_compiler_no_builtin_flag" | $Xsed -e "$delay_single_quote_subst"`'
-lt_prog_compiler_wl='`$ECHO "X$lt_prog_compiler_wl" | $Xsed -e "$delay_single_quote_subst"`'
-lt_prog_compiler_pic='`$ECHO "X$lt_prog_compiler_pic" | $Xsed -e "$delay_single_quote_subst"`'
-lt_prog_compiler_static='`$ECHO "X$lt_prog_compiler_static" | $Xsed -e "$delay_single_quote_subst"`'
-lt_cv_prog_compiler_c_o='`$ECHO "X$lt_cv_prog_compiler_c_o" | $Xsed -e "$delay_single_quote_subst"`'
-need_locks='`$ECHO "X$need_locks" | $Xsed -e "$delay_single_quote_subst"`'
-DSYMUTIL='`$ECHO "X$DSYMUTIL" | $Xsed -e "$delay_single_quote_subst"`'
-NMEDIT='`$ECHO "X$NMEDIT" | $Xsed -e "$delay_single_quote_subst"`'
-LIPO='`$ECHO "X$LIPO" | $Xsed -e "$delay_single_quote_subst"`'
-OTOOL='`$ECHO "X$OTOOL" | $Xsed -e "$delay_single_quote_subst"`'
-OTOOL64='`$ECHO "X$OTOOL64" | $Xsed -e "$delay_single_quote_subst"`'
-libext='`$ECHO "X$libext" | $Xsed -e "$delay_single_quote_subst"`'
-shrext_cmds='`$ECHO "X$shrext_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-extract_expsyms_cmds='`$ECHO "X$extract_expsyms_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-archive_cmds_need_lc='`$ECHO "X$archive_cmds_need_lc" | $Xsed -e "$delay_single_quote_subst"`'
-enable_shared_with_static_runtimes='`$ECHO "X$enable_shared_with_static_runtimes" | $Xsed -e "$delay_single_quote_subst"`'
-export_dynamic_flag_spec='`$ECHO "X$export_dynamic_flag_spec" | $Xsed -e "$delay_single_quote_subst"`'
-whole_archive_flag_spec='`$ECHO "X$whole_archive_flag_spec" | $Xsed -e "$delay_single_quote_subst"`'
-compiler_needs_object='`$ECHO "X$compiler_needs_object" | $Xsed -e "$delay_single_quote_subst"`'
-old_archive_from_new_cmds='`$ECHO "X$old_archive_from_new_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-old_archive_from_expsyms_cmds='`$ECHO "X$old_archive_from_expsyms_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-archive_cmds='`$ECHO "X$archive_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-archive_expsym_cmds='`$ECHO "X$archive_expsym_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-module_cmds='`$ECHO "X$module_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-module_expsym_cmds='`$ECHO "X$module_expsym_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-with_gnu_ld='`$ECHO "X$with_gnu_ld" | $Xsed -e "$delay_single_quote_subst"`'
-allow_undefined_flag='`$ECHO "X$allow_undefined_flag" | $Xsed -e "$delay_single_quote_subst"`'
-no_undefined_flag='`$ECHO "X$no_undefined_flag" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_libdir_flag_spec='`$ECHO "X$hardcode_libdir_flag_spec" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_libdir_flag_spec_ld='`$ECHO "X$hardcode_libdir_flag_spec_ld" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_libdir_separator='`$ECHO "X$hardcode_libdir_separator" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_direct='`$ECHO "X$hardcode_direct" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_direct_absolute='`$ECHO "X$hardcode_direct_absolute" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_minus_L='`$ECHO "X$hardcode_minus_L" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_shlibpath_var='`$ECHO "X$hardcode_shlibpath_var" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_automatic='`$ECHO "X$hardcode_automatic" | $Xsed -e "$delay_single_quote_subst"`'
-inherit_rpath='`$ECHO "X$inherit_rpath" | $Xsed -e "$delay_single_quote_subst"`'
-link_all_deplibs='`$ECHO "X$link_all_deplibs" | $Xsed -e "$delay_single_quote_subst"`'
-fix_srcfile_path='`$ECHO "X$fix_srcfile_path" | $Xsed -e "$delay_single_quote_subst"`'
-always_export_symbols='`$ECHO "X$always_export_symbols" | $Xsed -e "$delay_single_quote_subst"`'
-export_symbols_cmds='`$ECHO "X$export_symbols_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-exclude_expsyms='`$ECHO "X$exclude_expsyms" | $Xsed -e "$delay_single_quote_subst"`'
-include_expsyms='`$ECHO "X$include_expsyms" | $Xsed -e "$delay_single_quote_subst"`'
-prelink_cmds='`$ECHO "X$prelink_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-file_list_spec='`$ECHO "X$file_list_spec" | $Xsed -e "$delay_single_quote_subst"`'
-variables_saved_for_relink='`$ECHO "X$variables_saved_for_relink" | $Xsed -e "$delay_single_quote_subst"`'
-need_lib_prefix='`$ECHO "X$need_lib_prefix" | $Xsed -e "$delay_single_quote_subst"`'
-need_version='`$ECHO "X$need_version" | $Xsed -e "$delay_single_quote_subst"`'
-version_type='`$ECHO "X$version_type" | $Xsed -e "$delay_single_quote_subst"`'
-runpath_var='`$ECHO "X$runpath_var" | $Xsed -e "$delay_single_quote_subst"`'
-shlibpath_var='`$ECHO "X$shlibpath_var" | $Xsed -e "$delay_single_quote_subst"`'
-shlibpath_overrides_runpath='`$ECHO "X$shlibpath_overrides_runpath" | $Xsed -e "$delay_single_quote_subst"`'
-libname_spec='`$ECHO "X$libname_spec" | $Xsed -e "$delay_single_quote_subst"`'
-library_names_spec='`$ECHO "X$library_names_spec" | $Xsed -e "$delay_single_quote_subst"`'
-soname_spec='`$ECHO "X$soname_spec" | $Xsed -e "$delay_single_quote_subst"`'
-postinstall_cmds='`$ECHO "X$postinstall_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-postuninstall_cmds='`$ECHO "X$postuninstall_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-finish_cmds='`$ECHO "X$finish_cmds" | $Xsed -e "$delay_single_quote_subst"`'
-finish_eval='`$ECHO "X$finish_eval" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_into_libs='`$ECHO "X$hardcode_into_libs" | $Xsed -e "$delay_single_quote_subst"`'
-sys_lib_search_path_spec='`$ECHO "X$sys_lib_search_path_spec" | $Xsed -e "$delay_single_quote_subst"`'
-sys_lib_dlsearch_path_spec='`$ECHO "X$sys_lib_dlsearch_path_spec" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_action='`$ECHO "X$hardcode_action" | $Xsed -e "$delay_single_quote_subst"`'
-enable_dlopen='`$ECHO "X$enable_dlopen" | $Xsed -e "$delay_single_quote_subst"`'
-enable_dlopen_self='`$ECHO "X$enable_dlopen_self" | $Xsed -e "$delay_single_quote_subst"`'
-enable_dlopen_self_static='`$ECHO "X$enable_dlopen_self_static" | $Xsed -e "$delay_single_quote_subst"`'
-old_striplib='`$ECHO "X$old_striplib" | $Xsed -e "$delay_single_quote_subst"`'
-striplib='`$ECHO "X$striplib" | $Xsed -e "$delay_single_quote_subst"`'
-compiler_lib_search_dirs='`$ECHO "X$compiler_lib_search_dirs" | $Xsed -e "$delay_single_quote_subst"`'
-predep_objects='`$ECHO "X$predep_objects" | $Xsed -e "$delay_single_quote_subst"`'
-postdep_objects='`$ECHO "X$postdep_objects" | $Xsed -e "$delay_single_quote_subst"`'
-predeps='`$ECHO "X$predeps" | $Xsed -e "$delay_single_quote_subst"`'
-postdeps='`$ECHO "X$postdeps" | $Xsed -e "$delay_single_quote_subst"`'
-compiler_lib_search_path='`$ECHO "X$compiler_lib_search_path" | $Xsed -e "$delay_single_quote_subst"`'
-LD_CXX='`$ECHO "X$LD_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-old_archive_cmds_CXX='`$ECHO "X$old_archive_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-compiler_CXX='`$ECHO "X$compiler_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-GCC_CXX='`$ECHO "X$GCC_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-lt_prog_compiler_no_builtin_flag_CXX='`$ECHO "X$lt_prog_compiler_no_builtin_flag_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-lt_prog_compiler_wl_CXX='`$ECHO "X$lt_prog_compiler_wl_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-lt_prog_compiler_pic_CXX='`$ECHO "X$lt_prog_compiler_pic_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-lt_prog_compiler_static_CXX='`$ECHO "X$lt_prog_compiler_static_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-lt_cv_prog_compiler_c_o_CXX='`$ECHO "X$lt_cv_prog_compiler_c_o_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-archive_cmds_need_lc_CXX='`$ECHO "X$archive_cmds_need_lc_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-enable_shared_with_static_runtimes_CXX='`$ECHO "X$enable_shared_with_static_runtimes_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-export_dynamic_flag_spec_CXX='`$ECHO "X$export_dynamic_flag_spec_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-whole_archive_flag_spec_CXX='`$ECHO "X$whole_archive_flag_spec_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-compiler_needs_object_CXX='`$ECHO "X$compiler_needs_object_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-old_archive_from_new_cmds_CXX='`$ECHO "X$old_archive_from_new_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-old_archive_from_expsyms_cmds_CXX='`$ECHO "X$old_archive_from_expsyms_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-archive_cmds_CXX='`$ECHO "X$archive_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-archive_expsym_cmds_CXX='`$ECHO "X$archive_expsym_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-module_cmds_CXX='`$ECHO "X$module_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-module_expsym_cmds_CXX='`$ECHO "X$module_expsym_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-with_gnu_ld_CXX='`$ECHO "X$with_gnu_ld_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-allow_undefined_flag_CXX='`$ECHO "X$allow_undefined_flag_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-no_undefined_flag_CXX='`$ECHO "X$no_undefined_flag_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_libdir_flag_spec_CXX='`$ECHO "X$hardcode_libdir_flag_spec_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_libdir_flag_spec_ld_CXX='`$ECHO "X$hardcode_libdir_flag_spec_ld_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_libdir_separator_CXX='`$ECHO "X$hardcode_libdir_separator_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_direct_CXX='`$ECHO "X$hardcode_direct_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_direct_absolute_CXX='`$ECHO "X$hardcode_direct_absolute_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_minus_L_CXX='`$ECHO "X$hardcode_minus_L_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_shlibpath_var_CXX='`$ECHO "X$hardcode_shlibpath_var_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_automatic_CXX='`$ECHO "X$hardcode_automatic_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-inherit_rpath_CXX='`$ECHO "X$inherit_rpath_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-link_all_deplibs_CXX='`$ECHO "X$link_all_deplibs_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-fix_srcfile_path_CXX='`$ECHO "X$fix_srcfile_path_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-always_export_symbols_CXX='`$ECHO "X$always_export_symbols_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-export_symbols_cmds_CXX='`$ECHO "X$export_symbols_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-exclude_expsyms_CXX='`$ECHO "X$exclude_expsyms_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-include_expsyms_CXX='`$ECHO "X$include_expsyms_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-prelink_cmds_CXX='`$ECHO "X$prelink_cmds_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-file_list_spec_CXX='`$ECHO "X$file_list_spec_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-hardcode_action_CXX='`$ECHO "X$hardcode_action_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-compiler_lib_search_dirs_CXX='`$ECHO "X$compiler_lib_search_dirs_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-predep_objects_CXX='`$ECHO "X$predep_objects_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-postdep_objects_CXX='`$ECHO "X$postdep_objects_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-predeps_CXX='`$ECHO "X$predeps_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-postdeps_CXX='`$ECHO "X$postdeps_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-compiler_lib_search_path_CXX='`$ECHO "X$compiler_lib_search_path_CXX" | $Xsed -e "$delay_single_quote_subst"`'
-
-LTCC='$LTCC'
-LTCFLAGS='$LTCFLAGS'
-compiler='$compiler_DEFAULT'
-
-# Quote evaled strings.
-for var in SED \
-GREP \
-EGREP \
-FGREP \
-LD \
-NM \
-LN_S \
-lt_SP2NL \
-lt_NL2SP \
-reload_flag \
-OBJDUMP \
-deplibs_check_method \
-file_magic_cmd \
-AR \
-AR_FLAGS \
-STRIP \
-RANLIB \
-CC \
-CFLAGS \
-compiler \
-lt_cv_sys_global_symbol_pipe \
-lt_cv_sys_global_symbol_to_cdecl \
-lt_cv_sys_global_symbol_to_c_name_address \
-lt_cv_sys_global_symbol_to_c_name_address_lib_prefix \
-SHELL \
-ECHO \
-lt_prog_compiler_no_builtin_flag \
-lt_prog_compiler_wl \
-lt_prog_compiler_pic \
-lt_prog_compiler_static \
-lt_cv_prog_compiler_c_o \
-need_locks \
-DSYMUTIL \
-NMEDIT \
-LIPO \
-OTOOL \
-OTOOL64 \
-shrext_cmds \
-export_dynamic_flag_spec \
-whole_archive_flag_spec \
-compiler_needs_object \
-with_gnu_ld \
-allow_undefined_flag \
-no_undefined_flag \
-hardcode_libdir_flag_spec \
-hardcode_libdir_flag_spec_ld \
-hardcode_libdir_separator \
-fix_srcfile_path \
-exclude_expsyms \
-include_expsyms \
-file_list_spec \
-variables_saved_for_relink \
-libname_spec \
-library_names_spec \
-soname_spec \
-finish_eval \
-old_striplib \
-striplib \
-compiler_lib_search_dirs \
-predep_objects \
-postdep_objects \
-predeps \
-postdeps \
-compiler_lib_search_path \
-LD_CXX \
-compiler_CXX \
-lt_prog_compiler_no_builtin_flag_CXX \
-lt_prog_compiler_wl_CXX \
-lt_prog_compiler_pic_CXX \
-lt_prog_compiler_static_CXX \
-lt_cv_prog_compiler_c_o_CXX \
-export_dynamic_flag_spec_CXX \
-whole_archive_flag_spec_CXX \
-compiler_needs_object_CXX \
-with_gnu_ld_CXX \
-allow_undefined_flag_CXX \
-no_undefined_flag_CXX \
-hardcode_libdir_flag_spec_CXX \
-hardcode_libdir_flag_spec_ld_CXX \
-hardcode_libdir_separator_CXX \
-fix_srcfile_path_CXX \
-exclude_expsyms_CXX \
-include_expsyms_CXX \
-file_list_spec_CXX \
-compiler_lib_search_dirs_CXX \
-predep_objects_CXX \
-postdep_objects_CXX \
-predeps_CXX \
-postdeps_CXX \
-compiler_lib_search_path_CXX; do
-    case \`eval \\\\\$ECHO "X\\\\\$\$var"\` in
-    *[\\\\\\\`\\"\\\$]*)
-      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"X\\\$\$var\\" | \\\$Xsed -e \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
-      ;;
-    *)
-      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
-      ;;
-    esac
-done
+$as_echo "#define USE_UDUNITS 1" >>confdefs.h
 
-# Double-quote double-evaled strings.
-for var in reload_cmds \
-old_postinstall_cmds \
-old_postuninstall_cmds \
-old_archive_cmds \
-extract_expsyms_cmds \
-old_archive_from_new_cmds \
-old_archive_from_expsyms_cmds \
-archive_cmds \
-archive_expsym_cmds \
-module_cmds \
-module_expsym_cmds \
-export_symbols_cmds \
-prelink_cmds \
-postinstall_cmds \
-postuninstall_cmds \
-finish_cmds \
-sys_lib_search_path_spec \
-sys_lib_dlsearch_path_spec \
-old_archive_cmds_CXX \
-old_archive_from_new_cmds_CXX \
-old_archive_from_expsyms_cmds_CXX \
-archive_cmds_CXX \
-archive_expsym_cmds_CXX \
-module_cmds_CXX \
-module_expsym_cmds_CXX \
-export_symbols_cmds_CXX \
-prelink_cmds_CXX; do
-    case \`eval \\\\\$ECHO "X\\\\\$\$var"\` in
-    *[\\\\\\\`\\"\\\$]*)
-      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"X\\\$\$var\\" | \\\$Xsed -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
-      ;;
-    *)
-      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
-      ;;
-    esac
-done
+else
 
-# Fix-up fallback echo if it was mangled by the above quoting rules.
-case \$lt_ECHO in
-*'\\\$0 --fallback-echo"')  lt_ECHO=\`\$ECHO "X\$lt_ECHO" | \$Xsed -e 's/\\\\\\\\\\\\\\\$0 --fallback-echo"\$/\$0 --fallback-echo"/'\`
-  ;;
-esac
+    echo ""
+    echo "Error! UDUNITS-2 is required but was not found"
+    echo "       Use --with-udunits=DIR to specify the UDUNITS-2 directory tree"
+    echo "       Use --with-udunits=no  to not use it"
+    echo "       Check the README or use configure --help for other libraries needed"
+    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
+    exit -1
 
-ac_aux_dir='$ac_aux_dir'
-xsi_shell='$xsi_shell'
-lt_shell_append='$lt_shell_append'
+fi
 
-# See if we are running on zsh, and set the options which allow our
-# commands through without removal of \ escapes INIT.
-if test -n "\${ZSH_VERSION+set}" ; then
-   setopt NO_GLOB_SUBST
 fi
 
 
-    PACKAGE='$PACKAGE'
-    VERSION='$VERSION'
-    TIMESTAMP='$TIMESTAMP'
-    RM='$RM'
-    ofile='$ofile'
 
 
+# Check whether --with-grib was given.
+if test "${with_grib+set}" = set; then :
+  withval=$with_grib; with_grib="$withval"
+fi
 
 
+if test "x$with_grib" != "xno"; then
+  if test "x$with_grib" != "xyes"; then
+    LIBS="$LIBS -L$with_grib/lib -lgrib_api"
+    INCLUDES="$INCLUDES -I$with_grib/include"
+  else
+    INCLUDES="$INCLUDES -I/usr/include"
+    LIBS="$LIBS -lgrib_api"
+  fi
 
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for grib_handle_new_from_file in -lgrib_api" >&5
+$as_echo_n "checking for grib_handle_new_from_file in -lgrib_api... " >&6; }
+if test "${ac_cv_lib_grib_api_grib_handle_new_from_file+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgrib_api  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char grib_handle_new_from_file ();
+int
+main ()
+{
+return grib_handle_new_from_file ();
+  ;
+  return 0;
+}
 _ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_grib_api_grib_handle_new_from_file=yes
+else
+  ac_cv_lib_grib_api_grib_handle_new_from_file=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_grib_api_grib_handle_new_from_file" >&5
+$as_echo "$ac_cv_lib_grib_api_grib_handle_new_from_file" >&6; }
+if test "x$ac_cv_lib_grib_api_grib_handle_new_from_file" = x""yes; then :
 
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 
-# Handling of arguments.
-for ac_config_target in $ac_config_targets
-do
-  case $ac_config_target in
-    "config.h") CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
-    "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
-    "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
-    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
-    "src/Makefile") CONFIG_FILES="$CONFIG_FILES src/Makefile" ;;
-    "src/antlr/Makefile") CONFIG_FILES="$CONFIG_FILES src/antlr/Makefile" ;;
-    "src/pro/Makefile") CONFIG_FILES="$CONFIG_FILES src/pro/Makefile" ;;
-    "src/pro/dicom/Makefile") CONFIG_FILES="$CONFIG_FILES src/pro/dicom/Makefile" ;;
-    "testsuite/Makefile") CONFIG_FILES="$CONFIG_FILES testsuite/Makefile" ;;
-    "doc/Makefile") CONFIG_FILES="$CONFIG_FILES doc/Makefile" ;;
+$as_echo "#define USE_GRIB 1" >>confdefs.h
 
-  *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
-  esac
-done
 
+else
 
-# If the user did not use the arguments to specify the items to instantiate,
-# then the envvar interface is used.  Set only those that are not.
-# We use the long form for the default assignment because of an extremely
-# bizarre bug on SunOS 4.1.3.
-if $ac_need_defaults; then
-  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
-  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
-  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
-fi
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking if linking with Jasper helps" >&5
+$as_echo_n "checking if linking with Jasper helps... " >&6; }
+      echo ""
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for grib_handle_clone in -lgrib_api" >&5
+$as_echo_n "checking for grib_handle_clone in -lgrib_api... " >&6; }
+if test "${ac_cv_lib_grib_api_grib_handle_clone+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgrib_api -ljasper $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
 
-# Have a temporary directory for convenience.  Make it in the build tree
-# simply because there is no reason against having it here, and in addition,
-# creating and moving files from /tmp can sometimes cause problems.
-# Hook for its removal unless debugging.
-# Note that there is a small window in which the directory will not be cleaned:
-# after its creation but before its name has been assigned to `$tmp'.
-$debug ||
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char grib_handle_clone ();
+int
+main ()
 {
-  tmp=
-  trap 'exit_status=$?
-  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
-' 0
-  trap 'as_fn_exit 1' 1 2 13 15
+return grib_handle_clone ();
+  ;
+  return 0;
 }
-# Create a (secure) tmp directory for tmp files.
-
-{
-  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
-  test -n "$tmp" && test -d "$tmp"
-}  ||
-{
-  tmp=./conf$$-$RANDOM
-  (umask 077 && mkdir "$tmp")
-} || as_fn_error "cannot create a temporary directory in ." "$LINENO" 5
-
-# Set up the scripts for CONFIG_FILES section.
-# No need to generate them if there are no CONFIG_FILES.
-# This happens for instance with `./config.status config.h'.
-if test -n "$CONFIG_FILES"; then
-
-
-ac_cr=`echo X | tr X '\015'`
-# On cygwin, bash can eat \r inside `` if the user requested igncr.
-# But we know of no other shell where ac_cr would be empty at this
-# point, so we can use a bashism as a fallback.
-if test "x$ac_cr" = x; then
-  eval ac_cr=\$\'\\r\'
-fi
-ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
-if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
-  ac_cs_awk_cr='\r'
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_grib_api_grib_handle_clone=yes
 else
-  ac_cs_awk_cr=$ac_cr
+  ac_cv_lib_grib_api_grib_handle_clone=no
 fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_grib_api_grib_handle_clone" >&5
+$as_echo "$ac_cv_lib_grib_api_grib_handle_clone" >&6; }
+if test "x$ac_cv_lib_grib_api_grib_handle_clone" = x""yes; then :
 
-echo 'BEGIN {' >"$tmp/subs1.awk" &&
-_ACEOF
-
-
-{
-  echo "cat >conf$$subs.awk <<_ACEOF" &&
-  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
-  echo "_ACEOF"
-} >conf$$subs.sh ||
-  as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
-ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
-ac_delim='%!_!# '
-for ac_last_try in false false false false false :; do
-  . ./conf$$subs.sh ||
-    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
-
-  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
-  if test $ac_delim_n = $ac_delim_num; then
-    break
-  elif $ac_last_try; then
-    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
-  else
-    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
-  fi
-done
-rm -f conf$$subs.sh
+        LIBS="$LIBS -ljasper"
 
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
-_ACEOF
-sed -n '
-h
-s/^/S["/; s/!.*/"]=/
-p
-g
-s/^[^!]*!//
-:repl
-t repl
-s/'"$ac_delim"'$//
-t delim
-:nl
-h
-s/\(.\{148\}\)..*/\1/
-t more1
-s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
-p
-n
-b repl
-:more1
-s/["\\]/\\&/g; s/^/"/; s/$/"\\/
-p
-g
-s/.\{148\}//
-t nl
-:delim
-h
-s/\(.\{148\}\)..*/\1/
-t more2
-s/["\\]/\\&/g; s/^/"/; s/$/"/
-p
-b
-:more2
-s/["\\]/\\&/g; s/^/"/; s/$/"\\/
-p
-g
-s/.\{148\}//
-t delim
-' <conf$$subs.awk | sed '
-/^[^""]/{
-  N
-  s/\n//
-}
-' >>$CONFIG_STATUS || ac_write_fail=1
-rm -f conf$$subs.awk
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-_ACAWK
-cat >>"\$tmp/subs1.awk" <<_ACAWK &&
-  for (key in S) S_is_set[key] = 1
-  FS = ""
+$as_echo "#define USE_GRIB 1" >>confdefs.h
 
-}
-{
-  line = $ 0
-  nfields = split(line, field, "@")
-  substed = 0
-  len = length(field[1])
-  for (i = 2; i < nfields; i++) {
-    key = field[i]
-    keylen = length(key)
-    if (S_is_set[key]) {
-      value = S[key]
-      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
-      len += length(value) + length(field[++i])
-      substed = 1
-    } else
-      len += 1 + keylen
-  }
 
-  print line
-}
+else
 
-_ACAWK
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
-  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking if linking with Jasper and OpenJPEG helps" >&5
+$as_echo_n "checking if linking with Jasper and OpenJPEG helps... " >&6; }
+        echo ""
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for grib_handle_delete in -lgrib_api" >&5
+$as_echo_n "checking for grib_handle_delete in -lgrib_api... " >&6; }
+if test "${ac_cv_lib_grib_api_grib_handle_delete+set}" = set; then :
+  $as_echo_n "(cached) " >&6
 else
-  cat
-fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
-  || as_fn_error "could not setup config files machinery" "$LINENO" 5
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgrib_api -ljasper -lopenjpeg $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char grib_handle_delete ();
+int
+main ()
+{
+return grib_handle_delete ();
+  ;
+  return 0;
+}
 _ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_grib_api_grib_handle_delete=yes
+else
+  ac_cv_lib_grib_api_grib_handle_delete=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_grib_api_grib_handle_delete" >&5
+$as_echo "$ac_cv_lib_grib_api_grib_handle_delete" >&6; }
+if test "x$ac_cv_lib_grib_api_grib_handle_delete" = x""yes; then :
+
+          LIBS="$LIBS -ljasper -lopenjpeg"
+
+$as_echo "#define USE_GRIB 1" >>confdefs.h
+
+
+else
+
+          echo ""
+          echo "Error! GRIB is required but was not found"
+          echo "       Use --with-grib=DIR to specify the GRIB directory tree"
+          echo "       Use --with-grib=no  to not use it"
+          echo "       Check the README or use configure --help for other libraries needed"
+          echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
+          exit -1
 
-# VPATH may cause trouble with some makes, so we remove $(srcdir),
-# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
-# trailing colons and then remove the whole line if VPATH becomes empty
-# (actually we leave an empty line to preserve line numbers).
-if test "x$srcdir" = x.; then
-  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
-s/:*\$(srcdir):*/:/
-s/:*\${srcdir}:*/:/
-s/:*@srcdir@:*/:/
-s/^\([^=]*=[	 ]*\):*/\1/
-s/:*$//
-s/^[^=]*=[	 ]*$//
-}'
 fi
 
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-fi # test -n "$CONFIG_FILES"
 
-# Set up the scripts for CONFIG_HEADERS section.
-# No need to generate them if there are no CONFIG_HEADERS.
-# This happens for instance with `./config.status Makefile'.
-if test -n "$CONFIG_HEADERS"; then
-cat >"$tmp/defines.awk" <<\_ACAWK ||
-BEGIN {
-_ACEOF
+fi
 
-# Transform confdefs.h into an awk script `defines.awk', embedded as
-# here-document in config.status, that substitutes the proper values into
-# config.h.in to produce config.h.
 
-# Create a delimiter string that does not exist in confdefs.h, to ease
-# handling of long lines.
-ac_delim='%!_!# '
-for ac_last_try in false false :; do
-  ac_t=`sed -n "/$ac_delim/p" confdefs.h`
-  if test -z "$ac_t"; then
-    break
-  elif $ac_last_try; then
-    as_fn_error "could not make $CONFIG_HEADERS" "$LINENO" 5
-  else
-    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
-  fi
-done
 
-# For the awk script, D is an array of macro values keyed by name,
-# likewise P contains macro parameters if any.  Preserve backslash
-# newline sequences.
+fi
 
-ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
-sed -n '
-s/.\{148\}/&'"$ac_delim"'/g
-t rset
-:rset
-s/^[	 ]*#[	 ]*define[	 ][	 ]*/ /
-t def
-d
-:def
-s/\\$//
-t bsnl
-s/["\\]/\\&/g
-s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
-D["\1"]=" \3"/p
-s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2"/p
-d
-:bsnl
-s/["\\]/\\&/g
-s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
-D["\1"]=" \3\\\\\\n"\\/p
-t cont
-s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2\\\\\\n"\\/p
-t cont
-d
-:cont
-n
-s/.\{148\}/&'"$ac_delim"'/g
-t clear
-:clear
-s/\\$//
-t bsnlc
-s/["\\]/\\&/g; s/^/"/; s/$/"/p
-d
-:bsnlc
-s/["\\]/\\&/g; s/^/"/; s/$/\\\\\\n"\\/p
-b cont
-' <confdefs.h | sed '
-s/'"$ac_delim"'/"\\\
-"/g' >>$CONFIG_STATUS || ac_write_fail=1
 
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-  for (key in D) D_is_set[key] = 1
-  FS = ""
-}
-/^[\t ]*#[\t ]*(define|undef)[\t ]+$ac_word_re([\t (]|\$)/ {
-  line = \$ 0
-  split(line, arg, " ")
-  if (arg[1] == "#") {
-    defundef = arg[2]
-    mac1 = arg[3]
-  } else {
-    defundef = substr(arg[1], 2)
-    mac1 = arg[2]
-  }
-  split(mac1, mac2, "(") #)
-  macro = mac2[1]
-  prefix = substr(line, 1, index(line, defundef) - 1)
-  if (D_is_set[macro]) {
-    # Preserve the white space surrounding the "#".
-    print prefix "define", macro P[macro] D[macro]
-    next
-  } else {
-    # Replace #undef with comments.  This is necessary, for example,
-    # in the case of _POSIX_SOURCE, which is predefined and required
-    # on some systems where configure will not decide to define it.
-    if (defundef == "undef") {
-      print "/*", prefix defundef, macro, "*/"
-      next
-    }
-  }
-}
-{ print }
-_ACAWK
+fi
+
+
+
+# Check whether --with-gshhs was given.
+if test "${with_gshhs+set}" = set; then :
+  withval=$with_gshhs; with_gshhs="$withval"
+fi
+
+
+if test "x$with_gshhs" != "xno"; then
+  if test "x$with_gshhs" != "xyes"; then
+    INCLUDES="$INCLUDES -I$with_gshhs/include"
+  fi
+
+  for ac_header in gshhs.h
+do :
+  ac_fn_cxx_check_header_mongrel "$LINENO" "gshhs.h" "ac_cv_header_gshhs_h" "$ac_includes_default"
+if test "x$ac_cv_header_gshhs_h" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_GSHHS_H 1
 _ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-  as_fn_error "could not setup config headers machinery" "$LINENO" 5
-fi # test -n "$CONFIG_HEADERS"
 
 
-eval set X "  :F $CONFIG_FILES  :H $CONFIG_HEADERS    :C $CONFIG_COMMANDS"
-shift
-for ac_tag
-do
-  case $ac_tag in
-  :[FHLC]) ac_mode=$ac_tag; continue;;
-  esac
-  case $ac_mode$ac_tag in
-  :[FHL]*:*);;
-  :L* | :C*:*) as_fn_error "invalid tag \`$ac_tag'" "$LINENO" 5;;
-  :[FH]-) ac_tag=-:-;;
-  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
-  esac
-  ac_save_IFS=$IFS
-  IFS=:
-  set x $ac_tag
-  IFS=$ac_save_IFS
-  shift
-  ac_file=$1
-  shift
+$as_echo "#define USE_GSHHS 1" >>confdefs.h
 
-  case $ac_mode in
-  :L) ac_source=$1;;
-  :[FH])
-    ac_file_inputs=
-    for ac_f
-    do
-      case $ac_f in
-      -) ac_f="$tmp/stdin";;
-      *) # Look for the file first in the build tree, then in the source tree
-	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
-	 # because $ac_f cannot contain `:'.
-	 test -f "$ac_f" ||
-	   case $ac_f in
-	   [\\/$]*) false;;
-	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
-	   esac ||
-	   as_fn_error "cannot find input file: \`$ac_f'" "$LINENO" 5;;
-      esac
-      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
-      as_fn_append ac_file_inputs " '$ac_f'"
-    done
 
-    # Let's still pretend it is `configure' which instantiates (i.e., don't
-    # use $as_me), people would be surprised to read:
-    #    /* config.h.  Generated by config.status.  */
-    configure_input='Generated from '`
-	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
-	`' by configure.'
-    if test x"$ac_file" != x-; then
-      configure_input="$ac_file.  $configure_input"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
-$as_echo "$as_me: creating $ac_file" >&6;}
-    fi
-    # Neutralize special characters interpreted by sed in replacement strings.
-    case $configure_input in #(
-    *\&* | *\|* | *\\* )
-       ac_sed_conf_input=`$as_echo "$configure_input" |
-       sed 's/[\\\\&|]/\\\\&/g'`;; #(
-    *) ac_sed_conf_input=$configure_input;;
-    esac
+else
+
+    echo ""
+    echo "Error! GSHHS is required but gshhs.h was not found"
+    echo "       Use --with-gshhs=DIR to specify the GSHHS directory tree"
+    echo "       Use --with-gshhs=no  to not use it"
+    echo "       Check the README or use configure --help for other libraries needed"
+    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
+    exit -1
 
-    case $ac_tag in
-    *:-:* | *:-) cat >"$tmp/stdin" \
-      || as_fn_error "could not create $ac_file" "$LINENO" 5 ;;
-    esac
-    ;;
-  esac
+fi
 
-  ac_dir=`$as_dirname -- "$ac_file" ||
-$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$ac_file" : 'X\(//\)[^/]' \| \
-	 X"$ac_file" : 'X\(//\)$' \| \
-	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$ac_file" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-  as_dir="$ac_dir"; as_fn_mkdir_p
-  ac_builddir=.
+done
 
-case "$ac_dir" in
-.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
-*)
-  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
-  # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
-  case $ac_top_builddir_sub in
-  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
-  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
-  esac ;;
-esac
-ac_abs_top_builddir=$ac_pwd
-ac_abs_builddir=$ac_pwd$ac_dir_suffix
-# for backward compatibility:
-ac_top_builddir=$ac_top_build_prefix
 
-case $srcdir in
-  .)  # We are building in place.
-    ac_srcdir=.
-    ac_top_srcdir=$ac_top_builddir_sub
-    ac_abs_top_srcdir=$ac_pwd ;;
-  [\\/]* | ?:[\\/]* )  # Absolute name.
-    ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir
-    ac_abs_top_srcdir=$srcdir ;;
-  *) # Relative name.
-    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_build_prefix$srcdir
-    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
-esac
-ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+fi
 
 
-  case $ac_mode in
-  :F)
-  #
-  # CONFIG_FILE
-  #
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for X" >&5
+$as_echo_n "checking for X... " >&6; }
 
-  case $INSTALL in
-  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
-  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
-  esac
-  ac_MKDIR_P=$MKDIR_P
-  case $MKDIR_P in
-  [\\/$]* | ?:[\\/]* ) ;;
-  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
-  esac
-_ACEOF
 
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-# If the template does not know about datarootdir, expand it.
-# FIXME: This hack should be removed a few years after 2.60.
-ac_datarootdir_hack=; ac_datarootdir_seen=
-ac_sed_dataroot='
-/datarootdir/ {
-  p
-  q
-}
-/@datadir@/p
-/@docdir@/p
-/@infodir@/p
-/@localedir@/p
-/@mandir@/p'
-case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
-*datarootdir*) ac_datarootdir_seen=yes;;
-*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
-$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-  ac_datarootdir_hack='
-  s&@datadir@&$datadir&g
-  s&@docdir@&$docdir&g
-  s&@infodir@&$infodir&g
-  s&@localedir@&$localedir&g
-  s&@mandir@&$mandir&g
-  s&\\\${datarootdir}&$datarootdir&g' ;;
-esac
-_ACEOF
+# Check whether --with-x was given.
+if test "${with_x+set}" = set; then :
+  withval=$with_x;
+fi
 
-# Neutralize VPATH when `$srcdir' = `.'.
-# Shell code in configure.ac might set extrasub.
-# FIXME: do we really want to maintain this feature?
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-ac_sed_extra="$ac_vpsub
-$extrasub
+# $have_x is `yes', `no', `disabled', or empty when we do not yet know.
+if test "x$with_x" = xno; then
+  # The user explicitly disabled X.
+  have_x=disabled
+else
+  case $x_includes,$x_libraries in #(
+    *\'*) as_fn_error "cannot use X directory names containing '" "$LINENO" 5;; #(
+    *,NONE | NONE,*) if test "${ac_cv_have_x+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  # One or both of the vars are not set, and there is no cached value.
+ac_x_includes=no ac_x_libraries=no
+rm -f -r conftest.dir
+if mkdir conftest.dir; then
+  cd conftest.dir
+  cat >Imakefile <<'_ACEOF'
+incroot:
+	@echo incroot='${INCROOT}'
+usrlibdir:
+	@echo usrlibdir='${USRLIBDIR}'
+libdir:
+	@echo libdir='${LIBDIR}'
 _ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-:t
-/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
-s|@configure_input@|$ac_sed_conf_input|;t t
-s&@top_builddir@&$ac_top_builddir_sub&;t t
-s&@top_build_prefix@&$ac_top_build_prefix&;t t
-s&@srcdir@&$ac_srcdir&;t t
-s&@abs_srcdir@&$ac_abs_srcdir&;t t
-s&@top_srcdir@&$ac_top_srcdir&;t t
-s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
-s&@builddir@&$ac_builddir&;t t
-s&@abs_builddir@&$ac_abs_builddir&;t t
-s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
-s&@INSTALL@&$ac_INSTALL&;t t
-s&@MKDIR_P@&$ac_MKDIR_P&;t t
-$ac_datarootdir_hack
-"
-eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
-  || as_fn_error "could not create $ac_file" "$LINENO" 5
+  if (export CC; ${XMKMF-xmkmf}) >/dev/null 2>/dev/null && test -f Makefile; then
+    # GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+    for ac_var in incroot usrlibdir libdir; do
+      eval "ac_im_$ac_var=\`\${MAKE-make} $ac_var 2>/dev/null | sed -n 's/^$ac_var=//p'\`"
+    done
+    # Open Windows xmkmf reportedly sets LIBDIR instead of USRLIBDIR.
+    for ac_extension in a so sl dylib la dll; do
+      if test ! -f "$ac_im_usrlibdir/libX11.$ac_extension" &&
+	 test -f "$ac_im_libdir/libX11.$ac_extension"; then
+	ac_im_usrlibdir=$ac_im_libdir; break
+      fi
+    done
+    # Screen out bogus values from the imake configuration.  They are
+    # bogus both because they are the default anyway, and because
+    # using them would break gcc on systems where it needs fixed includes.
+    case $ac_im_incroot in
+	/usr/include) ac_x_includes= ;;
+	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes=$ac_im_incroot;;
+    esac
+    case $ac_im_usrlibdir in
+	/usr/lib | /usr/lib64 | /lib | /lib64) ;;
+	*) test -d "$ac_im_usrlibdir" && ac_x_libraries=$ac_im_usrlibdir ;;
+    esac
+  fi
+  cd ..
+  rm -f -r conftest.dir
+fi
 
-test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
-  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
-  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&5
-$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&2;}
+# Standard set of common directories for X headers.
+# Check X11 before X11Rn because it is often a symlink to the current release.
+ac_x_header_dirs='
+/usr/X11/include
+/usr/X11R7/include
+/usr/X11R6/include
+/usr/X11R5/include
+/usr/X11R4/include
 
-  rm -f "$tmp/stdin"
-  case $ac_file in
-  -) cat "$tmp/out" && rm -f "$tmp/out";;
-  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
-  esac \
-  || as_fn_error "could not create $ac_file" "$LINENO" 5
- ;;
-  :H)
-  #
-  # CONFIG_HEADER
-  #
-  if test x"$ac_file" != x-; then
-    {
-      $as_echo "/* $configure_input  */" \
-      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs"
-    } >"$tmp/config.h" \
-      || as_fn_error "could not create $ac_file" "$LINENO" 5
-    if diff "$ac_file" "$tmp/config.h" >/dev/null 2>&1; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
-$as_echo "$as_me: $ac_file is unchanged" >&6;}
-    else
-      rm -f "$ac_file"
-      mv "$tmp/config.h" "$ac_file" \
-	|| as_fn_error "could not create $ac_file" "$LINENO" 5
-    fi
-  else
-    $as_echo "/* $configure_input  */" \
-      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs" \
-      || as_fn_error "could not create -" "$LINENO" 5
+/usr/include/X11
+/usr/include/X11R7
+/usr/include/X11R6
+/usr/include/X11R5
+/usr/include/X11R4
+
+/usr/local/X11/include
+/usr/local/X11R7/include
+/usr/local/X11R6/include
+/usr/local/X11R5/include
+/usr/local/X11R4/include
+
+/usr/local/include/X11
+/usr/local/include/X11R7
+/usr/local/include/X11R6
+/usr/local/include/X11R5
+/usr/local/include/X11R4
+
+/usr/X386/include
+/usr/x386/include
+/usr/XFree86/include/X11
+
+/usr/include
+/usr/local/include
+/usr/unsupported/include
+/usr/athena/include
+/usr/local/x11r5/include
+/usr/lpp/Xamples/include
+
+/usr/openwin/include
+/usr/openwin/share/include'
+
+if test "$ac_x_includes" = no; then
+  # Guess where to find include files, by looking for Xlib.h.
+  # First, try using that file with no special directory specified.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+_ACEOF
+if ac_fn_cxx_try_cpp "$LINENO"; then :
+  # We can compile using X headers with no special include directory.
+ac_x_includes=
+else
+  for ac_dir in $ac_x_header_dirs; do
+  if test -r "$ac_dir/X11/Xlib.h"; then
+    ac_x_includes=$ac_dir
+    break
   fi
-# Compute "$ac_file"'s index in $config_headers.
-_am_arg="$ac_file"
-_am_stamp_count=1
-for _am_header in $config_headers :; do
-  case $_am_header in
-    $_am_arg | $_am_arg:* )
-      break ;;
-    * )
-      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
-  esac
 done
-echo "timestamp for $_am_arg" >`$as_dirname -- "$_am_arg" ||
-$as_expr X"$_am_arg" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$_am_arg" : 'X\(//\)[^/]' \| \
-	 X"$_am_arg" : 'X\(//\)$' \| \
-	 X"$_am_arg" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$_am_arg" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`/stamp-h$_am_stamp_count
- ;;
+fi
+rm -f conftest.err conftest.$ac_ext
+fi # $ac_x_includes = no
 
-  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
-$as_echo "$as_me: executing $ac_file commands" >&6;}
- ;;
+if test "$ac_x_libraries" = no; then
+  # Check for the libraries.
+  # See if we find them without any special options.
+  # Don't add to $LIBS permanently.
+  ac_save_LIBS=$LIBS
+  LIBS="-lX11 $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+int
+main ()
+{
+XrmInitialize ()
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  LIBS=$ac_save_LIBS
+# We can link X programs with no special library path.
+ac_x_libraries=
+else
+  LIBS=$ac_save_LIBS
+for ac_dir in `$as_echo "$ac_x_includes $ac_x_header_dirs" | sed s/include/lib/g`
+do
+  # Don't even attempt the hair of trying to link an X program!
+  for ac_extension in a so sl dylib la dll; do
+    if test -r "$ac_dir/libX11.$ac_extension"; then
+      ac_x_libraries=$ac_dir
+      break 2
+    fi
+  done
+done
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi # $ac_x_libraries = no
+
+case $ac_x_includes,$ac_x_libraries in #(
+  no,* | *,no | *\'*)
+    # Didn't find X, or a directory has "'" in its name.
+    ac_cv_have_x="have_x=no";; #(
+  *)
+    # Record where we found X for the cache.
+    ac_cv_have_x="have_x=yes\
+	ac_x_includes='$ac_x_includes'\
+	ac_x_libraries='$ac_x_libraries'"
+esac
+fi
+;; #(
+    *) have_x=yes;;
   esac
+  eval "$ac_cv_have_x"
+fi # $with_x != no
 
+if test "$have_x" != yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $have_x" >&5
+$as_echo "$have_x" >&6; }
+  no_x=yes
+else
+  # If each of the values was on the command line, it overrides each guess.
+  test "x$x_includes" = xNONE && x_includes=$ac_x_includes
+  test "x$x_libraries" = xNONE && x_libraries=$ac_x_libraries
+  # Update the cache value to reflect the command line values.
+  ac_cv_have_x="have_x=yes\
+	ac_x_includes='$x_includes'\
+	ac_x_libraries='$x_libraries'"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: libraries $x_libraries, headers $x_includes" >&5
+$as_echo "libraries $x_libraries, headers $x_includes" >&6; }
+fi
 
-  case $ac_file$ac_mode in
-    "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
-  # Autoconf 2.62 quotes --file arguments for eval, but not when files
-  # are listed without --file.  Let's play safe and only enable the eval
-  # if we detect the quoting.
-  case $CONFIG_FILES in
-  *\'*) eval set x "$CONFIG_FILES" ;;
-  *)   set x $CONFIG_FILES ;;
-  esac
-  shift
-  for mf
-  do
-    # Strip MF so we end up with the name of the file.
-    mf=`echo "$mf" | sed -e 's/:.*$//'`
-    # Check whether this is an Automake generated Makefile or not.
-    # We used to match only the files named `Makefile.in', but
-    # some people rename them; so instead we look at the file content.
-    # Grep'ing the first line is not enough: some people post-process
-    # each Makefile.in and add a new line on top of each file to say so.
-    # Grep'ing the whole file is not good either: AIX grep has a line
-    # limit of 2048, but all sed's we know have understand at least 4000.
-    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
-      dirpart=`$as_dirname -- "$mf" ||
-$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$mf" : 'X\(//\)[^/]' \| \
-	 X"$mf" : 'X\(//\)$' \| \
-	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$mf" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-    else
-      continue
-    fi
-    # Extract the definition of DEPDIR, am__include, and am__quote
-    # from the Makefile without running `make'.
-    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
-    test -z "$DEPDIR" && continue
-    am__include=`sed -n 's/^am__include = //p' < "$mf"`
-    test -z "am__include" && continue
-    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-    # When using ansi2knr, U may be empty or an underscore; expand it
-    U=`sed -n 's/^U = //p' < "$mf"`
-    # Find all dependency output files, they are included files with
-    # $(DEPDIR) in their names.  We invoke sed twice because it is the
-    # simplest approach to changing $(DEPDIR) to its actual value in the
-    # expansion.
-    for file in `sed -n "
-      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
-	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
-      # Make sure the directory exists.
-      test -f "$dirpart/$file" && continue
-      fdir=`$as_dirname -- "$file" ||
-$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$file" : 'X\(//\)[^/]' \| \
-	 X"$file" : 'X\(//\)$' \| \
-	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$file" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      as_dir=$dirpart/$fdir; as_fn_mkdir_p
-      # echo "creating $dirpart/$file"
-      echo '# dummy' > "$dirpart/$file"
-    done
-  done
-}
- ;;
-    "libtool":C)
+if test "x$no_x" = "xyes"; then
+  echo ""
+  echo "Warning! X Window System not detected, building with Xlib calls disabled"
+  echo "         Use --x-includes=DIR and --x-libraries=DIR to pass any needed paths"
+  echo ""
+else
 
-    # See if we are running on zsh, and set the options which allow our
-    # commands through without removal of \ escapes.
-    if test -n "${ZSH_VERSION+set}" ; then
-      setopt NO_GLOB_SUBST
-    fi
+$as_echo "#define HAVE_X 1" >>confdefs.h
 
-    cfgfile="${ofile}T"
-    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
-    $RM "$cfgfile"
+fi
 
-    cat <<_LT_EOF >> "$cfgfile"
-#! $SHELL
 
-# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
-# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
-# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
-# NOTE: Changes made to this file will be lost: look at ltmain.sh.
-#
-#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
-#                 2006, 2007, 2008 Free Software Foundation, Inc.
-#   Written by Gordon Matzigkeit, 1996
-#
-#   This file is part of GNU Libtool.
-#
-# GNU Libtool is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# As a special exception to the GNU General Public License,
-# if you distribute this file as part of a program or library that
-# is built using GNU Libtool, you may include this file under the
-# same distribution terms that you use for the rest of that program.
-#
-# GNU Libtool is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with GNU Libtool; see the file COPYING.  If not, a copy
-# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
-# obtained by writing to the Free Software Foundation, Inc.,
-# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 
 
-# The names of the tagged configurations supported by this script.
-available_tags="CXX "
 
-# ### BEGIN LIBTOOL CONFIG
+  prefix_NONE=
+  exec_prefix_NONE=
+  test "x$prefix" = xNONE && prefix_NONE=yes && prefix=$ac_default_prefix
+  test "x$exec_prefix" = xNONE && exec_prefix_NONE=yes && exec_prefix=$prefix
+  eval ac_define_dir="\"$exec_prefix\""
+  eval ac_define_dir="\"$ac_define_dir\""
+  EXEC_PREFIX="$ac_define_dir"
 
-# Which release of libtool.m4 was used?
-macro_version=$macro_version
-macro_revision=$macro_revision
 
-# Whether or not to build shared libraries.
-build_libtool_libs=$enable_shared
+cat >>confdefs.h <<_ACEOF
+#define EXEC_PREFIX "$ac_define_dir"
+_ACEOF
 
-# Whether or not to build static libraries.
-build_old_libs=$enable_static
+  test "$prefix_NONE" && prefix=NONE
+  test "$exec_prefix_NONE" && exec_prefix=NONE
 
-# What type of objects to build.
-pic_mode=$pic_mode
+#AC_DEFINE([EXEC_PREFIX],[\"`echo ${exec_prefix}`\"],[GDL installation directory])
 
-# Whether or not to optimize for fast installation.
-fast_install=$enable_fast_install
+  prefix_NONE=
+  exec_prefix_NONE=
+  test "x$prefix" = xNONE && prefix_NONE=yes && prefix=$ac_default_prefix
+  test "x$exec_prefix" = xNONE && exec_prefix_NONE=yes && exec_prefix=$prefix
+  eval ac_define_dir="\"$datadir/$datasubdir\""
+  eval ac_define_dir="\"$ac_define_dir\""
+  GDLDATADIR="$ac_define_dir"
 
-# The host system.
-host_alias=$host_alias
-host=$host
-host_os=$host_os
 
-# The build system.
-build_alias=$build_alias
-build=$build
-build_os=$build_os
+cat >>confdefs.h <<_ACEOF
+#define GDLDATADIR "$ac_define_dir"
+_ACEOF
 
-# A sed program that does not truncate output.
-SED=$lt_SED
+  test "$prefix_NONE" && prefix=NONE
+  test "$exec_prefix_NONE" && exec_prefix=NONE
 
-# Sed that helps us avoid accidentally triggering echo(1) options like -n.
-Xsed="\$SED -e 1s/^X//"
 
-# A grep program that handles long lines.
-GREP=$lt_GREP
 
-# An ERE matcher.
-EGREP=$lt_EGREP
+DARWIN="no"
+
+case "${host}" in
+  powerpc-*-darwin* )
+        LDFLAGS="$LDFLAGS -bind_at_load"
+    DARWIN="yes"
+        ;;
 
-# A literal string matcher.
-FGREP=$lt_FGREP
+  powerpc*-*-linux* )
+    LDFLAGS="$LDFLAGS -rdynamic"
+    ;;
 
-# A BSD- or MS-compatible name lister.
-NM=$lt_NM
+  *linux*)
+                    LDFLAGS="$LDFLAGS -rdynamic -z muldefs"
+    ;;
 
-# Whether we need soft or hard links.
-LN_S=$lt_LN_S
+  *solaris* )
+    LIBS="$LIBS -lsocket -lnsl"
+    ;;
 
-# What is the maximum length of a command?
-max_cmd_len=$max_cmd_len
+  *cygwin* )
+    LIBS="$LIBS -lrpc"
+    ;;
 
-# Object file suffix (normally "o").
-objext=$ac_objext
+esac
 
-# Executable file suffix (normally "").
-exeext=$exeext
+case "${host}" in
 
-# whether the shell understands "unset".
-lt_unset=$lt_unset
+  *darwin6*)
 
-# turn spaces into newlines.
-SP2NL=$lt_lt_SP2NL
+$as_echo "#define OLD_DARWIN 1" >>confdefs.h
 
-# turn newlines into spaces.
-NL2SP=$lt_lt_NL2SP
+    ;;
+  *darwin7*)
 
-# How to create reloadable object files.
-reload_flag=$lt_reload_flag
-reload_cmds=$lt_reload_cmds
+$as_echo "#define OLD_DARWIN 1" >>confdefs.h
 
-# An object symbol dumper.
-OBJDUMP=$lt_OBJDUMP
+    ;;
+  *darwin8.8*)
+        ;;
+  *darwin8.9*)
+        ;;
+  *darwin8.10*)
+        ;;
+  *darwin8.11*)
+        ;;
+  *darwin8.12*)
+        ;;
+  *darwin8.13*)
+        ;;
+  *darwin8.14*)
+        ;;
+  *darwin8.15*)
+        ;;
+  *darwin9*)
+        ;;
+  *darwin8*)
 
-# Method to check whether dependent libraries are shared objects.
-deplibs_check_method=$lt_deplibs_check_method
+$as_echo "#define OLD_DARWIN 1" >>confdefs.h
 
-# Command to use when deplibs_check_method == "file_magic".
-file_magic_cmd=$lt_file_magic_cmd
+    ;;
+esac
 
-# The archiver.
-AR=$lt_AR
-AR_FLAGS=$lt_AR_FLAGS
 
-# A symbol stripping program.
-STRIP=$lt_STRIP
 
-# Commands used to install an old-style archive.
-RANLIB=$lt_RANLIB
-old_postinstall_cmds=$lt_old_postinstall_cmds
-old_postuninstall_cmds=$lt_old_postuninstall_cmds
+if test "x$DARWIN" = "xyes"; then
+  DARWIN_TRUE=
+  DARWIN_FALSE='#'
+else
+  DARWIN_TRUE='#'
+  DARWIN_FALSE=
+fi
 
-# A C compiler.
-LTCC=$lt_CC
 
-# LTCC compiler flags.
-LTCFLAGS=$lt_CFLAGS
 
-# Take the output of nm and produce a listing of raw symbols and C names.
-global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe
+EXT_LIBS="$EXT_LIBS $LIBS"
+EXT_INCLUDES="$EXT_INCLUDES $INCLUDES"
 
-# Transform the output of nm in a proper C declaration.
-global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl
 
-# Transform the output of nm in a C name address pair.
-global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address
 
-# Transform the output of nm in a C name address pair when lib prefix is needed.
-global_symbol_to_c_name_address_lib_prefix=$lt_lt_cv_sys_global_symbol_to_c_name_address_lib_prefix
 
-# The name of the directory that contains temporary libtool files.
-objdir=$objdir
 
-# Shell to use when invoking shell scripts.
-SHELL=$lt_SHELL
 
-# An echo program that does not interpret backslashes.
-ECHO=$lt_ECHO
+case ${INSTALL} in
+  /* ) # Absolute
+     ;;
+  ?:* ) # Drive letter, considered as absolute.
+     ;;
+  *)
+     INSTALL=`pwd`/${INSTALL} ;;
+esac
 
-# Used to examine libraries when file_magic_cmd begins with "file".
-MAGIC_CMD=$MAGIC_CMD
+case "${host}" in
 
-# Must we lock files when doing compilation?
-need_locks=$lt_need_locks
+                *-*-darwin* )
+        INSTALL_PROGRAM="cp -fp"
+        INSTALL_DATA="cp -fp"
+        ;;
+    *)
+        ;;
+esac
 
-# Tool to manipulate archived DWARF debug symbol files on Mac OS X.
-DSYMUTIL=$lt_DSYMUTIL
 
-# Tool to change global to local symbols on Mac OS X.
-NMEDIT=$lt_NMEDIT
 
-# Tool to manipulate fat objects and archives on Mac OS X.
-LIPO=$lt_LIPO
 
-# ldd/readelf like tool for Mach-O binaries on Mac OS X.
-OTOOL=$lt_OTOOL
 
-# ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4.
-OTOOL64=$lt_OTOOL64
 
-# Old archive suffix (normally "a").
-libext=$libext
+ac_config_files="$ac_config_files Makefile src/Makefile src/antlr/Makefile src/pro/Makefile src/pro/dicom/Makefile testsuite/Makefile doc/Makefile"
 
-# Shared library suffix (normally ".so").
-shrext_cmds=$lt_shrext_cmds
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
 
-# The commands to extract the exported symbol list from a shared archive.
-extract_expsyms_cmds=$lt_extract_expsyms_cmds
+_ACEOF
 
-# Variables whose values should be saved in libtool wrapper scripts and
-# restored at link time.
-variables_saved_for_relink=$lt_variables_saved_for_relink
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, we kill variables containing newlines.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(
+  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
 
-# Do we need the "lib" prefix for modules?
-need_lib_prefix=$need_lib_prefix
+  (set) 2>&1 |
+    case $as_nl`(ac_space=' '; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      # `set' does not quote correctly, so add quotes: double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \.
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;; #(
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+) |
+  sed '
+     /^ac_cv_env_/b end
+     t clear
+     :clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     :end' >>confcache
+if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
+  if test -w "$cache_file"; then
+    test "x$cache_file" != "x/dev/null" &&
+      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
+$as_echo "$as_me: updating cache $cache_file" >&6;}
+    cat confcache >$cache_file
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
+$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+  fi
+fi
+rm -f confcache
 
-# Do we need a version for libraries?
-need_version=$need_version
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
 
-# Library versioning type.
-version_type=$version_type
+DEFS=-DHAVE_CONFIG_H
 
-# Shared library runtime path variable.
-runpath_var=$runpath_var
+ac_libobjs=
+ac_ltlibobjs=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
+  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
 
-# Shared library path variable.
-shlibpath_var=$shlibpath_var
+LTLIBOBJS=$ac_ltlibobjs
 
-# Is shlibpath searched before the hard-coded library search path?
-shlibpath_overrides_runpath=$shlibpath_overrides_runpath
 
-# Format of library name prefix.
-libname_spec=$lt_libname_spec
+if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
+  as_fn_error "conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${am__fastdepCXX_TRUE}" && test -z "${am__fastdepCXX_FALSE}"; then
+  as_fn_error "conditional \"am__fastdepCXX\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
+  as_fn_error "conditional \"am__fastdepCC\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${BUILDASLIBRARY_TRUE}" && test -z "${BUILDASLIBRARY_FALSE}"; then
+  as_fn_error "conditional \"BUILDASLIBRARY\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${DARWIN_TRUE}" && test -z "${DARWIN_FALSE}"; then
+  as_fn_error "conditional \"DARWIN\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 
-# List of archive names.  First name is the real one, the rest are links.
-# The last name is the one that the linker finds with -lNAME
-library_names_spec=$lt_library_names_spec
+: ${CONFIG_STATUS=./config.status}
+ac_write_fail=0
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
+$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
+as_write_fail=0
+cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
 
-# The coded name of the library, if different from the real name.
-soname_spec=$lt_soname_spec
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
 
-# Command to use after installation of a shared archive.
-postinstall_cmds=$lt_postinstall_cmds
+SHELL=\${CONFIG_SHELL-$SHELL}
+export SHELL
+_ASEOF
+cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
 
-# Command to use after uninstallation of a shared archive.
-postuninstall_cmds=$lt_postuninstall_cmds
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
 
-# Commands used to finish a libtool library installation in a directory.
-finish_cmds=$lt_finish_cmds
 
-# As "finish_cmds", except a single script fragment to be evaled but
-# not shown.
-finish_eval=$lt_finish_eval
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
 
-# Whether we should hardcode library paths into libraries.
-hardcode_into_libs=$hardcode_into_libs
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
 
-# Compile-time system search path for libraries.
-sys_lib_search_path_spec=$lt_sys_lib_search_path_spec
 
-# Run-time system search path for libraries.
-sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
 
-# Whether dlopen is supported.
-dlopen_support=$enable_dlopen
+# Find who we are.  Look in the path if we contain no directory separator.
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
 
-# Whether dlopen of programs is supported.
-dlopen_self=$enable_dlopen_self
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
 
-# Whether dlopen of statically linked programs is supported.
-dlopen_self_static=$enable_dlopen_self_static
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
 
-# Commands to strip libraries.
-old_striplib=$lt_old_striplib
-striplib=$lt_striplib
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
 
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
-# The linker used to build libraries.
-LD=$lt_LD
 
-# Commands used to build an old-style archive.
-old_archive_cmds=$lt_old_archive_cmds
+# as_fn_error ERROR [LINENO LOG_FD]
+# ---------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with status $?, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$?; test $as_status -eq 0 && as_status=1
+  if test "$3"; then
+    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
+  fi
+  $as_echo "$as_me: error: $1" >&2
+  as_fn_exit $as_status
+} # as_fn_error
 
-# A language specific compiler.
-CC=$lt_compiler
 
-# Is the compiler the GNU compiler?
-with_gcc=$GCC
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
 
-# Compiler flag to turn off builtin functions.
-no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
 
-# How to pass a linker flag through the compiler.
-wl=$lt_lt_prog_compiler_wl
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
 
-# Additional compiler flags for building library objects.
-pic_flag=$lt_lt_prog_compiler_pic
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
 
-# Compiler flag to prevent dynamic linking.
-link_static_flag=$lt_lt_prog_compiler_static
 
-# Does compiler simultaneously support -c and -o options?
-compiler_c_o=$lt_lt_cv_prog_compiler_c_o
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
 
-# Whether or not to add -lc for building shared libraries.
-build_libtool_need_lc=$archive_cmds_need_lc
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
 
-# Whether or not to disallow shared libs when runtime libs are static.
-allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
 
-# Compiler flag to allow reflexive dlopens.
-export_dynamic_flag_spec=$lt_export_dynamic_flag_spec
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
 
-# Compiler flag to generate shared objects directly from archives.
-whole_archive_flag_spec=$lt_whole_archive_flag_spec
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
 
-# Whether the compiler copes with passing no objects directly.
-compiler_needs_object=$lt_compiler_needs_object
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
 
-# Create an old-style archive from a shared archive.
-old_archive_from_new_cmds=$lt_old_archive_from_new_cmds
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -p'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -p'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -p'
+  fi
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
 
-# Create a temporary old-style archive to link instead of a shared archive.
-old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds
 
-# Commands used to build a shared archive.
-archive_cmds=$lt_archive_cmds
-archive_expsym_cmds=$lt_archive_expsym_cmds
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
 
-# Commands used to build a loadable module if different from building
-# a shared archive.
-module_cmds=$lt_module_cmds
-module_expsym_cmds=$lt_module_expsym_cmds
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
 
-# Whether we are building with GNU ld or not.
-with_gnu_ld=$lt_with_gnu_ld
 
-# Flag that allows shared libraries with undefined symbols to be built.
-allow_undefined_flag=$lt_allow_undefined_flag
+} # as_fn_mkdir_p
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
 
-# Flag that enforces no undefined symbols.
-no_undefined_flag=$lt_no_undefined_flag
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+	test -d "$1/.";
+      else
+	case $1 in #(
+	-*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
 
-# Flag to hardcode \$libdir into a binary during linking.
-# This must work even if \$libdir does not exist
-hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
 
-# If ld is used when linking, flag to hardcode \$libdir into a binary
-# during linking.  This must work even if \$libdir does not exist.
-hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
 
-# Whether we need a single "-rpath" flag with a separated argument.
-hardcode_libdir_separator=$lt_hardcode_libdir_separator
 
-# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
-# DIR into the resulting binary.
-hardcode_direct=$hardcode_direct
+exec 6>&1
+## ----------------------------------- ##
+## Main body of $CONFIG_STATUS script. ##
+## ----------------------------------- ##
+_ASEOF
+test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
 
-# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
-# DIR into the resulting binary and the resulting library dependency is
-# "absolute",i.e impossible to change by setting \${shlibpath_var} if the
-# library is relocated.
-hardcode_direct_absolute=$hardcode_direct_absolute
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# Save the log message, to keep $0 and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.
+ac_log="
+This file was extended by gdl $as_me 0.9rc4 CVS, which was
+generated by GNU Autoconf 2.65.  Invocation command line was
 
-# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
-# into the resulting binary.
-hardcode_minus_L=$hardcode_minus_L
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
 
-# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
-# into the resulting binary.
-hardcode_shlibpath_var=$hardcode_shlibpath_var
+on `(hostname || uname -n) 2>/dev/null | sed 1q`
+"
 
-# Set to "yes" if building a shared library automatically hardcodes DIR
-# into the library and all subsequent libraries and executables linked
-# against it.
-hardcode_automatic=$hardcode_automatic
+_ACEOF
 
-# Set to yes if linker adds runtime paths of dependent libraries
-# to runtime path list.
-inherit_rpath=$inherit_rpath
+case $ac_config_files in *"
+"*) set x $ac_config_files; shift; ac_config_files=$*;;
+esac
 
-# Whether libtool must link a program against all its dependency libraries.
-link_all_deplibs=$link_all_deplibs
+case $ac_config_headers in *"
+"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
+esac
 
-# Fix the shell variable \$srcfile for the compiler.
-fix_srcfile_path=$lt_fix_srcfile_path
 
-# Set to "yes" if exported symbols are required.
-always_export_symbols=$always_export_symbols
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+# Files that config.status was made for.
+config_files="$ac_config_files"
+config_headers="$ac_config_headers"
+config_commands="$ac_config_commands"
 
-# The commands to list exported symbols.
-export_symbols_cmds=$lt_export_symbols_cmds
+_ACEOF
 
-# Symbols that should not be listed in the preloaded symbols.
-exclude_expsyms=$lt_exclude_expsyms
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+ac_cs_usage="\
+\`$as_me' instantiates files and other configuration actions
+from templates according to the current configuration.  Unless the files
+and actions are specified as TAGs, all are instantiated by default.
 
-# Symbols that must always be exported.
-include_expsyms=$lt_include_expsyms
+Usage: $0 [OPTION]... [TAG]...
 
-# Commands necessary for linking programs (against libraries) with templates.
-prelink_cmds=$lt_prelink_cmds
+  -h, --help       print this help, then exit
+  -V, --version    print version number and configuration settings, then exit
+      --config     print configuration, then exit
+  -q, --quiet, --silent
+                   do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+      --file=FILE[:TEMPLATE]
+                   instantiate the configuration file FILE
+      --header=FILE[:TEMPLATE]
+                   instantiate the configuration header FILE
 
-# Specify filename containing input files.
-file_list_spec=$lt_file_list_spec
+Configuration files:
+$config_files
 
-# How to hardcode a shared library path into an executable.
-hardcode_action=$hardcode_action
+Configuration headers:
+$config_headers
 
-# The directories searched by this compiler when creating a shared library.
-compiler_lib_search_dirs=$lt_compiler_lib_search_dirs
+Configuration commands:
+$config_commands
 
-# Dependencies to place before and after the objects being linked to
-# create a shared library.
-predep_objects=$lt_predep_objects
-postdep_objects=$lt_postdep_objects
-predeps=$lt_predeps
-postdeps=$lt_postdeps
+Report bugs to the package provider."
 
-# The library search path used internally by the compiler when linking
-# a shared library.
-compiler_lib_search_path=$lt_compiler_lib_search_path
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
+ac_cs_version="\\
+gdl config.status 0.9rc4 CVS
+configured by $0, generated by GNU Autoconf 2.65,
+  with options \\"\$ac_cs_config\\"
 
-# ### END LIBTOOL CONFIG
+Copyright (C) 2009 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
 
-_LT_EOF
+ac_pwd='$ac_pwd'
+srcdir='$srcdir'
+INSTALL='$INSTALL'
+AWK='$AWK'
+test -n "\$AWK" || AWK=awk
+_ACEOF
 
-  case $host_os in
-  aix3*)
-    cat <<\_LT_EOF >> "$cfgfile"
-# AIX sometimes has problems with the GCC collect2 program.  For some
-# reason, if we set the COLLECT_NAMES environment variable, the problems
-# vanish in a puff of smoke.
-if test "X${COLLECT_NAMES+set}" != Xset; then
-  COLLECT_NAMES=
-  export COLLECT_NAMES
-fi
-_LT_EOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# The default lists apply if the user does not specify any file.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=*)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  *)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
     ;;
   esac
 
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
+    $as_echo "$ac_cs_version"; exit ;;
+  --config | --confi | --conf | --con | --co | --c )
+    $as_echo "$ac_cs_config"; exit ;;
+  --debug | --debu | --deb | --de | --d | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    as_fn_append CONFIG_FILES " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    as_fn_append CONFIG_HEADERS " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --he | --h)
+    # Conflict between --help and --header
+    as_fn_error "ambiguous option: \`$1'
+Try \`$0 --help' for more information.";;
+  --help | --hel | -h )
+    $as_echo "$ac_cs_usage"; exit ;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
 
-ltmain="$ac_aux_dir/ltmain.sh"
-
-
-  # We use sed instead of cat because bash on DJGPP gets confused if
-  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
-  # text mode, it properly converts lines to CR/LF.  This bash problem
-  # is reportedly fixed, but why not run on old versions too?
-  sed '/^# Generated shell functions inserted here/q' "$ltmain" >> "$cfgfile" \
-    || (rm -f "$cfgfile"; exit 1)
-
-  case $xsi_shell in
-  yes)
-    cat << \_LT_EOF >> "$cfgfile"
-
-# func_dirname file append nondir_replacement
-# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
-# otherwise set result to NONDIR_REPLACEMENT.
-func_dirname ()
-{
-  case ${1} in
-    */*) func_dirname_result="${1%/*}${2}" ;;
-    *  ) func_dirname_result="${3}" ;;
-  esac
-}
+  # This is an error.
+  -*) as_fn_error "unrecognized option: \`$1'
+Try \`$0 --help' for more information." ;;
 
-# func_basename file
-func_basename ()
-{
-  func_basename_result="${1##*/}"
-}
+  *) as_fn_append ac_config_targets " $1"
+     ac_need_defaults=false ;;
 
-# func_dirname_and_basename file append nondir_replacement
-# perform func_basename and func_dirname in a single function
-# call:
-#   dirname:  Compute the dirname of FILE.  If nonempty,
-#             add APPEND to the result, otherwise set result
-#             to NONDIR_REPLACEMENT.
-#             value returned in "$func_dirname_result"
-#   basename: Compute filename of FILE.
-#             value retuned in "$func_basename_result"
-# Implementation must be kept synchronized with func_dirname
-# and func_basename. For efficiency, we do not delegate to
-# those functions but instead duplicate the functionality here.
-func_dirname_and_basename ()
-{
-  case ${1} in
-    */*) func_dirname_result="${1%/*}${2}" ;;
-    *  ) func_dirname_result="${3}" ;;
   esac
-  func_basename_result="${1##*/}"
-}
-
-# func_stripname prefix suffix name
-# strip PREFIX and SUFFIX off of NAME.
-# PREFIX and SUFFIX must not contain globbing or regex special
-# characters, hashes, percent signs, but SUFFIX may contain a leading
-# dot (in which case that matches only a dot).
-func_stripname ()
-{
-  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
-  # positional parameters, so assign one to ordinary parameter first.
-  func_stripname_result=${3}
-  func_stripname_result=${func_stripname_result#"${1}"}
-  func_stripname_result=${func_stripname_result%"${2}"}
-}
-
-# func_opt_split
-func_opt_split ()
-{
-  func_opt_split_opt=${1%%=*}
-  func_opt_split_arg=${1#*=}
-}
+  shift
+done
 
-# func_lo2o object
-func_lo2o ()
-{
-  case ${1} in
-    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
-    *)    func_lo2o_result=${1} ;;
-  esac
-}
+ac_configure_extra_args=
 
-# func_xform libobj-or-source
-func_xform ()
-{
-  func_xform_result=${1%.*}.lo
-}
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
 
-# func_arith arithmetic-term...
-func_arith ()
-{
-  func_arith_result=$(( $* ))
-}
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+if \$ac_cs_recheck; then
+  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  shift
+  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
+  CONFIG_SHELL='$SHELL'
+  export CONFIG_SHELL
+  exec "\$@"
+fi
 
-# func_len string
-# STRING may not start with a hyphen.
-func_len ()
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+exec 5>>config.log
 {
-  func_len_result=${#1}
-}
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+  $as_echo "$ac_log"
+} >&5
 
-_LT_EOF
-    ;;
-  *) # Bourne compatible functions.
-    cat << \_LT_EOF >> "$cfgfile"
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+#
+# INIT-COMMANDS
+#
+AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
 
-# func_dirname file append nondir_replacement
-# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
-# otherwise set result to NONDIR_REPLACEMENT.
-func_dirname ()
-{
-  # Extract subdirectory from the argument.
-  func_dirname_result=`$ECHO "X${1}" | $Xsed -e "$dirname"`
-  if test "X$func_dirname_result" = "X${1}"; then
-    func_dirname_result="${3}"
-  else
-    func_dirname_result="$func_dirname_result${2}"
-  fi
-}
+_ACEOF
 
-# func_basename file
-func_basename ()
-{
-  func_basename_result=`$ECHO "X${1}" | $Xsed -e "$basename"`
-}
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 
+# Handling of arguments.
+for ac_config_target in $ac_config_targets
+do
+  case $ac_config_target in
+    "config.h") CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
+    "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
+    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+    "src/Makefile") CONFIG_FILES="$CONFIG_FILES src/Makefile" ;;
+    "src/antlr/Makefile") CONFIG_FILES="$CONFIG_FILES src/antlr/Makefile" ;;
+    "src/pro/Makefile") CONFIG_FILES="$CONFIG_FILES src/pro/Makefile" ;;
+    "src/pro/dicom/Makefile") CONFIG_FILES="$CONFIG_FILES src/pro/dicom/Makefile" ;;
+    "testsuite/Makefile") CONFIG_FILES="$CONFIG_FILES testsuite/Makefile" ;;
+    "doc/Makefile") CONFIG_FILES="$CONFIG_FILES doc/Makefile" ;;
 
-# func_stripname prefix suffix name
-# strip PREFIX and SUFFIX off of NAME.
-# PREFIX and SUFFIX must not contain globbing or regex special
-# characters, hashes, percent signs, but SUFFIX may contain a leading
-# dot (in which case that matches only a dot).
-# func_strip_suffix prefix name
-func_stripname ()
-{
-  case ${2} in
-    .*) func_stripname_result=`$ECHO "X${3}" \
-           | $Xsed -e "s%^${1}%%" -e "s%\\\\${2}\$%%"`;;
-    *)  func_stripname_result=`$ECHO "X${3}" \
-           | $Xsed -e "s%^${1}%%" -e "s%${2}\$%%"`;;
+  *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
   esac
-}
-
-# sed scripts:
-my_sed_long_opt='1s/^\(-[^=]*\)=.*/\1/;q'
-my_sed_long_arg='1s/^-[^=]*=//'
-
-# func_opt_split
-func_opt_split ()
-{
-  func_opt_split_opt=`$ECHO "X${1}" | $Xsed -e "$my_sed_long_opt"`
-  func_opt_split_arg=`$ECHO "X${1}" | $Xsed -e "$my_sed_long_arg"`
-}
-
-# func_lo2o object
-func_lo2o ()
-{
-  func_lo2o_result=`$ECHO "X${1}" | $Xsed -e "$lo2o"`
-}
+done
 
-# func_xform libobj-or-source
-func_xform ()
-{
-  func_xform_result=`$ECHO "X${1}" | $Xsed -e 's/\.[^.]*$/.lo/'`
-}
 
-# func_arith arithmetic-term...
-func_arith ()
-{
-  func_arith_result=`expr "$@"`
-}
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
 
-# func_len string
-# STRING may not start with a hyphen.
-func_len ()
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason against having it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Hook for its removal unless debugging.
+# Note that there is a small window in which the directory will not be cleaned:
+# after its creation but before its name has been assigned to `$tmp'.
+$debug ||
 {
-  func_len_result=`expr "$1" : ".*" 2>/dev/null || echo $max_cmd_len`
+  tmp=
+  trap 'exit_status=$?
+  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
+' 0
+  trap 'as_fn_exit 1' 1 2 13 15
 }
+# Create a (secure) tmp directory for tmp files.
 
-_LT_EOF
-esac
-
-case $lt_shell_append in
-  yes)
-    cat << \_LT_EOF >> "$cfgfile"
-
-# func_append var value
-# Append VALUE to the end of shell variable VAR.
-func_append ()
 {
-  eval "$1+=\$2"
-}
-_LT_EOF
-    ;;
-  *)
-    cat << \_LT_EOF >> "$cfgfile"
-
-# func_append var value
-# Append VALUE to the end of shell variable VAR.
-func_append ()
+  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  test -n "$tmp" && test -d "$tmp"
+}  ||
 {
-  eval "$1=\$$1\$2"
-}
-
-_LT_EOF
-    ;;
-  esac
-
-
-  sed -n '/^# Generated shell functions inserted here/,$p' "$ltmain" >> "$cfgfile" \
-    || (rm -f "$cfgfile"; exit 1)
-
-  mv -f "$cfgfile" "$ofile" ||
-    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
-  chmod +x "$ofile"
-
-
-    cat <<_LT_EOF >> "$ofile"
-
-# ### BEGIN LIBTOOL TAG CONFIG: CXX
-
-# The linker used to build libraries.
-LD=$lt_LD_CXX
-
-# Commands used to build an old-style archive.
-old_archive_cmds=$lt_old_archive_cmds_CXX
-
-# A language specific compiler.
-CC=$lt_compiler_CXX
-
-# Is the compiler the GNU compiler?
-with_gcc=$GCC_CXX
-
-# Compiler flag to turn off builtin functions.
-no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag_CXX
-
-# How to pass a linker flag through the compiler.
-wl=$lt_lt_prog_compiler_wl_CXX
-
-# Additional compiler flags for building library objects.
-pic_flag=$lt_lt_prog_compiler_pic_CXX
+  tmp=./conf$$-$RANDOM
+  (umask 077 && mkdir "$tmp")
+} || as_fn_error "cannot create a temporary directory in ." "$LINENO" 5
 
-# Compiler flag to prevent dynamic linking.
-link_static_flag=$lt_lt_prog_compiler_static_CXX
+# Set up the scripts for CONFIG_FILES section.
+# No need to generate them if there are no CONFIG_FILES.
+# This happens for instance with `./config.status config.h'.
+if test -n "$CONFIG_FILES"; then
 
-# Does compiler simultaneously support -c and -o options?
-compiler_c_o=$lt_lt_cv_prog_compiler_c_o_CXX
 
-# Whether or not to add -lc for building shared libraries.
-build_libtool_need_lc=$archive_cmds_need_lc_CXX
+ac_cr=`echo X | tr X '\015'`
+# On cygwin, bash can eat \r inside `` if the user requested igncr.
+# But we know of no other shell where ac_cr would be empty at this
+# point, so we can use a bashism as a fallback.
+if test "x$ac_cr" = x; then
+  eval ac_cr=\$\'\\r\'
+fi
+ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
+if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
+  ac_cs_awk_cr='\r'
+else
+  ac_cs_awk_cr=$ac_cr
+fi
 
-# Whether or not to disallow shared libs when runtime libs are static.
-allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes_CXX
+echo 'BEGIN {' >"$tmp/subs1.awk" &&
+_ACEOF
 
-# Compiler flag to allow reflexive dlopens.
-export_dynamic_flag_spec=$lt_export_dynamic_flag_spec_CXX
 
-# Compiler flag to generate shared objects directly from archives.
-whole_archive_flag_spec=$lt_whole_archive_flag_spec_CXX
+{
+  echo "cat >conf$$subs.awk <<_ACEOF" &&
+  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
+  echo "_ACEOF"
+} >conf$$subs.sh ||
+  as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
+ac_delim='%!_!# '
+for ac_last_try in false false false false false :; do
+  . ./conf$$subs.sh ||
+    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
 
-# Whether the compiler copes with passing no objects directly.
-compiler_needs_object=$lt_compiler_needs_object_CXX
+  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
+  if test $ac_delim_n = $ac_delim_num; then
+    break
+  elif $ac_last_try; then
+    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+rm -f conf$$subs.sh
 
-# Create an old-style archive from a shared archive.
-old_archive_from_new_cmds=$lt_old_archive_from_new_cmds_CXX
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
+_ACEOF
+sed -n '
+h
+s/^/S["/; s/!.*/"]=/
+p
+g
+s/^[^!]*!//
+:repl
+t repl
+s/'"$ac_delim"'$//
+t delim
+:nl
+h
+s/\(.\{148\}\)..*/\1/
+t more1
+s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
+p
+n
+b repl
+:more1
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t nl
+:delim
+h
+s/\(.\{148\}\)..*/\1/
+t more2
+s/["\\]/\\&/g; s/^/"/; s/$/"/
+p
+b
+:more2
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t delim
+' <conf$$subs.awk | sed '
+/^[^""]/{
+  N
+  s/\n//
+}
+' >>$CONFIG_STATUS || ac_write_fail=1
+rm -f conf$$subs.awk
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+_ACAWK
+cat >>"\$tmp/subs1.awk" <<_ACAWK &&
+  for (key in S) S_is_set[key] = 1
+  FS = ""
 
-# Create a temporary old-style archive to link instead of a shared archive.
-old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds_CXX
+}
+{
+  line = $ 0
+  nfields = split(line, field, "@")
+  substed = 0
+  len = length(field[1])
+  for (i = 2; i < nfields; i++) {
+    key = field[i]
+    keylen = length(key)
+    if (S_is_set[key]) {
+      value = S[key]
+      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
+      len += length(value) + length(field[++i])
+      substed = 1
+    } else
+      len += 1 + keylen
+  }
 
-# Commands used to build a shared archive.
-archive_cmds=$lt_archive_cmds_CXX
-archive_expsym_cmds=$lt_archive_expsym_cmds_CXX
+  print line
+}
 
-# Commands used to build a loadable module if different from building
-# a shared archive.
-module_cmds=$lt_module_cmds_CXX
-module_expsym_cmds=$lt_module_expsym_cmds_CXX
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
+  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
+else
+  cat
+fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
+  || as_fn_error "could not setup config files machinery" "$LINENO" 5
+_ACEOF
 
-# Whether we are building with GNU ld or not.
-with_gnu_ld=$lt_with_gnu_ld_CXX
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/
+s/:*\${srcdir}:*/:/
+s/:*@srcdir@:*/:/
+s/^\([^=]*=[	 ]*\):*/\1/
+s/:*$//
+s/^[^=]*=[	 ]*$//
+}'
+fi
 
-# Flag that allows shared libraries with undefined symbols to be built.
-allow_undefined_flag=$lt_allow_undefined_flag_CXX
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+fi # test -n "$CONFIG_FILES"
 
-# Flag that enforces no undefined symbols.
-no_undefined_flag=$lt_no_undefined_flag_CXX
+# Set up the scripts for CONFIG_HEADERS section.
+# No need to generate them if there are no CONFIG_HEADERS.
+# This happens for instance with `./config.status Makefile'.
+if test -n "$CONFIG_HEADERS"; then
+cat >"$tmp/defines.awk" <<\_ACAWK ||
+BEGIN {
+_ACEOF
 
-# Flag to hardcode \$libdir into a binary during linking.
-# This must work even if \$libdir does not exist
-hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec_CXX
+# Transform confdefs.h into an awk script `defines.awk', embedded as
+# here-document in config.status, that substitutes the proper values into
+# config.h.in to produce config.h.
 
-# If ld is used when linking, flag to hardcode \$libdir into a binary
-# during linking.  This must work even if \$libdir does not exist.
-hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld_CXX
+# Create a delimiter string that does not exist in confdefs.h, to ease
+# handling of long lines.
+ac_delim='%!_!# '
+for ac_last_try in false false :; do
+  ac_t=`sed -n "/$ac_delim/p" confdefs.h`
+  if test -z "$ac_t"; then
+    break
+  elif $ac_last_try; then
+    as_fn_error "could not make $CONFIG_HEADERS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
 
-# Whether we need a single "-rpath" flag with a separated argument.
-hardcode_libdir_separator=$lt_hardcode_libdir_separator_CXX
+# For the awk script, D is an array of macro values keyed by name,
+# likewise P contains macro parameters if any.  Preserve backslash
+# newline sequences.
 
-# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
-# DIR into the resulting binary.
-hardcode_direct=$hardcode_direct_CXX
+ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
+sed -n '
+s/.\{148\}/&'"$ac_delim"'/g
+t rset
+:rset
+s/^[	 ]*#[	 ]*define[	 ][	 ]*/ /
+t def
+d
+:def
+s/\\$//
+t bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3"/p
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2"/p
+d
+:bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3\\\\\\n"\\/p
+t cont
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2\\\\\\n"\\/p
+t cont
+d
+:cont
+n
+s/.\{148\}/&'"$ac_delim"'/g
+t clear
+:clear
+s/\\$//
+t bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/"/p
+d
+:bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/\\\\\\n"\\/p
+b cont
+' <confdefs.h | sed '
+s/'"$ac_delim"'/"\\\
+"/g' >>$CONFIG_STATUS || ac_write_fail=1
 
-# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
-# DIR into the resulting binary and the resulting library dependency is
-# "absolute",i.e impossible to change by setting \${shlibpath_var} if the
-# library is relocated.
-hardcode_direct_absolute=$hardcode_direct_absolute_CXX
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  for (key in D) D_is_set[key] = 1
+  FS = ""
+}
+/^[\t ]*#[\t ]*(define|undef)[\t ]+$ac_word_re([\t (]|\$)/ {
+  line = \$ 0
+  split(line, arg, " ")
+  if (arg[1] == "#") {
+    defundef = arg[2]
+    mac1 = arg[3]
+  } else {
+    defundef = substr(arg[1], 2)
+    mac1 = arg[2]
+  }
+  split(mac1, mac2, "(") #)
+  macro = mac2[1]
+  prefix = substr(line, 1, index(line, defundef) - 1)
+  if (D_is_set[macro]) {
+    # Preserve the white space surrounding the "#".
+    print prefix "define", macro P[macro] D[macro]
+    next
+  } else {
+    # Replace #undef with comments.  This is necessary, for example,
+    # in the case of _POSIX_SOURCE, which is predefined and required
+    # on some systems where configure will not decide to define it.
+    if (defundef == "undef") {
+      print "/*", prefix defundef, macro, "*/"
+      next
+    }
+  }
+}
+{ print }
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+  as_fn_error "could not setup config headers machinery" "$LINENO" 5
+fi # test -n "$CONFIG_HEADERS"
 
-# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
-# into the resulting binary.
-hardcode_minus_L=$hardcode_minus_L_CXX
 
-# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
-# into the resulting binary.
-hardcode_shlibpath_var=$hardcode_shlibpath_var_CXX
+eval set X "  :F $CONFIG_FILES  :H $CONFIG_HEADERS    :C $CONFIG_COMMANDS"
+shift
+for ac_tag
+do
+  case $ac_tag in
+  :[FHLC]) ac_mode=$ac_tag; continue;;
+  esac
+  case $ac_mode$ac_tag in
+  :[FHL]*:*);;
+  :L* | :C*:*) as_fn_error "invalid tag \`$ac_tag'" "$LINENO" 5;;
+  :[FH]-) ac_tag=-:-;;
+  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
+  esac
+  ac_save_IFS=$IFS
+  IFS=:
+  set x $ac_tag
+  IFS=$ac_save_IFS
+  shift
+  ac_file=$1
+  shift
 
-# Set to "yes" if building a shared library automatically hardcodes DIR
-# into the library and all subsequent libraries and executables linked
-# against it.
-hardcode_automatic=$hardcode_automatic_CXX
+  case $ac_mode in
+  :L) ac_source=$1;;
+  :[FH])
+    ac_file_inputs=
+    for ac_f
+    do
+      case $ac_f in
+      -) ac_f="$tmp/stdin";;
+      *) # Look for the file first in the build tree, then in the source tree
+	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+	 # because $ac_f cannot contain `:'.
+	 test -f "$ac_f" ||
+	   case $ac_f in
+	   [\\/$]*) false;;
+	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
+	   esac ||
+	   as_fn_error "cannot find input file: \`$ac_f'" "$LINENO" 5;;
+      esac
+      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
+      as_fn_append ac_file_inputs " '$ac_f'"
+    done
 
-# Set to yes if linker adds runtime paths of dependent libraries
-# to runtime path list.
-inherit_rpath=$inherit_rpath_CXX
+    # Let's still pretend it is `configure' which instantiates (i.e., don't
+    # use $as_me), people would be surprised to read:
+    #    /* config.h.  Generated by config.status.  */
+    configure_input='Generated from '`
+	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
+	`' by configure.'
+    if test x"$ac_file" != x-; then
+      configure_input="$ac_file.  $configure_input"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
+$as_echo "$as_me: creating $ac_file" >&6;}
+    fi
+    # Neutralize special characters interpreted by sed in replacement strings.
+    case $configure_input in #(
+    *\&* | *\|* | *\\* )
+       ac_sed_conf_input=`$as_echo "$configure_input" |
+       sed 's/[\\\\&|]/\\\\&/g'`;; #(
+    *) ac_sed_conf_input=$configure_input;;
+    esac
 
-# Whether libtool must link a program against all its dependency libraries.
-link_all_deplibs=$link_all_deplibs_CXX
+    case $ac_tag in
+    *:-:* | *:-) cat >"$tmp/stdin" \
+      || as_fn_error "could not create $ac_file" "$LINENO" 5 ;;
+    esac
+    ;;
+  esac
 
-# Fix the shell variable \$srcfile for the compiler.
-fix_srcfile_path=$lt_fix_srcfile_path_CXX
+  ac_dir=`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  as_dir="$ac_dir"; as_fn_mkdir_p
+  ac_builddir=.
 
-# Set to "yes" if exported symbols are required.
-always_export_symbols=$always_export_symbols_CXX
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
 
-# The commands to list exported symbols.
-export_symbols_cmds=$lt_export_symbols_cmds_CXX
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
 
-# Symbols that should not be listed in the preloaded symbols.
-exclude_expsyms=$lt_exclude_expsyms_CXX
 
-# Symbols that must always be exported.
-include_expsyms=$lt_include_expsyms_CXX
+  case $ac_mode in
+  :F)
+  #
+  # CONFIG_FILE
+  #
 
-# Commands necessary for linking programs (against libraries) with templates.
-prelink_cmds=$lt_prelink_cmds_CXX
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
+  esac
+_ACEOF
 
-# Specify filename containing input files.
-file_list_spec=$lt_file_list_spec_CXX
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# If the template does not know about datarootdir, expand it.
+# FIXME: This hack should be removed a few years after 2.60.
+ac_datarootdir_hack=; ac_datarootdir_seen=
+ac_sed_dataroot='
+/datarootdir/ {
+  p
+  q
+}
+/@datadir@/p
+/@docdir@/p
+/@infodir@/p
+/@localedir@/p
+/@mandir@/p'
+case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
+*datarootdir*) ac_datarootdir_seen=yes;;
+*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  ac_datarootdir_hack='
+  s&@datadir@&$datadir&g
+  s&@docdir@&$docdir&g
+  s&@infodir@&$infodir&g
+  s&@localedir@&$localedir&g
+  s&@mandir@&$mandir&g
+  s&\\\${datarootdir}&$datarootdir&g' ;;
+esac
+_ACEOF
 
-# How to hardcode a shared library path into an executable.
-hardcode_action=$hardcode_action_CXX
+# Neutralize VPATH when `$srcdir' = `.'.
+# Shell code in configure.ac might set extrasub.
+# FIXME: do we really want to maintain this feature?
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_sed_extra="$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s|@configure_input@|$ac_sed_conf_input|;t t
+s&@top_builddir@&$ac_top_builddir_sub&;t t
+s&@top_build_prefix@&$ac_top_build_prefix&;t t
+s&@srcdir@&$ac_srcdir&;t t
+s&@abs_srcdir@&$ac_abs_srcdir&;t t
+s&@top_srcdir@&$ac_top_srcdir&;t t
+s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
+s&@builddir@&$ac_builddir&;t t
+s&@abs_builddir@&$ac_abs_builddir&;t t
+s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
+s&@INSTALL@&$ac_INSTALL&;t t
+$ac_datarootdir_hack
+"
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
+  || as_fn_error "could not create $ac_file" "$LINENO" 5
 
-# The directories searched by this compiler when creating a shared library.
-compiler_lib_search_dirs=$lt_compiler_lib_search_dirs_CXX
+test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&5
+$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined." >&2;}
 
-# Dependencies to place before and after the objects being linked to
-# create a shared library.
-predep_objects=$lt_predep_objects_CXX
-postdep_objects=$lt_postdep_objects_CXX
-predeps=$lt_predeps_CXX
-postdeps=$lt_postdeps_CXX
+  rm -f "$tmp/stdin"
+  case $ac_file in
+  -) cat "$tmp/out" && rm -f "$tmp/out";;
+  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
+  esac \
+  || as_fn_error "could not create $ac_file" "$LINENO" 5
+ ;;
+  :H)
+  #
+  # CONFIG_HEADER
+  #
+  if test x"$ac_file" != x-; then
+    {
+      $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs"
+    } >"$tmp/config.h" \
+      || as_fn_error "could not create $ac_file" "$LINENO" 5
+    if diff "$ac_file" "$tmp/config.h" >/dev/null 2>&1; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
+$as_echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      rm -f "$ac_file"
+      mv "$tmp/config.h" "$ac_file" \
+	|| as_fn_error "could not create $ac_file" "$LINENO" 5
+    fi
+  else
+    $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$tmp/defines.awk"' "$ac_file_inputs" \
+      || as_fn_error "could not create -" "$LINENO" 5
+  fi
+# Compute "$ac_file"'s index in $config_headers.
+_am_stamp_count=1
+for _am_header in $config_headers :; do
+  case $_am_header in
+    "$ac_file" | "$ac_file":* )
+      break ;;
+    * )
+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
+  esac
+done
+echo "timestamp for "$ac_file"" >`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`/stamp-h$_am_stamp_count
+ ;;
 
-# The library search path used internally by the compiler when linking
-# a shared library.
-compiler_lib_search_path=$lt_compiler_lib_search_path_CXX
+  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
+$as_echo "$as_me: executing $ac_file commands" >&6;}
+ ;;
+  esac
 
-# ### END LIBTOOL TAG CONFIG: CXX
-_LT_EOF
 
+  case $ac_file$ac_mode in
+    "depfiles":C) test x"$AMDEP_TRUE" != x"" || for mf in $CONFIG_FILES; do
+  # Strip MF so we end up with the name of the file.
+  mf=`echo "$mf" | sed -e 's/:.*$//'`
+  # Check whether this is an Automake generated Makefile or not.
+  # We used to match only the files named `Makefile.in', but
+  # some people rename them; so instead we look at the file content.
+  # Grep'ing the first line is not enough: some people post-process
+  # each Makefile.in and add a new line on top of each file to say so.
+  # So let's grep whole file.
+  if grep '^#.*generated by automake' $mf > /dev/null 2>&1; then
+    dirpart=`$as_dirname -- "$mf" ||
+$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$mf" : 'X\(//\)[^/]' \| \
+	 X"$mf" : 'X\(//\)$' \| \
+	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$mf" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  else
+    continue
+  fi
+  # Extract the definition of DEPDIR, am__include, and am__quote
+  # from the Makefile without running `make'.
+  DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+  test -z "$DEPDIR" && continue
+  am__include=`sed -n 's/^am__include = //p' < "$mf"`
+  test -z "am__include" && continue
+  am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+  # When using ansi2knr, U may be empty or an underscore; expand it
+  U=`sed -n 's/^U = //p' < "$mf"`
+  # Find all dependency output files, they are included files with
+  # $(DEPDIR) in their names.  We invoke sed twice because it is the
+  # simplest approach to changing $(DEPDIR) to its actual value in the
+  # expansion.
+  for file in `sed -n "
+    s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+       sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+    # Make sure the directory exists.
+    test -f "$dirpart/$file" && continue
+    fdir=`$as_dirname -- "$file" ||
+$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$file" : 'X\(//\)[^/]' \| \
+	 X"$file" : 'X\(//\)$' \| \
+	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+    as_dir=$dirpart/$fdir; as_fn_mkdir_p
+    # echo "creating $dirpart/$file"
+    echo '# dummy' > "$dirpart/$file"
+  done
+done
  ;;
 
   esac
@@ -19872,7 +23457,9 @@
   Installation prefix: $prefix
   C++ compiler:        $CXX $CXXFLAGS
   OpenMP support:      `if test "x$with_openmp" = "xno";
-    then echo 'no'; else echo 'yes (use --with-openmp=no if your compiler does not support it)'; fi`
+    then echo 'no'; else echo 'yes'; fi`
+  Build type:          `if test "x$PYTHON_MODULE" = "xyes";
+    then echo 'library (Python module)'; else echo 'standalone (other: Python module)'; fi`
   ----- optional libraries (consult README/INSTALL): ---
   wxWidgets:           `if test no = $with_wxWidgets;
     then echo 'no  (needs explicit enabling)'; else echo yes; fi`
@@ -19885,7 +23472,7 @@
   HDF5:                `if test no = $with_hdf5;
     then echo 'no'; else echo yes; fi`
   FFTW:                `if test no = $with_fftw;
-    then echo 'no  (GSL version used by default)'; else echo yes; fi`
+    then echo 'no  (GSL version used)'; else echo yes; fi`
   libproject:          `if test no = $with_libproj4;
     then echo 'no  (see also MAP_INSTALL)'; else echo yes; fi`
   MPICH:               `if test no = $with_mpich;
@@ -19896,12 +23483,22 @@
     then echo 'no  (needs explicit enabling)'; else echo yes; fi`
   GRIB:                `if test no = $with_grib;
     then echo 'no  (needs explicit enabling)'; else echo yes; fi`
+  GSHHS:               `if test no = $with_gshhs;
+    then echo 'no  (see also MAP_INSTALL)'; else echo yes; fi`
+  Xlib:                `if test xyes = x$no_x;
+    then echo 'no'; else echo yes; fi`
   ----- notes on auxiliary files: ----------------------
   - consult MAP_INSTALL for details concerning auxiliary
     files needed for mapping support
   - SAVE and RESTORE procedures require *.pro files from
     the CMSVLIB package (see README for details)
   ------------------------------------------------------
+`if test yes = $openmp_autodetected; then
+  echo '  ----- note on OpenMP support -------------------------'
+  echo '   OpenMP was autodetected, use --with-openmp=no if your'
+  echo '   compiler does not support it (e.g. GCC < 4.2)'
+  echo '  ------------------------------------------------------'; fi`
   use 'make' to build and 'make install' to install GDL
+  (optional 'make check' tests the build - experimental)
 "
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/configure.in cvs/gdl/configure.in
--- gdl-0.9rc4/configure.in	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/configure.in	2010-07-07 14:40:58.457941669 -0600
@@ -1,4 +1,4 @@
-AC_INIT(gdl, 0.9rc4)
+AC_INIT(gdl, 0.9rc4 CVS)
 AC_CONFIG_MACRO_DIR([m4])
 
 dnl == Configuration (of the configure script)  ============
@@ -18,10 +18,11 @@
 if test "x$with_netcdf"      = "x"; then with_netcdf=yes;      fi
 if test "x$with_hdf"         = "x"; then with_hdf=yes;         fi
 if test "x$with_hdf5"        = "x"; then with_hdf5=yes;        fi
-if test "x$with_fftw"        = "x"; then with_fftw=no;         fi
+if test "x$with_fftw"        = "x"; then with_fftw=auto;       fi
 if test "x$with_libproj4"    = "x"; then with_libproj4=no;     fi
 if test "x$with_mpich"       = "x"; then with_mpich=no;        fi
 if test "x$with_python"      = "x"; then with_python=yes;      fi
+if test "x$with_gshhs"       = "x"; then with_gshhs=no;        fi
 
 dnl default DATADIR subdirectory 
 datasubdir="gnudatalanguage"
@@ -52,6 +53,11 @@
 AC_SUBST(HAVE_64BIT_OS)
 AC_LANG_RESTORE
 
+AC_SEARCH_LIBS([dlopen], [dl])
+if test x"$ac_cv_search_dlopen" = x-ldl; then
+LIBS="$LIBS -ldl"
+fi
+
 dnl == Python module (calling GDL from Python) =============
 dnl ========================================================
 
@@ -183,14 +189,14 @@
 	[with_openmp="$withval" ])
 
 dnl default yes if omp.h found
+openmp_autodetected=no
 if test "x$with_openmp" = "x"; then
    AC_CHECK_HEADERS("omp.h", [
      with_openmp=yes
+     openmp_autodetected=yes
      echo ""
      echo "OpenMP enabled (omp.h file was found)."
      echo "Try --with-openmp=no if your compiler does not support it (e.g. GCC < 4.2)"
-     echo "The warnings about unsigned iteration variable can be ignored."
-     echo "See the README for details."
      echo ""
    ], [
      with_openmp=no
@@ -288,6 +294,8 @@
     LIBS="$LIBS -lplplotd -lplplotcxxd"
 fi
 
+dnl LIBS="$LIBS /usr/local/lib/libplplotd.a /usr/local/lib/libplplotcxxd.a"
+
 AC_CHECK_LIB(plplotcxxd, plsexit, [AC_DEFINE([HAVE_LIBPLPLOTCXXD], [1], [plplot library])], 
 	[
 	echo ""
@@ -296,6 +304,20 @@
 	exit -1
 	])
 
+if test "x$with_Magick" != "xno"; then
+  # https://sourceforge.net/tracker/index.php?func=detail&aid=2974380&group_id=97659&atid=618683
+  AC_CHECK_LIB(plplotd, plGetDrvDir, [
+    echo ""
+    echo "Warning! Dynamic drivers have to be disabled in plplot"
+    echo "         to make plplot work with ImageMagic:"
+    echo "         - use the -DENABLE_DYNDRIVERS=OFF cmake option when" 
+    echo "           compiling plplot to disable dynamic drivers in plplot, or"
+    echo "         - use --with-Magick=no here to not use ImageMagick in GDL."
+    echo ""
+  ])
+fi
+
+
 dnl == wxWidgets ===========================================
 dnl ========================================================
 
@@ -324,21 +346,25 @@
     dnl LDFLAGS="$LDFLAGS -Wl,-dylib_file,/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib:/System/Library/Frameworks/OpenGL.framework/Versions/A/Libraries/libGL.dylib"
   fi
 
-  tmp="`wx-config --basename`-`wx-config --release`"
-  AC_CHECK_LIB($tmp, wxFatalSignalHandler, 
-    [AC_DEFINE([HAVE_LIBWXWIDGETS], [1], [wxWidgets library])], [
-      dnl SA: handling the multi-port wxWidgets installation case	 
-      tmp="`wx-config --basename --toolkit=base`-`wx-config --release`"	 
-      AC_CHECK_LIB($tmp, wxInteger_compare, [AC_DEFINE([HAVE_LIBWXWIDGETS], [1])], [
-        echo ""
-        echo "Error! wxWidgets version 2.8 or later is required but was not found"
-        echo "       Use --with-wxWidgets=DIR to specify the wxWidgets directory tree"
-        echo "       Use --with-wxWidgets=no  to not use it"
-        echo "       Check the README or use configure --help for other libraries needed"
-        echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-        exit -1
-      ])
-  ])
+  AC_DEFINE([HAVE_LIBWXWIDGETS], [1], [wxWidgets library])
+
+  # SA: the code below worked for me on Ubuntu and Macports... but it does not work e.g. on Fedora
+  #
+  #tmp="`wx-config --basename`-`wx-config --release`"
+  #AC_CHECK_LIB($tmp, wxFatalSignalHandler, 
+  #  [AC_DEFINE([HAVE_LIBWXWIDGETS], [1], [wxWidgets library])], [
+  #    dnl SA: handling the multi-port wxWidgets installation case	 
+  #    tmp="`wx-config --basename --toolkit=base`-`wx-config --release`"	 
+  #    AC_CHECK_LIB($tmp, wxInteger_compare, [AC_DEFINE([HAVE_LIBWXWIDGETS], [1])], [
+  #      echo ""
+  #      echo "Error! wxWidgets version 2.8 or later is required but was not found"
+  #      echo "       Use --with-wxWidgets=DIR to specify the wxWidgets directory tree"
+  #      echo "       Use --with-wxWidgets=no  to not use it"
+  #      echo "       Check the README or use configure --help for other libraries needed"
+  #      echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
+  #      exit -1
+  #    ])
+  #])
 fi
 
 dnl == ImageMagick =========================================
@@ -380,7 +406,7 @@
         echo "       Use --with-Magick=DIR to specify the ImageMagick directory tree"
         echo "       Use --with-Magick=no  to not use it"
         echo "       Check the README or use configure --help for other libraries needed"
-        echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
+        echo "       (--with-xxxdir = mandatory, --with-xxx = optional (--with-xxx=no to disable))"
         exit -1
       ])
     ]
@@ -547,6 +573,12 @@
 dnl == FFTW ================================================
 dnl ========================================================
 
+if test "x$with_fftw" = "xauto"; then 
+  AC_CHECK_LIB(fftw3, fftw_malloc, [
+    AC_CHECK_LIB(fftw3f, fftwf_malloc, [with_fftw=yes], [with_fftw=no])
+  ], [with_fftw=no])
+fi
+
 AC_ARG_WITH(fftw,	
 	[  --with-fftw[=DIR]         use FFTW package (with optional path DIR) ],
 	[with_fftw="$withval" ])
@@ -813,25 +845,74 @@
     LIBS="$LIBS -lgrib_api"
   fi
 
-  AC_CHECK_LIB(grib_api, grib_handle_new_from_file, [AC_DEFINE([USE_GRIB], [1], [Define if you want to use GRIB])], 
-    AC_MSG_CHECKING([if linking with Jasper helps])
-    echo ""
-    AC_CHECK_LIB(grib_api, grib_handle_clone, [
-      LIBS="$LIBS -ljasper"
+  AC_CHECK_LIB(grib_api, grib_handle_new_from_file, [
       AC_DEFINE([USE_GRIB], [1], [Define if you want to use GRIB])
-    ], [
+    ], [ 
+      AC_MSG_CHECKING([if linking with Jasper helps])
       echo ""
-      echo "Error! GRIB is required but was not found"
-      echo "       Use --with-grib=DIR to specify the GRIB directory tree"
-      echo "       Use --with-grib=no  to not use it"
-      echo "       Check the README or use configure --help for other libraries needed"
-      echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-      exit -1
-    ], [-ljasper])
+      AC_CHECK_LIB(grib_api, grib_handle_clone, [
+        LIBS="$LIBS -ljasper"
+        AC_DEFINE([USE_GRIB], [1], [Define if you want to use GRIB])
+      ], [ 
+        AC_MSG_CHECKING([if linking with Jasper and OpenJPEG helps])
+        echo ""
+        AC_CHECK_LIB(grib_api, grib_handle_delete, [
+          LIBS="$LIBS -ljasper -lopenjpeg"
+          AC_DEFINE([USE_GRIB], [1], [Define if you want to use GRIB])
+        ], [
+          echo ""
+          echo "Error! GRIB is required but was not found"
+          echo "       Use --with-grib=DIR to specify the GRIB directory tree"
+          echo "       Use --with-grib=no  to not use it"
+          echo "       Check the README or use configure --help for other libraries needed"
+          echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
+          exit -1
+        ], [-ljasper -lopenjpeg])
+      ], [-ljasper])
+    ]
   )
 
 fi
 
+dnl == GSHHS ===============================================
+dnl ========================================================
+
+AC_ARG_WITH(gshhs,
+         [  --with-gshhs[=DIR]        use GSHHS package (with optional path DIR) ],
+         [with_gshhs="$withval" ])
+  
+if test "x$with_gshhs" != "xno"; then
+  if test "x$with_gshhs" != "xyes"; then
+    INCLUDES="$INCLUDES -I$with_gshhs/include"
+  fi
+
+  AC_CHECK_HEADERS(gshhs.h, [
+    AC_DEFINE([USE_GSHHS], [1], [Define if you want to use GSHHS])
+  ], [
+    echo ""
+    echo "Error! GSHHS is required but gshhs.h was not found"
+    echo "       Use --with-gshhs=DIR to specify the GSHHS directory tree"
+    echo "       Use --with-gshhs=no  to not use it"
+    echo "       Check the README or use configure --help for other libraries needed"
+    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
+    exit -1
+  ])
+
+fi
+
+dnl == Xlib ================================================
+dnl ========================================================
+
+AC_PATH_X
+if test "x$no_x" = "xyes"; then
+  echo ""
+  echo "Warning! X Window System not detected, building with Xlib calls disabled"
+  echo "         Use --x-includes=DIR and --x-libraries=DIR to pass any needed paths"
+  echo ""
+else
+  AC_DEFINE([HAVE_X], [1], [Define if you want to enable calls to Xlib])
+fi
+
 dnl == installation paths ==================================
 dnl ========================================================
 
@@ -884,6 +965,10 @@
     LIBS="$LIBS -lsocket -lnsl"
     ;;
 
+  *cygwin* )
+    LIBS="$LIBS -lrpc"
+    ;;
+
 dnl  *)
 dnl    AC_MSG_ERROR(unknown system type ${host}.)
 dnl    ;;
@@ -1002,7 +1087,9 @@
   Installation prefix: $prefix
   C++ compiler:        $CXX $CXXFLAGS
   OpenMP support:      `if test "x$with_openmp" = "xno";
-    then echo 'no'; else echo 'yes (use --with-openmp=no if your compiler does not support it)'; fi`
+    then echo 'no'; else echo 'yes'; fi`
+  Build type:          `if test "x$PYTHON_MODULE" = "xyes";
+    then echo 'library (Python module)'; else echo 'standalone (other: Python module)'; fi`
   ----- optional libraries (consult README/INSTALL): ---
   wxWidgets:           `if test no = $with_wxWidgets;
     then echo 'no  (needs explicit enabling)'; else echo yes; fi`
@@ -1015,7 +1102,7 @@
   HDF5:                `if test no = $with_hdf5;
     then echo 'no'; else echo yes; fi`
   FFTW:                `if test no = $with_fftw; 
-    then echo 'no  (GSL version used by default)'; else echo yes; fi`
+    then echo 'no  (GSL version used)'; else echo yes; fi`
   libproject:          `if test no = $with_libproj4;
     then echo 'no  (see also MAP_INSTALL)'; else echo yes; fi`
   MPICH:               `if test no = $with_mpich;
@@ -1026,13 +1113,23 @@
     then echo 'no  (needs explicit enabling)'; else echo yes; fi`
   GRIB:                `if test no = $with_grib;
     then echo 'no  (needs explicit enabling)'; else echo yes; fi`
+  GSHHS:               `if test no = $with_gshhs;
+    then echo 'no  (see also MAP_INSTALL)'; else echo yes; fi`
+  Xlib:                `if test xyes = x$no_x;
+    then echo 'no'; else echo yes; fi`
   ----- notes on auxiliary files: ----------------------
   - consult MAP_INSTALL for details concerning auxiliary
     files needed for mapping support
   - SAVE and RESTORE procedures require *.pro files from 
     the CMSVLIB package (see README for details)
   ------------------------------------------------------
+`if test yes = $openmp_autodetected; then
+  echo '  ----- note on OpenMP support -------------------------'
+  echo '   OpenMP was autodetected, use --with-openmp=no if your'
+  echo '   compiler does not support it (e.g. GCC < 4.2)'
+  echo '  ------------------------------------------------------'; fi`
   use 'make' to build and 'make install' to install GDL
+  (optional 'make check' tests the build - experimental)
 "
 
 dnl == EOF =================================================
Only in gdl-0.9rc4/doc: Makefile
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/doc/www/contribute.html cvs/gdl/doc/www/contribute.html
--- gdl-0.9rc4/doc/www/contribute.html	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/doc/www/contribute.html	2010-01-20 15:20:40.000000000 -0700
@@ -0,0 +1,30 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml"><head><title>GDL Contribute</title>
+
+
+
+<link href="gdl.css" rel="stylesheet" type="text/css"></head><body>
+
+<center><h2>Contributions to <span class="g">G</span><span class="d">D</span><span class="l">L</span></h2></center>
+
+<p>GDL is actively developed and has already a lot of functionality.
+But it is still in beta state as of November 2009.
+Even though it can already be used for many tasks, there are many
+things left to be done.<br>
+Any contributions are very welcome. Currently contributions can be made in C/C++, GDL and python.
+See the files HACKING and PYHTON.txt in the GDL root directory.</p>
+
+<p>Urgent things to do are:</p>
+<ul>
+<li>Library functions and procedures</li>
+<li>Porting GDL to other platforms</li>
+<li>Implementing GUI library functions</li>
+<li>Completing the graphical output system</li>
+<li>Testing and test routines written in GDL</li>
+</ul>
+
+<p>
+Please send your contributions using the <a href="http://sourceforge.net/tracker/?group_id=97659" target="_top">trackers</a>.
+</p>
+
+</body></html>
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/doc/www/credits.html cvs/gdl/doc/www/credits.html
--- gdl-0.9rc4/doc/www/credits.html	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/doc/www/credits.html	2010-07-07 14:40:58.486004616 -0600
@@ -0,0 +1,55 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<title>GDL credits</title>
+<link href="gdl.css" rel="stylesheet" type="text/css" />
+</head>
+
+<body>
+
+<center><h2><span class="g">Cr</span><span class="d">ed</span><span
+class="l">its</span></h2></center>
+
+<p>
+Among many good folks who provided patches and valuable feedback (in alphabetical order):
+</p>
+
+<p>
+<a href="mailto:slayoo@users.sourceforge.net>">Sylwester Arabas</a> 
+<br>
+Library routines, testing, documentation, installation/portability issues 
+</p>
+
+<p>
+<a href="mailto:alaingdl@users.sourceforge.net">Alain Coulais</a> 
+<br>
+Library routines, testing, documentation, presentations 
+</p>
+
+<p>
+<a href="mailto:jomoga@users.sourceforge.net">Joel Gales</a>
+<br>
+Library routines (TV, FFT, HISTOGRAM, HDF support...)
+</p>
+
+<p>
+<a href="mailto:c_lee@users.sourceforge.net">Christopher Lee</a>  
+<br>
+Library routines (ImageMagick, PLOTS, XYOUTS, netCDF support...)
+</p>
+
+<p>
+<a href="mailto:messmer@users.sourceforge.net">Peter Messmer</a> 
+<br>
+Library routines (STREGEXP, GET/SETENV, HDF5 file support...)
+</p>
+
+<p>
+<a href="mailto:m_schellens@users.sourceforge.net">Marc Schellens</a>
+(Project founder)
+<br>
+Compiler, Interpreter, Library routines...
+</p>
+
+
+</body>
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/doc/www/download.html cvs/gdl/doc/www/download.html
--- gdl-0.9rc4/doc/www/download.html	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/doc/www/download.html	2010-04-16 11:22:42.000000000 -0600
@@ -0,0 +1,69 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<title>Download GDL</title>
+<link href="gdl.css" rel="stylesheet" type="text/css" />
+</head>
+
+<body>
+
+<center><h2>Download <span class="g">G</span><span class="d">D</span><span class="l">L</span></h2></center>
+
+<p>
+  GDL compiles "out of the box" on Linux, Mac OS X (since Panther) and several other UNIX systems
+  (see <a href="require.html">requirements</a> for details).
+</p>
+
+<p>
+  The source code distribution is available from the
+  <a href="http://sourceforge.net/projects/gnudatalanguage/" target="_top">SF.net project summary page</a>.
+</p>
+
+<p>
+  The latest development version of GDL can be obtained via CVS - consult the
+  <a href="http://sourceforge.net/projects/gnudatalanguage/develop/" target="_top">SF.net project development page</a>
+  for details. It is also possible to 
+  <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/" target="_top">
+    browse the CVS repository using a web-based interface</a>.
+</p>
+
+<p>
+  There are numerous packaged versions of GDL available for various OSes, including:
+  <ul>
+    <li>Linux
+      <ul>
+        <li><a href="http://koji.fedoraproject.org/koji/packageinfo?packageID=1830" target="_top">Fedora</a>
+        <li><a href="http://packages.debian.org/search?keywords=gnudatalanguage" target="_top">Debian GNU/Linux</a></li>
+        <li><a href="http://gentoo-portage.com/dev-lang/gdl" target="_top">Gentoo</a></li>
+        <li><a href="http://aur.archlinux.org/packages.php?ID=2493" target="_top">Arch Linux</a></li>
+        <li><a href="http://packages.ubuntu.com/gnudatalanguage" target="_top">Ubuntu</a></li>
+      </ul>
+    </li>
+    <li>Mac OS X
+      <ul>
+        <li><a href="http://www.macports.org/ports.php?by=name&substr=gnudatalanguage" target="_top">Macports</a></li>
+        <li><a href="http://hpc.sourceforge.net/" target="_top">HPC page</a></li>
+        <li><a href="http://www.hmug.org/pub/MacOS_X/X/Applications/Science/gdl/" target="_top">HMUG</a></li>
+        <li><a href="http://pdb.finkproject.org/pdb/package.php/gdl" target="_top">Fink</a></li>
+      </ul>
+    </li>
+    <li>BSD
+      <ul>
+        <li><a href="http://www.freebsd.org/cgi/cvsweb.cgi/ports/science/gnudatalanguage/" target="_top">FreeBSD</a></li>
+        <li><a href="http://packages.debian.org/search?keywords=gnudatalanguage" target="_top">Debian GNU/kFreeBSD</a></li>
+      </ul>
+    </li>
+  </ul>
+</p>
+<p>
+  Please do check the version number of the package you intend to use against
+    <a href="http://sourceforge.net/projects/gnudatalanguage/" target="_top">the current GDL source-code release</a>.
+  GDL is still in beta stage of development and thus it is highly recommended to 
+    use a resonably recent version.
+</p>
+<p>
+  Please note as well that several features of GDL depend on compile-time configuration, 
+    and might not be available in pre-built or pre-configured packages.
+</p>
+
+</body>
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/doc/www/feedback.html cvs/gdl/doc/www/feedback.html
--- gdl-0.9rc4/doc/www/feedback.html	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/doc/www/feedback.html	2010-01-20 15:20:40.000000000 -0700
@@ -0,0 +1,23 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<title>GDL Feedback</title>
+<link href="gdl.css" rel="stylesheet" type="text/css" />
+</head>
+
+<body>
+
+<center><h2><span class="g">G</span><span class="d">D</span><span class="l">L</span> Feedback</h2></center>
+
+<p>Your comments are welcome! Let us know what you use GDL for. Or if you don't,
+why not. Which functionality are you missing/would appreciate most for
+comming versions.</p>
+
+<p>Please send your bug reports, complaints, suggestions and comments using the
+<a href="http://sourceforge.net/tracker/?group_id=97659" target="_top">trackers</a>
+or
+<a href="http://sourceforge.net/projects/gnudatalanguage/forums" target="_top">forums</a>.
+
+</p>
+ 
+ </body>
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/doc/www/gdl.css cvs/gdl/doc/www/gdl.css
--- gdl-0.9rc4/doc/www/gdl.css	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/doc/www/gdl.css	2010-01-20 15:20:40.000000000 -0700
@@ -0,0 +1,25 @@
+body{
+	background-color: #ffffff;
+	font-family: Verdana, Geneva, Arial, Helvetica, sans-serif;
+	font-size: 18px;
+	line-height: 20px;
+	color: #000000;
+	width: 540px
+}
+
+a{
+	color: #5555aa; 
+	text-decoration:none;
+	cursor: crosshair
+}
+a:hover{ color: #ee3322}		
+a:active{ color: #eecc00}		
+a:visited{ color: #5566ee}		
+
+p{ margin: 12px}
+
+h2{ line-height: 32px}
+
+.g{ color: #ee3322}
+.d{ color: #eecc00}
+.l{ color: #5566ee}
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/doc/www/home.html cvs/gdl/doc/www/home.html
--- gdl-0.9rc4/doc/www/home.html	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/doc/www/home.html	2010-04-16 11:22:42.000000000 -0600
@@ -0,0 +1,70 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<title>GDL ::. Home</title>
+<link href="gdl.css" rel="stylesheet" type="text/css" />
+</head>
+
+<body>
+
+<center><h2><span class="g">G</span><span class="d">D</span><span class="l">L</span> - <span class="g">G</span>NU <span class="d">D</span>ata <span class="l">L</span>anguage</h2></center>
+
+<p>A free IDL (Interactive Data Language) compatible incremental
+compiler (i. e. runs IDL programs).
+IDL is a registered trademark of <a href="http://www.ittvis.com" target="_self">ITT Visual Information Solutions</a>.</p>
+
+<br />
+
+<center><h3><u>Features</u></h3></center>
+
+<p>Full syntax compatibility with IDL 6.0 and later</p>
+
+<p><b>ALL</b> IDL language elements are supported, including:</p>
+
+<ul>
+    <li>objects, pointers, structs and arrays,</li>
+    <li>system, common block and assoc variables,</li>
+    <li>all operators and datatypes,</li>
+    <li>_EXTRA, _STRICT_EXTRA and _REF_EXTRA keywords...</li>
+</ul>
+
+<p>The file input output system is fully implemented<br/>
+(Exception: For formatted I/O the C() sub-codes are not supported yet)</p>
+
+<p>netCDF files are fully supported.</p>
+<p>HDF files are partially supported.</p>
+<p>Basic support for HDF5 files.</p>
+
+<p>Overall more than 380 library routines are implemented.
+For a sorted list enter HELP,/LIB at the command prompt and look for
+library routines written in GDL in the src/pro subdirectory.</p>
+
+<p>
+<a href="mailto:alaingdl@users.sourceforge.net">Alain Coulais</a> maintains a <a href="http://aramis.obspm.fr/~coulais/IDL_et_GDL/Matrice_IDLvsGDL_intrinsic.html" target="_self">list</a>
+of subroutines available in GDL. 
+</p>
+
+<p>
+SAVE and RESTORE are supported through Craig Markwardt's <a href="http://cow.physics.wisc.edu/~craigm/idl/down/cmsvlib.tar.gz">CMSVLIB library</a>.
+</p>
+
+<p>
+Graphical output is partially implemented. The PLOT, OPLOT, PLOTS,
+ XYOUTS, SURFACE, TVRD and TV commands
+(along with WINDOW, WDELETE, SET_PLOT, WSET, TVLCT) work 
+(important keywords, some !P
+system variable tags and multi-plots are supported) 
+for X windows, z-buffer and postscript output.
+</p>
+
+<p> GDL has an interface to <a href="http://www.python.org" target="_self">python</a> (python routines can be called from GDL).</p>
+<p> GDL can be build as a pyhton module (GDL subroutines can be called from python).</p>
+
+<p>No GUI support (widgets) is implemented so far.</p>
+
+
+ <p>GDL is free software licensed under the <a href="http://www.gnu.org/licenses/gpl.html" target="_self">GPL</a>.</p>
+ 
+</body>
+
+</html>
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/doc/www/index.html cvs/gdl/doc/www/index.html
--- gdl-0.9rc4/doc/www/index.html	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/doc/www/index.html	2010-01-20 15:20:40.000000000 -0700
@@ -0,0 +1,12 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html>
+
+<head>
+<title>GDL - GNU Data Language</title>
+</head>
+
+<frameset cols="145,*">
+   <frame src="menu.html" name="left" noresize>
+   <frame src="home.html" name="right">
+</frameset>
+</html>
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/doc/www/menu.html cvs/gdl/doc/www/menu.html
--- gdl-0.9rc4/doc/www/menu.html	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/doc/www/menu.html	2010-01-27 04:56:10.000000000 -0700
@@ -0,0 +1,32 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<title>GDL ::. menu</title>
+<base target="right"/>
+<link href="gdl.css" rel="stylesheet" type="text/css"/>
+</head>
+
+<body style="width:125px">
+
+
+<h2><span class="g">G</span><span class="d">D</span><span
+class="l">L</span></h2>
+
+<p><a href="home.html">home</a></p>
+<p><a href="screenshot.html">screenshots</a></p>
+<p><a href="require.html">requirements</a></p>
+<p><a href="support.html">support</a></p>
+<p><a href="contribute.html">contribute</a></p>
+<p><a href="feedback.html">feedback</a></p>
+<p><a href="download.html">download</a></p>
+<p><a href="resources.html">resources</a></p>
+<p><a href="credits.html">credits</a></p>
+<p><a href="tdl.html"><span class="g">T</span><span class="d">D</span><span class="l">L</span>?</a></p>
+<br /><br /><br />
+hosted by
+<a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=97659&amp;type=2" width="125" height="37" border="0" alt="SourceForge.net Logo" /></a>
+
+</body>
+
+</html>
+
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/doc/www/require.html cvs/gdl/doc/www/require.html
--- gdl-0.9rc4/doc/www/require.html	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/doc/www/require.html	2010-07-07 14:40:58.632940372 -0600
@@ -0,0 +1,86 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<title>GDL requirements</title>
+<link href="gdl.css" rel="stylesheet" type="text/css" />
+</head>
+
+<body>
+
+<center><h2><span class="g">G</span><span class="d">D</span><span class="l">L</span>  Requirements</h2></center>
+
+<p>Obligatory libraries:</p>
+<ul>
+    <li><a href="http://plplot.sourceforge.net/">plplot</a></li>      
+    <li><a href="http://www.gnu.org/software/gsl">gsl</a></li>         
+    <li><a href="http://tiswww.case.edu/php/chet/readline/rltop.html">readline</a></li>
+</ul>    
+
+<p>Optional libraries:</p>
+<ul>
+    <li>Xlib (part of any X11 distribution)</li>
+    <li><a href="http://www.imagemagick.org/Magick++/">Magick++</a> (ImageMagick's C++ API)</li>   
+    <li><a href="http://www.fftw.org/">FFTW</a> (both float and double versions needed)</li>
+    <li><a href="http://www.unidata.ucar.edu/software/netcdf/">netCDF</a> (v3 or v4)</li>   
+    <li><a href="http://www.hdfgroup.org/products/hdf4/">HDF4</a></li>
+    <li><a href="http://www.hdfgroup.org/HDF5/">HDF5</a></li>
+    <li><a href="http://www.ecmwf.int/products/data/software/grib_api.html">GRIB API</a></li>
+    <li><a href="http://www.unidata.ucar.edu/software/udunits/">UDUNITS-2</a></li>
+    <li><a href="http://www.wxwidgets.org/">wxWidgets</a></li>
+    <li><a href="http://home.comcast.net/~gevenden56/proj/">libproject</a></li>
+    <li><a href="ftp://ftp.soest.hawaii.edu/pwessel/gshhs">GSHHS</a> (see GDL's <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/MAP_INSTALL">MAP_INSTALL</a> file)</li>
+</ul>
+
+<p>The Python interface (see <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/PYTHON.txt">PYTHON.txt</a>) requires:</p>
+<ul>
+    <li><a href="http://www.python.org">Python</a></li>   
+    <li><a href="http://www.stsci.edu/resources/software_hardware/numarray">numarray</a></li>
+</ul>
+
+<p>Useful IDL/GDL-written libraries:</p>
+<ul>
+    <li><a href="http://cow.physics.wisc.edu/~craigm/idl/cmsave.html">CMSVLIB</a> (for SAVE and RESTORE)</li>
+    <li><a href="http://cow.physics.wisc.edu/~craigm/idl/fitting.html">MPFIT</a> (fitting)</li>
+    <li><a href="http://idlastro.gsfc.nasa.gov/">Astron Lib</a> (FITS format I/O, astronomy-related procedures)</li>
+    <li><a href="http://physweb.mnstate.edu/mcraig/textoidl/">TeXtoIDL</a> (Greek letters, special symbols, sub/superscripts via TeX commands)</li>
+</ul>
+
+<p>At least g++ 3.2 (or a similar C++ standard conforming
+compiler) is needed for compiling GDL. 
+Note that problems were reported with following versions of g++:
+</p>
+<ul>
+  <li>g++ 3.3.1 (problems with static casts)</li>
+  <li>g++ 3.3.5 (buggy nested templates)</li>
+  <li>g++ 3.3 build 1671 shipped with OS X</li>
+</ul>
+<p>
+Succesfull compilations were reported with numerous other versions
+of both the 3.x and 4.x families, on various UNIX environments including
+Linux, Mac OS X, FreeBSD, OpenSolaris, Cygwin and OpenBSD. 
+GCC &gt;= 4.2 is needed for OpenMP.
+</p>
+
+<p>The <a href="http://ftp.gnu.org/pub/gnu/readline/readline-5.0.tar.gz">GNU readline</a>
+library 4.3 or later is needed (GDL should compile
+without it, but it's very inconvenient to use that way, furthermore,
+proper event handling for graphic windows requires readline).<br/>
+OS X 10.4: Note that the the readline library which comes with OS X is <b>
+not</b> GNU readline. You need to install GNU readline and set the --with-readlinedir= DIR option to configure.
+</p>
+
+<p>Consult the <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/README">README</a> 
+  and the <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/INSTALL">INSTALL</a> 
+  files in the GDL distribution for further details on GDL requirements and configuration.
+</p>
+
+<p>GDL was developed using <a href="http://www.antlr2.org">ANTLR v2</a> 
+but unless you want to change the grammar (*.g files) you don't need
+ANTLR. All relevant ANTLR files are included in the package.<br/>
+</p>
+
+<p>GDL is currently developed using <a href="http://www.kdevelop.org">KDevelop</a> 
+3.5.1 under the GNU/Linux distribution Kubuntu. The KDevelop project file is included in the tarball, so if you
+have KDevelop you should be able to use it with GDL seamlessly.</p>
+
+</body>
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/doc/www/resources.html cvs/gdl/doc/www/resources.html
--- gdl-0.9rc4/doc/www/resources.html	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/doc/www/resources.html	2010-01-20 15:20:40.000000000 -0700
@@ -0,0 +1,38 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<title>GDL Resources</title>
+<link href="gdl.css" rel="stylesheet" type="text/css" />
+</head>
+
+<body>
+
+<center><h2><span class="g">G</span><span class="d">D</span><span
+class="l">L</span> resources</h2></center>
+
+<p>As GDL is almost 100% compatible to IDL (although not complete as many
+subroutines are waiting to be implemented), resources for IDL can also
+be utilized for GDL.</p>
+ 
+<p>
+Many IDL resources can be found on the page run by IDL guru
+<a href="http://www.dfanning.com/documents/idllinks.html"
+target="_self">David Fanning</a>.
+</p>
+<p>
+Lots of routines written for IDL can be found with the
+<a href="http://www.astro.washington.edu/deutsch/idl/htmlhelp/"
+target="_self">IDL Libraries Browser</a> many of them should also
+work with GDL.
+</p>
+<p>
+An IDL online tutorial is available at the Scientific Computing and
+Visualization <a href="http://scv.bu.edu/Tutorials/IDL/idl_webtut.html"
+target="_self">website</a>.
+</p>
+<p>
+For writing programs in GDL using Emacs the Emacs addon (mode) 
+<a href="http://www.idlwave.org/"target="_self">IDLWAVE</a>, maintained
+by J.D. Smith is highly appreciated.
+</p>
+</body>
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/doc/www/screenshot.html cvs/gdl/doc/www/screenshot.html
--- gdl-0.9rc4/doc/www/screenshot.html	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/doc/www/screenshot.html	2010-04-22 09:50:40.000000000 -0600
@@ -0,0 +1,124 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<title>GDL ::. Screenshots</title>
+<link href="gdl.css" rel="stylesheet" type="text/css" />
+</head>
+
+<body>
+
+<center><h2><span class="g">G</span><span class="d">D</span><span
+class="l">L</span>  Screenshots</h2></center>
+
+<table cellspacing=10>
+
+  <tr>
+    <td>
+      <a href="screenshots/screenshot01.png">
+        <img src="screenshots/screenshot01_thumb.png" alt="GDL drawing fractals" border=0 /> 
+      </a>
+      <br />
+      GDL rendering the Mandelbrot set. Screenshot generated using the APPLEMAN procedure
+      (included in GDL distribution, file: src/pro/appleman.pro)
+    </td>
+    <td>
+      <a href="screenshots/screenshot02.png">
+        <img src="screenshots/screenshot02_thumb.png" alt="GDL compressing weather-radar data using wavelet transform" border=0 /> 
+      </a>
+      <br />
+      GDL compressing weather-radar images using truncated wavelet approximation.
+    </td>
+  </tr>
+
+  <tr>
+    <td>
+      <a href="screenshots/screenshot03.png">
+        <img src="screenshots/screenshot03_thumb.png" alt="GDL run via a web interface" border=0 /> 
+      </a>
+      <br />
+      GDL used as a part of a web-interface for controlling 2D fluid flow simulation and 
+      visualizing the output (reading netCDF files and outputting SVG plots).
+    </td>
+    <td>
+      <a href="screenshots/screenshot04.png">
+        <img src="screenshots/screenshot04_thumb.png" alt="GDL plotting data from a MODIS HDF file" border=0 /> 
+      </a>
+      <br />
+      GDL plotting data from a HDF file with MODIS satellite image.
+    </td>
+  </tr>
+
+  <tr>
+    <td>
+      <a href="screenshots/screenshot05.png">
+        <img src="screenshots/screenshot05_thumb.png" alt="GDL used for demonstrating Kalman filtering" border=0 /> 
+      </a>
+      <br />
+      GDL used for demonstrating Kalman filtering.
+    </td>
+    <td>
+      <a href="screenshots/screenshot06.png">
+        <img src="screenshots/screenshot06_thumb.png" alt="GDL-generated PostScript plot of a Fourier tranform in a LaTeX-generated PDF file" border=0 /> 
+      </a>
+      GDL-generated PostScript plot of a Fourier spectrum in a LaTeX-generated PDF file.
+    </td>
+  </tr>
+
+  <tr>
+    <td>
+      <a href="screenshots/screenshot07.png">
+        <img src="screenshots/screenshot07_thumb.png" alt="GDL plotting weather-forecast map from a GRIB file with the GFS model output" border=0 /> 
+      </a>
+      <br />
+      GDL plotting weather-forecast map from a GRIB file with NOAA GFS model output.
+    </td>
+    <td>
+      <a href="screenshots/screenshot08.png">
+        <img src="screenshots/screenshot08_thumb.png" alt="GDL plotting Daubechies wavelet to an SVG file under OpenSolaris" border=0 /> 
+      </a>
+      <br />
+      GDL plotting Daubechies wavelet to an SVG file under OpenSolaris.
+    </td>
+  </tr>
+
+  <tr>
+    <td>
+      <a href="screenshots/screenshot09.png">
+        <img src="screenshots/screenshot09_thumb.png" alt="GDL writing a surface plot to a PNG file under Cygwin on Windows" border=0 /> 
+      </a>
+      <br />
+      GDL writing a surface plot to a PNG file under Cygwin on Windows (by Mateusz Turcza).
+    </td>
+    <td>
+      <a href="screenshots/screenshot10.png">
+        <img src="screenshots/screenshot10_thumb.png" alt="GDL rendering the Madnelbrot set in an X window under coLinux on Windows" border=0 /> 
+      </a>
+      <br />
+      GDL rendering the Madelbrot set in an X window under coLinux on Windows (<a href="http://hesperia.gsfc.nasa.gov/colinux/" target="_top">by Merrick Berg</a>).
+    </td>
+  </tr>
+  <tr>
+    <td>
+      <a href="screenshots/screenshot11.png">
+        <img src="screenshots/screenshot11_thumb.png" alt="GDL rendering two HST images of Saturn (FITS files read with
+							   Astron Lib) on Mandriva Linux 2009" border=0 /> 
+      </a>
+      <br />
+      GDL rendering two HST images of <a href="http://fr.wikipedia.org/wiki/Aurore_polaire">Polar Aurorae</a> on Saturn in UV
+      taken with STIS camera (by <a href="http://www.lesia.obspm.fr/Sur-les-autres-planetes-du-systeme.html">Palier and Prange</a>, 1999) (FITS files read with
+      <a href="http://idlastro.gsfc.nasa.gov/">Astron Lib</a>) on <a href="http://mandriva.com/">Mandriva Linux 2009</a>.
+    </td>
+    <td>
+      <a href="screenshots/screenshot12.png">
+        <img src="screenshots/screenshot12_thumb.png" alt=""/>
+      </a>
+      <br />
+      GDL used for analyzing <a href="http://en.wikipedia.org/wiki/LIDAR">LIDAR</a> data (reading them from netCDF files, producing PostScript plots) on Linux, using <a href="http://idlwave.org/">the IDLWAVE mode for Emacs</a>. (by Micha&#322; Pi&#261;d&#322;owski)
+    </td>
+  </tr>
+  
+</table>
+ 
+</body>
+
+</html>
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot01.png and cvs/gdl/doc/www/screenshots/screenshot01.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot01_thumb.png and cvs/gdl/doc/www/screenshots/screenshot01_thumb.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot02.png and cvs/gdl/doc/www/screenshots/screenshot02.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot02_thumb.png and cvs/gdl/doc/www/screenshots/screenshot02_thumb.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot03.png and cvs/gdl/doc/www/screenshots/screenshot03.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot03_thumb.png and cvs/gdl/doc/www/screenshots/screenshot03_thumb.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot04.png and cvs/gdl/doc/www/screenshots/screenshot04.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot04_thumb.png and cvs/gdl/doc/www/screenshots/screenshot04_thumb.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot05.png and cvs/gdl/doc/www/screenshots/screenshot05.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot05_thumb.png and cvs/gdl/doc/www/screenshots/screenshot05_thumb.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot06.png and cvs/gdl/doc/www/screenshots/screenshot06.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot06_thumb.png and cvs/gdl/doc/www/screenshots/screenshot06_thumb.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot07.png and cvs/gdl/doc/www/screenshots/screenshot07.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot07_thumb.png and cvs/gdl/doc/www/screenshots/screenshot07_thumb.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot08.png and cvs/gdl/doc/www/screenshots/screenshot08.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot08_thumb.png and cvs/gdl/doc/www/screenshots/screenshot08_thumb.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot09.png and cvs/gdl/doc/www/screenshots/screenshot09.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot09_thumb.png and cvs/gdl/doc/www/screenshots/screenshot09_thumb.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot10.png and cvs/gdl/doc/www/screenshots/screenshot10.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot10_thumb.png and cvs/gdl/doc/www/screenshots/screenshot10_thumb.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot11.png and cvs/gdl/doc/www/screenshots/screenshot11.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot11_thumb.png and cvs/gdl/doc/www/screenshots/screenshot11_thumb.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot12.png and cvs/gdl/doc/www/screenshots/screenshot12.png differ
Binary files gdl-0.9rc4/doc/www/screenshots/screenshot12_thumb.png and cvs/gdl/doc/www/screenshots/screenshot12_thumb.png differ
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/doc/www/support.html cvs/gdl/doc/www/support.html
--- gdl-0.9rc4/doc/www/support.html	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/doc/www/support.html	2010-01-20 15:20:41.000000000 -0700
@@ -0,0 +1,20 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<title>GDL Support</title>
+<link href="gdl.css" rel="stylesheet" type="text/css" />
+</head>
+
+<body>
+
+<center><h2><span class="g">G</span><span class="d">D</span><span class="l">L</span> Support</h2></center>
+
+<p>Please read the files in the GDL root directory carefully. Especially README and INSTALL.</p>
+
+<p>
+If you still have any questions you might use one of these <a href="http://sourceforge.net/tracker/?group_id=97659" target="_top">trackers</a>
+or
+<a href="http://sourceforge.net/projects/gnudatalanguage/forums">forums</a>. 
+</p>
+
+</body>
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/doc/www/tdl.html cvs/gdl/doc/www/tdl.html
--- gdl-0.9rc4/doc/www/tdl.html	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/doc/www/tdl.html	2010-01-20 15:20:41.000000000 -0700
@@ -0,0 +1,19 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<title>GDL -TDL</title>
+<link href="gdl.css" rel="stylesheet" type="text/css" />
+</head>
+
+<body>
+
+<center><h2><span class="g">G</span><span class="d">D</span><span
+class="l">L</span> - <span class="g">T</span><span class="d">D</span><span class="l">L</span></h2></center>
+
+<p>
+The good folks at <a href="http://freshmeat.net">freshmeat</a> had
+a problem with the name GDL - GNU Data Language, but kindly agreed to
+list it as TDL - The Data Language. Therefore its listed there as TDL.
+</p>
+
+</body>
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/gdl.kdevelop cvs/gdl/gdl.kdevelop
--- gdl-0.9rc4/gdl.kdevelop	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/gdl.kdevelop	2010-04-16 11:22:42.000000000 -0600
@@ -32,13 +32,13 @@
       <terminal>false</terminal>
       <directoryradio>executable</directoryradio>
       <customdirectory>/</customdirectory>
-      <programargs/>
+      <programargs></programargs>
       <autocompile>true</autocompile>
       <envvars/>
       <runarguments>
         <gdl/>
       </runarguments>
-      <globaldebugarguments/>
+      <globaldebugarguments></globaldebugarguments>
       <globalcwd>/home/marc/gdl/debug/src</globalcwd>
       <useglobalprogram>true</useglobalprogram>
       <autoinstall>false</autoinstall>
@@ -63,7 +63,7 @@
         <f77flags/>
       </optimized>
       <debug>
-        <configargs>--with-readlinedir=yes --with-python=yes --with-hdf=yes --with-hdf5=no --with-plplotdir=/usr --with-python=yes --disable-python_module --with-netcdf=no --enable-oldplplot --with-openmp=yes --with-libproj4=no --with-wxWidgets=no --with-Magick=no</configargs>
+        <configargs>--with-readlinedir=yes --with-hdf=yes --with-hdf5=yes --with-plplotdir=/usr/local --with-python=yes --disable-python_module --with-netcdf=no --disable-oldplplot --with-openmp=no --with-libproj4=no --with-mpich=/usr/lib/mpich --with-wxWidgets=yes --with-Magick=yes</configargs>
         <builddir>debug</builddir>
         <ccompiler>kdevgccoptions</ccompiler>
         <cxxcompiler>kdevgppoptions</cxxcompiler>
@@ -279,6 +279,7 @@
   </kdevcvsservice>
   <ctagspart>
     <customArguments/>
-    <customTagfilePath/>
+    <customTagfilePath>/home/marc/gdl/tags</customTagfilePath>
+    <activeTagsFiles/>
   </ctagspart>
 </kdevelop>
Only in gdl-0.9rc4: gdl.kdevses
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/INSTALL cvs/gdl/INSTALL
--- gdl-0.9rc4/INSTALL	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/INSTALL	2010-04-22 09:50:39.000000000 -0600
@@ -4,15 +4,18 @@
 (If you encounter any problems, please read on further, also have a
 look at the REQUIREMENTS section in the README file.)
 
-Unpack the tarball under any directory (tar xfvz gdl-0.9.tar.gz)
-change to the new subdirectory gdl-0.9
-type ./configure  (use './configure --help' for a list of options)
-type make         (use 'make -j N' to run N parallel processes)
-The executable (named 'gdl') should then be in the src subdirectory
-(gdl-0.9/src/gdl).
+* unpack the tarball under any directory (tar xfvz gdl-0.9.tar.gz)
+* change to the new subdirectory gdl-0.9 
+* type "./configure"  (use './configure --help' for a list of options)
+* type "make"         (use 'make -j N' to run N parallel processes)
+* optionally type "make check" to test the build 
+* type "make install" to deploy GDL binary (gdl), libraries, manpage, etc
 
 If you know IDL, you should feel very familiar with GDL.
-Some GDL test files are in the gdl/pro subdirectory (test_*.pro)
+A list of command-line options is available both in the manpage and
+after typing "gdl --help". 
+
+Some GDL test files are in the gdl/testsuite subdirectory (test_*.pro)
 
 Note:
 When compiling you might get some warnings:
@@ -71,42 +74,31 @@
                                   determine which python version is actually 
                                   used. With this option the version can be
                                   expicitely set 
-                                  (e.g. --enable-python_version=2.3).
+                                  (e.g. --enable-python_version=2.6).
+--with-ncursesdir=DIR  to specify the ncurses (or curses) directory tree
+--with-readlinedir=DIR to specify the GNU readline directory tree
+--with-libzdir=DIR     to specify the Zlib directory tree
+--with-openmp=no       to disable the OpenMP support (e.g. for GCC <4.2)
+--with-gsldir=DIR      to specify the GSL directory tree
 --with-plplotdir=DIR   to specify the plplot directory tree
 --enable-oldplplot     to specify that you have an older than 5.9.0 plplot lib.
 
---with-ncursesdir=DIR  to specify the ncurses directory tree
---with-readlinedir=DIR to specify the readline directory tree
---with-gsldir=DIR      to specify the GSL directory tree
---with-libzdir=DIR     to specify the Zlib directory tree
+--with-Magick=DIR      to specify the ImageMagick directory tree
+--with-Magick=no       to not use ImageMagick
 
 --with-netcdf=DIR      to specify the netcdf directory tree
 --with-netcdf=no       to not use netcdf
 
---with-hdf=DIR         to specify the HDF4 directory tree
---with-hdf=no          to not use HDF4
-
---with-hdf5=DIR        to specify the HDF5 directory tree
---with-hdf5=no         to not use HDF5
-
---with-python=DIR      to specify the python directory tree
---with-python=no       to not use python
-
---with-Magick=DIR      to specify the ImageMagick directory tree
---with-Magick=no       to not use ImageMagick
-
 --with-fftw=DIR        to specify the FFTW directory tree
---with-fftw=no         to not use FFTW (this is the default)
-
---with-libproj4=DIR    to specify the libproj4 directory tree
---with-libproj4=no     to not use libproj4 (this is the default)
+--with-fftw=no         to not use FFTW
 
+... and so on for: wxWidgets, hdf, hdf5, fftw, libproj4, python, udunits, 
+grib, GSHHS, and others - see README file for details (REQUIREMENTS section).
 
 For example, if you have python installed in /usr/local, use
 
 ./configure --with-python=/usr/local
 
-
 Basic Installation Instructions
 ===============================
 
Only in gdl-0.9rc4: m4
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/Makefile.cvs cvs/gdl/Makefile.cvs
--- gdl-0.9rc4/Makefile.cvs	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/Makefile.cvs	2004-12-09 08:10:02.000000000 -0700
@@ -0,0 +1,8 @@
+default: all
+
+all:
+	aclocal
+	autoheader
+	automake
+	autoconf
+
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/MAP_INSTALL cvs/gdl/MAP_INSTALL
--- gdl-0.9rc4/MAP_INSTALL	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/MAP_INSTALL	2010-05-21 10:23:52.346969024 -0600
@@ -1,12 +1,10 @@
+===========================================================================
 
 To provide map projections support your first need to make sure the libproj4
 library is installed.  The source code for this can be found at:
 
-http://members.verizon.net/~vze2hc4d/proj4/libproj4.3_20081120.tar.bz2
-(or http://home.comcast.net/~gevenden56/)
-
-(Older version: http://members.verizon.net/~vze2hc4d/proj4/lbp4_050319S.tar.gz)
-
+http://home.comcast.net/~gevenden56/proj/
+(http://home.comcast.net/~gevenden56/proj/libproj4.3_20081120.tar.bz2)
 
 The "--with-libproj4=DIR" switch in configure can be used give the location
 of this library.
@@ -15,7 +13,6 @@
 The following additional PRO files must be acquired and placed in the
 appropriate directories:
 
-map_continents.pro
 map_grid.pro
 map_horizon.pro
 map_image.pro
@@ -38,29 +35,33 @@
 
 They can be placed in any directory within you GDL path.
 
+===========================================================================
+
+MAP_CONTINENTS is implemented in GDL using the GSHHS (Global 
+Self-consistent, Hierarchical, High-resolution Shoreline Database) 
+available under the GNU GPL. To provide support for MAP_CONTINENTS the 
+database files and one header file (gshhs.h) need to be downloaded e.g. from:
+
+ftp://ftp.soest.hawaii.edu/pwessel/gshhs
+
+The header file for the 2.0 dataset is in the gshhs_1.12_src.zip file.
+The datafiles (*.b) are in the gshhs_2.0.tbz file.
+
+When compiling GDL, the --with-gshhs option must be given (not enabled 
+by default), optionally with an argument pointing to the GSHHS installation
+prefix:
 
-To provide support for MAP_CONTINENTS the database files must be
-downloaded:
+--with-gshhs : searches gshhs.h in the default include path of the compiler
+--with-gshhs=/usr/local : searches for /usr/local/include/gshhs.h
 
-blow.dat
-blow.ndx
-clow.dat
-clow.ndx
-plow.dat
-plow.ndx
-rlow.dat
-rlow.ndx
-
-These files can be found at:
-
-http://comm.nsdl.org/viewcvs/viewcvs.cgi/ddtoolkitnfndry/ETA_Viewer/Development/resource/maps/low/
-
-These files should be placed in the "resource/maps/low" subdirectory
-of the !DIR directory which can be found by starting GDL and printing
-the !DIR system variable.
+GDL searches for the GSHHS datafiles (gshhs_f.b, gshhs_l.b, etc...) in the
+$GDLDATADIR/../gshhs/ directory (we need a better solution - FIXME!)
 
-Note: Only low-resolution boundaries are currently supported.
+Reference:
+Wessel, P. and Smith, W.H.F., 1996. A global, self-consistent, hierarchical, 
+  high-resolution shoreline database. J. Geophys. Res., 101(B4): 8741--8743.
 
+===========================================================================
 
 The following projections are at least partially supported
 (numbers defined in the map_sep.pro file itself):
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/NEWS cvs/gdl/NEWS
--- gdl-0.9rc4/NEWS	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/NEWS	2010-07-07 14:40:56.391004378 -0600
@@ -200,10 +200,9 @@
 	  and Inf values, add Nlevels= and /Fill
 	  Two new projections in MAP_SET: Satellite and Robinson
 	  Preliminary version for Width parameter in MEDIAN()
-	  add SPL_INIT() and SPL_INTERP() (GDL syntax)
+	  initial import for SPL_INIT() and SPL_INTERP() (GDL syntax)
 
 0.9rc2:   undocumented BYTSCL accepting three parameters (value,min,max)
-	  initial import for SPL_INIT() and SPL_INTERP()
 	  g++ 4.3 compatibility
 	  ignore something like a=(a=a) (so it is allowed even if a is undefined)
 	  accept self assignment of undefined variables
@@ -475,6 +474,31 @@
              test_plotting_ranges.pro, test_grib.pro, test_poly2d.pro, test_wavelet.pro
            - inclusion of some of the test-routines in the "make check" rule
            - quick_start_GDL.sh script 
-           - making the initial "DECOMPOSED" setting of the X device dependtant on the colour 
+           - making the initial "DECOMPOSED" setting of the X device dependant on the colour 
              depth reported by the X-server
 
+0.9rc5:	    
+	   - FOREACH statement, syntax: FOREACH loopVar OF array DO
+	   - member function and procedure calls with '.' e. g.: object.aProcedure
+	   - support of negative index ranges. -1 is the last element, -2 the one before 
+	     the last and so on. E.g.: array[-7:-5]
+           - new widget features incl. WIDGET_DROPLIST
+           - automatic garbage collection
+           - numerous bugfixes (incl. SAVE/RESTORE, WRITEU, ...)
+           - memory leak in FFT when using FFTw lib should be solved
+           - all input types OK in FFT when using GSL FFT
+           - new routines: HIST_2D, INTERPOL, MAP_CONTINENTS, POLYFILL, 
+             RESOLVE_ROUTINE, SPHER_HARM, IMSL_ERF
+           - new keywords/calling sequences handled:
+             - DEVICE, /INCHES, GET_SCREEN_SIZE
+             - PRODUCT, /PRESERVE_TYPE, /INTEGER
+             - REBIN: support for specifying new dimensions as an array
+             - TOTAL, /PRESERVE_TYPE
+             - FILE_SEARCH, /FOLD_CASE
+             - STRSPLIT, /preserve_null
+           - new test routines (invoked during "make check")
+           - DIALOG_PICKFILE, based on Zenity, OK on most Linux and OSX
+           - FILE_DELETE, FILE_COPY and FILE_EXPAND_PATH
+	   - SPL_INIT: now y0= and yn_1= ready
+           - Compressed files should be well processed now (readf, printf, fstat, point_lun, ...). See test_zip.pro
+
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/README cvs/gdl/README
--- gdl-0.9rc4/README	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/README	2010-04-22 09:50:39.000000000 -0600
@@ -37,7 +37,7 @@
 DICOM files are supported via the GDLffDICOM object
 (src/pro/dicom subdirectory).
 
-Overall more than 300 library routines are implemented.
+Overall more than 380 library routines are implemented.
 For a list enter HELP,/LIB at the command prompt and look for
 library routines written in GDL in the src/pro subdirectory.
 
@@ -77,8 +77,10 @@
 HDF5        ftp://ftp.ncsa.uiuc.edu/HDF/HDF5/current
 FFTW        http://www.fftw.org/download.html
 python      http://www.python.org
-libproj4    http://members.verizon.net/~vze2hc4d/proj4/
+libproj4    (consult the MAP_INSTALL file)
 UDUNITS-2   http://www.unidata.ucar.edu/software/udunits/
+GRIB API    http://www.ecmwf.int/products/data/software/grib_api.html        
+GSHHS       (consult the MAP_INSTALL file)
 
 Only with python:
 numarray    http://www.stsci.edu/resources/software_hardware/numarray
@@ -119,6 +121,14 @@
 If you have plplot older than 5.9.0 use the configure
 option --enable-oldplplot 
 With this option, plplot down to 5.3 should work.
+A possible problem was reported:
+On opening more than one window, plplot causes a segmentation fault
+if GDL is compiled with ImageMagick. This happens if plplot uses 
+dynamic drivers .
+The current solution is to disable dynamic drivers for plplot
+(-DENABLE_DYNDRIVERS=OFF option for cmake).
+Current ubuntu/debian distributions are using dynamic drivers, so plplot
+needs to be compiled from source there.
 
 Furthermore you need the GNU Scientific Library.
 (Minimal version is 1.7, which is now checked via "gsl.m4".
@@ -231,6 +241,10 @@
 library (http://www.unidata.ucar.edu/software/udunits/)
 If you want to use it, use --with-udunits=DIR
 
+GDL supports the GRIB file format - see README_GRIB
+
+GDL uses GSHHS to implement MAP_CONTINENTS - see MAP_INSTALL
+
 GDL 0.9 was developed using ANTLR 2.7.6,   
 but unless you want to change the grammar (*.g files) you don't need
 ANTLR. All relevant ANTLR files are included in the package.
@@ -258,7 +272,7 @@
 ==============
 
 GDL 0.9 is actively developed, but due to the vast amount of subroutines
-to implement still in beta state as of November 2009.
+to implement still in beta state as of February 2010.
 Even though it can already be used for several tasks, there are many
 things to be done.
 Bug reports, feedback in general and interested people who would
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/accessdesc.hpp cvs/gdl/src/accessdesc.hpp
--- gdl-0.9rc4/src/accessdesc.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/accessdesc.hpp	2010-04-16 11:22:53.000000000 -0600
@@ -337,9 +337,13 @@
   BaseGDL* Resolve()
   {
     SetupDim();
-    
-    // no zeroing, here the new variable is created
-    BaseGDL* newData=top->New( dim, BaseGDL::NOZERO);
+
+    BaseGDL* newData;
+    // no zeroing, here the new variable is created TODO: zero only for PTR and OBJECT
+    if( top->Type() == PTR || top->Type() == OBJECT)
+		newData=top->New( dim);//, BaseGDL::NOZERO);
+    else
+		newData=top->New( dim, BaseGDL::NOZERO);
 
     rOffset=0; // crucial line, only with rOffset == 0 var is set
  
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/antlr/LLkParser.cpp cvs/gdl/src/antlr/LLkParser.cpp
--- gdl-0.9rc4/src/antlr/LLkParser.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/antlr/LLkParser.cpp	2010-04-16 11:22:54.000000000 -0600
@@ -2,7 +2,7 @@
  * Project led by Terence Parr at http://www.jGuru.com
  * Software rights: http://www.antlr.org/license.html
  *
- * $Id: LLkParser.cpp,v 1.1.1.1 2004/12/09 15:10:20 m_schellens Exp $
+ * $Id: LLkParser.cpp,v 1.3 2010/04/07 14:59:09 m_schellens Exp $
  */
 
 #include "antlr/LLkParser.hpp"
@@ -40,11 +40,13 @@
 
 void LLkParser::trace(const char* ee, const char* rname)
 {
+	if(inputState->guessing>0) return;
+	
 	traceIndent();
 
-	cout << ee << rname << ((inputState->guessing>0)?"; [guessing]":"; ");
+	cout << ee << rname << ((inputState->guessing>0)?";                                        [guessing]":";        <<<");
 
-	for (int i = 1; i <= k; i++)
+	for (int i = 1; i <= k+3; i++)
 	{
 		if (i != 1) {
 			cout << ", ";
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/antlr/Makefile.am cvs/gdl/src/antlr/Makefile.am
--- gdl-0.9rc4/src/antlr/Makefile.am	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/antlr/Makefile.am	2010-04-16 11:22:54.000000000 -0600
@@ -3,14 +3,14 @@
 antlr_sources = ANTLRException.hpp ANTLRUtil.cpp ANTLRUtil.hpp ASTArray.hpp ASTFactory.cpp ASTFactory.hpp AST.hpp ASTNULLType.cpp ASTNULLType.hpp ASTPair.hpp ASTRefCount.cpp ASTRefCount.hpp BaseAST.cpp BaseAST.hpp BitSet.cpp BitSet.hpp CharBuffer.cpp CharBuffer.hpp CharInputBuffer.hpp CharScanner.cpp CharScanner.hpp CharStreamException.hpp CharStreamIOException.hpp CircularQueue.hpp CommonAST.cpp CommonAST.hpp CommonASTWithHiddenTokens.cpp CommonASTWithHiddenTokens.hpp CommonHiddenStreamToken.cpp CommonHiddenStreamToken.hpp CommonToken.cpp CommonToken.hpp config.hpp InputBuffer.cpp InputBuffer.hpp IOException.hpp LexerSharedInputState.hpp LLkParser.cpp LLkParser.hpp Makefile.am Makefile.in MismatchedCharException.cpp MismatchedCharException.hpp MismatchedTokenException.cpp MismatchedTokenException.hpp NoViableAltException.cpp NoViableAltException.hpp NoViableAltForCharException.cpp NoViableAltForCharException.hpp Parser.cpp Parser.hpp ParserSharedInputState.hpp RecognitionException.cpp RecognitionException.hpp RefCount.hpp SemanticException.hpp String.cpp String.hpp TokenBuffer.cpp TokenBuffer.hpp Token.cpp Token.hpp TokenStreamBasicFilter.cpp TokenStreamBasicFilter.hpp TokenStreamException.hpp TokenStreamHiddenTokenFilter.cpp TokenStreamHiddenTokenFilter.hpp TokenStream.hpp TokenStreamIOException.hpp TokenStreamRecognitionException.hpp TokenStreamRetryException.hpp TokenStreamSelector.cpp TokenStreamSelector.hpp TreeParser.cpp TreeParser.hpp TreeParserSharedInputState.hpp
 
 if !BUILDASLIBRARY
-lib_LIBRARIES =  libantlr.a
+noinst_LIBRARIES =  libantlr.a
 libantlr_a_SOURCES = $(antlr_sources)
 # trigger basename generation
 libantlr_a_CXXFLAGS = $(AM_CXXFLAGS)
 endif
 
-# if we build a shared library, antlr stuff has to build
-# as shared library also
+# if we build a shared library, antlr stuff has to be build
+# as a shared library also
 if BUILDASLIBRARY
 noinst_LTLIBRARIES =  libantlr.la
 libantlr_la_SOURCES = $(antlr_sources)
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/antlr/Makefile.in cvs/gdl/src/antlr/Makefile.in
--- gdl-0.9rc4/src/antlr/Makefile.in	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/antlr/Makefile.in	2010-04-16 11:22:54.000000000 -0600
@@ -45,29 +45,7 @@
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
 CONFIG_CLEAN_VPATH_FILES =
-am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
-am__vpath_adj = case $$p in \
-    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
-    *) f=$$p;; \
-  esac;
-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
-am__install_max = 40
-am__nobase_strip_setup = \
-  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
-am__nobase_strip = \
-  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
-am__nobase_list = $(am__nobase_strip_setup); \
-  for p in $$list; do echo "$$p $$p"; done | \
-  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
-  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
-    if (++n[$$2] == $(am__install_max)) \
-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
-    END { for (dir in files) print dir, files[dir] }'
-am__base_list = \
-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
-  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
-am__installdirs = "$(DESTDIR)$(libdir)"
-LIBRARIES = $(lib_LIBRARIES)
+LIBRARIES = $(noinst_LIBRARIES)
 ARFLAGS = cru
 libantlr_a_AR = $(AR) $(ARFLAGS)
 libantlr_a_LIBADD =
@@ -352,13 +330,13 @@
 	TokenStreamRetryException.hpp TokenStreamSelector.cpp \
 	TokenStreamSelector.hpp TreeParser.cpp TreeParser.hpp \
 	TreeParserSharedInputState.hpp
-@BUILDASLIBRARY_FALSE@lib_LIBRARIES = libantlr.a
+@BUILDASLIBRARY_FALSE@noinst_LIBRARIES = libantlr.a
 @BUILDASLIBRARY_FALSE@libantlr_a_SOURCES = $(antlr_sources)
 # trigger basename generation
 @BUILDASLIBRARY_FALSE@libantlr_a_CXXFLAGS = $(AM_CXXFLAGS)
 
-# if we build a shared library, antlr stuff has to build
-# as shared library also
+# if we build a shared library, antlr stuff has to be build
+# as a shared library also
 @BUILDASLIBRARY_TRUE@noinst_LTLIBRARIES = libantlr.la
 @BUILDASLIBRARY_TRUE@libantlr_la_SOURCES = $(antlr_sources)
 all: all-am
@@ -395,38 +373,9 @@
 $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(am__aclocal_m4_deps):
-install-libLIBRARIES: $(lib_LIBRARIES)
-	@$(NORMAL_INSTALL)
-	test -z "$(libdir)" || $(MKDIR_P) "$(DESTDIR)$(libdir)"
-	@list='$(lib_LIBRARIES)'; test -n "$(libdir)" || list=; \
-	list2=; for p in $$list; do \
-	  if test -f $$p; then \
-	    list2="$$list2 $$p"; \
-	  else :; fi; \
-	done; \
-	test -z "$$list2" || { \
-	  echo " $(INSTALL_DATA) $$list2 '$(DESTDIR)$(libdir)'"; \
-	  $(INSTALL_DATA) $$list2 "$(DESTDIR)$(libdir)" || exit $$?; }
-	@$(POST_INSTALL)
-	@list='$(lib_LIBRARIES)'; test -n "$(libdir)" || list=; \
-	for p in $$list; do \
-	  if test -f $$p; then \
-	    $(am__strip_dir) \
-	    echo " ( cd '$(DESTDIR)$(libdir)' && $(RANLIB) $$f )"; \
-	    ( cd "$(DESTDIR)$(libdir)" && $(RANLIB) $$f ) || exit $$?; \
-	  else :; fi; \
-	done
 
-uninstall-libLIBRARIES:
-	@$(NORMAL_UNINSTALL)
-	@list='$(lib_LIBRARIES)'; test -n "$(libdir)" || list=; \
-	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	test -n "$$files" || exit 0; \
-	echo " ( cd '$(DESTDIR)$(libdir)' && rm -f "$$files" )"; \
-	cd "$(DESTDIR)$(libdir)" && rm -f $$files
-
-clean-libLIBRARIES:
-	-test -z "$(lib_LIBRARIES)" || rm -f $(lib_LIBRARIES)
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
 libantlr.a: $(libantlr_a_OBJECTS) $(libantlr_a_DEPENDENCIES) 
 	-rm -f libantlr.a
 	$(libantlr_a_AR) libantlr.a $(libantlr_a_OBJECTS) $(libantlr_a_LIBADD)
@@ -995,9 +944,6 @@
 check: check-am
 all-am: Makefile $(LIBRARIES) $(LTLIBRARIES)
 installdirs:
-	for dir in "$(DESTDIR)$(libdir)"; do \
-	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
-	done
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -1025,7 +971,7 @@
 	@echo "it deletes files that may require special tools to rebuild."
 clean: clean-am
 
-clean-am: clean-generic clean-libLIBRARIES clean-libtool \
+clean-am: clean-generic clean-libtool clean-noinstLIBRARIES \
 	clean-noinstLTLIBRARIES mostlyclean-am
 
 distclean: distclean-am
@@ -1052,7 +998,7 @@
 
 install-dvi-am:
 
-install-exec-am: install-libLIBRARIES
+install-exec-am:
 
 install-html: install-html-am
 
@@ -1092,23 +1038,23 @@
 
 ps-am:
 
-uninstall-am: uninstall-libLIBRARIES
+uninstall-am:
 
 .MAKE: install-am install-strip
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
-	clean-libLIBRARIES clean-libtool clean-noinstLTLIBRARIES ctags \
-	distclean distclean-compile distclean-generic \
+	clean-libtool clean-noinstLIBRARIES clean-noinstLTLIBRARIES \
+	ctags distclean distclean-compile distclean-generic \
 	distclean-libtool distclean-tags distdir dvi dvi-am html \
 	html-am info info-am install install-am install-data \
 	install-data-am install-dvi install-dvi-am install-exec \
 	install-exec-am install-html install-html-am install-info \
-	install-info-am install-libLIBRARIES install-man install-pdf \
-	install-pdf-am install-ps install-ps-am install-strip \
-	installcheck installcheck-am installdirs maintainer-clean \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-libLIBRARIES
+	tags uninstall uninstall-am
 
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/antlr/Parser.cpp cvs/gdl/src/antlr/Parser.cpp
--- gdl-0.9rc4/src/antlr/Parser.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/antlr/Parser.cpp	2010-04-16 11:22:54.000000000 -0600
@@ -2,11 +2,12 @@
  * Project led by Terence Parr at http://www.jGuru.com
  * Software rights: http://www.antlr.org/license.html
  *
- * $Id: Parser.cpp,v 1.2 2008/11/16 13:51:49 m_schellens Exp $
+ * $Id: Parser.cpp,v 1.4 2010/04/07 14:59:09 m_schellens Exp $
  */
 
 // g++-4.3 needs this
 #include <cstdlib>
+#include <iomanip>
 
 #include "antlr/Parser.hpp"
 
@@ -187,13 +188,16 @@
 void Parser::traceIndent()
 {
 	for( int i = 0; i < traceDepth; i++ )
-		ANTLR_USE_NAMESPACE(std)cout << " ";
+		ANTLR_USE_NAMESPACE(std)cout << "  ";
+	ANTLR_USE_NAMESPACE(std)cout << ANTLR_USE_NAMESPACE(std)setw(3) << traceDepth << " ";
 }
 
 void Parser::traceIn(const char* rname)
 {
 	traceDepth++;
 
+if(inputState->guessing>0) return;
+
 	for( int i = 0; i < traceDepth; i++ )
 		ANTLR_USE_NAMESPACE(std)cout << " ";
 
@@ -205,6 +209,7 @@
 
 void Parser::traceOut(const char* rname)
 {
+if(inputState->guessing<=0) {
 	for( int i = 0; i < traceDepth; i++ )
 		ANTLR_USE_NAMESPACE(std)cout << " ";
 
@@ -212,7 +217,7 @@
 		<< "; LA(1)==" << LT(1)->getText().c_str()
 		<<	((inputState->guessing>0)?" [guessing]":"")
 		<< ANTLR_USE_NAMESPACE(std)endl;
-
+}
 	traceDepth--;
 }
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/antlr/RefCount.hpp cvs/gdl/src/antlr/RefCount.hpp
--- gdl-0.9rc4/src/antlr/RefCount.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/antlr/RefCount.hpp	2010-04-16 11:22:54.000000000 -0600
@@ -4,7 +4,7 @@
  * Project led by Terence Parr at http://www.jGuru.com
  * Software rights: http://www.antlr.org/license.html
  *
- * $Id: RefCount.hpp,v 1.1.1.1 2004/12/09 15:10:20 m_schellens Exp $
+ * $Id: RefCount.hpp,v 1.2 2010/03/09 23:54:39 m_schellens Exp $
  */
 
 #include <antlr/config.hpp>
@@ -62,7 +62,7 @@
 		return ref ? ref->ptr : 0;
 	}
 
-	T* get() const
+	 T* get() const
 	{
 		return ref ? ref->ptr : 0;
 	}
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/antlr/TreeParser.cpp cvs/gdl/src/antlr/TreeParser.cpp
--- gdl-0.9rc4/src/antlr/TreeParser.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/antlr/TreeParser.cpp	2010-04-16 11:22:54.000000000 -0600
@@ -2,11 +2,12 @@
  * Project led by Terence Parr at http://www.jGuru.com
  * Software rights: http://www.antlr.org/license.html
  *
- * $Id: TreeParser.cpp,v 1.2 2008/11/16 13:51:49 m_schellens Exp $
+ * $Id: TreeParser.cpp,v 1.3 2010/04/05 01:22:05 m_schellens Exp $
  */
 
 // g++-4.3 needs this
 #include <cstdlib>
+#include <iomanip>
 
 #include "antlr/TreeParser.hpp"
 #include "antlr/ASTNULLType.hpp"
@@ -98,7 +99,8 @@
 void TreeParser::traceIndent()
 {
 	for( int i = 0; i < traceDepth; i++ )
-		ANTLR_USE_NAMESPACE(std)cout << " ";
+		ANTLR_USE_NAMESPACE(std)cout << "  ";
+	ANTLR_USE_NAMESPACE(std)cout << ANTLR_USE_NAMESPACE(std)setw(3) << traceDepth << ": ";
 }
 
 void TreeParser::traceIn(const char* rname, RefAST t)
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/arrayindex.cpp cvs/gdl/src/arrayindex.cpp
--- gdl-0.9rc4/src/arrayindex.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/arrayindex.cpp	2010-05-21 10:23:54.851967986 -0600
@@ -197,13 +197,13 @@
   
   if( ixList->size() == 1)
     {
-      if( dynamic_cast< CArrayIndexScalar*>((*ixList)[0]))
+      if( CArrayIndexScalarID == (*ixList)[0]->Type())
 	return new ArrayIndexListOneConstScalarT( ixList);
       
-      if( dynamic_cast< ArrayIndexScalar*>((*ixList)[0]))
+      if( ArrayIndexScalarID == (*ixList)[0]->Type())
 	return new ArrayIndexListOneScalarT( ixList);
       
-      if( dynamic_cast< ArrayIndexScalarVP*>((*ixList)[0]))
+      if( ArrayIndexScalarVPID == (*ixList)[0]->Type())
 	return new ArrayIndexListOneScalarVPT( ixList);
       
       return new ArrayIndexListOneT( ixList);
@@ -212,9 +212,9 @@
   SizeT nScalar  = 0;
   for( SizeT i=0; i<ixList->size(); ++i)
     {
-      if( dynamic_cast< ArrayIndexScalar*>((*ixList)[i]) ||
-	  dynamic_cast< ArrayIndexScalarVP*>((*ixList)[i]) ||
-	  dynamic_cast< CArrayIndexScalar*>((*ixList)[i])) ++nScalar;
+      if( ArrayIndexScalarID == (*ixList)[i]->Type() ||
+	  ArrayIndexScalarVPID == (*ixList)[i]->Type() ||
+	  CArrayIndexScalarID == (*ixList)[i]->Type() ) ++nScalar;
     }
   if( nScalar == ixList->size())
     return new ArrayIndexListScalarT( ixList);
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/arrayindex.hpp cvs/gdl/src/arrayindex.hpp
--- gdl-0.9rc4/src/arrayindex.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/arrayindex.hpp	2010-05-21 10:23:54.881967727 -0600
@@ -27,9 +27,30 @@
 //typedef std::valarray<SizeT> AllIxT; // now in typedefs.hpp
 typedef std::vector<BaseGDL*>     IxExprListT;
 
+enum IndexType
+{
+ArrayIndexTID,
+ArrayIndexScalarID,
+ArrayIndexScalarVPID,
+CArrayIndexScalarID,
+ArrayIndexIndexedID,
+CArrayIndexIndexedID,
+ArrayIndexAllID,
+ArrayIndexORangeID,
+CArrayIndexORangeID,
+ArrayIndexRangeID,
+CArrayIndexRangeID,
+ArrayIndexORangeSID,
+CArrayIndexORangeSID,
+ArrayIndexRangeSID,
+CArrayIndexRangeSID
+};
+
 class ArrayIndexT
 {
 public:
+ virtual IndexType Type() { return ArrayIndexTID;}
+
 // this may be called from ArrayIndexListT::ToAssocIndex
   virtual void Init() {} 
   
@@ -41,8 +62,8 @@
   virtual void Clear() {}
   virtual ~ArrayIndexT() {}
 
-  virtual SizeT GetIx0()=0;
-  virtual SizeT GetS() { return 0;}
+  virtual RangeT GetIx0()=0;
+  virtual RangeT GetS() { return 0;}
   virtual SizeT GetStride() { return 0;}
   
   virtual bool Scalar()           { return false;}
@@ -68,11 +89,13 @@
   SizeT s;
 
 public:
+ IndexType Type() { return ArrayIndexScalarID;}
+
   SizeT GetVarIx() const { return varIx;}
 
   SizeT NParam() { return 0;} // number of parameter to Init(...)
 
-  SizeT GetS() { return s;}
+  RangeT GetS() { return s;}
 
   bool Scalar() { return true;}
   bool Scalar( SizeT& s_)
@@ -81,7 +104,7 @@
     return true;
   }
 
-  SizeT GetIx0()
+  RangeT GetIx0()
   {
     return s;
   }
@@ -123,11 +146,13 @@
   SizeT s;
 
 public:
+ IndexType Type() { return ArrayIndexScalarVPID;}
+
   DVar* GetVarPtr() const { return varPtr;}
 
   SizeT NParam() { return 0;} // number of parameter to Init(...)
 
-  SizeT GetS() { return s;}
+  RangeT GetS() { return s;}
 
   bool Scalar() { return true;}
   bool Scalar( SizeT& s_)
@@ -144,7 +169,7 @@
   void Clear()
   {}
 
-  SizeT GetIx0()
+  RangeT GetIx0()
   {
     return s;
   }
@@ -180,6 +205,8 @@
   SizeT s;
 
 public:
+ IndexType Type() { return CArrayIndexScalarID;}
+
   SizeT NParam() { return 0;} // number of parameter to Init(...)
 
   bool Scalar() { return true;}
@@ -189,12 +216,12 @@
     return true;
   }
 
-  SizeT GetIx0()
+  RangeT GetIx0()
   {
     return s;
   }
 
-  SizeT GetS() { return s;}
+  RangeT GetS() { return s;}
 
   ~CArrayIndexScalar() 
   {}
@@ -238,6 +265,8 @@
   }
 };
 
+
+
 // INDEXED or ONE [v] (must handle both)
 class ArrayIndexIndexed: public ArrayIndexT
 {
@@ -254,9 +283,11 @@
   ArrayIndexIndexed( const ArrayIndexT& r) {}
 
 public:
+ IndexType Type() { return ArrayIndexIndexedID;}
+
   SizeT NParam() { return 1;} // number of parameter to Init(...)
 
-  SizeT GetS() { return s;}
+  RangeT GetS() { return s;}
 
   bool Scalar() { return (ix == NULL);}
   bool Scalar( SizeT& s_)
@@ -274,7 +305,7 @@
 
   dimension GetDim() { return *ixDim;}
 
-  SizeT GetIx0()
+  RangeT GetIx0()
   {
     if( ix != NULL) return (*ix)[0]; // from array
     return s;
@@ -744,6 +775,8 @@
 
 };
 
+
+
 // constant version
 class CArrayIndexIndexed: public ArrayIndexIndexed
 {
@@ -752,6 +785,8 @@
   SizeT      maxIx;
 
 public:
+ IndexType Type() { return CArrayIndexIndexedID;}
+
   ~CArrayIndexIndexed() { delete ixOri;}
 
   CArrayIndexIndexed( BaseGDL* c, bool strictArrSubs_ = false): 
@@ -874,15 +909,22 @@
   }
 };
 
+
+
+
+
+
 // [*]
 class ArrayIndexAll: public ArrayIndexT
 {
 public:
+ IndexType Type() { return ArrayIndexAllID;}
+
   SizeT NParam() { return 0;} // number of parameter to Init(...)
 
   void Init() {};
 
-  SizeT GetIx0() { return 0;}
+  RangeT GetIx0() { return 0;}
 
   ArrayIndexT* Dup() const
   {
@@ -905,17 +947,21 @@
   }
 };
 
+
+
 // [s:*]
 class ArrayIndexORange: public ArrayIndexT
 {
 protected:
-  SizeT s;
+  RangeT s;
 
 public:
+ IndexType Type() { return ArrayIndexORangeID;}
+
   SizeT NParam() { return 1;} // number of parameter to Init(...)
 
-  SizeT GetS() { return s;}
-  SizeT GetIx0() { return s;}
+  RangeT GetS() { return s;}
+  RangeT GetIx0() { return s;}
 
   ArrayIndexT* Dup() const
   {
@@ -924,34 +970,47 @@
     return d;
   }
 
+   // s is always scalar here
   void Init( BaseGDL* s_)
   {
-    int retMsg=s_->Scalar2index(s);
+    int retMsg=s_->Scalar2RangeT(s);
     if( retMsg == 0) // index empty or array
       {
 	if( s_->N_Elements() == 0)
 	  throw 
-	    GDLException(NULL,"Internal error: Scalar2index:"
+	    GDLException(NULL,"Internal error: Scalar2RangeT:"
 			  " 1st index empty",true,false); 
 	else
 	  throw 
 	    GDLException(NULL,"Expression must be a scalar"
 			  " in this context.",true,false); 
       }
-    if( retMsg == -1) // index < 0
-      {
-	throw 
-	  GDLException(NULL,"Subscript range values of the"
-			" form low:high must be >= 0, < size, "
-			"with low <= high.",true,false);
-      }
+// not with Scalar2RangeT():
+//     if( retMsg == -1) // index < 0
+//       {
+// 	throw 
+// 	  GDLException(NULL,"Subscript range values of the"
+// 			" form low:high must be >= 0, < size, "
+// 			"with low <= high.",true,false);
+//       }
   }
 
   BaseGDL* Index( BaseGDL* var, IxExprListT& ix)
   {
     Init( ix[0]);
+
+	SizeT varSize = var->Size();
     
-    if( s >= var->Size())
+	if( s < 0)
+		{
+			RangeT i = s + varSize;
+			if( i < 0)
+				throw GDLException(NULL,"Subscript out of range [-s:*].",true,false);
+    
+			return var->NewIxFrom( i);
+		}
+	
+    if( s >= varSize)
       throw GDLException(NULL,"Subscript out of range [s:*].",true,false);
 
     return var->NewIxFrom( s);
@@ -961,13 +1020,25 @@
   {
     if( s >= varDim)
       throw GDLException(NULL,"Subscript out of range [s:*].",true,false);
+    if( s < 0)
+    {
+		RangeT i = s + varDim;
+		if( i < 0)
+			throw GDLException(NULL,"Subscript out of range [-s:*].",true,false);
+		
+		return (varDim - i);
+    }
     return (varDim - s);
   }
 };
 
+
+
 class CArrayIndexORange: public ArrayIndexORange
 {
 public:
+ IndexType Type() { return CArrayIndexORangeID;}
+
   SizeT NParam() { return 0;} // number of parameter to Init(...)
 
   CArrayIndexORange( BaseGDL* c): ArrayIndexORange()
@@ -986,36 +1057,74 @@
 
   BaseGDL* Index( BaseGDL* var, IxExprListT& ix)
   {
-    if( s >= var->Size())
+	SizeT varSize = var->Size();
+    
+	if( s < 0)
+		{
+			RangeT i = s + varSize;
+			if( i < 0)
+				throw GDLException(NULL,"Subscript out of range [-s:*].",true,false);
+    
+			return var->NewIxFrom( i);
+		}
+    
+    if( s >= varSize)
       throw GDLException(NULL,"Subscript out of range [s:*].",true,false);
 
     return var->NewIxFrom( s);
   }
 };
 
+
+
 // [s:e]
 class ArrayIndexRange: public ArrayIndexT
 {
 protected:
-  SizeT s,e;
+  RangeT s,e;
 
 public:
+ IndexType Type() { return ArrayIndexRangeID;}
+
   SizeT NParam() { return 2;} // number of parameter to Init(...)
 
-  SizeT GetS() { return s;}
-  SizeT GetIx0() { return s;}
+  RangeT GetS() { return s;}
+  RangeT GetIx0() { return s;}
 
   BaseGDL* Index( BaseGDL* var, IxExprListT& ix)
   {
     Init( ix[0], ix[1]);
     
-    if( e >= var->Size())
+	SizeT varSize = var->Size();
+	
+    RangeT sl,el;
+	if( s < 0)
+		{
+			sl = s + varSize;
+			if( sl < 0)
+				throw GDLException(NULL,"Subscript out of range [-S:e].",true,false);
+		}
+	else
+		sl = s;
+	if( e < 0)
+		{
+			el = e + varSize;
+			if( el < 0)
+				throw GDLException(NULL,"Subscript out of range [s:-E].",true,false);
+		}
+	else
+		el = e;
+    
+    if( sl > el)
+		throw 
+			GDLException(NULL,"Subscript range values of the form low:high "
+				"must be < size, with low <= high",true,false);
+    if( el >= var->Size())
       throw GDLException(NULL,"Subscript out of range [s:e].",true,false);
 
-    return var->NewIxFrom( s, e);
+    return var->NewIxFrom( sl, el);
   }
 
-
   ArrayIndexT* Dup() const
   {
     ArrayIndexRange* d = new ArrayIndexRange();
@@ -1024,65 +1133,90 @@
     return d;
   }
 
-
   void Init( BaseGDL* s_, BaseGDL* e_)
   {
-    int retMsg=s_->Scalar2index(s);
+// 	SizeT varSize = var->Size();
+    
+    int retMsg=s_->Scalar2RangeT(s);
     if( retMsg == 0) // index empty or array
       {
 	if( s_->N_Elements() == 0)
 	  throw 
-	    GDLException(NULL,"Internal error: Scalar2index: 1st index empty.",true,false); 
+	    GDLException(NULL,"Internal error: Scalar2RangeT: 1st index empty.",true,false);
 	else
 	  throw 
 	    GDLException(NULL,"Expression must be a scalar in this context.",true,false); 
       }
-    if( retMsg == -1) // index < 0
-      {
-	throw 
-	  GDLException(NULL,"Subscript range values of the form low:high " 
-			"must be >= 0, < size, with low <= high.",true,false);
-      }
-            
-    retMsg=e_->Scalar2index(e);
+//     if( retMsg == -1) // index < 0
+//       {
+// 	throw 
+// 	  GDLException(NULL,"Subscript range values of the form low:high " 
+// 			"must be >= 0, < size, with low <= high.",true,false);
+//       }
+    
+    retMsg=e_->Scalar2RangeT(e);
     if( retMsg == 0) // index empty or array
       {
 	if( e_->N_Elements() == 0)
 	  throw 
-	    GDLException(NULL,"Internal error: Scalar2index: 2nd index empty.",true,false); 
+	    GDLException(NULL,"Internal error: Scalar2RangeT: 2nd index empty.",true,false);
 	else
 	  throw 
 	    GDLException(NULL,"Expression must be a scalar in this context.",true,false); 
       }
-    if( retMsg == -1) // index < 0
-      {
-	throw 
-	  GDLException(NULL,"Subscript range values of the form low:high " 
-			"must be >= 0, < size, with low <= high.",true,false);
-      }
+//     if( retMsg == -1) // index < 0
+//       {
+// 	throw 
+// 	  GDLException(NULL,"Subscript range values of the form low:high " 
+// 			"must be >= 0, < size, with low <= high.",true,false);
+//       }
     
-    if( e < s)
+    if( e>=0 && s>=0 && e < s)
       {
 	throw 
-	  GDLException(NULL," Subscript range values of the form low:high " 
+	  GDLException(NULL,"Subscript range values of the form low:high "
 			"must be >= 0, < size, with low <= high",true,false);
       }
   }
 
-
   // number of iterations
   // also checks/adjusts range 
   SizeT NIter( SizeT varDim)
   {
-    if( e >= varDim)
-      throw GDLException(NULL,"Subscript out of range [s:e].",true,false);
-    return (e - s + 1);
+	RangeT sl,el;
+	if( s < 0)
+	{
+		sl = s + varDim;
+		if( sl < 0)
+			throw GDLException(NULL,"Subscript out of range [S:e].",true,false);
+	}
+	else
+		sl = s;
+	if( e < 0)
+	{
+		el = e + varDim;
+		if( el < 0)
+			throw GDLException(NULL,"Subscript out of range [s:E].",true,false);
+	}
+	else
+		el = e;
+    if( sl > el)
+		throw 
+			GDLException(NULL,"Subscript range values of the form low:high "
+				"must be < size, with low <= high",true,false);
+    if( el >= varDim)
+		throw GDLException(NULL,"Subscript out of range [s:e].",true,false);
+    return (el - sl + 1);
   }
 };
 
+
+
 class CArrayIndexRange: public ArrayIndexRange
 {
 public:
+ IndexType Type() { return CArrayIndexRangeID;}
+
   SizeT NParam() { return 0;} // number of parameter to Init(...)
 
   CArrayIndexRange( BaseGDL* c1, BaseGDL* c2): ArrayIndexRange()
@@ -1100,27 +1234,56 @@
     return d;
   }
 
-  BaseGDL* Index( BaseGDL* var, IxExprListT& ix)
-  {
-    if( e >= var->Size())
+   BaseGDL* Index( BaseGDL* var, IxExprListT& ix)
+   {
+	SizeT varSize = var->Size();
+	
+    RangeT sl,el;
+	if( s < 0)
+		{
+			sl = s + varSize;
+			if( sl < 0)
+				throw GDLException(NULL,"Subscript out of range [-S:e].",true,false);
+		}
+	else
+		sl = s;
+	if( e < 0)
+		{
+			el = e + varSize;
+			if( el < 0)
+				throw GDLException(NULL,"Subscript out of range [s:-E].",true,false);
+		}
+	else
+		el = e;
+    
+    if( sl > el)
+		throw 
+			GDLException(NULL,"Subscript range values of the form low:high "
+				"must be < size, with low <= high",true,false);
+    if( el >= var->Size())
       throw GDLException(NULL,"Subscript out of range [s:e].",true,false);
 
-    return var->NewIxFrom( s, e);
-  }
+    return var->NewIxFrom( sl, el);
+   }
 };
 
+
+
 // [s:*:st]
 class ArrayIndexORangeS: public ArrayIndexT
 {
 protected:
-  SizeT s,stride;
+  RangeT s;
+  SizeT stride;
 
 public:
+ IndexType Type() { return ArrayIndexORangeSID;}
+
   SizeT NParam() { return 2;} // number of parameter to Init(...)
 
-  SizeT GetS() { return s;}
+  RangeT GetS() { return s;}
   SizeT GetStride() { return stride;}
-  SizeT GetIx0() { return s;}
+  RangeT GetIx0() { return s;}
 
   ArrayIndexT* Dup() const
   {
@@ -1132,47 +1295,58 @@
 
   void Init( BaseGDL* s_, BaseGDL* stride_)
   {
-    int retMsg=s_->Scalar2index( s);
+    int retMsg=s_->Scalar2RangeT( s);
     if( retMsg == 0) // index empty or array
       {
-	if( s_->N_Elements() == 0)
-	  throw 
-	    GDLException(  "Internal error: Scalar2index:"
-			  " 1st index empty",true,false); 
-	else
-	  throw 
-	    GDLException(  "Expression must be a scalar"
-			  " in this context.",true,false); 
-      }
-    if( retMsg == -1) // index < 0
-      {
-	throw 
-	  GDLException(  "Subscript range values of the"
-			" form low:high must be >= 0, < size, with low <= high.",true,false);
-      }
+			if( s_->N_Elements() == 0)
+			throw
+				GDLException(  "Internal error: Scalar2RangeT:"
+					" 1st index empty",true,false);
+			else
+			throw
+				GDLException(  "Expression must be a scalar"
+					" in this context.",true,false);
+      }
+//     if( retMsg == -1) // index < 0
+//       {
+// 	throw 
+// 	  GDLException(  "Subscript range values of the"
+// 			" form low:high must be >= 0, < size, with low <= high.",true,false);
+//       }
     // stride
     retMsg=stride_->Scalar2index( stride);
     if( retMsg == 0) // index empty or array
       {
-	if( stride_->N_Elements() == 0)
-	  throw 
-	    GDLException(  "Internal error: Scalar2index:"
-			  " stride index empty",true,false); 
-	else
-	  throw 
-	    GDLException(  "Expression must be a scalar"
-			  " in this context.",true,false); 
+			if( stride_->N_Elements() == 0)
+			throw
+				GDLException(  "Internal error: Scalar2index:"
+					" stride index empty",true,false);
+			else
+			throw
+				GDLException(  "Expression must be a scalar"
+					" in this context.",true,false);
       }
     if( retMsg == -1 || stride == 0) // stride <= 0
       {
-	throw 
-	  GDLException(  "Range subscript stride must be >= 1.",true,false);
+			throw 
+			GDLException(  "Range subscript stride must be >= 1.",true,false);
       }
   }
 
   BaseGDL* Index( BaseGDL* var, IxExprListT& ix)
   {
     Init( ix[0], ix[1]);
+	
+	SizeT varSize = var->Size();
+
+	if( s < 0)
+		{
+			RangeT sl = s + varSize;
+			if( sl < 0)
+				throw GDLException(NULL,"Subscript out of range [-S:*:stride].",true,false);
+
+			return var->NewIxFromStride( sl, stride);
+		}
 
     if( s >= var->Size())
       throw GDLException(NULL,"Subscript out of range [s:*:stride].",true,false);
@@ -1184,6 +1358,14 @@
   // also checks/adjusts range 
   SizeT NIter( SizeT varDim)
   {
+	if( s < 0)
+		{
+			RangeT sl = s + varDim;
+			if( sl < 0)
+				throw GDLException(NULL,"Subscript out of range [-S:*:stride].",true,false);
+			return (varDim - sl + stride - 1)/stride;
+		}
+    
     if( s >= varDim)
       throw GDLException(NULL,"Subscript out of range [s:*:stride].",true,false);
     return (varDim - s + stride - 1)/stride;
@@ -1193,6 +1375,8 @@
 class CArrayIndexORangeS: public ArrayIndexORangeS
 {
 public:
+ IndexType Type() { return CArrayIndexORangeSID;}
+
   SizeT NParam() { return 0;} // number of parameter to Init(...)
 
   CArrayIndexORangeS( BaseGDL* c1, BaseGDL* c2): ArrayIndexORangeS()
@@ -1212,6 +1396,17 @@
 
   BaseGDL* Index( BaseGDL* var, IxExprListT& ix)
   {
+	SizeT varSize = var->Size();
+
+	if( s < 0)
+		{
+			RangeT sl = s + varSize;
+			if( sl < 0)
+				throw GDLException(NULL,"Subscript out of range [-S:*:stride].",true,false);
+
+			return var->NewIxFromStride( sl, stride);
+		}
+
     if( s >= var->Size())
       throw GDLException(NULL,"Subscript out of range [s:*:stride].",true,false);
 
@@ -1223,14 +1418,17 @@
 class ArrayIndexRangeS: public ArrayIndexT
 {
 protected:
-  SizeT s,e,stride;
+  RangeT s,e;
+  SizeT stride;
 
 public:
+ IndexType Type() { return ArrayIndexRangeSID;}
+
   SizeT NParam() { return 3;} // number of parameter to Init(...)
 
-  SizeT GetS() { return s;}
+  RangeT GetS() { return s;}
   SizeT GetStride() { return stride;}
-  SizeT GetIx0() { return s;}
+  RangeT GetIx0() { return s;}
 
   ArrayIndexT* Dup() const
   {
@@ -1243,45 +1441,45 @@
 
   void Init( BaseGDL* s_, BaseGDL* e_, BaseGDL* stride_)
   {
-    int retMsg=s_->Scalar2index(s);
+    int retMsg=s_->Scalar2RangeT(s);
     if( retMsg == 0) // index empty or array
       {
 	if( s_->N_Elements() == 0)
 	  throw 
-	    GDLException(  "Internal error: Scalar2index: 1st index empty.",true,false); 
+	    GDLException(  "Internal error: Scalar2RangeT: 1st index empty.",true,false);
 	else
 	  throw 
 	    GDLException(  "Expression must be a scalar in this context.",true,false); 
       }
-    if( retMsg == -1) // index < 0
-      {
-	throw 
-	  GDLException(  "Subscript range values of the form low:high " 
-			"must be >= 0, < size, with low <= high.",true,false);
-      }
+//     if( retMsg == -1) // index < 0
+//       {
+// 	throw 
+// 	  GDLException(  "Subscript range values of the form low:high " 
+// 			"must be >= 0, < size, with low <= high.",true,false);
+//       }
             
-    retMsg=e_->Scalar2index(e);
+    retMsg=e_->Scalar2RangeT(e);
     if( retMsg == 0) // index empty or array
       {
 	if( e_->N_Elements() == 0)
 	  throw 
-	    GDLException(  "Internal error: Scalar2index: 2nd index empty.",true,false); 
+	    GDLException(  "Internal error: Scalar2RangeT: 2nd index empty.",true,false);
 	else
 	  throw 
 	    GDLException(  "Expression must be a scalar in this context.",true,false); 
       }
-    if( retMsg == -1) // index < 0
-      {
-	throw 
-	  GDLException(  "Subscript range values of the form low:high " 
-			"must be >= 0, < size, with low <= high.",true,false);
-      }
+//     if( retMsg == -1) // index < 0
+//       {
+// 	throw 
+// 	  GDLException(  "Subscript range values of the form low:high " 
+// 			"must be >= 0, < size, with low <= high.",true,false);
+//       }
             
-    if( e < s)
+    if( e >= 0 && s >= 0 && e < s)
       {
-	throw 
-	  GDLException(  "Subscript range values of the form low:high " 
-			"must be >= 0, < size, with low <= high",true,false);
+		throw 
+		GDLException(  "Subscript range values of the form low:high "
+				"must be < size, with low <= high",true,false);
       }
                             
     // stride
@@ -1308,29 +1506,79 @@
   {
     Init( ix[0], ix[1], ix[2]);
 
-    if( e >= var->Size())
+	SizeT varSize = var->Size();
+	
+    RangeT sl,el;
+	if( s < 0)
+		{
+			sl = s + varSize;
+			if( sl < 0)
+				throw GDLException(NULL,"Subscript out of range [-S:e:stride].",true,false);
+		}
+	else
+		sl = s;
+	if( e < 0)
+		{
+			el = e + varSize;
+			if( el < 0)
+				throw GDLException(NULL,"Subscript out of range [s:-E:stride].",true,false);
+		}
+	else
+		el = e;
+    
+    if( sl > el)
+		throw 
+			GDLException(NULL,"Subscript range values of the form low:high "
+				"must be < size, with low <= high",true,false);
+    
+    if( el >= var->Size())
       {
 	throw GDLException(NULL,"Subscript out of range [s:e:st].",true,false);
       }
 
-    return var->NewIxFromStride( s, e, stride);
+    return var->NewIxFromStride( sl, el, stride);
   }
 
   // number of iterations
   // also checks/adjusts range 
   SizeT NIter( SizeT varDim)
   {
-    if( e >= varDim)
+    RangeT sl,el;
+	if( s < 0)
+		{
+			sl = s + varDim;
+			if( sl < 0)
+				throw GDLException(NULL,"Subscript out of range [-S:e:stride].",true,false);
+		}
+	else
+		sl = s;
+	if( e < 0)
+		{
+			el = e + varDim;
+			if( el < 0)
+				throw GDLException(NULL,"Subscript out of range [s:-E:stride].",true,false);
+		}
+	else
+		el = e;
+    
+    if( sl > el)
+		throw 
+			GDLException(NULL,"Subscript range values of the form low:high "
+				"must be < size, with low <= high",true,false);
+    
+    if( el >= varDim)
       {
-	throw GDLException(NULL,"Subscript out of range [s:e:st].",true,false);
+		throw GDLException(NULL,"Subscript out of range [s:e:st].",true,false);
       }
-    return (e - s + stride)/stride;
+    return (el - sl + stride)/stride;
   }
 };
 
 class CArrayIndexRangeS: public ArrayIndexRangeS
 {
 public:
+ IndexType Type() { return CArrayIndexRangeSID;}
+
   SizeT NParam() { return 0;} // number of parameter to Init(...)
 
   CArrayIndexRangeS( BaseGDL* c1, BaseGDL* c2, BaseGDL* c3): 
@@ -1352,12 +1600,37 @@
 
   BaseGDL* Index( BaseGDL* var, IxExprListT& ix)
   {
-    if( e >= var->Size())
+	SizeT varSize = var->Size();
+	
+    RangeT sl,el;
+	if( s < 0)
+		{
+			sl = s + varSize;
+			if( sl < 0)
+				throw GDLException(NULL,"Subscript out of range [-S:e:stride].",true,false);
+		}
+	else
+		sl = s;
+	if( e < 0)
+		{
+			el = e + varSize;
+			if( el < 0)
+				throw GDLException(NULL,"Subscript out of range [s:-E:stride].",true,false);
+		}
+	else
+		el = e;
+    
+    if( sl > el)
+		throw 
+			GDLException(NULL,"Subscript range values of the form low:high "
+				"must be < size, with low <= high",true,false);
+    
+    if( el >= var->Size())
       {
-	throw GDLException(NULL,"Subscript out of range [s:e:st].",true,false);
+		throw GDLException(NULL,"Subscript out of range [s:e:st].",true,false);
       }
 
-    return var->NewIxFromStride( s, e, stride);
+    return var->NewIxFromStride( sl, el, stride);
   }
 };
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/arrayindexlistt.hpp cvs/gdl/src/arrayindexlistt.hpp
--- gdl-0.9rc4/src/arrayindexlistt.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/arrayindexlistt.hpp	2010-05-21 10:23:54.885967465 -0600
@@ -1014,11 +1014,11 @@
     SizeT nScalar  = 0;
     for( SizeT i=0; (i+1)<ixList.size(); ++i)
       {
-	// note: here we examine the actual type
-	if( dynamic_cast< ArrayIndexScalar*>(ixList[i]) ||
-	    dynamic_cast< CArrayIndexScalar*>(ixList[i])) nScalar++;
-	if( dynamic_cast< ArrayIndexIndexed*>(ixList[i]) ||
-	    dynamic_cast< CArrayIndexIndexed*>(ixList[i])) nIndexed++;
+		// note: here we examine the actual type
+		if( ArrayIndexScalarID == ixList[i]->Type() ||
+			CArrayIndexScalarID == ixList[i]->Type() ) nScalar++;
+		if( ArrayIndexIndexedID == ixList[i]->Type() ||
+			CArrayIndexIndexedID == ixList[i]->Type()) nIndexed++;
       }
     if( nScalar == ixList.size()-1)
       accessTypeAssocInit = ALLONE;
@@ -1029,10 +1029,14 @@
     else
       accessTypeAssocInit = INDEXED_ONE;
     
-    if( dynamic_cast< ArrayIndexScalar*>(ixList[ixList.size()-1]) ||
+	if( ArrayIndexScalarID == ixList[ixList.size()-1]->Type() ||
+		CArrayIndexScalarID == ixList[ixList.size()-1]->Type()) nScalar++;
+	if( ArrayIndexIndexedID == ixList[ixList.size()-1]->Type() ||
+		CArrayIndexIndexedID == ixList[ixList.size()-1]->Type()) nIndexed++;
+/*    if( dynamic_cast< ArrayIndexScalar*>(ixList[ixList.size()-1]) ||
 	dynamic_cast< CArrayIndexScalar*>(ixList[ixList.size()-1])) nScalar++;
     if( dynamic_cast<ArrayIndexIndexed*>(ixList[ixList.size()-1]) ||
-	dynamic_cast<CArrayIndexIndexed*>(ixList[ixList.size()-1]) ) nIndexed++;
+	dynamic_cast<CArrayIndexIndexed*>(ixList[ixList.size()-1]) ) nIndexed++;*/
     
     if( nScalar == ixList.size())
       accessTypeInit = ALLONE;
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/assocdata.cpp cvs/gdl/src/assocdata.cpp
--- gdl-0.9rc4/src/assocdata.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/assocdata.cpp	2010-07-07 14:41:00.569942552 -0600
@@ -103,9 +103,8 @@
 
       if( fileUnits[ lun].Size() > seekPos)
 	{
-	  fstream& fs = fileUnits[ lun].IStream();
 	  fileUnits[ lun].Seek( seekPos);
-	  Parent_::Read( fs, 
+	  Parent_::Read( (fileUnits[lun].Compress()?static_cast<std::istream&>(fileUnits[lun].IgzStream()):static_cast<std::istream&>(fileUnits[lun].IStream())), 
 			 fileUnits[ lun].SwapEndian(),
 			 fileUnits[ lun].Compress(),
 			 fileUnits[ lun].Xdr());
@@ -149,9 +148,9 @@
 
       if( fileUnits[ lun].Size() > seekPos)
 	{
-	  fstream& fs = fileUnits[ lun].IStream();
+//	  fstream& fs = fileUnits[ lun].IStream();
 	  fileUnits[ lun].Seek( seekPos);
-	  Parent_::Read( fs, 
+	  Parent_::Read( (fileUnits[lun].Compress()?static_cast<std::istream&>(fileUnits[lun].IgzStream()):static_cast<std::istream&>(fileUnits[lun].IStream())),  
 			 fileUnits[ lun].SwapEndian(),
 			 fileUnits[ lun].Compress(),
 			 fileUnits[ lun].Xdr());
@@ -234,7 +233,7 @@
       // throw GDLException("File expression cannot be subindexed for output.");
       fstream& fs = fileUnits[ lun].IStream();
       fileUnits[ lun].Seek( fileOffset + recordNum * sliceSize);
-      Parent_::Read( fs, 
+      Parent_::Read( fs,
 		     fileUnits[ lun].SwapEndian(),
 		     fileUnits[ lun].Compress(),
 		     fileUnits[ lun].Xdr());
@@ -259,9 +258,9 @@
   SizeT recordNum;
   bool ixEmpty = ixList->ToAssocIndex( recordNum);
 
-  fstream& fs = fileUnits[ lun].IStream();
+  istream& fs = fileUnits[lun].Compress()?static_cast<std::istream&>(fileUnits[lun].IgzStream()):static_cast<std::istream&>(fileUnits[lun].IStream());
   fileUnits[ lun].Seek( fileOffset + recordNum * sliceSize);
-  Parent_::Read( fs, 
+  Parent_::Read( fs,
 		 fileUnits[ lun].SwapEndian(),
 		 fileUnits[ lun].Compress(),
 		 fileUnits[ lun].Xdr());
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/assocdata.hpp cvs/gdl/src/assocdata.hpp
--- gdl-0.9rc4/src/assocdata.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/assocdata.hpp	2010-05-21 10:23:54.895969758 -0600
@@ -44,13 +44,13 @@
   ~Assoc_() {}
   
   // c-i
-  Assoc_( const Assoc_& cp): Parent_( cp),
+  Assoc_( const Assoc_& cp): Parent_(cp),
 			     lun(cp.lun),
 			     fileOffset( cp.fileOffset),
 			     sliceSize( cp.sliceSize)
   {}
 
-  Parent_* Dup() { return new Assoc_(*this);}
+ Parent_* Dup() { return new Assoc_(*this);}
 
   void AssignAt( BaseGDL* srcIn, ArrayIndexListT* ixList, SizeT offset);
   void AssignAt( BaseGDL* srcIn, ArrayIndexListT* ixList);
@@ -170,11 +170,22 @@
     throw GDLException("File expression not allowed in this context.");
   }
 
+  bool EqualNoDelete( const BaseGDL*)
+  {
+    throw GDLException("File expression not allowed in this context.");
+  }
+
   void ForCheck( BaseGDL**, BaseGDL** = NULL)
   {
     throw GDLException("File expression not allowed in this context.");
   }
 
+  bool ForAddCondUp( BaseGDL* loopInfo)
+//   bool ForAddCondUp( ForLoopInfoT& loopInfo)
+  {
+    throw GDLException("File expression not allowed in this context.");
+  }
+  
   bool ForCondUp( BaseGDL*)
   {
     throw GDLException("File expression not allowed in this context.");
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/basegdl.cpp cvs/gdl/src/basegdl.cpp
--- gdl-0.9rc4/src/basegdl.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/basegdl.cpp	2010-05-21 10:23:54.899967552 -0600
@@ -191,6 +191,10 @@
 { 
   throw GDLException("Operation not defined for UNDEF 1.");
 }
+int BaseGDL::Scalar2RangeT(RangeT& ret) const
+{ 
+  throw GDLException("Operation not defined for UNDEF 1a.");
+}
 
 bool BaseGDL::BaseGDL::True()
 {
@@ -227,16 +231,21 @@
   throw GDLException("Operation not defined for UNDEF 5.");
 }
 
-bool BaseGDL::Equal( BaseGDL*)
+bool BaseGDL::Equal( BaseGDL*) const
 {
   throw GDLException("Operation not defined for UNDEF 6.");
 }
 
-bool BaseGDL::ArrayEqual( BaseGDL*)
+bool BaseGDL::EqualNoDelete( const BaseGDL*) const
 {
   throw GDLException("Operation not defined for UNDEF 6a.");
 }
 
+bool BaseGDL::ArrayEqual( BaseGDL*)
+{
+  throw GDLException("Operation not defined for UNDEF 6b.");
+}
+
 // for statement compliance (int types , float types scalar only)
 void BaseGDL::ForCheck( BaseGDL**, BaseGDL**)
 {
@@ -248,6 +257,12 @@
   throw GDLException("Operation not defined for UNDEF 8.");
 }
 
+bool BaseGDL::ForAddCondUp( BaseGDL* loopInfo)
+// bool BaseGDL::ForAddCondUp( ForLoopInfoT& loopInfo)
+{
+  throw GDLException("Operation not defined for UNDEF 8a.");
+}
+
 bool BaseGDL::ForCondDown( BaseGDL*)
 {
   throw GDLException("Operation not defined for UNDEF 9.");
@@ -414,7 +429,7 @@
   throw GDLException("Operation not defined for UNDEF 171.");
 }
 
-BaseGDL* BaseGDL::MatrixOp( BaseGDL* r)   
+BaseGDL* BaseGDL::MatrixOp( BaseGDL* r, bool rtranspose, bool transposeResult, bool strassen)
 {
   throw GDLException("Operation not defined for UNDEF 18.");
 }
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/basegdl.hpp cvs/gdl/src/basegdl.hpp
--- gdl-0.9rc4/src/basegdl.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/basegdl.hpp	2010-07-07 14:41:00.598003107 -0600
@@ -33,6 +33,13 @@
 #ifdef HAVE_MALLOC_MALLOC_H
 #  include <malloc/malloc.h>
 #endif
+#if !defined(HAVE_MALLINFO) 
+#  if (!defined(HAVE_MALLOC_ZONE_STATISTICS) || !defined(HAVE_MALLOC_MALLOC_H))
+#    if defined(HAVE_SBRK)
+#      include <unistd.h>
+#    endif
+#  endif
+#endif
 
 // GDL typecodes
 enum DType {  // Object types (IDL type numbers)
@@ -157,8 +164,8 @@
   true, 	//STRING,	
   true, 	//STRUCT,	
   true, 	//COMPLEXDBL,	
-  false, 	//PTR,		
-  false, 	//OBJECT,
+  true, 	//PTR, nonPOD due to reference counting
+  true, 	//OBJECT, nonPOD due to reference counting
   false, 	//UINT,	
   false, 	//ULONG,
   false, 	//LONG64,
@@ -210,6 +217,8 @@
 struct SpDULong;
 template<class> class Data_;
 
+struct ForLoopInfoT;
+
 void breakpoint();
 
 // --- SA: MemStats stuff
@@ -364,7 +373,7 @@
     return i;
   }
 
-  virtual BaseGDL& operator=(const BaseGDL& right);
+ virtual BaseGDL& operator=(const BaseGDL& right);
 
   // virtual functions
   virtual bool IsAssoc() const;
@@ -420,6 +429,7 @@
   virtual BaseGDL* SetBuffer( const void* b);
   virtual void     SetBufferSize( SizeT s);
   virtual int Scalar2index(SizeT& ret) const;
+  virtual int Scalar2RangeT(RangeT& ret) const;
   virtual SizeT LoopIndex() const; 
   virtual bool True();
   virtual bool False();
@@ -428,12 +438,16 @@
   virtual DLong* Where( bool comp, SizeT& count);
   virtual BaseGDL* LogNeg();
   virtual int Sgn(); // -1,0,1
-  virtual bool Equal( BaseGDL*);
+  virtual bool Equal( BaseGDL*) const;
+  virtual bool EqualNoDelete( const BaseGDL*) const;
   virtual bool ArrayEqual( BaseGDL*);
   // for statement compliance (int types , float types scalar only)
   virtual void ForCheck( BaseGDL**, BaseGDL** = NULL);
   virtual bool ForCondUp( BaseGDL*);
   virtual bool ForCondDown( BaseGDL*);
+  virtual bool ForAddCondUp( BaseGDL* loopInfo);
+//   virtual bool ForAddCondUp( ForLoopInfoT& loopInfo);
+//  virtual bool ForAddCondDown( ForLoopInfoT& loopInfo);
 //   virtual bool ForCondUpDown( BaseGDL*);
   virtual void ForAdd( BaseGDL* add=NULL);
   virtual BaseGDL* CatArray( ExprListT& exprList,
@@ -530,7 +544,7 @@
   //  virtual BaseGDL* ModInvNew( BaseGDL* r);   
   virtual BaseGDL* PowNew( BaseGDL* r);     
   //  virtual BaseGDL* PowInvNew( BaseGDL* r);  
-  virtual BaseGDL* MatrixOp( BaseGDL* r);   
+  virtual BaseGDL* MatrixOp( BaseGDL* r, bool rtranspose = false, bool transposeResult =false, bool strassen = false);
   virtual void AssignAt( BaseGDL* srcIn, ArrayIndexListT* ixList, SizeT offset);
   virtual void AssignAt( BaseGDL* srcIn, ArrayIndexListT* ixList);
   virtual void AssignAt( BaseGDL* srcIn);
@@ -578,7 +592,29 @@
   }
 };
 
+
+
 typedef ExprListT::iterator ExprListIterT;
 
+
+
+struct ForLoopInfoT
+{
+	BaseGDL*  endLoopVar; // the source for foreach as well
+	BaseGDL*  loopStepVar;
+	DLong        foreachIx;
+
+	ForLoopInfoT()
+	: endLoopVar(NULL)
+	, loopStepVar(NULL)
+	, foreachIx(-1)
+	{}
+	~ForLoopInfoT()
+	{
+		delete endLoopVar;
+		delete loopStepVar;
+	}
+};
+
 #endif
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/basic_fun_cl.cpp cvs/gdl/src/basic_fun_cl.cpp
--- gdl-0.9rc4/src/basic_fun_cl.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/basic_fun_cl.cpp	2010-05-21 10:23:55.098906081 -0600
@@ -128,7 +128,7 @@
       DIntGDL* v = static_cast<DIntGDL*>(e->GetParDefined(0)->Convert2(INT,BaseGDL::COPY));
       v_guard.reset( v); //  e->Guard(v);
 
-      if (v->Equal(new DIntGDL(1)))
+      if ( (*v)[0] == 1) //->EqualNoDelete( static_cDIntGDL(1)))
         ret_seconds=true;
     } else if (nParam == 2) {
       if (e->KeywordSet("JULIAN")) e->Throw("Conflicting keywords.");
@@ -140,7 +140,7 @@
       v_guard.reset( v1); //  e->Guard(v1);
       DDoubleGDL* v2 = static_cast<DDoubleGDL*>(e->GetParDefined(1)->Convert2(DOUBLE,BaseGDL::COPY));
 
-      if(v1->Equal(new DIntGDL(0))) { //0, read the second argument as time_t;
+      if( (*v1)[0] == 0) { //v1->EqualNoDelete( DIntGDL(0))) { //0, read the second argument as time_t;
         tval.tv_sec = static_cast<long int>((*v2)[0]);
         tval.tv_usec = static_cast<long int>(((*v2)[0]-tval.tv_sec)*1e+6);
         delete v2; // we delete v2 here as it is not guarded. Avoids a "new" in the following "else"
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/basic_fun.cpp cvs/gdl/src/basic_fun.cpp
--- gdl-0.9rc4/src/basic_fun.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/basic_fun.cpp	2010-07-07 14:41:00.646004164 -0600
@@ -38,7 +38,7 @@
 #include <unistd.h>
 #endif
 
-#if defined(__FreeBSD__) || defined(__sun__)
+#if defined(__FreeBSD__) || defined(__sun__) || defined(__OpenBSD__)
 extern "C" char **environ;
 #endif
 
@@ -322,21 +322,26 @@
 
       DPtrGDL* ret;
 
-      if( e->KeywordSet(0) || e->KeywordSet(1)) 
+//       if( e->KeywordSet(0))
+// 	       ret= new DPtrGDL(dim);//, BaseGDL::NOZERO);
+//       else
+//     if( e->KeywordSet(1))
+// 	ret= new DPtrGDL(dim, BaseGDL::NOZERO);
+//       else
+// 	return new DPtrGDL(dim);
+    if( !e->KeywordSet(1))
+		return new DPtrGDL(dim);
+
 	ret= new DPtrGDL(dim, BaseGDL::NOZERO);
-      else
-	return new DPtrGDL(dim);
 
-      if( e->KeywordSet(1))
-	{
 	  SizeT nEl=ret->N_Elements();
 	  SizeT sIx=e->NewHeap(nEl);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-	  for( SizeT i=0; i<nEl; i++) (*ret)[i]=sIx+i;
+	  for( SizeT i=0; i<nEl; i++)
+		(*ret)[i]=sIx+i;
 }
-	}
       return ret;
 /*    }
     catch( GDLException& ex)
@@ -352,7 +357,7 @@
       if (dim[0] == 0)
 	throw GDLException( "Array dimensions must be greater than 0");
 
-      if( e->KeywordSet(0)) return new DObjGDL(dim, BaseGDL::NOZERO);
+// reference counting      if( e->KeywordSet(0)) return new DObjGDL(dim, BaseGDL::NOZERO);
       return new DObjGDL(dim);
   /*  }
     catch( GDLException& ex)
@@ -492,7 +497,7 @@
 	auto_ptr<DLongGDL> pL_guard;
 	if( pL == NULL)
 	  {
-	    pL = static_cast<DLongGDL*>(p->Convert2(LONG,BaseGDL::COPY)); 
+	    pL = static_cast<DLongGDL*>(p->Convert2(LONG,BaseGDL::COPY));
 	    pL_guard.reset( pL);
 	    //	    e->Guard( pL);
 	  }
@@ -1239,6 +1244,8 @@
     return e->Interpreter()->call_fun( method->GetTree());
   }
 
+
+
   BaseGDL* execute( EnvT* e)
   {
     int nParam=e->NParam( 1);
@@ -1259,7 +1266,8 @@
     e->AssureScalarPar<DStringGDL>( 0, line);
 
     // remove current environment (own one)
-    EnvBaseT* caller = e->Caller();
+    assert( dynamic_cast<EnvUDT*>(e->Caller()) != NULL);
+    EnvUDT* caller = static_cast<EnvUDT*>(e->Caller());
     e->Interpreter()->CallStack().pop_back();
     delete e;
 
@@ -1312,30 +1320,42 @@
       
     if( trAST == NULL) return new DIntGDL( 1);
 
+	int nForLoopsIn = caller->NForLoops();
     try
       {
-	ProgNodeP progAST = ProgNode::NewProgNode( trAST);
-	auto_ptr< ProgNode> progAST_guard( progAST);
+		ProgNodeP progAST = ProgNode::NewProgNode( trAST);
+		auto_ptr< ProgNode> progAST_guard( progAST);
 
-	GDLInterpreter::RetCode retCode =
-	  caller->Interpreter()->execute( progAST);
+		int nForLoops = ProgNode::NumberForLoops( progAST, nForLoopsIn);
+		caller->ResizeForLoops( nForLoops);
 
-	if( retCode == GDLInterpreter::RC_OK)
-	  return new DIntGDL( 1);
-	else
-	  return new DIntGDL( 0);
+		progAST->setLine( e->GetLineNumber());
+
+		RetCode retCode = caller->Interpreter()->execute( progAST);
+
+		caller->ResizeForLoops( nForLoopsIn);
+
+		if( retCode == RC_OK)
+		return new DIntGDL( 1);
+		else
+		return new DIntGDL( 0);
       }
     catch( GDLException& ex)
       {
-	if( !quietCompile) cerr << "EXECUTE: Unhandled GDL exception: " <<  
-			     ex.getMessage() << endl;
-	return new DIntGDL( 0);
+		caller->ResizeForLoops( nForLoopsIn);
+		// are we throwing to target environment?
+// 		if( ex.GetTargetEnv() == NULL)
+			if( !quietCompile) cerr << "EXECUTE: " <<
+					ex.getMessage() << endl;
+		return new DIntGDL( 0);
       }
     catch( ANTLRException ex)
       {
-	if( !quietCompile) cerr << "EXECUTE: Interpreter exception: " <<  
-			     ex.getMessage() << endl;
-	return new DIntGDL( 0);
+		caller->ResizeForLoops( nForLoopsIn);
+		
+		if( !quietCompile) cerr << "EXECUTE: Interpreter exception: " <<
+					ex.getMessage() << endl;
+		return new DIntGDL( 0);
       }
 
     return new DIntGDL( 0); // control flow cannot reach here - compiler shut up
@@ -1751,7 +1771,7 @@
     DLong scVal1;
     bool sc1 = p1L->Scalar( scVal1);
 
-    long scVal2 = numeric_limits<long>::max();
+    DLong scVal2 = numeric_limits<DLong>::max();
     bool sc2 = true;
     if( p2L != NULL) 
       {
@@ -1766,7 +1786,7 @@
 	stride = p1L->Dim( 0);
 	if( stride != p2L->Dim( 0))
 	  e->Throw(
-			      "Starting offset and Length arguments "
+			      "Starting offset and length arguments "
 			      "have incompatible first dimension.");	  
       }
     else
@@ -1790,21 +1810,21 @@
     SizeT nEl2 = (sc2)? 1 : p2L->N_Elements();
 
     SizeT nSrcStr = p0S->N_Elements();
-#pragma omp parallel if ((nSrcStr*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nSrcStr*10)))
+#pragma omp parallel if ((nSrcStr*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nSrcStr*10))) default( shared)
 {
 #pragma omp for
     for( long i=0; i<nSrcStr; ++i)
       {
-	for( long ii=0; ii<stride; ++ii)
-	  {
-	    SizeT destIx = i * stride + ii;
-	    DLong actFirst = (sc1)? scVal1 : (*p1L)[ destIx % nEl1];
-	    DLong actLen   = (sc2)? scVal2 : (*p2L)[ destIx % nEl2];
-	if( actLen <= 0)
-		(*res)[ destIx] = "";//StrMid((*p0S)[ i], actFirst, actLen, reverse);
-	else	
-		(*res)[ destIx] = StrMid((*p0S)[ i], actFirst, actLen, reverse);
-	  }
+		for( long ii=0; ii<stride; ++ii)
+		{
+			SizeT destIx = i * stride + ii;
+			DLong actFirst = (sc1)? scVal1 : (*p1L)[ destIx % nEl1];
+			DLong actLen   = (sc2)? scVal2 : (*p2L)[ destIx % nEl2];
+			if( actLen <= 0)
+				(*res)[ destIx] = "";//StrMid((*p0S)[ i], actFirst, actLen, reverse);
+			else	
+				(*res)[ destIx] = StrMid((*p0S)[ i], actFirst, actLen, reverse);
+		}
       }
 }    
     return res;
@@ -2146,11 +2166,13 @@
     static int intIx = e->KeywordIx("INTEGER");
     static int doubleIx = e->KeywordIx( "DOUBLE");
     static int nanIx = e->KeywordIx( "NAN");
+    static int preserveIx = e->KeywordIx( "PRESERVE_TYPE");
 
     bool cumulative = e->KeywordSet( cumIx);
     bool intRes  = e->KeywordSet( intIx);
     bool doubleRes  = e->KeywordSet( doubleIx);
     bool nan        = e->KeywordSet( nanIx);
+    bool preserve   = e->KeywordSet( preserveIx);
 
     DLong sumDim = 0;
     if( nParam == 2)
@@ -2160,6 +2182,24 @@
       {
 	if( !cumulative)
 	  {
+            if (preserve) 
+            {
+              switch (p0->Type())
+              {
+                case BYTE: return total_template<DByteGDL>(static_cast<DByteGDL*>(p0), false);
+                case INT: return total_template<DIntGDL>(static_cast<DIntGDL*>(p0), false);
+                case UINT: return total_template<DUIntGDL>(static_cast<DUIntGDL*>(p0), false);
+                case LONG: return total_template<DLongGDL>(static_cast<DLongGDL*>(p0), false);
+                case ULONG: return total_template<DULongGDL>(static_cast<DULongGDL*>(p0), false);
+                case LONG64: return total_template<DLong64GDL>(static_cast<DLong64GDL*>(p0), false);
+                case ULONG64: return total_template<DULong64GDL>(static_cast<DULong64GDL*>(p0), false);
+                case FLOAT: return total_template<DFloatGDL>(static_cast<DFloatGDL*>(p0), nan);
+                case DOUBLE: return total_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0), nan);
+                case COMPLEX: return total_template<DComplexGDL>(static_cast<DComplexGDL*>(p0), nan);
+                case COMPLEXDBL: return total_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0), nan);
+                default: assert(false);
+              }
+            }
 
 	    // Integer parts by Erin Sheldon
 	    // In IDL total(), the INTEGER keyword takes precedence 
@@ -2229,6 +2269,24 @@
 	  }
 	else // cumulative
 	  {
+            if (preserve) 
+            {
+              switch (p0->Type())
+              {
+                case BYTE: return total_cu_template<DByteGDL>(static_cast<DByteGDL*>(p0)->Dup(), false);
+                case INT: return total_cu_template<DIntGDL>(static_cast<DIntGDL*>(p0)->Dup(), false);
+                case UINT: return total_cu_template<DUIntGDL>(static_cast<DUIntGDL*>(p0)->Dup(), false);
+                case LONG: return total_cu_template<DLongGDL>(static_cast<DLongGDL*>(p0)->Dup(), false);
+                case ULONG: return total_cu_template<DULongGDL>(static_cast<DULongGDL*>(p0)->Dup(), false);
+                case LONG64: return total_cu_template<DLong64GDL>(static_cast<DLong64GDL*>(p0)->Dup(), false);
+                case ULONG64: return total_cu_template<DULong64GDL>(static_cast<DULong64GDL*>(p0)->Dup(), false);
+                case FLOAT: return total_cu_template<DFloatGDL>(static_cast<DFloatGDL*>(p0)->Dup(), nan);
+                case DOUBLE: return total_cu_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0)->Dup(), nan);
+                case COMPLEX: return total_cu_template<DComplexGDL>(static_cast<DComplexGDL*>(p0)->Dup(), nan);
+                case COMPLEXDBL: return total_cu_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0)->Dup(), nan);
+                default: assert(false);
+              }
+            }
 
 	    // INTEGER keyword takes precedence
 	    if( intRes )
@@ -2302,6 +2360,24 @@
 
     if( !cumulative)
       {
+        if (preserve) 
+        {
+          switch (p0->Type())
+          {
+            case BYTE: return total_over_dim_template<DByteGDL>(static_cast<DByteGDL*>(p0), srcDim, sumDim-1, false);
+            case INT: return total_over_dim_template<DIntGDL>(static_cast<DIntGDL*>(p0), srcDim, sumDim-1, false);
+            case UINT: return total_over_dim_template<DUIntGDL>(static_cast<DUIntGDL*>(p0), srcDim, sumDim-1, false);
+            case LONG: return total_over_dim_template<DLongGDL>(static_cast<DLongGDL*>(p0), srcDim, sumDim-1, false);
+            case ULONG: return total_over_dim_template<DULongGDL>(static_cast<DULongGDL*>(p0), srcDim, sumDim-1, false);
+            case LONG64: return total_over_dim_template<DLong64GDL>(static_cast<DLong64GDL*>(p0), srcDim, sumDim-1, false);
+            case ULONG64: return total_over_dim_template<DULong64GDL>(static_cast<DULong64GDL*>(p0), srcDim, sumDim-1, false);
+            case FLOAT: return total_over_dim_template<DFloatGDL>(static_cast<DFloatGDL*>(p0), srcDim, sumDim-1, nan);
+            case DOUBLE: return total_over_dim_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0), srcDim, sumDim-1, nan);
+            case COMPLEX: return total_over_dim_template<DComplexGDL>(static_cast<DComplexGDL*>(p0), srcDim, sumDim-1, nan);
+            case COMPLEXDBL: return total_over_dim_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0), srcDim, sumDim-1, nan);
+            default: assert(false);
+          }
+        }
 
 	// INTEGER keyword takes precedence 
 	if( intRes )
@@ -2377,6 +2453,24 @@
       }
     else // cumulative
       {
+        if (preserve) 
+        {
+          switch (p0->Type())
+          {
+            case BYTE: return total_over_dim_cu_template<DByteGDL>(static_cast<DByteGDL*>(p0)->Dup(), sumDim-1, false);
+            case INT: return total_over_dim_cu_template<DIntGDL>(static_cast<DIntGDL*>(p0)->Dup(), sumDim-1, false);
+            case UINT: return total_over_dim_cu_template<DUIntGDL>(static_cast<DUIntGDL*>(p0)->Dup(), sumDim-1, false);
+            case LONG: return total_over_dim_cu_template<DLongGDL>(static_cast<DLongGDL*>(p0)->Dup(), sumDim-1, false);
+            case ULONG: return total_over_dim_cu_template<DULongGDL>(static_cast<DULongGDL*>(p0)->Dup(), sumDim-1, false);
+            case LONG64: return total_over_dim_cu_template<DLong64GDL>(static_cast<DLong64GDL*>(p0)->Dup(), sumDim-1, false);
+            case ULONG64: return total_over_dim_cu_template<DULong64GDL>(static_cast<DULong64GDL*>(p0)->Dup(), sumDim-1, false);
+            case FLOAT: return total_over_dim_cu_template<DFloatGDL>(static_cast<DFloatGDL*>(p0)->Dup(), sumDim-1, nan);
+            case DOUBLE: return total_over_dim_cu_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0)->Dup(), sumDim-1, nan);
+            case COMPLEX: return total_over_dim_cu_template<DComplexGDL>(static_cast<DComplexGDL*>(p0)->Dup(), sumDim-1, nan);
+            case COMPLEXDBL: return total_over_dim_cu_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0)->Dup(), sumDim-1, nan);
+            default: assert(false);
+          }
+        }
 
 	// INTEGER keyword takes precedence
 	if( intRes )
@@ -2502,6 +2596,28 @@
   }
 
   template<>
+  BaseGDL* product_template( DComplexGDL* src, bool omitNaN)
+  {
+    DComplexGDL::Ty sum = 1;
+    SizeT nEl = src->N_Elements();
+    if( !omitNaN) 
+	{
+	for ( SizeT i=0; i<nEl; ++i)
+		{
+		sum *= (*src)[ i];
+		}
+	}
+    else
+	{
+	for ( SizeT i=0; i<nEl; ++i)
+		{
+		MultOmitNaN( sum, (*src)[ i]);
+		}
+	}
+    return new DComplexGDL( sum);
+  }
+  
+  template<>
   BaseGDL* product_template( DComplexDblGDL* src, bool omitNaN)
   {
     DComplexDblGDL::Ty sum = 1;
@@ -2606,138 +2722,324 @@
   BaseGDL* product( EnvT* e)
   {
     SizeT nParam = e->NParam( 1);
-
+    
     BaseGDL* p0 = e->GetParDefined( 0);
-
+    
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
       e->Throw( "Variable is undefined: "+e->GetParString(0));
-
+    
     if( p0->Type() == STRING)
       e->Throw( "String expression not allowed "
 		"in this context: "+e->GetParString(0));
     
     static int cumIx = e->KeywordIx( "CUMULATIVE");
     static int nanIx = e->KeywordIx( "NAN");
-    bool cumulative = e->KeywordSet( cumIx);
-    bool nan        = e->KeywordSet( nanIx);
-
+    static int intIx = e->KeywordIx("INTEGER");
+    static int preIx = e->KeywordIx("PRESERVE_TYPE");
+    bool KwCumul     = e->KeywordSet( cumIx);
+    bool KwNaN       = e->KeywordSet( nanIx);
+    bool KwInt       = e->KeywordSet( intIx);
+    bool KwPre       = e->KeywordSet( preIx);
+    bool nanInt=false;
+    
     DLong sumDim = 0;
     if( nParam == 2)
       e->AssureLongScalarPar( 1, sumDim);
+    
+    if( sumDim == 0) {
+	if( !KwCumul) {
+          if (KwPre) 
+          {
+            switch (p0->Type())
+            {
+              case BYTE: return product_template<DByteGDL>(static_cast<DByteGDL*>(p0), nanInt);
+              case INT: return product_template<DIntGDL>(static_cast<DIntGDL*>(p0), nanInt);
+              case UINT: return product_template<DUIntGDL>(static_cast<DUIntGDL*>(p0), nanInt);
+              case LONG: return product_template<DLongGDL>(static_cast<DLongGDL*>(p0), nanInt);
+              case ULONG: return product_template<DULongGDL>(static_cast<DULongGDL*>(p0), nanInt);
+              case LONG64: return product_template<DLong64GDL>(static_cast<DLong64GDL*>(p0), nanInt);
+              case ULONG64: return product_template<DULong64GDL>(static_cast<DULong64GDL*>(p0), nanInt);
+              case FLOAT: return product_template<DFloatGDL>(static_cast<DFloatGDL*>(p0), KwNaN);
+              case DOUBLE: return product_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0), KwNaN);
+              case COMPLEX: return product_template<DComplexGDL>(static_cast<DComplexGDL*>(p0), KwNaN);
+              case COMPLEXDBL: return product_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0), KwNaN);
+              default: assert(false);
+            }
+          }
 
-    if( sumDim == 0)
-      {
-	if( !cumulative)
-	  {
-	    if( p0->Type() == DOUBLE)
-	      {
-		return product_template<DDoubleGDL>
-                  ( static_cast<DDoubleGDL*>(p0), nan); 
-	      }
-	    if( p0->Type() == COMPLEXDBL)
-	      {
-		return product_template<DComplexDblGDL>
-                  ( static_cast<DComplexDblGDL*>(p0), nan); 
-	      }
-	    if( p0->Type() == COMPLEX)
-	      {
-		DComplexDblGDL* p0D = static_cast<DComplexDblGDL*>
-		  (p0->Convert2( COMPLEXDBL,BaseGDL::COPY));
-		auto_ptr<DComplexDblGDL> p0D_guard( p0D);
-		//p0D_guard.reset( p0D);
-		return product_template<DComplexDblGDL>( p0D, nan); 
-	      }
+	  // Integer parts derivated from Total code by Erin Sheldon
+	  // In IDL PRODUCT(), the INTEGER keyword takes precedence 
+	  if (KwInt) {
+	    // We use LONG64 unless the input is ULONG64
+	    if ((p0->Type() == LONG64) && (!KwNaN)) {
+	      return product_template<DLong64GDL>
+		( static_cast<DLong64GDL*>(p0), nanInt );
+	    }
+	    if ((p0->Type() == ULONG64) && (!KwNaN)) {
+	      return product_template<DULong64GDL>
+		(static_cast<DULong64GDL*>(p0), nanInt );
+	    }
 	    
-	    DDoubleGDL* p0D = static_cast<DDoubleGDL*>
-	      (p0->Convert2( DOUBLE, BaseGDL::COPY));
-	    auto_ptr<DDoubleGDL> p0D_guard( p0D);
-	    //	    p0D_guard.reset( p0D);
-	    return product_template<DDoubleGDL>( p0D, nan);
-	  }
-	else // cumulative
-	  {
-	    // special case as DOUBLE type overrides /DOUBLE
-	    if( p0->Type() == DOUBLE)
-	      {
-  	        return product_cu_template< DDoubleGDL>
-		  ( static_cast<DDoubleGDL*>(p0)->Dup(), nan);
-	      }
-	    if( p0->Type() == COMPLEXDBL)
-	      {
-  	        return product_cu_template< DComplexDblGDL>
-		  ( static_cast<DComplexDblGDL*>(p0)->Dup(), nan);
-	      }
-	    if( p0->Type() == COMPLEX)
-	      {
-		return product_cu_template< DComplexDblGDL>
-		  ( static_cast<DComplexDblGDL*>(p0->Convert2( COMPLEXDBL, 
-							       BaseGDL::COPY)), nan);
+	    // Convert to Long64
+	    DLong64GDL* p0L64 = static_cast<DLong64GDL*>
+	      (p0->Convert2( LONG64, BaseGDL::COPY));
+	    auto_ptr<DLong64GDL> guard( p0L64);
+	    if (KwNaN) {
+	      DFloatGDL* p0f = static_cast<DFloatGDL*>
+		(p0->Convert2( FLOAT, BaseGDL::COPY));
+	      auto_ptr<DFloatGDL> guard( p0f);
+	      for( SizeT i=0; i<nEl; ++i) {
+		if (!isfinite((*p0f)[i])) (*p0L64)[i]=1;
 	      }
-    	    return product_cu_template< DDoubleGDL>
-	      ( static_cast<DDoubleGDL*>(p0->Convert2( DOUBLE, 
-						       BaseGDL::COPY)), nan);
+	    }
+	    return product_template<DLong64GDL>( p0L64, nanInt);	      
+	  } // integer results
+	  
+	  if( p0->Type() == DOUBLE) {
+	    return product_template<DDoubleGDL>
+	      ( static_cast<DDoubleGDL*>(p0), KwNaN); 
+	  }
+	  if( p0->Type() == COMPLEXDBL) {
+	    return product_template<DComplexDblGDL>
+	      ( static_cast<DComplexDblGDL*>(p0), KwNaN); 
 	  }
-      }
+	  if( p0->Type() == COMPLEX) {
+	    DComplexDblGDL* p0D = static_cast<DComplexDblGDL*>
+	      (p0->Convert2( COMPLEXDBL,BaseGDL::COPY));
+	    auto_ptr<DComplexDblGDL> p0D_guard( p0D);
+	    //p0D_guard.reset( p0D);
+	    return product_template<DComplexDblGDL>( p0D, KwNaN); 
+	  }
+	  
+	  DDoubleGDL* p0D = static_cast<DDoubleGDL*>
+	    (p0->Convert2( DOUBLE, BaseGDL::COPY));
+	  auto_ptr<DDoubleGDL> p0D_guard( p0D);
+	  //	    p0D_guard.reset( p0D);
+	  return product_template<DDoubleGDL>( p0D, KwNaN);
+	} 
+	else
+	  { // KwCumul
 
+            if (KwPre) 
+            {
+              switch (p0->Type())
+              {
+                case BYTE: return product_cu_template<DByteGDL>(static_cast<DByteGDL*>(p0)->Dup(), nanInt);
+                case INT: return product_cu_template<DIntGDL>(static_cast<DIntGDL*>(p0)->Dup(), nanInt);
+                case UINT: return product_cu_template<DUIntGDL>(static_cast<DUIntGDL*>(p0)->Dup(), nanInt);
+                case LONG: return product_cu_template<DLongGDL>(static_cast<DLongGDL*>(p0)->Dup(), nanInt);
+                case ULONG: return product_cu_template<DULongGDL>(static_cast<DULongGDL*>(p0)->Dup(), nanInt);
+                case LONG64: return product_cu_template<DLong64GDL>(static_cast<DLong64GDL*>(p0)->Dup(), nanInt);
+                case ULONG64: return product_cu_template<DULong64GDL>(static_cast<DULong64GDL*>(p0)->Dup(), nanInt);
+                case FLOAT: return product_cu_template<DFloatGDL>(static_cast<DFloatGDL*>(p0)->Dup(), KwNaN);
+                case DOUBLE: return product_cu_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0)->Dup(), KwNaN);
+                case COMPLEX: return product_cu_template<DComplexGDL>(static_cast<DComplexGDL*>(p0)->Dup(), KwNaN);
+                case COMPLEXDBL: return product_cu_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0)->Dup(), KwNaN);
+                default: assert(false);
+              }
+            }
+
+	    // Integer parts derivated from Total code by Erin Sheldon
+	    // In IDL PRODUCT(), the INTEGER keyword takes precedence 
+	    if (KwInt) {
+	      // We use LONG64 unless the input is ULONG64
+	      if ((p0->Type() == LONG64) && (!KwNaN)) {
+		return product_cu_template<DLong64GDL>
+		  ( static_cast<DLong64GDL*>(p0)->Dup(), nanInt);
+	      }
+	      if ((p0->Type() == ULONG64) && (!KwNaN)) {
+		return product_cu_template<DULong64GDL>
+		  ( static_cast<DULong64GDL*>(p0)->Dup(), nanInt);
+	      }
+	      // Convert to Long64
+	      DLong64GDL* p0L64 = static_cast<DLong64GDL*>
+		(p0->Convert2( LONG64, BaseGDL::COPY));
+	      auto_ptr<DLong64GDL> guard( p0L64);
+	      if (KwNaN) {
+		DFloatGDL* p0f = static_cast<DFloatGDL*>
+		  (p0->Convert2( FLOAT, BaseGDL::COPY));
+		auto_ptr<DFloatGDL> guard( p0f);
+		for( SizeT i=0; i<nEl; ++i) {
+		  if (!isfinite((*p0f)[i])) (*p0L64)[i]=1;
+		}
+	      }
+	      return product_cu_template<DLong64GDL>
+		((p0L64)->Dup(), nanInt);	      
+	    } // integer results
+	      
+	      // special case as DOUBLE type overrides /DOUBLE
+	    if (p0->Type() == DOUBLE) {
+	      return product_cu_template< DDoubleGDL>
+		( static_cast<DDoubleGDL*>(p0)->Dup(), KwNaN);
+	    }
+	    if (p0->Type() == COMPLEXDBL) {
+	      return product_cu_template< DComplexDblGDL>
+		( static_cast<DComplexDblGDL*>(p0)->Dup(), KwNaN);
+	    }
+	    if (p0->Type() == COMPLEX) {
+	      return product_cu_template< DComplexDblGDL>
+		( static_cast<DComplexDblGDL*>
+		  (p0->Convert2( COMPLEXDBL, BaseGDL::COPY)), KwNaN);
+	    }
+	    return product_cu_template< DDoubleGDL>
+	      ( static_cast<DDoubleGDL*>
+		(p0->Convert2( DOUBLE, BaseGDL::COPY)), KwNaN);
+	  }
+    }
+    
     // product over sumDim
     dimension srcDim = p0->Dim();
     SizeT srcRank = srcDim.Rank();
-
+    
     if( sumDim < 1 || sumDim > srcRank)
       e->Throw( "Array must have "+i2s(sumDim)+
 		" dimensions: "+e->GetParString(0));
+    
+    if (!KwCumul) {
 
-    if( !cumulative)
+      if (KwPre) 
       {
-	if( p0->Type() == DOUBLE)
-	  {
-	    return product_over_dim_template< DDoubleGDL>
-	      ( static_cast<DDoubleGDL*>(p0), srcDim, sumDim-1, nan);
-	  }
-	if( p0->Type() == COMPLEXDBL)
-	  {
-	    return product_over_dim_template< DComplexDblGDL>
-	      ( static_cast<DComplexDblGDL*>(p0), srcDim, sumDim-1, nan);
-	  }
-	if( p0->Type() == COMPLEX)
-	  {
-	    DComplexDblGDL* p0D = static_cast<DComplexDblGDL*>
-	      (p0->Convert2( COMPLEXDBL,BaseGDL::COPY));
-	    auto_ptr<DComplexDblGDL> p0D_guard( p0D);
-	    //	    p0D_guard.reset( p0D);
-	    return product_over_dim_template< DComplexDblGDL>
-	      ( p0D, srcDim, sumDim-1, nan);
-	  }
-
-	DDoubleGDL* p0D = static_cast<DDoubleGDL*>
-	  (p0->Convert2( DOUBLE,BaseGDL::COPY));
-	auto_ptr<DDoubleGDL> p0D_guard( p0D);
-	//p0D_guard.reset( p0D);
-	return product_over_dim_template< DDoubleGDL>( p0D, srcDim, sumDim-1,nan);
+        switch (p0->Type())
+        {
+          case BYTE: return product_over_dim_template<DByteGDL>(static_cast<DByteGDL*>(p0), srcDim, sumDim-1, nanInt);
+          case INT: return product_over_dim_template<DIntGDL>(static_cast<DIntGDL*>(p0), srcDim, sumDim-1, nanInt);
+          case UINT: return product_over_dim_template<DUIntGDL>(static_cast<DUIntGDL*>(p0), srcDim, sumDim-1, nanInt);
+          case LONG: return product_over_dim_template<DLongGDL>(static_cast<DLongGDL*>(p0), srcDim, sumDim-1, nanInt);
+          case ULONG: return product_over_dim_template<DULongGDL>(static_cast<DULongGDL*>(p0), srcDim, sumDim-1, nanInt);
+          case LONG64: return product_over_dim_template<DLong64GDL>(static_cast<DLong64GDL*>(p0), srcDim, sumDim-1, nanInt);
+          case ULONG64: return product_over_dim_template<DULong64GDL>(static_cast<DULong64GDL*>(p0), srcDim, sumDim-1, nanInt);
+          case FLOAT: return product_over_dim_template<DFloatGDL>(static_cast<DFloatGDL*>(p0), srcDim, sumDim-1, KwNaN);
+          case DOUBLE: return product_over_dim_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0), srcDim, sumDim-1, KwNaN);
+          case COMPLEX: return product_over_dim_template<DComplexGDL>(static_cast<DComplexGDL*>(p0), srcDim, sumDim-1, KwNaN);
+          case COMPLEXDBL: return product_over_dim_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0), srcDim, sumDim-1, KwNaN);
+          default: assert(false);
+        }
       }
-    else // cumulative
-      {
-	if( p0->Type() == DOUBLE)
-	  {
-	    return product_over_dim_cu_template< DDoubleGDL>
-	      ( static_cast<DDoubleGDL*>(p0)->Dup(), sumDim-1, nan);
-	  }
-	if( p0->Type() == COMPLEXDBL)
-	  {
-	    return product_over_dim_cu_template< DComplexDblGDL>
-	      ( static_cast<DComplexDblGDL*>(p0)->Dup(), sumDim-1, nan);
-	  }
-	if( p0->Type() == COMPLEX)
-	  {
-	    return product_over_dim_cu_template< DComplexDblGDL>
-	      ( static_cast<DComplexDblGDL*>(p0->Convert2( COMPLEXDBL,
-							   BaseGDL::COPY)), sumDim-1, nan);
+
+      // Integer parts derivated from Total code by Erin Sheldon
+      // In IDL PRODUCT(), the INTEGER keyword takes precedence 
+      if (KwInt) {	  
+	// We use LONG64 unless the input is ULONG64
+	if ((p0->Type() == LONG64 ) && (!KwNaN)) {
+	  return product_over_dim_template<DLong64GDL>
+	    ( static_cast<DLong64GDL*>(p0), srcDim, sumDim-1, nanInt);
+	}
+	if ((p0->Type() == ULONG64) && (!KwNaN)) {
+	  return product_over_dim_template<DULong64GDL>
+	    ( static_cast<DULong64GDL*>(p0), srcDim, sumDim-1, nanInt);
+	}
+	
+	// Conver to Long64
+	DLong64GDL* p0L64 = static_cast<DLong64GDL*>
+	  (p0->Convert2( LONG64, BaseGDL::COPY));
+	auto_ptr<DLong64GDL> guard( p0L64);
+	if (KwNaN) {
+	  DFloatGDL* p0f = static_cast<DFloatGDL*>
+	    (p0->Convert2( FLOAT, BaseGDL::COPY));
+	  auto_ptr<DFloatGDL> guard( p0f);
+	  for( SizeT i=0; i<nEl; ++i) {
+	    if (!isfinite((*p0f)[i])) (*p0L64)[i]=1;
 	  }
+	}
+	return product_over_dim_template<DLong64GDL>
+	  ( p0L64, srcDim, sumDim-1, nanInt);
+      } // integer results
+      
+      if( p0->Type() == DOUBLE) {
+	return product_over_dim_template< DDoubleGDL>
+	  ( static_cast<DDoubleGDL*>(p0), srcDim, sumDim-1, KwNaN);
+      }
+      if( p0->Type() == COMPLEXDBL) {
+	return product_over_dim_template< DComplexDblGDL>
+	  ( static_cast<DComplexDblGDL*>(p0), srcDim, sumDim-1, KwNaN);
+      }
+      if( p0->Type() == COMPLEX) {
+	DComplexDblGDL* p0D = static_cast<DComplexDblGDL*>
+	  (p0->Convert2( COMPLEXDBL,BaseGDL::COPY));
+	auto_ptr<DComplexDblGDL> p0D_guard( p0D);
+	//	    p0D_guard.reset( p0D);
+	return product_over_dim_template< DComplexDblGDL>
+	  ( p0D, srcDim, sumDim-1, KwNaN);
+      }
+	
+      DDoubleGDL* p0D = static_cast<DDoubleGDL*>
+	(p0->Convert2( DOUBLE,BaseGDL::COPY));
+      auto_ptr<DDoubleGDL> p0D_guard( p0D);
+      //p0D_guard.reset( p0D);
+      return product_over_dim_template< DDoubleGDL>
+	( p0D, srcDim, sumDim-1,KwNaN);
+    } 
+    else
+      { // KwCumul
 
+        if (KwPre) 
+        {
+          switch (p0->Type())
+          {
+            case BYTE: return product_over_dim_cu_template<DByteGDL>(static_cast<DByteGDL*>(p0)->Dup(), sumDim-1, nanInt);
+            case INT: return product_over_dim_cu_template<DIntGDL>(static_cast<DIntGDL*>(p0)->Dup(), sumDim-1, nanInt);
+            case UINT: return product_over_dim_cu_template<DUIntGDL>(static_cast<DUIntGDL*>(p0)->Dup(), sumDim-1, nanInt);
+            case LONG: return product_over_dim_cu_template<DLongGDL>(static_cast<DLongGDL*>(p0)->Dup(), sumDim-1, nanInt);
+            case ULONG: return product_over_dim_cu_template<DULongGDL>(static_cast<DULongGDL*>(p0)->Dup(), sumDim-1, nanInt);
+            case LONG64: return product_over_dim_cu_template<DLong64GDL>(static_cast<DLong64GDL*>(p0)->Dup(), sumDim-1, nanInt);
+            case ULONG64: return product_over_dim_cu_template<DULong64GDL>(static_cast<DULong64GDL*>(p0)->Dup(), sumDim-1, nanInt);
+            case FLOAT: return product_over_dim_cu_template<DFloatGDL>(static_cast<DFloatGDL*>(p0)->Dup(), sumDim-1, KwNaN);
+            case DOUBLE: return product_over_dim_cu_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0)->Dup(), sumDim-1, KwNaN);
+            case COMPLEX: return product_over_dim_cu_template<DComplexGDL>(static_cast<DComplexGDL*>(p0)->Dup(), sumDim-1, KwNaN);
+            case COMPLEXDBL: return product_over_dim_cu_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0)->Dup(), sumDim-1, KwNaN);
+            default: assert(false);
+          }
+        }
+
+	// Integer parts derivated from Total code by Erin Sheldon
+	// In IDL PRODUCT(), the INTEGER keyword takes precedence 
+	if (KwInt) {
+	  // We use LONG64 unless the input is ULONG64
+	  if ((p0->Type() == LONG64) && (!KwNaN)) {
+	  return product_over_dim_cu_template<DLong64GDL>
+	    ( static_cast<DLong64GDL*>(p0)->Dup(), sumDim-1, nanInt);
+	}
+	if ((p0->Type() == ULONG64 ) && (!KwNaN)) {
+	  return product_over_dim_cu_template<DULong64GDL>
+	    ( static_cast<DULong64GDL*>(p0)->Dup(), sumDim-1, nanInt);
+	}
+	  
+	// Convert to Long64
+	if (KwNaN) {
+	  DFloatGDL* p0f = static_cast<DFloatGDL*>
+	    (p0->Convert2( FLOAT, BaseGDL::COPY));
+	  auto_ptr<DFloatGDL> guard( p0f);
+	  for( SizeT i=0; i<nEl; ++i) {
+	    if (!isfinite((*p0f)[i])) (*p0f)[i]=1;
+	  }
+	  return product_over_dim_cu_template<DLong64GDL>
+	    ( static_cast<DLong64GDL*>
+	      (p0f->Convert2( LONG64, BaseGDL::COPY)), sumDim-1, nanInt);  
+	} else {
+	  return product_over_dim_cu_template<DLong64GDL>
+	    ( static_cast<DLong64GDL*>
+	      (p0->Convert2( LONG64, BaseGDL::COPY)), sumDim-1, nanInt);
+	}
+	} // integer results
+	
+	if( p0->Type() == DOUBLE) {
+	  return product_over_dim_cu_template< DDoubleGDL>
+	    ( static_cast<DDoubleGDL*>(p0)->Dup(), sumDim-1, KwNaN);
+	}
+	if( p0->Type() == COMPLEXDBL) {
+	  return product_over_dim_cu_template< DComplexDblGDL>
+	    ( static_cast<DComplexDblGDL*>(p0)->Dup(), sumDim-1, KwNaN);
+	}
+	if( p0->Type() == COMPLEX) {
+	  return product_over_dim_cu_template< DComplexDblGDL>
+	    ( static_cast<DComplexDblGDL*>
+	      (p0->Convert2( COMPLEXDBL, BaseGDL::COPY)), sumDim-1, KwNaN);
+	}
+      
 	return product_over_dim_cu_template< DDoubleGDL>
-	  ( static_cast<DDoubleGDL*>(p0->Convert2( DOUBLE,
-						   BaseGDL::COPY)), sumDim-1, nan);
+	  ( static_cast<DDoubleGDL*>
+	    (p0->Convert2( DOUBLE, BaseGDL::COPY)), sumDim-1, KwNaN);
       }
   }
 
@@ -3000,7 +3302,7 @@
     }
   }
  
-  BaseGDL* transpose( EnvT* e)
+BaseGDL* transpose( EnvT* e)
   {
     SizeT nParam=e->NParam( 1); 
 
@@ -3043,7 +3345,47 @@
     return p0->Transpose( NULL);
   }
 
- 
+
+// BaseGDL* matrix_multiply( EnvT* e)
+//   {
+//     SizeT nParam=e->NParam( 2); 
+// 
+//     BaseGDL* a = e->GetNumericArrayParDefined( 0);
+//     BaseGDL* b = e->GetNumericArrayParDefined( 1);
+//     
+//     static int aTIx = e->KeywordIx("ATRANSPOSE");
+//     bool aT = e->KeywordPresent(aTIx);
+//     static int bTIx = e->KeywordIx("BTRANSPOSE");
+//     bool bT = e->KeywordPresent(bTIx);
+//     
+//     static int strassenIx = e->KeywordIx("STRASSEN_ALGORITHM");
+//     bool strassen = e->KeywordPresent(strassenIx);
+// 
+//     
+//     if( p1->N_Elements() != rank)
+// 	  e->Throw("Incorrect number of elements in permutation.");
+// 
+// 	DUInt* perm = new DUInt[rank];
+// 	auto_ptr<DUInt> perm_guard( perm);
+// 
+// 	DUIntGDL* p1L = static_cast<DUIntGDL*>
+// 	  (p1->Convert2( UINT, BaseGDL::COPY));
+// 	for( SizeT i=0; i<rank; ++i) perm[i] = (*p1L)[ i];
+// 	delete p1L;
+// 
+// 	// check permutaion vector
+// 	for( SizeT i=0; i<rank; ++i) 
+// 	  {
+// 	    DUInt j;
+// 	    for( j=0; j<rank; ++j) if( perm[j] == i) break;
+// 	    if (j == rank)
+// 	      e->Throw( "Incorrect permutation vector.");
+// 	  }
+// 	return p0->Transpose( perm);
+//       }
+// 
+//     return a->Transpose( NULL);
+//   }
 
   // helper function for sort_fun, recursive
   // optimized version
@@ -3134,6 +3476,79 @@
     // helper arrays
     DLongGDL* res = new DLongGDL( dimension( nEl), BaseGDL::INDGEN);
 
+	DLong nanIx = nEl;
+    if( p0->Type() == FLOAT)
+    {
+		DFloatGDL* p0F = static_cast<DFloatGDL*>(p0);
+		for( DLong i=nEl-1; i >= 0; --i)
+		{
+			if( isnan((*p0F)[ i]) )//|| !isfinite((*p0F)[ i]))
+				{
+					--nanIx;
+					(*res)[i] = (*res)[nanIx];
+					(*res)[ nanIx] = i;
+
+// cout << "swap " << i << " with " << nanIx << endl;
+// cout << "now:     ";
+// 		for( DLong ii=0; ii < nEl; ++ii)
+// 		{
+// 		cout << (*res)[ii] << " ";		
+// 		}
+// cout  << endl;
+				}
+		}
+    }
+    else if( p0->Type() == DOUBLE)
+    {
+		DDoubleGDL* p0F = static_cast<DDoubleGDL*>(p0);
+		for( DLong i=nEl-1; i >= 0; --i)
+		{
+			if( isnan((*p0F)[ i]))// || !isfinite((*p0F)[ i]))
+				{
+					--nanIx;
+					(*res)[i] = (*res)[nanIx];
+					(*res)[ nanIx] = i;
+				}
+		}
+    }
+    else if( p0->Type() == COMPLEX)
+    {
+		DComplexGDL* p0F = static_cast<DComplexGDL*>(p0);
+		for( DLong i=nEl-1; i >= 0; --i)
+		{
+			if( isnan((*p0F)[ i].real()) || //!isfinite((*p0F)[ i].real()) ||
+			     isnan((*p0F)[ i].imag()))// || !isfinite((*p0F)[ i].imag()) )
+				{
+					--nanIx;
+					(*res)[i] = (*res)[nanIx];
+					(*res)[ nanIx] = i;
+				}
+		}
+    }
+    else if( p0->Type() == COMPLEXDBL)
+    {
+		DComplexDblGDL* p0F = static_cast<DComplexDblGDL*>(p0);
+		for( DLong i=nEl-1; i >= 0; --i)
+		{
+			if( isnan((*p0F)[ i].real()) || //!isfinite((*p0F)[ i].real()) ||
+			     isnan((*p0F)[ i].imag()))// || !isfinite((*p0F)[ i].imag()) )
+				{
+					--nanIx;
+					(*res)[i] = (*res)[nanIx];
+					(*res)[ nanIx] = i;
+				}
+		}
+    }
+
+// cout << "nEl " << nEl << " nanIx " << nanIx << endl;
+	nEl = nanIx;
+// cout << "sorting:  ";
+// 		for( DLong ii=0; ii < nEl; ++ii)
+// 		{
+// 		cout << (*res)[ii] << " ";		
+// 		}
+// cout  << endl;
+
     DLong *hh = static_cast<DLong*>(res->DataAddr());
 
     DLong* h1 = new DLong[ nEl/2];
@@ -3163,6 +3578,12 @@
       {
 	BaseGDL* p0 = e->GetParDefined( 0);
 
+	if( p0->Type() == PTR)
+	  e->Throw( "Pointer expression not allowed in this context: "+
+		    e->GetParString(0));
+	if( p0->Type() == OBJECT)
+	  e->Throw( "Object expression not allowed in this context: "+
+		    e->GetParString(0));
 	if( p0->Type() == STRUCT)
 	  e->Throw( "Struct expression not allowed in this context: "+
 		    e->GetParString(0));
@@ -3178,8 +3599,8 @@
           p0->Type() == DOUBLE || 
           p0->Type() == COMPLEXDBL || 
           e->KeywordSet(e->KeywordIx("DOUBLE"));
-        DType type = dbl ? DOUBLE : FLOAT;
-        bool noconv = (dbl && p0->Type() == DOUBLE) || (!dbl && p0->Type() == FLOAT); 
+    DType type = dbl ? DOUBLE : FLOAT;
+    bool noconv = (dbl && p0->Type() == DOUBLE) || (!dbl && p0->Type() == FLOAT);
 
 	// DIMENSION keyword
 	DLong dim = 0;
@@ -3214,7 +3635,7 @@
 	DLong *hh = new DLong[ nEl];
 	DLong* h1 = new DLong[ nEl/2];
 	DLong* h2 = new DLong[ (nEl+1)/2];
-	
+
 	DLong accumStride = 1;
 	if (nmed > 1)
 	  for( DLong i=0; i<dim-1; ++i) accumStride *= p0->Dim(i);
@@ -3228,13 +3649,81 @@
 	  
 	  if (nmed == 1) { 
 	    for( DLong i=0; i<nEl; ++i) hh[i] = i;
+
+		DLong nanIx = nEl;
+		if( p0->Type() == FLOAT)
+		{
+			DFloatGDL* p0F = static_cast<DFloatGDL*>(p0);
+			for( DLong i=nEl-1; i >= 0; --i)
+			{
+				if( isnan((*p0F)[ i]) )//|| !isfinite((*p0F)[ i]))
+					{
+						--nanIx;
+						hh[i] = hh[nanIx];
+						hh[ nanIx] = i;
+
+	// cout << "swap " << i << " with " << nanIx << endl;
+	// cout << "now:     ";
+	// 		for( DLong ii=0; ii < nEl; ++ii)
+	// 		{
+	// 		cout << hh[ii] << " ";
+	// 		}
+	// cout  << endl;
+					}
+			}
+		}
+		else if( p0->Type() == DOUBLE)
+		{
+			DDoubleGDL* p0F = static_cast<DDoubleGDL*>(p0);
+			for( DLong i=nEl-1; i >= 0; --i)
+			{
+				if( isnan((*p0F)[ i]))// || !isfinite((*p0F)[ i]))
+					{
+						--nanIx;
+						hh[i] = hh[nanIx];
+						hh[ nanIx] = i;
+					}
+			}
+		}
+		else if( p0->Type() == COMPLEX)
+		{
+			DComplexGDL* p0F = static_cast<DComplexGDL*>(p0);
+			for( DLong i=nEl-1; i >= 0; --i)
+			{
+				if( isnan((*p0F)[ i].real()) || //!isfinite((*p0F)[ i].real()) ||
+					isnan((*p0F)[ i].imag()))// || !isfinite((*p0F)[ i].imag()) )
+					{
+						--nanIx;
+						hh[i] = hh[nanIx];
+						hh[ nanIx] = i;
+					}
+			}
+		}
+		else if( p0->Type() == COMPLEXDBL)
+		{
+			DComplexDblGDL* p0F = static_cast<DComplexDblGDL*>(p0);
+			for( DLong i=nEl-1; i >= 0; --i)
+			{
+				if( isnan((*p0F)[ i].real()) || //!isfinite((*p0F)[ i].real()) ||
+					isnan((*p0F)[ i].imag()))// || !isfinite((*p0F)[ i].imag()) )
+					{
+						--nanIx;
+						hh[i] = hh[nanIx];
+						hh[ nanIx] = i;
+					}
+			}
+		}
+
+		// cout << "nEl " << nEl << " nanIx " << nanIx << endl;
+		nEl = nanIx;
+
 	  } else {
 	    // Starting Element
 	    DLong start = accumStride * p0->Dim(dim-1) * (k / accumStride) + 
 	      (k % accumStride);
 	    for( DLong i=0; i<nEl; ++i) hh[i] = start + i * accumStride;
 	  }
-	  
+
 	  // call the sort routine
 	  MergeSortOpt<DLong>( p0, hh, h1, h2, nEl);
 	  DLong medEl = hh[ nEl/2];
@@ -3242,7 +3731,7 @@
 	  
 	  if( (nEl % 2) == 1 || !e->KeywordSet( evenIx)) {
 	    if (nmed == 1)
-	      res = p0->NewIx(medEl)->Convert2(type, BaseGDL::CONVERT); // TODO: leak with res?
+	      res = p0->NewIx(medEl)->Convert2(type, BaseGDL::CONVERT); 
 	    else {
               if (noconv) 
               {
@@ -3294,7 +3783,7 @@
 	return res;
       }
     else 
-      // with parameter Width : median filtering with no optmisation,
+      // with parameter Width : median filtering with no optimisation,
       //  such as histogram algorithms.
       // Copyright: (C) 2008 by Nicolas Galmiche
       {
@@ -3320,7 +3809,7 @@
 	  MaxAllowedWidth=p0->Dim(0);
 	  if (p0->Dim(1) < MaxAllowedWidth) MaxAllowedWidth=p0->Dim(1);	   
 	}
-	int debug =0;
+	const int debug =0;
 	if (debug == 1) {
 	  cout << "X dim " << p0->Dim(0) <<endl;
 	  cout << "y dim " << p0->Dim(1) <<endl;	  
@@ -3345,9 +3834,9 @@
 
 	
 	static int evenIx = e->KeywordIx( "EVEN");
-    	static int doubleIx = e->KeywordIx( "DOUBLE");
+    static int doubleIx = e->KeywordIx( "DOUBLE");
 	static DStructGDL *Values =  SysVar::Values();                                                
-    	DDouble d_nan=(*static_cast<DDoubleGDL*>(Values->GetTag(Values->Desc()->TagIndex("D_NAN"), 0)))[0]; 
+    DDouble d_nan=(*static_cast<DDoubleGDL*>(Values->GetTag(Values->Desc()->TagIndex("D_NAN"), 0)))[0];
 	DDouble d_infinity= (*static_cast<DDoubleGDL*>(Values->GetTag(Values->Desc()->TagIndex("D_INFINITY"), 0)))[0]; 
  
 	//------------------------------ Init variables and allocation ---------------------------------------
@@ -3575,23 +4064,23 @@
 			    if(ctl_NaN==width)(*tamp)[col]= d_nan;
 			    else 
 			      {
-				DLong*	hhbis = new DLong[ width-ctl_NaN];
-				DLong*	h1bis = new DLong[ width-ctl_NaN/2];
-				DLong*	h2bis= new DLong[(width-ctl_NaN+1)/2];
-				DDoubleGDL *Mask1Dbis = new DDoubleGDL(width-ctl_NaN,BaseGDL::NOZERO);
-				for( DLong t=0; t<width-ctl_NaN; ++t) hhbis[t] = t;
-				for( DLong ii=0; ii<width-ctl_NaN; ++ii)(*Mask1Dbis)[ii]=(*Mask1D)[ii];
-				BaseGDL* besort=static_cast<BaseGDL*>(Mask1Dbis);	
-				MergeSortOpt<DLong>( besort, hhbis, h1bis, h2bis,(width - ctl_NaN));
-				if (e->KeywordSet( evenIx)&& (width - ctl_NaN) % 2 == 0)
-				  (*tamp)[col]=((*Mask1Dbis)[hhbis[ (width-ctl_NaN)/2]]+(*Mask1Dbis
-											 )[hhbis	[ (width - ctl_NaN-1)/2]])/2;	
-				else
-				  (*tamp)[col]=(*Mask1Dbis)[hhbis[ (width- ctl_NaN)/2]];
-				delete[]hhbis;
-				delete[]h2bis;
-				delete[]h1bis;
-			      }
+					DLong*	hhbis = new DLong[ width-ctl_NaN];
+					DLong*	h1bis = new DLong[ width-ctl_NaN/2];
+					DLong*	h2bis= new DLong[(width-ctl_NaN+1)/2];
+					DDoubleGDL *Mask1Dbis = new DDoubleGDL(width-ctl_NaN,BaseGDL::NOZERO);
+					for( DLong t=0; t<width-ctl_NaN; ++t) hhbis[t] = t;
+					for( DLong ii=0; ii<width-ctl_NaN; ++ii)(*Mask1Dbis)[ii]=(*Mask1D)[ii];
+					BaseGDL* besort=static_cast<BaseGDL*>(Mask1Dbis);	
+					MergeSortOpt<DLong>( besort, hhbis, h1bis, h2bis,(width - ctl_NaN));
+					if (e->KeywordSet( evenIx)&& (width - ctl_NaN) % 2 == 0)
+					(*tamp)[col]=((*Mask1Dbis)[hhbis[ (width-ctl_NaN)/2]]+(*Mask1Dbis
+												)[hhbis	[ (width - ctl_NaN-1)/2]])/2;
+					else
+					(*tamp)[col]=(*Mask1Dbis)[hhbis[ (width- ctl_NaN)/2]];
+					delete[]hhbis;
+					delete[]h2bis;
+					delete[]h1bis;
+					}
 			  }	
 			else
 			  {
@@ -3762,26 +4251,26 @@
 			 
 			    if (ctl_NaN!=0)
 			      {	
-				if(ctl_NaN==N_MaskElem)(*tamp)[j]= d_nan;
-				else {
-						
-				  DLong*	hhb = new DLong[ N_MaskElem-ctl_NaN];
-				  DLong*	h1b = new DLong[ (N_MaskElem-ctl_NaN)/2];
-				  DLong*	h2b= new DLong[(N_MaskElem-ctl_NaN+1)/2];
-				  DDoubleGDL*Maskb = new DDoubleGDL(N_MaskElem-ctl_NaN,BaseGDL::NOZERO);
-				  for( DLong t=0; t<N_MaskElem-ctl_NaN; ++t) hhb[t] = t;
-				  for( DLong ii=0; ii<N_MaskElem-ctl_NaN; ++ii)(*Maskb)[ii]=(*Mask)[ii];
-				  BaseGDL* besort=static_cast<BaseGDL*>(Maskb);	
-				  MergeSortOpt<DLong>( besort, hhb, h1b, h2b,(N_MaskElem - ctl_NaN)); 
-				  if ((N_MaskElem - ctl_NaN) % 2 == 0 && e->KeywordSet( evenIx))
-				    (*tamp)[j]=((*Maskb)[hhb[ (N_MaskElem-ctl_NaN)/2]]+(*Maskb)[hhb 
-												[ (N_MaskElem - 
-												   ctl_NaN-1)/2]])/2;
-				  else(*tamp)[j]=(*Maskb)[hhb[(N_MaskElem- ctl_NaN)/2]];
-				  delete[]hhb;
-				  delete[]h2b;
-				  delete[]h1b;
-				}
+					if(ctl_NaN==N_MaskElem)
+						(*tamp)[j]= d_nan;
+					else {
+						DLong*	hhb = new DLong[ N_MaskElem-ctl_NaN];
+						DLong*	h1b = new DLong[ (N_MaskElem-ctl_NaN)/2];
+						DLong*	h2b= new DLong[(N_MaskElem-ctl_NaN+1)/2];
+						DDoubleGDL*Maskb = new DDoubleGDL(N_MaskElem-ctl_NaN,BaseGDL::NOZERO);
+						for( DLong t=0; t<N_MaskElem-ctl_NaN; ++t) hhb[t] = t;
+						for( DLong ii=0; ii<N_MaskElem-ctl_NaN; ++ii)(*Maskb)[ii]=(*Mask)[ii];
+						BaseGDL* besort=static_cast<BaseGDL*>(Maskb);
+						MergeSortOpt<DLong>( besort, hhb, h1b, h2b,(N_MaskElem - ctl_NaN));
+						if ((N_MaskElem - ctl_NaN) % 2 == 0 && e->KeywordSet( evenIx))
+							(*tamp)[j]=((*Maskb)[hhb[ (N_MaskElem-ctl_NaN)/2]]+(*Maskb)[hhb
+														[ (N_MaskElem - 
+														ctl_NaN-1)/2]])/2;
+						else(*tamp)[j]=(*Maskb)[hhb[(N_MaskElem- ctl_NaN)/2]];
+						delete[]hhb;
+						delete[]h2b;
+						delete[]h1b;
+					}
 			      }	
 			    else
 			      {
@@ -3989,10 +4478,17 @@
 		e->GetParString(0));
     
     SizeT resDimInit[ MAXRANK];
-    for( SizeT p=1; p<nParam; ++p)
+
+    DLongGDL* p1 = e->GetParAs<DLongGDL>(1);
+    if (p1->Rank() > 0 && nParam > 2) 
+      e->Throw("The new dimensions must either be specified as an array or as a set of scalars.");
+    SizeT np = p1->Rank() == 0 ? nParam : p1->N_Elements() + 1;
+
+    for( SizeT p=1; p<np; ++p)
       {
 	DLong newDim;
-	e->AssureLongScalarPar( p, newDim);
+	if (p1->Rank() == 0) e->AssureLongScalarPar( p, newDim);
+        else newDim = (*p1)[p - 1];
 
 	if( newDim <= 0)
 	  e->Throw( "Array dimensions must be greater than 0.");
@@ -4018,7 +4514,7 @@
 	resDimInit[ p-1] = newDim; 
       }
 
-    dimension resDim( resDimInit, nParam-1);
+    dimension resDim( resDimInit, np-1);
 
     static int sampleIx = e->KeywordIx( "SAMPLE");
     bool sample = e->KeywordSet( sampleIx);
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/basic_fun_jmg.cpp cvs/gdl/src/basic_fun_jmg.cpp
--- gdl-0.9rc4/src/basic_fun_jmg.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/basic_fun_jmg.cpp	2010-07-07 14:41:00.681004314 -0600
@@ -189,7 +189,16 @@
       throw GDLException( e->CallingNode(), 
 			  "FSTAT:  File unit is not within allowed range.");
 
-    DStructGDL*  fstat = new DStructGDL( "FSTAT");
+    SizeT size;
+    bool big = false;
+    if (lun > 0)
+    {
+      size = fileUnits[ lun-1].Size();
+      big = (DLong(size) != size);
+    }
+    DStructGDL* fstat;
+    if (big) fstat = new DStructGDL( "FSTAT64");
+    else fstat = new DStructGDL( "FSTAT");
    
     fstat->InitTag("UNIT", DLongGDL( lun));
 
@@ -243,18 +252,23 @@
 	int status = stat(actUnit.Name().c_str(), &buffer);
 
 	fstat->InitTag("NAME", DStringGDL( actUnit.Name()));
-	fstat->InitTag("SIZE", DLongGDL( actUnit.Size())); 
+	if (big) fstat->InitTag("SIZE", DLong64GDL( buffer.st_size));//size)); 
+        else fstat->InitTag("SIZE", DLongGDL( buffer.st_size));//size));
 	fstat->InitTag("OPEN", DByteGDL( 1)); 
 	// fstat->InitTag("ISATTY", DByteGDL( 0)); 
 	// fstat->InitTag("ISAGUI", DByteGDL( 0)); 
 	// fstat->InitTag("INTERACTIVE", DByteGDL( 0)); 
 	// fstat->InitTag("COMPRESS", DByteGDL( 0)); 
+
+	fstat->InitTag("COMPRESS",DByteGDL( actUnit.Compress()));
+
 	fstat->InitTag("READ", DByteGDL( actUnit.IsReadable()?1:0)); 
 	fstat->InitTag("WRITE", DByteGDL( actUnit.IsWriteable()?1:0)); 
 	fstat->InitTag("ATIME", DLong64GDL( buffer.st_atime)); 
 	fstat->InitTag("CTIME", DLong64GDL( buffer.st_ctime)); 
 	fstat->InitTag("MTIME", DLong64GDL( buffer.st_mtime)); 
-        fstat->InitTag("CUR_PTR", DLongGDL( actUnit.Tell()));
+        if (big) fstat->InitTag("CUR_PTR", DLong64GDL( actUnit.Tell()));
+        else fstat->InitTag("CUR_PTR", DLongGDL( actUnit.Tell()));
       }
 
     return fstat;
@@ -640,7 +654,6 @@
       return res;
     }
 
-
     if (e->KeywordSet( "S_PROCEDURES")) {
       deque<DString> subList;
 
@@ -720,19 +733,20 @@
       } else if (fetch) { // FETCH
 
 	e->AssureScalarPar<DStringGDL>( 0, varName);
-	int xI = pro->FindVar(StrUpCase( varName));
+	varName = StrUpCase( varName);
+	int xI = pro->FindVar( varName);
 	//	cout << xI << endl;
 	if (xI != -1) {
 	  BaseGDL*& par = ((EnvT*)(callStack[desiredlevnum-1]))->GetPar( xI);
 
 	  if( par == NULL)
-// 		e->Throw( "Variable is undefined: " + varName);
- 		return NULL;
+ 		e->Throw( "Variable is undefined: " + varName);
+// 		return NULL;
 	  //	  char* addr = static_cast<char*>(par->DataAddr());
 	  return par->Dup();
 	}
 	
-// 	e->Throw( "Variable not found: " + varName);
+ 	e->Throw( "Variable not found: " + varName);
  	return NULL;
       } else if (arg) { // ARG_NAME
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/basic_op.cpp cvs/gdl/src/basic_op.cpp
--- gdl-0.9rc4/src/basic_op.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/basic_op.cpp	2010-04-22 09:50:40.000000000 -0600
@@ -43,7 +43,7 @@
   ULong nEl=N_Elements();
   assert( nEl != 0);
   //  if( !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -57,7 +57,7 @@
   ULong nEl=N_Elements();
   assert( nEl != 0);
   //  if( !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -70,7 +70,7 @@
   ULong nEl=N_Elements();
   assert( nEl != 0);
   //  if( !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -122,7 +122,7 @@
   ULong nEl=N_Elements();
   assert( nEl != 0);
   //  if( !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -167,7 +167,7 @@
   //  if( nEl == 0) throw GDLException("Variable is undefined.");  
   
   DByteGDL* res = new Data_<SpDByte>( this->dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -182,7 +182,7 @@
   //  if( nEl == 0) throw GDLException("Variable is undefined.");  
   
   DByteGDL* res = new Data_<SpDByte>( this->dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -197,7 +197,7 @@
   //  if( nEl == 0) throw GDLException("Variable is undefined.");  
   
   DByteGDL* res = new Data_<SpDByte>( dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -211,7 +211,7 @@
   assert( nEl);
   //  if( nEl == 0) throw GDLException("Variable is undefined.");  
   DByteGDL* res = new Data_<SpDByte>( dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -225,7 +225,7 @@
   assert( nEl);
   //  if( nEl == 0) throw GDLException("Variable is undefined.");  
   DByteGDL* res = new Data_<SpDByte>( dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -239,7 +239,7 @@
   assert( nEl);
   //  if( nEl == 0) throw GDLException("Variable is undefined.");  
   DByteGDL* res = new Data_<SpDByte>( dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -255,7 +255,7 @@
   ULong nEl=N_Elements();
   assert( nEl != 0);
   // if( !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -267,7 +267,7 @@
   ULong nEl=N_Elements();
   assert( nEl != 0);
   // if( !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -281,7 +281,7 @@
   ULong nEl=N_Elements();
   assert( nEl != 0);
   // if( !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -294,7 +294,7 @@
   ULong nEl=N_Elements();
   assert( nEl != 0);
   // if( !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -308,7 +308,7 @@
   ULong nEl=N_Elements();
   assert( nEl != 0);
   // if( !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -321,7 +321,7 @@
   ULong nEl=N_Elements();
   assert( nEl != 0);
   // if( !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -335,7 +335,7 @@
   ULong nEl=N_Elements();
   assert( nEl != 0);
   // if( !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -348,7 +348,7 @@
   ULong nEl=N_Elements();
   assert( nEl != 0);
   // if( !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -361,7 +361,7 @@
   ULong nEl=N_Elements();
   assert( nEl != 0);
   // if( !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -374,7 +374,7 @@
   ULong nEl=N_Elements();
   assert( nEl != 0);
   // if( !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -437,7 +437,7 @@
   if( right->StrictScalar(s)) 
     {
       res= new Data_<SpDByte>( this->dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -464,7 +464,7 @@
   else // ( rEl >= nEl)
     {
       res= new Data_<SpDByte>( this->dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -512,7 +512,7 @@
   if( right->StrictScalar(s)) 
     {
       res= new Data_<SpDByte>( this->dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -539,7 +539,7 @@
   else // ( rEl >= nEl)
     {
       res= new Data_<SpDByte>( this->dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -587,7 +587,7 @@
   if( right->StrictScalar(s)) 
     {
       res= new Data_<SpDByte>( this->dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -614,7 +614,7 @@
   else // ( rEl >= nEl)
     {
       res= new Data_<SpDByte>( this->dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -674,7 +674,7 @@
   if( right->StrictScalar(s)) 
     {
       res= new Data_<SpDByte>( this->dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -701,7 +701,7 @@
   else // ( rEl >= nEl)
     {
       res= new Data_<SpDByte>( this->dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -761,7 +761,7 @@
   if( right->StrictScalar(s)) 
     {
       res= new Data_<SpDByte>( this->dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -788,7 +788,7 @@
   else // ( rEl >= nEl)
     {
       res= new Data_<SpDByte>( this->dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -848,7 +848,7 @@
   if( right->StrictScalar(s)) 
     {
       res= new Data_<SpDByte>( this->dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -875,7 +875,7 @@
   else // ( rEl >= nEl)
     {
       res= new Data_<SpDByte>( this->dim, BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -918,7 +918,7 @@
 // MatrixOp
 // returns *this # *r, //C deletes itself and right
 template<class Sp>
-Data_<Sp>* Data_<Sp>::MatrixOp( BaseGDL* r)
+Data_<Sp>* Data_<Sp>::MatrixOp( BaseGDL* r, bool transpose, bool transposeResult, bool strassen)
 {
   Data_* right=static_cast<Data_*>(r);
 
@@ -962,11 +962,11 @@
       // [n] # [n,m] -> [1,m] ([n] -> [1,n])
 
       // right op 1st
-      SizeT nRow=right->dim[1];
+      SizeT nRow=transpose ? right->dim[0] : right->dim[1];
       if( nRow == 0) nRow=1;
 
       // loop dim
-      SizeT nRowEl=right->dim[0];
+      SizeT nRowEl=transpose ? right->dim[1] : right->dim[0];
       if( nRowEl == 0) nRowEl=1;
 
       // result dim
@@ -1005,15 +1005,27 @@
 	throw GDLException("Operands of matrix multiply have"
 			   " incompatible dimensions.",true,false);  
 
+      if( transposeResult)
+      {
+      if( nCol > 1)
+	res=New(dimension( nRow, nCol),BaseGDL::NOZERO);
+      else
+	res=New(dimension(nRow),BaseGDL::NOZERO);
+      }
+      else
+      {
       if( nRow > 1)
 	res=New(dimension(nCol,nRow),BaseGDL::NOZERO);
       else
 	res=New(dimension(nCol),BaseGDL::NOZERO);
+     }
      
       SizeT rIxEnd = nRow * nColEl;
       //#ifdef _OPENMP 
       SizeT nOp = rIxEnd * nCol;
+
 #ifdef USE_STRASSEN_MATRIXMULTIPLICATION
+      if( !transpose && !transposeResult && strassen)
       //if( nOp > 1000000)
 	{
 	  SizeT maxDim;
@@ -1051,11 +1063,16 @@
 
 
       //#endif
+
+if( !transposeResult) // normal
+{
+if( !transpose) // normal
+{
 #pragma omp parallel if (nOp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nOp)) default(shared)
 {
-#pragma omp for 
+#pragma omp for
       for( SizeT colA=0; colA < nCol; ++colA) // res dim 0
-	for( SizeT rIx=0, rowBnCol=0; rIx < rIxEnd; 
+	for( SizeT rIx=0, rowBnCol=0; rIx < rIxEnd;
 	     rIx += nColEl, rowBnCol += nCol) // res dim 1
 	  {
 	    Ty& resEl = (*res)[ rowBnCol + colA];
@@ -1065,6 +1082,59 @@
 	  }
     }
 }
+else // transpose r
+{
+#pragma omp parallel if (nOp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nOp)) default(shared)
+{
+#pragma omp for
+      for( SizeT colA=0; colA < nCol; ++colA) // res dim 0
+	for( SizeT rIx=0, rowBnCol=0; rIx < nRow; ++rIx, rowBnCol += nCol) // res dim 1
+	  {
+	    Ty& resEl = (*res)[ rowBnCol + colA];
+	    resEl = 0;//(*this)[ colA] * (*right)[ rIx]; // initialization
+	    for( SizeT i=0; i < nColEl; ++i)
+	      resEl += (*this)[ i*nCol+colA] * (*right)[ rIx + i * nRow];
+	  }
+    }
+}
+}
+else // transposeResult
+{
+if( !transpose) // normal
+{
+#pragma omp parallel if (nOp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nOp)) default(shared)
+{
+#pragma omp for
+      for( SizeT colA=0; colA < nCol; ++colA) // res dim 0
+	for( SizeT rIx=0, rowBnCol=0; rIx < rIxEnd;
+	     rIx += nColEl, ++rowBnCol) // res dim 1
+	  {
+	    Ty& resEl = (*res)[ rowBnCol + colA * nRow];
+	    resEl = 0;//(*this)[ colA] * (*right)[ rIx]; // initialization
+	    for( SizeT i=0; i < nColEl; ++i)
+	      resEl += (*this)[ i*nCol+colA] * (*right)[ rIx+i];
+	  }
+    }
+}
+else // transpose r
+{
+#pragma omp parallel if (nOp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nOp)) default(shared)
+{
+#pragma omp for
+      for( SizeT colA=0; colA < nCol; ++colA) // res dim 0
+	for( SizeT rIx=0; rIx < nRow; ++rIx) // res dim 1
+	  {
+	    Ty& resEl = (*res)[ rIx + colA * nRow];
+	    resEl = 0;//(*this)[ colA] * (*right)[ rIx]; // initialization
+	    for( SizeT i=0; i < nColEl; ++i)
+	      resEl += (*this)[ i*nCol+colA] * (*right)[ rIx + i * nRow];
+	  }
+    }
+}
+}
+
+
+}
   //C delete right;
   //C delete this;
   return res;
@@ -1075,25 +1145,25 @@
 
 
 // invalid types
-DStructGDL* DStructGDL::MatrixOp( BaseGDL* r)
+DStructGDL* DStructGDL::MatrixOp( BaseGDL* r, bool t, bool tr, bool s)
 {
   throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
   return NULL;
 }
 template<>
-Data_<SpDString>* Data_<SpDString>::MatrixOp( BaseGDL* r)
+Data_<SpDString>* Data_<SpDString>::MatrixOp( BaseGDL* r, bool t, bool tr,  bool s)
 {
   throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
   return this;
 }
 template<>
-Data_<SpDPtr>* Data_<SpDPtr>::MatrixOp( BaseGDL* r)
+Data_<SpDPtr>* Data_<SpDPtr>::MatrixOp( BaseGDL* r, bool t, bool tr,  bool s)
 {
   throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
   return NULL;
 }
 template<>
-Data_<SpDObj>* Data_<SpDObj>::MatrixOp( BaseGDL* r)
+Data_<SpDObj>* Data_<SpDObj>::MatrixOp( BaseGDL* r, bool t, bool tr,  bool s)
 {
   throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
   return NULL;
@@ -1116,7 +1186,7 @@
   assert( nEl);
   // note: we can't use valarray operation here as right->dd 
   // might be larger than this->dd
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -1140,7 +1210,7 @@
   ULong nEl=N_Elements();
   // assert( rEl);
   assert( nEl);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -1157,7 +1227,7 @@
   ULong nEl=N_Elements();
   // assert( rEl);
   assert( nEl);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -1175,7 +1245,7 @@
   ULong nEl=N_Elements();
   // assert( rEl);
   assert( nEl);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -1192,7 +1262,7 @@
   ULong nEl=N_Elements();
   // assert( rEl);
   assert( nEl);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -1278,7 +1348,7 @@
 
   // s &= Ty(1);
 //  dd &= s;
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared(s)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared(s)
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -1305,7 +1375,7 @@
   if( s == zero)
  //   dd = zero;
  {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -1327,7 +1397,7 @@
   if( s == zero)
 //    dd = zero;
 {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
      for( SizeT i=0; i < nEl; ++i)
@@ -1335,7 +1405,7 @@
 }}
   else
 {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -1357,7 +1427,7 @@
   // right->Scalar(s); 
   if( s == zero)
 //    dd = zero;
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -1377,7 +1447,7 @@
   if( s == zero)
 //    dd = zero;
  {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
    for( SizeT i=0; i < nEl; ++i)
@@ -1385,7 +1455,7 @@
 }}
   else
 {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -1462,7 +1532,7 @@
   // assert( rEl);
   assert( nEl);
   //if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -1488,7 +1558,7 @@
   // assert( rEl);
   assert( nEl);
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -1506,7 +1576,7 @@
   // assert( rEl);
   assert( nEl);
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -1525,7 +1595,7 @@
   // assert( rEl);
   assert( nEl);
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -1543,7 +1613,7 @@
   // assert( rEl);
   assert( nEl);
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -1607,7 +1677,7 @@
   // right->Scalar(s); 
   //s &= Ty(1);
 //  dd |= s;
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -1634,7 +1704,7 @@
   // right->Scalar(s); 
   if( s != zero)
 {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -1668,7 +1738,7 @@
   // right->Scalar(s);
   if( s != zero)
 {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -1688,7 +1758,7 @@
   if( s != zero)
 //    dd = s;
 {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -1696,7 +1766,7 @@
 }}
   else
 {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -1766,7 +1836,7 @@
       if( s != Sp::zero)
 //	dd ^= s;
 {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	for( SizeT i=0; i < nEl; ++i)
@@ -1775,7 +1845,7 @@
     }
   else
     {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -1841,7 +1911,7 @@
   assert( nEl);
   Ty s = (*right)[0];
 //  dd ^= s;
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -1913,7 +1983,7 @@
   ULong nEl=N_Elements();
   // assert( rEl);
   assert( nEl);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -1936,7 +2006,7 @@
   // assert( rEl);
   assert( nEl);
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -1978,7 +2048,7 @@
   Ty s = (*right)[0];
   // right->Scalar(s);
 //  dd += s;
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -2001,7 +2071,7 @@
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
   Ty s = (*right)[0];
   // right->Scalar(s);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -2050,7 +2120,7 @@
     dd -= right->dd;
   else
 {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -2072,7 +2142,7 @@
 /*  if( nEl == rEl)
     dd = right->dd - dd;
   else*/
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -2137,7 +2207,7 @@
   Ty s = (*right)[0];
   // right->Scalar(s); 
 //  dd -= s;
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -2156,7 +2226,7 @@
   Ty s = (*right)[0];
   // right->Scalar(s); 
 //  dd = s - dd;
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -2225,7 +2295,7 @@
   //  assert( rEl);
   assert( nEl);
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -2278,7 +2348,7 @@
   assert( nEl);
   Ty s = (*right)[0];
   // right->Scalar(s);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -2335,7 +2405,7 @@
   // assert( rEl);
   assert( nEl);
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -2388,7 +2458,7 @@
   assert( nEl);
   Ty s = (*right)[0];
   // right->Scalar(s);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -2446,7 +2516,7 @@
   // assert( rEl);
   assert( nEl);
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -2488,7 +2558,7 @@
   Ty s = (*right)[0];
   // right->Scalar(s);
 //  dd *= s;
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -2547,7 +2617,7 @@
     }
   else
     {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 //       bool zeroEncountered = false; // until zero operation is already done.
 #pragma omp for
@@ -2586,7 +2656,7 @@
     }
   else
     {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 //       bool zeroEncountered = false; // until zero operation is already done.
 #pragma omp for
@@ -2667,7 +2737,7 @@
     {
       // right->Scalar(s); 
 //      dd /= s;
-/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for*/
        for( SizeT i=0; i < nEl; ++i)
@@ -2701,7 +2771,7 @@
     }
   else
     {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 //       bool zeroEncountered = false;
 #pragma omp for
@@ -2795,7 +2865,7 @@
     }
   else
     {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 //       bool zeroEncountered = false;
 #pragma omp for
@@ -2839,7 +2909,7 @@
     }
   else
     {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 //       bool zeroEncountered = false;
 #pragma omp for
@@ -2878,7 +2948,7 @@
   // assert( rEl);
   assert( nEl);
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -2897,7 +2967,7 @@
   // assert( rEl);
   assert( nEl);
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -2922,7 +2992,7 @@
   // assert( rEl);
   assert( nEl);
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -2941,7 +3011,7 @@
   // assert( rEl);
   assert( nEl);
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -3046,7 +3116,7 @@
       
       // right->Scalar(s); 
       assert( s == this->zero);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT ix=i; ix < nEl; ++ix)
@@ -3080,7 +3150,7 @@
     }
   else
     {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 //       bool zeroEncountered = false;
@@ -3113,7 +3183,7 @@
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
   Ty s = (*right)[0];
   // right->Scalar(s); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -3132,7 +3202,7 @@
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
   Ty s = (*right)[0];
   // right->Scalar(s); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -3149,7 +3219,7 @@
   assert( nEl);
   Ty s = (*right)[0];
   // right->Scalar(s);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -3167,7 +3237,7 @@
   assert( nEl);
   Ty s = (*right)[0];
   // right->Scalar(s); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -3286,7 +3356,7 @@
   //  assert( rEl);
   assert( nEl);
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -3308,7 +3378,7 @@
   //      right->dd.resize(nEl);
   //      dd = pow( right->Resize(nEl), dd); // valarray
       
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -3333,7 +3403,7 @@
     }
   else*/
     {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -3378,7 +3448,7 @@
   if( r->StrictScalar())
     {
       DLong r0 = (*right)[0];  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -3398,7 +3468,7 @@
     }
   if( nEl <= rEl)
     {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -3429,7 +3499,7 @@
     {
       Data_* res = new Data_( Dim(), BaseGDL::NOZERO);
       DLong r0 = (*right)[0];  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -3450,7 +3520,7 @@
   if( nEl <= rEl)
     {
       Data_* res = new Data_( Dim(), BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -3480,7 +3550,7 @@
   if( r->StrictScalar())
     {
       DLong r0 = (*right)[0];  
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -3500,7 +3570,7 @@
     }
   if( nEl <= rEl)
     {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -3531,7 +3601,7 @@
     {
       Data_* res = new Data_( Dim(), BaseGDL::NOZERO);
       DLong r0 = (*right)[0];  
-  #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+  #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -3552,7 +3622,7 @@
   if( nEl <= rEl)
     {
       Data_* res = new Data_( Dim(), BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -3586,7 +3656,7 @@
 /*  if( rEl == nEl)
     dd = pow( right->dd, dd); // valarray
   else*/
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -3610,7 +3680,7 @@
 /*  if( rEl == nEl)
     dd = pow( dd, right->dd); // valarray
   else*/
-  #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+  #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -3634,7 +3704,7 @@
 /*  if( rEl == nEl)
     dd = pow( right->dd, dd); // valarray
   else*/
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -3662,7 +3732,7 @@
       // (must also be consistent with ComplexDbl)
       if( right->StrictScalar(s)) 
 	{
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	  for( SizeT i=0; i<nEl; ++i)
@@ -3689,7 +3759,7 @@
 		  return res;
 		}
 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	      for( SizeT i=0; i<nEl; ++i)
@@ -3722,7 +3792,7 @@
       // (must also be consistent with ComplexDbl)
       if( right->StrictScalar(s)) 
 	{
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	  for( SizeT i=0; i<nEl; ++i)
@@ -3749,7 +3819,7 @@
 		  return res;
 		}
 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	      for( SizeT i=0; i<nEl; ++i)
@@ -3788,7 +3858,7 @@
 /*  if( r->N_Elements() == nEl)
     dd = pow( dd, right->dd); // valarray
   else*/
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -3818,7 +3888,7 @@
 /*  if( rEl == nEl)
     dd = pow( right->dd, dd); // valarray
   else*/
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -3847,7 +3917,7 @@
       // (concerning when a new variable is created vs. using this)
       if( right->StrictScalar(s)) 
 	{
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	  for( SizeT i=0; i<nEl; ++i)
@@ -3874,7 +3944,7 @@
 		  return res;
 		}
 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	      for( SizeT i=0; i<nEl; ++i)
@@ -3909,7 +3979,7 @@
       // (concerning when a new variable is created vs. using this)
       if( right->StrictScalar(s)) 
 	{
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	  for( SizeT i=0; i<nEl; ++i)
@@ -3936,7 +4006,7 @@
 		  return res;
 		}
 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	      for( SizeT i=0; i<nEl; ++i)
@@ -3975,7 +4045,7 @@
 /*  if( r->N_Elements() == nEl)
     dd = pow( dd, right->dd); // valarray
   else*/
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -4005,7 +4075,7 @@
 /*  if( rEl == nEl)
     dd = pow( right->dd, dd); // valarray
   else*/
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
     for( SizeT i=0; i < nEl; ++i)
@@ -4073,7 +4143,7 @@
   Ty s = (*right)[0];
   // right->Scalar(s); 
 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -4094,7 +4164,7 @@
   Ty s = (*right)[0];
   // right->Scalar(s); 
   //      dd = pow( s, d); // valarray
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i < nEl; ++i)
@@ -4112,7 +4182,7 @@
   assert( nEl);
   Ty s = (*right)[0];
   // right->Scalar(s); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i<nEl; ++i)	
@@ -4130,7 +4200,7 @@
   assert( nEl);
   Ty s = (*right)[0];
   // right->Scalar(s); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i<nEl; ++i)	
@@ -4148,7 +4218,7 @@
   assert( nEl);
   Ty s = (*right)[0];
   // right->Scalar(s); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i<nEl; ++i)	
@@ -4166,7 +4236,7 @@
   assert( nEl);
   Ty s = (*right)[0];
   // right->Scalar(s); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i<nEl; ++i)	
@@ -4194,7 +4264,7 @@
       // (must also be consistent with ComplexDbl)
       if( right->StrictScalar(s)) 
 	{
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	  for( SizeT i=0; i<nEl; ++i)
@@ -4221,7 +4291,7 @@
 		  return res;
 		}
 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	      for( SizeT i=0; i<nEl; ++i)
@@ -4254,7 +4324,7 @@
       // (must also be consistent with ComplexDbl)
       if( right->StrictScalar(s)) 
 	{
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	  for( SizeT i=0; i<nEl; ++i)
@@ -4281,7 +4351,7 @@
 		  return res;
 		}
 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	      for( SizeT i=0; i<nEl; ++i)
@@ -4313,7 +4383,7 @@
   Ty s = (*right)[0];
   // right->Scalar(s); 
 //#if (__GNUC__ == 3) && (__GNUC_MINOR__ <= 2)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i<nEl; ++i)
@@ -4340,7 +4410,7 @@
   Ty s = (*right)[0];
   // right->Scalar(s); 
 //#if (__GNUC__ == 3) && (__GNUC_MINOR__ <= 2)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i<nEl; ++i)
@@ -4372,7 +4442,7 @@
       // (concerning when a new variable is created vs. using this)
       if( right->StrictScalar(s)) 
 	{
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	  for( SizeT i=0; i<nEl; ++i)
@@ -4399,7 +4469,7 @@
 		  return res;
 		}
 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	      for( SizeT i=0; i<nEl; ++i)
@@ -4434,7 +4504,7 @@
       // (concerning when a new variable is created vs. using this)
       if( right->StrictScalar(s)) 
 	{
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	  for( SizeT i=0; i<nEl; ++i)
@@ -4461,7 +4531,7 @@
 		  return res;
 		}
 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	      for( SizeT i=0; i<nEl; ++i)
@@ -4493,7 +4563,7 @@
   Ty s = (*right)[0];
   // right->Scalar(s); 
 //#if (__GNUC__ == 3) && (__GNUC_MINOR__ <= 2)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i<nEl; ++i)
@@ -4517,7 +4587,7 @@
   Ty s = (*right)[0];
   // right->Scalar(s); 
 //#if (__GNUC__ == 3) && (__GNUC_MINOR__ <= 2)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
   for( SizeT i=0; i<nEl; ++i)
@@ -4602,7 +4672,7 @@
   Ty s;
   if( right->StrictScalar(s)) 
     {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -4611,7 +4681,7 @@
     }
   else 
     {
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i < nEl; ++i)
@@ -4660,7 +4730,7 @@
 	{
 	  DComplexGDL* res = new DComplexGDL( this->Dim(), 
 					      BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	  for( SizeT i=0; i<nEl; ++i)
@@ -4689,7 +4759,7 @@
 
 	      DComplexGDL* res = new DComplexGDL( this->Dim(), 
 						  BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	      for( SizeT i=0; i<nEl; ++i)
@@ -4724,7 +4794,7 @@
 	{
 	  DComplexGDL* res = new DComplexGDL( this->Dim(), 
 					      BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	  for( SizeT i=0; i<nEl; ++i)
@@ -4753,7 +4823,7 @@
 
 	      DComplexGDL* res = new DComplexGDL( this->Dim(), 
 						  BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	      for( SizeT i=0; i<nEl; ++i)
@@ -4788,7 +4858,7 @@
       DComplexGDL* res = new DComplexGDL( this->Dim(), 
 					  BaseGDL::NOZERO);
 //#if (__GNUC__ == 3) && (__GNUC_MINOR__ <= 2)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i<nEl; ++i)
@@ -4812,7 +4882,7 @@
 /*      if( r->N_Elements() == nEl)
 	res->dd = pow( dd, right->dd); // valarray
       else*/
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	for( SizeT i=0; i < nEl; ++i)
@@ -4844,7 +4914,7 @@
 	{
 	  DComplexDblGDL* res = new DComplexDblGDL( this->Dim(), 
 						    BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	  for( SizeT i=0; i<nEl; ++i)
@@ -4873,7 +4943,7 @@
 
 	      DComplexDblGDL* res = new DComplexDblGDL( this->Dim(), 
 							BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	      for( SizeT i=0; i<nEl; ++i)
@@ -4908,7 +4978,7 @@
 	{
 	  DComplexDblGDL* res = new DComplexDblGDL( this->Dim(), 
 						    BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	  for( SizeT i=0; i<nEl; ++i)
@@ -4937,7 +5007,7 @@
 
 	      DComplexDblGDL* res = new DComplexDblGDL( this->Dim(), 
 							BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	      for( SizeT i=0; i<nEl; ++i)
@@ -4972,7 +5042,7 @@
       DComplexDblGDL* res = new DComplexDblGDL( this->Dim(), 
 						BaseGDL::NOZERO);
 //#if (__GNUC__ == 3) && (__GNUC_MINOR__ <= 2)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
       for( SizeT i=0; i<nEl; ++i)
@@ -4996,7 +5066,7 @@
 /*      if( r->N_Elements() == nEl)
 	res->dd = pow( dd, right->dd); // valarray
       else*/
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
 	for( SizeT i=0; i < nEl; ++i)
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/basic_pro.cpp cvs/gdl/src/basic_pro.cpp
--- gdl-0.9rc4/src/basic_pro.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/basic_pro.cpp	2010-07-07 14:41:01.137003709 -0600
@@ -688,47 +688,50 @@
   void exitgdl( EnvT* e)
   {
 
-#ifdef HAVE_LIBWXWIDGETS
-    wxTheApp->OnExit(); // Defined in GDLApp::OnExit() in gdlwidget.cpp
-    wxUninitialize();
-#endif
-
 #ifdef HAVE_LIBREADLINE
 
     // we manage the ASCII "history" file (located in ~/.gdl/)
     // we do not manage NOW the number of lines we save,
     // this should be limited by "history/readline" itself
-    
-    // Create eventually the ".gdl" path in user $HOME
-    int result, debug=0;
-    char *homeDir = getenv( "HOME");
-    if (homeDir != NULL)
+
+    if( historyIntialized)
     {
-      string pathToGDL_history = homeDir;
-      AppendIfNeeded(pathToGDL_history, "/");
-      pathToGDL_history += ".gdl";
-      // Create eventially the ".gdl" path in Home
-      result = mkdir(pathToGDL_history.c_str(), 0700);
-      if (debug)
-      { 
-        if (result == 0) cout << "Creation of ~/.gdl PATH "<< endl;
-        else cout << "~/.gdl PATH was still here "<< endl;
-      }
-    
-      // (over)write the history file in ~/.gdl PATH
-  
-      AppendIfNeeded(pathToGDL_history, "/");
-      string history_filename = pathToGDL_history + "history";
-      if (debug) cout << "History file name: " << history_filename << endl;
-      result = write_history(history_filename.c_str());
-      if (debug) 
-      { 
-        if (result == 0) cout<<"Successfull writing of ~/.gdl/history"<<endl;
-        else cout <<"Fail to write ~/.gdl/history"<<endl;
-      }
+		// Create eventually the ".gdl" path in user $HOME
+		int result, debug=0;
+		char *homeDir = getenv( "HOME");
+		if (homeDir != NULL)
+		{
+			string pathToGDL_history = homeDir;
+			AppendIfNeeded(pathToGDL_history, "/");
+			pathToGDL_history += ".gdl";
+			// Create eventially the ".gdl" path in Home
+			result = mkdir(pathToGDL_history.c_str(), 0700);
+			if (debug)
+			{
+				if (result == 0) cout << "Creation of ~/.gdl PATH "<< endl;
+				else cout << "~/.gdl PATH was still here "<< endl;
+			}
+			
+			// (over)write the history file in ~/.gdl PATH
+		
+			AppendIfNeeded(pathToGDL_history, "/");
+			string history_filename = pathToGDL_history + "history";
+			if (debug) cout << "History file name: " << history_filename << endl;
+			result = write_history(history_filename.c_str());
+			if (debug)
+			{
+				if (result == 0) cout<<"Successfull writing of ~/.gdl/history"<<endl;
+				else cout <<"Fail to write ~/.gdl/history"<<endl;
+			}
+		}
     }
 #endif
 
+#ifdef HAVE_LIBWXWIDGETS
+    wxTheApp->OnExit(); // Defined in GDLApp::OnExit() in gdlwidget.cpp
+//     wxUninitialize();
+#endif
+
     BaseGDL* status=e->GetKW( 1);
     if( status == NULL) exit( EXIT_SUCCESS);
     
@@ -913,8 +916,8 @@
     e->AssureScalarPar<DStringGDL>( 1, name); 
 
     // Change leading "~" to home directory
-    if (name.substr(0,2) == "~/")
-      name = getenv("HOME") + name.substr(1,name.size()-1);
+//     if (name.substr(0,2) == "~/")
+//       name = getenv("HOME") + name.substr(1,name.size()-1);
 
     // endian
     bool swapEndian=false;
@@ -1233,6 +1236,9 @@
       }
     else
       {
+        if (!fileUnits[lun-1].IsOpen())
+          e->Throw("File unit is not open: " + i2s(lun));
+
 	compress = fileUnits[ lun-1].Compress();
 	if( !compress)
 		os = &fileUnits[ lun-1].OStream();
@@ -2171,11 +2177,61 @@
       }
   }
 
-  void resolve_routine( EnvT* e) {
+  void resolve_routine( EnvT* e)
+  {
+    SizeT nParam=e->NParam(1); 
+    
+//     static int eitherIx = e->KeywordIx( "EITHER");
+//     static int is_functionIx = e->KeywordIx( "IS_FUNCTION");
+//     static int no_recompileIx = e->KeywordIx( "NO_RECOMPILE");
+
+	BaseGDL* p0 = e->GetParDefined( 0);
+	DStringGDL* p0S = dynamic_cast<DStringGDL*>( p0);
+	if( p0S == NULL)
+	      e->Throw( "Expression must be a string in this context: "+
+		        e->GetParString(0));
 
+	static StrArr openFiles;
+	
+	SizeT nEl = p0S->N_Elements();
+	for( int i=0; i<nEl; ++i)
+	{
+		DString pro = (*p0S)[ i];
 
-  }
+		string proFile=StrLowCase(pro);
+		AppendIfNeeded( proFile, ".pro");
 
+		bool found=CompleteFileName(proFile);
+		if( !found)
+			e->Throw("Not found: " + proFile);
+	
+		// file already opened?
+		bool open = false;
+		for( StrArr::iterator i=openFiles.begin(); i != openFiles.end(); i++)
+		{
+			if( proFile == *i)
+			{
+				open = true;
+				break;
+			}
+		}
+		if( open)
+			continue;
+
+		StackSizeGuard<StrArr> guard( openFiles);
+
+	    // append file to list
+		openFiles.push_back(proFile);
+
+		bool success =  GDLInterpreter::CompileFile( proFile, ""); // this might trigger recursion
+			
+		if( success)
+			Message("RESOLVE_ROUTINE: Compiled file: " + proFile);
+		else
+			e->Throw("Failed to compiled file: " + proFile);
+	}
+  }
+  
   void caldat(EnvT* e) {
     /* 
      * SA: based on the following codes:
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/basic_pro_jmg.cpp cvs/gdl/src/basic_pro_jmg.cpp
--- gdl-0.9rc4/src/basic_pro_jmg.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/basic_pro_jmg.cpp	2010-04-16 11:22:53.000000000 -0600
@@ -45,17 +45,22 @@
     e->AssureLongScalarPar( 0, lun);
 
     if( lun == 0 || abs(lun) > maxLun)
-      e->Throw(  "File unit is not within allowed range.");
+      throw GDLException( e->CallingNode(), 
+  			  "POINT_LUN:  File unit is not within allowed range.");
 
     GDLStream& actUnit = fileUnits[ abs(lun)-1];
 
     if( !actUnit.IsOpen()) 
-      e->Throw(  "File unit is not open: " +i2s(abs(lun)));
+      throw GDLException( e->CallingNode(), 
+  			  "POINT_LUN:  File unit is not open: " +i2s(abs(lun)));
 
     if (lun < 0) {
-      e->AssureGlobalPar(1);
-      // TODO: 64-bit long if needed 
-      e->SetPar(1, new DLongGDL( actUnit.Tell()));
+      BaseGDL** retPos = &e->GetPar( 1);
+
+      delete *retPos;
+      *retPos = new DLongGDL( actUnit.Tell());
+      return;
+
     } else {
       DLong pos;
       e->AssureLongScalarPar( 1, pos);
@@ -160,27 +165,46 @@
     double t_current=0.0;
 
     double diff=0.0;
-    while (diff < waittime ) {
-
-      if( sigControlC) return;
-
-      struct timespec delay;
-      delay.tv_sec=0;
-      if( (waittime - diff) > 0.1)
-	{
-	  delay.tv_nsec = 100000000; // 100ms
-	  nanosleep(&delay,NULL);
-	}
-      else
-	{
-	  delay.tv_nsec = (long int)(waittime - diff) * 1000000000; // 1s
-	  nanosleep(&delay,NULL);
-	}
-
+    while (diff < waittime ) {      
       gettimeofday(&tval,&tzone);
       t_current= tval.tv_sec+tval.tv_usec/1e+6;
-      diff=t_current - t_start;      
+      diff=t_current - t_start;
     }
   }
 
+  void kwtest( EnvT* e)
+  {
+    StackGuard<EnvStackT> guard( e->Interpreter()->CallStack());
+
+    // here first parameter is the function name
+    // set callF to the function you want to call
+    int nParam=e->NParam();
+    if( nParam == 0)
+     e->Throw( "No function specified.");
+    DString callF;
+    e->AssureScalarPar<DStringGDL>( 0, callF);
+ 
+    // this is a function name -> convert to UPPERCASE
+    callF = StrUpCase( callF);
+
+	SizeT funIx = GDLInterpreter::GetFunIx( callF);
+	
+	EnvUDT* newEnv= new EnvUDT( e, funList[ funIx], NULL);
+
+	// add parameter
+	SizeT widgetID = 999;
+      
+    newEnv->SetNextPar( new DLongGDL(widgetID)); // pass as local
+
+	e->Interpreter()->CallStack().push_back( newEnv);
+	
+	// make the call
+	BaseGDL* res = e->Interpreter()->
+	  call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
+
+	// set the keyword to the function's return value
+    static int testIx = e->KeywordIx( "TEST");
+    e->SetKW( testIx, res);
+  }
+
 } // namespace
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/basic_pro_jmg.hpp cvs/gdl/src/basic_pro_jmg.hpp
--- gdl-0.9rc4/src/basic_pro_jmg.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/basic_pro_jmg.hpp	2010-04-16 11:22:53.000000000 -0600
@@ -27,6 +27,8 @@
   void linkimage( EnvT* e);
   void wait( EnvT* e);
 
+  void kwtest( EnvT* e);
+
 } // namespace
 
 #endif
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/convert2.cpp cvs/gdl/src/convert2.cpp
--- gdl-0.9rc4/src/convert2.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/convert2.cpp	2010-07-07 14:41:01.218007705 -0600
@@ -38,6 +38,14 @@
   return os.str();
 }
 
+// for float -> string
+inline string float2string( DFloat f)      
+{
+  std::ostringstream os;
+  OutAuto( os, f, 13, 6);
+  return os.str();
+}
+
 // every type need this function which defines its conversion to all other types
 // so for every new type each of this functions has to be extended
 // and a new function has to be 'specialized'
@@ -572,6 +580,8 @@
 } // UINT
 
 
+
+
 template<> BaseGDL* Data_<SpDLong>::Convert2( DType destTy, BaseGDL::Convert2Mode mode)
 {
   if( destTy == t) return (((mode & BaseGDL::COPY) != 0)?Dup():this);
@@ -688,7 +698,7 @@
 {
 #pragma omp for
       	for( SizeT i=0; i < nEl; ++i)
-      	  (*dest)[i]=i2s((*this)[i],8);
+      	  (*dest)[i]=i2s((*this)[i],12);
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
       	return dest;
@@ -730,6 +740,9 @@
   return NULL; 
 } // LONG  
 
+
+
+
 template<> BaseGDL* Data_<SpDULong>::Convert2( DType destTy, BaseGDL::Convert2Mode mode)
 {
   if( destTy == t) return (((mode & BaseGDL::COPY) != 0)?Dup():this);
@@ -846,7 +859,7 @@
 {
 #pragma omp for
       	for( SizeT i=0; i < nEl; ++i)
-      	  (*dest)[i]=i2s((*this)[i],8);
+      	  (*dest)[i]=i2s((*this)[i],12);
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
       	return dest;
@@ -888,6 +901,9 @@
   return NULL; 
 } // ULONG   
 
+
+
+
 template<> BaseGDL* Data_<SpDFloat>::Convert2( DType destTy, BaseGDL::Convert2Mode mode)
 {
   if( destTy == t) return (((mode & BaseGDL::COPY) != 0)?Dup():this);
@@ -1000,7 +1016,7 @@
 {
 #pragma omp for
       	for( SizeT i=0; i < nEl; ++i)
-      	  (*dest)[i]=i2s((*this)[i],13);
+      	  (*dest)[i]=float2string((*this)[i]);
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
       	return dest;
@@ -1041,6 +1057,9 @@
   return NULL; 
 }  
 
+
+
+
 template<> BaseGDL* Data_<SpDDouble>::Convert2( DType destTy, BaseGDL::Convert2Mode mode)
 {
   if( destTy == t) return (((mode & BaseGDL::COPY) != 0)?Dup():this);
@@ -1196,6 +1215,10 @@
   return NULL; 
 }  
 
+
+
+
+
 inline void StringConversionError( bool& errorFlag, BaseGDL::Convert2Mode mode, const string& msg)
 {
   if( (mode & BaseGDL::THROWIOERROR) != 0)
@@ -1537,6 +1560,9 @@
   return NULL; 
 }  
 
+
+
+
 template<> BaseGDL* Data_<SpDComplex>::Convert2( DType destTy, BaseGDL::Convert2Mode mode)
 {
   if( destTy == t) return (((mode & BaseGDL::COPY) != 0)?Dup():this);
@@ -1690,6 +1716,9 @@
   return NULL; // get rid of warning
 }  
 
+
+
+
 template<> BaseGDL* Data_<SpDComplexDbl>::Convert2( DType destTy, BaseGDL::Convert2Mode mode)
 {
   if( destTy == t) return (((mode & BaseGDL::COPY) != 0)?Dup():this);
@@ -1843,6 +1872,9 @@
   return NULL; // get rid of warning
 }  
 
+
+
+
 // 64 bit integers
 template<> BaseGDL* Data_<SpDLong64>::Convert2( DType destTy, BaseGDL::Convert2Mode mode)
 {
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/datalistt.hpp cvs/gdl/src/datalistt.hpp
--- gdl-0.9rc4/src/datalistt.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/datalistt.hpp	2010-05-21 10:23:55.471906250 -0600
@@ -84,7 +84,7 @@
     env.pop_back();
   }
 
-  SizeT size() { return env.size();}
+  SizeT size() const { return env.size();}
   void reserve( SizeT s)
   {
     env.reserve( s);
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/datatypes.cpp cvs/gdl/src/datatypes.cpp
--- gdl-0.9rc4/src/datatypes.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/datatypes.cpp	2010-05-21 10:23:55.497968057 -0600
@@ -56,7 +56,6 @@
 
 using namespace std;
 
-
 // this (ugly) including of other sourcefiles has to be done, because
 // on Mac OS X a template instantiation request (see bottom of file)
 // can only be done once
@@ -72,6 +71,9 @@
 #define INCLUDE_OFMT_CPP 1
 #include "ofmt.cpp"
 
+#define INCLUDE_DATATYPESREF_CPP 1
+#include "datatypesref.cpp"
+
 #if defined(USE_PYTHON) || defined(PYTHON_MODULE)
 
 #define INCLUDE_TOPYTHON_CPP 1
@@ -86,13 +88,15 @@
 #endif
 #endif
 
-template<class Sp> 
+template<class Sp>
 deque< void*> Data_<Sp>::freeList;
 
 template<class Sp> void* Data_<Sp>::operator new( size_t bytes)
 {
 	assert( bytes == sizeof( Data_));
 	
+// 	cout << "Alloc: " << bytes << "  " << Sp::str << endl;
+
 	if( freeList.size() > 0)
 	{
 		void* res = freeList.back();
@@ -100,8 +104,6 @@
 		return res;	
 	}
 
-//	cout << "Alloc: " << bytes << "  " << Sp::str << endl;
-
 	const size_t newSize = multiAlloc - 1;
 	freeList.resize( newSize);
 	char* res = static_cast< char*>( malloc( sizeof( Data_) * multiAlloc)); // one more than newSize
@@ -116,13 +118,25 @@
 
 template<class Sp> void Data_<Sp>::operator delete( void *ptr)
 {
+// 	cout << "Delete: " << ptr << endl;
+
 	freeList.push_back( ptr);
 }
 
 
 
 // destructor
-template<class Sp> Data_<Sp>::~Data_() {};
+template<class Sp> Data_<Sp>::~Data_() {}
+template<> Data_<SpDPtr>::~Data_()
+{
+	if( this->dd.GetBuffer() != NULL)
+		GDLInterpreter::DecRef( this);
+}
+template<> Data_<SpDObj>::~Data_()
+{
+	if( this->dd.GetBuffer() != NULL)
+		GDLInterpreter::DecRefObj( this);
+}
 
 // default
 template<class Sp> Data_<Sp>::Data_(): Sp(), dd() {}
@@ -130,6 +144,10 @@
 // scalar
 template<class Sp> Data_<Sp>::Data_(const Ty& d_): Sp(), dd(d_)
 {}
+// template<> Data_<SpDPtr>::Data_(const Ty& d_): SpDPtr(), dd(d_)
+// {GDLInterpreter::IncRef(d_);}
+// template<> Data_<SpDObj>::Data_(const Ty& d_): SpDObj(), dd(d_)
+// {GDLInterpreter::IncRefObj(d_);}
 
 // new array, zero fields
 template<class Sp> Data_<Sp>::Data_(const dimension& dim_): 
@@ -142,13 +160,18 @@
 template<class Sp> Data_<Sp>::Data_( const Ty* p, const SizeT nEl): 
   Sp( dimension( nEl)), dd( p, nEl)
 {}
+template<> Data_<SpDPtr>::Data_( const Ty* p, const SizeT nEl):
+  SpDPtr( dimension( nEl)), dd( p, nEl)
+{GDLInterpreter::IncRef(this);}
+template<> Data_<SpDObj>::Data_( const Ty* p, const SizeT nEl):
+  SpDObj( dimension( nEl)), dd( p, nEl)
+{GDLInterpreter::IncRefObj(this);}
 
 // c-i 
 // template<class Sp> Data_<Sp>::Data_(const Data_& d_): 
 // Sp(d_.dim), dd(d_.dd) {}
 
-template<class Sp> Data_<Sp>::Data_(const dimension& dim_,
-				    BaseGDL::InitType iT): 
+template<class Sp> Data_<Sp>::Data_(const dimension& dim_, BaseGDL::InitType iT):
   Sp( dim_), dd( (iT == BaseGDL::NOALLOC) ? 0 : this->dim.N_Elements(), false)
 {
   this->dim.Purge();
@@ -157,13 +180,13 @@
     {
       SizeT sz=dd.size();
 //       Ty val=Sp::zero;
-#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
+#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS)// && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
 {
 #pragma omp for
       for( SizeT i=0; i<sz; i++)
 	{
 	  (*this)[i]=i;//val;
-}
+	}
 // 	  val += 1; // no increment operator for floats
 	}
     }
@@ -236,8 +259,7 @@
 // string, ptr, obj (cannot be INDGEN, 
 // need not to be zeroed if all intialized later)
 // struct (as a separate class) as well
-template<> Data_<SpDString>::Data_(const dimension& dim_,  
-				   BaseGDL::InitType iT): 
+template<> Data_<SpDString>::Data_(const dimension& dim_, BaseGDL::InitType iT):
   SpDString(dim_), dd( (iT == BaseGDL::NOALLOC) ? 0 : this->dim.N_Elements(), false)
 {
   dim.Purge();
@@ -245,25 +267,84 @@
   if( iT == BaseGDL::INDGEN)
     throw GDLException("DStringGDL(dim,InitType=INDGEN) called.");
 }
-template<> Data_<SpDPtr>::Data_(const dimension& dim_,  
-				BaseGDL::InitType iT): 
+template<> Data_<SpDPtr>::Data_(const dimension& dim_,  BaseGDL::InitType iT):
   SpDPtr(dim_), dd( (iT == BaseGDL::NOALLOC) ? 0 : this->dim.N_Elements(), false)
 {
   dim.Purge();
   
   if( iT == BaseGDL::INDGEN)
     throw GDLException("DPtrGDL(dim,InitType=INDGEN) called.");
+
+  if( iT != BaseGDL::NOALLOC && iT != BaseGDL::NOZERO)
+	{
+	SizeT sz = dd.size();
+/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
+{
+#pragma omp for*/
+      for( SizeT i=0; i<sz; ++i)
+		{
+			(*this)[i]=0;
+		}
+// 	  val += 1; // no increment operator for floats
+// 	}
+	}
 }
-template<> Data_<SpDObj>::Data_(const dimension& dim_,  
-				BaseGDL::InitType iT): 
+template<> Data_<SpDObj>::Data_(const dimension& dim_, BaseGDL::InitType iT):
   SpDObj(dim_), dd( (iT == BaseGDL::NOALLOC) ? 0 : this->dim.N_Elements(), false)
 {
   dim.Purge();
 
   if( iT == BaseGDL::INDGEN)
     throw GDLException("DObjGDL(dim,InitType=INDGEN) called.");
+
+  if( iT != BaseGDL::NOALLOC && iT != BaseGDL::NOZERO)
+	{
+	SizeT sz = dd.size();
+/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
+{
+#pragma omp for*/
+      for( SizeT i=0; i<sz; i++)
+	{
+	  (*this)[i]=0;
+	}
+// 	  val += 1; // no increment operator for floats
+// 	}
+	}
 }
 
+// c-i
+template<class Sp>
+  Data_<Sp>::Data_(const Data_& d_): Sp(d_.dim), dd(d_.dd) {}
+template<>
+  Data_<SpDPtr>::Data_(const Data_& d_): SpDPtr(d_.dim), dd(d_.dd)
+  {
+    GDLInterpreter::IncRef( this);
+  }
+template<>
+  Data_<SpDObj>::Data_(const Data_& d_): SpDObj(d_.dim), dd(d_.dd)
+  {
+    GDLInterpreter::IncRefObj( this);
+  }
+
+
+template<class Sp>
+Data_<Sp>* Data_<Sp>::Dup() const { return new Data_(*this);}
+
+// template<>
+// Data_<SpDPtr>* Data_<SpDPtr>::Dup() const
+//   {
+//   Data_<SpDPtr>* p =new Data_(*this);
+//   GDLInterpreter::IncRef( p);
+//   return p;
+//   }
+// template<>
+//   Data_<SpDObj>* Data_<SpDObj>::Dup() const
+//   {
+//   Data_<SpDObj>* p =new Data_(*this);
+//   GDLInterpreter::IncRefObj( p);
+//   return p;
+//   }
+
 
 template<class Sp>
 Data_<Sp>* Data_<Sp>::Log()              
@@ -584,10 +665,11 @@
 
       srcIx[ aSp] = 0;
       if( s[ aSp] >= 0)
-	dstIx[ aSp] = s[ aSp] % this_dim[ aSp];
+		dstIx[ aSp] = s[ aSp] % this_dim[ aSp];
       else
-	dstIx[ aSp] = -(-s[aSp] % this_dim[ aSp]);
-      if( dstIx[ aSp] < 0) dstIx[ aSp] += this_dim[ aSp];
+		dstIx[ aSp] = -(-s[aSp] % this_dim[ aSp]);
+      if( dstIx[ aSp] < 0)
+		dstIx[ aSp] += this_dim[ aSp];
 
       dim_stride[ aSp] = this_dim[ aSp] * stride[ aSp];
     }
@@ -599,7 +681,44 @@
 
   Ty* ddP = &(*this)[0];
   Ty* shP = &(*sh)[0];
-  
+
+  if( nDim == 2)
+  {
+	for( SizeT a=0; a<nEl; ++srcIx[0],++dstIx[0])
+		{
+		if( dstIx[ 0] >= this_dim[ 0])
+			{
+			// dstIx[ aSp] -= dim[ aSp];
+			dstIx[ 0] = 0;
+			dstLonIx -= dim_stride[ 0];
+			}
+		if( srcIx[ 0] >= this_dim[ 0])
+		{
+			srcIx[ 0] = 0;
+			++srcIx[ 1];
+			++dstIx[ 1];
+			dstLonIx += stride[ 1];
+ 	
+			if( dstIx[ 1] >= this_dim[ 1])
+				{
+				// dstIx[ aSp] -= dim[ aSp];
+				dstIx[ 1] = 0;
+				dstLonIx -= dim_stride[ 1];
+				}
+			
+			assert( srcIx[ 1] < this_dim[ 1]);
+/*			if( srcIx[ 1] >= this_dim[ 1])
+				{
+				srcIx[ 1] = 0;
+				}*/
+		}
+		
+		shP[ dstLonIx++] = ddP[ a++];
+		}
+	
+	return sh;
+  }
+
   for( SizeT a=0; a<nEl; ++srcIx[0],++dstIx[0])
     {
       for( SizeT aSp=0; aSp<nDim;)
@@ -613,7 +732,9 @@
 	  if( srcIx[ aSp] < this_dim[ aSp]) break;
 
 	  srcIx[ aSp] = 0;
-	  ++srcIx[ ++aSp];
+	  if( ++aSp >= nDim) break; // ??
+	  
+	  ++srcIx[ aSp];
 	  ++dstIx[ aSp];
 	  dstLonIx += stride[ aSp];
 	}
@@ -798,6 +919,62 @@
   }
   return res_guard.release();
 }
+template<>
+BaseGDL* Data_<SpDPtr>::DupReverse( DLong dim)
+{
+  // SA: based on total_over_dim_template()
+  Data_* res = new Data_(this->dim, BaseGDL::NOZERO);
+  auto_ptr<Data_> res_guard(res);
+  SizeT nEl = N_Elements();
+  SizeT revStride = this->dim.Stride(dim); 
+  SizeT outerStride = this->dim.Stride(dim + 1);
+  SizeT revLimit = this->dim[dim] * revStride;
+  for (SizeT o = 0; o < nEl; o += outerStride)
+  {
+    for (SizeT i = 0; i < revStride; ++i) 
+    {
+      SizeT oi = o + i; 
+      SizeT last_plus_oi = revLimit + oi - revStride + oi;
+      SizeT half = ((revLimit / revStride) / 2) * revStride + oi;
+      for (SizeT s = oi; s < half; s += revStride) 
+      {
+        SizeT opp = last_plus_oi - s;
+        (*res)[s] = (*this)[opp];
+        (*res)[opp] = (*this)[s];
+      }
+    }
+  }
+  GDLInterpreter::IncRef( res);
+  return res_guard.release();
+}
+template<>
+BaseGDL* Data_<SpDObj>::DupReverse( DLong dim)
+{
+  // SA: based on total_over_dim_template()
+  Data_* res = new Data_(this->dim, BaseGDL::NOZERO);
+  auto_ptr<Data_> res_guard(res);
+  SizeT nEl = N_Elements();
+  SizeT revStride = this->dim.Stride(dim); 
+  SizeT outerStride = this->dim.Stride(dim + 1);
+  SizeT revLimit = this->dim[dim] * revStride;
+  for (SizeT o = 0; o < nEl; o += outerStride)
+  {
+    for (SizeT i = 0; i < revStride; ++i) 
+    {
+      SizeT oi = o + i; 
+      SizeT last_plus_oi = revLimit + oi - revStride + oi;
+      SizeT half = ((revLimit / revStride) / 2) * revStride + oi;
+      for (SizeT s = oi; s < half; s += revStride) 
+      {
+        SizeT opp = last_plus_oi - s;
+        (*res)[s] = (*this)[opp];
+        (*res)[opp] = (*this)[s];
+      }
+    }
+  }
+  GDLInterpreter::IncRefObj( res);
+  return res_guard.release();
+}
 
 // rank must be 1 or 2 (already checked)
 template<class Sp> 
@@ -968,6 +1145,32 @@
   dd = right.dd;
   return *this;
 }
+template<>
+Data_<SpDPtr>& Data_<SpDPtr>::operator=(const BaseGDL& r)
+{
+  assert( r.Type() == this->Type());
+  const Data_& right = static_cast<const Data_&>( r);
+  assert( &right != this);
+  if( &right == this) return *this; // self assignment
+  this->dim = right.dim;
+  GDLInterpreter::DecRef( this);
+  dd = right.dd;
+  GDLInterpreter::IncRef( this);
+  return *this;
+}
+template<>
+Data_<SpDObj>& Data_<SpDObj>::operator=(const BaseGDL& r)
+{
+  assert( r.Type() == this->Type());
+  const Data_& right = static_cast<const Data_&>( r);
+  assert( &right != this);
+  if( &right == this) return *this; // self assignment
+  this->dim = right.dim;
+  GDLInterpreter::DecRefObj( this);
+  dd = right.dd;
+  GDLInterpreter::IncRefObj( this);
+  return *this;
+}
 
 template< class Sp>
 bool Data_<Sp>::EqType( const BaseGDL* r) const 
@@ -1010,84 +1213,104 @@
 void Data_<Sp>::Clear() 
 { 
 SizeT nEl = dd.size(); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
-#pragma omp for
+#pragma omp for*/
 for( SizeT i = 0; i<nEl; ++i) (*this)[ i] = Sp::zero;
-}}
+}//}
 
 // first time initialization (construction)
 template< class Sp>
 void Data_<Sp>::Construct() 
 {}
+template<>
+void Data_<SpDPtr>::Construct() 
+{
+SizeT nEl = dd.size(); 
+//  for( SizeT i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty;
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+{
+#pragma omp for*/
+  for( SizeT i = 0; i<nEl; ++i) dd[ i] = 0;
+}//}
+template<>
+void Data_<SpDObj>::Construct()
+{
+SizeT nEl = dd.size(); 
+//  for( SizeT i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty;
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+{
+#pragma omp for*/
+  for( SizeT i = 0; i<nEl; ++i) dd[ i] = 0;
+}//}
 // non POD - use placement new
 template<>
 void Data_< SpDString>::Construct() 
 { 
   SizeT nEl = dd.size(); 
 //  for( SizeT i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty;
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
-#pragma omp for
+#pragma omp for*/
   for( SizeT i = 0; i<nEl; ++i) new (&(dd[ i])) Ty;
-}}
+}//}
 template<>
 void Data_< SpDComplex>::Construct() 
 { 
   SizeT nEl = dd.size(); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
-#pragma omp for
+#pragma omp for*/
   for( SizeT i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty;
-}}
+}//}
 template<>
 void Data_< SpDComplexDbl>::Construct() 
 { 
   SizeT nEl = dd.size(); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
-#pragma omp for
+#pragma omp for*/
   for( SizeT i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty;
-}}
+}//}
 
 // construction and initalization to zero
 template< class Sp>
 void Data_<Sp>::ConstructTo0() 
 { 
 SizeT nEl = dd.size(); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
-#pragma omp for
+#pragma omp for*/
 for( SizeT i = 0; i<nEl; ++i) (*this)[ i] = Sp::zero;
-}}
+}//}
 // non POD - use placement new
 template<>
 void Data_< SpDString>::ConstructTo0() 
 { 
   SizeT nEl = dd.size(); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
-#pragma omp for
+#pragma omp for*/
   for( SizeT i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty( zero);
-}}
+}//}
 template<>
 void Data_< SpDComplex>::ConstructTo0() 
 { 
   SizeT nEl = dd.size(); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
-#pragma omp for
+#pragma omp for*/
   for( SizeT i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty( zero);
-}}
+}//}
 template<>
 void Data_< SpDComplexDbl>::ConstructTo0() 
 { 
   SizeT nEl = dd.size(); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
-#pragma omp for
+#pragma omp for*/
   for( SizeT i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty( zero);
-}}
+}//}
 
 template< class Sp>
 void Data_<Sp>::Destruct() 
@@ -1095,35 +1318,45 @@
   // no destruction for POD
 }
 template<>
+void Data_< SpDPtr>::Destruct()
+{
+	GDLInterpreter::DecRef( this);
+}
+template<>
+void Data_< SpDObj>::Destruct()
+{
+	GDLInterpreter::DecRefObj( this);
+}
+template<>
 void Data_< SpDString>::Destruct() 
 {
   SizeT nEl = dd.size(); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
-#pragma omp for
+#pragma omp for*/
   for( SizeT i = 0; i<nEl; ++i) 
     (*this)[ i].~DString();
-}}
+}//}
 template<>
 void Data_< SpDComplex>::Destruct() 
 {
   SizeT nEl = dd.size(); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
-#pragma omp for
+#pragma omp for*/
   for( SizeT i = 0; i<nEl; ++i) 
     (*this)[ i].~DComplex();
-}}
+}//}
 template<>
 void Data_< SpDComplexDbl>::Destruct() 
 {
   SizeT nEl = dd.size(); 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
-#pragma omp for
+#pragma omp for*/
   for( SizeT i = 0; i<nEl; ++i) 
     (*this)[ i].~DComplexDbl();
-}}
+}//}
 
 template< class Sp>
 BaseGDL* Data_<Sp>::SetBuffer( const void* b)
@@ -1149,11 +1382,12 @@
     {
       Data_* res =  new Data_(dim_, BaseGDL::NOZERO);
       SizeT nEl = res->dd.size();
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
-#pragma omp for
+#pragma omp for*/
       for( SizeT i=0; i<nEl; ++i) (*res)[ i] = (*this)[ 0]; // set all to scalar
-}      return res;
+//}
+      return res;
     }
   return new Data_(dim_);
 }
@@ -1183,12 +1417,12 @@
 {
   SizeT nEl = dd.size();
   SizeT nB = 0;
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
-#pragma omp for
+#pragma omp for*/
   for( SizeT i=0; i<nEl; ++i)
     nB += (*this)[i].size();
-}
+//}
   return nB;
 }
 // template<> SizeT Data_<SpDObj>::NBytes() const
@@ -1275,6 +1509,16 @@
   return 1;
 }
 
+template<class Sp> 
+int Data_<Sp>::Scalar2RangeT( RangeT& st) const
+{
+  if( dd.size() != 1) return 0;
+
+  st= static_cast<RangeT>((*this)[0]);
+  if( this->dim.Rank() != 0) return 2;
+  return 1;
+}
+
 template<> 
 int Data_<SpDComplex>::Scalar2index( SizeT& st) const
 {
@@ -1285,7 +1529,18 @@
   if( this->dim.Rank() != 0) return 2;
   return 1;
 }
+
 template<> 
+int Data_<SpDComplex>::Scalar2RangeT( RangeT& st) const
+{
+  if( dd.size() != 1) return 0;
+  float r=real((*this)[0]);
+  st= static_cast<RangeT>(r);
+  if( this->dim.Rank() != 0) return 2;
+  return 1;
+}
+
+template<>
 int Data_<SpDComplexDbl>::Scalar2index( SizeT& st) const
 {
   if( dd.size() != 1) return 0;
@@ -1295,6 +1550,18 @@
   if( this->dim.Rank() != 0) return 2;
   return 1;
 }
+
+template<> 
+int Data_<SpDComplexDbl>::Scalar2RangeT( RangeT& st) const
+{
+  if( dd.size() != 1) return 0;
+  double r=real((*this)[0]);
+  st= static_cast<RangeT>(r);
+  if( this->dim.Rank() != 0) return 2;
+  return 1;
+}
+
+
 template<> 
 int Data_<SpDString>::Scalar2index( SizeT& st) const
 {
@@ -1316,11 +1583,36 @@
   return 1;
 }
 
+template<> 
+int Data_<SpDString>::Scalar2RangeT( RangeT& st) const
+{
+  if( dd.size() != 1) return 0;
+
+  SizeT tSize=(*this)[0].size();
+
+  if( tSize == 0) 
+    {
+      st=0;
+    }
+  else 
+    {
+      long int number = Str2L( (*this)[0].c_str());
+      st=number;
+    }
+  if( dim.Rank() != 0) return 2;
+  return 1;
+}
+
 int DStructGDL::Scalar2index( SizeT& st) const
 {
   throw GDLException("STRUCT expression not allowed in this context.");
   return 0; // get rid of warning
 }
+int DStructGDL::Scalar2RangeT( RangeT& st) const
+{
+  throw GDLException("STRUCT expression not allowed in this context.");
+  return 0; // get rid of warning
+}
 
 template<> 
 int Data_<SpDPtr>::Scalar2index( SizeT& st) const
@@ -1328,6 +1620,12 @@
   throw GDLException("PTR expression not allowed in this context.");
   return 0; // get rid of warning
 }
+template<> 
+int Data_<SpDPtr>::Scalar2RangeT( RangeT& st) const
+{
+  throw GDLException("PTR expression not allowed in this context.");
+  return 0; // get rid of warning
+}
 
 template<> 
 int Data_<SpDObj>::Scalar2index( SizeT& st) const
@@ -1335,6 +1633,12 @@
   throw GDLException("Object expression not allowed in this context.");
   return 0; // get rid of warning
 }
+template<> 
+int Data_<SpDObj>::Scalar2RangeT( RangeT& st) const
+{
+  throw GDLException("Object expression not allowed in this context.");
+  return 0; // get rid of warning
+}
 
 // for FOR loop *indices*
 template<class Sp> 
@@ -1392,8 +1696,20 @@
 template<> 
 SizeT Data_<SpDString>::LoopIndex() const
 {
-  throw GDLException( "String expression not allowed as index.");
-  return 0;
+	if( (*this)[0] == "")
+		return 0;
+	
+    const char* cStart=(*this)[0].c_str();
+    char* cEnd;
+    SizeT ix=strtol(cStart,&cEnd,10);
+    if( cEnd == cStart)
+		{
+		Warning( "Type conversion error: "
+				       "Unable to convert given STRING: '"+
+				       (*this)[0]+"' to index.");
+      	return 0;
+      	}
+  return ix;
 }
 // SizeT DStructGDL::LoopIndex() const
 // {
@@ -1542,7 +1858,7 @@
 
 // Equal (deletes r)
 template<class Sp>
-bool Data_<Sp>::Equal( BaseGDL* r)
+bool Data_<Sp>::Equal( BaseGDL* r) const
 {
   if( !r->Scalar())
     {
@@ -1555,13 +1871,42 @@
   return ret;
 }
 
-bool DStructGDL::Equal( BaseGDL* r)
+// Equal (deletes r)
+template<class Sp>
+bool Data_<Sp>::EqualNoDelete( const BaseGDL* r) const
+{
+  if( !r->Scalar())
+    {
+      throw GDLException("Expression must be a scalar in this context.");
+    }
+  bool ret;
+  if( r->Type() != this->t)
+  {
+  const Data_* rr=static_cast<const Data_*>(const_cast<BaseGDL*>(r)->Convert2( this->t, BaseGDL::COPY));
+  ret= ((*this)[0] == (*rr)[0]);
+  delete rr;
+	}
+else
+{
+  const Data_* rr=static_cast<const Data_*>(r);
+  ret= ((*this)[0] == (*rr)[0]);
+}
+  return ret;
+}
+
+bool DStructGDL::Equal( BaseGDL* r) const
 {
   delete r;
   throw GDLException("Struct expression not allowed in this context.");
   return false;
 }
 
+bool DStructGDL::EqualNoDelete( const BaseGDL* r) const
+{
+  throw GDLException("Struct expression not allowed in this context.");
+  return false;
+}
+
 // For array_equal r must be of same type
 template<class Sp>
 bool Data_<Sp>::ArrayEqual( BaseGDL* rIn)
@@ -1633,22 +1978,43 @@
 
 // ForCheck must have been called before
 template<class Sp>
-bool Data_<Sp>::ForCondUp( BaseGDL* lEndIn)
+bool Data_<Sp>::ForAddCondUp( BaseGDL* endLoopVar)
+// bool Data_<Sp>::ForAddCondUp( ForLoopInfoT& loopInfo)
 {
+  (*this)[0] += 1;
 //   Data_* lEnd=static_cast<Data_*>(lEndIn);
-  Data_* lEnd=dynamic_cast<Data_*>(lEndIn);
-  if( lEnd == NULL)
+  if( endLoopVar->Type() != this->t)
     throw GDLException("Type of FOR index variable changed.");
+  Data_* lEnd=static_cast<Data_*>(endLoopVar);
+/*  Data_* lEnd=dynamic_cast<Data_*>(endLoopVar);
+  if( lEnd == NULL)
+    throw GDLException("Type of FOR index variable changed.");*/
   return (*this)[0] <= (*lEnd)[0]; 
 }
+// ForCheck must have been called before
 template<class Sp>
-bool Data_<Sp>::ForCondDown( BaseGDL* lEndIn)
+bool Data_<Sp>::ForCondUp( BaseGDL* lEndIn)
 {
 //   Data_* lEnd=static_cast<Data_*>(lEndIn);
-  Data_* lEnd=dynamic_cast<Data_*>(lEndIn);
+  if( lEndIn->Type() != this->t)
+    throw GDLException("Type of FOR index variable changed.");
+  Data_* lEnd=static_cast<Data_*>(lEndIn);
+/*  Data_* lEnd=dynamic_cast<Data_*>(lEndIn);
   if( lEnd == NULL)
+    throw GDLException("Type of FOR index variable changed.");*/
+  return (*this)[0] <= (*lEnd)[0];
+}
+template<class Sp>
+bool Data_<Sp>::ForCondDown( BaseGDL* lEndIn)
+{
+//   Data_* lEnd=static_cast<Data_*>(lEndIn);
+  if( lEndIn->Type() != this->t)
     throw GDLException("Type of FOR index variable changed.");
-  return (*this)[0] >= (*lEnd)[0]; 
+  Data_* lEnd=static_cast<Data_*>(lEndIn);
+/*  Data_* lEnd=dynamic_cast<Data_*>(lEndIn);
+  if( lEnd == NULL)
+    throw GDLException("Type of FOR index variable changed.");*/
+  return (*this)[0] >= (*lEnd)[0];
 }
 
 // error if the type of the loop variable changed
@@ -1668,12 +2034,28 @@
     throw GDLException("Type of FOR index variable changed to COMPLEX.");
     return false; 
 }
+
+template<>
+bool Data_<SpDComplex>::ForAddCondUp( BaseGDL* loopInfo)
+// bool Data_<SpDComplex>::ForAddCondUp( ForLoopInfoT& loopInfo)
+{ 
+    throw GDLException("Type of FOR index variable changed to COMPLEX.");
+    return false; 
+}
 template<>
 bool Data_<SpDComplex>::ForCondDown( BaseGDL*)
 { 
     throw GDLException("Type of FOR index variable changed to COMPLEX.");
     return false; 
 }
+
+template<>
+bool Data_<SpDComplexDbl>::ForAddCondUp( BaseGDL* loopInfo)
+// bool Data_<SpDComplexDbl>::ForAddCondUp( ForLoopInfoT& loopInfo)
+{ 
+    throw GDLException("Type of FOR index variable changed to DCOMPLEX.");
+    return false; 
+}
 template<>
 bool Data_<SpDComplexDbl>::ForCondUp( BaseGDL*)
 { 
@@ -1702,6 +2084,7 @@
 }
 // cannnot be called, just to make the compiler shut-up
 void DStructGDL::ForAdd( BaseGDL* addIn) {}
+
 // normal (+1) version
 template<class Sp>
 void Data_<Sp>::ForAdd()
@@ -1729,8 +2112,7 @@
 // used by DotAccessDescT::DoAssign
 //         GDLInterpreter::l_array_expr
 template<class Sp>
-void Data_<Sp>::AssignAt( BaseGDL* srcIn, ArrayIndexListT* ixList, 
-			  SizeT offset)
+void Data_<Sp>::AssignAt( BaseGDL* srcIn, ArrayIndexListT* ixList, SizeT offset)
 {
   //  breakpoint(); // gdbg can not handle breakpoints in template functions
   Data_* src = static_cast<Data_*>(srcIn);  
@@ -1746,25 +2128,25 @@
 	{
 	  SizeT nCp=Data_::N_Elements();
 
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
 	  for( SizeT c=0; c<nCp; ++c)
 	    (*this)[ c]=scalar;
-}
+// }
 	}
       else
 	{
 	  SizeT nCp=ixList->N_Elements();
 	  
 	  AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
 	  for( SizeT c=0; c<nCp; ++c)
 	    (*this)[ (*allIx)[ c]]=scalar;
-}	  //	    (*this)[ ixList->GetIx( c)]=scalar;
-	}
+//}	  //	    (*this)[ ixList->GetIx( c)]=scalar;
+ 	}
     }
   else
     {
@@ -1779,12 +2161,12 @@
 	    else
 	      throw GDLException("Source expression contains not enough elements.");
 
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
 	  for( SizeT c=0; c<nCp; ++c)
 	    (*this)[ c]=(*src)[c+offset];
-}	}
+}//}
       else
 	{
  	  // crucial part
@@ -1808,12 +2190,12 @@
 				       " source expression.");
 		  
 		  AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
 		  for( SizeT c=0; c<nCp; ++c)
 		    (*this)[ (*allIx)[ c]]=(*src)[c];
-}		  //		(*this)[ ixList->GetIx( c)]=(*src)[c+offset];
+// }		  //		(*this)[ ixList->GetIx( c)]=(*src)[c+offset];
 		}
 	      else
 		{
@@ -1822,12 +2204,12 @@
 				       " source expression.");
 		  
 		  AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
 		  for( SizeT c=0; c<nCp; ++c)
 		    (*this)[ (*allIx)[ c]]=(*src)[c+offset];
-}		  //		(*this)[ ixList->GetIx( c)]=(*src)[c+offset];
+// }		  //		(*this)[ ixList->GetIx( c)]=(*src)[c+offset];
 		}
 	    }
 	}
@@ -1855,12 +2237,12 @@
 	{
 	  Ty scalar=(*src)[0];
 	  AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
 	  for( SizeT c=0; c<nCp; ++c)
 	    (*this)[ (*allIx)[ c]]=scalar;
-}	  //	    (*this)[ ixList->GetIx( c)]=scalar;
+// }	  //	    (*this)[ ixList->GetIx( c)]=scalar;
 	}
     }
   else
@@ -1879,12 +2261,12 @@
 			       " source expression.");
 	  
 	  AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
 	  for( SizeT c=0; c<nCp; ++c)
 	    (*this)[ (*allIx)[ c]]=(*src)[c];
-}	  //		(*this)[ ixList->GetIx( c)]=(*src)[c+offset];
+// }	  //		(*this)[ ixList->GetIx( c)]=(*src)[c+offset];
 	}
     }
 }
@@ -1904,12 +2286,12 @@
       SizeT nCp=Data_::N_Elements();
       
       
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
       for( SizeT c=0; c<nCp; ++c)
 	(*this)[ c]=scalar;
-}      
+// }      
       //       SizeT nCp=Data_::N_Elements();
 
       //       for( SizeT c=0; c<nCp; ++c)
@@ -1922,12 +2304,12 @@
       // if (non-indexed) src is smaller -> just copy its number of elements
       if( nCp > srcElem) nCp=srcElem;
       
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
       for( SizeT c=0; c<nCp; ++c)
 	(*this)[ c]=(*src)[c];
-}
+// }
     }
 }
 
@@ -1949,12 +2331,12 @@
       SizeT nCp=ixList->N_Elements();
 
       AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
       for( SizeT c=0; c<nCp; ++c)
 	(*this)[ (*allIx)[ c]]--;
-}    }
+}//    }
 }
 template<class Sp>
 void Data_<Sp>::IncAt( ArrayIndexListT* ixList) 
@@ -1972,12 +2354,12 @@
       SizeT nCp=ixList->N_Elements();
       
       AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
       for( SizeT c=0; c<nCp; ++c)
 	(*this)[ (*allIx)[ c]]++;
-}    }
+	}//    }
 }
 // float, double
 template<>
@@ -1997,12 +2379,12 @@
       SizeT nCp=ixList->N_Elements();
 
       AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
       for( SizeT c=0; c<nCp; ++c)
 	(*this)[ (*allIx)[ c]] -= 1.0;
-}    }
+}//    }
 }
 template<>
 void Data_<SpDFloat>::IncAt( ArrayIndexListT* ixList) 
@@ -2021,12 +2403,12 @@
       SizeT nCp=ixList->N_Elements();
       
       AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
       for( SizeT c=0; c<nCp; ++c)
 	(*this)[ (*allIx)[ c]] += 1.0;
-}    }
+}//    }
 }
 template<>
 void Data_<SpDDouble>::DecAt( ArrayIndexListT* ixList) 
@@ -2045,12 +2427,12 @@
       SizeT nCp=ixList->N_Elements();
       
       AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
       for( SizeT c=0; c<nCp; ++c)
 	(*this)[ (*allIx)[ c]] -= 1.0;
-}    }
+}//    }
 }
 template<>
 void Data_<SpDDouble>::IncAt( ArrayIndexListT* ixList) 
@@ -2069,12 +2451,12 @@
       SizeT nCp=ixList->N_Elements();
       
       AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
       for( SizeT c=0; c<nCp; ++c)
 	(*this)[ (*allIx)[ c]] += 1.0;
-}    }
+}//    }
 }
 // complex
 template<>
@@ -2086,23 +2468,23 @@
 
             SizeT nCp=Data_::N_Elements();
       
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
             for( SizeT c=0; c<nCp; ++c)
       	(*this)[ c] -= 1.0;
-}    }
+}//    }
   else
     {
       SizeT nCp=ixList->N_Elements();
       
       AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
       for( SizeT c=0; c<nCp; ++c)
 	(*this)[ (*allIx)[ c]] -= 1.0;
-}    }
+}//    }
 }
 template<>
 void Data_<SpDComplex>::IncAt( ArrayIndexListT* ixList) 
@@ -2113,23 +2495,23 @@
 
             SizeT nCp=Data_::N_Elements();
       
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
             for( SizeT c=0; c<nCp; ++c)
       	(*this)[ c] += 1.0;
-}    }
+}//    }
   else
     {
       SizeT nCp=ixList->N_Elements();
       
       AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
       for( SizeT c=0; c<nCp; ++c)
 	(*this)[ (*allIx)[ c]] += 1.0;
-}    }
+}//    }
 }
 template<>
 void Data_<SpDComplexDbl>::DecAt( ArrayIndexListT* ixList) 
@@ -2140,23 +2522,23 @@
 
             SizeT nCp=Data_::N_Elements();
       
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
             for( SizeT c=0; c<nCp; ++c)
       	(*this)[ c] -= 1.0;
-}    }
+}//    }
   else
     {
       SizeT nCp=ixList->N_Elements();
       
       AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
       for( SizeT c=0; c<nCp; ++c)
 	(*this)[ (*allIx)[ c]] -= 1.0;
-}    }
+} //   }
 }
 template<>
 void Data_<SpDComplexDbl>::IncAt( ArrayIndexListT* ixList) 
@@ -2167,23 +2549,23 @@
 
             SizeT nCp=Data_::N_Elements();
       
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
             for( SizeT c=0; c<nCp; ++c)
       	(*this)[ c] += 1.0;
-}    }
+}//    }
   else
     {
       SizeT nCp=ixList->N_Elements();
       
       AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
       for( SizeT c=0; c<nCp; ++c)
 	(*this)[ (*allIx)[ c]] += 1.0;
-}    }
+}//    }
 }
 // forbidden types
 template<>
@@ -2230,23 +2612,23 @@
     {
       SizeT nCp=src->N_Elements();
 
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
       for( SizeT c=0; c<nCp; ++c)
 	(*this)[ c+offset]=(*src)[c];
-}    }
+}//    }
   else
     {
       SizeT nCp=ixList->N_Elements();
 
       AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
       for( SizeT c=0; c<nCp; ++c)
 	(*this)[ c+offset]=(*src)[ (*allIx)[ c]];
-}      //	(*this)[ c+offset]=(*src)[ ixList->GetIx( c)];
+//}      //	(*this)[ c+offset]=(*src)[ ixList->GetIx( c)];
     }
 }
 
@@ -2320,12 +2702,12 @@
   
   //  DataT& res_dd = res->dd; 
   AllIxT* allIx = ixList->BuildIx();
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
   for( SizeT c=0; c<nCp; ++c)
     (*res)[c]=(*this)[ (*allIx)[ c]];
-}  //    res_(*this)[c]=(*this)[ (*allIx)[ c]];
+//}  //    res_(*this)[c]=(*this)[ (*allIx)[ c]];
   //    (*res)[c]=(*this)[ ixList->GetIx(c)];
   
   return res;
@@ -2447,6 +2829,7 @@
 	  }
     }
 }
+
   
 // used for concatenation, called from CatArray
 // assumes that everything is checked (see CatInfo)
@@ -2466,22 +2849,22 @@
   // number of elements to skip
   SizeT gap=this->dim.Stride(atDim+1);    // dest array
 
-#ifdef _OPENMP
-SizeT nEl = srcArr->N_Elements();
-#pragma omp parallel for if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-  for( SizeT c=0; c<nCp; ++c)
-    {
-      // set new destination pointer
-      SizeT eIx = c*gap;
-      SizeT sIx = eIx  + destStart;
-      eIx += destEnd;
-
-      // copy one segment
-      SizeT srcIx = c*len;
-      for( SizeT destIx=sIx; destIx< eIx; ++destIx)
-	(*this)[destIx] = (*srcArr)[ srcIx+destIx-sIx];
-    }
-#else
+// #ifdef _OPENMP
+// SizeT nEl = srcArr->N_Elements();
+// #pragma omp parallel for if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+//   for( SizeT c=0; c<nCp; ++c)
+//     {
+//       set new destination pointer
+//       SizeT eIx = c*gap;
+//       SizeT sIx = eIx  + destStart;
+//       eIx += destEnd;
+// 
+//       copy one segment
+//       SizeT srcIx = c*len;
+//       for( SizeT destIx=sIx; destIx< eIx; ++destIx)
+// 	(*this)[destIx] = (*srcArr)[ srcIx+destIx-sIx];
+//     }
+// #else
   SizeT srcIx=0;
   for( SizeT c=0; c<nCp; ++c)
     {
@@ -2493,7 +2876,7 @@
       destStart += gap;
       destEnd   += gap;
     }
-#endif
+// #endif
 
   SizeT add=srcArr->dim[atDim]; // update 'at'
   at += (add > 1)? add : 1;
@@ -3471,12 +3854,12 @@
 	      }
       
 	  SizeT resEl = res->N_Elements();
-#pragma omp parallel if (resEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= resEl))
+/*#pragma omp parallel if (resEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= resEl))
 {
-#pragma omp for
+#pragma omp for*/
 	  for( SizeT r=0; r < resEl; ++r)
 	    (*res)[ r] /= ratio;
-}
+// }
 	  return res;
 	}
     }
@@ -3948,15 +4331,19 @@
       srcTGuard.reset( srcT);
     }
 
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
-#pragma omp for
+#pragma omp for*/
   for(long k=0; k < nEl; ++k)
     {
       (*this)[ k] = (*srcT)[ k];
-}    }
+}//    }
 }
 
+
+
+
+
 // return a new type of itself (only for one dimensional case)
 template<class Sp>
 Data_<Sp>* Data_<Sp>::NewIx( SizeT ix)
@@ -3968,12 +4355,12 @@
 {
   SizeT nCp = ix->size();
   Data_* res=Data_::New( *dIn, BaseGDL::NOZERO);
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
   for( SizeT c=0; c<nCp; ++c)
     (*res)[c]=(*this)[ (*ix)[ c]];
-}
+// }
   return res;
 }
 template<class Sp>
@@ -3981,12 +4368,12 @@
 {
   SizeT nCp = dd.size() - s;
   Data_* res=Data_::New( dimension( nCp), BaseGDL::NOZERO);
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
   for( SizeT c=0; c<nCp; ++c)
     (*res)[c]=(*this)[ s+c];
-}
+// }
   return res;
 }
 template<class Sp>
@@ -3994,12 +4381,12 @@
 {
   SizeT nCp = e - s + 1;
   Data_* res=Data_::New( dimension( nCp), BaseGDL::NOZERO);
-#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+/*#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
 {
-#pragma omp for
+#pragma omp for*/
   for( SizeT c=0; c<nCp; ++c)
     (*res)[c]=(*this)[ s+c];
-}
+// }
   return res;
 }
 template<class Sp>
@@ -4021,6 +4408,8 @@
   return res;
 }
 
+#undef NEWIX_SIGNEDINT
+#undef NEWIX_UNSIGNEDINT
 #define NEWIX_UNSIGNEDINT \
 SizeT i = 0;\
 for( ; i < nElem; ++i)\
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/datatypes.hpp cvs/gdl/src/datatypes.hpp
--- gdl-0.9rc4/src/datatypes.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/datatypes.hpp	2010-05-21 10:23:55.525968552 -0600
@@ -86,7 +86,7 @@
     Sp( dim_), dd( dd_) {}
 
   // c-i 
-  Data_(const Data_& d_): Sp(d_.dim), dd(d_.dd) {}
+  Data_(const Data_& d_);//: Sp(d_.dim), dd(d_.dd) {}
 
   // operators
   // assignment. 
@@ -151,10 +151,11 @@
  
   // used by the interpreter
   int Scalar2index( SizeT& st) const;
-  SizeT LoopIndex() const; 
+  int Scalar2RangeT( RangeT& st) const;
+  SizeT LoopIndex() const;
   
   // make a duplicate on the heap
-  Data_* Dup() const { return new Data_(*this);}
+  Data_* Dup() const;
 //   // make a duplicate at loc
 //   Data_* Dup( void* loc) const { return ::new ( loc) Data_(*this);}
 
@@ -208,11 +209,14 @@
   DLong* Where( bool comp, SizeT& count);
   Data_<SpDByte>* LogNeg();
   int  Sgn(); // returns -1,0,1
-  bool Equal( BaseGDL*);
+  bool Equal( BaseGDL*) const;
+  bool EqualNoDelete( const BaseGDL*) const;
   bool ArrayEqual( BaseGDL*);
   void ForCheck( BaseGDL**, BaseGDL** =NULL);
   bool ForCondUp( BaseGDL*);
   bool ForCondDown( BaseGDL*);
+  bool ForAddCondUp( BaseGDL* loopInfo);
+//   bool ForAddCondUp( ForLoopInfoT& loopInfo);
   //  bool ForCondUpDown( BaseGDL*);
   void ForAdd();
   void ForAdd( BaseGDL* add);
@@ -253,7 +257,7 @@
   Data_*   PowInv( BaseGDL* r);
   Data_*   PowInt( BaseGDL* r);      
   Data_*   PowIntNew( BaseGDL* r);   
-  Data_*   MatrixOp( BaseGDL* r);
+  Data_*   MatrixOp( BaseGDL* r, bool transpose, bool transposeResult, bool strassen);
 
   Data_*   AndOpS( BaseGDL* r);
   Data_*   AndOpInvS( BaseGDL* r);
@@ -367,6 +371,9 @@
   void CatInsert( const Data_* srcArr, const SizeT atDim, SizeT& at);
 };
 
+// template<> Data_<SpDPtr>::Data_(const Ty& d_);
+// template<> Data_<SpDObj>::Data_(const Ty& d_);
+
 #include "specializations.hpp"
 
 typedef Data_<SpDByte>       DByteGDL;
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/datatypesref.cpp cvs/gdl/src/datatypesref.cpp
--- gdl-0.9rc4/src/datatypesref.cpp	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/datatypesref.cpp	2010-03-31 12:59:33.000000000 -0600
@@ -0,0 +1,1906 @@
+/**************************************************************************
+                          datatypesref.cpp  -  specializations for DPtrGDL and DObjGDL for reference counting
+                             -------------------
+    begin                : March 08 2010
+    copyright            : (C) 2010 by Marc Schellens
+    email                : m_schellens@users.sf.net
+ ***************************************************************************/
+
+/* *************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+// to be included from datatypes.cpp
+#ifdef INCLUDE_DATATYPESREF_CPP
+#undef INCLUDE_DATATYPESREF_CPP
+
+template<>
+void Data_<SpDPtr>::InsAt( Data_* srcIn, ArrayIndexListT* ixList, SizeT offset)
+{
+// max. number of dimensions to copy
+SizeT nDim = ixList->NDim();
+
+if( nDim == 1)
+	{
+	SizeT destStart = ixList->LongIx();
+
+	//SizeT len;
+	if( this->N_Elements() == 1)
+	{
+	//	  len = 1;
+	SizeT rStride = srcIn->Stride(this->Rank());
+	Ty& a = (*this)[ destStart];
+	Ty b = (*srcIn)[ offset/rStride];
+	GDLInterpreter::IncRef( b);
+	GDLInterpreter::DecRef( a);
+	a = b;//(*this)[ destStart] = (*srcIn)[ offset/rStride];
+	}
+	else
+	{
+	SizeT len = srcIn->Dim( 0); // length of segment to copy
+		// TODO: IDL reports here (and probably in the insert-dimension case below as well)
+		//       the name of a variable, e.g.:
+		//       IDL> a=[0,0,0] & a[2]=[2,2,2]
+		//       % Out of range subscript encountered: A.
+	if( (destStart+len) > this->N_Elements()) //dim[0])
+		throw GDLException("Out of range subscript encountered (lenght of insert exceeds array boundaries).");
+
+	// DataT& srcIn_dd = srcIn->dd;
+	SizeT srcIx = 0; // this one simply runs from 0 to N_Elements(srcIn)
+
+	SizeT destEnd = destStart + len;
+	for( SizeT destIx = destStart; destIx < destEnd; ++destIx)
+{
+	Ty& a = (*this)[ destIx];
+	Ty b = (*srcIn)[ srcIx++];
+	GDLInterpreter::IncRef( b);
+	GDLInterpreter::DecRef( a);
+
+	a = b;//	(*this)[ destIx] = (*srcIn)[ srcIx++];
+}
+	}
+
+	return;
+	}
+
+SizeT destStart; // 1-dim starting index
+// ATTENTION: dimension is used as an index here
+dimension ixDim = ixList->GetDimIx0( destStart);
+nDim--;
+
+dimension srcDim=srcIn->Dim();
+SizeT len=srcDim[0]; // length of one segment to copy (one line of srcIn)
+
+//  SizeT nDim   =RankIx(ixDim.Rank());
+SizeT srcNDim=RankIx(srcDim.Rank()); // number of source dimensions
+if( srcNDim < nDim) nDim=srcNDim;
+
+// check limits (up to Rank to consider)
+for( SizeT dIx=0; dIx <= nDim; ++dIx)
+	// check if in bounds of a
+	if( (ixDim[dIx]+srcDim[dIx]) > this->dim[dIx])
+	throw GDLException("Out of range subscript encountered (dimension of insert exceeds array boundaries for dimension " + i2s(dIx +1) + ").");
+
+SizeT nCp=srcIn->Stride(nDim+1)/len; // number of OVERALL copy actions
+
+// as lines are copied, we need the stride from 2nd dim on
+SizeT retStride[MAXRANK];
+for( SizeT a=0; a <= nDim; ++a) retStride[a]=srcDim.Stride(a+1)/len;
+	
+// a magic number, to reset destStart for this dimension
+SizeT resetStep[MAXRANK];
+for( SizeT a=1; a <= nDim; ++a)
+	resetStep[a]=(retStride[a]-1)/retStride[a-1]*this->dim.Stride(a);
+	
+//  SizeT destStart=this->dim.LongIndex(ixDim); // starting pos
+
+// DataT& srcIn_dd = srcIn->dd;
+
+SizeT srcIx=0; // this one simply runs from 0 to N_Elements(srcIn)
+for( SizeT c=1; c<=nCp; ++c) // linearized verison of nested loops
+	{
+	// copy one segment
+	SizeT destEnd=destStart+len;
+	for( SizeT destIx=destStart; destIx<destEnd; ++destIx)
+{
+	Ty& a = (*this)[ destIx];
+	Ty b = (*srcIn)[ srcIx++];
+	GDLInterpreter::IncRef( b);
+	GDLInterpreter::DecRef( a);
+	a = b;//(*this)[destIx] = (*srcIn)[ srcIx++];
+}
+
+	// update destStart for all dimensions
+	if( c < nCp)
+	for( SizeT a=1; a<=nDim; ++a)
+	{
+		if( c % retStride[a])
+		{
+		// advance to next
+		destStart += this->dim.Stride(a);
+		break;
+		}
+		else
+		{
+		// reset
+		destStart -= resetStep[a];
+		}
+	}
+	}
+}
+
+template<>
+void Data_<SpDObj>::InsAt( Data_* srcIn, ArrayIndexListT* ixList, SizeT offset)
+{
+// max. number of dimensions to copy
+SizeT nDim = ixList->NDim();
+
+if( nDim == 1)
+	{
+	SizeT destStart = ixList->LongIx();
+
+	//SizeT len;
+	if( this->N_Elements() == 1)
+	{
+	//	  len = 1;
+	SizeT rStride = srcIn->Stride(this->Rank());
+	Ty& a = (*this)[ destStart];
+	Ty b = (*srcIn)[ offset/rStride];
+	GDLInterpreter::IncRefObj( b);
+	GDLInterpreter::DecRefObj( a);
+	a = b;//(*this)[ destStart] = (*srcIn)[ offset/rStride];
+	}
+	else
+	{
+	SizeT len = srcIn->Dim( 0); // length of segment to copy
+		// TODO: IDL reports here (and probably in the insert-dimension case below as well)
+		//       the name of a variable, e.g.:
+		//       IDL> a=[0,0,0] & a[2]=[2,2,2]
+		//       % Out of range subscript encountered: A.
+	if( (destStart+len) > this->N_Elements()) //dim[0])
+		throw GDLException("Out of range subscript encountered (lenght of insert exceeds array boundaries).");
+
+	// DataT& srcIn_dd = srcIn->dd;
+	SizeT srcIx = 0; // this one simply runs from 0 to N_Elements(srcIn)
+
+	SizeT destEnd = destStart + len;
+	for( SizeT destIx = destStart; destIx < destEnd; ++destIx)
+{
+	Ty& a = (*this)[ destIx];
+	Ty b = (*srcIn)[ srcIx++];
+	GDLInterpreter::IncRefObj( b);
+	GDLInterpreter::DecRefObj( a);
+
+	a = b;//	(*this)[ destIx] = (*srcIn)[ srcIx++];
+}
+	}
+
+	return;
+	}
+
+SizeT destStart; // 1-dim starting index
+// ATTENTION: dimension is used as an index here
+dimension ixDim = ixList->GetDimIx0( destStart);
+nDim--;
+
+dimension srcDim=srcIn->Dim();
+SizeT len=srcDim[0]; // length of one segment to copy (one line of srcIn)
+
+//  SizeT nDim   =RankIx(ixDim.Rank());
+SizeT srcNDim=RankIx(srcDim.Rank()); // number of source dimensions
+if( srcNDim < nDim) nDim=srcNDim;
+
+// check limits (up to Rank to consider)
+for( SizeT dIx=0; dIx <= nDim; ++dIx)
+	// check if in bounds of a
+	if( (ixDim[dIx]+srcDim[dIx]) > this->dim[dIx])
+	throw GDLException("Out of range subscript encountered (dimension of insert exceeds array boundaries for dimension " + i2s(dIx +1) + ").");
+
+SizeT nCp=srcIn->Stride(nDim+1)/len; // number of OVERALL copy actions
+
+// as lines are copied, we need the stride from 2nd dim on
+SizeT retStride[MAXRANK];
+for( SizeT a=0; a <= nDim; ++a) retStride[a]=srcDim.Stride(a+1)/len;
+	
+// a magic number, to reset destStart for this dimension
+SizeT resetStep[MAXRANK];
+for( SizeT a=1; a <= nDim; ++a)
+	resetStep[a]=(retStride[a]-1)/retStride[a-1]*this->dim.Stride(a);
+	
+//  SizeT destStart=this->dim.LongIndex(ixDim); // starting pos
+
+// DataT& srcIn_dd = srcIn->dd;
+
+SizeT srcIx=0; // this one simply runs from 0 to N_Elements(srcIn)
+for( SizeT c=1; c<=nCp; ++c) // linearized verison of nested loops
+	{
+	// copy one segment
+	SizeT destEnd=destStart+len;
+	for( SizeT destIx=destStart; destIx<destEnd; ++destIx)
+{
+	Ty& a = (*this)[ destIx];
+	Ty b = (*srcIn)[ srcIx++];
+	GDLInterpreter::IncRefObj( b);
+	GDLInterpreter::DecRefObj( a);
+	a = b;//(*this)[destIx] = (*srcIn)[ srcIx++];
+}
+
+	// update destStart for all dimensions
+	if( c < nCp)
+	for( SizeT a=1; a<=nDim; ++a)
+	{
+		if( c % retStride[a])
+		{
+		// advance to next
+		destStart += this->dim.Stride(a);
+		break;
+		}
+		else
+		{
+		// reset
+		destStart -= resetStep[a];
+		}
+	}
+	}
+}
+
+
+
+template<>
+void Data_<SpDPtr>::AssignAtIx( SizeT ix, BaseGDL* srcIn)
+{
+  if( srcIn->Type() != this->Type())
+		throw GDLException("Only expressions of type " + srcIn->TypeStr() + " can be assigned to " + this->TypeStr());
+  GDLInterpreter::IncRef( (*static_cast<Data_*>(srcIn))[0]);
+  GDLInterpreter::DecRef( (*this)[ix]);
+  (*this)[ix] = (*static_cast<Data_*>(srcIn))[0];
+}
+template<>
+void Data_<SpDObj>::AssignAtIx( SizeT ix, BaseGDL* srcIn)
+{
+  if( srcIn->Type() != this->Type())
+		throw GDLException("Only expressions of type " + srcIn->TypeStr() + " can be assigned to " + this->TypeStr());
+  GDLInterpreter::IncRefObj( (*static_cast<Data_*>(srcIn))[0]);
+  GDLInterpreter::DecRefObj( (*this)[ix]);
+  (*this)[ix] = (*static_cast<Data_*>(srcIn))[0];
+}
+
+
+
+
+
+
+
+
+
+
+template<>
+void Data_<SpDPtr>::AssignAt( BaseGDL* srcIn, ArrayIndexListT* ixList, SizeT offset)
+{
+  //  breakpoint(); // gdbg can not handle breakpoints in template functions
+  Data_* src = static_cast<Data_*>(srcIn);  
+
+  SizeT srcElem= src->N_Elements();
+  //  bool  isScalar= (srcElem == 1);
+  bool  isScalar= (srcElem == 1) && (src->Rank() == 0);
+  if( isScalar) 
+    { // src is scalar
+      Ty scalar=(*src)[0];
+      
+      if( ixList == NULL)
+	{
+	  SizeT nCp=Data_::N_Elements();
+
+	  GDLInterpreter::AddRef( scalar, nCp);
+
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	  for( SizeT c=0; c<nCp; ++c)
+	{
+	    GDLInterpreter::DecRef( (*this)[ c]);
+	    (*this)[ c]=scalar;
+	}
+}
+	}
+      else
+	{
+	  SizeT nCp=ixList->N_Elements();
+	  
+	  AllIxT* allIx = ixList->BuildIx();
+	  
+	  GDLInterpreter::AddRef( scalar, nCp);
+
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	  for( SizeT c=0; c<nCp; ++c)
+		{
+			SizeT ix = (*allIx)[ c];
+			GDLInterpreter::DecRef( (*this)[ ix]);
+			(*this)[ ix]=scalar;
+		}
+}	  //	    (*this)[ ixList->GetIx( c)]=scalar;
+	}
+    }
+  else
+    {
+      if( ixList == NULL)
+	{
+	  SizeT nCp=Data_::N_Elements();
+	
+	  // if (non-indexed) src is smaller -> just copy its number of elements
+	  if( nCp > (srcElem-offset))
+	    if( offset == 0)
+	      nCp=srcElem;
+	    else
+	      throw GDLException("Source expression contains not enough elements.");
+
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	  for( SizeT c=0; c<nCp; ++c)
+		{
+	Ty& a = (*this)[ c];
+	Ty b = (*src)[c+offset];
+			GDLInterpreter::IncRef( b);
+			GDLInterpreter::DecRef( a);
+			a = b;//(*this)[ c]=(*src)[c+offset];
+		}
+}
+	}
+      else
+	{
+ 	  // crucial part
+	  SizeT nCp=ixList->N_Elements();
+
+	  if( nCp == 1)
+	    {
+		SizeT destStart = ixList->LongIx();
+		//  len = 1;
+		SizeT rStride = srcIn->Stride(this->Rank());
+		(*this)[ destStart] = (*src)[ offset/rStride];
+
+//	      InsAt( src, ixList, offset);
+	    }
+	  else
+	    {
+	      if( offset == 0)
+		{
+		  if( srcElem < nCp)
+		    throw GDLException("Array subscript must have same size as"
+				       " source expression.");
+		  
+		  AllIxT* allIx = ixList->BuildIx();
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+		  for( SizeT c=0; c<nCp; ++c)
+		{
+			Ty& a =  (*this)[ (*allIx)[ c]];
+			Ty b = (*src)[c];
+			GDLInterpreter::IncRef( b);
+			GDLInterpreter::DecRef( a);
+			a = b;//		    (*this)[ (*allIx)[ c]]=(*src)[c];
+		}
+}		  //		(*this)[ ixList->GetIx( c)]=(*src)[c+offset];
+		}
+	      else
+		{
+		  if( (srcElem-offset) < nCp)
+		    throw GDLException("Array subscript must have same size as"
+				       " source expression.");
+		  
+		  AllIxT* allIx = ixList->BuildIx();
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+		  for( SizeT c=0; c<nCp; ++c)
+		{
+			Ty& a =  (*this)[ (*allIx)[ c]];
+			Ty b = (*src)[c+offset];
+			GDLInterpreter::IncRef( b);
+			GDLInterpreter::DecRef( a);
+			a = b;//		    (*this)[ (*allIx)[ c]]=(*src)[c+offset];
+}
+}		  //		(*this)[ ixList->GetIx( c)]=(*src)[c+offset];
+		}
+	    }
+	}
+    }
+}
+
+template<>
+void Data_<SpDObj>::AssignAt( BaseGDL* srcIn, ArrayIndexListT* ixList, SizeT offset)
+{
+  //  breakpoint(); // gdbg can not handle breakpoints in template functions
+  Data_* src = static_cast<Data_*>(srcIn);  
+
+  SizeT srcElem= src->N_Elements();
+  //  bool  isScalar= (srcElem == 1);
+  bool  isScalar= (srcElem == 1) && (src->Rank() == 0);
+  if( isScalar) 
+    { // src is scalar
+      Ty scalar=(*src)[0];
+      
+      if( ixList == NULL)
+	{
+	  SizeT nCp=Data_::N_Elements();
+
+	  GDLInterpreter::AddRefObj( scalar, nCp);
+
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	  for( SizeT c=0; c<nCp; ++c)
+	{
+	    GDLInterpreter::DecRefObj( (*this)[ c]);
+	    (*this)[ c]=scalar;
+	}
+}
+	}
+      else
+	{
+	  SizeT nCp=ixList->N_Elements();
+	  
+	  AllIxT* allIx = ixList->BuildIx();
+	  
+	  GDLInterpreter::AddRefObj( scalar, nCp);
+
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	  for( SizeT c=0; c<nCp; ++c)
+		{
+			SizeT ix = (*allIx)[ c];
+			GDLInterpreter::DecRefObj( (*this)[ ix]);
+			(*this)[ ix]=scalar;
+		}
+}	  //	    (*this)[ ixList->GetIx( c)]=scalar;
+	}
+    }
+  else
+    {
+      if( ixList == NULL)
+	{
+	  SizeT nCp=Data_::N_Elements();
+	
+	  // if (non-indexed) src is smaller -> just copy its number of elements
+	  if( nCp > (srcElem-offset))
+	    if( offset == 0)
+	      nCp=srcElem;
+	    else
+	      throw GDLException("Source expression contains not enough elements.");
+
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	  for( SizeT c=0; c<nCp; ++c)
+		{
+	Ty& a = (*this)[ c];
+	Ty b = (*src)[c+offset];
+			GDLInterpreter::IncRefObj( b);
+			GDLInterpreter::DecRefObj( a);
+			a = b;//(*this)[ c]=(*src)[c+offset];
+		}
+}
+	}
+      else
+	{
+ 	  // crucial part
+	  SizeT nCp=ixList->N_Elements();
+
+	  if( nCp == 1)
+	    {
+		SizeT destStart = ixList->LongIx();
+		//  len = 1;
+		SizeT rStride = srcIn->Stride(this->Rank());
+		(*this)[ destStart] = (*src)[ offset/rStride];
+
+//	      InsAt( src, ixList, offset);
+	    }
+	  else
+	    {
+	      if( offset == 0)
+		{
+		  if( srcElem < nCp)
+		    throw GDLException("Array subscript must have same size as"
+				       " source expression.");
+		  
+		  AllIxT* allIx = ixList->BuildIx();
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+		  for( SizeT c=0; c<nCp; ++c)
+		{
+			Ty& a =  (*this)[ (*allIx)[ c]];
+			Ty b = (*src)[c];
+			GDLInterpreter::IncRefObj( b);
+			GDLInterpreter::DecRefObj( a);
+			a = b;//		    (*this)[ (*allIx)[ c]]=(*src)[c];
+		}
+}		  //		(*this)[ ixList->GetIx( c)]=(*src)[c+offset];
+		}
+	      else
+		{
+		  if( (srcElem-offset) < nCp)
+		    throw GDLException("Array subscript must have same size as"
+				       " source expression.");
+		  
+		  AllIxT* allIx = ixList->BuildIx();
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+		  for( SizeT c=0; c<nCp; ++c)
+		{
+			Ty& a =  (*this)[ (*allIx)[ c]];
+			Ty b = (*src)[c+offset];
+			GDLInterpreter::IncRefObj( b);
+			GDLInterpreter::DecRefObj( a);
+			a = b;//		    (*this)[ (*allIx)[ c]]=(*src)[c+offset];
+}
+}		  //		(*this)[ ixList->GetIx( c)]=(*src)[c+offset];
+		}
+	    }
+	}
+    }
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+template<>
+void Data_<SpDPtr>::AssignAt( BaseGDL* srcIn, ArrayIndexListT* ixList) 
+{
+assert( ixList != NULL);
+
+//  breakpoint(); // gdbg can not handle breakpoints in template functions
+Data_* src = static_cast<Data_*>(srcIn);
+
+SizeT srcElem= src->N_Elements();
+bool  isScalar= (srcElem == 1);
+if( isScalar)
+	{ // src is scalar
+	SizeT nCp=ixList->N_Elements();
+
+	if( nCp == 1)
+	{
+	Ty& a = (*this)[ ixList->LongIx()] ;
+	Ty b = (*src)[ 0];
+	GDLInterpreter::IncRef( b);
+	GDLInterpreter::DecRef( a);
+	a = b;//(*this)[ ixList->LongIx()] = (*src)[0];
+	}
+	else
+	{
+	Ty scalar=(*src)[0];
+	AllIxT* allIx = ixList->BuildIx();
+	
+	GDLInterpreter::AddRef( scalar, nCp);
+
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	for( SizeT c=0; c<nCp; ++c)
+	{
+	Ty& a = (*this)[ (*allIx)[ c]];
+// 	Ty b = scalar;
+	GDLInterpreter::DecRef( a);
+	a = scalar;//	(*this)[ (*allIx)[ c]]=scalar;
+	}
+}	  //	    (*this)[ ixList->GetIx( c)]=scalar;
+	}
+	}
+else
+	{
+	// crucial part
+	SizeT nCp=ixList->N_Elements();
+	
+	if( nCp == 1)
+	{
+	InsAt( src, ixList);
+	}
+	else
+	{
+	if( srcElem < nCp)
+		throw GDLException("Array subscript must have same size as"
+				" source expression.");
+
+	AllIxT* allIx = ixList->BuildIx();
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	for( SizeT c=0; c<nCp; ++c)
+	{
+	Ty& a = (*this)[ (*allIx)[ c]];
+	Ty b = (*src)[c];
+	GDLInterpreter::IncRef( b);
+	GDLInterpreter::DecRef( a);
+	a = b;//	(*this)[ (*allIx)[ c]]=(*src)[c];
+	}
+}	  //		(*this)[ ixList->GetIx( c)]=(*src)[c+offset];
+	}
+	}
+}
+template<>
+void Data_<SpDPtr>::AssignAt( BaseGDL* srcIn)
+{
+//  breakpoint(); // gdbg can not handle breakpoints in template functions
+Data_* src = static_cast<Data_*>(srcIn);
+
+SizeT srcElem= src->N_Elements();
+bool  isScalar= (srcElem == 1);
+if( isScalar)
+	{ // src is scalar
+	Ty scalar=(*src)[0];
+
+/*      dd = scalar;*/
+	SizeT nCp=Data_::N_Elements();
+	
+	GDLInterpreter::AddRef( scalar, nCp);
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	for( SizeT c=0; c<nCp; ++c)
+	{
+	Ty& a = (*this)[ c];
+	GDLInterpreter::DecRef( a);
+// 	GDLInterpreter::IncRef( b);
+	a = scalar;//(*this)[ c]=scalar;
+}
+}  
+	//       SizeT nCp=Data_::N_Elements();
+
+	//       for( SizeT c=0; c<nCp; ++c)
+	// 	(*this)[ c]=scalar;
+	}
+else
+	{
+	SizeT nCp=Data_::N_Elements();
+	
+	// if (non-indexed) src is smaller -> just copy its number of elements
+	if( nCp > srcElem) nCp=srcElem;
+	
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	for( SizeT c=0; c<nCp; ++c)
+	{
+	Ty& a = (*this)[ c];
+	Ty b = (*src)[c];
+	GDLInterpreter::IncRef( b);
+	GDLInterpreter::DecRef( a);
+	a = b;//(*this)[ c]=(*src)[c];
+	}
+}
+	}
+}
+
+
+template<>
+void Data_<SpDObj>::AssignAt( BaseGDL* srcIn, ArrayIndexListT* ixList)
+{
+assert( ixList != NULL);
+
+//  breakpoint(); // gdbg can not handle breakpoints in template functions
+Data_* src = static_cast<Data_*>(srcIn);
+
+SizeT srcElem= src->N_Elements();
+bool  isScalar= (srcElem == 1);
+if( isScalar)
+	{ // src is scalar
+	SizeT nCp=ixList->N_Elements();
+
+	if( nCp == 1)
+	{
+	Ty& a = (*this)[ ixList->LongIx()] ;
+	Ty b = (*src)[ 0];
+	GDLInterpreter::IncRefObj( b);
+	GDLInterpreter::DecRefObj( a);
+	a = b;//(*this)[ ixList->LongIx()] = (*src)[0];
+	}
+	else
+	{
+	Ty scalar=(*src)[0];
+	AllIxT* allIx = ixList->BuildIx();
+	
+	GDLInterpreter::AddRefObj( scalar, nCp);
+
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	for( SizeT c=0; c<nCp; ++c)
+	{
+	Ty& a = (*this)[ (*allIx)[ c]];
+	GDLInterpreter::DecRefObj( a);
+	a = scalar;//	(*this)[ (*allIx)[ c]]=scalar;
+	}
+}	  //	    (*this)[ ixList->GetIx( c)]=scalar;
+	}
+	}
+else
+	{
+	// crucial part
+	SizeT nCp=ixList->N_Elements();
+	
+	if( nCp == 1)
+	{
+	InsAt( src, ixList);
+	}
+	else
+	{
+	if( srcElem < nCp)
+		throw GDLException("Array subscript must have same size as"
+				" source expression.");
+
+	AllIxT* allIx = ixList->BuildIx();
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	for( SizeT c=0; c<nCp; ++c)
+	{
+	Ty& a = (*this)[ (*allIx)[ c]];
+	Ty b = (*src)[c];
+	GDLInterpreter::IncRefObj( b);
+	GDLInterpreter::DecRefObj( a);
+	a = b;//	(*this)[ (*allIx)[ c]]=(*src)[c];
+	}
+}	  //		(*this)[ ixList->GetIx( c)]=(*src)[c+offset];
+	}
+	}
+}
+template<>
+void Data_<SpDObj>::AssignAt( BaseGDL* srcIn)
+{
+//  breakpoint(); // gdbg can not handle breakpoints in template functions
+Data_* src = static_cast<Data_*>(srcIn);
+
+SizeT srcElem= src->N_Elements();
+bool  isScalar= (srcElem == 1);
+if( isScalar)
+	{ // src is scalar
+	Ty scalar=(*src)[0];
+
+/*      dd = scalar;*/
+	SizeT nCp=Data_::N_Elements();
+	
+	GDLInterpreter::AddRefObj( scalar, nCp);
+	
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	for( SizeT c=0; c<nCp; ++c)
+	{
+	Ty& a = (*this)[ c];
+	GDLInterpreter::DecRefObj( a);
+	a = scalar;//(*this)[ c]=scalar;
+}
+}
+
+	//       SizeT nCp=Data_::N_Elements();
+
+	//       for( SizeT c=0; c<nCp; ++c)
+	// 	(*this)[ c]=scalar;
+	}
+else
+	{
+	SizeT nCp=Data_::N_Elements();
+	
+	// if (non-indexed) src is smaller -> just copy its number of elements
+	if( nCp > srcElem) nCp=srcElem;
+	
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	for( SizeT c=0; c<nCp; ++c)
+	{
+	Ty& a = (*this)[ c];
+	Ty b = (*src)[c];
+	GDLInterpreter::IncRefObj( b);
+	GDLInterpreter::DecRefObj( a);
+	a = b;//(*this)[ c]=(*src)[c];
+	}
+}
+	}
+}
+
+
+
+// returns (*this)[ ixList]
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::Index( ArrayIndexListT* ixList)
+{
+//  ixList->SetVariable( this);
+
+Data_* res=Data_::New( ixList->GetDim(), BaseGDL::NOZERO);
+
+SizeT nCp=ixList->N_Elements();
+
+//  cout << "nCP = " << nCp << endl;
+//  cout << "dim = " << this->dim << endl;
+
+//  DataT& res_dd = res->dd;
+AllIxT* allIx = ixList->BuildIx();
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+for( SizeT c=0; c<nCp; ++c)
+	{
+		Ty a = (*this)[ (*allIx)[ c]];
+		GDLInterpreter::IncRef(a);
+		(*res)[c]=a;
+	}
+}  //    res_(*this)[c]=(*this)[ (*allIx)[ c]];
+//    (*res)[c]=(*this)[ ixList->GetIx(c)];
+
+return res;
+}
+// returns (*this)[ ixList]
+template<>
+Data_<SpDObj>* Data_<SpDObj>::Index( ArrayIndexListT* ixList)
+{
+//  ixList->SetVariable( this);
+
+Data_* res=Data_::New( ixList->GetDim(), BaseGDL::NOZERO);
+
+SizeT nCp=ixList->N_Elements();
+
+//  cout << "nCP = " << nCp << endl;
+//  cout << "dim = " << this->dim << endl;
+
+//  DataT& res_dd = res->dd;
+AllIxT* allIx = ixList->BuildIx();
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+for( SizeT c=0; c<nCp; ++c)
+	{
+		Ty a = (*this)[ (*allIx)[ c]];
+		GDLInterpreter::IncRefObj(a);
+		(*res)[c]=a;
+	}
+}  //    res_(*this)[c]=(*this)[ (*allIx)[ c]];
+//    (*res)[c]=(*this)[ ixList->GetIx(c)];
+
+return res;
+}
+
+
+
+// used by AccessDescT for resolving, no checking is done
+// inserts srcIn[ ixList] at offset
+// used by DotAccessDescT::DoResolve
+template<>
+void Data_<SpDPtr>::InsertAt( SizeT offset, BaseGDL* srcIn, 
+			ArrayIndexListT* ixList)
+{
+Data_* src=static_cast<Data_* >(srcIn);
+if( ixList == NULL)
+	{
+	SizeT nCp=src->N_Elements();
+
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	for( SizeT c=0; c<nCp; ++c)
+{
+	Ty a = (*this)[ c+offset];
+	Ty b = (*src)[c];
+	GDLInterpreter::IncRef( b);
+	GDLInterpreter::DecRef( a);
+	(*this)[ c+offset]=(*src)[c];
+}
+}    }
+else
+	{
+	SizeT nCp=ixList->N_Elements();
+
+	AllIxT* allIx = ixList->BuildIx();
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	for( SizeT c=0; c<nCp; ++c)
+{
+	Ty a = (*this)[ c+offset];
+	Ty b = (*src)[ (*allIx)[ c]];
+	GDLInterpreter::IncRef( b);
+	GDLInterpreter::DecRef( a);
+	(*this)[ c+offset]=(*src)[ (*allIx)[ c]];
+}      //	(*this)[ c+offset]=(*src)[ ixList->GetIx( c)];
+	}
+}
+}
+
+
+// used for concatenation, called from CatArray
+// assumes that everything is checked (see CatInfo)
+template<>
+void Data_<SpDPtr>::CatInsert( const Data_* srcArr, const SizeT atDim, SizeT& at)
+{
+// length of one segment to copy
+SizeT len=srcArr->dim.Stride(atDim+1); // src array
+
+// number of copy actions
+SizeT nCp=srcArr->N_Elements()/len;
+
+// initial offset
+SizeT destStart= this->dim.Stride(atDim) * at; // dest array
+SizeT destEnd  = destStart + len;
+
+// number of elements to skip
+SizeT gap=this->dim.Stride(atDim+1);    // dest array
+
+#ifdef _OPENMP
+SizeT nEl = srcArr->N_Elements();
+//#pragma omp parallel for if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+for( SizeT c=0; c<nCp; ++c)
+	{
+	// set new destination pointer
+	SizeT eIx = c*gap;
+	SizeT sIx = eIx  + destStart;
+	eIx += destEnd;
+
+	// copy one segment
+	SizeT srcIx = c*len;
+	for( SizeT destIx=sIx; destIx< eIx; ++destIx)
+{
+	Ty b = (*srcArr)[ srcIx+destIx-sIx];
+	GDLInterpreter::IncRef( b);
+	(*this)[destIx] = (*srcArr)[ srcIx+destIx-sIx];
+}
+	}
+#else
+SizeT srcIx=0;
+for( SizeT c=0; c<nCp; ++c)
+	{
+	// copy one segment
+	for( SizeT destIx=destStart; destIx< destEnd; destIx++)
+{
+	Ty b = (*srcArr)[ srcIx];
+	GDLInterpreter::IncRef( b);
+	(*this)[destIx] = (*srcArr)[ srcIx++];
+}
+
+	// set new destination pointer
+	destStart += gap;
+	destEnd   += gap;
+	}
+#endif
+
+SizeT add=srcArr->dim[atDim]; // update 'at'
+at += (add > 1)? add : 1;
+}
+
+
+
+// used by AccessDescT for resolving, no checking is done
+// inserts srcIn[ ixList] at offset
+// used by DotAccessDescT::DoResolve
+template<>
+void Data_<SpDObj>::InsertAt( SizeT offset, BaseGDL* srcIn,
+			ArrayIndexListT* ixList)
+{
+Data_* src=static_cast<Data_* >(srcIn);
+if( ixList == NULL)
+	{
+	SizeT nCp=src->N_Elements();
+
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	for( SizeT c=0; c<nCp; ++c)
+{
+	Ty a = (*this)[ c+offset];
+	Ty b = (*src)[c];
+	GDLInterpreter::IncRefObj( b);
+	GDLInterpreter::DecRefObj( a);
+	(*this)[ c+offset]=(*src)[c];
+}
+}    }
+else
+	{
+	SizeT nCp=ixList->N_Elements();
+
+	AllIxT* allIx = ixList->BuildIx();
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+	for( SizeT c=0; c<nCp; ++c)
+{
+	Ty a = (*this)[ c+offset];
+	Ty b = (*src)[ (*allIx)[ c]];
+	GDLInterpreter::IncRefObj( b);
+	GDLInterpreter::DecRefObj( a);
+	(*this)[ c+offset]=(*src)[ (*allIx)[ c]];
+}      //	(*this)[ c+offset]=(*src)[ ixList->GetIx( c)];
+	}
+}
+}
+
+
+// used for concatenation, called from CatArray
+// assumes that everything is checked (see CatInfo)
+template<>
+void Data_<SpDObj>::CatInsert( const Data_* srcArr, const SizeT atDim, SizeT& at)
+{
+// length of one segment to copy
+SizeT len=srcArr->dim.Stride(atDim+1); // src array
+
+// number of copy actions
+SizeT nCp=srcArr->N_Elements()/len;
+
+// initial offset
+SizeT destStart= this->dim.Stride(atDim) * at; // dest array
+SizeT destEnd  = destStart + len;
+
+// number of elements to skip
+SizeT gap=this->dim.Stride(atDim+1);    // dest array
+
+#ifdef _OPENMP
+SizeT nEl = srcArr->N_Elements();
+//#pragma omp parallel for if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+for( SizeT c=0; c<nCp; ++c)
+	{
+	// set new destination pointer
+	SizeT eIx = c*gap;
+	SizeT sIx = eIx  + destStart;
+	eIx += destEnd;
+
+	// copy one segment
+	SizeT srcIx = c*len;
+	for( SizeT destIx=sIx; destIx< eIx; ++destIx)
+{
+	Ty b = (*srcArr)[ srcIx+destIx-sIx];
+	GDLInterpreter::IncRefObj( b);
+	(*this)[destIx] = (*srcArr)[ srcIx+destIx-sIx];
+}
+	}
+#else
+SizeT srcIx=0;
+for( SizeT c=0; c<nCp; ++c)
+	{
+	// copy one segment
+	for( SizeT destIx=destStart; destIx< destEnd; destIx++)
+{
+	Ty b = (*srcArr)[ srcIx];
+	GDLInterpreter::IncRefObj( b);
+	(*this)[destIx] = (*srcArr)[ srcIx++];
+}
+
+	// set new destination pointer
+	destStart += gap;
+	destEnd   += gap;
+	}
+#endif
+
+SizeT add=srcArr->dim[atDim]; // update 'at'
+at += (add > 1)? add : 1;
+}
+
+
+
+template<>
+void Data_<SpDPtr>::Assign( BaseGDL* src, SizeT nEl)
+{
+Data_* srcT = dynamic_cast<Data_*>( src);
+
+auto_ptr< Data_> srcTGuard;
+if( srcT == NULL)
+	{
+	srcT = static_cast<Data_*>( src->Convert2( Data_::t, BaseGDL::COPY));
+	srcTGuard.reset( srcT);
+	}
+
+//#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+{
+//#pragma omp for
+for(long k=0; k < nEl; ++k)
+	{
+	Ty a = (*this)[ k];
+	Ty b = (*srcT)[k];
+	GDLInterpreter::IncRef( b);
+	GDLInterpreter::DecRef( a);
+		(*this)[ k] = (*srcT)[ k];
+}    }
+}
+
+template<>
+void Data_<SpDObj>::Assign( BaseGDL* src, SizeT nEl)
+{
+Data_* srcT = dynamic_cast<Data_*>( src);
+
+auto_ptr< Data_> srcTGuard;
+if( srcT == NULL)
+	{
+	srcT = static_cast<Data_*>( src->Convert2( Data_::t, BaseGDL::COPY));
+	srcTGuard.reset( srcT);
+	}
+
+//#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+{
+//#pragma omp for
+for(long k=0; k < nEl; ++k)
+	{
+	Ty a = (*this)[ k];
+	Ty b = (*srcT)[k];
+	GDLInterpreter::IncRefObj( b);
+	GDLInterpreter::DecRefObj( a);
+		(*this)[ k] = (*srcT)[ k];
+}    }
+}
+
+
+
+// return a new type of itself (only for one dimensional case)
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::NewIx( SizeT ix)
+{
+	Ty b = (*this)[ ix];
+	GDLInterpreter::IncRef( b);
+return new Data_( (*this)[ ix]);
+}
+
+// return a new type of itself (only for one dimensional case)
+template<>
+Data_<SpDObj>* Data_<SpDObj>::NewIx( SizeT ix)
+{
+	Ty b = (*this)[ ix];
+	GDLInterpreter::IncRefObj( b);
+return new Data_( (*this)[ ix]);
+}
+
+
+
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::NewIx( AllIxT* ix, dimension* dIn)
+{
+SizeT nCp = ix->size();
+Data_* res=Data_::New( *dIn, BaseGDL::NOZERO);
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+for( SizeT c=0; c<nCp; ++c)
+{
+	Ty b = (*this)[ (*ix)[ c]];
+	GDLInterpreter::IncRef( b);
+	(*res)[c]=(*this)[ (*ix)[ c]];
+}
+}
+return res;
+}
+template<>
+Data_<SpDObj>* Data_<SpDObj>::NewIx( AllIxT* ix, dimension* dIn)
+{
+SizeT nCp = ix->size();
+Data_* res=Data_::New( *dIn, BaseGDL::NOZERO);
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+for( SizeT c=0; c<nCp; ++c)
+{
+	Ty b = (*this)[ (*ix)[ c]];
+	GDLInterpreter::IncRefObj( b);
+	(*res)[c]=(*this)[ (*ix)[ c]];
+}
+}
+return res;
+}
+
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::NewIxFrom( SizeT s)
+{
+SizeT nCp = dd.size() - s;
+Data_* res=Data_::New( dimension( nCp), BaseGDL::NOZERO);
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+for( SizeT c=0; c<nCp; ++c)
+{
+	Ty b = (*this)[ s+c];
+	GDLInterpreter::IncRef( b);
+	(*res)[c]=(*this)[ s+c];
+}
+}
+return res;
+}
+template<>
+Data_<SpDObj>* Data_<SpDObj>::NewIxFrom( SizeT s)
+{
+SizeT nCp = dd.size() - s;
+Data_* res=Data_::New( dimension( nCp), BaseGDL::NOZERO);
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+for( SizeT c=0; c<nCp; ++c)
+{
+	Ty b = (*this)[ s+c];
+	GDLInterpreter::IncRefObj( b);
+	(*res)[c]=(*this)[ s+c];
+}
+}
+return res;
+}
+
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::NewIxFrom( SizeT s, SizeT e)
+{
+SizeT nCp = e - s + 1;
+Data_* res=Data_::New( dimension( nCp), BaseGDL::NOZERO);
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+for( SizeT c=0; c<nCp; ++c)
+{
+	Ty b = (*this)[ s+c];
+	GDLInterpreter::IncRef( b);
+	(*res)[c]=(*this)[ s+c];
+}
+}
+return res;
+}
+
+template<>
+Data_<SpDObj>* Data_<SpDObj>::NewIxFrom( SizeT s, SizeT e)
+{
+SizeT nCp = e - s + 1;
+Data_* res=Data_::New( dimension( nCp), BaseGDL::NOZERO);
+//#pragma omp parallel if (nCp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCp))
+{
+//#pragma omp for
+for( SizeT c=0; c<nCp; ++c)
+{
+	Ty b = (*this)[ s+c];
+	GDLInterpreter::IncRefObj( b);
+	(*res)[c]=(*this)[ s+c];
+}
+}
+return res;
+}
+
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::NewIxFromStride( SizeT s, SizeT stride)
+{
+SizeT nCp = (dd.size() - s + stride - 1)/stride;
+Data_* res=Data_::New( dimension( nCp), BaseGDL::NOZERO);
+for( SizeT c=0; c<nCp; ++c, s += stride)
+{
+	Ty b = (*this)[ s];
+	GDLInterpreter::IncRef( b);
+	(*res)[c]=(*this)[ s];
+}
+return res;
+}
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::NewIxFromStride( SizeT s, SizeT e, SizeT stride)
+{
+SizeT nCp = (e - s + stride)/stride;
+Data_* res=Data_::New( dimension( nCp), BaseGDL::NOZERO);
+for( SizeT c=0; c<nCp; ++c, s += stride)
+{
+	Ty b = (*this)[ s];
+	GDLInterpreter::IncRef( b);
+	(*res)[c]=(*this)[ s];
+}
+return res;
+}
+
+template<>
+Data_<SpDObj>* Data_<SpDObj>::NewIxFromStride( SizeT s, SizeT stride)
+{
+SizeT nCp = (dd.size() - s + stride - 1)/stride;
+Data_* res=Data_::New( dimension( nCp), BaseGDL::NOZERO);
+for( SizeT c=0; c<nCp; ++c, s += stride)
+{
+	Ty b = (*this)[ s];
+	GDLInterpreter::IncRefObj( b);
+	(*res)[c]=(*this)[ s];
+}
+return res;
+}
+template<>
+Data_<SpDObj>* Data_<SpDObj>::NewIxFromStride( SizeT s, SizeT e, SizeT stride)
+{
+SizeT nCp = (e - s + stride)/stride;
+Data_* res=Data_::New( dimension( nCp), BaseGDL::NOZERO);
+for( SizeT c=0; c<nCp; ++c, s += stride)
+{
+	Ty b = (*this)[ s];
+	GDLInterpreter::IncRefObj( b);
+	(*res)[c]=(*this)[ s];
+}
+return res;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#undef NEWIX_SIGNEDINT
+#undef NEWIX_UNSIGNEDINT
+#define NEWIX_UNSIGNEDINT \
+SizeT i = 0;\
+for( ; i < nElem; ++i)\
+  if( (*src)[i] > upper)\
+    {\
+      if( strict)\
+	throw GDLException("Array used to subscript array "\
+			   "contains out of range (>) subscript.");\
+      (*res)[i++]= upperVal;\
+      break;\
+    }\
+  else\
+    (*res)[i]= (*this)[ (*src)[i]];\
+for(; i < nElem; ++i)\
+  if( (*src)[i] > upper)\
+    (*res)[i] = upperVal;\
+  else\
+    (*res)[i]= (*this)[ (*src)[i]];\
+GDLInterpreter::IncRef( res);\
+return guard.release();
+
+#define NEWIX_SIGNEDINT \
+  SizeT i = 0;\
+for(; i < nElem; ++i)\
+	  if( (*src)[i] < 0)\
+	    {\
+	      if( strict)\
+		throw GDLException("Array used to subscript array "\
+				   "contains out of range (<0) subscript.");\
+	      (*res)[i++]= zeroVal;\
+	      break;\
+	    }\
+	  else if( (*src)[i] > upper)\
+	    {\
+	      if( strict)\
+		throw GDLException("Array used to subscript array "\
+				   "contains out of range (>) subscript.");\
+	      (*res)[i++]= upperVal;\
+	      break;\
+	    }\
+	  else\
+	    (*res)[ i] = (*this)[ (*src)[ i]];\
+	for(; i < nElem; ++i)\
+	  if( (*src)[i] < 0)\
+	    (*res)[i]= zeroVal;\
+	  else if( (*src)[i] > upper)\
+	    (*res)[i]= upperVal;\
+	  else\
+	    (*res)[ i] = (*this)[ (*src)[ i]];\
+    GDLInterpreter::IncRef( res);\
+	return guard.release();
+
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::NewIx( BaseGDL* ix, bool strict)
+{
+SizeT nElem = ix->N_Elements();
+
+Data_* res = New( ix->Dim(), BaseGDL::NOZERO);
+auto_ptr<Data_> guard( res);
+
+SizeT upper = dd.size() - 1;
+Ty    upperVal = (*this)[ upper];
+Ty    zeroVal  = (*this)[ 0];
+switch( ix->Type())
+	{
+	case BYTE:
+	{
+	DByteGDL* src = static_cast<DByteGDL*>( ix);
+
+	NEWIX_UNSIGNEDINT
+	}
+	case INT:
+	{
+	DIntGDL* src = static_cast<DIntGDL*>( ix);
+
+	NEWIX_SIGNEDINT
+	}
+	case UINT:
+	{
+	DUIntGDL* src = static_cast<DUIntGDL*>( ix);
+
+	NEWIX_UNSIGNEDINT
+	}
+	case LONG: // typical type (returned from WHERE)
+	{
+	DLongGDL* src = static_cast<DLongGDL*>( ix);
+
+	NEWIX_SIGNEDINT
+	}
+	case ULONG:
+	{
+	DULongGDL* src = static_cast<DULongGDL*>( ix);
+
+	NEWIX_UNSIGNEDINT
+	}
+	case LONG64:
+	{
+	DLong64GDL* src = static_cast<DLong64GDL*>( ix);
+
+	NEWIX_SIGNEDINT
+	}
+	case ULONG64:
+	{
+	DULong64GDL* src = static_cast<DULong64GDL*>( ix);
+
+	NEWIX_UNSIGNEDINT
+	}
+	case FLOAT:
+	{
+	DFloat maxF = upper; 
+	DFloatGDL* src = static_cast<DFloatGDL*>( ix);
+	for( SizeT i=0; i < nElem; ++i)
+	if( (*src)[i] <= 0.0)
+		{
+		Ty b = zeroVal;
+		GDLInterpreter::IncRef( b);
+
+		(*res)[i] = zeroVal;
+		if( (*src)[i] <= -1.0 && strict)
+		throw GDLException("Array used to subscript array "
+				"contains out of range (<0) subscript.");
+		}
+	else if( (*src)[i] > maxF)
+		{
+		if( (*src)[i] >= (maxF + 1.0) && strict)
+		throw GDLException("Array used to subscript array "
+				"contains out of range (>) subscript.");
+		Ty b = upperVal;
+		GDLInterpreter::IncRef( b);
+		(*res)[i] = upperVal;
+		}
+	else
+		{
+		(*res)[i]= (*this)[ Real2Int<SizeT,float>((*src)[i])];
+		}
+	GDLInterpreter::IncRef( res);
+	return guard.release();
+	}
+	case DOUBLE:
+	{
+	DDouble maxF = upper; 
+	DDoubleGDL* src = static_cast<DDoubleGDL*>( ix);
+	for( SizeT i=0; i < nElem; ++i)
+	if( (*src)[i] <= 0.0)
+		{
+		(*res)[i] = zeroVal;
+		if( (*src)[i] <= -1.0 && strict)
+		throw GDLException("Array used to subscript array "
+				"contains out of range (<0) subscript.");
+		}
+	else if( (*src)[i] > maxF)
+		{
+		(*res)[i] = upperVal;
+		if( (*src)[i] >= (maxF + 1.0) && strict)
+		throw GDLException("Array used to subscript array "
+				"contains out of range (>) subscript.");
+		}
+	else
+		{
+		(*res)[i]= (*this)[ Real2Int<SizeT,double>((*src)[i])];
+		}
+	GDLInterpreter::IncRef( res);
+	return guard.release();
+	}
+	case STRING:
+	{
+	DStringGDL* src = static_cast<DStringGDL*>( ix);
+	for( SizeT i=0; i < nElem; ++i)
+	{
+		const char* cStart=(*src)[i].c_str();
+		char* cEnd;
+		long l=strtol(cStart,&cEnd,10);
+		if( cEnd == cStart)
+		{
+		Warning("Type conversion error: "
+			"Unable to convert given STRING to LONG.");
+		(*res)[i] = zeroVal;
+		}
+		else if( l < 0)
+		{
+		if( strict)
+		throw GDLException("Array used to subscript array "
+					"contains out of range (<0) subscript.");
+		(*res)[i] = zeroVal;
+		}
+		else if( l > upper)
+		{
+		if( strict)
+		throw GDLException("Array used to subscript array "
+					"contains out of range (>) subscript.");
+		(*res)[i] = upperVal;
+		}
+		else
+		{
+		(*res)[i] = (*this)[ l];
+		}
+	}
+	GDLInterpreter::IncRef( res);
+	return guard.release();
+	}
+	case COMPLEX:
+	{
+	DFloat maxF = upper; 
+	DComplexGDL* src = static_cast<DComplexGDL*>( ix);
+	for( SizeT i=0; i < nElem; ++i)
+	if( real((*src)[i]) <= 0.0)
+		{
+		if( real((*src)[i]) <= -1.0 && strict)
+		throw GDLException("Array used to subscript array "
+				"contains out of range (<0) subscript.");
+		(*res)[i] = zeroVal;
+		}
+	else if( real((*src)[i]) > upper)
+		{
+		if( real((*src)[i]) >= upper+1.0 && strict)
+		throw GDLException("Array used to subscript array "
+				"contains out of range (>) subscript.");
+		(*res)[i] = upperVal;
+		}
+	else
+		{
+		(*res)[i]= (*this)[ Real2Int<DLong,float>(real((*src)[i]))];
+		}
+	GDLInterpreter::IncRef( res);
+	return guard.release();
+	}
+	case COMPLEXDBL:
+	{
+	DDouble maxF = upper; 
+	DComplexDblGDL* src = static_cast<DComplexDblGDL*>( ix);
+	for( SizeT i=0; i < nElem; ++i)
+	if( real((*src)[i]) <= 0.0)
+		{
+		if( real((*src)[i]) <= -1.0 && strict)
+		throw GDLException("Array used to subscript array "
+				"contains out of range (<0) subscript.");
+		(*res)[i] = zeroVal;
+		}
+	else if( real((*src)[i]) > upper)
+		{
+		if( real((*src)[i]) >= upper+1.0 && strict)
+		throw GDLException("Array used to subscript array "
+				"contains out of range (>) subscript.");
+		(*res)[i] = upperVal;
+		}
+	else
+		{
+		(*res)[i]= (*this)[ Real2Int<DLong,float>(real((*src)[i]))];
+		}
+	GDLInterpreter::IncRef( res);
+	return guard.release();
+	}
+	default:
+	{
+	DType dType = ix->Type();
+	assert( dType != UNDEF);
+	
+	int typeCheck = DTypeOrder[ dType];
+	if( typeCheck >= 100)
+	throw GDLException("Type not allowed as subscript.");
+
+	assert( 0);
+	}
+	}
+assert( 0);
+}
+
+#undef NEWIX_SIGNEDINT
+#undef NEWIX_UNSIGNEDINT
+
+#define NEWIX_UNSIGNEDINT \
+SizeT i = 0;\
+for( ; i < nElem; ++i)\
+  if( (*src)[i] > upper)\
+    {\
+      if( strict)\
+	throw GDLException("Array used to subscript array "\
+			   "contains out of range (>) subscript.");\
+      (*res)[i++]= upperVal;\
+      break;\
+    }\
+  else\
+    (*res)[i]= (*this)[ (*src)[i]];\
+for(; i < nElem; ++i)\
+  if( (*src)[i] > upper)\
+    (*res)[i] = upperVal;\
+  else\
+    (*res)[i]= (*this)[ (*src)[i]];\
+GDLInterpreter::IncRefObj( res);\
+return guard.release();
+
+#define NEWIX_SIGNEDINT \
+  SizeT i = 0;\
+for(; i < nElem; ++i)\
+	  if( (*src)[i] < 0)\
+	    {\
+	      if( strict)\
+		throw GDLException("Array used to subscript array "\
+				   "contains out of range (<0) subscript.");\
+	      (*res)[i++]= zeroVal;\
+	      break;\
+	    }\
+	  else if( (*src)[i] > upper)\
+	    {\
+	      if( strict)\
+		throw GDLException("Array used to subscript array "\
+				   "contains out of range (>) subscript.");\
+	      (*res)[i++]= upperVal;\
+	      break;\
+	    }\
+	  else\
+	    (*res)[ i] = (*this)[ (*src)[ i]];\
+	for(; i < nElem; ++i)\
+	  if( (*src)[i] < 0)\
+	    (*res)[i]= zeroVal;\
+	  else if( (*src)[i] > upper)\
+	    (*res)[i]= upperVal;\
+	  else\
+	    (*res)[ i] = (*this)[ (*src)[ i]];\
+    GDLInterpreter::IncRefObj( res);\
+	return guard.release();
+
+template<>
+Data_<SpDObj>* Data_<SpDObj>::NewIx( BaseGDL* ix, bool strict)
+{
+SizeT nElem = ix->N_Elements();
+
+Data_* res = New( ix->Dim(), BaseGDL::NOZERO);
+auto_ptr<Data_> guard( res);
+
+SizeT upper = dd.size() - 1;
+Ty    upperVal = (*this)[ upper];
+Ty    zeroVal  = (*this)[ 0];
+switch( ix->Type())
+	{
+	case BYTE:
+	{
+	DByteGDL* src = static_cast<DByteGDL*>( ix);
+
+	NEWIX_UNSIGNEDINT
+	}
+	case INT:
+	{
+	DIntGDL* src = static_cast<DIntGDL*>( ix);
+
+	NEWIX_SIGNEDINT
+	}
+	case UINT:
+	{
+	DUIntGDL* src = static_cast<DUIntGDL*>( ix);
+
+	NEWIX_UNSIGNEDINT
+	}
+	case LONG: // typical type (returned from WHERE)
+	{
+	DLongGDL* src = static_cast<DLongGDL*>( ix);
+
+	NEWIX_SIGNEDINT
+	}
+	case ULONG:
+	{
+	DULongGDL* src = static_cast<DULongGDL*>( ix);
+
+	NEWIX_UNSIGNEDINT
+	}
+	case LONG64:
+	{
+	DLong64GDL* src = static_cast<DLong64GDL*>( ix);
+
+	NEWIX_SIGNEDINT
+	}
+	case ULONG64:
+	{
+	DULong64GDL* src = static_cast<DULong64GDL*>( ix);
+
+	NEWIX_UNSIGNEDINT
+	}
+	case FLOAT:
+	{
+	DFloat maxF = upper; 
+	DFloatGDL* src = static_cast<DFloatGDL*>( ix);
+	for( SizeT i=0; i < nElem; ++i)
+	if( (*src)[i] <= 0.0)
+		{
+		Ty b = zeroVal;
+		GDLInterpreter::IncRefObj( b);
+
+		(*res)[i] = zeroVal;
+		if( (*src)[i] <= -1.0 && strict)
+		throw GDLException("Array used to subscript array "
+				"contains out of range (<0) subscript.");
+		}
+	else if( (*src)[i] > maxF)
+		{
+		if( (*src)[i] >= (maxF + 1.0) && strict)
+		throw GDLException("Array used to subscript array "
+				"contains out of range (>) subscript.");
+		Ty b = upperVal;
+		GDLInterpreter::IncRefObj( b);
+		(*res)[i] = upperVal;
+		}
+	else
+		{
+		(*res)[i]= (*this)[ Real2Int<SizeT,float>((*src)[i])];
+		}
+	GDLInterpreter::IncRefObj( res);
+	return guard.release();
+	}
+	case DOUBLE:
+	{
+	DDouble maxF = upper; 
+	DDoubleGDL* src = static_cast<DDoubleGDL*>( ix);
+	for( SizeT i=0; i < nElem; ++i)
+	if( (*src)[i] <= 0.0)
+		{
+		(*res)[i] = zeroVal;
+		if( (*src)[i] <= -1.0 && strict)
+		throw GDLException("Array used to subscript array "
+				"contains out of range (<0) subscript.");
+		}
+	else if( (*src)[i] > maxF)
+		{
+		(*res)[i] = upperVal;
+		if( (*src)[i] >= (maxF + 1.0) && strict)
+		throw GDLException("Array used to subscript array "
+				"contains out of range (>) subscript.");
+		}
+	else
+		{
+		(*res)[i]= (*this)[ Real2Int<SizeT,double>((*src)[i])];
+		}
+	GDLInterpreter::IncRefObj( res);
+	return guard.release();
+	}
+	case STRING:
+	{
+	DStringGDL* src = static_cast<DStringGDL*>( ix);
+	for( SizeT i=0; i < nElem; ++i)
+	{
+		const char* cStart=(*src)[i].c_str();
+		char* cEnd;
+		long l=strtol(cStart,&cEnd,10);
+		if( cEnd == cStart)
+		{
+		Warning("Type conversion error: "
+			"Unable to convert given STRING to LONG.");
+		(*res)[i] = zeroVal;
+		}
+		else if( l < 0)
+		{
+		if( strict)
+		throw GDLException("Array used to subscript array "
+					"contains out of range (<0) subscript.");
+		(*res)[i] = zeroVal;
+		}
+		else if( l > upper)
+		{
+		if( strict)
+		throw GDLException("Array used to subscript array "
+					"contains out of range (>) subscript.");
+		(*res)[i] = upperVal;
+		}
+		else
+		{
+		(*res)[i] = (*this)[ l];
+		}
+	}
+	GDLInterpreter::IncRefObj( res);
+	return guard.release();
+	}
+	case COMPLEX:
+	{
+	DFloat maxF = upper; 
+	DComplexGDL* src = static_cast<DComplexGDL*>( ix);
+	for( SizeT i=0; i < nElem; ++i)
+	if( real((*src)[i]) <= 0.0)
+		{
+		if( real((*src)[i]) <= -1.0 && strict)
+		throw GDLException("Array used to subscript array "
+				"contains out of range (<0) subscript.");
+		(*res)[i] = zeroVal;
+		}
+	else if( real((*src)[i]) > upper)
+		{
+		if( real((*src)[i]) >= upper+1.0 && strict)
+		throw GDLException("Array used to subscript array "
+				"contains out of range (>) subscript.");
+		(*res)[i] = upperVal;
+		}
+	else
+		{
+		(*res)[i]= (*this)[ Real2Int<DLong,float>(real((*src)[i]))];
+		}
+	GDLInterpreter::IncRefObj( res);
+	return guard.release();
+	}
+	case COMPLEXDBL:
+	{
+	DDouble maxF = upper; 
+	DComplexDblGDL* src = static_cast<DComplexDblGDL*>( ix);
+	for( SizeT i=0; i < nElem; ++i)
+	if( real((*src)[i]) <= 0.0)
+		{
+		if( real((*src)[i]) <= -1.0 && strict)
+		throw GDLException("Array used to subscript array "
+				"contains out of range (<0) subscript.");
+		(*res)[i] = zeroVal;
+		}
+	else if( real((*src)[i]) > upper)
+		{
+		if( real((*src)[i]) >= upper+1.0 && strict)
+		throw GDLException("Array used to subscript array "
+				"contains out of range (>) subscript.");
+		(*res)[i] = upperVal;
+		}
+	else
+		{
+		(*res)[i]= (*this)[ Real2Int<DLong,float>(real((*src)[i]))];
+		}
+	GDLInterpreter::IncRefObj( res);
+	return guard.release();
+	}
+	default:
+	{
+	DType dType = ix->Type();
+	assert( dType != UNDEF);
+	
+	int typeCheck = DTypeOrder[ dType];
+	if( typeCheck >= 100)
+	throw GDLException("Type not allowed as subscript.");
+
+	assert( 0);
+	}
+	}
+assert( 0);
+}
+
+#endif
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/dcompiler.cpp cvs/gdl/src/dcompiler.cpp
--- gdl-0.9rc4/src/dcompiler.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/dcompiler.cpp	2010-04-16 11:22:53.000000000 -0600
@@ -29,7 +29,7 @@
 #include "GDLInterpreter.hpp"
 
 // print out AST tree
-//#define GDL_DEBUG
+// #define GDL_DEBUG
 //#undef GDL_DEBUG
 
 #ifdef GDL_DEBUG
@@ -177,7 +177,10 @@
   EnvStackT& cS = GDLInterpreter::CallStack();
   SizeT stSz = cS.size();
   for( SizeT i=1; i<stSz; ++i) // i=1: skip $MAIN$
-    if( cS[ i]->GetPro() == p) return true;
+  {
+    if( cS[ i]->GetPro() == p)
+		return true;
+  }
   return false;
 }
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/deviceps.hpp cvs/gdl/src/deviceps.hpp
--- gdl-0.9rc4/src/deviceps.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/deviceps.hpp	2010-07-07 14:41:01.439987312 -0600
@@ -20,6 +20,7 @@
 
 //#include "dstructgdl.hpp"
 #include "gdlpsstream.hpp"
+#include "initsysvar.hpp"
 
 class DevicePS: public Graphics
 {
@@ -60,8 +61,8 @@
     sprintf(as, "%f",a);
     actStream->SetOpt( "a", as); // this necessary to keep labels from looking stretched (plplot bug)
                                  // but plrender -a is also buggy: aspect ratios are not exactly correct 
-    xleng=floor(scale*540. +0.5);
-    yleng=floor(scale*720. +0.5);
+    xleng=static_cast<PLINT>(floor(scale*540. +0.5));
+    yleng=static_cast<PLINT>(floor(scale*720. +0.5));
     // setting this without plrender -a makes the labels stretched (plplot bug)
     actStream->spage( xp, yp, xleng, yleng, xoff, yoff); 
 
@@ -154,14 +155,26 @@
     return true;
   }
 
-  bool SetXPageSize( const float xs)
+  bool SetXPageSize( const float xs) // xs [cm]
   {
     XPageSize=xs;
+
+    (*static_cast<DLongGDL*>(dStruct->GetTag(dStruct->Desc()->TagIndex("X_SIZE"))))[0] 
+      = floor(0.5+
+        xs * (*static_cast<DFloatGDL*>(dStruct->GetTag(dStruct->Desc()->TagIndex("X_PX_CM"))))[0]
+      );
+
     return true;
   }
-  bool SetYPageSize( const float ys)
+  bool SetYPageSize( const float ys) // ys [cm]
   {
     YPageSize=ys;
+
+    (*static_cast<DLongGDL*>(dStruct->GetTag(dStruct->Desc()->TagIndex("Y_SIZE"))))[0] 
+      = floor(0.5+
+        ys * (*static_cast<DFloatGDL*>(dStruct->GetTag(dStruct->Desc()->TagIndex("Y_PX_CM"))))[0]
+      );
+
     return true;
   }
   bool SetColor()
Only in gdl-0.9rc4/src: deviceps.hpp.orig
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/devicex.hpp cvs/gdl/src/devicex.hpp
--- gdl-0.9rc4/src/devicex.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/devicex.hpp	2010-07-07 14:41:01.456946379 -0600
@@ -18,6 +18,9 @@
 #ifndef DEVICEX_HPP_
 #define DEVICEX_HPP_
 
+#ifndef HAVE_X
+#else
+
 #include <algorithm>
 #include <vector>
 #include <cstring>
@@ -30,9 +33,10 @@
 #include "initsysvar.hpp"
 
 #define ToXColor(a) (((0xFF & (a)) << 8) | (a))
+#ifndef free_mem
 #define free_mem(a) \
     if (a != NULL) { free((void *) a); a = NULL; }
-
+#endif
 
 const int maxWin=32;  
 
@@ -386,7 +390,10 @@
       return false;
 
     if( winList[ wIx] != NULL)
-      delete winList[ wIx];
+		{
+		delete winList[ wIx];
+		winList[ wIx] = NULL;
+		}
 
     DLongGDL* pMulti = SysVar::GetPMulti();
     DLong nx = (*pMulti)[ 1];
@@ -878,3 +885,5 @@
 
 
 #endif
+
+#endif
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/dimension.hpp cvs/gdl/src/dimension.hpp
--- gdl-0.9rc4/src/dimension.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/dimension.hpp	2010-06-03 09:06:37.260740232 -0600
@@ -65,7 +65,7 @@
       dim[i]= d[i];
   }
 
-  // simplified constructor for one to three dimensions
+  // simplified constructors for one to three dimensions
   dimension(const SizeT d0)
   {
     assert( d0 != 0);
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/dinterpreter.cpp cvs/gdl/src/dinterpreter.cpp
--- gdl-0.9rc4/src/dinterpreter.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/dinterpreter.cpp	2010-04-22 09:50:40.000000000 -0600
@@ -39,6 +39,9 @@
 // #define GDL_DEBUG
 //#undef GDL_DEBUG
 
+// print out an exspression entered at teh comand line
+//#define 	AUTO_PRINT_EXPR
+
 #ifdef GDL_DEBUG
 #include "print_tree.hpp"
 #endif
@@ -46,6 +49,8 @@
 using namespace std;
 using namespace antlr;
 
+bool historyIntialized = false;
+
 // instantiation of static data
 GDLInterpreter::HeapT     GDLInterpreter::heap; 
 GDLInterpreter::ObjHeapT  GDLInterpreter::objHeap; 
@@ -82,16 +87,16 @@
   //  tmpList.reserve(100);
 }
 
-void SetActualCompileOpt( unsigned int cOpt)
-{
-if( BaseGDL::interpreter!=NULL && BaseGDL::interpreter->CallStack().size()>0) 
-	BaseGDL::interpreter->CallStack().back()->SetCompileOpt( cOpt);
-}
+// void SetActualCompileOpt( unsigned int cOpt)
+// {
+// if( BaseGDL::interpreter!=NULL && BaseGDL::interpreter->CallStack().size()>0) 
+// 	BaseGDL::interpreter->CallStack().back()->SetCompileOpt( cOpt);
+// }
 
 // used in the statement function.
 // runs a new instance of the interpreter if not
 // at main level
-GDLInterpreter::RetCode GDLInterpreter::NewInterpreterInstance( SizeT lineOffset)
+RetCode GDLInterpreter::NewInterpreterInstance( SizeT lineOffset)
 {
   if( callStack.size() <= 1) return RC_ABORT; // stay in main loop 
   
@@ -149,6 +154,7 @@
   static StrArr openFiles;
 
   string proFile=StrLowCase(pro)+".pro";
+  //AppendIfNeeded( proFile, ".pro");
 
   bool found=CompleteFileName(proFile);
   if( !found) return false;
@@ -737,6 +743,11 @@
   try { 
     auto_ptr<GDLLexer> lexer;
 
+    // LineContinuation LC
+    // conactenate the strings and insert \n
+    // the resulting string can be fed to the lexer
+   
+    // print if expr parse ok 
     int lCNum = 0;
     for(;;) 
       {
@@ -748,14 +759,40 @@
  	  lexer->Parser().interactive();
 	  break; // no error -> everything ok
 	}
-	catch( GDLException e)
+	catch( GDLException& e)
 	  {
 	    int lCNew = lexer->LineContinuation();
 	    if( lCNew == lCNum)
-	      throw; // no LC -> real error
+// 	      throw; // no LC -> real error
+	{
+#ifdef 	AUTO_PRINT_EXPR
+#ifndef GDL_DEBUG 		
+ 		try {
+// 			executeLine.clear(); // clear EOF (for executeLine)
+// 			lexer.reset( new GDLLexer(executeLine, "", callStack.back()->CompileOpt()));
+// 			lexer->Parser().expr();
+	
+			executeLine.clear(); // clear EOF (for executeLine)
+			executeLine.str( "print," + executeLine.str()); // append new line
+			
+			lexer.reset( new GDLLexer(executeLine, "", callStack.back()->CompileOpt()));
+			lexer->Parser().interactive();
+			
+			break; // no error -> everything ok
+		}
+		catch( GDLException& e2)
+#endif
+#endif
+		{
+			throw e;
+		}
+	}
+
 	    lCNum = lCNew; // save number to see if next line also has LC
 	  }
 
+
+
 	// line continuation -> get next line
 	if( in != NULL && !in->good())
 	  throw GDLException( "End of file encountered during line continuation.");
@@ -770,12 +807,12 @@
     theAST = lexer->Parser().getAST();
 
   }
-  catch( GDLException e)
+  catch( GDLException& e)
     {
       ReportCompileError( e);
       return CC_OK;
     }
-  catch( ANTLRException e)
+  catch( ANTLRException& e)
     {
       cerr << "Lexer/Parser exception: " <<  e.getMessage() << endl;
       return CC_OK;
@@ -793,9 +830,13 @@
   cout << "ExecuteLine: Parser end." << endl;
 #endif
 
-  ProgNodeP progAST = NULL;;
+  ProgNodeP progAST = NULL;
 
   RefDNode trAST;
+	
+  assert( dynamic_cast<EnvUDT*>(callStack.back()) != NULL);
+  EnvUDT* env = static_cast<EnvUDT*>(callStack.back());
+  int nForLoopsIn = env->NForLoops();
   try
     {
       GDLTreeParser treeParser( callStack.back());
@@ -816,15 +857,24 @@
   cout << "ExecuteLine: Tree parser end." << endl;
 #endif
 
-      progAST = ProgNode::NewProgNode( trAST);
+    progAST = ProgNode::NewProgNode( trAST);
+
+	assert( dynamic_cast<EnvUDT*>(callStack.back()) != NULL);
+    EnvUDT* env = static_cast<EnvUDT*>(callStack.back());
+    int nForLoops = ProgNode::NumberForLoops( progAST, nForLoopsIn);
+	env->ResizeForLoops( nForLoops);
     }
-  catch( GDLException e)
+  catch( GDLException& e)
     {
+	  env->ResizeForLoops( nForLoopsIn);
+      
       ReportCompileError( e);
       return CC_OK;
     }
-  catch( ANTLRException e)
+  catch( ANTLRException& e)
     {
+	  env->ResizeForLoops( nForLoopsIn);
+      
       cerr << "Compiler exception: " <<  e.getMessage() << endl;
       return CC_OK;
     }
@@ -839,7 +889,9 @@
   cout << "end." << endl;
 #endif
 
-      GDLInterpreter::RetCode retCode = interactive( progAST);
+      RetCode retCode = interactive( progAST);
+      
+	  env->ResizeForLoops( nForLoopsIn);
       
       // write to journal file
       string actualLine = GetClearActualLine();
@@ -850,11 +902,15 @@
     }
   catch( GDLException& e)
     {
+	  env->ResizeForLoops( nForLoopsIn);
+      
       cerr << "Unhandled GDL exception: " <<  e.toString() << endl;;
       return CC_OK;
     }
   catch( ANTLRException& e)
     {
+	  env->ResizeForLoops( nForLoopsIn);
+      
       cerr << "Interpreter exception: " <<  e.getMessage() << endl;
       return CC_OK;
     }
@@ -890,12 +946,14 @@
 }
 
 bool  lineEdit = false;
+string actualPrompt;
 
 void ControlCHandler(int)
 {
   cout << SysVar::MsgPrefix() << "Interrupt encountered." << endl;
-  if( lineEdit) cout << SysVar::Prompt() /*.c_str()*/ << flush;
+  if( lineEdit) cout << actualPrompt /*SysVar::Prompt()*/ /*.c_str()*/ << flush;
   sigControlC = true;
+  signal(SIGINT,ControlCHandler);
 }
 
 string DInterpreter::GetLine()
@@ -911,17 +969,19 @@
 
     char *cline;
 
+	actualPrompt = SysVar::Prompt();
+
     lineEdit = true;
 
 #ifdef HAVE_LIBREADLINE
     
     if( edit_input != 0)
-      cline = readline(const_cast<char*>(SysVar::Prompt().c_str()));
+      cline = readline(const_cast<char*>(actualPrompt.c_str()));
     else
-      cline = NoReadline(SysVar::Prompt().c_str());
+      cline = NoReadline(actualPrompt.c_str());
 #else
     
-    cline = NoReadline(SysVar::Prompt().c_str());
+    cline = NoReadline(actualPrompt.c_str());
 #endif
     
     lineEdit = false;
@@ -937,9 +997,10 @@
 	StrTrim(line);
 	break;
       }
-    
+    else
     // make a string
     line = cline;
+    
     free(cline);        // done here for compatibility with readline
   
     StrTrim(line);
@@ -965,7 +1026,7 @@
 
 // reads user input and executes it
 // inner loop (called via Control-C, STOP, error)
-GDLInterpreter::RetCode DInterpreter::InnerInterpreterLoop(SizeT lineOffset)
+RetCode DInterpreter::InnerInterpreterLoop(SizeT lineOffset)
 {
 
   bool runCmd = false;
@@ -1107,7 +1168,7 @@
 
 // reads user input and executes it
 // the main loop
-GDLInterpreter::RetCode DInterpreter::InterpreterLoop( const string& startup, 
+RetCode DInterpreter::InterpreterLoop( const string& startup,
   vector<string>& batch_files, const std::string& statement)
 {
   // process startup file
@@ -1191,7 +1252,12 @@
     // execute single statement and exit (a new-line is added to statement in gdl.cpp)
     // (e.g. $ gdl -e "print, 'hello world'")
     istringstream iss(statement, ios_base::out);
-    ExecuteLine(&iss);
+    try {
+		ExecuteLine(&iss);
+    }
+      catch( RetAllException& retAllEx)
+	{
+	}
     return RC_OK;
   }
   else
@@ -1204,6 +1270,7 @@
   }
 
 #ifdef HAVE_LIBREADLINE
+
   // initialize readline (own version - not pythons one)
   // in includefirst.hpp readline is disabled for python_module
   // http://www.delorie.com/gnu/docs/readline/rlman.html
@@ -1238,6 +1305,9 @@
       else cout<<"Fail to read back ~/.gdl/history"<<endl;
     }
   }
+
+historyIntialized = true;
+
 #endif
 
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/dinterpreter.hpp cvs/gdl/src/dinterpreter.hpp
--- gdl-0.9rc4/src/dinterpreter.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/dinterpreter.hpp	2010-07-07 14:41:01.580003393 -0600
@@ -27,7 +27,20 @@
 
 #ifdef __cplusplus
   extern "C" {
+#if defined(__OpenBSD__)
+// SA: based on http://ftp2.cz.freesbie.org/pub/FreeBSD-cvs/gnats/i386/75862
+#  include <ieeefp.h>
+#  define feclearexcept(e)	(void)fpsetsticky(~((fp_except)(e)))
+#  define fetestexcept(e)	((int)(fpgetsticky() & (fp_except)(e)))
+#  define FE_ALL_EXCEPT 	(FP_X_INV | FP_X_DNML | FP_X_DZ | FP_X_OFL | FP_X_UFL | FP_X_IMP)
+#  define FE_DIVBYZERO		FP_X_DZ
+#  define FE_INEXACT		FP_X_IMP
+#  define FE_INVALID		FP_X_INV
+#  define FE_OVERFLOW		FP_X_OFL
+#  define FE_UNDERFLOW		FP_X_UFL
+#else
 #  include <fenv.h>
+#endif
     //#  if defined(__FreeBSD__)
 #    pragma STDC FENV_ACCESS ON
     //#  endif
@@ -50,8 +63,13 @@
 #include <fstream>
 #include <vector>
 
+
 void ControlCHandler(int);
 
+extern bool lineEdit; // = false;
+extern bool historyIntialized; 
+extern std::string actualPrompt;
+
 class DInterpreter: public GDLInterpreter
 {
 public:
@@ -61,10 +79,10 @@
      CC_RETURN
    };
 
-private:
-
   char* NoReadline(const std::string&);
 
+private:
+
   // execute GDL command (.run, .step, ...)
   CommandCode ExecuteCommand(const std::string& command);
   CommandCode CmdCompile(const std::string& command);
@@ -99,11 +117,11 @@
   bool RunBatch( std::istream* in);
 
   // the main program for interactive mode
-  GDLInterpreter::RetCode InterpreterLoop( const std::string& startup, 
+  RetCode InterpreterLoop( const std::string& startup,
     std::vector<std::string>& batch_files, const std::string& statement);  
 
   // called within InterpreterLoop()
-  GDLInterpreter::RetCode InnerInterpreterLoop(SizeT lineOffset);  
+  RetCode InnerInterpreterLoop(SizeT lineOffset);
 
 };
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/dnode.cpp cvs/gdl/src/dnode.cpp
--- gdl-0.9rc4/src/dnode.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/dnode.cpp	2010-04-16 11:22:53.000000000 -0600
@@ -1,5 +1,5 @@
 /***************************************************************************
-                          dnode.cpp  -  GDL's AST is made of DNodes
+                             dnode.cpp  -  GDL's AST is made of DNodes
                              -------------------
     begin                : July 22 2002
     copyright            : (C) 2002 by Marc Schellens
@@ -52,6 +52,7 @@
 DInterpreter* ProgNode::interpreter;
 
 DNode::DNode( const DNode& cp): 
+//   keepRight( false),
   CommonAST( cp), //down(), right(), 
   lineNumber( cp.getLine()), cData(NULL), 
   var(cp.var), arrIxList(NULL), 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/dnode.hpp cvs/gdl/src/dnode.hpp
--- gdl-0.9rc4/src/dnode.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/dnode.hpp	2010-04-16 11:22:53.000000000 -0600
@@ -62,7 +62,8 @@
 
   ~DNode();
 
-  DNode(): CommonAST(), //down(), right(), 
+  DNode(): CommonAST(), //down(), right(),
+// 	keepRight( false),
 	   lineNumber(0), cData(NULL), 
 	   var(NULL), 
 	   libFun(NULL),
@@ -74,17 +75,22 @@
   DNode( const DNode& cp);
 
   DNode(antlr::RefToken t) : antlr::CommonAST(t) //, down(), right()
-  {
+//   	, keepRight( false)
+{
     //    antlr::CommonAST::setType(t->getType() );
     //    antlr::CommonAST::setText(t->getText() );
     DNode::SetLine(t->getLine() );
   }
 
+// 	void DoKeepRight() { keepRight = true;}
+
   void initialize(int t, const std::string& txt)
   {
     antlr::CommonAST::setType(t);
     antlr::CommonAST::setText(txt);
 
+// 	keepRight = false;
+
     lineNumber = 0;
     cData=NULL;
     libFun=NULL;
@@ -258,6 +264,7 @@
   void SetLibFun(DLibFun* const l) { libFun=l;}
   void SetLibPro(DLibPro* const l) { libPro=l;}
   void SetNDot(const int n) { nDot=n;}
+  int GetNDot() const { return nDot;}
 
   void SetCompileOpt(const int n) { compileOpt=n; }
   int GetCompileOpt() { return compileOpt; }
@@ -287,6 +294,8 @@
   { ArrayIndexListT* res = arrIxList; arrIxList=NULL; return res;}
   ArrayIndexListT* CloneArrIxList(); 
 
+// 	bool keepRight; // for passing to ProgNode, nodes here are reference counted
+
   //  RefDNode down;
   //  RefDNode right;
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/dpro.cpp cvs/gdl/src/dpro.cpp
--- gdl-0.9rc4/src/dpro.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/dpro.cpp	2010-04-22 09:50:40.000000000 -0600
@@ -155,7 +155,7 @@
 
 DLibFunRetNew::DLibFunRetNew( LibFun f, const string& n, const int nPar_, 
 			const string keyNames[], const string warnKeyNames[], bool rConstant)
-  : DLibFun(f,n,nPar_,keyNames, NULL), retConstant( rConstant)
+  : DLibFun(f,n,nPar_,keyNames, warnKeyNames), retConstant( rConstant)
 {}
 // DLibFunRetNew::DLibFunRetNew( LibFun f, const string& n, const int nPar_, 
 // 			bool rConstant)
@@ -185,7 +185,8 @@
   DSub(n,o), file(f),
   tree( NULL),
   labelList(),
-  compileOpt(GDLParser::NONE)
+  compileOpt(GDLParser::NONE),
+  nForLoops( 0)
 {
   if( o != "")
     AddPar( "SELF");
@@ -215,6 +216,7 @@
   labelList.Clear(); // labels are invalid after tree is deleted
   delete tree;
   tree = NULL; //static_cast<RefDNode>(antlr::nullAST);
+  nForLoops = 0;
 }
 
 void DSubUD::AddPar(const string& p)
@@ -264,13 +266,18 @@
 void DSubUD::ResolveLabel( ProgNodeP p)
 {
   if( p == NULL) return;
+
+// if( p->getNextSibling() != NULL)
+// 	std::cout << "Resolve("<< p->getLine()<<"): " << p << " keepRight: " << p->KeepRight()<< ": "<< p->getText() <<"  r: "<< p->GetNextSibling()->getText() << std::endl;
+// else
+// 	std::cout << "Resolve("<< p->getLine()<<"): " << p << " keepRight: " << p->KeepRight()<< ": "<< p->getText() <<"  r: NULL"<< std::endl;
   
   if( p->getType() == GDLTreeParser::ON_IOERROR || 
       p->getType() == GDLTreeParser::GOTO)
     {
       int ix = labelList.Find( p->getText());
       if( ix == -1)
-	throw GDLException( p, ObjectName()+": Undefined label "+p->getText()+
+		throw GDLException( p, ObjectName()+": Undefined label "+p->getText()+
 			    " referenced in GOTO statement.",false,false);
       
       p->SetGotoIx( ix);
@@ -280,8 +287,12 @@
       labelList.SetLabelNode( p);
     }
   
-  ResolveLabel( p->getFirstChild());
-  ResolveLabel( p->getNextSibling());
+  if( !p->KeepDown())
+	ResolveLabel( p->getFirstChild());
+  if( !p->KeepRight())
+	ResolveLabel( p->getNextSibling());
+//   else
+// 	ResolveLabel( p->getNextSibling());
 }
 
   // the final "compilation" takes part here 
@@ -294,6 +305,8 @@
   //
   tree = ProgNode::NewProgNode( n);
 
+  nForLoops = ProgNode::NumberForLoops( tree);
+
 #ifdef GDL_DEBUG
       cout << "DSubUD::SetTree:" << endl;
       antlr::print_tree pt;
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/dpro.hpp cvs/gdl/src/dpro.hpp
--- gdl-0.9rc4/src/dpro.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/dpro.hpp	2010-05-21 10:23:56.602905285 -0600
@@ -277,6 +277,9 @@
 
   void ResolveLabel( ProgNodeP);
 
+protected:
+  int nForLoops;
+
 public:
   DSubUD(const std::string&,const std::string& o="",const std::string& f="");
   ~DSubUD(); 
@@ -310,6 +313,8 @@
   void     DelVar(const int ix) {var.erase(var.begin() + ix);}
 
   SizeT Size() { return var.size();}
+
+  int NForLoops() const { return nForLoops;}
   
   // search for variable returns true if its found in var or common blocks
   bool Find(const std::string& n)
@@ -351,7 +356,7 @@
   {
     return key[ix];
   }
-  
+
   bool GetCommonVarName(const BaseGDL* p, std::string& varName)
   {
     for( CommonBaseListT::iterator c=common.begin();
@@ -427,7 +432,8 @@
 {
 public:
   // for main function, not inserted into proList
-  DPro(): DSubUD("$MAIN$","","") {}
+  // should be fine (way too much): 32 NESTED loops in $MAIN$ (elswhere: unlimited)
+  DPro(): DSubUD("$MAIN$","","") { this->nForLoops = 32;}
 
   DPro(const std::string& n,const std::string& o="",const std::string& f=""): 
     DSubUD(n,o,f)
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/dstructgdl.cpp cvs/gdl/src/dstructgdl.cpp
--- gdl-0.9rc4/src/dstructgdl.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/dstructgdl.cpp	2010-04-16 11:22:53.000000000 -0600
@@ -118,10 +118,11 @@
 }
  
   // c-i 
+// only used from Assoc_
 DStructGDL::DStructGDL(const DStructGDL& d_)
-  : SpDStruct(d_.desc, d_.dim) 
+  : SpDStruct(d_.desc, d_.dim)
   , typeVar( d_.NTags())
-  , dd(d_.NBytes(), false) 
+  , dd(d_.NBytes(), false)
 {
   MakeOwnDesc();
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/dstructgdl.hpp cvs/gdl/src/dstructgdl.hpp
--- gdl-0.9rc4/src/dstructgdl.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/dstructgdl.hpp	2010-05-21 10:23:56.606906918 -0600
@@ -117,7 +117,8 @@
   }
 
   // c-i (desc defined)
-  DStructGDL(const DStructGDL& d_);
+  // only called from Assoc_'s c-i
+DStructGDL(const DStructGDL& d_);
 
   // For creating new structs (always scalar)
   DStructGDL( DStructDesc* desc_)
@@ -411,6 +412,7 @@
   // used by the interpreter
   // throws (datatypes.cpp)
   int Scalar2index( SizeT& st) const;
+  int Scalar2RangeT( RangeT& st) const;
   
   bool Scalar() const 
   { return (N_Elements() == 1);}
@@ -498,7 +500,8 @@
   Data_<SpDByte>* LogNeg()
   { throw GDLException("Struct expression not allowed in this context.");}
   int  Sgn(); // -1,0,1
-  bool Equal( BaseGDL*);
+  bool Equal( BaseGDL*) const;
+  bool EqualNoDelete( const BaseGDL*) const;
   bool ArrayEqual( BaseGDL*);
   // 'for' statement compliance (int types , float types scalar only)
   void ForCheck( BaseGDL**, BaseGDL** =NULL);
@@ -529,7 +532,7 @@
   DStructGDL*   PowInv( BaseGDL* r);
   DStructGDL*   PowInt( BaseGDL* r);
   DStructGDL*   PowIntNew( BaseGDL* r);
-  DStructGDL*   MatrixOp( BaseGDL* r);
+  DStructGDL*   MatrixOp( BaseGDL* r,bool,bool,bool);
 
 
   DStructGDL*   AndOpS( BaseGDL* r);
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/envt.cpp cvs/gdl/src/envt.cpp
--- gdl-0.9rc4/src/envt.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/envt.cpp	2010-04-22 09:50:40.000000000 -0600
@@ -53,6 +53,9 @@
   lastJump( -1)
 {
   DSubUD* proUD=static_cast<DSubUD*>(pro);
+
+  forLoopInfo.resize( proUD->NForLoops());
+  
   SizeT envSize;
   SizeT keySize;
 
@@ -95,7 +98,7 @@
   lastJump( -1)
 {
   obj = true;
-
+  
   DStructGDL* oStructGDL = interpreter->ObjectStruct( self, cN);
 
   const string& mp = cN->getText();
@@ -120,6 +123,9 @@
     }
 
   DSubUD* proUD=static_cast<DSubUD*>(pro);
+
+  forLoopInfo.resize( proUD->NForLoops());
+
   SizeT envSize;
   SizeT keySize;
   envSize=proUD->var.size();
@@ -169,6 +175,9 @@
     }
 
   DSubUD* proUD=static_cast<DSubUD*>(pro);
+
+  forLoopInfo.resize( proUD->NForLoops());
+
   SizeT envSize;
   SizeT keySize;
   envSize=proUD->var.size();
@@ -204,7 +213,7 @@
   if( self != NULL)
     env.Set( parIx++, self); //static_cast<BaseGDL*>(oStructGDL));
 }
-EnvUDT::EnvUDT( EnvT* pEnv, DSub* newPro, BaseGDL** self):
+EnvUDT::EnvUDT( EnvBaseT* pEnv, DSub* newPro, BaseGDL** self):
   EnvBaseT( pEnv->CallingNode(), newPro),
   ioError(NULL), 
   onError( -1), 
@@ -217,6 +226,9 @@
   obj = (self != NULL);
 
   DSubUD* proUD=static_cast<DSubUD*>(pro);
+  
+  forLoopInfo.resize( proUD->NForLoops());
+
   SizeT envSize;
   SizeT keySize;
   envSize=proUD->var.size();
@@ -229,7 +241,7 @@
 }
 
 
-void EnvBaseT::AddStruct( DPtrListT& ptrAccessible, 
+void EnvBaseT::AddStruct( DPtrListT& ptrAccessible,
 			  DPtrListT& objAccessible, DStructGDL* stru)
 {
   if( stru == NULL) return;
@@ -268,7 +280,7 @@
 
     }
 }
-void EnvBaseT::AddPtr( DPtrListT& ptrAccessible, DPtrListT& objAccessible, 
+void EnvBaseT::AddPtr( DPtrListT& ptrAccessible, DPtrListT& objAccessible,
 		       DPtrGDL* ptr)
 {
   if( ptr == NULL) return;
@@ -287,7 +299,7 @@
 	}
     }
 }
-void EnvBaseT::AddObj( DPtrListT& ptrAccessible, DPtrListT& objAccessible, 
+void EnvBaseT::AddObj( DPtrListT& ptrAccessible, DPtrListT& objAccessible,
 		       DObjGDL* ptr)
 {
   if( ptr == NULL) return;
@@ -307,7 +319,7 @@
 	}
     }
 }
-void EnvBaseT::Add( DPtrListT& ptrAccessible, DPtrListT& objAccessible, 
+void EnvBaseT::Add( DPtrListT& ptrAccessible, DPtrListT& objAccessible,
 		    BaseGDL* p)
 {
   DPtrGDL* ptr = dynamic_cast< DPtrGDL*>( p);
@@ -354,7 +366,7 @@
 	    DVar* var = common->Var( v);
 	    if( var != NULL)
 	      {
-		Add( ptrAccessible, objAccessible, var->Data());
+			Add( ptrAccessible, objAccessible, var->Data());
 	      }
 	  }
       }
@@ -378,11 +390,11 @@
     // do OBJ first as the cleanup might need the PTR be valid
     if( doObj)
       {
-	DObjGDL* heap = interpreter->GetAllObjHeap();
-	auto_ptr< DObjGDL> heap_guard( heap);
+	std::vector<DObj>* heap = interpreter->GetAllObjHeapSTL();
+	auto_ptr< std::vector<DObj> > heap_guard( heap);
 	if( (*heap)[0] != 0)
 	  {
-	    SizeT nH = heap->N_Elements();
+	    SizeT nH = heap->size();//N_Elements();
 	    for( SizeT h=0; h<nH; ++h)
 	      {
 		DObj p = (*heap)[ h];
@@ -406,11 +418,11 @@
       }
     if( doPtr)
       {
-	DPtrGDL* heap = interpreter->GetAllHeap();
-	auto_ptr< BaseGDL> heap_guard( heap);
+	std::vector<DPtr>* heap = interpreter->GetAllHeapSTL();
+	auto_ptr< std::vector<DPtr> > heap_guard( heap);
 	if( (*heap)[0] != 0)
 	  {
-	    SizeT nH = heap->N_Elements();
+	    SizeT nH = heap->size();
 	    for( SizeT h=0; h<nH; ++h)
 	      {
 		DPtr p = (*heap)[ h];
@@ -447,71 +459,137 @@
     }
   inProgress = 0;
 }
-void EnvT::ObjCleanup( DObj actID)
+
+
+set< DObj> EnvBaseT::inProgress;
+
+// for CLEANUP calls due to reference counting
+// note: refcount is already zero for actID
+void EnvBaseT::ObjCleanup( DObj actID)
 {
-  static set< DObj> inProgress;
+  if( actID != 0 && (inProgress.find( actID) == inProgress.end()))
+    {
+      DStructGDL* actObj;
+      try{
+// 		actObj=GetObjHeap( actID);
+ 		GDLInterpreter::ObjHeapT::iterator it;
+		actObj=GDLInterpreter::GetObjHeap( actID, it);
+      }
+      catch( GDLInterpreter::HeapException){
+		actObj=NULL;
+      }
+	    
+    if( actObj != NULL)
+		{
+		try{
+				// call CLEANUP function
+				DPro* objCLEANUP= actObj->Desc()->GetPro( "CLEANUP");
+			
+				if( objCLEANUP != NULL)
+				{
+					BaseGDL* actObjGDL = new DObjGDL( actID);
+					auto_ptr<BaseGDL> actObjGDL_guard( actObjGDL);
+					GDLInterpreter::IncRefObj( actID); // set refcount to 1
+				
+					PushNewEmptyEnvUD( objCLEANUP, &actObjGDL);
+				
+					inProgress.insert( actID);
+				
+					interpreter->call_pro( objCLEANUP->GetTree());
+				
+					inProgress.erase( actID);
+
+					EnvBaseT* callStackBack =  interpreter->CallStack().back();
+					interpreter->CallStack().pop_back();
+					delete callStackBack;
+
+					FreeObjHeap( actID); // make sure actObj is freed
+					// actObjGDL goes out of scope -> refcount is (would be) decreased
+				}
+			}
+		catch( ...)
+			{
+				FreeObjHeap( actID); // make sure actObj is freed
+				throw; // rethrow
+			}		
+		}
+	else		
+		FreeObjHeap( actID); // the actual freeing
+    }
+}
 
+
+
+void EnvT::ObjCleanup( DObj actID)
+{
   if( actID != 0 && (inProgress.find( actID) == inProgress.end()))
     {
       DStructGDL* actObj;
       try{
-	actObj=GetObjHeap( actID);
+// 		actObj=GetObjHeap( actID);
+ 		GDLInterpreter::ObjHeapT::iterator it;
+		actObj=GDLInterpreter::GetObjHeap( actID, it);
       }
       catch( GDLInterpreter::HeapException){
-	actObj=NULL;
+		actObj=NULL;
       }
 	    
       if( actObj != NULL)
-	{
-	  // call CLEANUP function
-	  DPro* objCLEANUP= actObj->Desc()->GetPro( "CLEANUP");
-	  
-	  if( objCLEANUP != NULL)
-	    {
-	      BaseGDL* actObjGDL = new DObjGDL( actID);
-	      auto_ptr<BaseGDL> actObjGDL_guard( actObjGDL);
-	      
-	      PushNewEnvUD( objCLEANUP, 1, &actObjGDL);
-	      
-	      inProgress.insert( actID);
-	      
-	      interpreter->call_pro( objCLEANUP->GetTree());
-	      
-	      inProgress.erase( actID);
+		{
+			// call CLEANUP function
+			DPro* objCLEANUP= actObj->Desc()->GetPro( "CLEANUP");
+		
+			if( objCLEANUP != NULL)
+				{
+				BaseGDL* actObjGDL = new DObjGDL( actID);
+				auto_ptr<BaseGDL> actObjGDL_guard( actObjGDL);
+				GDLInterpreter::IncRefObj( actID);
+			
+				PushNewEnvUD( objCLEANUP, 1, &actObjGDL);
+			
+				inProgress.insert( actID);
+			
+				interpreter->call_pro( objCLEANUP->GetTree());
+			
+				inProgress.erase( actID);
 
-	      delete interpreter->CallStack().back();
-	      interpreter->CallStack().pop_back();
-	    }
-	  
-	  FreeObjHeap( actID); // the actual freeing
-	}
+				delete interpreter->CallStack().back();
+				interpreter->CallStack().pop_back();
+			}
+ 	
+		FreeObjHeap( actID); // the actual freeing
+		}
     }
 }
 
 
 
 // these two functions should be inlined
-SizeT EnvT::NewObjHeap( SizeT n, DStructGDL* v) 
+SizeT EnvBaseT::NewObjHeap( SizeT n, DStructGDL* v) 
 {
   return interpreter->NewObjHeap(n,v);
 }
-SizeT EnvT::NewHeap( SizeT n, BaseGDL* v) 
+SizeT EnvBaseT::NewHeap( SizeT n, BaseGDL* v)
 { 
   return interpreter->NewHeap(n,v);
 }
-void EnvT::FreeObjHeap( DObj id)
+void EnvBaseT::FreeObjHeap( DObj id)
 {
   interpreter->FreeObjHeap( id);
 }
-void EnvT::FreeHeap( DPtrGDL* p)
+void EnvBaseT::FreeHeap( DPtrGDL* p)
 {
   interpreter->FreeHeap(p);
 }
-DStructGDL* EnvT::GetObjHeap( DObj ID)
+// // DStructGDL* EnvT::GetObjHeap( DObj ID, ObjHeapT::iterator& it)
+// // {
+// //   return interpreter->GetObjHeap( ID, it);
+// // }
+DStructGDL* EnvBaseT::GetObjHeap( DObj ID)
 {
   return interpreter->GetObjHeap( ID);
 }
-BaseGDL* EnvT::GetHeap( DPtr ID)
+BaseGDL* EnvBaseT::GetHeap( DPtr ID)
 {
   return interpreter->GetHeap( ID);
 }
@@ -769,6 +847,27 @@
 
 // used by obj_new (basic_fun.cpp)
 // and obj_destroy (basic_pro.cpp)
+void EnvBaseT::PushNewEmptyEnvUD(  DSub* newPro, BaseGDL** newObj)
+{
+  EnvUDT* newEnv= new EnvUDT( this, newPro, newObj);
+
+  // pass the parameters, skip the first 'skipP'
+//   SizeT nParam = NParam();
+//   for( SizeT p=skipP; p<nParam; p++)
+//     {
+//       newEnv->SetNextPar( &GetPar( p)); // pass as global
+//     }
+
+  interpreter->CallStack().push_back( newEnv); 
+
+  // _REF_EXTRA is set to the keyword string array
+//   newEnv->extra = new ExtraT( newEnv);
+//   newEnv->extra->Set( &env[0]);
+//   newEnv->extra->Resolve();
+}
+
+// used by obj_new (basic_fun.cpp)
+// and obj_destroy (basic_pro.cpp)
 void EnvT::PushNewEnvUD(  DSub* newPro, SizeT skipP, BaseGDL** newObj)
 {
   EnvUDT* newEnv= new EnvUDT( this, newPro, newObj);
@@ -1114,10 +1213,11 @@
 BaseGDL*& EnvT::GetPar(SizeT i)
 {
   static BaseGDL* null=NULL;
+  assert( null == NULL);
   SizeT ix= i + pro->key.size();
   if( ix >= env.size()) 
     {
-      Warning( "EnvT::GetPar(): Index out of env: " + GetParString(ix));
+//       Warning( "EnvT::GetPar(): Index out of env size ("+i2s(env.size())+"): " + i2s(i) +" (+ "+i2s(pro->key.size())+" KW)");
       return null;
     }
   return env[ ix];
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/envt.hpp cvs/gdl/src/envt.hpp
--- gdl-0.9rc4/src/envt.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/envt.hpp	2010-05-21 10:23:56.876905583 -0600
@@ -42,6 +42,9 @@
 class EnvBaseT
 {
 protected:
+  // for obj cleanup
+  static std::set< DObj> inProgress;
+  
   static DInterpreter* interpreter;
   DataListT            env;
   SizeT                parIx;     // ix of next parameter to put
@@ -57,22 +60,40 @@
   int GetKeywordIx( const std::string& k);
 
   // for HEAP_GC
-  void AddStruct( DPtrListT& ptrAccessible,  DPtrListT& objAccessible, 
+  static void AddStruct( DPtrListT& ptrAccessible,  DPtrListT& objAccessible, 
 		  DStructGDL* stru);
-  void AddPtr( DPtrListT& ptrAccessible, DPtrListT& objAccessible, 
+  static void AddPtr( DPtrListT& ptrAccessible, DPtrListT& objAccessible, 
 	       DPtrGDL* ptr);
-  void AddObj( DPtrListT& ptrAccessible, DPtrListT& objAccessible, 
+  static void AddObj( DPtrListT& ptrAccessible, DPtrListT& objAccessible, 
 	       DObjGDL* obj);
-  void Add( DPtrListT& ptrAccessible, DPtrListT& objAccessible, 
+  static void Add( DPtrListT& ptrAccessible, DPtrListT& objAccessible, 
 	    BaseGDL* p);
 
 public:
+// 	void DebugInfo()
+// 	{
+// 		std::cout << this->pro->ObjectName() << std::endl;
+// 	}
+
+  virtual void ObjCleanup( DObj actID);
+
+  // for CLEANUP calls due to reference counting
+  void PushNewEmptyEnvUD(  DSub* newPro, BaseGDL** newObj = NULL);
+  
   void AddEnv( DPtrListT& ptrAccessible, DPtrListT& objAccessible);
 
   virtual ~EnvBaseT() { delete extra;}
 
   EnvBaseT( ProgNodeP cN, DSub* pro_);
 
+  static SizeT NewObjHeap( SizeT n=1, DStructGDL* v=NULL);
+  static SizeT NewHeap( SizeT n=1, BaseGDL* v=NULL);
+  static void FreeObjHeap( DObj id);
+  static void FreeHeap( DPtr id);
+  static void FreeHeap( DPtrGDL* p);
+  static DStructGDL* GetObjHeap( DObj ID);
+  static BaseGDL* GetHeap( DPtr ID);
+
 int GetLineNumber()
 {
 return lineNumber;
@@ -84,13 +105,15 @@
 unsigned int CompileOpt()
 {
 DSubUD* proUD = dynamic_cast<DSubUD*>(pro);
-if( proUD == NULL) throw GDLException("Intenal error: CompileOpt called non DSub object.");
+if( proUD == NULL)
+	throw GDLException("Intenal error: CompileOpt called non DSub object.");
 return proUD->GetCompileOpt();
 }
 void SetCompileOpt( unsigned int cOpt)
 {
 DSubUD* proUD = dynamic_cast<DSubUD*>(pro);
-if( proUD == NULL) throw GDLException("Intenal error: CompileOpt called non DSub object.");
+if( proUD == NULL)
+	throw GDLException("Intenal error: CompileOpt called non DSub object.");
 proUD->SetCompileOpt( cOpt);
 }
 
@@ -198,9 +221,13 @@
   friend class DInterpreter; // gcc 4.4 compatibility
 };
 
+
+
 // for UD subroutines (written in GDL) ********************************
 class EnvUDT: public EnvBaseT
 {
+  std::vector<ForLoopInfoT> forLoopInfo;
+
   ProgNodeP         ioError; 
   DLong             onError; // on_error setting
   BaseGDL**         catchVar;
@@ -210,6 +237,11 @@
   int               lastJump; // to which label last jump went
   
 public:
+	ForLoopInfoT& GetForLoopInfo( int forIx) { return forLoopInfo[forIx];}
+    
+    int NForLoops() const { return forLoopInfo.size();}
+    void ResizeForLoops( int newSize) { forLoopInfo.resize(newSize);}
+
   // UD pro/fun
   EnvUDT( ProgNodeP idN, DSub* pro_, bool lF = false);
 
@@ -222,7 +254,7 @@
 
 
   // for obj_new and obj_destroy
-  EnvUDT( EnvT* pEnv, DSub* newPro, BaseGDL** self); 
+  EnvUDT( EnvBaseT* pEnv, DSub* newPro, BaseGDL** self); 
 
   DLong GetOnError() const { return onError;}
 
@@ -293,15 +325,6 @@
   void HeapGC( bool doPtr, bool doObj, bool verbose);
   void ObjCleanup( DObj actID);
 
-
-  SizeT NewObjHeap( SizeT n=1, DStructGDL* v=NULL);
-  SizeT NewHeap( SizeT n=1, BaseGDL* v=NULL);
-  void FreeObjHeap( DObj id);
-  void FreeHeap( DPtr id);
-  void FreeHeap( DPtrGDL* p);
-  DStructGDL* GetObjHeap( DObj ID);
-  BaseGDL* GetHeap( DPtr ID);
-
   // used by obj_new (basic_fun.cpp)
   void PushNewEnv(  DSub* newPro, SizeT skipP, BaseGDL** newObj=NULL);
   void PushNewEnvUD(  DSub* newPro, SizeT skipP, BaseGDL** newObj=NULL);
@@ -584,7 +607,7 @@
 };
 
 
-typedef std::deque<EnvBaseT*> EnvStackT;
+	typedef std::deque<EnvBaseT*> EnvStackT;
 
 #endif
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/fftw.cpp cvs/gdl/src/fftw.cpp
--- gdl-0.9rc4/src/fftw.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/fftw.cpp	2010-07-07 14:41:01.795005194 -0600
@@ -82,6 +82,11 @@
 	}
 }
       }
+
+      // 02 06 2010
+      //cout << "fftw dest" << endl ;
+      fftw_destroy_plan(p); // 1 
+
     }
     else if( p0->Type() == COMPLEX) {
       float *dptrf;
@@ -107,6 +112,11 @@
 	}
 }
       }
+
+      // 02 06 2010
+      //cout << "fftwF dest" << endl ;
+      fftwf_destroy_plan(p_f); // 2
+
     }
     
     return res;
@@ -165,6 +175,7 @@
       DComplexDblGDL *p0C;
 
       auto_ptr<BaseGDL> guard_p0C;
+
       if( p0->Type() != COMPLEXDBL) {
 	p0C = static_cast<DComplexDblGDL*>(p0->Convert2( COMPLEXDBL, BaseGDL::COPY));
         guard_p0C.reset(p0C); 
@@ -175,18 +186,12 @@
     }
     else if( p0->Type() == COMPLEX) {
 
-      DComplexGDL* res;
+      //      DComplexGDL* res;
 
       return fftw_template< DComplexGDL> (p0, nEl, dbl, overwrite, direct);
 
     }
-    else if (p0->Type() == FLOAT ||
-	     p0->Type() == LONG ||
-	     p0->Type() == ULONG ||
-	     p0->Type() == INT ||
-	     p0->Type() == UINT ||
-	     p0->Type() == BYTE) {
-
+    else {
       overwrite = 0;
 
       DComplexGDL* p0C = static_cast<DComplexGDL*>
@@ -194,15 +199,10 @@
       auto_ptr<BaseGDL> guard_p0C( p0C); 
       return fftw_template< DComplexGDL> (p0C, nEl, dbl, overwrite, direct);
 
-    } else {
-      DFloatGDL* res = static_cast<DFloatGDL*>
-	(p0->Convert2( FLOAT, BaseGDL::COPY));
-
-      return res;
-
     }
   }
 
+
 } // namespace
 
 #endif // USE_FFTW
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/file.cpp cvs/gdl/src/file.cpp
--- gdl-0.9rc4/src/file.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/file.cpp	2010-07-07 14:41:01.817004317 -0600
@@ -39,12 +39,18 @@
 #include <fnmatch.h>
 
 // workaround for HP-UX. A better solution is needed i think
-#if defined(__hpux__) || defined(__sun__)
+//#if defined(__hpux__) || defined(__sun__)
+#if !defined(GLOB_TILDE)
 #  define GLOB_TILDE 0
+#endif
+#if !defined(GLOB_BRACE)
 #  define GLOB_BRACE 0
 #endif
-#if defined(__hpux__) || defined(__sun__) || defined(__CYGWIN__)
+//#if defined(__hpux__) || defined(__sun__) || defined(__CYGWIN__) || defined(__OpenBSD__)
+#if !defined(GLOB_ONLYDIR)
 #  define GLOB_ONLYDIR 0
+#endif
+#if !defined(GLOB_PERIOD)
 #  define GLOB_PERIOD 0
 #endif
 
@@ -376,21 +382,25 @@
 	return;
       }
     
-    if( dirN[0] != '+')
+    if( dirN[0] != '+' && dirN[0] != '~')
       {
 	result.push_back( dirN);
 	return;
       }
     
-    if( dirN.length() == 1) // dirN == "+" 
-      return;
+    if( dirN.length() == 1) {
+      // dirN == "+" 
+      if (dirN[0] == '+') return;
+    }
 
     // dirN == "+DIRNAME"
 
     // do first a glob because of '~'
     int flags = GLOB_TILDE | GLOB_NOSORT;
     glob_t p;
-    int gRes = glob( dirN.substr(1).c_str(), flags, NULL, &p);
+    int offset_tilde=0;
+    if (dirN[0] == '+') offset_tilde=1;
+    int gRes = glob( dirN.substr(offset_tilde).c_str(), flags, NULL, &p);
     if( gRes != 0 || p.gl_pathc == 0)
       {
 	globfree( &p);
@@ -399,8 +409,16 @@
 
     DString initDir = p.gl_pathv[ 0];
     globfree( &p);
-     
-    ExpandPathN( result, initDir, pat, all_dirs);
+    
+    if (dirN[0] == '+')
+      {
+	ExpandPathN( result, initDir, pat, all_dirs);
+      } 
+    else
+      {
+	result.push_back(initDir);
+      }
+
   }
 
   BaseGDL* expand_path( EnvT* e)
@@ -562,6 +580,47 @@
       }
   }
 
+// Make s string case-insensitive for glob()
+void makeInsensitive(DString &s)
+{
+	DString insen;
+	char coupleBracket[5]={'[',0,0,']',0};
+	char couple[3]={0};
+	bool bracket=false;
+	
+	for(size_t i=0;i<s.size();i++) 
+		if((s[i]>='A' && s[i]<='Z') || (s[i]>='a' && s[i]<='z'))
+		{
+			char m,M;
+			if(s[i]>='a' && s[i]<='z')
+				m=s[i],M=m+'A'-'a';
+			else
+				M=s[i],m=M-'A'+'a';
+
+			if(bracket) // If bracket is open, then don't add bracket
+				couple[0]=m,couple[1]=M,insen+=couple;
+			else // else [aA]
+				coupleBracket[1]=m,coupleBracket[2]=M,insen+=coupleBracket;
+		}
+		else
+		{
+			if(s[i]=='[')
+			{
+				bracket=false;
+				for(size_t ii=i;ii<s.size();ii++) // Looking for matching right bracket
+					if(s[ii]==']') { bracket=true; break; }
+
+				if(bracket) insen+=s[i];
+				else insen+="[[]";
+			}
+			else if(s[i]==']' && s[(!i?0:i-1)]!='[')
+				bracket=false, insen+=s[i];
+			else
+				insen+=s[i];
+		}
+	s.swap(insen);
+}
+
   void FileSearch( FileListT& fL, const DString& s, 
 		   bool environment,
 		   bool tilde,
@@ -623,6 +682,7 @@
         pattern = GetCWD();
         pattern.append("/");
         pattern.append(s);
+	if(!( s.size() ==1 && s.at(0) == '.')) pattern.append(s);
         gRes = glob(pattern.c_str(), flags, NULL, &p);
       }
       else 
@@ -735,7 +795,9 @@
 
     // ...
     if( fold_case)
-      Warning( "FILE_SEARCH: FOLD_CASE keyword ignored (not supported).");
+	for(SizeT f=0; f < nPath; ++f)
+		makeInsensitive((*pathSpec)[0]);
+
     if( match_all_dot)
       Warning( "FILE_SEARCH: MATCH_ALL_INITIAL_DOT keyword ignored (not supported).");
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/.#file.cpp.1.9 cvs/gdl/src/.#file.cpp.1.9
--- gdl-0.9rc4/src/.#file.cpp.1.9	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/.#file.cpp.1.9	2008-11-12 17:03:31.000000000 -0700
@@ -0,0 +1,842 @@
+/***************************************************************************
+                                 file.cpp  -  file related library functions 
+                             -------------------
+    begin                : July 22 2004
+    copyright            : (C) 2004 by Marc Schellens
+    email                : m_schellens@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "includefirst.hpp"
+
+#include "basegdl.hpp"
+#include "str.hpp"
+
+//#ifdef HAVE_LIBWXWIDGETS
+
+#include "envt.hpp"
+#include "file.hpp"
+
+#include <unistd.h>
+#include <sys/stat.h>
+
+// #include <wx/utils.h>
+// #include <wx/file.h>
+// #include <wx/dir.h>
+
+#include <glob.h>
+#include <dirent.h>
+#include <fnmatch.h>
+
+// workaround for HP-UX. A better solution is needed i think
+#if defined(__hpux__)
+#define GLOB_TILDE 0
+#define GLOB_BRACE 0
+#define GLOB_ONLYDIR 0
+#define GLOB_PERIOD 0
+#endif
+
+
+namespace lib {
+
+  using namespace std;
+
+  BaseGDL* file_test( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 1); 
+    
+    BaseGDL* p0 = e->GetParDefined( 0);
+
+    DStringGDL* p0S = dynamic_cast<DStringGDL*>( p0);
+    if( p0S == NULL)
+      e->Throw( "String expression required in this context: "+
+		e->GetParString(0));
+
+    static int directoryIx = e->KeywordIx( "DIRECTORY");
+    bool directory = e->KeywordSet( directoryIx);
+
+    static int executableIx = e->KeywordIx( "EXECUTABLE");
+    bool executable = e->KeywordSet( executableIx);
+
+    static int readIx = e->KeywordIx( "READ");
+    bool read = e->KeywordSet( readIx);
+
+    static int writeIx = e->KeywordIx( "WRITE");
+    bool write = e->KeywordSet( writeIx);
+
+    static int zero_lengthIx = e->KeywordIx( "ZERO_LENGTH");
+    bool zero_length = e->KeywordSet( zero_lengthIx);
+
+    static int get_modeIx = e->KeywordIx( "GET_MODE");
+    bool get_mode = e->KeywordPresent( get_modeIx);
+
+    static int regularIx = e->KeywordIx( "REGULAR");
+    bool regular = e->KeywordSet( regularIx);
+
+    static int block_specialIx = e->KeywordIx( "BLOCK_SPECIAL");
+    bool block_special = e->KeywordSet( block_specialIx);
+
+    static int character_specialIx = e->KeywordIx( "CHARACTER_SPECIAL");
+    bool character_special = e->KeywordSet( character_specialIx);
+
+    static int named_pipeIx = e->KeywordIx( "NAMED_PIPE");
+    bool named_pipe = e->KeywordSet( named_pipeIx);
+
+    static int socketIx = e->KeywordIx( "SOCKET");
+    bool socket = e->KeywordSet( socketIx);
+
+    static int symlinkIx = e->KeywordIx( "SYMLINK");
+    bool symlink = e->KeywordSet( symlinkIx);
+
+    DLongGDL* getMode = NULL; 
+    if( get_mode)
+      {
+	getMode = new DLongGDL( p0S->Dim()); // zero
+	e->SetKW( get_modeIx, getMode);
+      }
+    
+    DLongGDL* res = new DLongGDL( p0S->Dim()); // zero
+
+//     bool doStat = 
+//       zero_length || get_mode || directory || 
+//       regular || block_special || character_special || 
+//       named_pipe || socket || symlink;
+
+    SizeT nEl = p0S->N_Elements();
+    for( SizeT f=0; f<nEl; ++f)
+      {
+	const char* actFile = (*p0S)[ f].c_str();
+
+	struct stat statStruct;
+	int actStat = lstat( actFile, &statStruct);
+	if( actStat != 0) 
+	  continue;
+
+	// 	if( !wxFileExists( actFile) && !wxDirExists( actFile))
+	// 	  continue;
+
+	// 	if( directory && !wxDirExists( actFile))
+	// 	  continue;
+	// 	if( read && !wxFile::Access( actFile, wxFile::read))
+	// 	  continue;
+	// 	if( write && !wxFile::Access( actFile, wxFile::write))
+	// 	  continue;
+
+	if( read && access( actFile, R_OK) != 0)
+	  continue;
+	if( write && access( actFile, W_OK) != 0)
+	  continue;
+	if( executable && access( actFile, X_OK) != 0)
+	  continue;
+
+	if( zero_length && statStruct.st_size != 0) 
+	  continue;
+
+	if( get_mode)
+	  (*getMode)[ f] = statStruct.st_mode & 
+	    (S_IRWXU | S_IRWXG | S_IRWXO);
+	    
+	if( directory && S_ISDIR(statStruct.st_mode) == 0) 
+	  continue;
+	if( regular && S_ISREG(statStruct.st_mode) == 0) 
+	  continue;
+	if( block_special && S_ISBLK(statStruct.st_mode) == 0) 
+	  continue;
+	if( character_special && S_ISCHR(statStruct.st_mode) == 0) 
+	  continue;
+	if( named_pipe && S_ISFIFO(statStruct.st_mode) == 0) 
+	  continue;
+	if( socket && S_ISSOCK(statStruct.st_mode) == 0) 
+	  continue;
+	if( symlink && S_ISLNK(statStruct.st_mode) == 0) 
+	  continue;
+	
+	(*res)[ f] = 1;
+      }
+
+    return res;
+  }
+
+  BaseGDL* file_info( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 1); 
+    
+    BaseGDL* p0 = e->GetParDefined( 0);
+
+    DStringGDL* p0S = dynamic_cast<DStringGDL*>( p0);
+    if( p0S == NULL)
+      e->Throw( "String expression required in this context: "+
+		e->GetParString(0));
+
+    static int directoryIx = e->KeywordIx( "NOEXPAND_PATH");
+    bool directory = e->KeywordSet( noexpand_pathIx);
+
+    DLongGDL* getMode = NULL; 
+    if( get_mode)
+      {
+	getMode = new DLongGDL( p0S->Dim()); // zero
+	e->SetKW( get_modeIx, getMode);
+      }
+    
+    DLongGDL* res = new DLongGDL( p0S->Dim()); // zero
+
+//     bool doStat = 
+//       zero_length || get_mode || directory || 
+//       regular || block_special || character_special || 
+//       named_pipe || socket || symlink;
+
+    SizeT nEl = p0S->N_Elements();
+    for( SizeT f=0; f<nEl; ++f)
+      {
+	const char* actFile = (*p0S)[ f].c_str();
+
+	struct stat statStruct;
+	int actStat = lstat( actFile, &statStruct);
+	if( actStat != 0) 
+	  continue;
+
+	// 	if( !wxFileExists( actFile) && !wxDirExists( actFile))
+	// 	  continue;
+
+	// 	if( directory && !wxDirExists( actFile))
+	// 	  continue;
+	// 	if( read && !wxFile::Access( actFile, wxFile::read))
+	// 	  continue;
+	// 	if( write && !wxFile::Access( actFile, wxFile::write))
+	// 	  continue;
+
+	if( read && access( actFile, R_OK) != 0)
+	  continue;
+	if( write && access( actFile, W_OK) != 0)
+	  continue;
+	if( executable && access( actFile, X_OK) != 0)
+	  continue;
+
+	if( zero_length && statStruct.st_size != 0) 
+	  continue;
+
+	if( get_mode)
+	  (*getMode)[ f] = statStruct.st_mode & 
+	    (S_IRWXU | S_IRWXG | S_IRWXO);
+	    
+	if( directory && S_ISDIR(statStruct.st_mode) == 0) 
+	  continue;
+	if( regular && S_ISREG(statStruct.st_mode) == 0) 
+	  continue;
+	if( block_special && S_ISBLK(statStruct.st_mode) == 0) 
+	  continue;
+	if( character_special && S_ISCHR(statStruct.st_mode) == 0) 
+	  continue;
+	if( named_pipe && S_ISFIFO(statStruct.st_mode) == 0) 
+	  continue;
+	if( socket && S_ISSOCK(statStruct.st_mode) == 0) 
+	  continue;
+	if( symlink && S_ISLNK(statStruct.st_mode) == 0) 
+	  continue;
+	
+	(*res)[ f] = 1;
+      }
+
+    return res;
+  }
+
+  DString GetCWD()
+  {
+    SizeT bufSize = PATH_MAX;
+    char *buf = new char[ bufSize];
+    for(;;)
+      {
+	char* value = getcwd( buf, bufSize);
+	if( value != NULL)
+	  break;
+	delete[] buf;
+	if( bufSize > 32000) 
+	  throw GDLException("Cannot get CWD.");
+	bufSize += PATH_MAX;
+	buf = new char[ bufSize];
+      }
+
+    DString cur( buf);
+    delete[] buf;
+    
+    return cur;
+  }
+
+  void cd_pro( EnvT* e)
+  {
+    if( e->KeywordPresent( 0)) // CURRENT
+      {
+	DString cur = GetCWD();
+	e->SetKW( 0, new DStringGDL( cur));
+      }
+
+    SizeT nParam=e->NParam(); 
+    if( nParam == 0) return;
+    
+    DString dir;
+    e->AssureScalarPar<DStringGDL>( 0, dir);
+   
+    WordExp( dir);
+     
+//     // expand tilde
+//     if( dir[0] == '~')
+//       {
+// 	char* homeDir = getenv( "HOME");
+// 	if( homeDir != NULL)
+// 	  {
+// 	    dir = string( homeDir) + dir.substr(1);
+// 	  }
+//       }
+
+    int success = chdir( dir.c_str());
+    if( success != 0)
+      e->Throw( "Unable to change current directory to: "+dir+".");
+  }
+
+//   void FileSearchWE( FileListT& fL, const DString& s)
+//   {
+//     wordexp_t p;
+//     int wERes;
+//     if( s == "")
+//       wERes = wordexp( "*", &p, WRDE_NOCMD);
+//     else
+//       wERes = wordexp( s.c_str(), &p, WRDE_NOCMD);
+//     if( wERes == 0)
+//       for( SizeT f=0; f<p.we_wordc; ++f)
+// 	fL.push_back( p.we_wordv[ f]);
+//     wordfree( &p);
+//   }
+
+  bool FindInDir( const DString& dirN, const DString& pat)
+  {
+    DString root = dirN;
+    AppendIfNeeded( root, "/");
+
+    DIR* dir = opendir( dirN.c_str());
+    if( dir == NULL) return false;
+
+    struct stat    statStruct;
+
+    for(;;)
+      {
+	struct dirent* entry = readdir( dir);
+	if( entry == NULL) break;
+	
+	DString entryStr( entry->d_name);
+	if( entryStr != "." && entryStr != "..")
+	  {
+	    DString testFile = root + entryStr;
+	    int actStat = lstat( testFile.c_str(), &statStruct);
+	    if( S_ISDIR(statStruct.st_mode) == 0)
+	      { // only test non-dirs
+		int match = fnmatch( pat.c_str(), entryStr.c_str(), 0);
+		if( match == 0)
+		  {
+		    closedir( dir);
+		    return true;
+		  }
+	      }
+	  }
+      }
+
+    closedir( dir);
+    return false;
+  }
+  
+  void ExpandPathN( FileListT& result,
+		    const DString& dirN, 
+		    const DString& pat,
+		    bool all_dirs)
+  {
+    // expand "+"
+	    
+    int fnFlags = 0;
+
+    //    fnFlags |= FNM_PERIOD;
+    //    fnFlags |= FNM_NOESCAPE;
+
+    DString root = dirN;
+    AppendIfNeeded( root, "/");
+    
+    struct stat    statStruct;
+
+    FileListT recurDir;
+    
+    bool notAdded = true;
+
+    DIR* dir = opendir( dirN.c_str());
+    if( dir == NULL) return;
+
+    if( all_dirs)
+      notAdded = false;
+    
+    for(;;)
+      {
+	struct dirent* entry = readdir( dir);
+	if( entry == NULL) break;
+
+	DString entryStr( entry->d_name);
+	if( entryStr != "." && entryStr != "..")
+	  {
+	    DString testDir = root + entryStr;
+	    int actStat = lstat( testDir.c_str(), &statStruct);
+	    if( S_ISDIR(statStruct.st_mode) != 0)
+	      {
+		recurDir.push_back( testDir);
+	      }
+	    else if( notAdded)
+	      {
+		int match = fnmatch( pat.c_str(), entryStr.c_str(), 0);
+		if( match == 0)
+		  notAdded = false;
+	      }
+	  }
+      }
+
+    int c = closedir( dir);
+    if( c == -1) return;
+
+    // recursive search
+    SizeT nRecur = recurDir.size();
+    for( SizeT d=0; d<nRecur; ++d)
+      {
+	ExpandPathN( result, recurDir[d], pat, all_dirs); 
+      }
+
+    if( !notAdded)
+      result.push_back( dirN);
+  }
+
+  void ExpandPath( FileListT& result,
+		    const DString& dirN, 
+		    const DString& pat,
+		    bool all_dirs)
+  {
+    if( dirN == "") 
+      return;
+
+    if( StrUpCase( dirN) == "<GDL_DEFAULT>" ||
+	StrUpCase( dirN) == "<IDL_DEFAULT>")
+      {
+	// result.push_back( the default path here);
+	return;
+      }
+    
+    if( dirN[0] != '+')
+      {
+	result.push_back( dirN);
+	return;
+      }
+    
+    if( dirN.length() == 1) // dirN == "+" 
+      return;
+
+    // dirN == "+DIRNAME"
+
+    // do first a glob because of '~'
+    int flags = GLOB_TILDE | GLOB_NOSORT;
+    glob_t p;
+    int gRes = glob( dirN.substr(1).c_str(), flags, NULL, &p);
+    if( gRes != 0 || p.gl_pathc == 0)
+      {
+	globfree( &p);
+	return;
+      }
+
+    DString initDir = p.gl_pathv[ 0];
+    globfree( &p);
+     
+    ExpandPathN( result, initDir, pat, all_dirs);
+  }
+
+  BaseGDL* expand_path( EnvT* e)
+  {
+    e->NParam( 1);
+
+    DString s;
+    e->AssureStringScalarPar( 0, s);
+
+    FileListT sArr;
+
+    static int all_dirsIx = e->KeywordIx( "ALL_DIRS");
+    bool all_dirs = e->KeywordSet( all_dirsIx);
+
+    static int arrayIx = e->KeywordIx( "ARRAY");
+    bool array = e->KeywordSet( arrayIx);
+
+    static int countIx = e->KeywordIx( "COUNT");
+
+    SizeT d;
+    long   sPos=0;
+    do
+      {
+	d=s.find(':',sPos);
+	string act = s.substr(sPos,d-sPos);
+	
+	ExpandPath( sArr, act, "*.pro", all_dirs);
+	
+	sPos=d+1;
+      }
+    while( d != s.npos);
+
+    SizeT nArr = sArr.size();
+
+    if( e->KeywordPresent( countIx)) 
+      {
+	e->SetKW( countIx, new DLongGDL( nArr));
+      }
+
+    if( nArr == 0)
+      return new DStringGDL( "");
+
+    if( array)
+      {
+	DStringGDL* res = new DStringGDL( dimension( nArr), BaseGDL::NOZERO);
+	for( SizeT i=0; i<nArr; ++i)
+	  (*res)[ i] = sArr[i];
+	return res;
+      }
+
+    // set the path
+    DString cat = sArr[0];
+    for( SizeT i=1; i<nArr; ++i)
+      cat += ":" + sArr[i];
+    
+    return new DStringGDL( cat);
+  }
+
+
+  void PatternSearch( FileListT& fL, const DString& dirN, const DString& pat,
+		      bool accErr,
+		      bool quote,
+		      bool match_dot,
+		      const DString& prefixIn)
+  {
+    int fnFlags = 0;
+
+    if( !match_dot)
+      fnFlags |= FNM_PERIOD;
+
+    if( !quote)
+      fnFlags |= FNM_NOESCAPE;
+
+    DString root = dirN;
+    if( root != "")
+      {
+	 long endR; 
+	 for( endR = root.length()-1; endR >= 0; --endR)
+	   {
+	     if( root[ endR] != '/')
+	       break;
+	   }
+	 if( endR >= 0)
+	   root = root.substr( 0, endR+1) + "/";
+	 else
+	   root = "/";
+      }
+
+     DString prefix = root;
+//     DString prefix = prefixIn;
+//     if( prefix != "")
+//       {
+// 	 long endR; 
+// 	 for( endR = prefix.length()-1; endR >= 0; --endR)
+// 	   {
+// 	     if( prefix[ endR] != '/')
+// 	       break;
+// 	   }
+// 	 if( endR >= 0)
+// 	   prefix = prefix.substr( 0, endR+1) + "/";
+// 	 else
+// 	   prefix = "/";
+//       }
+
+    struct stat    statStruct;
+
+    FileListT recurDir;
+    
+    DIR* dir;
+    if( root != "")
+      dir = opendir( dirN.c_str());
+    else
+      dir = opendir( ".");
+    if( dir == NULL)
+      if( accErr)
+	throw GDLException( "FILE_SEARCH: Error opening dir: "+dirN);
+      else
+	return;
+
+    for(;;)
+      {
+	struct dirent* entry = readdir( dir);
+	if( entry == NULL)
+	  break;
+
+	DString entryStr( entry->d_name);
+	if( entryStr != "." && entryStr != "..")
+	  {
+	    if( root != "") // dirs for current ("") already included
+	      {
+		DString testDir = root + entryStr;
+		int actStat = lstat( testDir.c_str(), &statStruct);
+		if( S_ISDIR(statStruct.st_mode) != 0)
+		    recurDir.push_back( testDir);
+	      }
+
+	    // dirs are also returned if they match
+	    int match = fnmatch( pat.c_str(), entryStr.c_str(), fnFlags);
+	    if( match == 0)
+	      fL.push_back( prefix + entryStr);
+	  }
+      }
+
+    int c = closedir( dir);
+    if( c == -1)
+      if( accErr)
+	throw GDLException( "FILE_SEARCH: Error closing dir: "+dirN);
+      else
+	return;
+
+    // recursive search
+    SizeT nRecur = recurDir.size();
+    for( SizeT d=0; d<nRecur; ++d)
+      {
+	//	cout << "Recursive looking in: " << recurDir[d] << endl;
+	PatternSearch( fL, recurDir[d], pat, accErr, quote, 
+		       match_dot,
+		       /*prefix +*/ recurDir[d]);
+      }
+  }
+
+  void FileSearch( FileListT& fL, const DString& s, 
+		   bool environment,
+		   bool tilde,
+		   bool accErr,
+		   bool mark,
+		   bool noSort,
+		   bool quote,
+		   bool dir,
+		   bool period)
+  {
+    int flags = 0;
+
+    if( environment)
+      flags |= GLOB_BRACE;
+    
+    if( tilde)
+      flags |= GLOB_TILDE;
+
+    if( accErr)
+      flags |= GLOB_ERR;
+    
+    if( mark && !dir) // only mark directory if not in dir mode
+      flags |= GLOB_MARK;
+
+    if( noSort)
+      flags |= GLOB_NOSORT;
+
+#if !defined(__APPLE__) && !defined(__FreeBSD__)
+    if( !quote) // n/a on OS X
+      flags |= GLOB_NOESCAPE;
+
+    if( dir) // simulate with lstat()
+      flags |= GLOB_ONLYDIR;
+
+    if( period) // n/a on OS X
+      flags |= GLOB_PERIOD;
+#else
+    struct stat    statStruct;
+#endif
+
+    glob_t p;
+    int gRes;
+    if( s == "")
+      gRes = glob( "*", flags, NULL, &p);
+    else
+      gRes = glob( s.c_str(), flags, NULL, &p);
+
+#ifndef __APPLE__
+    if( accErr && (gRes == GLOB_ABORTED || gRes == GLOB_NOSPACE))
+      throw GDLException( "FILE_SEARCH: Read error: "+s);
+#else
+    if( accErr && (gRes != 0 && p.gl_pathc > 0)) // NOMATCH is no error
+      throw GDLException( "FILE_SEARCH: Read error: "+s);
+#endif      
+
+    if( gRes == 0)
+      for( SizeT f=0; f<p.gl_pathc; ++f)
+	{
+#ifndef __APPLE__
+	  fL.push_back( p.gl_pathv[ f]);
+#else
+	  if( !dir)
+	    fL.push_back( p.gl_pathv[ f]);
+	  else
+	    { // push only if dir
+	      int actStat = lstat( p.gl_pathv[ f], &statStruct);
+	      if( S_ISDIR(statStruct.st_mode) != 0)
+		fL.push_back( p.gl_pathv[ f]);
+	    }
+#endif      
+	}
+    globfree( &p);
+
+    if( s == "" && dir)
+      fL.push_back( "");
+  }
+
+  // not finished yet
+  BaseGDL* file_search( EnvT* e)
+  {
+    SizeT nParam=e->NParam(); // 0 -> "*"
+    
+    DStringGDL* pathSpec;
+    DString     recurPattern;
+
+    SizeT nPath = 0;
+
+    if( nParam > 0)
+      {
+	BaseGDL* p0 = e->GetParDefined( 0);
+	pathSpec = dynamic_cast<DStringGDL*>( p0);
+	if( pathSpec == NULL)
+	  e->Throw( "String expression required in this context.");
+
+	nPath = pathSpec->N_Elements();
+
+	if( nParam > 1)
+	  e->AssureScalarPar< DStringGDL>( 1, recurPattern);
+      }
+
+    // unix defaults
+    bool tilde = true;
+    bool environment = true;
+    bool fold_case = false;
+
+    // keywords
+    // next three have default behaviour
+    static int tildeIx = e->KeywordIx( "EXPAND_TILDE");
+    bool tildeKW = e->KeywordPresent( tildeIx);
+    if( tildeKW) tilde = e->KeywordSet( tildeIx);
+
+    static int environmentIx = e->KeywordIx( "EXPAND_ENVIRONMENT");
+    bool environmentKW = e->KeywordPresent( environmentIx);
+    if( environmentKW) 
+      {
+	environment = e->KeywordSet( environmentIx);
+	if( environment) // only warn when expiclitely set
+	  Warning( "FILE_SEARCH: EXPAND_ENVIRONMENT not supported.");
+      }
+
+    static int fold_caseIx = e->KeywordIx( "FOLD_CASE");
+    bool fold_caseKW = e->KeywordPresent( fold_caseIx);
+    if( fold_caseKW) fold_case = e->KeywordSet( fold_caseIx);
+
+    // 
+    static int countIx = e->KeywordIx( "COUNT");
+    bool countKW = e->KeywordPresent( countIx);
+
+    static int accerrIx = e->KeywordIx( "ISSUE_ACCESS_ERROR");
+    bool accErr = e->KeywordSet( accerrIx);
+
+    static int markIx = e->KeywordIx( "MARK_DIRECTORY");
+    bool mark = e->KeywordSet( markIx);
+
+    static int nosortIx = e->KeywordIx( "NOSORT");
+    bool noSort = e->KeywordSet( nosortIx);
+
+    static int quoteIx = e->KeywordIx( "QUOTE");
+    bool quote = e->KeywordSet( quoteIx);
+
+    static int match_dotIx = e->KeywordIx( "MATCH_INITIAL_DOT");
+    bool match_dot = e->KeywordSet( match_dotIx);
+
+    static int match_all_dotIx = e->KeywordIx( "MATCH_ALL_INITIAL_DOT");
+    bool match_all_dot = e->KeywordSet( match_all_dotIx);
+
+    // ...
+    if( fold_case)
+      Warning( "FILE_SEARCH: FOLD_CASE keyword ignored (not supported).");
+    if( match_all_dot)
+      Warning( "FILE_SEARCH: MATCH_ALL_INITIAL_DOT keyword ignored (not supported).");
+
+    bool onlyDir = nParam > 1;
+
+    FileListT fileList;
+
+    if( nPath == 0)
+      FileSearch( fileList, "", 
+		  environment, tilde, 
+		  accErr, mark, noSort, quote, onlyDir, match_dot);
+    else
+      FileSearch( fileList, (*pathSpec)[0],
+		  environment, tilde, 
+		  accErr, mark, noSort, quote, onlyDir, match_dot);
+    
+    for( SizeT f=1; f < nPath; ++f) 
+      FileSearch( fileList, (*pathSpec)[f],
+		  environment, tilde, 
+		  accErr, mark, noSort, quote, onlyDir, match_dot);
+
+    DLong count = fileList.size();
+
+    if( onlyDir)
+      { // recursive search for recurPattern
+	FileListT fileOut;
+	
+	for( SizeT f=0; f<count; ++f) // ok for count == 0
+	  {
+	    //	    cout << "Looking in: " << fileList[f] << endl;
+	    PatternSearch( fileOut, fileList[f], recurPattern, accErr, quote,
+			   match_dot,
+			   fileList[f]);
+	  }	
+
+	DLong pCount = fileOut.size();
+	
+	if( countKW)
+	  e->SetKW( countIx, new DLongGDL( pCount));
+
+	if( pCount == 0)
+	  return new DStringGDL("");
+
+	if( !noSort)
+	  sort( fileOut.begin(), fileOut.end());
+    
+	// fileOut -> res
+	DStringGDL* res = new DStringGDL( dimension( pCount), BaseGDL::NOZERO);
+	for( SizeT r=0; r<pCount; ++r)
+	  (*res)[r] = fileOut[ r];
+
+	return res;
+      }
+
+    if( countKW)
+      e->SetKW( countIx, new DLongGDL( count));
+
+    if( count == 0)
+      return new DStringGDL("");
+    
+    if( !noSort)
+      sort( fileList.begin(), fileList.end());
+
+    // fileList -> res
+    DStringGDL* res = new DStringGDL( dimension( count), BaseGDL::NOZERO);
+    for( SizeT r=0; r<count; ++r)
+      (*res)[r] = fileList[ r];
+
+    return res;
+  }
+
+
+}
+
+//#endif
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdlc.g cvs/gdl/src/gdlc.g
--- gdl-0.9rc4/src/gdlc.g	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdlc.g	2010-04-22 09:50:40.000000000 -0600
@@ -44,7 +44,7 @@
 //#include "dinterpreter.hpp"
 
 // defintion in dinterpreter.cpp
-void SetActualCompileOpt( unsigned int cOpt);
+//void SetActualCompileOpt( unsigned int cOpt);
 }
 
 options {
@@ -73,6 +73,7 @@
 	ASSIGN;
 	ASSIGN_INPLACE;
 	ASSIGN_REPLACE;
+    ASSIGN_ARRAYEXPR_MFCALL;
 	ARRAYDEF;
 	ARRAYDEF_CONST;
 	ARRAYIX;
@@ -83,8 +84,10 @@
 	ARRAYIX_RANGE_S;
 	ARRAYEXPR;
 	ARRAYEXPR_FN;
+	ARRAYEXPR_MFCALL;
 	BLOCK;
     BREAK;
+	CSBLOCK;
     CONTINUE;
 	COMMONDECL;
 	COMMONDEF;
@@ -92,9 +95,15 @@
 	DEREF;
 	ELSEBLK;
 	EXPR;
+    FOR;
     FOR_STEP; // for with step
+    FOREACH;
+    FOR_LOOP;
+    FOR_STEP_LOOP; // for with step
+    FOREACH_LOOP;
 	FCALL;
 	FCALL_LIB; // library function call
+// 	FCALL_LIB_N_ELEMENTS; // N_ELEMENTS
 	FCALL_LIB_RETNEW; // library function call always return newly allocated data
     IF_ELSE;
 	KEYDECL;
@@ -126,6 +135,8 @@
     REF;        // expr pass by reference
     REF_CHECK;  // expr maybe be passed by reference
     REF_EXPR;   // assign/dec/inc expr passed by reference
+    REPEAT;
+    REPEAT_LOOP;
     RETURN;  // unspecified return (replaced by tree parser with RETF/RETP)
   	RETF;    // return from function (return argument)
   	RETP;    // return from procedure (no return argument)
@@ -135,6 +146,7 @@
 	UMINUS;
 	VAR;     // varaible, referenced through index
 	VARPTR;  // variable, referenced through pointer
+    WHILE;
 }
 
 {
@@ -166,7 +178,7 @@
         else if( opt == "IDL2")              compileOpt |= IDL2;
         else if( opt == "STRICTARRSUBS")     compileOpt |= STRICTARRSUBS;
         else throw GDLException("Unrecognised COMPILE_OPT option: "+opt);
-        SetActualCompileOpt( compileOpt);
+//        SetActualCompileOpt( compileOpt);
     }
 
     std::string subName; // name of procedure function to be compiled ("" -> all file)
@@ -206,12 +218,14 @@
     | end:ENDCASE { #end->setType( IDENTIFIER);}
     | ende:ENDELSE { #ende->setType( IDENTIFIER);}
     | endf:ENDFOR { #endf->setType( IDENTIFIER);}
+    | endfe:ENDFOREACH { #endf->setType( IDENTIFIER);}
     | endi:ENDIF { #endi->setType( IDENTIFIER);}
     | endr:ENDREP { #endr->setType( IDENTIFIER);}
     | ends:ENDSWITCH { #ends->setType( IDENTIFIER);}
     | endw:ENDWHILE { #endw->setType( IDENTIFIER);}
     | eq:EQ_OP { #eq->setType( IDENTIFIER);}
     | f:FOR { #f->setType( IDENTIFIER);}
+    | fe:FOREACH { #f->setType( IDENTIFIER);}
     | fo:FORWARD { #fo->setType( IDENTIFIER);}
     | fu:FUNCTION { #fu->setType( IDENTIFIER);}
     | g:GE_OP { #g->setType( IDENTIFIER);}
@@ -515,10 +529,15 @@
 	| ENDCASE
 	| ENDSWITCH
 	| ENDFOR
+	| ENDFOREACH
 	| ENDWHILE
 	| ENDREP
 	;
 
+endforeach_mark!
+	: ENDFOREACH | ENDFOR | END
+	;
+
 endfor_mark!
 	: ENDFOR | END
 	;
@@ -586,8 +605,87 @@
     bool parent=false;
 }
     : (assign_expr)=> assign_expr (DEC^ | INC^)?
-    | (deref_expr 
-			// assignment
+//     | (deref_expr_dot)=>
+//       (deref_expr 
+// 			// assignment
+// 			(EQUAL! expr 			
+//                 { #statement = #([ASSIGN,":="], #statement);}
+//             |   ( AND_OP_EQ^ 
+//                 | ASTERIX_EQ^ 
+//                 | EQ_OP_EQ^ 
+//                 | GE_OP_EQ^
+//                 | GTMARK_EQ^
+//                 | GT_OP_EQ^
+//                 | LE_OP_EQ^
+//                 | LTMARK_EQ^
+//                 | LT_OP_EQ^
+//                 | MATRIX_OP1_EQ^
+//                 | MATRIX_OP2_EQ^
+//                 | MINUS_EQ^
+//                 | MOD_OP_EQ^
+//                 | NE_OP_EQ^
+//                 | OR_OP_EQ^
+//                 | PLUS_EQ^
+//                 | POW_EQ^
+//                 | SLASH_EQ^
+//                 | XOR_OP_EQ^) expr
+// 			| (DEC^ | INC^) // no POSTDEC/POSTINC for statements			
+// 			| MEMBER! // member procedure call 
+//                 (baseclass_method { parent=true; })? 
+//                 formal_procedure_call
+// 				{ 
+//                     if( parent)
+//                         #statement = #([MPCALL_PARENT, "mpcall::"], 
+//                                         #statement);
+//                     else
+//                         #statement = #([MPCALL, "mpcall"], #statement);
+//                 }
+//             | // empty -> member procedure call with DOT parsed by tag_access
+//             )
+//       )
+
+
+    | (deref_dot_expr_keeplast IDENTIFIER COMMA)=>
+        d1:deref_dot_expr_keeplast formal_procedure_call
+				{ 
+                        #statement = #([MPCALL, "mpcall"], #statement);
+                        #statement->SetLine( #d1->getLine());
+
+                }
+    | (deref_dot_expr_keeplast baseclass_method)=>
+        d2:deref_dot_expr_keeplast baseclass_method formal_procedure_call
+				{ 
+                        #statement = #([MPCALL_PARENT, "mpcall::"], 
+                                        #statement);
+                        #statement->SetLine( #d2->getLine());
+                }
+    | ( deref_expr
+                ( EQUAL
+                | AND_OP_EQ^ 
+                | ASTERIX_EQ^ 
+                | EQ_OP_EQ^ 
+                | GE_OP_EQ^
+                | GTMARK_EQ^
+                | GT_OP_EQ^
+                | LE_OP_EQ^
+                | LTMARK_EQ^
+                | LT_OP_EQ^
+                | MATRIX_OP1_EQ^
+                | MATRIX_OP2_EQ^
+                | MINUS_EQ^
+                | MOD_OP_EQ^
+                | NE_OP_EQ^
+                | OR_OP_EQ^
+                | PLUS_EQ^
+                | POW_EQ^
+                | SLASH_EQ^
+                | XOR_OP_EQ^
+                | DEC^  
+                | INC^ // no POSTDEC/POSTINC for statements			
+                | MEMBER! // member procedure call 
+                )
+      )=>
+        deref_expr
 			(EQUAL! expr 			
                 { #statement = #([ASSIGN,":="], #statement);}
             |   ( AND_OP_EQ^ 
@@ -610,7 +708,7 @@
                 | SLASH_EQ^
                 | XOR_OP_EQ^) expr
 			| (DEC^ | INC^) // no POSTDEC/POSTINC for statements			
-			| MEMBER! // member procedure call 
+            | MEMBER! // member procedure call 
                 (baseclass_method { parent=true; })? 
                 formal_procedure_call
 				{ 
@@ -621,12 +719,18 @@
                         #statement = #([MPCALL, "mpcall"], #statement);
                 }
 			)
-		)
+    | // (deref_dot_expr_keeplast IDENTIFIER)=>
+      d3:deref_dot_expr_keeplast formal_procedure_call
+				{ 
+                    #statement = #([MPCALL, "mpcall"], #statement);
+                    #statement->SetLine( #d3->getLine());
+                }
     | (DEC^ | INC^) expr
 	| procedure_call // next two handled by procedure_call also
 //	| BREAK     // only valid in loops and switch_statement
 //	| CONTINUE  // only valid in loops
 	| for_statement 
+	| foreach_statement 
 	| repeat_statement
 	| while_statement
 	| jump_statement
@@ -674,7 +778,6 @@
 		for_block
 	;
 
-
 for_block
 	: st:statement
 		{ #for_block = #([BLOCK, "block"], #st);}
@@ -682,6 +785,18 @@
 		{ #for_block = #([BLOCK, "block"], #stl);}
 	;	
 
+foreach_statement
+	: FOREACH^ IDENTIFIER OF! expr DO!
+		foreach_block
+	;
+
+foreach_block
+	: st:statement
+		{ #foreach_block = #([BLOCK, "block"], #st);}
+	| BEGIN! stl:statement_list endforeach_mark
+		{ #foreach_block = #([BLOCK, "block"], #stl);}
+	;	
+
 jump_statement
 	: GOTO^ COMMA! IDENTIFIER
 // now handled as a procedure_call because RETURN is no reserved word
@@ -1185,15 +1300,100 @@
 		)
 	;	
 
+tag_access_keeplast returns [int nDot]
+// {
+//     nDot=0;
+//     SizeT dotCount = 0 ;
+//     int last;
+// }
+// 	: 
+//         (options {greedy=true;}: DOT! { ++nDot;} tag_array_expr_nth)+
+//     ;
+{
+    int t;
+    bool parent = false;
+    nDot=1;
+}
+	: DOT!
+        (
+            (tag_array_expr_nth tag_access_keeplast)=>
+                    (tag_array_expr_nth t=tag_access_keeplast { nDot += t;})
+        |   //(tag_array_expr_nth DOT tag_array_expr_nth)=> 
+            //        (tag_array_expr_nth)
+        )
+    ;
+
+// // can be an array expr
+// deref_expr_dot // only used in predicate
+// 	: array_expr_1st t=tag_access
+//     | ASTERIX! deref_expr_dot
+//         { #deref_expr = 
+// 			#([DEREF,"deref"], #deref_expr);}
+// 	;
+
+deref_dot_expr_keeplast
+{
+    RefDNode dot;
+    int nDot;
+}
+	: a1:array_expr_1st 
+        (// (tag_access_keeplast)=>
+        nDot=tag_access_keeplast
+            { 
+                if( --nDot > 0)
+                    {
+                        dot=#[DOT,"."];
+                        dot->SetNDot( nDot);    
+                        dot->SetLine( #a1->getLine());
+                        #deref_dot_expr_keeplast = #(dot, #deref_dot_expr_keeplast);
+                    }
+            }		
+//      |   { #deref_dot_expr_keeplast = #a1;}
+        )
+    | ASTERIX! deref_dot_expr_keeplast
+        { #deref_dot_expr_keeplast = 
+			#([DEREF,"deref"], #deref_dot_expr_keeplast);}
+	;
+// {
+//     RefDNode dot;
+//     SizeT nDot = 1;
+// }
+//     :
+//  (array_expr_1st tag_access_keeplast)=> 
+//       a1:array_expr_1st
+//         ( /*(tag_access_keeplast)=>*/ nDot=tag_access_keeplast
+//             { 
+//                 dot=#[DOT,"."];
+//                 dot->SetNDot( nDot);    
+//                 dot->SetLine( #a1->getLine());
+
+//                 #deref_dot_expr_keeplast = #(dot, #deref_dot_expr_keeplast);
+//             }
+//         )
+//     |
+//  (array_expr_1st DOT tag_array_expr_nth)=> 
+//       array_expr_1st 
+// //        {/*xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx*/}
+// //             {
+// //                 dot=#[DOT,"."];
+// //                 dot->SetNDot( nDot);    
+// //                 dot->SetLine( #a1->getLine());
+
+// //                 #deref_dot_expr_keeplast = #(dot, #deref_dot_expr_keeplast);
+// //             }
+//     | ASTERIX! deref_dot_expr_keeplast
+//         { #deref_dot_expr_keeplast = 
+// 			#([DEREF,"deref"], #deref_dot_expr_keeplast);}
+// ;
+
 tag_access returns [SizeT nDot]
 {
     nDot=0;
 }
-	: (DOT! { nDot++;} tag_array_expr_nth)+
+	: (options {greedy=true;}: DOT! { ++nDot;} tag_array_expr_nth)+
     ;
 
-// can be an array expr
-deref_expr //!
+deref_dot_expr
 {
     RefDNode dot;
     SizeT nDot;
@@ -1207,6 +1407,29 @@
                 dot->SetNDot( nDot);    
                 dot->SetLine( #a1->getLine());
 
+                #deref_dot_expr = #(dot, #deref_dot_expr);
+            }		
+//        |   { #deref_expr = #a1;}
+        )
+    | ASTERIX! deref_dot_expr
+        { #deref_dot_expr = 
+			#([DEREF,"deref"], #deref_dot_expr);}
+	;
+
+deref_expr
+{
+    RefDNode dot;
+    SizeT nDot;
+}
+//	: array_expr_1st (DOT array_expr_nth)*
+	: a1:array_expr_1st 
+        ((tag_access)=> nDot=tag_access
+            { 
+
+                dot=#[DOT,"."];
+                dot->SetNDot( nDot);    
+                dot->SetLine( #a1->getLine());
+
                 #deref_expr = #(dot, #deref_expr);
             }		
         |   { #deref_expr = #a1;}
@@ -1216,36 +1439,42 @@
 			#([DEREF,"deref"], #deref_expr);}
 	;
 
+// array or member function (only to be used in primary_expr)
+// array_expr_mfcall!
+//     : v:var al:arrayindex_list 
+//     ;
+
 // array or function (only to be used in primary_expr)
-array_expr_fn!//
-{
-    RefDNode dot, t;
-    SizeT nDot;
-}
-    : v:var al:arrayindex_list 
-        ( nDot=tag_access // must be a variable with index list
-            {          // -> do so 
-            t= RefDNode(returnAST);    
-
-            dot=#[DOT,"."];
-            dot->SetNDot( nDot);    
-            dot->SetLine( #al->getLine());
+//array_expr_fn
+// {
+//     RefDNode dot;//, t;
+//     SizeT nDot;
+// }
+//    : v:var al:arrayindex_list 
+//         ( (tag_access)=> nDot=t:tag_access // must be a variable with index list
+//             {          // -> do so 
+//             //t= RefDNode(returnAST);    
+
+//             dot=#[DOT,"."];
+//             dot->SetNDot( nDot);    
+//             dot->SetLine( #al->getLine());
   
-            #array_expr_fn = 
-	  		#(dot, ([ARRAYEXPR,"arrayexpr"], #v, #al), #t);} 
+//             #array_expr_fn = 
+// 	  		#(dot, ([ARRAYEXPR,"arrayexpr"], #v, #al), #t);} 
 
-        | // still ambiguous
-            { #array_expr_fn = 
-	  		#([ARRAYEXPR_FN,"arrayexpr_fn"], #v, #al);}
+//         | // still ambiguous
 //	  		#([ARRAYEXPR_FN,"arrayexpr_fn"], #array_expr_fn);}
-        )
-	;	
+//      )
+//	;	
 
 
 member_function_call returns [bool parent]
 	: { parent = false;} MEMBER! 
         (IDENTIFIER METHOD! { parent = true;} )? formal_function_call
   	;
+member_function_call_dot
+	:  DOT! (IDENTIFIER METHOD!) formal_function_call
+  	;
 
 assign_expr
     : LBRACE! deref_expr EQUAL! expr RBRACE! // assignment
@@ -1257,30 +1486,89 @@
 {
     bool parent;
 }
-	:   // ambiguity (arrayexpr or fcall)
-		(IDENTIFIER LBRACE expr (COMMA expr)* RBRACE)=>
+	   
+    : 
+        // with METHOD
+        (deref_dot_expr_keeplast baseclass_method)=>
+        d1:deref_dot_expr_keeplast baseclass_method formal_function_call
+        {
+            #primary_expr = #([MFCALL_PARENT, "mfcall::"], #primary_expr);
+        }   
+    | 
+        // ambiguity (arrayexpr or mfcall)
+        (deref_dot_expr_keeplast 
+            (IDENTIFIER LBRACE expr (COMMA expr)* RBRACE))=>
+        d2:deref_dot_expr_keeplast 
+            // here it is impossible to decide about function call
+            // as we do not know the object type/struct tag
+            IDENTIFIER arrayindex_list 
+            { #primary_expr = #([ARRAYEXPR_MFCALL,"arrayexpr_mfcall"], #primary_expr);}
+    | 
+        // not the above -> unambigous mfcall (or unambigous array expr handled below)
+        (deref_dot_expr_keeplast formal_function_call)=> 
+        d3:deref_dot_expr_keeplast 
+            // here it is impossible to decide about function call
+            // as we do not know the object type/struct tag
+            formal_function_call
+			{ #primary_expr = #([MFCALL, "mfcall"], #primary_expr);}
+	|   // a member function call starts with a deref_expr 
+ 		(deref_dot_expr)=>
+        // same parsing as (deref_expr)=> see below
+		deref_expr 
+        ( parent=member_function_call
+            { 
+                if( parent)
+                {
+                    #primary_expr = #([MFCALL_PARENT, "mfcall::"], #primary_expr);
+                }
+                else
+                {
+                    #primary_expr = #([MFCALL, "mfcall"], #primary_expr);
+                }
+            }
+        | // empty -> array expression
+        )
+    |   
+        // ambiguity (arrayexpr or fcall)
+        (IDENTIFIER LBRACE expr (COMMA expr)* RBRACE)=>
 		(
 			// already known function 
 			// (could be reordered, but this is conform to original)
 			{ IsFun(LT(1))}? formal_function_call
-			{ #primary_expr = #([FCALL, "fcall"], #primary_expr);}
+			{ 
+//                 if( StrUpCase(#i->getText) == "N_ELEMENTS")
+//                     #primary_expr = #([FCALL_LIB_N_ELEMENTS, "fcall_n_elements"], #primary_expr);
+//                 else
+                   #primary_expr = #([FCALL, "fcall"], #primary_expr);
+            }
 		| 
-            // no function call (fcall cannot be followed by MEMBER or DOT)
-	  		array_expr_fn
-	  		( parent=member_function_call
-				{ 
-                    if( parent)
-                    {
-                        #primary_expr = 
-                        #([MFCALL_PARENT, "mfcall::"], #primary_expr);
-                    }
-                    else
-                    {
-                        #primary_expr = 
-                        #([MFCALL, "mfcall"], #primary_expr);
-                    }
-                }
-	  		)?		
+            // still ambiguity (arrayexpr or fcall)
+            var arrayindex_list     // array_expr_fn
+            { #primary_expr = #([ARRAYEXPR_FN,"arrayexpr_fn"], #primary_expr);}
+// 	  		( parent=member_function_call
+// 				{ 
+//                     if( parent)
+//                     {
+//                         #primary_expr = 
+//                         #([MFCALL_PARENT, "mfcall::"], #primary_expr);
+//                     }
+//                     else
+//                     {
+//                         #primary_expr = 
+//                         #([MFCALL, "mfcall"], #primary_expr);
+//                     }
+//                 }
+// 	  		| (DOT IDENTIFIER METHOD)=> member_function_call_dot
+//                     {
+//                         #primary_expr = 
+//                         #([MFCALL_PARENT, "mfcall::"], #primary_expr);
+//                     }
+//             | DOT! formal_function_call
+//                 {
+//                     #primary_expr = #([MFCALL, "mfcall"], #primary_expr);
+//                 }
+//             |
+//          )		
 // commented out to leave checking to tree parser (if MEMBER and DOT are
 // present it could be decided already here if it can be a FCALL)
 //		|
@@ -1292,9 +1580,9 @@
 	|   // not the above => keyword parameter (or no args) => function call
 		(formal_function_call)=> formal_function_call
 		{ #primary_expr = #([FCALL, "fcall"], #primary_expr);}
-    
 	|   // a member function call starts with a deref_expr 
-		(deref_expr)=>
+        // deref_dot_expr already failed
+ 		(deref_expr)=>
 		deref_expr 
         ( parent=member_function_call
             { 
@@ -1307,7 +1595,17 @@
                     #primary_expr = #([MFCALL, "mfcall"], #primary_expr);
                 }
             }
-        )?
+// 	  	| (DOT IDENTIFIER METHOD)=> member_function_call_dot
+//                     {
+//                         #primary_expr = 
+//                         #([MFCALL_PARENT, "mfcall::"], #primary_expr);
+//                     }
+//         | DOT! formal_function_call
+//                 {
+//                     #primary_expr = #([MFCALL, "mfcall"], #primary_expr);
+//                 }
+        | // empty -> array expression
+        )
 	|! sl:STRING_LITERAL // also a CONSTANT
 		{ #primary_expr=#[CONSTANT,sl->getText()];
             #primary_expr->Text2String();	
@@ -1477,12 +1775,14 @@
 	ENDCASE="endcase";
 	ENDELSE="endelse";
 	ENDFOR="endfor";
+	ENDFOREACH="endforeach";
 	ENDIF="endif";
 	ENDREP="endrep";
 	ENDSWITCH="endswitch";
 	ENDWHILE="endwhile";
 	EQ_OP="eq";
 	FOR="for";
+	FOREACH="foreach";
 	FORWARD="forward_function";
 	FUNCTION="function";
 	GE_OP="ge";
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdlc.i.g cvs/gdl/src/gdlc.i.g
--- gdl-0.9rc4/src/gdlc.i.g	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdlc.i.g	2010-05-21 10:23:57.195908800 -0600
@@ -1,3 +1,12 @@
+
+
+
+
+
+
+
+
+
 /* *************************************************************************
                           gdlc.i.g 
 the GDL interpreter
@@ -35,29 +44,6 @@
 #define RefAST( xxx)     ConvertAST( xxx) /* antlr::RefAST( Ref type)  */
 #define match( a, b)     /* remove from source */
 
-// optimizations
-// #define  constant constantNotOptimized
-// #define  interactive interactiveNotOptimized
-// #define  statement_list statement_listNotOptimized
-// #define  execute executeNotOptimized
-// #define  call_fun call_funNotOptimized
-// #define  call_lfun call_lfunNotOptimized
-// #define  call_pro call_proNotOptimized 
-// #define  block blockNotOptimized
-// #define  expr exprNotOptimized
-// #define  l_simple_var l_simple_varNotOptimized
-// #define  sys_var sys_varNotOptimized
-// #define  sys_var_nocopy sys_var_nocopyNotOptimized
-// #define  dot_expr dot_exprNotOptimized
-// #define  simple_var simple_varNotOptimized
-// #define  ref_parameter ref_parameterNotOptimized
-// #define  unnamed_struct_def unnamed_struct_defNotOptimized
-// #define  lib_function_call_retnew lib_function_call_retnewNotOptimized
-// #define  lib_function_call lib_function_callNotOptimized
-// #define  constant_nocopy constant_nocopyNotOptimized
-// #define  struct_def struct_defNotOptimized
-
-
 using namespace std;
 }
 
@@ -88,6 +74,7 @@
 // print out AST tree
 //#define GDL_DEBUG
 //#undef GDL_DEBUG
+//#define GDL_DEBUG_HEAP
 
 }
 
@@ -126,23 +113,35 @@
     friend class NSTRUCNode;
     friend class NSTRUC_REFNode;
     friend class ASSIGNNode;
+    friend class ASSIGN_ARRAYEXPR_MFCALLNode;
     friend class ASSIGN_REPLACENode;
-friend class PCALL_LIBNode;//: public CommandNode
-friend class MPCALLNode;//: public CommandNode
-friend class MPCALL_PARENTNode;//: public CommandNode
-friend class PCALLNode;//: public CommandNode
-
-  friend class KEYDEFNode;
-  friend class KEYDEF_REFNode;
-  friend class KEYDEF_REF_CHECKNode;
-  friend class KEYDEF_REF_EXPRNode;
-  friend class REFNode;
-  friend class REF_CHECKNode;
-  friend class REF_EXPRNode;
-  friend class ParameterNode;
+    friend class PCALL_LIBNode;//: public CommandNode
+    friend class MPCALLNode;//: public CommandNode
+    friend class MPCALL_PARENTNode;//: public CommandNode
+    friend class PCALLNode;//: public CommandNode
+    friend class RETFNode;
+    friend class RETPNode;
+    friend class FORNode;
+    friend class FOR_LOOPNode;
+    friend class FOREACHNode;
+    friend class FOREACH_LOOPNode;
+    friend class FOR_STEPNode;
+    friend class FOR_STEP_LOOPNode;
+    
+    friend class KEYDEFNode;
+    friend class KEYDEF_REFNode;
+    friend class KEYDEF_REF_CHECKNode;
+    friend class KEYDEF_REF_EXPRNode;
+    friend class REFNode;
+    friend class REF_CHECKNode;
+    friend class REF_EXPRNode;
+    friend class ParameterNode;
 
 public: 
+
 //     RetCode returnCode;    
+    ProgNodeP GetNULLProgNodeP() const { return NULLProgNodeP;}
+
 
     void SetRetTree( ProgNodeP rT)
     {
@@ -153,13 +152,13 @@
 //         this->returnCode = rC;
 //     }
     
-    enum RetCode {
-        RC_OK=0,
-        RC_BREAK,
-        RC_CONTINUE,
-        RC_RETURN, 
-        RC_ABORT, // checked as retCode >= RC_RETURN
-    };  
+//     enum RetCode {
+//         RC_OK=0,
+//         RC_BREAK,
+//         RC_CONTINUE,
+//         RC_RETURN, 
+//         RC_ABORT, // checked as retCode >= RC_RETURN
+//     };  
 
     // code in: dinterpreter.cpp
     static bool SearchCompilePro(const std::string& pro);
@@ -170,9 +169,12 @@
     DStructGDL* ObjectStruct( BaseGDL* self, ProgNodeP mp);
     DStructGDL* ObjectStructCheckAccess( BaseGDL* self, ProgNodeP mp);
 
-private: 
     // code in: dinterpreter.cpp
     static void SetFunIx( ProgNodeP f); // triggers read/compile
+
+
+private: 
+
     static void SetProIx( ProgNodeP f); // triggers read/compile
     static void AdjustTypes( BaseGDL*&, BaseGDL*&);
 
@@ -208,14 +210,24 @@
     
     // code in: dinterpreter.cpp
 //    static bool CompleteFileName(std::string& fn); -> str.cpp
-    static bool CompileFile(const std::string& f, const std::string& untilPro=""); 
+
     BaseGDL*  returnValue;  // holding the return value for functions
     BaseGDL** returnValueL; // holding the return value for l_functions
 
     bool interruptEnable;
 
-    typedef std::map<SizeT, BaseGDL*> HeapT;
-    typedef std::map<SizeT, DStructGDL*> ObjHeapT;
+public:
+    static bool CompileFile(const std::string& f, const std::string& untilPro=""); 
+
+    typedef RefHeap<BaseGDL> RefBaseGDL;
+    typedef RefHeap<DStructGDL> RefDStructGDL;
+
+    typedef std::map<SizeT, RefBaseGDL> HeapT;
+    typedef std::map<SizeT, RefDStructGDL> ObjHeapT;
+
+protected:
+//     typedef std::map<SizeT, BaseGDL*> HeapT;
+//     typedef std::map<SizeT, DStructGDL*> ObjHeapT;
 
     // the following must be all static because several interpreter might be active
     // the heap for all dynamic variables
@@ -244,7 +256,7 @@
         SizeT tmpIx=objHeapIx;
         for( SizeT i=0; i<n; i++)
         objHeap.insert( objHeap.end(),
-            std::pair<SizeT, DStructGDL*>( objHeapIx++, var));
+            std::pair<SizeT, RefDStructGDL>( objHeapIx++, (DStructGDL*)var));
         return tmpIx;
     }
     SizeT NewHeap( SizeT n=1, BaseGDL* var=NULL)
@@ -252,7 +264,7 @@
         SizeT tmpIx=heapIx;
         for( SizeT i=0; i<n; i++)
         heap.insert( heap.end(),
-            std::pair<SizeT, BaseGDL*>( heapIx++, var));
+            std::pair<SizeT, RefBaseGDL>( heapIx++, var));
         return tmpIx;
     }
     static void FreeObjHeap( DObj id)
@@ -262,11 +274,16 @@
             ObjHeapT::iterator it=objHeap.find( id);
             if  ( it != objHeap.end()) 
             { 
-                delete (*it).second;
+                delete (*it).second.get();
                 objHeap.erase( id);
             }
         }
     }
+    static void FreeObjHeapDirect( DObj id, ObjHeapT::iterator it)
+    {
+        delete (*it).second.get();
+        objHeap.erase( id);
+    }
     static void FreeHeap( DPtr id)
     {
         if( id != 0)
@@ -274,11 +291,16 @@
                 HeapT::iterator it=heap.find( id);
                 if( it != heap.end()) 
                     { 
-                        delete (*it).second;
+                        delete (*it).second.get();
                         heap.erase( id); 
                     }
             }
     }
+    static void FreeHeapDirect( DPtr id, HeapT::iterator it)
+    {
+        delete (*it).second.get();
+        heap.erase( id); 
+    }
 
    static void FreeHeap( DPtrGDL* p)
     {
@@ -290,19 +312,176 @@
        }
     }
 
+   static void DecRef( DPtr id)
+    {
+        if( id != 0)
+            {
+#ifdef GDL_DEBUG_HEAP
+                std::cout << "-- <PtrHeapVar" << id << ">" << std::endl; 
+#endif
+                HeapT::iterator it=heap.find( id);
+                if( it != heap.end()) 
+                    { 
+                        if( (*it).second.Dec())
+                            {
+                                std::cout << "Out of scope (garbage collected): <PtrHeapVar" << id 
+                                          << ">"
+                                          << " at: " << callStack.back()->GetProName()
+                                          << "  line: " << callStack.back()->GetLineNumber()
+                                          << std::endl; 
+                                FreeHeapDirect( id, it);
+                            }
+#ifdef GDL_DEBUG_HEAP
+                        else
+std::cout << "<PtrHeapVar" << id << "> = " << (*it).second.Count() << std::endl; 
+#endif
+                    }
+            }
+    }
+   static void DecRef( DPtrGDL* p)
+    {
+        SizeT nEl=p->N_Elements();
+        for( SizeT ix=0; ix < nEl; ix++)
+        {
+            DPtr id= (*p)[ix];
+            DecRef( id);
+       }
+    }
+   static void DecRefObj( DObj id)
+    {
+        if( id != 0)
+            {
+#ifdef GDL_DEBUG_HEAP
+std::cout << "-- <ObjHeapVar" << id << ">" << std::endl; 
+#endif
+                ObjHeapT::iterator it=objHeap.find( id);
+                if( it != objHeap.end()) 
+                    { 
+                       if( (*it).second.Dec())
+                           {
+                               std::cout << "Out of scope (garbage collected): <ObjHeapVar" << id 
+                                          << ">"
+                                          << " at: " << callStack.back()->GetProName()
+                                          << "  line: " << callStack.back()->GetLineNumber()
+                                          << std::endl; 
+                               callStack.back()->ObjCleanup( id);
+//                             FreeObjHeapDirect( id, it);
+                           }
+#ifdef GDL_DEBUG_HEAP
+                        else
+std::cout << "<ObjHeapVar" << id << "> = " << (*it).second.Count() << std::endl; 
+#endif
+                        
+                     }
+            }
+    }
+   static void DecRefObj( DObjGDL* p)
+    {
+        SizeT nEl=p->N_Elements();
+        for( SizeT ix=0; ix < nEl; ix++)
+        {
+            DObj id= (*p)[ix];
+            DecRefObj( id);
+       }
+    }
+   static void IncRef( DPtr id)
+    {
+        if( id != 0)
+            {
+#ifdef GDL_DEBUG_HEAP
+std::cout << "++ <PtrHeapVar" << id << ">" << std::endl; 
+#endif
+                HeapT::iterator it=heap.find( id);
+                if( it != heap.end()) 
+                    { 
+                        (*it).second.Inc(); 
+#ifdef GDL_DEBUG_HEAP
+std::cout << "<PtrHeapVar" << id << "> = " << (*it).second.Count() << std::endl; 
+#endif
+                    }
+            }
+    }
+   static void AddRef( DPtr id, SizeT add)
+    {
+        if( id != 0)
+            {
+#ifdef GDL_DEBUG_HEAP
+std::cout << add << " + <PtrHeapVar" << id << ">" << std::endl; 
+#endif
+                HeapT::iterator it=heap.find( id);
+                if( it != heap.end()) 
+                    { 
+                        (*it).second.Add(add); 
+                    }
+            }
+    }
+   static void IncRef( DPtrGDL* p)
+    {
+        SizeT nEl=p->N_Elements();
+        for( SizeT ix=0; ix < nEl; ix++)
+        {
+            DPtr id= (*p)[ix];
+            IncRef( id);
+       }
+    }
+   static void IncRefObj( DObj id)
+    {
+        if( id != 0)
+            {
+#ifdef GDL_DEBUG_HEAP
+std::cout << "++ <ObjHeapVar" << id << ">" << std::endl; 
+#endif
+                ObjHeapT::iterator it=objHeap.find( id);
+                if( it != objHeap.end()) 
+                    { 
+                        (*it).second.Inc(); 
+                    }
+            }
+    }
+   static void AddRefObj( DObj id, SizeT add)
+    {
+        if( id != 0)
+            {
+#ifdef GDL_DEBUG_HEAP
+std::cout << add << " + <ObjHeapVar" << id << ">" << std::endl; 
+#endif
+                ObjHeapT::iterator it=objHeap.find( id);
+                if( it != objHeap.end()) 
+                    { 
+                        (*it).second.Add(add); 
+                    }
+            }
+    }
+   static void IncRefObj( DObjGDL* p)
+    {
+        SizeT nEl=p->N_Elements();
+        for( SizeT ix=0; ix < nEl; ix++)
+        {
+            DObj id= (*p)[ix];
+            IncRefObj( id);
+       }
+    }
+
     class HeapException {};
 
     static BaseGDL*& GetHeap( DPtr ID)
     {
         HeapT::iterator it=heap.find( ID);
         if( it == heap.end()) throw HeapException();
-        return it->second;
+        return it->second.get();
     }
     static DStructGDL*& GetObjHeap( DObj ID)
     {
         ObjHeapT::iterator it=objHeap.find( ID);
         if( it == objHeap.end()) throw HeapException();
-        return it->second;
+        return it->second.get();
+    }
+    static DStructGDL*& GetObjHeap( DObj ID, ObjHeapT::iterator& it)
+    {
+//         ObjHeapT::iterator it=objHeap.find( ID);
+        it=objHeap.find( ID);
+        if( it == objHeap.end()) throw HeapException();
+        return it->second.get();
     }
 
     static bool PtrValid( DPtr ID)
@@ -316,6 +495,15 @@
         return heap.size();
     }
 
+    static DPtr FindInHeap( BaseGDL** p)
+    {
+        for( HeapT::iterator it=heap.begin(); it != heap.end(); ++it)
+        {
+            if( &it->second.get() == p)
+                return it->first;
+        }
+        return 0;
+    }
     static DPtrGDL* GetAllHeap()
     {
         SizeT nEl = heap.size();
@@ -324,6 +512,21 @@
         SizeT i=0;
         for( HeapT::iterator it=heap.begin(); it != heap.end(); ++it)
         {
+            IncRef( it->first);
+            (*ret)[ i++] = it->first;
+        }
+        return ret;
+    }
+
+    // no ref counting here
+    static std::vector<DPtr>* GetAllHeapSTL()
+    {
+        SizeT nEl = heap.size();
+        if( nEl == 0) return new std::vector<DPtr>();
+        std::vector<DPtr>* ret = new std::vector<DPtr>( nEl);
+        SizeT i=0;
+        for( HeapT::iterator it=heap.begin(); it != heap.end(); ++it)
+        {
             (*ret)[ i++] = it->first;
         }
         return ret;
@@ -340,6 +543,15 @@
         return objHeap.size();
     }
 
+//     static DObj FindInObjHeap( BaseGDL** p)
+//     {
+//         for( ObjHeapT::iterator it=objHeap.begin(); it != objHeap.end(); ++it)
+//         {
+//             if( &it->second == reinterpret_cast<DStructGDL**>(p))
+//                 return it->first;
+//         }
+//         return 0;
+//     }
     static DObjGDL* GetAllObjHeap()
     {
         SizeT nEl = objHeap.size();
@@ -348,6 +560,21 @@
         SizeT i=0;
         for( ObjHeapT::iterator it=objHeap.begin(); it != objHeap.end(); ++it)
         {
+            IncRefObj( it->first);
+            (*ret)[ i++] = it->first;
+        }
+        return ret;
+    }
+
+    // no ref counting here
+    static std::vector<DObj>* GetAllObjHeapSTL()
+    {
+        SizeT nEl = objHeap.size();
+        if( nEl == 0) return new std::vector<DObj>();
+        std::vector<DObj>* ret = new std::vector<DObj>( nEl);
+        SizeT i=0;
+        for( ObjHeapT::iterator it=objHeap.begin(); it != objHeap.end(); ++it)
+        {
             (*ret)[ i++] = it->first;
         }
         return ret;
@@ -361,7 +588,12 @@
 
     static const std::string Name( BaseGDL** p) // const
     {
-        return "<(Find name not implemented yet)>";
+        assert( *p == NULL);
+        DPtr h = FindInHeap( p);
+        if( h != 0) return std::string("<PtrHeapVar")+i2s(h)+">";
+//         DObj o = FindInObjHeap( p);
+//         if( o != 0) return std::string("<ObjHeapVar")+i2s(o)+">";
+        return "<(ptr to undefined expression not found on the heap)>";
     }
 
     // compiler (lexer, parser, treeparser) def in dinterpreter.cpp
@@ -506,14 +738,14 @@
 //***********************************************************************
 
 // intercative usage
-interactive returns[ GDLInterpreter::RetCode retCode]
+interactive returns[ RetCode retCode]
 // {
 // 	return interactive_statement_list(_t);
 // }    
 //     : retCode=statement_list
 //     ;
 // // used from interactive nulls line number
-// interactive_statement_list returns[ GDLInterpreter::RetCode retCode]
+// interactive_statement_list returns[ RetCode retCode]
 {
 	for (; _t != NULL;) {
 
@@ -534,9 +766,9 @@
     ;
 
 // execute statement
-execute returns[ GDLInterpreter::RetCode retCode]
+execute returns[ RetCode retCode]
 {
-//    GDLInterpreter::RetCode retCode;
+//    RetCode retCode;
     ValueGuard<bool> guard( interruptEnable);
     interruptEnable = false;
 
@@ -552,12 +784,11 @@
 
     res = NULL;
     returnValue = NULL;
-    GDLInterpreter::RetCode retCode;
+    RetCode retCode;
 
 	for (; _t != NULL;) {
 
 			retCode=statement(_t);
-			_t = _retTree;
 			
 // 			if( retCode == RC_RETURN) 
 			if( retCode >= RC_RETURN) 
@@ -566,8 +797,9 @@
 			returnValue=NULL;
 			
 			break;
-			}
-					
+			}					
+
+		_t = _retTree;
 	}
 	
 	// default return value if none was set
@@ -598,7 +830,7 @@
 {
     res = NULL;
     returnValueL = NULL;
-    GDLInterpreter::RetCode retCode;
+    RetCode retCode;
 
 	ProgNodeP in = _t;
 
@@ -648,7 +880,7 @@
 // used to call procedures
 call_pro
 {
-    GDLInterpreter::RetCode retCode;
+    RetCode retCode;
 
 	for (; _t != NULL;) {
 			retCode=statement(_t);
@@ -670,7 +902,7 @@
 
 
 // used on many occasions
-statement_list returns[ GDLInterpreter::RetCode retCode]
+statement_list returns[ RetCode retCode]
 {
 	for (; _t != NULL;) {
 
@@ -689,74 +921,144 @@
         )+
     ;
 
-statement returns[ GDLInterpreter::RetCode retCode]
+statement returns[ RetCode retCode]
 {
-    retCode = RC_OK;
-    ProgNodeP actPos = _t;
+//    ProgNodeP& actPos = statement_AST_in;
     assert( _t != NULL);
-//     if( callStack.back()->GetLineNumber() == 0) 
-    if( _t->getLine() != 0) 
-        callStack.back()->SetLineNumber( _t->getLine());
+    ProgNodeP last;
+    _retTree = _t;
+//  if( callStack.back()->GetLineNumber() == 0) 
+//  if( _t->getLine() != 0) 
+//      callStack.back()->SetLineNumber( _t->getLine());
+}
+	:  
+        {
+            do {
+//                 if( _t->getLine() != 0) 
+//                     callStack.back()->SetLineNumber( _t->getLine());
+                
+                last = _retTree;
+
+                retCode = last->Run(); // Run() sets _retTree
+                        
+            }
+            while( 
+                    _retTree != NULL && 
+                    retCode == RC_OK && 
+                    !(sigControlC && interruptEnable) && 
+                    (debugMode == DEBUG_CLEAR));
+
+            if( _retTree != NULL) 
+                last = _retTree;
+
+            goto afterStatement;
 }
-	: (
+        (
             // note: assignment must take care to update the owner of lvalue
             // a real copy must be performed (creating a new BaseGDL)  
-            a:ASSIGN            
-            {a->Run();}
-        |   r:ASSIGN_REPLACE            
-            {r->Run();}
+            ASSIGN            
+//            {a->Run();}
+        |   ASSIGN_ARRAYEXPR_MFCALL
+//            {ac->Run();}
+        |   ASSIGN_REPLACE            
+//            {ar->Run();}
             //            assignment
-        |   l:PCALL_LIB
-            {l->Run();}
-        |   m:MPCALL
-            {m->Run();}
-        |   mp:MPCALL_PARENT
-            {mp->Run();}
-        |   p:PCALL
-            {p->Run();}
+        |   PCALL_LIB
+//            {pl->Run();}
+        |   MPCALL
+//            {m->Run();}
+        |   MPCALL_PARENT
+//            {mp->Run();}
+        |   PCALL
+//            {p->Run();}
             // procedure_call
             //        |   lib_procedure_call
-        |   d:DEC
-            {d->Run();}
-        |   i:INC
-            {i->Run();}
+        |   DEC
+//            {d->Run();}
+        |   INC
+//            {in->Run();}
             // decinc_statement
-        |   retCode=for_statement 
-        |   retCode=repeat_statement
-        |   retCode=while_statement
-        |   retCode=if_statement
-        |   retCode=if_else_statement
-        |   retCode=case_statement
-        |   retCode=switch_statement
-        |   retCode=block
-        |   retCode=jump_statement
+        |   FOR
+//            {f->Run(); _t = _retTree;}
+        |   FOR_LOOP
+//            {fl->Run(); _t = _retTree;}
+        |   FOREACH
+//            {fe->Run(); _t = _retTree;}
+        |   FOREACH_LOOP
+//            {fel->Run(); _t = _retTree;}
+        |   FOR_STEP
+//            {fs->Run(); _t = _retTree;}
+        |   FOR_STEP_LOOP
+//            {fsl->Run(); _t = _retTree;}
+        |   REPEAT
+//            {r->Run(); _t = _retTree;}
+        |   REPEAT_LOOP
+//            {rl->Run(); _t = _retTree;}
+        |   WHILE
+//            {w->Run(); _t = _retTree;}
+        |   IF
+//            {i->Run(); _t = _retTree;}
+        |   IF_ELSE
+//            {ie->Run(); _t = _retTree;}
+        |   CASE
+//            {c->Run(); _t = _retTree;}
+        |   SWITCH
+//            {s->Run(); _t = _retTree;}
+        |   BLOCK
+//            {b->Run(); _t = _retTree;}
+//        |   retCode=jump_statement
         |   LABEL
+//            {l->Run(); _t = _retTree;}
         |   ON_IOERROR_NULL
-            {
-                static_cast<EnvUDT*>(callStack.back())->SetIOError( -1);
-            }
-        |   o:ON_IOERROR
-            {
-                static_cast<EnvUDT*>(callStack.back())->
-                    SetIOError( o->targetIx);
-            }
+//            {on->Run(); _t = _retTree;}
+        |   ON_IOERROR
+//            {o->Run(); _t = _retTree;}
+        |   BREAK
+//            {br->Run(); _t = _retTree;}
+        |   CONTINUE
+//            {co->Run(); _t = _retTree;}
+        |   GOTO
+//            {g->Run(); _t = _retTree;}
+        |   RETF 
+//             ( { !static_cast<EnvUDT*>(callStack.back())->LFun()}? e=expr // expr -> r value
+//                 {
+//                     delete returnValue;
+//                     returnValue=e;
+//                     retCode=RC_RETURN;
+//                     callStack.back()->RemoveLoc( e); // steal e from local list
+//                 }
+//             | eL=l_ret_expr
+//                 {
+//                     // returnValueL is otherwise owned
+//                     returnValueL=eL;
+//                     retCode=RC_RETURN;
+//                 }
+//             )
+//             ) 
+        | RETP
+//         {
+//             retCode=RC_RETURN;
+//         }
         )
-        // control c and debugging
+
+        // control-c and debugging
         {
+           afterStatement:;
+
            // possible optimization: make sigControlC a debugMode 
            if( interruptEnable && sigControlC)
             {
-                DebugMsg( actPos, "Interrupted at: "); 
+                DebugMsg( last, "Interrupted at: "); 
 
                 sigControlC = false;
 
-                retCode = NewInterpreterInstance(actPos->getLine()-1);
+                retCode = NewInterpreterInstance( last->getLine()-1);
             }
-            else if( debugMode != DEBUG_CLEAR)
+           else if( debugMode != DEBUG_CLEAR)
             {
                 if( debugMode == DEBUG_STOP)
                 {
-                    DebugMsg( actPos, "Stop encoutered: ");
+                    DebugMsg( last, "Stop encoutered: ");
                     if( !interruptEnable)
                         debugMode = DEBUG_PROCESS_STOP;
                 }
@@ -765,18 +1067,19 @@
                 {
                     if( debugMode == DEBUG_PROCESS_STOP)
                     {
-                        DebugMsg( actPos, "Stepped to: ");
+                        DebugMsg( last, "Stepped to: ");
                     }
 
                     debugMode = DEBUG_CLEAR;
                 
-                    retCode = NewInterpreterInstance(actPos->getLine()-1);
+                    retCode = NewInterpreterInstance( last->getLine()-1);
                 }   
                 else
                 {
                     retCode = RC_ABORT;
                 }
             }
+           return retCode;
         }
 	;
     exception 
@@ -785,15 +1088,14 @@
         if( dynamic_cast< GDLIOException*>( &e) != NULL)
             {
                 // set the jump target - also logs the jump
-                ProgNodeP onIOErr = static_cast<EnvUDT*>(callStack.back())->GetIOError();
+                ProgNodeP onIOErr = 
+                    static_cast<EnvUDT*>(callStack.back())->GetIOError();
                 if( onIOErr != NULL)
                     {
                         SysVar::SetErr_String( e.getMessage());
-                        _t = onIOErr;
-                        retCode=RC_OK;		
 
-                        _retTree = _t;
-                        return retCode;
+                        _retTree = onIOErr;
+                        return RC_OK;
                     }
             }
 
@@ -823,7 +1125,10 @@
                     // 2 -> caller of routine which called ON_ERROR
                     else if( oE == 2)
                     {
-                        ++i; // set to caller
+                        // set to caller, handle nested
+                        while( static_cast<EnvUDT*>(*(++i))->GetOnError() == 2 
+                               && i != callStack.rend());
+
                         if( i == callStack.rend())
                         {
                             EnvUDT* cS_begin = 
@@ -843,19 +1148,27 @@
                         targetEnv = iUDT;
                     }
                     
-                    // remeber where to stop
-                    e.SetTargetEnv( targetEnv);
                     
                     // State where error occured
 //                     if( e.getLine() == 0 && _t != NULL)
 //                         e.SetLine( _t->getLine());
 //                     if( e.getLine() == 0 && _retTree != NULL)
 //                         e.SetLine( _retTree->getLine());
-                    if( e.getLine() == 0 && actPos != NULL)
-                        e.SetLine( actPos->getLine());
-                    
-                    ReportError(e, "Error occurred at:");
+                    if( e.getLine() == 0 && last != NULL)
+                        e.SetLine( last->getLine());
+
+                    if( interruptEnable)
+                        ReportError(e, "Error occurred at:");
+
+                    // remeber where to stop
+                    e.SetTargetEnv( targetEnv);
                     
+                    if( targetEnv->GetLineNumber() != 0)
+                        e.SetLine( targetEnv->GetLineNumber());                    
+
+//                     ProgNodeP errorNodeP = targetEnv->CallingNode();
+//                     e.SetErrorNodeP( errorNodeP);
+
                     // break on first occurence of set oE
                     break;
                 }
@@ -874,8 +1187,8 @@
 //             e.SetLine( _t->getLine());
 //         if( e.getLine() == 0 && _retTree != NULL)
 //             e.SetLine( _retTree->getLine());
-        if( e.getLine() == 0 && actPos != NULL)
-            e.SetLine( actPos->getLine());
+//        if( e.getLine() == 0 && actPos != NULL)
+//            e.SetLine( actPos->getLine());
 
         if( interruptEnable)
             {
@@ -901,36 +1214,41 @@
 
                 retCode = RC_ABORT;
             }
+
+        return retCode;
     }
 
-block returns[ GDLInterpreter::RetCode retCode]
+block returns[ RetCode retCode]
 {
-    retCode = RC_OK;
-
-	ProgNodeP block = _t;
 	match(antlr::RefAST(_t),BLOCK);
-	_t = _t->getFirstChild();
-	if (_t != NULL)
-		{
+	_retTree = _t->getFirstChild();
+    return RC_OK;
+//     retCode = RC_OK;
+
+// 	ProgNodeP block = _t;
+// 	match(antlr::RefAST(_t),BLOCK);
+// 	_t = _t->getFirstChild();
+// 	if (_t != NULL)
+// 		{
 
-            SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+//             SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
 
-            retCode=statement_list(_t);
+//             retCode=statement_list(_t);
 
-            if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-                !block->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
-                {
-                    // a jump (goto) occured out of this block
-                    return retCode;
-                }
-		}
-	_retTree = block->getNextSibling();
-	return retCode;
+//             if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+//                 !block->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+//                 {
+//                     // a jump (goto) occured out of this block
+//                     return retCode;
+//                 }
+// 		}
+// 	_retTree = block->getNextSibling();
+// 	return retCode;
 }
 	: #(BLOCK (retCode=statement_list)?)
 	;
 
-switch_statement returns[ GDLInterpreter::RetCode retCode]
+switch_statement returns[ RetCode retCode]
 {
     BaseGDL* e;
     retCode = RC_OK; // not set if no branch is executed
@@ -939,7 +1257,7 @@
             {
                 auto_ptr<BaseGDL> e_guard(e);
                 
-                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+//                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
 
                 ProgNodeP b=_t; // remeber block begin (block)
 
@@ -952,25 +1270,29 @@
 
                         ProgNodeP sL = b->GetFirstChild(); // statement_list
 
-                        if( sL != NULL )
+                        if(sL != NULL )
                         {
-                            // statement there
-                            retCode=statement_list( sL);
-                            if( retCode == RC_BREAK) 
-                            {
-                                retCode = RC_OK;    
-                                break;          // break
-                            }
-                            if( retCode >= RC_RETURN) break; // goto
+                            _retTree = sL;
+                            return RC_OK;
+                        }
 
-                            if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-                                !s->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
-                            {
-                                // a jump (goto) occured out of this loop
-                                return retCode;
-                            }
+//                             // statement there
+//                             retCode=statement_list( sL);
+//                             if( retCode == RC_BREAK) 
+//                             {
+//                                 retCode = RC_OK;    
+//                                 break;          // break
+//                             }
+//                             if( retCode >= RC_RETURN) break; // goto
 
-                        }
+//                             if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+//                                 !s->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+//                             {
+//                                 // a jump (goto) occured out of this loop
+//                                 return retCode;
+//                             }
+
+//                         }
                     }
                     else
                     {
@@ -987,35 +1309,47 @@
                             hook=e->Equal(ee); // Equal deletes ee
                         }
                             
-                        if(bb != NULL && hook)
+                        if( hook)
                         {
                             // statement there
-                            retCode=statement_list(bb);
-                            if( retCode == RC_BREAK) 
-                            {
-                                retCode = RC_OK;    
-                                break;          // break
-                            }
-                            if( retCode >= RC_RETURN) break; // goto
+                            if(bb != NULL )
+                                {
+                                    _retTree = bb;
+                                    return RC_OK;
+                                }
+                 
+//                             _retTree = // find first non empty
+//                             return RC_OK;
+//                                 }
 
-                            if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-                                !s->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
-                            {
-                                // a jump (goto) occured out of this loop
-                                return retCode;
-                            }
+//                             retCode=statement_list(bb);
+//                             if( retCode == RC_BREAK) 
+//                             {
+//                                 retCode = RC_OK;    
+//                                 break;          // break
+//                             }
+//                             if( retCode >= RC_RETURN) break; // goto
+
+//                             if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+//                                 !s->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+//                             {
+//                                 // a jump (goto) occured out of this loop
+//                                 return retCode;
+//                             }
                         }
                         
                     }
                     b=b->GetNextSibling(); // next block
                 }
+                _retTree = s->GetNextSibling();
+                return RC_OK;
                 // finish or break
 //                retCode=RC_OK; // clear RC_BREAK retCode
             }
         )
     ;
 
-case_statement returns[ GDLInterpreter::RetCode retCode]
+case_statement returns[ RetCode retCode]
 {
     BaseGDL* e;
     retCode = RC_OK; // not set if no branch is executed
@@ -1024,7 +1358,7 @@
             {
                 auto_ptr<BaseGDL> e_guard(e);
 
-                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+//                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
 
                 if( !e->Scalar())
                 throw GDLException( _t, "Expression must be a"
@@ -1032,7 +1366,7 @@
 
                 ProgNodeP b=_t; // remeber block begin
 
-                for( int i=0; i<c->numBranch; i++)
+                for( int i=0; i<c->numBranch; ++i)
                 {
                     if( b->getType() == ELSEBLK)
                     {
@@ -1040,22 +1374,31 @@
 
                         if(sL != NULL )
                         {
-                            // statement there
-                            retCode=statement_list(sL);
-                            //if( retCode == RC_BREAK) break; // break anyway
-//                            if( retCode >= RC_RETURN) return retCode; 
-                            if( retCode >= RC_RETURN) break;
+                            _retTree = sL;
+                            return RC_OK;
+                        }
+                        else
+                        {
+                            _retTree = c->GetNextSibling();
+                            return RC_OK;
+                        }
+
+//                             // statement there
+//                             retCode=statement_list(sL);
+//                             //if( retCode == RC_BREAK) break; // break anyway
+// //                            if( retCode >= RC_RETURN) return retCode; 
+//                             if( retCode >= RC_RETURN) break;
                             
-                            if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-                                !c->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
-                            {
-                                // a jump (goto) occured out of this loop
-                                return retCode;
-                            }
+//                             if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+//                                 !c->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+//                             {
+//                                 // a jump (goto) occured out of this loop
+//                                 return retCode;
+//                             }
 
-                        }
-                        retCode = RC_OK;
-                        break;
+//                         }
+//                         retCode = RC_OK;
+//                         break;
                     }
                     else
                     {
@@ -1069,129 +1412,185 @@
 
                         if( equalexpr)
                         {
-                            if(bb != NULL)
-                            {
-                                // statement there
-                                retCode=statement_list(bb);
-                                //if( retCode == RC_BREAK) break; // break anyway
-//                                if( retCode >= RC_RETURN) return retCode;
-                                if( retCode >= RC_RETURN) break;
-
-                                if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-                                    !c->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+                            if(bb != NULL )
                                 {
-                                    // a jump (goto) occured out of this loop
-                                    return retCode;
+                                    _retTree = bb;
+                                    return RC_OK;
                                 }
+                            else
+                                {
+                                    _retTree = c->GetNextSibling();
+                                    return RC_OK;
+                                }
+//                             if(bb != NULL)
+//                             {
+//                                 // statement there
+//                                 retCode=statement_list(bb);
+//                                 //if( retCode == RC_BREAK) break; // break anyway
+// //                                if( retCode >= RC_RETURN) return retCode;
+//                                 if( retCode >= RC_RETURN) break;
+
+//                                 if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+//                                     !c->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+//                                 {
+//                                     // a jump (goto) occured out of this loop
+//                                     return retCode;
+//                                 }
 
-                            }
-                            retCode = RC_OK;
-                            break;
+//                             }
+//                             retCode = RC_OK;
+//                             break;
                         }
                         
                     }
                     b=b->GetNextSibling(); // next block
-                }
+                } // for
                 // finish or break
 //                retCode=RC_OK; // clear RC_BREAK retCode
+                throw GDLException( c, "CASE statement found no match.",true,false);
             }
+
         )
 	;
 
-repeat_statement returns[ GDLInterpreter::RetCode retCode]
-{
-    retCode = RC_OK; // not set if no branch is executed
-}
+
+
+repeat_statement returns[ RetCode retCode]
 	: #(r:REPEAT // block expr
             {
-                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
-
-                // remember block and expr nodes
-                ProgNodeP e =_t;
-                ProgNodeP bb  = e->GetNextSibling();
-
-//                 ProgNodeP bb =_t;
-//                 ProgNodeP e  = bb->GetNextSibling();
-//                 bb = bb->GetFirstChild();
-                
-                auto_ptr<BaseGDL> eVal;
-                do {
-                    if( bb != NULL)
-                    {
-                    retCode=statement_list(bb);
+                // _t is REPEAT_LOOP, GetFirstChild() is expr, GetNextSibling is first loop statement
+               _retTree = _t->GetFirstChild()->GetNextSibling();     // statement
+               return RC_OK;
+            }
+        )
+	;
 
-                    if( retCode == RC_CONTINUE)
-                                {
-                                retCode = RC_OK;
-                                continue;  
-                                }
-                    if( retCode == RC_BREAK) 
+repeat_loop_statement returns[ RetCode retCode]
+// {
+//     retCode = RC_OK; // not set if no branch is executed
+// }
+	: #(r:REPEAT_LOOP // block expr
+            {
+                auto_ptr<BaseGDL> eVal( expr(_t));
+                if( eVal.get()->False())
                     {
-                        retCode = RC_OK;
-                        break;        
+                        _retTree = _t->GetNextSibling();     // 1st loop statement
+                        if( _retTree == NULL)
+                            throw GDLException(r,
+                                               "Empty REPEAT loop entered (infinite loop).",
+                                               true,false);
+                        return RC_OK;
                     }
-                    if( retCode >= RC_RETURN) break;
-                    // if( retCode == RC_BREAK) break;        
-                    // if( retCode >= RC_RETURN) return retCode;
-
-                    if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-                        !r->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+                else
                     {
-                        // a jump (goto) occured out of this loop
-                        return retCode;
-                    }
+                        _retTree = r->GetNextSibling();     // statement
+                        return RC_OK;
                     }
-                    eVal.reset( expr(e));
-                } while( eVal.get()->False());
+
+//                 retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
+//                 SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+
+//                 // remember block and expr nodes
+//                 ProgNodeP e =_t;
+//                 ProgNodeP bb  = e->GetNextSibling();
+
+// //                 ProgNodeP bb =_t;
+// //                 ProgNodeP e  = bb->GetNextSibling();
+// //                 bb = bb->GetFirstChild();
                 
-                // retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
+//                 auto_ptr<BaseGDL> eVal;
+//                 do {
+//                     if( bb != NULL)
+//                     {
+//                     retCode=statement_list(bb);
+
+//                     if( retCode == RC_CONTINUE)
+//                                 {
+//                                 retCode = RC_OK;
+//                                 continue;  
+//                                 }
+//                     if( retCode == RC_BREAK) 
+//                     {
+//                         retCode = RC_OK;
+//                         break;        
+//                     }
+//                     if( retCode >= RC_RETURN) break;
+//                     // if( retCode == RC_BREAK) break;        
+//                     // if( retCode >= RC_RETURN) return retCode;
+
+//                     if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+//                         !r->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+//                     {
+//                         // a jump (goto) occured out of this loop
+//                         return retCode;
+//                     }
+//                     }
+//                     eVal.reset( expr(e));
+//                 } while( eVal.get()->False());
+                
+//                 // retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
             }
         )
 	;
 
-while_statement returns[ GDLInterpreter::RetCode retCode]
+while_statement returns[ RetCode retCode]
 {
     retCode = RC_OK;
 }
 	: #(w:WHILE // statement expr 
             {
-                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+//                 SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
 
-                ProgNodeP e = _t; //->GetFirstChild();  // expr
-                ProgNodeP s = _t->GetNextSibling();     // statement
+//                 ProgNodeP e = _t; //->GetFirstChild();  // expr
 
-                auto_ptr< BaseGDL> eVal( expr( e));
-                while( eVal.get()->True()) {
-                    retCode=statement(s);
-
-                    if( retCode == RC_CONTINUE) 
-                                {
-                                retCode = RC_OK;
-                                continue;  
-                                }
-                    if( retCode == RC_BREAK) 
+                auto_ptr<BaseGDL> eVal( expr( _t));
+                if( eVal.get()->True()) 
                     {
-                        retCode = RC_OK;
-                        break;        
+                        _retTree = _t->GetNextSibling();     // 1st loop statement
+                        if( _retTree == NULL)
+                            throw GDLException(w,
+                                               "Empty WHILE loop entered (infinite loop).",
+                                               true,false);
+                        return RC_OK;
                     }
-                    if( retCode >= RC_RETURN) break;
-                    
-                    if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-                        !w->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+                else
                     {
-                        // a jump (goto) occured out of this loop
-                        return retCode;
+                        _retTree = w->GetNextSibling();     // statement
+                        return RC_OK;
                     }
 
-                    eVal.reset( expr( e));
-                } 
+//                 auto_ptr< BaseGDL> eVal( expr( e));
+//                 while( eVal.get()->True()) {
+//                     retCode=statement_list(s);
+
+//                     if( retCode == RC_CONTINUE) 
+//                                 {
+//                                 retCode = RC_OK;
+//                                 continue;  
+//                                 }
+//                     if( retCode == RC_BREAK) 
+//                     {
+//                         retCode = RC_OK;
+//                         break;        
+//                     }
+//                     if( retCode >= RC_RETURN) break;
+                    
+//                     if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+//                         !w->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+//                     {
+//                         // a jump (goto) occured out of this loop
+//                         return retCode;
+//                     }
+
+//                     eVal.reset( expr( e));
+//                 } 
 
                 // retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
             }
         )
 	;
 
-for_statement returns[ GDLInterpreter::RetCode retCode]
+for_statement returns[ RetCode retCode]
 {
     BaseGDL** v;
     BaseGDL* s;
@@ -1199,422 +1598,542 @@
     BaseGDL* st;
     retCode = RC_OK;
 }
-    : #(f:FOR // (VAR|VARPTR) expr expr 
-            {
-                ProgNodeP sv = _t;
-            }
-            v=l_simple_var
-            s=expr e=expr
+    : #(f:FOR // #(FOR_LOOP (VAR|VARPTR) expr expr ...) 
             {
-                auto_ptr<BaseGDL> s_guard(s);
-                auto_ptr<BaseGDL> e_guard(e);
+                _t = f->GetNextSibling()->GetFirstChild();
 
                 EnvUDT* callStack_back = 
                 static_cast<EnvUDT*>(callStack.back());
-                SizeT nJump = callStack_back->NJump();
 
-                s->ForCheck( &e);
-                e_guard.release();
-                e_guard.reset(e);
+                ForLoopInfoT& loopInfo = 
+                    callStack_back->GetForLoopInfo( f->forLoopIx);
+
+                v=l_simple_var(_t);
+                _t = _retTree;
+
+                s=expr(_t);
+                auto_ptr<BaseGDL> s_guard(s);
+                _t = _retTree;
+
+                delete loopInfo.endLoopVar;
+                loopInfo.endLoopVar=expr(_t);
+
+                ProgNodeP b = _retTree;
+		
+                s->ForCheck( &loopInfo.endLoopVar);
 
-                ProgNodeP b=_t; //->getFirstChild();
-                
                 // ASSIGNMENT used here also
                 delete (*v);
+                (*v)= s_guard.release(); // s held in *v after this
 
-// problem:
-// EXECUTE may call DataListT.loc.resize(), as v points to the
-// old sequence v might be invalidated -> segfault
-// note that the value (*v) is preserved by resize()
-                s_guard.release(); // s held in *v after this
-                for((*v)=s; (*v)->ForCondUp( e); 
-                    v=l_simple_var( sv), (*v)->ForAdd()) 
+                if( (*v)->ForCondUp( loopInfo.endLoopVar))
                 {
-//                    retCode=block(b);
-                    if( b != NULL)
-                    {
-                        retCode=statement_list(b);
-                    
-                        if( retCode != RC_OK) // optimization
-                        {
-                            if( retCode == RC_CONTINUE) 
-                                {
-                                retCode = RC_OK;
-                                continue;  
-                                }
-                            if( retCode == RC_BREAK) 
-                            {
-                                retCode = RC_OK;
-                                break;        
-                            }
-                            if( retCode >= RC_RETURN) break;
-                        }
+                    _retTree = b;
+                    return RC_OK;
+                }
+                else
+                {
+                    // skip if initial test fails
+                    _retTree = f->GetNextSibling()->GetNextSibling();
+                    return RC_OK;
+                }
+            }
+        ) 
+    | #(fl:FOR_LOOP// (VAR|VARPTR) expr expr 
+            {
+                EnvUDT* callStack_back = 
+                static_cast<EnvUDT*>(callStack.back());
 
-                        if( (callStack_back->NJump() != nJump) &&
-                            !f->LabelInRange( callStack_back->LastJump()))
-                        {
-                            // a jump (goto) occured out of this loop
-                            return retCode;
-                        }
+                ForLoopInfoT& loopInfo = 
+                    callStack_back->GetForLoopInfo( fl->forLoopIx);
+
+                if( loopInfo.endLoopVar == NULL)
+                    {
+                        // non-initialized loop (GOTO)
+                        _retTree = fl->GetNextSibling();
+                        return RC_OK;
                     }
+
+// // problem:
+// // EXECUTE may call DataListT.loc.resize(), as v points to the
+// // old sequence v might be invalidated -> segfault
+// // note that the value (*v) is preserved by resize()
+
+                v=l_simple_var(_t);
+                _t = _retTree;
+
+                (*v)->ForAdd();
+                if( (*v)->ForCondUp( loopInfo.endLoopVar))
+                {
+                    _retTree = _t->GetNextSibling()->GetNextSibling();
+                    return RC_OK;
+                }
+                else
+                {
+                    delete loopInfo.endLoopVar;
+                    loopInfo.endLoopVar = NULL;
+                    _retTree = fl->GetNextSibling();
+                    return RC_OK;
                 }
-//                retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
+
             }
         )
+//                 for((*v)=s; (*v)->ForCondUp( e); 
+//                     v=l_simple_var( sv), (*v)->ForAdd()) 
+//                 {
+// //                    retCode=block(b);
+//                     if( b != NULL)
+//                     {
+//                         retCode=statement_list(b);
+                    
+//                         if( retCode != RC_OK) // optimization
+//                         {
+//                             if( retCode == RC_CONTINUE) 
+//                                 {
+//                                 retCode = RC_OK;
+//                                 continue;  
+//                                 }
+//                             if( retCode == RC_BREAK) 
+//                             {
+//                                 retCode = RC_OK;
+//                                 break;        
+//                             }
+//                             if( retCode >= RC_RETURN) break;
+//                         }
+
+//                         if( (callStack_back->NJump() != nJump) &&
+//                             !f->LabelInRange( callStack_back->LastJump()))
+//                         {
+//                             // a jump (goto) occured out of this loop
+//                             return retCode;
+//                         }
+//                     }
+//                 }
+// //                retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
+//             }
+//         )
     | #(fs:FOR_STEP // (VAR|VARPTR) expr expr expr 
             {
-                ProgNodeP sv = _t;
-            }
-            v=l_simple_var
-            s=expr e=expr st=expr
-            {
+                _t = fs->GetNextSibling()->GetFirstChild();
+
+                EnvUDT* callStack_back = 
+                static_cast<EnvUDT*>(callStack.back());
+
+                ForLoopInfoT& loopInfo = 
+                    callStack_back->GetForLoopInfo( fs->forLoopIx);
+
+                v=l_simple_var(_t);
+                _t = _retTree;
+
+                s=expr(_t);
                 auto_ptr<BaseGDL> s_guard(s);
-                auto_ptr<BaseGDL> e_guard(e);
-                auto_ptr<BaseGDL> st_guard(st);
+                _t = _retTree;
 
-                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+                delete loopInfo.endLoopVar;
+                loopInfo.endLoopVar=expr(_t);
+                _t = _retTree;
+
+                delete loopInfo.loopStepVar;
+                loopInfo.loopStepVar=expr(_t);
+
+                ProgNodeP b = _retTree;
+		
+                s->ForCheck( &loopInfo.endLoopVar, &loopInfo.loopStepVar);
 
-                s->ForCheck( &e, &st);
-                e_guard.release();
-                e_guard.reset(e);
-                st_guard.release();
-                st_guard.reset(st);
-                
-                ProgNodeP bs=_t;
-                
                 // ASSIGNMENT used here also
                 delete (*v);
-                
-                if( st->Sgn() == -1) 
-                {
-                    s_guard.release();
-                    for((*v)=s; (*v)->ForCondDown( e); 
-                        v=l_simple_var( sv), (*v)->ForAdd(st))
+                (*v)= s_guard.release(); // s held in *v after this
+
+                if( loopInfo.loopStepVar->Sgn() == -1) 
                     {
-                        if( bs != NULL)
+                    if( (*v)->ForCondDown( loopInfo.endLoopVar))
                         {
-                            retCode=statement_list(bs);
-                            
-                            if( retCode == RC_CONTINUE)
-                                {
-                                retCode = RC_OK;
-                                continue;  
-                                }
-                            if( retCode == RC_BREAK) 
-                            {
-                                retCode = RC_OK;
-                                break;        
-                            }
-                            if( retCode >= RC_RETURN) break;
-                            
-                            if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-                                !fs->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
-                            {
-                                // a jump (goto) occured out of this loop
-                                return retCode;
-                            }
+                            _retTree = b;
+                            return RC_OK;
                         }
                     }
-                } 
                 else
-                {
-                    s_guard.release();
-                    for((*v)=s; (*v)->ForCondUp( e);
-                        v=l_simple_var( sv), (*v)->ForAdd(st))
-                        {
-                        if( bs != NULL)
+                    {
+                    if( (*v)->ForCondUp( loopInfo.endLoopVar))
                         {
-                            retCode=statement_list(bs);
-                        
-                            if( retCode == RC_CONTINUE)
-                                {
-                                retCode = RC_OK;
-                                continue;  
-                                }
+                            _retTree = b;
+                            return RC_OK;
+                        }
+                    }
 
-                            if( retCode == RC_BREAK) 
-                            {
-                                retCode = RC_OK;
-                                break;        
-                            }
-                            if( retCode >= RC_RETURN) break;
-                            
-                            if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-                                !fs->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
-                            {
-                                // a jump (goto) occured out of this loop
-                                return retCode;
-                            }
+                // skip if initial test fails
+                _retTree = f->GetNextSibling()->GetNextSibling();
+                return RC_OK;
+            }
+        )
+    | #(fsl:FOR_STEP_LOOP // (VAR|VARPTR) expr expr expr 
+            {
+                EnvUDT* callStack_back = 
+                static_cast<EnvUDT*>(callStack.back());
+
+                ForLoopInfoT& loopInfo = 
+                    callStack_back->GetForLoopInfo( fsl->forLoopIx);
+
+                if( loopInfo.endLoopVar == NULL)
+                    {
+                        // non-initialized loop (GOTO)
+                        _retTree = fsl->GetNextSibling();
+                        return RC_OK;
+                    }
+
+// // problem:
+// // EXECUTE may call DataListT.loc.resize(), as v points to the
+// // old sequence v might be invalidated -> segfault
+// // note that the value (*v) is preserved by resize()
+
+                v=l_simple_var(_t);
+                _t = _retTree;
+
+                ProgNodeP b = _t->GetNextSibling()->GetNextSibling()->GetNextSibling();
+
+                (*v)->ForAdd(loopInfo.loopStepVar);
+                if( loopInfo.loopStepVar->Sgn() == -1) 
+                    {
+                    if( (*v)->ForCondDown( loopInfo.endLoopVar))
+                        {
+                            _retTree = b;
+                            return RC_OK;
                         }
                     }
-                }
+                else
+                    {
+                    if( (*v)->ForCondUp( loopInfo.endLoopVar))
+                        {
+                            _retTree = b;
+                            return RC_OK;
+                        }
+                    }
+
+               delete loopInfo.endLoopVar;
+               loopInfo.endLoopVar = NULL;
+               delete loopInfo.loopStepVar;
+               loopInfo.loopStepVar = NULL;
+               _retTree = fsl->GetNextSibling();
+               return RC_OK;
+
             }
         )
+//             {
+//                 ProgNodeP sv = _t;
+//             }
+//             v=l_simple_var
+//             s=expr e=expr st=expr
+//             {
+//                 auto_ptr<BaseGDL> s_guard(s);
+//                 auto_ptr<BaseGDL> e_guard(e);
+//                 auto_ptr<BaseGDL> st_guard(st);
+
+//                 SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+
+//                 s->ForCheck( &e, &st);
+//                 e_guard.release();
+//                 e_guard.reset(e);
+//                 st_guard.release();
+//                 st_guard.reset(st);
+                
+//                 ProgNodeP bs=_t;
+                
+//                 // ASSIGNMENT used here also
+//                 delete (*v);
+                
+//                 if( st->Sgn() == -1) 
+//                 {
+//                     s_guard.release();
+//                     for((*v)=s; (*v)->ForCondDown( e); 
+//                         v=l_simple_var( sv), (*v)->ForAdd(st))
+//                     {
+//                         if( bs != NULL)
+//                         {
+//                             retCode=statement_list(bs);
+                            
+//                             if( retCode == RC_CONTINUE)
+//                                 {
+//                                 retCode = RC_OK;
+//                                 continue;  
+//                                 }
+//                             if( retCode == RC_BREAK) 
+//                             {
+//                                 retCode = RC_OK;
+//                                 break;        
+//                             }
+//                             if( retCode >= RC_RETURN) break;
+                            
+//                             if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+//                                 !fs->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+//                             {
+//                                 // a jump (goto) occured out of this loop
+//                                 return retCode;
+//                             }
+//                         }
+//                     }
+//                 } 
+//                 else
+//                 {
+//                     s_guard.release();
+//                     for((*v)=s; (*v)->ForCondUp( e);
+//                         v=l_simple_var( sv), (*v)->ForAdd(st))
+//                         {
+//                         if( bs != NULL)
+//                         {
+//                             retCode=statement_list(bs);
+                        
+//                             if( retCode == RC_CONTINUE)
+//                                 {
+//                                 retCode = RC_OK;
+//                                 continue;  
+//                                 }
+
+//                             if( retCode == RC_BREAK) 
+//                             {
+//                                 retCode = RC_OK;
+//                                 break;        
+//                             }
+//                             if( retCode >= RC_RETURN) break;
+                            
+//                             if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+//                                 !fs->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+//                             {
+//                                 // a jump (goto) occured out of this loop
+//                                 return retCode;
+//                             }
+//                         }
+//                     }
+//                 }
+//             }
+//         )
 	;
 
-if_statement returns[ GDLInterpreter::RetCode retCode]
+
+
+foreach_statement returns[ RetCode retCode]
 {
-    BaseGDL* e;
-    retCode = RC_OK; // not set if not executed
+    BaseGDL** v;
+    BaseGDL* s;
+    retCode = RC_OK;
 }
-	: #(i:IF e=expr
-            { 
-                auto_ptr<BaseGDL> e_guard(e);
+    : #(f:FOREACH // #(FOREACH_LOOP (VAR|VARPTR) expr ...)
+            {
+                _t = f->GetNextSibling()->GetFirstChild();
+
+                EnvUDT* callStack_back = 
+                static_cast<EnvUDT*>(callStack.back());
 
-                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+                ForLoopInfoT& loopInfo = 
+                    callStack_back->GetForLoopInfo( f->forLoopIx);
 
-                if( e->True())
-                {
-                    retCode=statement(_t);
-//                    if( retCode != RC_OK) return retCode;
+                v=l_simple_var(_t);
+                _t = _retTree;
 
-                        if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-                            !i->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
-                        {
-                            // a jump (goto) occured out of this loop
-                            return retCode;
-                        }
-                }
+                delete loopInfo.endLoopVar;
+                loopInfo.endLoopVar=expr(_t);
+
+                ProgNodeP b = _retTree;
+		
+                loopInfo.foreachIx = 0;
+
+                // currently there are no empty arrays
+                //SizeT nEl = loopInfo.endLoopVar->N_Elements();
+
+                // ASSIGNMENT used here also
+                delete (*v);
+                (*v) = loopInfo.endLoopVar->NewIx( 0);
+
+                _retTree = b;
+                return RC_OK;
             }
         )
-	;   
+    | #(fl:FOREACH_LOOP // (VAR|VARPTR) expr 
+            {
+                EnvUDT* callStack_back = 
+                static_cast<EnvUDT*>(callStack.back());
+
+                ForLoopInfoT& loopInfo = 
+                    callStack_back->GetForLoopInfo( fl->forLoopIx);
+
+                if( loopInfo.endLoopVar == NULL)
+                    {
+                        // non-initialized loop (GOTO)
+                        _retTree = fl->GetNextSibling();
+                        return RC_OK;
+                    }
+
+                v=l_simple_var(_t);
+                _t = _retTree;
+
+                // skip expr
+                _t = _t->getNextSibling();
+
+                ++loopInfo.foreachIx;
+
+                SizeT nEl = loopInfo.endLoopVar->N_Elements();
+
+                if( loopInfo.foreachIx < nEl)
+                    {
+                        // ASSIGNMENT used here also
+                        delete (*v);
+                        (*v) = loopInfo.endLoopVar->NewIx( loopInfo.foreachIx);
+
+                        _retTree = _t;
+                        return RC_OK;
+                    }
+
+                delete loopInfo.endLoopVar;
+                loopInfo.endLoopVar = NULL;
+                loopInfo.foreachIx = -1;
+                _retTree = fl->GetNextSibling();
+                return RC_OK;
+            }
+        )
+// //          always copies (owned by caller)
+//             s=expr
+//             {
+//                 EnvUDT* callStack_back = 
+//                 static_cast<EnvUDT*>(callStack.back());
+//                 SizeT nJump = callStack_back->NJump();
+
+//                 ProgNodeP b=_t; //->getFirstChild();
+                
+//                 // ASSIGNMENT used here also
+
+
+//                 SizeT nEl = s->N_Elements();
+// // problem:
+// // EXECUTE may call DataListT.loc.resize(), as v points to the
+// // old sequence v might be invalidated -> segfault
+// // note that the value (*v) is preserved by resize()
+//                 for( SizeT i=0; i<nEl; ++i)
+//                 {
+// //                  retCode=block(b);
+//                     v=l_simple_var( sv);
+//                     delete (*v); 
+//                     (*v) = s->NewIx( i);
+
+//                     if( b != NULL)
+//                     {
+//                         retCode=statement_list(b);
+                    
+//                         if( retCode != RC_OK) // optimization
+//                         {
+//                             if( retCode == RC_CONTINUE) 
+//                                 {
+//                                 retCode = RC_OK;
+//                                 continue;  
+//                                 }
+//                             if( retCode == RC_BREAK) 
+//                             {
+//                                 retCode = RC_OK;
+//                                 break;        
+//                             }
+//                             if( retCode >= RC_RETURN) break;
+//                         }
+
+//                         if( (callStack_back->NJump() != nJump) &&
+//                             !f->LabelInRange( callStack_back->LastJump()))
+//                         {
+//                             // a jump (goto) occured out of this loop
+//                             return retCode;
+//                         }
+//                     }
+//                 }
+// //                retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
+//             }
+//         )
+    ;
+
+
 
-if_else_statement returns[ GDLInterpreter::RetCode retCode]
+if_statement returns[ RetCode retCode]
 {
     BaseGDL* e;
-    retCode = RC_OK; // not set if not executed
+//    retCode = RC_OK; // not set if not executed
 }
-	: #(i:IF_ELSE e=expr
+	: #(i:IF e=expr
             { 
                 auto_ptr<BaseGDL> e_guard(e);
 
-                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+//                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
 
                 if( e->True())
                 {
-                    retCode=statement(_t);
-//                    if( retCode != RC_OK) return retCode;
-
-                    if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-                        !i->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
-                    {
-                        // a jump (goto) occured out of this loop
-                        return retCode;
-                    }
+                   _retTree = _t;
+                   return RC_OK;
                 }
-                else
-                {
-                    _t=_t->GetNextSibling(); // jump over 1st statement
-                    retCode=statement(_t);
-//                    if( retCode != RC_OK) return retCode;
 
-                    if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-                        !i->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
-                    {
-                        // a jump (goto) occured out of this loop
-                        return retCode;
-                    }
-                }
+                _retTree = i->GetNextSibling();
+                return RC_OK;
+
+//                     retCode=statement(_t);
+// //                     if( retCode != RC_OK) return retCode;
+
+//                         if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+//                             !i->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+//                         {
+//                             // a jump (goto) occured out of this loop
+//                             return retCode;
+//                         }
             }
         )
 	;   
 
-// to be processed (to make sure it really returns)
-jump_statement returns[ GDLInterpreter::RetCode retCode]
+if_else_statement returns[ RetCode retCode]
 {
-BaseGDL*  e;
-BaseGDL** eL;
+    BaseGDL* e;
+    retCode = RC_OK; // not set if not executed
 }
-    : g:GOTO // target in g->gotoTarget; // pointer to an DNode (NO RefDNode)
-        {
-            // note that this version jumps 'dumb'
-            // jumping into loops is legal, even then looping is not done
+	: #(i:IF_ELSE e=expr
+            { 
+                auto_ptr<BaseGDL> e_guard(e);
 
-            // set the jump target - also logs the jump
-            _t = static_cast<EnvUDT*>(callStack.back())->GotoTarget( g->targetIx);
-            _t = _t->GetNextSibling();
-            retCode=RC_OK;
-        }
-    | #(RETF ( { !static_cast<EnvUDT*>(callStack.back())->LFun()}? e=expr // expr -> r value
-                {
-                    delete returnValue;
-                    returnValue=e;
-                    retCode=RC_RETURN;
-                    callStack.back()->RemoveLoc( e); // steal e from local list
-                }
-            | eL=l_ret_expr
+//                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+
+                if( e->True())
                 {
-                    // returnValueL is otherwise owned
-                    returnValueL=eL;
-                    retCode=RC_RETURN;
+                   _retTree = _t->GetFirstChild();
+                   return RC_OK;
                 }
-            )
-        ) 
-    | RETP
-        {
-            retCode=RC_RETURN;
-        }
-	| BREAK    // only in loops or switch_statement and case_statement
-        {
-            retCode=RC_BREAK;
-        }
-	| CONTINUE // only in loops
-        {
-            retCode=RC_CONTINUE;
-        }
-  ;
-
-// procedure_call
-// { 
-//     // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
-//     StackGuard<EnvStackT> guard(callStack);
-//     BaseGDL *self;
-//     EnvUDT*   newEnv;
-// }
-// 	: #(PCALL_LIB pl:IDENTIFIER
-//             {
-//                 EnvT* newEnv=new EnvT( pl, pl->libPro);//libProList[pl->proIx]);
-//             }
-//             parameter_def[ newEnv]
-//             {
-//                 // push environment onto call stack
-//                 callStack.push_back(newEnv);
-
-//                 // make the call
-//                 static_cast<DLibPro*>(newEnv->GetPro())->Pro()(newEnv);
-//             }   
-//         )
-//     |
-//         (
-//         ( #(MPCALL 
-//                 self=expr mp:IDENTIFIER
-//                 {  
-//                     auto_ptr<BaseGDL> self_guard(self);
-                    
-//                     newEnv=new EnvUDT( mp, self);
 
-//                     self_guard.release();
-//                 }
-//                 parameter_def[ newEnv]
-//             )
-//         | #(MPCALL_PARENT 
-//                 self=expr parent:IDENTIFIER pp:IDENTIFIER
-//                 {
-//                     auto_ptr<BaseGDL> self_guard(self);
-                    
-//                     newEnv = new EnvUDT( pp, self, parent->getText());
+                _retTree = _t->GetNextSibling();
+                return RC_OK;
+//             { 
+//                 auto_ptr<BaseGDL> e_guard(e);
 
-//                     self_guard.release();
-//                 }
-//                 parameter_def[ newEnv]
-//             )
-//         | #(PCALL p:IDENTIFIER
-//             {
-//                 SetProIx( p);
-            
-//                 newEnv = new EnvUDT( p, proList[p->proIx]);
-//             }
-//             parameter_def[ newEnv]
-//             )
-//         )
-//         {
-//             // push environment onto call stack
-//             callStack.push_back(newEnv);
-            
-//             // make the call
-//             call_pro(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
-//         }   
-//         )
-// 	;	
+//                 SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
 
-// assignment
-// {
-//     BaseGDL*  r;
-//     BaseGDL** l;
-//     auto_ptr<BaseGDL> r_guard;
-// }
-//     : #(ASSIGN 
-// //             ( r=tmp_expr
-// //                 {
-// //                     r_guard.reset( r);
-// //                 }
-// //             | r=check_expr
-// //                 {
-// //                     if( !callStack.back()->Contains( r)) 
-// //                         r_guard.reset( r);
-// //                 }
-// //             )
-//             ( r=indexable_expr
-//             | r=indexable_tmp_expr { r_guard.reset( r);}
-//             | r=check_expr
+//                 if( e->True())
 //                 {
-//                     if( !callStack.back()->Contains( r)) 
-//                         r_guard.reset( r); // guard if no global data
-//                 }
-//             )
+//                     retCode=statement(_t);
+// // //                    if( retCode != RC_OK) return retCode;
 
-//             l=l_expr[ r]
-// //             {
-// //                 // no delete if assigned to itself
-// //                 // only possible from lib function
-// //                 if( (*l) == r || callStack.back()->Contains( r)) 
-// //                     r_guard.release();
-// //             }
-//         )
-// //     | #(ASSIGN_INPLACE // ;=, *=, ...
-// //             {
-// //                  ProgNodeP op = _t;
-// //                 _t = _t->getNextSibling();
-// //             }
-// //             ( r=indexable_expr
-// //             | r=indexable_tmp_expr { r_guard.reset( r);}
-// //             | r=check_expr
-// //                 {
-// //                     if( !callStack.back()->Contains( r)) 
-// //                         r_guard.reset( r); // guard if no global data
-// //                 }
-// //             )
-// // // don't forget ASSIGN_EXPR!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-// //             l=l_inplace_expr[ op, r]
-// //         )
-//     | #(ASSIGN_REPLACE 
-//             ( r=tmp_expr
-//                 {
-//                     r_guard.reset( r);
+//                     if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+//                         !i->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+//                     {
+//                         // a jump (goto) occured out of this loop
+//                         return retCode;
+//                     }
 //                 }
-//             | r=check_expr
+//                 else
 //                 {
+//                     _t=_t->GetNextSibling(); // jump over 1st statement
+//                     retCode=statement(_t);
+// // //                   if( retCode != RC_OK) return retCode;
 
-//                     if( !callStack.back()->Contains( r)) 
-//                         r_guard.reset( r);
+//                     if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+//                         !i->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+//                     {
+//                         // a jump (goto) occured out of this loop
+//                         return retCode;
+//                     }
 //                 }
-//             )
-//             (
-//               l=l_function_call   // FCALL_LIB, MFCALL, MFCALL_PARENT, FCALL
-//             | l=l_deref           // DEREF
-//             | l=l_simple_var      // VAR, VARPTR
-//             )
-//         {
-//             if( r != (*l))
-//             {
-//                 delete *l;
+             }
+        )
+	;   
 
-//                 if( r_guard.get() == r)
-//                   *l = r_guard.release();
-//                 else  
-//                   *l = r->Dup();
-//             }
-//         }
-//         )
-//     ;
 
-// decinc_statement
-// {
-//     BaseGDL* l;
-// }
-//     : #(DEC l=l_decinc_expr[ DECSTATEMENT])
-//     | #(INC l=l_decinc_expr[ INCSTATEMENT])
-//     ;
 
 // ***************************************************************************
 // the expressions ***********************************************************
@@ -1622,32 +2141,107 @@
 
 l_deref returns [BaseGDL** res]
 {
-    BaseGDL*       e1;
+	ProgNodeP retTree = _t->getNextSibling();
+
+    auto_ptr<BaseGDL> e1_guard;
+    BaseGDL* e1;
+    ProgNodeP evalExpr = _t->getFirstChild();
+    if( NonCopyNode( evalExpr->getType()))
+      {
+            e1 = evalExpr->EvalNC();
+      }
+    else if( evalExpr->getType() ==  GDLTokenTypes::FCALL_LIB)
+      {
+		e1=lib_function_call(evalExpr);
+
+		if( e1 == NULL) // ROUTINE_NAMES
+			throw GDLException( evalExpr, "Undefined return value", true, false);
+		
+		if( !callStack.back()->Contains( e1)) 
+			e1_guard.reset( e1);
+      }
+    else
+      {
+        e1 = evalExpr->Eval();
+        e1_guard.reset(e1);
+      }
+
+  if( e1 == NULL || e1->Type() != PTR)
+    throw GDLException( evalExpr, "Pointer type required"
+			" in this context: "+Name(e1),true,false);
+
+  DPtrGDL* ptr=static_cast<DPtrGDL*>(e1);
+
+//     _t = _t->getFirstChild();
+
+//     BaseGDL* e1;
+
+// 	auto_ptr<BaseGDL> e1_guard;
+
+//     if( _t->getType() ==  GDLTokenTypes::FCALL_LIB)
+//       {
+// 		e1=lib_function_call(_t);
+
+// 		if( e1 == NULL) // ROUTINE_NAMES
+// 			throw GDLException( _t, "Undefined return value", true, false);
+		
+// 		if( !ProgNode::interpreter->callStack.back()->Contains( e1)) 
+// 			e1_guard.reset( e1);
+//       }
+//     else
+//       {
+// 			e1=tmp_expr(_t);
+// 			e1_guard.reset( e1);
+//       }
+
+// 	DPtrGDL* ptr=dynamic_cast<DPtrGDL*>(e1);
+// 	if( ptr == NULL)
+// 	throw GDLException( _t, "Pointer type required"
+// 	" in this context: "+Name(e1),true,false);
+	DPtr sc; 
+	if( !ptr->Scalar(sc))
+	throw GDLException( _t, "Expression must be a "
+	"scalar in this context: "+Name(e1),true,false);
+	if( sc == 0)
+	throw GDLException( _t, "Unable to dereference"
+	" NULL pointer: "+Name(e1),true,false);
+	
+	try{
+        res = &GetHeap(sc);
+	}
+	catch( HeapException)
+	{
+        throw GDLException( _t, "Invalid pointer: "+Name(e1),true,false);
+	}
+	
+	_retTree = retTree;
+	return res;
+
 }
     : #(DEREF e1=expr 
-            {
-                auto_ptr<BaseGDL> e1_guard(e1);
+//             {
+//                 auto_ptr<BaseGDL> e1_guard(e1);
                 
-                DPtrGDL* ptr=dynamic_cast<DPtrGDL*>(e1);
-                if( ptr == NULL)
-                throw GDLException( _t, "Pointer type required"
-                    " in this context: "+Name(e1),true,false);
-                DPtr sc; 
-                if( !ptr->Scalar(sc))
-                throw GDLException( _t, "Expression must be a "
-                    "scalar in this context: "+Name(e1),true,false);
-                if( sc == 0)
-                throw GDLException( _t, "Unable to dereference"
-                    " NULL pointer: "+Name(e1),true,false);
+//                 DPtrGDL* ptr=dynamic_cast<DPtrGDL*>(e1);
+//                 if( ptr == NULL)
+//                 throw GDLException( _t, "Pointer type required"
+//                     " in this context: "+Name(e1),true,false);
+//                 DPtr sc; 
+//                 if( !ptr->Scalar(sc))
+//                 throw GDLException( _t, "Expression must be a "
+//                     "scalar in this context: "+Name(e1),true,false);
+//                 if( sc == 0)
+//                 throw GDLException( _t, "Unable to dereference"
+//                     " NULL pointer: "+Name(e1),true,false);
                 
-                try{
-                    res = &GetHeap(sc);
-                }
-                catch( HeapException)
-                {
-                    throw GDLException( _t, "Invalid pointer: "+Name(e1),true,false);
-                }
-            }
+//                 try{
+//                     res = &GetHeap(sc);
+//                 }
+//                 catch( HeapException)
+//                 {
+//                     throw GDLException( _t, "Invalid pointer: "+Name(e1),true,false);
+//                 }
+//             }
         )
     ;
 
@@ -1673,6 +2267,7 @@
             }
         ) // trinary operator
 //    | #(EXPR res=l_ret_expr) // does not exist anymore
+    | res=l_arrayexpr_mfcall_as_mfcall
     | res=l_function_call 
         { // here a local to the actual environment could be returned
             if( callStack.back()->IsLocalKW( res))
@@ -1702,7 +2297,7 @@
                 {
                     r_guard.reset( e1);
                 }
-            | e1=check_expr
+            | e1=lib_function_call
                 {
                     if( !callStack.back()->Contains( e1)) 
                         r_guard.reset( e1);
@@ -1718,6 +2313,30 @@
                 r_guard.release();
             }
         )
+    | #(ASSIGN_ARRAYEXPR_MFCALL // here as return value of l_function
+            { 
+                auto_ptr<BaseGDL> r_guard;
+            } 
+            ( e1=tmp_expr
+                {
+                    r_guard.reset( e1);
+                }
+            | e1=lib_function_call
+                {
+                    if( !callStack.back()->Contains( e1)) 
+                        r_guard.reset( e1);
+                }
+            )
+            res=l_arrayexpr_mfcall_as_mfcall
+            {
+                if( e1 != (*res))
+                    {
+                    delete *res;
+                    *res = e1;
+                    }
+                r_guard.release();
+            }
+        )
     | #(ASSIGN_REPLACE 
             { 
                 auto_ptr<BaseGDL> r_guard;
@@ -1726,7 +2345,7 @@
                 {
                     r_guard.reset( e1);
                 }
-            | e1=check_expr
+            | e1=lib_function_call
                 {
                     if( !callStack.back()->Contains( e1)) 
                         r_guard.reset( e1);
@@ -1906,6 +2525,7 @@
 l_decinc_expr [int dec_inc] returns [BaseGDL* res]
 {
     BaseGDL*       e1;
+    ProgNodeP startNode = _t;
 }
     : #(QUESTION e1=expr
             { 
@@ -1930,7 +2550,7 @@
 //                 {
 //                     r_guard.reset( e1);
 //                 }
-//             | e1=check_expr
+//             | e1=lib_function_call
 //                 {
 //                     if( !callStack.back()->Contains( e1)) 
 //                         r_guard.reset( e1);
@@ -1938,7 +2558,7 @@
 //             )
             ( e1=indexable_expr
             | e1=indexable_tmp_expr { r_guard.reset( e1);}
-            | e1=check_expr
+            | e1=lib_function_call
                 {
                     if( !callStack.back()->Contains( e1)) 
                         r_guard.reset( e1); // guard if no global data
@@ -1955,6 +2575,57 @@
             }
             res=l_decinc_expr[ dec_inc]
         )
+    | #(ASSIGN_ARRAYEXPR_MFCALL
+            { 
+                auto_ptr<BaseGDL> r_guard;
+            } 
+            ( e1=indexable_expr
+            | e1=indexable_tmp_expr { r_guard.reset( e1);}
+            | e1=lib_function_call
+                {
+                    if( !callStack.back()->Contains( e1)) 
+                        r_guard.reset( e1); // guard if no global data
+                }
+            )
+            { 
+                ProgNodeP l = _t;
+
+                BaseGDL** tmp;
+
+                // try MFCALL
+                try
+                {
+    
+                    tmp=l_arrayexpr_mfcall_as_mfcall(l);
+    
+                    if( e1 != (*tmp))
+                    {
+                        delete *tmp;
+
+                        if( r_guard.get() == e1)
+                            *tmp = r_guard.release();
+                        else          
+                            *tmp = e1->Dup();
+                    }
+
+                    res=l_decinc_expr( l, dec_inc);
+                }
+                catch( GDLException& ex)
+                {
+                // try ARRAYEXPR
+                    try
+	                {
+                        tmp=l_arrayexpr_mfcall_as_arrayexpr(l, e1);
+	                }
+                    catch( GDLException& ex2)
+                    {
+                        throw GDLException(ex.toString() + " or "+ex2.toString());
+                    }
+
+                    res=l_decinc_expr( l, dec_inc);
+                }
+            }
+        )
     | #(ASSIGN_REPLACE 
             { 
                 auto_ptr<BaseGDL> r_guard;
@@ -1963,7 +2634,7 @@
                 {
                     r_guard.reset( e1);
                 }
-            | e1=check_expr
+            | e1=lib_function_call
                 {
                     if( !callStack.back()->Contains( e1)) 
                         r_guard.reset( e1);
@@ -1985,18 +2656,90 @@
             {
                 delete *tmp;
 
-                if( r_guard.get() == e1)
-                  *tmp = r_guard.release();
-                else  
-                  *tmp = e1->Dup();
-            }
-        }
-            {
-                _t = l;
-            }
-            res=l_decinc_expr[ dec_inc]
+                if( r_guard.get() == e1)
+                  *tmp = r_guard.release();
+                else  
+                  *tmp = e1->Dup();
+            }
+        }
+            {
+                _t = l;
+            }
+            res=l_decinc_expr[ dec_inc]
+        )
+    | res=l_decinc_array_expr[ dec_inc]
+    | #(ARRAYEXPR_MFCALL
+        {
+            ProgNodeP mark = _t;
+            _t = _t->getNextSibling(); // step over DOT
+
+            BaseGDL* self;
+        }
+            
+        //BaseGDL** e = l_arrayexpr_mfcall_as_mfcall( _t);
+        self=expr mp2:IDENTIFIER
+
+        {  
+                auto_ptr<BaseGDL> self_guard(self);
+        
+                EnvUDT* newEnv;
+
+                try {
+                    newEnv=new EnvUDT( self, mp2, "", true);
+                    self_guard.release();
+                }
+                catch( GDLException& ex)
+                {
+                    _t = mark;
+
+                    res=l_decinc_dot_expr(_t, dec_inc);
+
+                    _retTree = startNode->getNextSibling();
+                    return res;
+                }   
+        }    
+
+        parameter_def[ newEnv]
+        
+        {
+            // push environment onto call stack
+            callStack.push_back(newEnv);
+            
+            // make the call
+            BaseGDL** ee=call_lfun(static_cast<DSubUD*>(
+                                  newEnv->GetPro())->GetTree());
+
+            BaseGDL* e = *ee;
+            if( e == NULL)
+                throw GDLException( _t, "Variable is undefined: "+Name(ee),true,false);
+
+            if( dec_inc == DECSTATEMENT) 
+                {
+                    e->Dec(); 
+                    res = NULL;
+                    _retTree = startNode->getNextSibling();
+                    return res;
+                }
+            if( dec_inc == INCSTATEMENT)
+                {
+                    e->Inc();
+                    res = NULL;
+                    _retTree = startNode->getNextSibling();
+                    return res;
+                }
+
+            if( dec_inc == DEC) e->Dec();
+            else if( dec_inc == INC) e->Inc();
+  //          
+            res = e->Dup();
+            
+            if( dec_inc == POSTDEC) e->Dec();
+            else if( dec_inc == POSTINC) e->Inc();
+
+            _retTree = startNode->getNextSibling();
+            return res;
+        }   
         )
-    | res=l_decinc_array_expr[ dec_inc]
     | res=l_decinc_dot_expr[ dec_inc]
     | e1=r_expr
         {
@@ -2025,6 +2768,11 @@
             if( *res == NULL)
             throw GDLException( _t, "Variable is undefined: "+Name(res),true,false);
         }
+    | res=l_arrayexpr_mfcall_as_mfcall 
+        {
+            if( *res == NULL)
+            throw GDLException( _t, "Variable is undefined: "+Name(res),true,false);
+        }
     | res=l_deref
         {
             if( *res == NULL)
@@ -2049,7 +2797,6 @@
             aL->AssignAt( *res, right);
 
 //             aL->SetVariable( *res);
-            
 //             if( (*res)->EqType( right))
 //             {
 //                 (*res)->AssignAt( right, aL); // assigns inplace
@@ -2058,7 +2805,6 @@
 //             {
 //                 BaseGDL* rConv = right->Convert2( (*res)->Type(), BaseGDL::COPY);
 //                 auto_ptr<BaseGDL> conv_guard( rConv);
-                
 //                 (*res)->AssignAt( rConv, aL); // assigns inplace
 //             }
         }
@@ -2161,7 +2907,7 @@
 //                 {
 //                     r_guard.reset( e1);
 //                 }
-//             | e1=check_expr
+//             | e1=lib_function_call
 //                 {
 //                     if( !callStack.back()->Contains( e1)) 
 //                         r_guard.reset( e1);
@@ -2170,7 +2916,7 @@
             ( e1=indexable_expr
             | e1=indexable_tmp_expr { delete e1;}
 //            | e1=indexable_tmp_expr { r_guard.reset( e1);}
-            | e1=check_expr
+            | e1=lib_function_call
                 {
                     if( !callStack.back()->Contains( e1)) 
                         delete e1; // guard if no global data
@@ -2184,6 +2930,44 @@
 //                     r_guard.release();
 //             }
         )
+    | #(ASSIGN_ARRAYEXPR_MFCALL
+            ( e1=indexable_expr
+            | e1=indexable_tmp_expr { delete e1;}
+            | e1=lib_function_call
+                {
+                    if( !callStack.back()->Contains( e1)) 
+                        delete e1; 
+                }
+            )
+            { 
+                ProgNodeP l = _t;
+
+                // try MFCALL
+                try
+                {
+    
+                    res=l_arrayexpr_mfcall_as_mfcall( l);
+    
+                    if( right != (*res))
+                    {
+                        delete *res;
+                        *res = right->Dup();
+                    }
+                }
+                catch( GDLException& ex)
+                {
+                // try ARRAYEXPR
+                    try
+	                {
+                        res=l_arrayexpr_mfcall_as_arrayexpr(l, right);
+	                }
+                    catch( GDLException& ex2)
+                    {
+                        throw GDLException(ex.toString() + " or "+ex2.toString());
+                    }
+                }
+            }
+        )
     | #(ASSIGN_REPLACE //???e1=expr
 //             { 
 //                 auto_ptr<BaseGDL> r_guard;
@@ -2193,7 +2977,7 @@
                     delete e1;
 //                    r_guard.reset( e1);
                 }
-            | e1=check_expr
+            | e1=lib_function_call
                 {
                     if( !callStack.back()->Contains( e1)) 
                         delete e1;
@@ -2266,6 +3050,7 @@
 //                 *res = right->Dup();
 //             }
 //         }
+    | res=l_arrayexpr_mfcall[ right]
 //    | res=l_dot_expr[ right]
     | #(dot:DOT  // struct assignment
             { 
@@ -2302,83 +3087,63 @@
 {
 	assert( _t != NULL);
 
+	_retTree = _t->getNextSibling();
+
 	if( _t->getType() == VAR)
 	{
-		ProgNodeP var = _t;
+		return &callStack.back()->GetKW(_t->varIx); 
+//		ProgNodeP var = _t;
 // 		match(antlr::RefAST(_t),VAR);
-		_t = _t->getNextSibling();
-		
-		
-		res=&callStack.back()->GetKW(var->varIx); 
-		
 	}
 	else
 	{
-		ProgNodeP varPtr = _t;
+		return &_t->var->Data(); // returns BaseGDL* of var (DVar*) 
+//		ProgNodeP varPtr = _t;
 // 		match(antlr::RefAST(_t),VARPTR);
-		_t = _t->getNextSibling();
-		
-		res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
-		
 	}
-
-	_retTree = _t;
 	return res;
 }
-    : var:VAR // DNode.varIx is index into functions/procedures environment
-        {
-
-            res=&callStack.back()->GetKW(var->varIx); 
-        }
-    | varPtr:VARPTR // DNode.var   is ptr to common block variable
-        {
-            res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
-        }
+    : VAR // DNode.varIx is index into functions/procedures environment
+    | VARPTR // DNode.var   is ptr to common block variable
     ;
 
 l_defined_simple_var returns [BaseGDL** res]
 {
 	if( _t->getType() == VAR)
 	{
-		var = _t;
 // 		match(antlr::RefAST(_t),VAR);
-		_t = _t->getNextSibling();
-		
-		res=&callStack.back()->GetKW(var->varIx); 
+		res=&callStack.back()->GetKW(_t->varIx); 
 		if( *res == NULL)
-		throw GDLException( var, "Variable is undefined: "+
-		callStack.back()->GetString(var->varIx),true,false);
+		throw GDLException( _t, "Variable is undefined: "+
+		callStack.back()->GetString(_t->varIx),true,false);
 		
 	}
 	else
 	{
-		varPtr = _t;
 // 		match(antlr::RefAST(_t),VARPTR);
-		_t = _t->getNextSibling();
-		
-		res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
+		res=&_t->var->Data(); // returns BaseGDL* of var (DVar*) 
 		if( *res == NULL)
 		throw GDLException( _t, "Variable is undefined: "+
 		callStack.back()->GetString( *res),true,false);
 		
 	}
-	_retTree = _t;
+	_retTree = _t->getNextSibling();
 	return res;
 }
-    : var:VAR // DNode.varIx is index into functions/procedures environment
-        {
-            res=&callStack.back()->GetKW(var->varIx); 
-            if( *res == NULL)
-            throw GDLException( _t, "Variable is undefined: "+
-                callStack.back()->GetString(var->varIx),true,false);
-        }
-    | varPtr:VARPTR // DNode.var   is ptr to common block variable
-        {
-            res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
-            if( *res == NULL)
-            throw GDLException( _t, "Variable is undefined: "+
-                callStack.back()->GetString( *res),true,false);
-        }
+    : VAR // DNode.varIx is index into functions/procedures environment
+//         {
+//             res=&callStack.back()->GetKW(var->varIx); 
+//             if( *res == NULL)
+//             throw GDLException( _t, "Variable is undefined: "+
+//                 callStack.back()->GetString(var->varIx),true,false);
+//         }
+    | VARPTR // DNode.var   is ptr to common block variable
+//         {
+//             res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
+//             if( *res == NULL)
+//             throw GDLException( _t, "Variable is undefined: "+
+//                 callStack.back()->GetString( *res),true,false);
+//         }
     ;
 
 l_sys_var returns [BaseGDL** res]
@@ -2412,309 +3177,55 @@
 // expressions which always only return a value
 // expecting to delete any sub-expressions
 r_expr returns [BaseGDL* res]
-    : e:EXPR
-        { res = e->Eval();}
-    | a:ARRAYDEF
-        { res = a->Eval(); _t=_retTree;}
-//     | c:ARRAYDEF_CONST
-//         { res = c->Eval(); _t=_retTree;}
-    | s:STRUC
-        { res = s->Eval(); _t=_retTree;}
-    | n:NSTRUC
-        { res = n->Eval(); _t=_retTree;}
-    | r:NSTRUC_REF
-        { res = r->Eval(); _t=_retTree;}
-//     | res=array_def
-//     | res=struct_def
-
-// {
-//     BaseGDL* e1;
-//     BaseGDL* e2;
-// }
-//     :	#(NOT_OP e1=expr { res= e1->NotOp();} )
-//     |	#(UMINUS e1=expr { res= e1->UMinus();} )
-//     |	#(AND_OP e1=expr e2=expr)			// binary operators...
-//         {
-//             AdjustTypes(e1,e2);
-//             if( e1->Scalar())
-//             res= e2->AndOp(e1); // scalar+scalar or array+scalar
-//             else
-//             if( e2->Scalar())
-//             res= e1->AndOpInv(e2); // array+scalar
-//             else
-//             if( e1->N_Elements() <= e2->N_Elements())
-//             res= e1->AndOpInv(e2); // smaller_array + larger_array or same size
-//             else
-//             res= e2->AndOp(e1); // smaller + larger
-//         }
-//     |	#(OR_OP  e1=expr e2=expr)
-//         {
-//             AdjustTypes(e1,e2);
-//             if( e1->Scalar())
-//             res= e2->OrOp(e1); // scalar+scalar or array+scalar
-//             else
-//             if( e2->Scalar())
-//             res= e1->OrOpInv(e2); // array+scalar
-//             else
-//             if( e1->N_Elements() <= e2->N_Elements())
-//             res= e1->OrOpInv(e2); // smaller_array + larger_array or same size
-//             else
-//             res= e2->OrOp(e1); // smaller + larger
-//         }
-//     |	#(XOR_OP e1=expr e2=expr) // xor is only defined for integers
-//         {
-//             AdjustTypes(e1,e2);
-//             if( e1->N_Elements() <= e2->N_Elements())
-//             res= e1->XorOp(e2); // smaller_array + larger_array or same size
-//             else
-//             res= e2->XorOp(e1); // smaller + larger
-//         }
-//     |	#(EQ_OP e1=expr e2=expr)
-//         {
-//             AdjustTypes(e1,e2);
-//             res=e1->EqOp(e2);
-//         }
-//     |	#(NE_OP e1=expr e2=expr)
-//         {
-//             AdjustTypes(e1,e2);
-//             res=e1->NeOp(e2);
-//         }
-//     |	#(LE_OP e1=expr e2=expr)
-//         {
-//             AdjustTypes(e1,e2);
-//             res=e1->LeOp(e2);
-//         }
-//     |	#(LT_OP e1=expr e2=expr)
-//         {
-//             AdjustTypes(e1,e2);
-//             res=e1->LtOp(e2);
-//         }
-//     |	#(GE_OP e1=expr e2=expr)
-//         {
-//             AdjustTypes(e1,e2);
-//             res=e1->GeOp(e2);
-//         }
-//     |	#(GT_OP e1=expr e2=expr)
-//         {
-//             AdjustTypes(e1,e2);
-//             res=e1->GtOp(e2);
-//         }
-//     |	#(PLUS  e1=expr e2=expr)
-//         {
-//             AdjustTypes(e1,e2);
-//             if( e1->Scalar())
-//             res= e2->AddInv(e1); // scalar+scalar or array+scalar
-//             else
-//             if( e2->Scalar())
-//             res= e1->Add(e2); // array+scalar
-//             else
-//             if( e1->N_Elements() <= e2->N_Elements())
-//             res= e1->Add(e2); // smaller_array + larger_array or same size
-//             else
-//             res= e2->AddInv(e1); // smaller + larger
-//         }
-//     |	#(MINUS e1=expr e2=expr)
-//         {
-//             AdjustTypes(e1,e2);
-//             if( e1->Scalar())
-//             res= e2->SubInv(e1); // scalar+scalar or array+scalar
-//             else
-//             if( e2->Scalar())
-//             res= e1->Sub(e2); // array+scalar
-//             else
-//             if( e1->N_Elements() <= e2->N_Elements())
-//             res= e1->Sub(e2); // smaller_array + larger_array or same size
-//             else
-//             res= e2->SubInv(e1); // smaller + larger
-//         }
-//     |	#(LTMARK e1=expr e2=expr)
-//         {
-//             AdjustTypes(e1,e2);
-//             if( e1->Scalar())
-//             res= e2->LtMark(e1); // scalar+scalar or array+scalar
-//             else
-//             if( e2->Scalar())
-//             res= e1->LtMark(e2); // array+scalar
-//             else
-//             if( e1->N_Elements() <= e2->N_Elements())
-//             res= e1->LtMark(e2); // smaller_array + larger_array or same size
-//             else
-//             res= e2->LtMark(e1); // smaller + larger
-//         }
-//     |	#(GTMARK e1=expr e2=expr)
-//         {
-//             AdjustTypes(e1,e2);
-//             if( e1->Scalar())
-//             res= e2->GtMark(e1); // scalar+scalar or array+scalar
-//             else
-//             if( e2->Scalar())
-//             res= e1->GtMark(e2); // array+scalar
-//             else
-//             if( e1->N_Elements() <= e2->N_Elements())
-//             res= e1->GtMark(e2); // smaller_array + larger_array or same size
-//             else
-//             res= e2->GtMark(e1); // smaller + larger
-//         }
-//     |	#(ASTERIX e1=expr e2=expr)
-//         {
-//             AdjustTypes(e1,e2);
-//             if( e1->Scalar())
-//             res= e2->Mult(e1); // scalar+scalar or array+scalar
-//             else
-//             if( e2->Scalar())
-//             res= e1->Mult(e2); // array+scalar
-//             else
-//             if( e1->N_Elements() <= e2->N_Elements())
-//             res= e1->Mult(e2); // smaller_array + larger_array or same size
-//             else
-//             res= e2->Mult(e1); // smaller + larger
-//         }
-//     |	#(MATRIX_OP1 e1=expr e2=expr) // #
-//         {
-//             DType aTy=e1->Type();
-//             DType bTy=e2->Type();
-//             DType maxTy=(DTypeOrder[aTy] >= DTypeOrder[bTy])? aTy: bTy;
-
-//             DType cTy=maxTy;
-//             if( maxTy == BYTE || maxTy == INT)
-//             cTy=LONG;
-//             else if( maxTy == UINT)
-//             cTy=ULONG;
-
-//             if( aTy != cTy) e1=e1->Convert2( cTy);
-
-//             AdjustTypes(e1,e2);
-//             res=e1->MatrixOp(e2);
-//         }
-//     |	#(MATRIX_OP2 e1=expr e2=expr) // ##
-//         {
-//             DType aTy=e1->Type();
-//             DType bTy=e2->Type();
-//             DType maxTy=(DTypeOrder[aTy] >= DTypeOrder[bTy])? aTy: bTy;
-
-//             DType cTy=maxTy;
-//             if( maxTy == BYTE || maxTy == INT)
-//             cTy=LONG;
-//             else if( maxTy == UINT)
-//             cTy=ULONG;
-
-//             if( aTy != cTy) e1=e1->Convert2( cTy);
-
-//             AdjustTypes(e1,e2);
-//             res=e2->MatrixOp(e1);
-//         }
-//     |	#(SLASH e1=expr e2=expr)
-//         {
-//             AdjustTypes(e1,e2);
-//             if( e1->Scalar())
-//             res= e2->DivInv(e1); // scalar+scalar or array+scalar
-//             else
-//             if( e2->Scalar())
-//             res= e1->Div(e2); // array+scalar
-//             else
-//             if( e1->N_Elements() <= e2->N_Elements())
-//             res= e1->Div(e2); // smaller_array + larger_array or same size
-//             else
-//             res= e2->DivInv(e1); // smaller + larger
-//         }
-//     |	#(MOD_OP e1=expr e2=expr)
-//         {
-//             AdjustTypes(e1,e2);
-//             if( e1->Scalar())
-//             res= e2->ModInv(e1); // scalar+scalar or array+scalar
-//             else
-//             if( e2->Scalar())
-//             res= e1->Mod(e2); // array+scalar
-//             else
-//             if( e1->N_Elements() <= e2->N_Elements())
-//             res= e1->Mod(e2); // smaller_array + larger_array or same size
-//             else
-//             res= e2->ModInv(e1); // smaller + larger
-//         }
-//     |	#(POW e1=expr e2=expr)
-//         {
-//            // special handling for complex
-//             DType aTy=e1->Type();
-//             if( aTy == COMPLEX)
-//             {
-//                 DType bTy=e2->Type();
-//                 if( IntType( bTy))
-//                 {
-//                     e2 = e2->Convert2( FLOAT);
-//                     res = e1->Pow( e2);
-//                     goto endPOW;
-//                 }
-//                 else if( bTy == FLOAT)
-//                 {
-//                     res = e1->Pow( e2);
-//                     goto endPOW;
-//                 }
-//             }
-//             else if( aTy == COMPLEXDBL)
-//             {
-//                 DType bTy=e2->Type();
-//                 if( IntType( bTy))
-//                 {
-//                     e2 = e2->Convert2( DOUBLE);
-//                     res = e1->Pow( e2);
-//                     goto endPOW;
-//                 }
-//                 else if( bTy == DOUBLE)
-//                 {
-//                     res = e1->Pow( e2);
-//                     goto endPOW;
-//                 }
-//             }
-
-//             DType convertBackT; 
-
-//             // convert back
-//             if( IntType( e2->Type()) && 
-//                 DTypeOrder[e2->Type()] > DTypeOrder[e1->Type()])
-//                 convertBackT = e1->Type();
-//             else
-//                 convertBackT = UNDEF;
-
-//             AdjustTypes(e2,e1); // order crucial here (for converting back)
-
-//             if( e1->Scalar())
-//             res= e2->PowInv(e1); // scalar+scalar or array+scalar
-//             else
-//             if( e2->Scalar())
-//             res= e1->Pow(e2); // array+scalar
-//             else
-//             if( e1->N_Elements() <= e2->N_Elements())
-//             res= e1->Pow(e2); // smaller_array + larger_array or same size
-//             else
-//             res= e2->PowInv(e1); // smaller + larger
-//             if( convertBackT != UNDEF)
-//             {
-//                 res = res->Convert2( convertBackT, BaseGDL::CONVERT);
-//             }
-//             endPOW:
-//         }
+{
+	switch ( _t->getType()) {
+	case EXPR:
+	case ARRAYDEF:
+	case STRUC:
+	case NSTRUC:
+	case NSTRUC_REF:
+	{
+		res = _t->Eval(); 
+		break;
+	}
+	case DEC:
+	{
+		res=l_decinc_expr( _t->getFirstChild(), DEC);
+		break;
+	}
+	case INC:
+	{
+		res=l_decinc_expr( _t->getFirstChild(), INC);
+		break;
+	}
+	case POSTDEC:
+	{
+		res=l_decinc_expr( _t->getFirstChild(), POSTDEC);
+		break;
+	}
+//	case POSTINC:
+	default:
+	{
+		res=l_decinc_expr( _t->getFirstChild(), POSTINC);
+		break;
+	}
+// 	default:
+// 	{
+// 		throw antlr::NoViableAltException(antlr::RefAST(_t));
+// 	}
+	}
+	_retTree = _t->getNextSibling();
+	return res;
+}
+    : EXPR
+    | ARRAYDEF
+    | STRUC
+    | NSTRUC
+    | NSTRUC_REF
     |	#(DEC res=l_decinc_expr[ DEC])
     |	#(INC res=l_decinc_expr[ INC])
     |	#(POSTDEC res=l_decinc_expr[ POSTDEC])
     |	#(POSTINC res=l_decinc_expr[ POSTINC])
-//     // logical expressions
-//     |   #(LOG_AND e1=expr e2=expr)
-//         {
-//             if( !e1->LogTrue()) {res = new DByteGDL( 0); break;}
-//             if( !e2->LogTrue()) {res = new DByteGDL( 0); break;}
-//             res = new DByteGDL( 1);
-//         }
-//     |   #(LOG_OR e1=expr e2=expr)
-//         {
-//             if( e1->LogTrue()) {res = new DByteGDL( 1); break;}
-//             if( e2->LogTrue()) {res = new DByteGDL( 1); break;}
-//             res = new DByteGDL( 0);
-//         }
-//     |   #(LOG_NEG e1=expr)
-//         {
-//             res = e1->LogNeg();
-//         }
-//    | res=constant
     ;
 
 array_expr returns [BaseGDL* res]
@@ -2724,15 +3235,164 @@
     ArrayIndexListGuard guard;
     auto_ptr<BaseGDL> r_guard;
 
-    ExprListT        exprList; // for cleanup
-    IxExprListT      ixExprList;
-    SizeT nExpr;
-    BaseGDL* s;
+    ExprListT        exprList; // for cleanup
+    IxExprListT      ixExprList;
+    SizeT nExpr;
+    BaseGDL* s;
+
+	ProgNodeP retTree = _t->getNextSibling();
+//	match(antlr::RefAST(_t),ARRAYEXPR);
+	_t = _t->getFirstChild();
+	
+	switch ( _t->getType()) {
+	case VAR:
+	case CONSTANT:
+	case DEREF:
+	case SYSVAR:
+	case VARPTR:
+	{
+        r=_t->EvalNC();
+		//r=indexable_expr(_t);
+		_t = _t->getNextSibling(); //_retTree;
+		break;
+	}
+	case FCALL_LIB:
+	{
+		r=lib_function_call(_t);
+		_t = _t->getNextSibling();
+		
+		if( !callStack.back()->Contains( r)) 
+            r_guard.reset( r); // guard if no global data
+		
+		break;
+	}
+// 	case ASSIGN:
+// 	case ASSIGN_REPLACE:
+// 	case ASSIGN_ARRAYEXPR_MFCALL:
+// 	case ARRAYDEF:
+// 	case ARRAYEXPR:
+// 	case ARRAYEXPR_MFCALL:
+// 	case EXPR:
+// 	case FCALL:
+// 	case FCALL_LIB_RETNEW:
+// 	case MFCALL:
+// 	case MFCALL_PARENT:
+// 	case NSTRUC:
+// 	case NSTRUC_REF:
+// 	case POSTDEC:
+// 	case POSTINC:
+// 	case STRUC:
+// 	case DEC:
+// 	case INC:
+// 	case DOT:
+// 	case QUESTION:
+    default:
+	{
+		r=indexable_tmp_expr(_t);
+		_t = _retTree;
+		r_guard.reset( r);
+		break;
+	}
+	}
+	
+
+	aL = _t->arrIxList;
+	assert( aL != NULL);
+	guard.reset(aL);
+	
+//    ax = _t
+//	match(antlr::RefAST(_t),ARRAYIX);
+	_t = _t->getFirstChild();
+	
+	nExpr = aL->NParam();
+	
+	if( nExpr == 0)
+	{
+        goto empty;
+	}
+	//                 if( nExpr > 1)
+	//                 {
+	//                     ixExprList.reserve( nExpr);
+	//                     exprList.reserve( nExpr);
+	//                 }
+	//                if( nExpr == 0) goto empty;
+	
+	for (;;) {
+//		if ((_tokenSet_1.member(_t->getType()))) {
+			switch ( _t->getType()) {
+			case VAR:
+			case CONSTANT:
+			case DEREF:
+			case SYSVAR:
+			case VARPTR:
+			{
+				s=_t->EvalNC();//indexable_expr(_t);
+				_t = _t->getNextSibling();//_retTree;
+				break;
+			}
+			case FCALL_LIB:
+			{
+				s=lib_function_call(_t);
+				_t = _retTree;
+				
+				if( !callStack.back()->Contains( s)) 
+				exprList.push_back( s);
+				
+				break;
+			}
+// 			case ASSIGN:
+// 			case ASSIGN_REPLACE:
+// 			case ASSIGN_ARRAYEXPR_MFCALL:
+// 			case ARRAYDEF:
+// 			case ARRAYEXPR:
+// 			case ARRAYEXPR_MFCALL:
+// 			case EXPR:
+// 			case FCALL:
+// 			case FCALL_LIB_RETNEW:
+// 			case MFCALL:
+// 			case MFCALL_PARENT:
+// 			case NSTRUC:
+// 			case NSTRUC_REF:
+// 			case POSTDEC:
+// 			case POSTINC:
+// 			case STRUC:
+// 			case DEC:
+// 			case INC:
+// 			case DOT:
+// 			case QUESTION:
+            default:
+			{
+				s=indexable_tmp_expr(_t);
+				_t = _retTree;
+				exprList.push_back( s);
+				break;
+			}
+			} // switch
+			
+			ixExprList.push_back( s);
+			if( ixExprList.size() == nExpr)
+                break; // finish
+			
+		} // for
+// 		else {
+// 			assert( 0);//goto _loop106;
+// 		}
+		
+	empty:
+	//_retTree = ax;
+	res = aL->Index( r, ixExprList);
+	//                 aL->Init( ixExprList);
+	//                 aL->SetVariable( r);
+	//                 res=r->Index( aL);
+	//                ClearTmpList();
+
+    _retTree = retTree;
+	return res;
 }
     : #(ARRAYEXPR 
             ( r=indexable_expr
             | r=indexable_tmp_expr { r_guard.reset( r);}
-            | r=check_expr
+            | r=lib_function_call
                 {
                     if( !callStack.back()->Contains( r)) 
                         r_guard.reset( r); // guard if no global data
@@ -2750,7 +3410,7 @@
 
                     if( nExpr == 0)
                     {
-                        goto empty;
+                        goto empty2;
                     }
                     //                 if( nExpr > 1)
                     //                 {
@@ -2761,7 +3421,7 @@
                 }
                 (
                     ( s=indexable_expr
-                    | s=check_expr
+                    | s=lib_function_call
                         {
                             if( !callStack.back()->Contains( s)) 
                             exprList.push_back( s);
@@ -2777,7 +3437,7 @@
                 //            { empty: ;}
             )
             {
-empty:
+empty2:
                 //_retTree = ax;
                 res = aL->Index( r, ixExprList);
 //                 aL->Init( ixExprList);
@@ -2980,7 +3640,7 @@
 //                 }
 //             }
         ) // trinary operator
-    | res=array_expr
+    | (a:ARRAYEXPR { res = a->Eval();}) //res=array_expr
     | res=dot_expr
     | res=assign_expr
     | res=function_call
@@ -2991,6 +3651,9 @@
 // not owned by caller 
 indexable_expr returns [BaseGDL* res]
 {
+	_retTree = _t->getNextSibling();
+    return _t->EvalNC();
+
     BaseGDL** e2;
 }
     : e2=l_defined_simple_var
@@ -3027,7 +3690,7 @@
 	}
 }
     : res=tmp_expr
-    | res=check_expr
+    | res=lib_function_call
         {
             if( callStack.back()->Contains( res)) 
                 res = res->Dup();
@@ -3035,9 +3698,9 @@
     ;
 
 
-check_expr returns [BaseGDL* res]
-    : res=lib_function_call 
-    ;
+// check_expr returns [BaseGDL* res]
+//     : res=lib_function_call 
+//     ;
 
 // l_expr used as r_expr and true r_expr
 tmp_expr returns [BaseGDL* res]
@@ -3057,7 +3720,6 @@
 //                 e1=expr
 //             { 
 //                 auto_ptr<BaseGDL> e1_guard(e1);
-
 //                 if( e1->True())
 //                 {
 //                     res=expr(_t);
@@ -3069,7 +3731,8 @@
 //                 }
 //             }
         ) // trinary operator
-    | res=array_expr
+    | (a:ARRAYEXPR { res = a->Eval();}) //res=array_expr
+//    | res=array_expr
     | res=dot_expr
     | res=assign_expr
     | res=function_call
@@ -3086,9 +3749,9 @@
     BaseGDL** l;
     BaseGDL*  r;
 
+	ProgNodeP startNode = _t;
 	if( _t->getType() == ASSIGN) 
 	{
-		ProgNodeP __t130 = _t;
 // 		match(antlr::RefAST(_t),ASSIGN);
 		_t = _t->getFirstChild();
 		
@@ -3096,7 +3759,7 @@
 		
 		if( _t->getType() == FCALL_LIB)
 		{
-			res=check_expr(_t);
+			res=lib_function_call(_t);
 			_t = _retTree;
 			
 			if( !callStack.back()->Contains( res)) 
@@ -3120,12 +3783,73 @@
 		else
 		res = res->Dup();
 		
-		_t = __t130;
-		_t = _t->getNextSibling();
 	}
+    else if( _t->getType() == ASSIGN_ARRAYEXPR_MFCALL) 
+        {
+
+		_t = _t->getFirstChild();
+		
+		auto_ptr<BaseGDL> r_guard;
+		
+		if( _t->getType() == FCALL_LIB)
+		{
+			res=lib_function_call(_t);
+			_t = _retTree;
+			
+			if( !callStack.back()->Contains( res)) 
+			r_guard.reset( res);
+			
+		}
+        else
+		{
+			res=tmp_expr(_t);
+			_t = _retTree;
+			
+			r_guard.reset( res);
+			
+		}
+
+        ProgNodeP mark = _t;
+
+        // try MFCALL
+        try
+            {
+                l=l_arrayexpr_mfcall_as_mfcall( mark);
+    
+                if( res != (*l))
+                    {
+                        delete *l;
+                        *l = res->Dup();     
+		
+                        if( r_guard.get() == res) // owner
+                            {
+                                r_guard.release(); 
+                            }
+                        else
+                            res = res->Dup();
+                    }
+            }
+        catch( GDLException& ex)
+            {
+                // try ARRAYEXPR
+                try
+	                {
+                        l=l_arrayexpr_mfcall_as_arrayexpr(mark, res);
+
+                        if( r_guard.get() == res) // owner
+                            r_guard.release();
+                        else
+                            res = res->Dup();
+	                }
+                catch( GDLException& ex2)
+                    {
+                        throw GDLException(ex.toString() + " or "+ex2.toString());
+                    }
+            }
+
+        }
     else
 	{
-		ProgNodeP __t132 = _t;
 // 		match(antlr::RefAST(_t),ASSIGN_REPLACE);
 		_t = _t->getFirstChild();
 		
@@ -3134,7 +3858,7 @@
 		if( _t->getType() == FCALL_LIB)
 		{
 
-			res=check_expr(_t);
+			res=lib_function_call(_t);
 			_t = _retTree;
 			
 			if( !callStack.back()->Contains( res)) 
@@ -3185,15 +3909,12 @@
 		else
 		res = res->Dup();
 		}
-		
-		_t = __t132;
-		_t = _t->getNextSibling();
-	}
+    }
 
-	_retTree = _t;
+	_retTree = startNode->getNextSibling();
 	return res;
-
 }
+
     : #(ASSIGN 
             { 
                 auto_ptr<BaseGDL> r_guard;
@@ -3202,7 +3923,29 @@
                 {
                     r_guard.reset( res);
                 }
-            | res=check_expr
+            | res=lib_function_call
+                {
+                    if( !callStack.back()->Contains( res)) 
+                        r_guard.reset( res);
+                }
+            )
+            l=l_expr[ res]
+            { 
+                if( r_guard.get() == res) // owner
+                    r_guard.release();
+                else
+                    res = res->Dup();
+            } // here res is returned!
+        )
+    | #(ASSIGN_ARRAYEXPR_MFCALL
+            { 
+                auto_ptr<BaseGDL> r_guard;
+            } 
+            ( res=tmp_expr
+                {
+                    r_guard.reset( res);
+                }
+            | res=lib_function_call
                 {
                     if( !callStack.back()->Contains( res)) 
                         r_guard.reset( res);
@@ -3224,7 +3967,7 @@
                 {
                     r_guard.reset( res);
                 }
-            | res=check_expr
+            | res=lib_function_call
                 {
                     if( !callStack.back()->Contains( res)) 
                         r_guard.reset( res);
@@ -3252,6 +3995,8 @@
         )
     ;
 
+
+
 simple_var returns [BaseGDL* res]
 {
 	assert( _t != NULL);
@@ -3366,20 +4111,21 @@
     ;
 
 constant returns [BaseGDL* res]
-    : c:CONSTANT
-        {
-            res=c->cData->Dup(); 
-        }
+{
+	_retTree = _t->getNextSibling();
+	return _t->cData->Dup(); 
+}
+  : CONSTANT
+//         {
+//             res=c->cData->Dup(); 
+//         }
   ;
 
 constant_nocopy returns [BaseGDL* res]
 {
-
 	//BaseGDL* 
-    res = _t->cData; // no ->Dup(); 
-		
 	_retTree = _t->getNextSibling();
-	return res;
+	return _t->cData; // no ->Dup(); 
 }
     : c:CONSTANT
         {
@@ -3400,8 +4146,8 @@
 	ProgNodeP& fl = _t;
 	EnvT* newEnv=new EnvT( fl, fl->libFun);//libFunList[fl->funIx]);
 	
-	parameter_def(_t->getFirstChild(), newEnv);
-	
+    parameter_def(_t->getFirstChild(), newEnv);
+
 	// push id.pro onto call stack
 	callStack.push_back(newEnv);
 	// make the call
@@ -3411,7 +4157,6 @@
 //    if( res == NULL)
 //       throw GDLException( _t, "");
 
-
 	_retTree = rTree;
 	return res;
 }
@@ -3429,101 +4174,289 @@
                 //*** MUST always return a defined expression
             }
         )
-    ;    
+    ;    
+
+lib_function_call_retnew returns[ BaseGDL* res]
+{ 
+    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+    StackGuard<EnvStackT> guard(callStack);
+
+	ProgNodeP rTree = _t->getNextSibling();
+
+// 	match(antlr::RefAST(_t),FCALL_LIB_RETNEW);
+//	_t = _t->getFirstChild();
+// 	match(antlr::RefAST(_t),IDENTIFIER);
+	EnvT* newEnv=new EnvT( _t, _t->libFun);//libFunList[fl->funIx]);
+
+// 	_t =_t->getFirstChild();
+	
+// 	EnvT* newEnv=new EnvT( fl, fl->libFun);//libFunList[fl->funIx]);
+    static int n_elementsIx = LibFunIx("N_ELEMENTS");
+    static DLibFun* n_elementsFun = libFunList[n_elementsIx];
+
+    if( _t->libFun == n_elementsFun)
+        {
+            parameter_def_n_elements(_t->getFirstChild(), newEnv);
+        }
+    else
+        {
+            parameter_def(_t->getFirstChild(), newEnv);
+        }
+
+
+//	parameter_def(_t->getFirstChild(), newEnv);
+	
+	// push id.pro onto call stack
+	callStack.push_back(newEnv);
+	// make the call
+	//BaseGDL* 
+    res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
+	//*** MUST always return a defined expression
+	
+	_retTree = rTree;
+	return res;
+}
+	: #(fll:FCALL_LIB_RETNEW //fll:IDENTIFIER
+            {
+                //EnvT* 
+                newEnv=new EnvT( fll, fll->libFun);//libFunList[fl->funIx]);
+            }
+            parameter_def[ newEnv]
+            {
+                // push id.pro onto call stack
+                callStack.push_back(newEnv);
+                // make the call
+                res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
+                //*** MUST always return a defined expression
+            }
+        )
+    ;    
+
+
+function_call returns[ BaseGDL* res]
+{ 
+    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+    StackGuard<EnvStackT> guard(callStack);
+    BaseGDL *self;
+    EnvUDT*  newEnv;
+    ProgNodeP startNode = _t;
+    ProgNodeP mark;
+}
+    : ( 
+          #(MFCALL 
+                self=expr mp:IDENTIFIER
+                {  
+                    auto_ptr<BaseGDL> self_guard(self);
+                    
+                    newEnv=new EnvUDT( self, mp);
+
+                    self_guard.release();
+                }
+                parameter_def[ newEnv]
+            )
+        | #(MFCALL_PARENT 
+                self=expr parent:IDENTIFIER p:IDENTIFIER
+                {
+                    auto_ptr<BaseGDL> self_guard(self);
+                    
+                    newEnv=new EnvUDT( self, p,
+                        parent->getText());
+
+                    self_guard.release();
+                }
+                parameter_def[ newEnv]
+            )
+        | #(f:FCALL //f:IDENTIFIER
+                {
+                    SetFunIx( f);
+                    
+                    newEnv=new EnvUDT( f, funList[f->funIx]);
+                }
+                parameter_def[ newEnv]
+            )
+        | #(ARRAYEXPR_MFCALL
+            {
+                mark = _t;
+                _t = _t->getNextSibling(); // skip DOT
+            }
+
+            self=expr mp2:IDENTIFIER
+
+            {  
+                auto_ptr<BaseGDL> self_guard(self);
+        
+                try {
+                    newEnv=new EnvUDT( self, mp2);
+                    self_guard.release();
+                }
+                catch( GDLException& ex)
+                {
+                    goto tryARRAYEXPR;
+                }
+            } 
+
+            parameter_def[ newEnv]
+            )
+        )        
+            {
+                // push environment onto call stack
+                callStack.push_back(newEnv);
+            
+                // make the call
+                res=call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
+
+                _retTree = startNode->getNextSibling();
+                return res;
+
+                tryARRAYEXPR:;
+                //_t = mark;
+
+                ProgNodeP dot = mark;
+                // 	match(antlr::RefAST(_t),DOT);
+                _t = mark->getFirstChild();
+	
+                SizeT nDot=dot->nDot;
+                auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+	
+                r_dot_array_expr(_t, aD.get());
+                _t = _retTree;
+                for (; _t != NULL;) {
+                    tag_array_expr(_t, aD.get());
+                    _t = _retTree;
+                }
+                res= aD->Resolve();
+
+                _retTree = startNode->getNextSibling();
+                return res;
+            }
+	;	
+
+
+
+l_arrayexpr_mfcall [BaseGDL* right] returns [BaseGDL** res]
+{ 
+    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+    StackGuard<EnvStackT> guard(callStack);
+    BaseGDL *self;
+    EnvUDT*  newEnv;
+    ProgNodeP startNode = _t;
+}
+    : #(ARRAYEXPR_MFCALL
+        {
+            ProgNodeP mark = _t;
+            _t = _t->getNextSibling(); // skip DOT
+        }
+
+        self=expr mp2:IDENTIFIER
+
+        {  
+            auto_ptr<BaseGDL> self_guard(self);
+        
+            try {
+                newEnv=new EnvUDT( self, mp2, "", true);
+                self_guard.release();
+            }
+            catch( GDLException& ex)
+            {
+                goto tryARRAYEXPR;
+            }
+        }    
+
+            parameter_def[ newEnv]
+        )
+        {
+            // push environment onto call stack
+            callStack.push_back(newEnv);
+            
+            // make the call
+            res=call_lfun(static_cast<DSubUD*>(
+                    newEnv->GetPro())->GetTree());
+
+            _retTree = startNode->getNextSibling();
+            return res;
+
+            tryARRAYEXPR:;
+            _t = mark;
+        }   
+        #(dot:DOT  // struct assignment
+            { 
+                SizeT nDot=dot->nDot;
+                auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+            } 
+            l_dot_array_expr[ aD.get()] 
+            (tag_array_expr[ aD.get()] /* nDot times*/ )+ 
+        )
+        {
+            if( right == NULL)
+            throw GDLException( _t, 
+                                "Struct expression not allowed in this context.",
+                                true,false);
+            
+            aD->Assign( right);
 
-lib_function_call_retnew returns[ BaseGDL* res]
-{ 
-    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
-    StackGuard<EnvStackT> guard(callStack);
+            res=NULL;
 
-	ProgNodeP rTree = _t->getNextSibling();
+            _retTree = startNode->getNextSibling();
+            return res;
+        }
+    ;
 
-// 	match(antlr::RefAST(_t),FCALL_LIB_RETNEW);
-//	_t = _t->getFirstChild();
-// 	match(antlr::RefAST(_t),IDENTIFIER);
-	EnvT* newEnv=new EnvT( _t, _t->libFun);//libFunList[fl->funIx]);
 
-// 	_t =_t->getFirstChild();
-	
-// 	EnvT* newEnv=new EnvT( fl, fl->libFun);//libFunList[fl->funIx]);
-	
-	parameter_def(_t->getFirstChild(), newEnv);
-	
-	// push id.pro onto call stack
-	callStack.push_back(newEnv);
-	// make the call
-	//BaseGDL* 
-    res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
-	//*** MUST always return a defined expression
-	
-	_retTree = rTree;
-	return res;
-}
-	: #(fll:FCALL_LIB_RETNEW //fll:IDENTIFIER
-            {
-                //EnvT* 
-                newEnv=new EnvT( fll, fll->libFun);//libFunList[fl->funIx]);
-            }
-            parameter_def[ newEnv]
-            {
-                // push id.pro onto call stack
-                callStack.push_back(newEnv);
-                // make the call
-                res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
-                //*** MUST always return a defined expression
-            }
+
+l_arrayexpr_mfcall_as_arrayexpr [BaseGDL* right] returns [BaseGDL** res]
+    : #(ARRAYEXPR_MFCALL
+            #(dot:DOT  // struct assignment
+            { 
+                SizeT nDot=dot->nDot;
+                auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+            } 
+            l_dot_array_expr[ aD.get()] 
+            (tag_array_expr[ aD.get()] /* nDot times*/ )+ 
+            )         
         )
-    ;    
+        {
+            if( right == NULL)
+            throw GDLException( _t, 
+                                "Struct expression not allowed in this context.",
+                                true,false);
+            
+            aD->Assign( right);
 
+            res=NULL;
+        }
+    ;
 
-function_call returns[ BaseGDL* res]
+// function call can be l_values (within (#EXPR ...) only)
+l_arrayexpr_mfcall_as_mfcall returns[ BaseGDL** res]
 { 
     // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
     StackGuard<EnvStackT> guard(callStack);
     BaseGDL *self;
     EnvUDT*   newEnv;
 }
-    :    (
-        ( #(MFCALL 
-                self=expr mp:IDENTIFIER
-                {  
-                    auto_ptr<BaseGDL> self_guard(self);
-                    
-                    newEnv=new EnvUDT( self, mp);
-
-                    self_guard.release();
-                }
-                parameter_def[ newEnv]
-            )
-        | #(MFCALL_PARENT 
-                self=expr parent:IDENTIFIER p:IDENTIFIER
+    : #(ARRAYEXPR_MFCALL
                 {
+                    _t = _t->getNextSibling(); // skip DOT
+                }
+ 
+                self=expr mp2:IDENTIFIER
+                {  
                     auto_ptr<BaseGDL> self_guard(self);
                     
-                    newEnv=new EnvUDT( self, p,
-                        parent->getText());
+                    newEnv=new EnvUDT( self, mp2, "", true);
 
                     self_guard.release();
                 }
                 parameter_def[ newEnv]
-            )
-        | #(f:FCALL //f:IDENTIFIER
-                {
-                    SetFunIx( f);
-                    
-                    newEnv=new EnvUDT( f, funList[f->funIx]);
-                }
-                parameter_def[ newEnv]
-            )
         )
         {
             // push environment onto call stack
             callStack.push_back(newEnv);
             
             // make the call
-            res=call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
-        } 
-        )
+            res=call_lfun(static_cast<DSubUD*>(
+                    newEnv->GetPro())->GetTree());
+        }   
 	;	
 
 // function call can be l_values (within (#EXPR ...) only)
@@ -3627,6 +4560,60 @@
     ;
 
 // the environment must be on the callstack
+parameter_def_n_elements [EnvBaseT* actEnv] 
+{
+    auto_ptr<EnvBaseT> guard(actEnv); 
+    _retTree = _t;
+//     bool interruptEnableIn = interruptEnable;
+    if( _retTree != NULL)
+        {
+        if( _retTree->getType() == REF ||
+            _retTree->getType() == REF_EXPR ||
+            _retTree->getType() == REF_CHECK ||
+            _retTree->getType() == PARAEXPR)
+            {
+                try{
+//                     interruptEnable = false;
+                    static_cast<ParameterNode*>(_retTree)->Parameter( actEnv);
+//                     interruptEnable = interruptEnableIn;
+                } 
+                catch( GDLException& e)
+                    {
+//                         interruptEnable = interruptEnableIn;
+                        if( actEnv->NParam() == 0) 
+                            {
+                                BaseGDL* nP = NULL;
+                                actEnv->SetNextPar( nP);
+                            }
+                    }
+            }
+        }
+    try{
+        while(_retTree != NULL) {
+            static_cast<ParameterNode*>(_retTree)->Parameter( actEnv);
+        }    
+    }
+    catch( GDLException& e)
+        {
+            // update line number, currently set to caller->CallingNode()
+            // because actEnv is not on the stack yet, 
+            // report caller->Pro()'s name is ok, because we are not inside
+            // the call yet
+            e.SetErrorNodeP( actEnv->CallingNode());
+            throw e;
+        }
+
+    actEnv->Extra(); // expand _EXTRA
+
+	guard.release();
+	
+    return;
+}
+    : #(KEYDEF_REF_EXPR IDENTIFIER //ref_parameter
+        )             
+;
+
+// the environment must be on the callstack
 parameter_def [EnvBaseT* actEnv] 
 {
     auto_ptr<EnvBaseT> guard(actEnv); 
@@ -3653,246 +4640,10 @@
 	guard.release();
 	
     return;
-
-//     BaseGDL*  kval = NULL;
-//     BaseGDL*  pval;
-//     BaseGDL** kvalRef;
-//     BaseGDL** pvalRef;
-
-// // 	while(_t != NULL) {
-// // 		switch ( _t->getType()) {
-// // 		case KEYDEF_REF:
-// // 		{
-// // 			ProgNodeP __t160 = _t;
-
-// // // 			match(antlr::RefAST(_t),KEYDEF_REF);
-// // 			_t = _t->getFirstChild();
-// // 			knameR = _t;
-// // // 			match(antlr::RefAST(_t),IDENTIFIER);
-// // 			_t = _t->getNextSibling();
-// // 			kvalRef=ref_parameter(_t);
-// // 			_t = _retTree;
-// // 			// pass reference
-// // 			actEnv->SetKeyword( knameR->getText(), kvalRef); 
-			
-// // 			_t = __t160;
-// // 			_t = _t->getNextSibling();
-// // 			break;
-// // 		}
-// // 		case KEYDEF_REF_EXPR:
-// // 		{
-// // 			ProgNodeP __t161 = _t;
-
-// // // 			match(antlr::RefAST(_t),KEYDEF_REF_EXPR);
-// // 			_t = _t->getFirstChild();
-// // 			knameE = _t;
-// // // 			match(antlr::RefAST(_t),IDENTIFIER);
-// // 			_t = _t->getNextSibling();
-// // 			kval=expr(_t);
-// // 			_t = _retTree;
-// // 			kvalRef=ref_parameter(_t);
-// // 			_t = _retTree;
-// // 			// pass reference
-// // 			delete kval;
-// // 			actEnv->SetKeyword( knameE->getText(), kvalRef); 
-			
-// // 			_t = __t161;
-// // 			_t = _t->getNextSibling();
-// // 			break;
-// // 		}
-// // 		case KEYDEF:
-// // 		{
-// // 			ProgNodeP __t162 = _t;
-
-// // // 			match(antlr::RefAST(_t),KEYDEF);
-// // 			_t = _t->getFirstChild();
-// // 			kname = _t;
-// // // 			match(antlr::RefAST(_t),IDENTIFIER);
-// // 			_t = _t->getNextSibling();
-// // 			kval=expr(_t);
-// // 			_t = _retTree;
-// // 			// pass value
-// // 			actEnv->SetKeyword( kname->getText(), kval);
-			
-// // 			_t = __t162;
-// // 			_t = _t->getNextSibling();
-// // 			break;
-// // 		}
-// // 		case REF:
-// // 		{
-// // 			ProgNodeP __t163 = _t;
-
-// // // 			match(antlr::RefAST(_t),REF);
-// // 			_t = _t->getFirstChild();
-// // 			pvalRef=ref_parameter(_t);
-// // 			_t = _retTree;
-// // 			// pass reference
-// // 			actEnv->SetNextPar(pvalRef); 
-			
-// // 			_t = __t163;
-// // 			_t = _t->getNextSibling();
-// // 			break;
-// // 		}
-// // 		case REF_EXPR:
-// // 		{
-// // 			ProgNodeP __t164 = _t;
-
-// // // 			match(antlr::RefAST(_t),REF_EXPR);
-// // 			_t = _t->getFirstChild();
-// // 			pval=expr(_t);
-// // 			_t = _retTree;
-// // 			pvalRef=ref_parameter(_t);
-// // 			_t = _retTree;
-// // 			// pass reference
-// // 			delete pval;
-// // 			actEnv->SetNextPar(pvalRef); 
-			
-// // 			_t = __t164;
-// // 			_t = _t->getNextSibling();
-// // 			break;
-// // 		}
-// //  		case KEYDEF_REF_CHECK:
-// // 		{
-// // 			ProgNodeP __t165 = _t;
-
-// // // 			match(antlr::RefAST(_t),KEYDEF_REF_CHECK);
-// // 			_t = _t->getFirstChild();
-// // 			knameCk = _t;
-// // // 			match(antlr::RefAST(_t),IDENTIFIER);
-// // 			_t = _t->getNextSibling();
-// // 			kval=check_expr(_t);
-// // 			_t = _retTree;
-			
-// // 			kvalRef = callStack.back()->GetPtrTo( kval);
-// // 			if( kvalRef != NULL)
-// // 			{   // pass reference
-// // 			actEnv->SetKeyword(knameCk->getText(), kvalRef); 
-// // 			}
-// // 			else 
-// // 			{   // pass value
-// // 			actEnv->SetKeyword(knameCk->getText(), kval); 
-// // 			}
-			
-// // 			_t = __t165;
-// // 			_t = _t->getNextSibling();
-// // 			break;
-// // 		}
-// // 		case REF_CHECK:
-// // 		{
-// // 			ProgNodeP __t166 = _t;
-
-// // // 			match(antlr::RefAST(_t),REF_CHECK);
-// // 			_t = _t->getFirstChild();
-// // 			pval=check_expr(_t);
-// // 			_t = _retTree;
-			
-// // 			pvalRef = callStack.back()->GetPtrTo( pval);
-// // 			if( pvalRef != NULL)
-// // 			{   // pass reference
-// // 			actEnv->SetNextPar( pvalRef); 
-// // 			}
-// // 			else 
-// // 			{   // pass value
-// // 			actEnv->SetNextPar( pval); 
-// // 			}
-			
-// // 			_t = __t166;
-// // 			_t = _t->getNextSibling();
-// // 			break;
-// // 		}
-// // 		default:
-// // 		{
-// // 			pval=expr(_t);
-// //  			_t = _retTree;
-			
-// // 			// pass value
-// // 			actEnv->SetNextPar(pval); 
-			
-// // 			break;
-// // 		}
-
-// // 		} // switch
-// //     } // while
-
-	
-// // 	actEnv->Extra(); // expand _EXTRA
-// // 	guard.release();
-	
-// // 	_retTree = _t;
-
-// //     return;
 }
     : (  #(KEYDEF_REF IDENTIFIER //ref_parameter
-//                 {   // pass reference
-//                     actEnv->SetKeyword( knameR->getText(), kvalRef); 
-//                 }
             )
-//         | #(KEYDEF_REF_EXPR IDENTIFIER 
-//                 // execute ++ and assignment
-//                 //expr 
-//                 //ref_parameter
-// //                 {   // pass reference
-// //                     delete kval;
-// //                     actEnv->SetKeyword( knameE->getText(), kvalRef); 
-// //                 }
-//             )
-//         | #(KEYDEF IDENTIFIER //expr
-// //                 {   // pass value
-// //                     actEnv->SetKeyword( kname->getText(), kval);
-// //                 }
-//             )
-//         | #(REF ref_parameter
-// //                 {   // pass reference
-// //                     actEnv->SetNextPar(pvalRef); 
-// //                 }   
-//             )
-//         | #(REF_EXPR 
-//                 // execute ++ and assignment
-//                 //expr 
-//                 //ref_parameter
-// //                 {   // pass reference
-// //                     delete pval;
-// //                     actEnv->SetNextPar(pvalRef); 
-// //                 }   
-//             )
-//         | //expr
-// //             {  
-// //                 // pass value
-// //                 actEnv->SetNextPar(pval); 
-// //             }
-//         | #(KEYDEF_REF_CHECK IDENTIFIER 
-//                 //check_expr
-// //                 {
-// //                     kvalRef = callStack.back()->GetPtrTo( kval);
-// //                     if( kvalRef != NULL)
-// //                     {   // pass reference
-// //                         actEnv->SetKeyword(knameCk->getText(), kvalRef); 
-// //                     }
-// //                     else 
-// //                     {   // pass value
-// //                         actEnv->SetKeyword(knameCk->getText(), kval); 
-// //                     }
-// //                 }
-//             )   
-//         | #(REF_CHECK
-//                 //check_expr
-// //                 {
-// //                     pvalRef = callStack.back()->GetPtrTo( pval);
-// //                     if( pvalRef != NULL)
-// //                     {   // pass reference
-// //                         actEnv->SetNextPar( pvalRef); 
-// //                     }
-// //                     else 
-// //                     {   // pass value
-// //                         actEnv->SetNextPar( pval); 
-// //                     }
-// //                 }       
-//             )
-        )*             
-//         {
-//             actEnv->Extra(); // expand _EXTRA
-//             guard.release();
-//         }
+        )
 	;
 
 arrayindex_list returns [ArrayIndexListT* aL]
@@ -3929,13 +4680,13 @@
 			case VARPTR:
 			{
 				s=indexable_expr(_t);
-				_t = _retTree;
+//				_t = _retTree;
 				break;
 			}
 			case FCALL_LIB:
 			{
-				s=check_expr(_t);
-				_t = _retTree;
+				s=lib_function_call(_t);
+//				_t = _retTree;
 				
 				if( !callStack.back()->Contains( s)) 
 				exprList.push_back( s);
@@ -3945,7 +4696,7 @@
 			default:
 			{
 				s=indexable_tmp_expr(_t);
-				_t = _retTree;
+//				_t = _retTree;
 				exprList.push_back( s);
 				break;
 			}
@@ -3955,6 +4706,8 @@
 			ixExprList.push_back( s);
 			if( ixExprList.size() == nExpr)
                 break; // allows some manual tuning
+
+            _t = _t->getNextSibling();
 	}
 
 	aL->Init( ixExprList);
@@ -3983,7 +4736,7 @@
 //             }
             (
                 ( s=indexable_expr
-                | s=check_expr
+                | s=lib_function_call
                     {
                         if( !callStack.back()->Contains( s)) 
                         exprList.push_back( s);
@@ -4004,241 +4757,3 @@
 //         }
     ;
 
-// // and array_def is a primary expression
-// array_def returns [BaseGDL* res]
-// {
-//     DType  cType=UNDEF; // conversion type
-//     SizeT maxRank=0;
-//     BaseGDL* e;
-//     ExprListT          exprList;
-//     BaseGDL*           cTypeData;
-// }
-//     : #(a:ARRAYDEF 
-//             (e=expr
-//                 {
-//                     // add first (this way it will get cleaned up anyway)
-//                     exprList.push_back(e);
-                    
-//                     DType ty=e->Type();
-//                     if( ty == UNDEF)
-//                     {
-//                         throw GDLException( _t, "Variable is undefined: "+
-//                             Name(e));
-//                     }
-//                     if( cType == UNDEF) 
-//                     {
-//                         cType=ty;
-//                         cTypeData=e;
-//                     }
-//                     else 
-//                     { 
-//                         if( cType != ty) 
-//                         {
-//                             if( DTypeOrder[ty] > 100 || DTypeOrder[cType] > 100) // struct, ptr, object
-//                             {
-//                                 throw 
-//                                 GDLException( _t, e->TypeStr()+
-//                                     " is not allowed in this context.");
-//                             }
-                            
-//                             // update order if larger type (or types are equal)
-//                             if( DTypeOrder[ty] >= DTypeOrder[cType]) 
-//                             {
-//                                 cType=ty;
-//                                 cTypeData=e;
-//                             }
-//                         }
-//                         if( ty == STRUCT)
-//                         {
-//                             // check for struct compatibility
-//                             DStructDesc* newS=
-//                             static_cast<DStructGDL*>(e)->Desc();
-//                             DStructDesc* oldS=
-//                             static_cast<DStructGDL*>(cTypeData)->Desc();
-
-//                             // *** here (*newS) != (*oldS) must be set when
-//                             // unnamed structs not in struct list anymore
-//                             // WRONG! This speeds up things for named structs
-//                             // unnamed structs all have their own desc
-//                             // and thus the next is always true for them
-//                             if( newS != oldS)
-//                             {
-// //                                 if( (*newS) == (*oldS))
-// //                                 {
-// // Not needed, CatArray puts the right descriptor
-// //                                     // different structs with same layout
-// //                                     // replace desc with first one
-// //                                     if( oldS->IsUnnamed())
-// //                                         oldS = new DStructDesc( oldS);
-
-// //                                     static_cast<DStructGDL*>(e)->SetDesc( oldS);
-// //                                 }
-// //                                 else
-
-//                                 if( (*newS) != (*oldS))
-//                                     throw GDLException( _t, 
-//                                         "Conflicting data structures: "+
-//                                         Name(cTypeData)+", "+Name(e));
-//                             }
-//                         }
-//                     }
-
-//                     // memorize maximum Rank
-//                     SizeT rank=e->Rank();
-//                     if( rank > maxRank) maxRank=rank;
-//                 }
-//             )+
-//         )
-//         {  
-//             res=cTypeData->CatArray(exprList,a->arrayDepth,maxRank);
-//         }
-//   ;
-
-
-// named_struct_def returns[ BaseGDL* res]
-// {
-//     DStructDesc*          nStructDesc;
-//     auto_ptr<DStructDesc> nStructDescGuard;
-//     BaseGDL* e;
-//     BaseGDL* ee;
-// }
-// 	: #(n:NSTRUC id:IDENTIFIER 
-//             {
-//                 // definedStruct: no tags present
-//                 if( n->definedStruct == 1) GetStruct( id->getText(), _t);
-
-//                 // find struct 'id' (for compatibility check)
-//                 DStructDesc* oStructDesc=
-//                 FindInStructList( structList, id->getText());
-                
-//                 if( oStructDesc == NULL || oStructDesc->NTags() > 0)
-//                 {
-//                     // not defined at all yet (-> define now)
-//                     // or completely defined  (-> define now and check equality)
-//                     nStructDesc= new DStructDesc( id->getText());
-                    
-//                     // guard it
-//                     nStructDescGuard.reset( nStructDesc); 
-//                 } 
-//                 else
-//                 {   // NTags() == 0
-//                     // not completely defined (only name in list)
-//                     nStructDesc= oStructDesc;
-//                 }
-                
-//                 // the instance variable
-// //                 DStructGDL* instance= new DStructGDL( nStructDesc,
-// //                                                       dimension(1)); 
-//                 DStructGDL* instance= new DStructGDL( nStructDesc);
-
-//                 auto_ptr<DStructGDL> instance_guard(instance);
-//             }
-
-//             // PROBLEM: both the descriptor AND the instance must be defined
-//             ( ee=expr
-//                 {
-//                     // also adds to descriptor, grabs
-//                     instance->NewTag( 
-//                         oStructDesc->TagName( nStructDesc->NTags()),
-//                         ee);
-//                 }
-//             | i:IDENTIFIER e=expr // e is a new BaseGDL*
-//                 {
-//                     // also adds to descriptor, grabs
-//                     instance->NewTag( i->getText(), e); 
-//                 }
-//             | INHERITS ii:IDENTIFIER
-//             // INHERITS triggers read/compile/interpret of 
-//             // IDENTIFIER__define.pro
-//             // if the struct named IDENTIFIER is not already known
-//                 {
-//                     DStructDesc* inherit=GetStruct( ii->getText(), _t);
-
-//                     //   nStructDesc->AddParent( inherit);
-//                     instance->AddParent( inherit);
-//                 }
-                
-//             )+
-       
-//             {
-//                 // inherit refers to nStructDesc, in case of error both have to
-//                 // be freed here
-//                 if( oStructDesc != NULL)
-//                 {
-//                     if( oStructDesc != nStructDesc)
-//                     {
-//                         oStructDesc->AssureIdentical(nStructDesc);
-//                         instance->DStructGDL::SetDesc(oStructDesc);
-//                         //delete nStructDesc; // auto_ptr
-//                     }
-//                 }
-//                 else
-//                 {
-//                     // release from guard (if not NULL)
-//                     nStructDescGuard.release();
-
-//                     // insert into struct list 
-//                     structList.push_back(nStructDesc);
-//                 }
-                
-//                 instance_guard.release();
-//                 res=instance;
-//             }
-//         )
-//     ;
-
-// unnamed_struct_def returns[ BaseGDL* res]
-// {
-//     // don't forget the struct in extrat.cpp if you change something here
-//     // "$" as first char in the name is necessary 
-//     // as it defines unnnamed structs (see dstructdesc.hpp)
-//     DStructDesc*   nStructDesc = new DStructDesc( "$truct");
-
-//     // instance takes care of nStructDesc since it is unnamed
-// //     DStructGDL* instance = new DStructGDL( nStructDesc, dimension(1));
-//     DStructGDL* instance = new DStructGDL( nStructDesc);
-//     auto_ptr<DStructGDL> instance_guard(instance);
-
-//     BaseGDL* e;
-// }
-// 	: #(STRUC 
-//             ( si:IDENTIFIER e=expr
-//                 {
-//                     // also adds to descriptor, grabs
-//                     instance->NewTag( si->getText(), e); 
-//                 }
-//             )+
-            
-//             {
-// //                 DStructDesc* oStructDesc=nStructDesc->FindEqual( structList);
-// //                 if( oStructDesc != NULL)
-// //                 {
-// //                     instance->SetDesc(oStructDesc);
-// //                     //delete nStructDesc; // auto_ptr
-// //                 }
-// //                 else
-// //                 {
-// //                     // insert into struct list
-// //                     structList.push_back( nStructDesc.release());
-// //                 }
-                
-//                 instance_guard.release();
-//                 res=instance;
-//             }
-//         )
-//     ;
-
-// // only from named structs
-// struct_def returns[ BaseGDL* res]
-//     : res=named_struct_def
-//     | res=unnamed_struct_def
-// 	| #(NSTRUC_REF idRef:IDENTIFIER 
-//             {
-//                 // find struct 'id'
-//                 // returns it or throws an exception
-//                 DStructDesc* dStruct=GetStruct( idRef->getText(), _t);
-                
-//                 res=new DStructGDL( dStruct, dimension(1));
-//             }
-//         )
-// 	;
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdl.cpp cvs/gdl/src/gdl.cpp
--- gdl-0.9rc4/src/gdl.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdl.cpp	2010-04-16 11:22:53.000000000 -0600
@@ -191,7 +191,7 @@
       }
     }
 
-  if (statement.length() > 0 && batch_files.size() > 0) 
+  if (0&&statement.length() > 0 && batch_files.size() > 0) 
   {
     cerr << argv[0] << ": " << "-e option cannot be specified with batch files" << endl;
     return 0;
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdlc.tree.g cvs/gdl/src/gdlc.tree.g
--- gdl-0.9rc4/src/gdlc.tree.g	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdlc.tree.g	2010-04-22 09:50:41.000000000 -0600
@@ -120,21 +120,29 @@
     {
         if( LoopVar( lN))
             {
-                Warning( "Warning: Assignment to FOR loop variable detected.");
+                Warning( "Warning: Assignment to loop variable detected.");
             }
         int lT = lN->getType();
         if( lT == FCALL || lT == MFCALL || lT == MFCALL_PARENT ||
-            lT == FCALL_LIB || 
+            lT == FCALL_LIB ||
+//            lT == FCALL_LIB_N_ELEMENTS ||
             lT == FCALL_LIB_RETNEW || 
             lT == MFCALL_LIB || 
             lT == MFCALL_LIB_RETNEW || 
             lT == MFCALL_PARENT_LIB ||
             lT == MFCALL_PARENT_LIB_RETNEW ||
-            lT == DEREF || lT == VAR || lT == VARPTR)
+            lT == DEREF || lT == VAR || lT == VARPTR 
+            )
         {
             aN->setType( ASSIGN_REPLACE);
             aN->setText( "r=");
         }
+        if( lT == ARRAYEXPR_MFCALL) // is MFCALL or DOT 
+        {
+            aN->setType( ASSIGN_ARRAYEXPR_MFCALL);
+            aN->setText( "?=");
+        }
+
     }
     
     bool SelfAssignment( RefDNode& lN, RefDNode& rN)
@@ -379,7 +387,7 @@
 
 
 caseswitch_body 
-	: #(BLOCK expr //labeled_expr 
+	: #(b:BLOCK { #b->setType(CSBLOCK);#b->setText("csblock");} expr //labeled_expr 
             (statement_list)? 
         )
 	| #(ELSEBLK 
@@ -408,13 +416,27 @@
 	;
 
 block
-	: #(BLOCK (statement_list)?)
+{
+//    int labelStart = comp.NDefLabel();
+}
+	: #(b:BLOCK (statement_list)?)
+        {
+//            #b->SetLabelRange( labelStart, comp.NDefLabel());
+        }
 	;
 
 unblock!
-	: #(BLOCK 
+	: #(b:BLOCK 
             ( s:statement_list { #unblock = #s;}
-            |
+            | { #unblock = #b;}
+            )
+        )
+	;
+
+unblock_empty!
+	: #(b:BLOCK 
+            ( s:statement_list { #unblock_empty = #s;}
+            | 
             )
         )
 	;
@@ -428,7 +450,8 @@
 //    | assign_expr
     | comp_assign_expr   
 	| procedure_call
-	| for_statement 
+	| for_statement
+	| foreach_statement  
 	| repeat_statement
 	| while_statement
 	| jump_statement
@@ -440,7 +463,7 @@
 	| block
     | #(DEC expr) //unbrace_expr)
     | #(INC expr) //unbrace_expr)
-	| BREAK    // only in loops or switch_statement
+	| BREAK    // only in loops or case/switch_statement
 	| CONTINUE // only in loops
 	;
 
@@ -448,7 +471,7 @@
 {
     int labelStart = comp.NDefLabel();
 }
-	: #(r:REPEAT b:unblock e:expr)
+	: #(r:REPEAT b:unblock_empty e:expr)
         {
             #r->SetLabelRange( labelStart, comp.NDefLabel());
             #repeat_statement=#( r, e, b);
@@ -498,7 +521,29 @@
                 }
             )? 
 //           for_block
-           unblock
+           unblock_empty
+        )
+        {
+        #f->SetLabelRange( labelStart, comp.NDefLabel());
+        }
+	;
+
+foreach_statement //!
+{
+    StackSizeGuard<IDList> guard( loopVarStack);
+    int labelStart = comp.NDefLabel();
+}
+	: #(f:FOREACH i:IDENTIFIER 
+        	{ 
+                #i->setType(VAR);
+                comp.Var(#i);	
+
+                loopVarStack.push_back(#i->getText());
+            }
+            expr
+//           for_block
+           unblock_empty
+//           unblock
         )
         {
         #f->SetLabelRange( labelStart, comp.NDefLabel());
@@ -526,11 +571,24 @@
 	{
 	  if( comp.IsFun())
 	  	{
-		if( !exprThere)	throw GDLException(	_t, 
+		if( !exprThere)	throw GDLException(	r, 
                     "Return statement in functions "
                     "must have 1 value.");
+
+//         // wrong: this is only true for l_function as return value
+//         // a ARRAYEXPR_MFCALL can only be a MFCALL here -> change tree
+//         if( #e->getType() == ARRAYEXPR_MFCALL)
+//             {
+//                 #e->setType( MFCALL);
+//                 #e->setText( "mfcall");
+//                 RefDNode mfc;
+//                 mfc = #e->getFirstChild();
+//                 mfc = mfc->getNextSibling();
+//                 #e->setFirstChild( antlr::RefAST(mfc));             
+//             }
+
 		#jump_statement=#([RETF,"retf"],e);
-      #jump_statement->SetLine(r->getLine()); 
+        #jump_statement->SetLine(r->getLine()); 
 		}
 	  else
 	  	{
@@ -561,20 +619,28 @@
 
 if_statement!//
 {
-    int labelStart = comp.NDefLabel();
+//     int labelStart = comp.NDefLabel();
+    RefDNode block;
 }
 	: #(i:IF e:expr s1:statement 
             (
                 {
-        #i->SetLabelRange( labelStart, comp.NDefLabel());
+//         #i->SetLabelRange( labelStart, comp.NDefLabel());
                 #if_statement=#(i,e,s1);
                 }
             | s2:statement
                 {
                 #i->setText( "if_else");
                 #i->setType( IF_ELSE);
-        #i->SetLabelRange( labelStart, comp.NDefLabel());
-                #if_statement=#(i,e,s1,s2);
+//         #i->SetLabelRange( labelStart, comp.NDefLabel());
+                if( #s1->getType() != BLOCK)
+                    {
+                        #block = astFactory->create(BLOCK,"block");
+                        #block->SetLine( #s1->getLine());
+                        #if_statement=#(i,e, #(block, s1), s2);
+                    }
+                else
+                    #if_statement=#(i,e,s1,s2);
                 }
             )
         )
@@ -637,10 +703,13 @@
                 else 
                 {
                     int t = #k->getType();
-                    if( t == FCALL_LIB || t == MFCALL_LIB || 
-                        t == MFCALL_PARENT_LIB ||
-                         t == FCALL_LIB_RETNEW || t == MFCALL_LIB_RETNEW || 
-                         t == MFCALL_PARENT_LIB_RETNEW) 
+                    if( t == FCALL_LIB || t == MFCALL_LIB || //t == FCALL_LIB_N_ELEMENTS ||
+
+                        t == MFCALL_PARENT_LIB //||
+//                          t == FCALL_LIB_RETNEW || t == MFCALL_LIB_RETNEW || 
+//                          t == MFCALL_PARENT_LIB_RETNEW //||
+//                          t == ARRARYEXPR_MFCALL_LIB // MFCALL_LIB or VAR or DEREF 
+                      )
                     {
                         #d=#[KEYDEF_REF_CHECK,"keydef_ref_check"];
                         #key_parameter=#(d,i,k);
@@ -680,10 +749,12 @@
             else 
             {
                 int t = #e->getType();
-                if( t == FCALL_LIB || t == MFCALL_LIB || 
-                    t == MFCALL_PARENT_LIB ||
-                     t == FCALL_LIB_RETNEW || t == MFCALL_LIB_RETNEW || 
-                     t == MFCALL_PARENT_LIB_RETNEW) 
+                if( t == FCALL_LIB || t == MFCALL_LIB || //t == FCALL_LIB_N_ELEMENTS ||
+                    t == MFCALL_PARENT_LIB //||
+//                      t == FCALL_LIB_RETNEW || t == MFCALL_LIB_RETNEW || 
+//                      t == MFCALL_PARENT_LIB_RETNEW
+//                      t == ARRARYEXPR_MFCALL_LIB // MFCALL_LIB or VAR or DEREF 
+                    ) 
                 {
                     // something like: CALLAPRO,reform(a,/OVERWRITE)
                     #pos_parameter=#([REF_CHECK,"ref_check"],e);
@@ -1140,11 +1211,12 @@
 
 // system variables have as variable ptr NULL initially
 sysvar!//
-  : #(SYSVAR i:SYSVARNAME)
+  : #(s:SYSVAR i:SYSVARNAME)
 	{ 
       std::string sysVarName = i->getText();
       // here we create the real sysvar node      
 	  #sysvar=astFactory->create(SYSVAR, sysVarName.substr(1));
+      #sysvar->SetLine(s->getLine());
 //	  #sysvar=#[SYSVAR,i->getText()];
 	  comp.SysVar(#sysvar); // sets var to NULL
 	}	
@@ -1155,23 +1227,23 @@
 // VARPTR for common block variables with a ptr to the
 //        variable in the common block
 var!//
-  : #(VAR i:IDENTIFIER)
+  : #(v:VAR i:IDENTIFIER)
 	{ 
 	  #var=astFactory->create(VAR,i->getText());
+      #var->SetLine(v->getLine());
 //	  #var=#[VAR,i->getText()];
 	  comp.Var(#var);	
 	}
   ;
 
-// out parameter_def_list is an expression list here
-arrayindex_list_to_expression_list! // ???
+arrayindex_list_to_parameter_list! // ???
 //{
 //    RefDNode variable;
 //}
-    : (#(ARRAYIX e:pos_parameter)
+    : (options {greedy=true;}: #(ARRAYIX e:pos_parameter)
             {
-                #arrayindex_list_to_expression_list=
-                    #(NULL, arrayindex_list_to_expression_list, e);
+                #arrayindex_list_to_parameter_list=
+                    #(NULL, arrayindex_list_to_parameter_list, e);
             }
         )+
   ;
@@ -1193,7 +1265,7 @@
             }
 
             (   { isVar}? al:arrayindex_list
-            |   el:arrayindex_list_to_expression_list
+            |   el:arrayindex_list_to_parameter_list
             )
             { 
                 if( !isVar)
@@ -1206,17 +1278,17 @@
                         #id->SetLibFun( libFunList[i]);
                         if( libFunList[ i]->RetNew())
                             {
-                        #id->setType( FCALL_LIB_RETNEW);
-                        #arrayexpr_fn=
-                        #( id, el);
-//                        #([/*FCALL_LIB_RETNEW,"fcall_lib_retnew"],*/ id, el);
+                                #id->setType( FCALL_LIB_RETNEW);
+                                #arrayexpr_fn =
+                                #( id, el);
+//                              #([/*FCALL_LIB_RETNEW,"fcall_lib_retnew"],*/ id, el);
                             }
                         else
                             {
-                        #id->setType( FCALL_LIB);
-                        #arrayexpr_fn=
-                        #( id, el);
-//                        #(/*[FCALL_LIB,"fcall_lib"],*/ id, el);
+                                #id->setType( FCALL_LIB);
+                                #arrayexpr_fn =
+                                #( id, el);
+//                              #(/*[FCALL_LIB,"fcall_lib"],*/ id, el);
                             }
                     }
                     else
@@ -1246,38 +1318,111 @@
         )  
     ;
 
+
+
+arrayexpr_mfcall!//
+    : #(a:ARRAYEXPR_MFCALL
+            {
+                RefDNode mark = _t; // mark
+            }
+            e:expr i:IDENTIFIER //al:arrayindex_list
+            { 
+                bool success = true;
+                RefDNode #first;
+	            try {
+                    arrayindex_list(_t);
+
+                    RefDNode al = returnAST;
+                    RefDNode #ae = #([ARRAYEXPR,"arrayexpr"], #i, al);
+
+                    if( e->getType() == DOT)
+                    {
+                        int nDot = #e->GetNDot();
+                        #e->SetNDot( ++nDot);
+
+                        #e->addChild( #ae);
+
+                        #first = #e;
+                    }
+                    else
+                    {
+                        RefDNode #dot = #([DOT,"."], e, ae);
+                        #dot->SetNDot( 1);
+
+                        #first = #dot;
+                    }
+                }
+                catch( GDLException& ex)
+                {
+                    Message( "Ambiguity resolved: member function call "
+                             "due to invalid array index.");
+
+                    success = false;
+
+                    #a->setType( MFCALL);
+                    #a->setText( "mfcall");
+                }
+
+                _t = mark; // rewind to parse again 
+            }
+            e2:expr i2:IDENTIFIER a2:arrayindex_list_to_parameter_list
+            {
+                if( success)
+                    #arrayexpr_mfcall = #(a, first, e2, i2, a2);
+                else
+                    #arrayexpr_mfcall = #(a, e2, i2, a2);
+            } 
+            
+        )
+    ;
+
 // only here a function call is ok also
 primary_expr
 {
 int dummy;
+RefDNode mark;
 }
     : assign_expr
-    | comp_assign_expr   
+    | comp_assign_expr
+    | arrayexpr_mfcall 
 	| #(MFCALL expr IDENTIFIER parameter_def
         )
 	| #(MFCALL_PARENT expr IDENTIFIER
             IDENTIFIER parameter_def
         )
+//     | #(nEl:FCALL_LIB_N_ELEMENTS id2:IDENTIFIER! parameter_def
+//         )
 	| #(f:FCALL id:IDENTIFIER! parameter_def
             {
                 // first search library functions
                 int i=LibFunIx(id->getText());
                 if( i != -1)
                 {
+                    // N_ELEMENTS must handle exceptions during parameter evaluation
+//                     if( StrUpCase( #id->getText()) == "N_ELEMENTS")
+//                     {
+//                     #f->setType(FCALL_LIB_N_ELEMENTS);
+//                     #f->setText(#id->getText());
+//                     #f->SetLibFun( libFunList[i]);
+//                         //                    #id->SetFunIx(i);
+//                     }
+//                     else
+                    {
                     if( libFunList[ i]->RetNew())
                     {
-                    #f->setType(FCALL_LIB_RETNEW);
-                    #f->setText(#id->getText());
-                    #f->SetLibFun( libFunList[i]);
+                        #f->setType(FCALL_LIB_RETNEW);
+                        #f->setText(#id->getText());
+                        #f->SetLibFun( libFunList[i]);
                         //                    #id->SetFunIx(i);
                     }
                     else
                     {
-                    #f->setType(FCALL_LIB);
-                    #f->setText(#id->getText());
-                    #f->SetLibFun( libFunList[i]);
+                        #f->setType(FCALL_LIB);
+                        #f->setText(#id->getText());
+                        #f->SetLibFun( libFunList[i]);
                         //                    #id->SetFunIx(i);
                     }
+                    }
                 }
                 else
                 {
@@ -1404,4 +1549,3 @@
 	| #(DEREF expr)    // deref
 	| op_expr
 	;
-
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdlgstream.cpp cvs/gdl/src/gdlgstream.cpp
--- gdl-0.9rc4/src/gdlgstream.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdlgstream.cpp	2010-07-07 14:41:01.858003785 -0600
@@ -15,6 +15,9 @@
  *                                                                         *
  ***************************************************************************/
 
+// try because of segfault in magick
+// #include "gdlgstream.hpp"
+
 #include "includefirst.hpp"
 
 #include <iostream>
@@ -25,6 +28,8 @@
 
 using namespace std;
 
+// bool GDLGStream::plstreamInitCalled = false;
+
 // void PLPlotAbortHandler(const char *c)
 // {
 //   cout << "PLPlot abort handler: " << c << endl;
@@ -135,7 +140,9 @@
     {
       DLong pMod = (*pMulti)[ 0] % (nx*ny);
       if( dir == 0)
+      {
 	plstream::adv(nx*ny - pMod + 1);
+      }
       else
 	{
 	  int p = nx*ny - pMod;
@@ -143,7 +150,10 @@
 	  plstream::adv(pp);
 	}
 
-      if( erase) --(*pMulti)[ 0];
+      if( erase) 
+      {
+        --(*pMulti)[ 0];
+      }
     }
 
   // restore charsize
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdlgstream.hpp cvs/gdl/src/gdlgstream.hpp
--- gdl-0.9rc4/src/gdlgstream.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdlgstream.hpp	2010-07-07 14:41:01.889004632 -0600
@@ -19,7 +19,11 @@
 #define GDLGSTREAM_HPP_
 
 #include <plplot/plstream.h>
-#include <plplot/plxwd.h>
+#include <plplot/plstrm.h>
+#ifndef HAVE_X
+#else
+#  include <plplot/plxwd.h>
+#endif
 #include <plplot/plplot.h>
 #include <string>
 #include <iostream>
@@ -31,6 +35,8 @@
 class GDLGStream: public plstream
 {
   void init(); // prevent plstream::init from being called directly
+	
+// 	static bool plstreamInitCalled;
 
 protected:
   bool valid;
@@ -38,28 +44,48 @@
 public:
     GDLGStream( int nx, int ny, 
 		const char *driver, 
-		const char *file=NULL):
-      plstream( nx, ny, driver, file), valid( true)
+		const char *file=NULL)
+	: plstream( nx, ny, driver, file)
+    , valid( true)
   {
+//   std::cerr << "GDLGStream()" << std::endl;
     if (!checkPlplotDriver(driver))
       ThrowGDLException(string("PLplot installation lacks the requested driver: ") + driver);
   }
 
   virtual ~GDLGStream()
   {
+//   std::cerr << "~GDLGStream()" << std::endl;
+// 	plend();
   }
 
+// 	void PlstreamInit()
+// 	{
+// 	    if( !plstreamInitCalled)
+// 		{
+// 			this->plstream::init();
+// 			plstreamInitCalled = true;
+// 		}
+// 	}
+
   static bool checkPlplotDriver(const char *driver)
   {
-    int numdevs_plus_one = 50;
+    int numdevs_plus_one = 64;
 #ifdef HAVE_OLDPLPLOT
-    char **devlongnames = NULL, **devnames = NULL;
+    char **devlongnames = NULL;
+    char **devnames = NULL;
 #else
-    const char **devlongnames = NULL, **devnames = NULL;
+    const char **devlongnames = NULL;
+    const char **devnames = NULL;
 #endif
 
+	static vector<std::string> devNames;// = NULL;
+
+// do only once
+if( devNames.empty())// == NULL)
+{
     // acquireing a list of drivers from plPlot
-    for (int maxnumdevs = numdevs_plus_one;; numdevs_plus_one = maxnumdevs += 5)
+    for (int maxnumdevs = numdevs_plus_one;; numdevs_plus_one = maxnumdevs += 16)
     {
 #ifdef HAVE_OLDPLPLOT
       devlongnames = static_cast<char**>(realloc(devlongnames, maxnumdevs * sizeof(char*)));
@@ -75,17 +101,31 @@
     } 
     free(devlongnames); // we do not need this information
 
-    // checking if a given driver is in the list
-    bool supported = false;
-    for (int i = numdevs_plus_one - 1; i--;) 
-    {
-      if (strcmp(driver, devnames[i]) == 0) 
-      {
-        supported = true;
-      }
-    }
+//     devNames = new std::vector<std::string>( numdevs_plus_one - 1);
+    for( int i = 0; i < numdevs_plus_one - 1; ++i)
+		devNames.push_back(string(devnames[ i]));
+    
     free(devnames);
-    return supported;
+}
+
+// for debug
+std::vector<std::string> devnamesDbg = devNames;
+
+return std::find( devNames.begin(), devNames.end(), string( driver)) != devNames.end();
+
+//     checking if a given driver is in the list
+//     bool supported = false;
+//     for (int i = numdevs_plus_one - 1; i--;) 
+//     {
+// 		
+//       if (strcmp(driver, devnames[i]) == 0) 
+//       {
+//         supported = true;
+//         break;
+//       }
+//     }
+//    free(devnames);
+//     return supported;
   }
 
   static void SetErrorHandlers();
@@ -96,9 +136,9 @@
 
   virtual void eop()          { plstream::eop();}
 
-  virtual void Raise()          {}
-  virtual void Lower()          {}
-  virtual void Clear()          {}
+  virtual void Raise()         {}
+  virtual void Lower()        {}
+  virtual void Clear()         {}
   virtual void Clear( DLong bColor)          {}
 
   bool Valid() { return valid;}
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/GDLInterpreter.cpp cvs/gdl/src/GDLInterpreter.cpp
--- gdl-0.9rc4/src/GDLInterpreter.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/GDLInterpreter.cpp	2010-05-21 10:23:54.409906082 -0600
@@ -23,37 +23,14 @@
 #define RefAST( xxx)     ConvertAST( xxx) /* antlr::RefAST( Ref type)  */
 #define match( a, b)     /* remove from source */
 
-// optimizations
-// #define  constant constantNotOptimized
-// #define  interactive interactiveNotOptimized
-// #define  statement_list statement_listNotOptimized
-// #define  execute executeNotOptimized
-// #define  call_fun call_funNotOptimized
-// #define  call_lfun call_lfunNotOptimized
-// #define  call_pro call_proNotOptimized 
-// #define  block blockNotOptimized
-// #define  expr exprNotOptimized
-// #define  l_simple_var l_simple_varNotOptimized
-// #define  sys_var sys_varNotOptimized
-// #define  sys_var_nocopy sys_var_nocopyNotOptimized
-// #define  dot_expr dot_exprNotOptimized
-// #define  simple_var simple_varNotOptimized
-// #define  ref_parameter ref_parameterNotOptimized
-// #define  unnamed_struct_def unnamed_struct_defNotOptimized
-// #define  lib_function_call_retnew lib_function_call_retnewNotOptimized
-// #define  lib_function_call lib_function_callNotOptimized
-// #define  constant_nocopy constant_nocopyNotOptimized
-// #define  struct_def struct_defNotOptimized
-
-
 using namespace std;
 
 GDLInterpreter::GDLInterpreter()
 	: antlr::TreeParser() {
 }
 
- GDLInterpreter::RetCode  GDLInterpreter::interactive(ProgNodeP _t) {
-	 GDLInterpreter::RetCode retCode;
+ RetCode  GDLInterpreter::interactive(ProgNodeP _t) {
+	 RetCode retCode;
 	ProgNodeP interactive_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	
 		for (; _t != NULL;) {
@@ -92,181 +69,260 @@
 	return retCode;
 }
 
- GDLInterpreter::RetCode  GDLInterpreter::statement(ProgNodeP _t) {
-	 GDLInterpreter::RetCode retCode;
+ RetCode  GDLInterpreter::statement(ProgNodeP _t) {
+	 RetCode retCode;
 	ProgNodeP statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	ProgNodeP a = ProgNodeP(antlr::nullAST);
-	ProgNodeP r = ProgNodeP(antlr::nullAST);
-	ProgNodeP l = ProgNodeP(antlr::nullAST);
-	ProgNodeP m = ProgNodeP(antlr::nullAST);
-	ProgNodeP mp = ProgNodeP(antlr::nullAST);
-	ProgNodeP p = ProgNodeP(antlr::nullAST);
-	ProgNodeP d = ProgNodeP(antlr::nullAST);
-	ProgNodeP i = ProgNodeP(antlr::nullAST);
-	ProgNodeP o = ProgNodeP(antlr::nullAST);
 	
-	retCode = RC_OK;
-	ProgNodeP actPos = _t;
+	//    ProgNodeP& actPos = statement_AST_in;
 	assert( _t != NULL);
-	//     if( callStack.back()->GetLineNumber() == 0) 
-	if( _t->getLine() != 0) 
-	callStack.back()->SetLineNumber( _t->getLine());
+	ProgNodeP last;
+	_retTree = _t;
+	//  if( callStack.back()->GetLineNumber() == 0) 
+	//  if( _t->getLine() != 0) 
+	//      callStack.back()->SetLineNumber( _t->getLine());
 	
 	
 	try {      // for error handling
+		
+		do {
+		//                 if( _t->getLine() != 0) 
+		//                     callStack.back()->SetLineNumber( _t->getLine());
+		
+		last = _retTree;
+		
+		retCode = last->Run(); // Run() sets _retTree
+		
+		}
+		while( 
+		_retTree != NULL && 
+		retCode == RC_OK && 
+		!(sigControlC && interruptEnable) && 
+		(debugMode == DEBUG_CLEAR));
+		
+		if( _retTree != NULL) 
+		last = _retTree;
+		
+		goto afterStatement;
+		
 		{
 		if (_t == ProgNodeP(antlr::nullAST) )
 			_t = ASTNULL;
 		switch ( _t->getType()) {
 		case ASSIGN:
 		{
-			a = _t;
+			ProgNodeP tmp1_AST_in = _t;
 			match(antlr::RefAST(_t),ASSIGN);
 			_t = _t->getNextSibling();
-			a->Run();
+			break;
+		}
+		case ASSIGN_ARRAYEXPR_MFCALL:
+		{
+			ProgNodeP tmp2_AST_in = _t;
+			match(antlr::RefAST(_t),ASSIGN_ARRAYEXPR_MFCALL);
+			_t = _t->getNextSibling();
 			break;
 		}
 		case ASSIGN_REPLACE:
 		{
-			r = _t;
+			ProgNodeP tmp3_AST_in = _t;
 			match(antlr::RefAST(_t),ASSIGN_REPLACE);
 			_t = _t->getNextSibling();
-			r->Run();
 			break;
 		}
 		case PCALL_LIB:
 		{
-			l = _t;
+			ProgNodeP tmp4_AST_in = _t;
 			match(antlr::RefAST(_t),PCALL_LIB);
 			_t = _t->getNextSibling();
-			l->Run();
 			break;
 		}
 		case MPCALL:
 		{
-			m = _t;
+			ProgNodeP tmp5_AST_in = _t;
 			match(antlr::RefAST(_t),MPCALL);
 			_t = _t->getNextSibling();
-			m->Run();
 			break;
 		}
 		case MPCALL_PARENT:
 		{
-			mp = _t;
+			ProgNodeP tmp6_AST_in = _t;
 			match(antlr::RefAST(_t),MPCALL_PARENT);
 			_t = _t->getNextSibling();
-			mp->Run();
 			break;
 		}
 		case PCALL:
 		{
-			p = _t;
+			ProgNodeP tmp7_AST_in = _t;
 			match(antlr::RefAST(_t),PCALL);
 			_t = _t->getNextSibling();
-			p->Run();
 			break;
 		}
 		case DEC:
 		{
-			d = _t;
+			ProgNodeP tmp8_AST_in = _t;
 			match(antlr::RefAST(_t),DEC);
 			_t = _t->getNextSibling();
-			d->Run();
 			break;
 		}
 		case INC:
 		{
-			i = _t;
+			ProgNodeP tmp9_AST_in = _t;
 			match(antlr::RefAST(_t),INC);
 			_t = _t->getNextSibling();
-			i->Run();
 			break;
 		}
-		case FOR_STEP:
 		case FOR:
 		{
-			retCode=for_statement(_t);
-			_t = _retTree;
+			ProgNodeP tmp10_AST_in = _t;
+			match(antlr::RefAST(_t),FOR);
+			_t = _t->getNextSibling();
+			break;
+		}
+		case FOR_LOOP:
+		{
+			ProgNodeP tmp11_AST_in = _t;
+			match(antlr::RefAST(_t),FOR_LOOP);
+			_t = _t->getNextSibling();
+			break;
+		}
+		case FOREACH:
+		{
+			ProgNodeP tmp12_AST_in = _t;
+			match(antlr::RefAST(_t),FOREACH);
+			_t = _t->getNextSibling();
+			break;
+		}
+		case FOREACH_LOOP:
+		{
+			ProgNodeP tmp13_AST_in = _t;
+			match(antlr::RefAST(_t),FOREACH_LOOP);
+			_t = _t->getNextSibling();
+			break;
+		}
+		case FOR_STEP:
+		{
+			ProgNodeP tmp14_AST_in = _t;
+			match(antlr::RefAST(_t),FOR_STEP);
+			_t = _t->getNextSibling();
+			break;
+		}
+		case FOR_STEP_LOOP:
+		{
+			ProgNodeP tmp15_AST_in = _t;
+			match(antlr::RefAST(_t),FOR_STEP_LOOP);
+			_t = _t->getNextSibling();
 			break;
 		}
 		case REPEAT:
 		{
-			retCode=repeat_statement(_t);
-			_t = _retTree;
+			ProgNodeP tmp16_AST_in = _t;
+			match(antlr::RefAST(_t),REPEAT);
+			_t = _t->getNextSibling();
+			break;
+		}
+		case REPEAT_LOOP:
+		{
+			ProgNodeP tmp17_AST_in = _t;
+			match(antlr::RefAST(_t),REPEAT_LOOP);
+			_t = _t->getNextSibling();
 			break;
 		}
 		case WHILE:
 		{
-			retCode=while_statement(_t);
-			_t = _retTree;
+			ProgNodeP tmp18_AST_in = _t;
+			match(antlr::RefAST(_t),WHILE);
+			_t = _t->getNextSibling();
 			break;
 		}
 		case IF:
 		{
-			retCode=if_statement(_t);
-			_t = _retTree;
+			ProgNodeP tmp19_AST_in = _t;
+			match(antlr::RefAST(_t),IF);
+			_t = _t->getNextSibling();
 			break;
 		}
 		case IF_ELSE:
 		{
-			retCode=if_else_statement(_t);
-			_t = _retTree;
+			ProgNodeP tmp20_AST_in = _t;
+			match(antlr::RefAST(_t),IF_ELSE);
+			_t = _t->getNextSibling();
 			break;
 		}
 		case CASE:
 		{
-			retCode=case_statement(_t);
-			_t = _retTree;
+			ProgNodeP tmp21_AST_in = _t;
+			match(antlr::RefAST(_t),CASE);
+			_t = _t->getNextSibling();
 			break;
 		}
 		case SWITCH:
 		{
-			retCode=switch_statement(_t);
-			_t = _retTree;
+			ProgNodeP tmp22_AST_in = _t;
+			match(antlr::RefAST(_t),SWITCH);
+			_t = _t->getNextSibling();
 			break;
 		}
 		case BLOCK:
 		{
-			retCode=block(_t);
-			_t = _retTree;
-			break;
-		}
-		case BREAK:
-		case CONTINUE:
-		case RETF:
-		case RETP:
-		case GOTO:
-		{
-			retCode=jump_statement(_t);
-			_t = _retTree;
+			ProgNodeP tmp23_AST_in = _t;
+			match(antlr::RefAST(_t),BLOCK);
+			_t = _t->getNextSibling();
 			break;
 		}
 		case LABEL:
 		{
-			ProgNodeP tmp1_AST_in = _t;
+			ProgNodeP tmp24_AST_in = _t;
 			match(antlr::RefAST(_t),LABEL);
 			_t = _t->getNextSibling();
 			break;
 		}
 		case ON_IOERROR_NULL:
 		{
-			ProgNodeP tmp2_AST_in = _t;
+			ProgNodeP tmp25_AST_in = _t;
 			match(antlr::RefAST(_t),ON_IOERROR_NULL);
 			_t = _t->getNextSibling();
-			
-			static_cast<EnvUDT*>(callStack.back())->SetIOError( -1);
-			
 			break;
 		}
 		case ON_IOERROR:
 		{
-			o = _t;
+			ProgNodeP tmp26_AST_in = _t;
 			match(antlr::RefAST(_t),ON_IOERROR);
 			_t = _t->getNextSibling();
-			
-			static_cast<EnvUDT*>(callStack.back())->
-			SetIOError( o->targetIx);
-			
+			break;
+		}
+		case BREAK:
+		{
+			ProgNodeP tmp27_AST_in = _t;
+			match(antlr::RefAST(_t),BREAK);
+			_t = _t->getNextSibling();
+			break;
+		}
+		case CONTINUE:
+		{
+			ProgNodeP tmp28_AST_in = _t;
+			match(antlr::RefAST(_t),CONTINUE);
+			_t = _t->getNextSibling();
+			break;
+		}
+		case GOTO:
+		{
+			ProgNodeP tmp29_AST_in = _t;
+			match(antlr::RefAST(_t),GOTO);
+			_t = _t->getNextSibling();
+			break;
+		}
+		case RETF:
+		{
+			ProgNodeP tmp30_AST_in = _t;
+			match(antlr::RefAST(_t),RETF);
+			_t = _t->getNextSibling();
+			break;
+		}
+		case RETP:
+		{
+			ProgNodeP tmp31_AST_in = _t;
+			match(antlr::RefAST(_t),RETP);
+			_t = _t->getNextSibling();
 			break;
 		}
 		default:
@@ -276,20 +332,22 @@
 		}
 		}
 		
+		afterStatement:;
+		
 		// possible optimization: make sigControlC a debugMode 
 		if( interruptEnable && sigControlC)
 		{
-		DebugMsg( actPos, "Interrupted at: "); 
+		DebugMsg( last, "Interrupted at: "); 
 		
 		sigControlC = false;
 		
-		retCode = NewInterpreterInstance(actPos->getLine()-1);
+		retCode = NewInterpreterInstance( last->getLine()-1);
 		}
 		else if( debugMode != DEBUG_CLEAR)
 		{
 		if( debugMode == DEBUG_STOP)
 		{
-		DebugMsg( actPos, "Stop encoutered: ");
+		DebugMsg( last, "Stop encoutered: ");
 		if( !interruptEnable)
 		debugMode = DEBUG_PROCESS_STOP;
 		}
@@ -298,18 +356,19 @@
 		{
 		if( debugMode == DEBUG_PROCESS_STOP)
 		{
-		DebugMsg( actPos, "Stepped to: ");
+		DebugMsg( last, "Stepped to: ");
 		}
 		
 		debugMode = DEBUG_CLEAR;
 		
-		retCode = NewInterpreterInstance(actPos->getLine()-1);
+		retCode = NewInterpreterInstance( last->getLine()-1);
 		}   
 		else
 		{
 		retCode = RC_ABORT;
 		}
 		}
+		return retCode;
 		
 	}
 	catch ( GDLException& e) {
@@ -317,15 +376,14 @@
 		if( dynamic_cast< GDLIOException*>( &e) != NULL)
 		{
 		// set the jump target - also logs the jump
-		ProgNodeP onIOErr = static_cast<EnvUDT*>(callStack.back())->GetIOError();
+		ProgNodeP onIOErr = 
+		static_cast<EnvUDT*>(callStack.back())->GetIOError();
 		if( onIOErr != NULL)
 		{
 		SysVar::SetErr_String( e.getMessage());
-		_t = onIOErr;
-		retCode=RC_OK;		
 		
-		_retTree = _t;
-		return retCode;
+		_retTree = onIOErr;
+		return RC_OK;
 		}
 		}
 		
@@ -355,7 +413,10 @@
 		// 2 -> caller of routine which called ON_ERROR
 		else if( oE == 2)
 		{
-		++i; // set to caller
+		// set to caller, handle nested
+		while( static_cast<EnvUDT*>(*(++i))->GetOnError() == 2 
+		&& i != callStack.rend());
+		
 		if( i == callStack.rend())
 		{
 		EnvUDT* cS_begin = 
@@ -375,19 +436,27 @@
 		targetEnv = iUDT;
 		}
 		
-		// remeber where to stop
-		e.SetTargetEnv( targetEnv);
 		
 		// State where error occured
 		//                     if( e.getLine() == 0 && _t != NULL)
 		//                         e.SetLine( _t->getLine());
 		//                     if( e.getLine() == 0 && _retTree != NULL)
 		//                         e.SetLine( _retTree->getLine());
-		if( e.getLine() == 0 && actPos != NULL)
-		e.SetLine( actPos->getLine());
+		if( e.getLine() == 0 && last != NULL)
+		e.SetLine( last->getLine());
 		
+		if( interruptEnable)
 		ReportError(e, "Error occurred at:");
 		
+		// remeber where to stop
+		e.SetTargetEnv( targetEnv);
+		
+		if( targetEnv->GetLineNumber() != 0)
+		e.SetLine( targetEnv->GetLineNumber());                    
+		
+		//                     ProgNodeP errorNodeP = targetEnv->CallingNode();
+		//                     e.SetErrorNodeP( errorNodeP);
+		
 		// break on first occurence of set oE
 		break;
 		}
@@ -406,8 +475,8 @@
 		//             e.SetLine( _t->getLine());
 		//         if( e.getLine() == 0 && _retTree != NULL)
 		//             e.SetLine( _retTree->getLine());
-		if( e.getLine() == 0 && actPos != NULL)
-		e.SetLine( actPos->getLine());
+		//        if( e.getLine() == 0 && actPos != NULL)
+		//            e.SetLine( actPos->getLine());
 		
 		if( interruptEnable)
 		{
@@ -434,16 +503,18 @@
 		retCode = RC_ABORT;
 		}
 		
+		return retCode;
+		
 	}
 	_retTree = _t;
 	return retCode;
 }
 
- GDLInterpreter::RetCode  GDLInterpreter::execute(ProgNodeP _t) {
-	 GDLInterpreter::RetCode retCode;
+ RetCode  GDLInterpreter::execute(ProgNodeP _t) {
+	 RetCode retCode;
 	ProgNodeP execute_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	
-	//    GDLInterpreter::RetCode retCode;
+	//    RetCode retCode;
 	ValueGuard<bool> guard( interruptEnable);
 	interruptEnable = false;
 	
@@ -456,8 +527,8 @@
 	return retCode;
 }
 
- GDLInterpreter::RetCode  GDLInterpreter::statement_list(ProgNodeP _t) {
-	 GDLInterpreter::RetCode retCode;
+ RetCode  GDLInterpreter::statement_list(ProgNodeP _t) {
+	 RetCode retCode;
 	ProgNodeP statement_list_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	
 		for (; _t != NULL;) {
@@ -502,12 +573,11 @@
 	
 	res = NULL;
 	returnValue = NULL;
-	GDLInterpreter::RetCode retCode;
+	RetCode retCode;
 	
 		for (; _t != NULL;) {
 	
 				retCode=statement(_t);
-				_t = _retTree;
 				
 	// 			if( retCode == RC_RETURN) 
 				if( retCode >= RC_RETURN) 
@@ -516,8 +586,9 @@
 				returnValue=NULL;
 				
 				break;
-				}
-						
+				}					
+	
+			_t = _retTree;
 		}
 		
 		// default return value if none was set
@@ -566,7 +637,7 @@
 	
 	res = NULL;
 	returnValueL = NULL;
-	GDLInterpreter::RetCode retCode;
+	RetCode retCode;
 	
 		ProgNodeP in = _t;
 	
@@ -632,7 +703,7 @@
 void GDLInterpreter::call_pro(ProgNodeP _t) {
 	ProgNodeP call_pro_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	
-	GDLInterpreter::RetCode retCode;
+	RetCode retCode;
 	
 		for (; _t != NULL;) {
 				retCode=statement(_t);
@@ -667,197 +738,82 @@
 	_retTree = _t;
 }
 
- GDLInterpreter::RetCode  GDLInterpreter::for_statement(ProgNodeP _t) {
-	 GDLInterpreter::RetCode retCode;
-	ProgNodeP for_statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	ProgNodeP f = ProgNodeP(antlr::nullAST);
-	ProgNodeP fs = ProgNodeP(antlr::nullAST);
+ RetCode  GDLInterpreter::block(ProgNodeP _t) {
+	 RetCode retCode;
+	ProgNodeP block_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	
-	BaseGDL** v;
-	BaseGDL* s;
-	BaseGDL* e;
-	BaseGDL* st;
-	retCode = RC_OK;
+		match(antlr::RefAST(_t),BLOCK);
+		_retTree = _t->getFirstChild();
+	return RC_OK;
+	//     retCode = RC_OK;
+	
+	// 	ProgNodeP block = _t;
+	// 	match(antlr::RefAST(_t),BLOCK);
+	// 	_t = _t->getFirstChild();
+	// 	if (_t != NULL)
+	// 		{
+	
+	//             SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+	
+	//             retCode=statement_list(_t);
 	
+	//             if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+	//                 !block->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+	//                 {
+	//                     // a jump (goto) occured out of this block
+	//                     return retCode;
+	//                 }
+	// 		}
+	// 	_retTree = block->getNextSibling();
+	// 	return retCode;
 	
+	
+	ProgNodeP __t20 = _t;
+	ProgNodeP tmp32_AST_in = _t;
+	match(antlr::RefAST(_t),BLOCK);
+	_t = _t->getFirstChild();
+	{
 	if (_t == ProgNodeP(antlr::nullAST) )
 		_t = ASTNULL;
 	switch ( _t->getType()) {
+	case ASSIGN:
+	case ASSIGN_REPLACE:
+	case ASSIGN_ARRAYEXPR_MFCALL:
+	case BLOCK:
+	case BREAK:
+	case CONTINUE:
 	case FOR:
+	case FOR_STEP:
+	case FOREACH:
+	case FOR_LOOP:
+	case FOR_STEP_LOOP:
+	case FOREACH_LOOP:
+	case IF_ELSE:
+	case LABEL:
+	case MPCALL:
+	case MPCALL_PARENT:
+	case ON_IOERROR_NULL:
+	case PCALL:
+	case PCALL_LIB:
+	case REPEAT:
+	case REPEAT_LOOP:
+	case RETF:
+	case RETP:
+	case WHILE:
+	case CASE:
+	case GOTO:
+	case IF:
+	case ON_IOERROR:
+	case SWITCH:
+	case DEC:
+	case INC:
 	{
-		ProgNodeP __t31 = _t;
-		f = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-		match(antlr::RefAST(_t),FOR);
-		_t = _t->getFirstChild();
-		
-		ProgNodeP sv = _t;
-		
-		v=l_simple_var(_t);
-		_t = _retTree;
-		s=expr(_t);
-		_t = _retTree;
-		e=expr(_t);
+		retCode=statement_list(_t);
 		_t = _retTree;
-		
-		auto_ptr<BaseGDL> s_guard(s);
-		auto_ptr<BaseGDL> e_guard(e);
-		
-		EnvUDT* callStack_back = 
-		static_cast<EnvUDT*>(callStack.back());
-		SizeT nJump = callStack_back->NJump();
-		
-		s->ForCheck( &e);
-		e_guard.release();
-		e_guard.reset(e);
-		
-		ProgNodeP b=_t; //->getFirstChild();
-		
-		// ASSIGNMENT used here also
-		delete (*v);
-		
-		// problem:
-		// EXECUTE may call DataListT.loc.resize(), as v points to the
-		// old sequence v might be invalidated -> segfault
-		// note that the value (*v) is preserved by resize()
-		s_guard.release(); // s held in *v after this
-		for((*v)=s; (*v)->ForCondUp( e); 
-		v=l_simple_var( sv), (*v)->ForAdd()) 
-		{
-		//                    retCode=block(b);
-		if( b != NULL)
-		{
-		retCode=statement_list(b);
-		
-		if( retCode != RC_OK) // optimization
-		{
-		if( retCode == RC_CONTINUE) 
-		{
-		retCode = RC_OK;
-		continue;  
-		}
-		if( retCode == RC_BREAK) 
-		{
-		retCode = RC_OK;
-		break;        
-		}
-		if( retCode >= RC_RETURN) break;
-		}
-		
-		if( (callStack_back->NJump() != nJump) &&
-		!f->LabelInRange( callStack_back->LastJump()))
-		{
-		// a jump (goto) occured out of this loop
-		return retCode;
-		}
-		}
-		}
-		//                retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
-		
-		_t = __t31;
-		_t = _t->getNextSibling();
 		break;
 	}
-	case FOR_STEP:
+	case 3:
 	{
-		ProgNodeP __t32 = _t;
-		fs = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-		match(antlr::RefAST(_t),FOR_STEP);
-		_t = _t->getFirstChild();
-		
-		ProgNodeP sv = _t;
-		
-		v=l_simple_var(_t);
-		_t = _retTree;
-		s=expr(_t);
-		_t = _retTree;
-		e=expr(_t);
-		_t = _retTree;
-		st=expr(_t);
-		_t = _retTree;
-		
-		auto_ptr<BaseGDL> s_guard(s);
-		auto_ptr<BaseGDL> e_guard(e);
-		auto_ptr<BaseGDL> st_guard(st);
-		
-		SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
-		
-		s->ForCheck( &e, &st);
-		e_guard.release();
-		e_guard.reset(e);
-		st_guard.release();
-		st_guard.reset(st);
-		
-		ProgNodeP bs=_t;
-		
-		// ASSIGNMENT used here also
-		delete (*v);
-		
-		if( st->Sgn() == -1) 
-		{
-		s_guard.release();
-		for((*v)=s; (*v)->ForCondDown( e); 
-		v=l_simple_var( sv), (*v)->ForAdd(st))
-		{
-		if( bs != NULL)
-		{
-		retCode=statement_list(bs);
-		
-		if( retCode == RC_CONTINUE)
-		{
-		retCode = RC_OK;
-		continue;  
-		}
-		if( retCode == RC_BREAK) 
-		{
-		retCode = RC_OK;
-		break;        
-		}
-		if( retCode >= RC_RETURN) break;
-		
-		if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-		!fs->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
-		{
-		// a jump (goto) occured out of this loop
-		return retCode;
-		}
-		}
-		}
-		} 
-		else
-		{
-		s_guard.release();
-		for((*v)=s; (*v)->ForCondUp( e);
-		v=l_simple_var( sv), (*v)->ForAdd(st))
-		{
-		if( bs != NULL)
-		{
-		retCode=statement_list(bs);
-		
-		if( retCode == RC_CONTINUE)
-		{
-		retCode = RC_OK;
-		continue;  
-		}
-		
-		if( retCode == RC_BREAK) 
-		{
-		retCode = RC_OK;
-		break;        
-		}
-		if( retCode >= RC_RETURN) break;
-		
-		if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-		!fs->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
-		{
-		// a jump (goto) occured out of this loop
-		return retCode;
-		}
-		}
-		}
-		}
-		
-		_t = __t32;
-		_t = _t->getNextSibling();
 		break;
 	}
 	default:
@@ -865,216 +821,201 @@
 		throw antlr::NoViableAltException(antlr::RefAST(_t));
 	}
 	}
+	}
+	_t = __t20;
+	_t = _t->getNextSibling();
 	_retTree = _t;
 	return retCode;
 }
 
- GDLInterpreter::RetCode  GDLInterpreter::repeat_statement(ProgNodeP _t) {
-	 GDLInterpreter::RetCode retCode;
-	ProgNodeP repeat_statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	ProgNodeP r = ProgNodeP(antlr::nullAST);
+ RetCode  GDLInterpreter::switch_statement(ProgNodeP _t) {
+	 RetCode retCode;
+	ProgNodeP switch_statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	ProgNodeP s = ProgNodeP(antlr::nullAST);
 	
+	BaseGDL* e;
 	retCode = RC_OK; // not set if no branch is executed
 	
 	
-	ProgNodeP __t27 = _t;
-	r = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	match(antlr::RefAST(_t),REPEAT);
+	ProgNodeP __t23 = _t;
+	s = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	match(antlr::RefAST(_t),SWITCH);
 	_t = _t->getFirstChild();
+	e=expr(_t);
+	_t = _retTree;
 	
-	SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
-	
-	// remember block and expr nodes
-	ProgNodeP e =_t;
-	ProgNodeP bb  = e->GetNextSibling();
+	auto_ptr<BaseGDL> e_guard(e);
 	
-	//                 ProgNodeP bb =_t;
-	//                 ProgNodeP e  = bb->GetNextSibling();
-	//                 bb = bb->GetFirstChild();
+	//                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
 	
-	auto_ptr<BaseGDL> eVal;
-	do {
-	if( bb != NULL)
-	{
-	retCode=statement_list(bb);
+	ProgNodeP b=_t; // remeber block begin (block)
 	
-	if( retCode == RC_CONTINUE)
+	bool hook=false; // switch executes everything after 1st match
+	for( int i=0; i<s->numBranch; i++)
 	{
-	retCode = RC_OK;
-	continue;  
-	}
-	if( retCode == RC_BREAK) 
+	if( b->getType() == ELSEBLK)
 	{
-	retCode = RC_OK;
-	break;        
-	}
-	if( retCode >= RC_RETURN) break;
-	// if( retCode == RC_BREAK) break;        
-	// if( retCode >= RC_RETURN) return retCode;
+	hook=true;
+	
+	ProgNodeP sL = b->GetFirstChild(); // statement_list
 	
-	if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-	!r->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+	if(sL != NULL )
 	{
-	// a jump (goto) occured out of this loop
-	return retCode;
-	}
+	_retTree = sL;
+	return RC_OK;
 	}
-	eVal.reset( expr(e));
-	} while( eVal.get()->False());
-	
-	// retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
 	
-	_t = __t27;
-	_t = _t->getNextSibling();
-	_retTree = _t;
-	return retCode;
-}
-
- GDLInterpreter::RetCode  GDLInterpreter::while_statement(ProgNodeP _t) {
-	 GDLInterpreter::RetCode retCode;
-	ProgNodeP while_statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	ProgNodeP w = ProgNodeP(antlr::nullAST);
+	//                             // statement there
+	//                             retCode=statement_list( sL);
+	//                             if( retCode == RC_BREAK) 
+	//                             {
+	//                                 retCode = RC_OK;    
+	//                                 break;          // break
+	//                             }
+	//                             if( retCode >= RC_RETURN) break; // goto
+	
+	//                             if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+	//                                 !s->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+	//                             {
+	//                                 // a jump (goto) occured out of this loop
+	//                                 return retCode;
+	//                             }
 	
-	retCode = RC_OK;
-	
-	
-	ProgNodeP __t29 = _t;
-	w = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	match(antlr::RefAST(_t),WHILE);
-	_t = _t->getFirstChild();
+	//                         }
+	}
+	else
+	{
+	ProgNodeP ex = b->GetFirstChild();  // EXPR
+	ProgNodeP bb = ex->GetNextSibling(); // statement_list
 	
-	SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+	if( !hook)
+	{
+	//                            RefDNode ee_ = _t->GetFirstChild(); // expr
 	
-	ProgNodeP e = _t; //->GetFirstChild();  // expr
-	ProgNodeP s = _t->GetNextSibling();     // statement
+	BaseGDL* ee=expr(ex);
+	// auto_ptr<BaseGDL> ee_guard(ee);
 	
-	auto_ptr< BaseGDL> eVal( expr( e));
-	while( eVal.get()->True()) {
-	retCode=statement(s);
+	hook=e->Equal(ee); // Equal deletes ee
+	}
 	
-	if( retCode == RC_CONTINUE) 
+	if( hook)
 	{
-	retCode = RC_OK;
-	continue;  
-	}
-	if( retCode == RC_BREAK) 
+	// statement there
+	if(bb != NULL )
 	{
-	retCode = RC_OK;
-	break;        
+	_retTree = bb;
+	return RC_OK;
 	}
-	if( retCode >= RC_RETURN) break;
 	
-	if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-	!w->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
-	{
-	// a jump (goto) occured out of this loop
-	return retCode;
+	//                             _retTree = // find first non empty
+	//                             return RC_OK;
+	//                                 }
+	
+	//                             retCode=statement_list(bb);
+	//                             if( retCode == RC_BREAK) 
+	//                             {
+	//                                 retCode = RC_OK;    
+	//                                 break;          // break
+	//                             }
+	//                             if( retCode >= RC_RETURN) break; // goto
+	
+	//                             if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+	//                                 !s->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+	//                             {
+	//                                 // a jump (goto) occured out of this loop
+	//                                 return retCode;
+	//                             }
 	}
 	
-	eVal.reset( expr( e));
-	} 
-	
-	// retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
-	
-	_t = __t29;
-	_t = _t->getNextSibling();
-	_retTree = _t;
-	return retCode;
-}
-
- GDLInterpreter::RetCode  GDLInterpreter::if_statement(ProgNodeP _t) {
-	 GDLInterpreter::RetCode retCode;
-	ProgNodeP if_statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	ProgNodeP i = ProgNodeP(antlr::nullAST);
-	
-	BaseGDL* e;
-	retCode = RC_OK; // not set if not executed
-	
-	
-	ProgNodeP __t34 = _t;
-	i = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	match(antlr::RefAST(_t),IF);
-	_t = _t->getFirstChild();
-	e=expr(_t);
-	_t = _retTree;
-	
-	auto_ptr<BaseGDL> e_guard(e);
-	
-	SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
-	
-	if( e->True())
-	{
-	retCode=statement(_t);
-	//                    if( retCode != RC_OK) return retCode;
-	
-	if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-	!i->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
-	{
-	// a jump (goto) occured out of this loop
-	return retCode;
 	}
+	b=b->GetNextSibling(); // next block
 	}
+	_retTree = s->GetNextSibling();
+	return RC_OK;
+	// finish or break
+	//                retCode=RC_OK; // clear RC_BREAK retCode
 	
-	_t = __t34;
+	_t = __t23;
 	_t = _t->getNextSibling();
 	_retTree = _t;
 	return retCode;
 }
 
- GDLInterpreter::RetCode  GDLInterpreter::if_else_statement(ProgNodeP _t) {
-	 GDLInterpreter::RetCode retCode;
-	ProgNodeP if_else_statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	ProgNodeP i = ProgNodeP(antlr::nullAST);
-	
-	BaseGDL* e;
-	retCode = RC_OK; // not set if not executed
-	
+BaseGDL*  GDLInterpreter::expr(ProgNodeP _t) {
+	BaseGDL* res;
+	ProgNodeP expr_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	
-	ProgNodeP __t36 = _t;
-	i = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	match(antlr::RefAST(_t),IF_ELSE);
-	_t = _t->getFirstChild();
-	e=expr(_t);
-	_t = _retTree;
+		
+		assert( _t != NULL);
 	
-	auto_ptr<BaseGDL> e_guard(e);
+		if ( _t->getType() == FCALL_LIB) {
+	BaseGDL* res=lib_function_call(_t);
+			
+			if( callStack.back()->Contains( res)) 
+			res = res->Dup();
 	
-	SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+	return res;    		
+		}
+		else
+		{
+			return tmp_expr(_t);
+		}
 	
-	if( e->True())
-	{
-	retCode=statement(_t);
-	//                    if( retCode != RC_OK) return retCode;
 	
-	if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-	!i->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+	if (_t == ProgNodeP(antlr::nullAST) )
+		_t = ASTNULL;
+	switch ( _t->getType()) {
+	case ASSIGN:
+	case ASSIGN_REPLACE:
+	case ASSIGN_ARRAYEXPR_MFCALL:
+	case ARRAYDEF:
+	case ARRAYEXPR:
+	case ARRAYEXPR_MFCALL:
+	case CONSTANT:
+	case DEREF:
+	case EXPR:
+	case FCALL:
+	case FCALL_LIB_RETNEW:
+	case MFCALL:
+	case MFCALL_PARENT:
+	case NSTRUC:
+	case NSTRUC_REF:
+	case POSTDEC:
+	case POSTINC:
+	case STRUC:
+	case SYSVAR:
+	case VAR:
+	case VARPTR:
+	case DEC:
+	case INC:
+	case DOT:
+	case QUESTION:
 	{
-	// a jump (goto) occured out of this loop
-	return retCode;
-	}
+		res=tmp_expr(_t);
+		_t = _retTree;
+		break;
 	}
-	else
+	case FCALL_LIB:
 	{
-	_t=_t->GetNextSibling(); // jump over 1st statement
-	retCode=statement(_t);
-	//                    if( retCode != RC_OK) return retCode;
-	
-	if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-	!i->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+		res=lib_function_call(_t);
+		_t = _retTree;
+		
+		if( callStack.back()->Contains( res)) 
+		res = res->Dup();
+		
+		break;
+	}
+	default:
 	{
-	// a jump (goto) occured out of this loop
-	return retCode;
+		throw antlr::NoViableAltException(antlr::RefAST(_t));
 	}
 	}
-	
-	_t = __t36;
-	_t = _t->getNextSibling();
 	_retTree = _t;
-	return retCode;
+	return res;
 }
 
- GDLInterpreter::RetCode  GDLInterpreter::case_statement(ProgNodeP _t) {
-	 GDLInterpreter::RetCode retCode;
+ RetCode  GDLInterpreter::case_statement(ProgNodeP _t) {
+	 RetCode retCode;
 	ProgNodeP case_statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	ProgNodeP c = ProgNodeP(antlr::nullAST);
 	
@@ -1091,7 +1032,7 @@
 	
 	auto_ptr<BaseGDL> e_guard(e);
 	
-	SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+	//                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
 	
 	if( !e->Scalar())
 	throw GDLException( _t, "Expression must be a"
@@ -1099,7 +1040,7 @@
 	
 	ProgNodeP b=_t; // remeber block begin
 	
-	for( int i=0; i<c->numBranch; i++)
+	for( int i=0; i<c->numBranch; ++i)
 	{
 	if( b->getType() == ELSEBLK)
 	{
@@ -1107,22 +1048,31 @@
 	
 	if(sL != NULL )
 	{
-	// statement there
-	retCode=statement_list(sL);
-	//if( retCode == RC_BREAK) break; // break anyway
-	//                            if( retCode >= RC_RETURN) return retCode; 
-	if( retCode >= RC_RETURN) break;
-	
-	if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-	!c->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+	_retTree = sL;
+	return RC_OK;
+	}
+	else
 	{
-	// a jump (goto) occured out of this loop
-	return retCode;
+	_retTree = c->GetNextSibling();
+	return RC_OK;
 	}
 	
-	}
-	retCode = RC_OK;
-	break;
+	//                             // statement there
+	//                             retCode=statement_list(sL);
+	//                             //if( retCode == RC_BREAK) break; // break anyway
+	// //                            if( retCode >= RC_RETURN) return retCode; 
+	//                             if( retCode >= RC_RETURN) break;
+	
+	//                             if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+	//                                 !c->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+	//                             {
+	//                                 // a jump (goto) occured out of this loop
+	//                                 return retCode;
+	//                             }
+	
+	//                         }
+	//                         retCode = RC_OK;
+	//                         break;
 	}
 	else
 	{
@@ -1136,31 +1086,42 @@
 	
 	if( equalexpr)
 	{
-	if(bb != NULL)
-	{
-	// statement there
-	retCode=statement_list(bb);
-	//if( retCode == RC_BREAK) break; // break anyway
-	//                                if( retCode >= RC_RETURN) return retCode;
-	if( retCode >= RC_RETURN) break;
-	
-	if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-	!c->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+	if(bb != NULL )
 	{
-	// a jump (goto) occured out of this loop
-	return retCode;
+	_retTree = bb;
+	return RC_OK;
 	}
-	
+	else
+	{
+	_retTree = c->GetNextSibling();
+	return RC_OK;
 	}
-	retCode = RC_OK;
-	break;
+	//                             if(bb != NULL)
+	//                             {
+	//                                 // statement there
+	//                                 retCode=statement_list(bb);
+	//                                 //if( retCode == RC_BREAK) break; // break anyway
+	// //                                if( retCode >= RC_RETURN) return retCode;
+	//                                 if( retCode >= RC_RETURN) break;
+	
+	//                                 if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+	//                                     !c->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+	//                                 {
+	//                                     // a jump (goto) occured out of this loop
+	//                                     return retCode;
+	//                                 }
+	
+	//                             }
+	//                             retCode = RC_OK;
+	//                             break;
 	}
 	
 	}
 	b=b->GetNextSibling(); // next block
-	}
+	} // for
 	// finish or break
 	//                retCode=RC_OK; // clear RC_BREAK retCode
+	throw GDLException( c, "CASE statement found no match.",true,false);
 	
 	_t = __t25;
 	_t = _t->getNextSibling();
@@ -1168,277 +1129,402 @@
 	return retCode;
 }
 
- GDLInterpreter::RetCode  GDLInterpreter::switch_statement(ProgNodeP _t) {
-	 GDLInterpreter::RetCode retCode;
-	ProgNodeP switch_statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	ProgNodeP s = ProgNodeP(antlr::nullAST);
-	
-	BaseGDL* e;
-	retCode = RC_OK; // not set if no branch is executed
-	
+ RetCode  GDLInterpreter::repeat_statement(ProgNodeP _t) {
+	 RetCode retCode;
+	ProgNodeP repeat_statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	ProgNodeP r = ProgNodeP(antlr::nullAST);
 	
-	ProgNodeP __t23 = _t;
-	s = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	match(antlr::RefAST(_t),SWITCH);
+	ProgNodeP __t27 = _t;
+	r = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	match(antlr::RefAST(_t),REPEAT);
 	_t = _t->getFirstChild();
-	e=expr(_t);
-	_t = _retTree;
 	
-	auto_ptr<BaseGDL> e_guard(e);
+	// _t is REPEAT_LOOP, GetFirstChild() is expr, GetNextSibling is first loop statement
+	_retTree = _t->GetFirstChild()->GetNextSibling();     // statement
+	return RC_OK;
 	
-	SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+	_t = __t27;
+	_t = _t->getNextSibling();
+	_retTree = _t;
+	return retCode;
+}
+
+ RetCode  GDLInterpreter::repeat_loop_statement(ProgNodeP _t) {
+	 RetCode retCode;
+	ProgNodeP repeat_loop_statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	ProgNodeP r = ProgNodeP(antlr::nullAST);
 	
-	ProgNodeP b=_t; // remeber block begin (block)
+	ProgNodeP __t29 = _t;
+	r = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	match(antlr::RefAST(_t),REPEAT_LOOP);
+	_t = _t->getFirstChild();
 	
-	bool hook=false; // switch executes everything after 1st match
-	for( int i=0; i<s->numBranch; i++)
+	auto_ptr<BaseGDL> eVal( expr(_t));
+	if( eVal.get()->False())
 	{
-	if( b->getType() == ELSEBLK)
+	_retTree = _t->GetNextSibling();     // 1st loop statement
+	if( _retTree == NULL)
+	throw GDLException(r,
+	"Empty REPEAT loop entered (infinite loop).",
+	true,false);
+	return RC_OK;
+	}
+	else
 	{
-	hook=true;
+	_retTree = r->GetNextSibling();     // statement
+	return RC_OK;
+	}
 	
-	ProgNodeP sL = b->GetFirstChild(); // statement_list
+	//                 retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
+	//                 SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
 	
-	if( sL != NULL )
-	{
-	// statement there
-	retCode=statement_list( sL);
-	if( retCode == RC_BREAK) 
-	{
-	retCode = RC_OK;    
-	break;          // break
-	}
-	if( retCode >= RC_RETURN) break; // goto
+	//                 // remember block and expr nodes
+	//                 ProgNodeP e =_t;
+	//                 ProgNodeP bb  = e->GetNextSibling();
+	
+	// //                 ProgNodeP bb =_t;
+	// //                 ProgNodeP e  = bb->GetNextSibling();
+	// //                 bb = bb->GetFirstChild();
+	
+	//                 auto_ptr<BaseGDL> eVal;
+	//                 do {
+	//                     if( bb != NULL)
+	//                     {
+	//                     retCode=statement_list(bb);
+	
+	//                     if( retCode == RC_CONTINUE)
+	//                                 {
+	//                                 retCode = RC_OK;
+	//                                 continue;  
+	//                                 }
+	//                     if( retCode == RC_BREAK) 
+	//                     {
+	//                         retCode = RC_OK;
+	//                         break;        
+	//                     }
+	//                     if( retCode >= RC_RETURN) break;
+	//                     // if( retCode == RC_BREAK) break;        
+	//                     // if( retCode >= RC_RETURN) return retCode;
+	
+	//                     if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+	//                         !r->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+	//                     {
+	//                         // a jump (goto) occured out of this loop
+	//                         return retCode;
+	//                     }
+	//                     }
+	//                     eVal.reset( expr(e));
+	//                 } while( eVal.get()->False());
 	
-	if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-	!s->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
-	{
-	// a jump (goto) occured out of this loop
-	return retCode;
-	}
+	//                 // retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
 	
-	}
-	}
-	else
-	{
-	ProgNodeP ex = b->GetFirstChild();  // EXPR
-	ProgNodeP bb = ex->GetNextSibling(); // statement_list
-	
-	if( !hook)
-	{
-	//                            RefDNode ee_ = _t->GetFirstChild(); // expr
-	
-	BaseGDL* ee=expr(ex);
-	// auto_ptr<BaseGDL> ee_guard(ee);
-	
-	hook=e->Equal(ee); // Equal deletes ee
-	}
-	
-	if(bb != NULL && hook)
-	{
-	// statement there
-	retCode=statement_list(bb);
-	if( retCode == RC_BREAK) 
-	{
-	retCode = RC_OK;    
-	break;          // break
-	}
-	if( retCode >= RC_RETURN) break; // goto
-	
-	if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-	!s->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
-	{
-	// a jump (goto) occured out of this loop
-	return retCode;
-	}
-	}
-	
-	}
-	b=b->GetNextSibling(); // next block
-	}
-	// finish or break
-	//                retCode=RC_OK; // clear RC_BREAK retCode
-	
-	_t = __t23;
+	_t = __t29;
 	_t = _t->getNextSibling();
 	_retTree = _t;
 	return retCode;
 }
 
- GDLInterpreter::RetCode  GDLInterpreter::block(ProgNodeP _t) {
-	 GDLInterpreter::RetCode retCode;
-	ProgNodeP block_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+ RetCode  GDLInterpreter::while_statement(ProgNodeP _t) {
+	 RetCode retCode;
+	ProgNodeP while_statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	ProgNodeP w = ProgNodeP(antlr::nullAST);
 	
 	retCode = RC_OK;
 	
-		ProgNodeP block = _t;
-		match(antlr::RefAST(_t),BLOCK);
-		_t = _t->getFirstChild();
-		if (_t != NULL)
-			{
-	
-	SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
 	
-	retCode=statement_list(_t);
+	ProgNodeP __t31 = _t;
+	w = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	match(antlr::RefAST(_t),WHILE);
+	_t = _t->getFirstChild();
 	
-	if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
-	!block->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
-	{
-	// a jump (goto) occured out of this block
-	return retCode;
-	}
-			}
-		_retTree = block->getNextSibling();
-		return retCode;
+	//                 SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
 	
+	//                 ProgNodeP e = _t; //->GetFirstChild();  // expr
 	
-	ProgNodeP __t20 = _t;
-	ProgNodeP tmp3_AST_in = _t;
-	match(antlr::RefAST(_t),BLOCK);
-	_t = _t->getFirstChild();
-	{
-	if (_t == ProgNodeP(antlr::nullAST) )
-		_t = ASTNULL;
-	switch ( _t->getType()) {
-	case ASSIGN:
-	case ASSIGN_REPLACE:
-	case BLOCK:
-	case BREAK:
-	case CONTINUE:
-	case FOR_STEP:
-	case IF_ELSE:
-	case LABEL:
-	case MPCALL:
-	case MPCALL_PARENT:
-	case ON_IOERROR_NULL:
-	case PCALL:
-	case PCALL_LIB:
-	case RETF:
-	case RETP:
-	case CASE:
-	case FOR:
-	case GOTO:
-	case IF:
-	case ON_IOERROR:
-	case REPEAT:
-	case SWITCH:
-	case WHILE:
-	case DEC:
-	case INC:
+	auto_ptr<BaseGDL> eVal( expr( _t));
+	if( eVal.get()->True()) 
 	{
-		retCode=statement_list(_t);
-		_t = _retTree;
-		break;
+	_retTree = _t->GetNextSibling();     // 1st loop statement
+	if( _retTree == NULL)
+	throw GDLException(w,
+	"Empty WHILE loop entered (infinite loop).",
+	true,false);
+	return RC_OK;
 	}
-	case 3:
-	{
-		break;
-	}
-	default:
+	else
 	{
-		throw antlr::NoViableAltException(antlr::RefAST(_t));
-	}
-	}
+	_retTree = w->GetNextSibling();     // statement
+	return RC_OK;
 	}
-	_t = __t20;
+	
+	//                 auto_ptr< BaseGDL> eVal( expr( e));
+	//                 while( eVal.get()->True()) {
+	//                     retCode=statement_list(s);
+	
+	//                     if( retCode == RC_CONTINUE) 
+	//                                 {
+	//                                 retCode = RC_OK;
+	//                                 continue;  
+	//                                 }
+	//                     if( retCode == RC_BREAK) 
+	//                     {
+	//                         retCode = RC_OK;
+	//                         break;        
+	//                     }
+	//                     if( retCode >= RC_RETURN) break;
+	
+	//                     if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+	//                         !w->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+	//                     {
+	//                         // a jump (goto) occured out of this loop
+	//                         return retCode;
+	//                     }
+	
+	//                     eVal.reset( expr( e));
+	//                 } 
+	
+	// retCode=RC_OK; // clear RC_BREAK/RC_CONTINUE retCode
+	
+	_t = __t31;
 	_t = _t->getNextSibling();
 	_retTree = _t;
 	return retCode;
 }
 
- GDLInterpreter::RetCode  GDLInterpreter::jump_statement(ProgNodeP _t) {
-	 GDLInterpreter::RetCode retCode;
-	ProgNodeP jump_statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	ProgNodeP g = ProgNodeP(antlr::nullAST);
+ RetCode  GDLInterpreter::for_statement(ProgNodeP _t) {
+	 RetCode retCode;
+	ProgNodeP for_statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	ProgNodeP f = ProgNodeP(antlr::nullAST);
+	ProgNodeP fl = ProgNodeP(antlr::nullAST);
+	ProgNodeP fs = ProgNodeP(antlr::nullAST);
+	ProgNodeP fsl = ProgNodeP(antlr::nullAST);
 	
-	BaseGDL*  e;
-	BaseGDL** eL;
+	BaseGDL** v;
+	BaseGDL* s;
+	BaseGDL* e;
+	BaseGDL* st;
+	retCode = RC_OK;
 	
 	
 	if (_t == ProgNodeP(antlr::nullAST) )
 		_t = ASTNULL;
 	switch ( _t->getType()) {
-	case GOTO:
+	case FOR:
 	{
-		g = _t;
-		match(antlr::RefAST(_t),GOTO);
-		_t = _t->getNextSibling();
+		ProgNodeP __t33 = _t;
+		f = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+		match(antlr::RefAST(_t),FOR);
+		_t = _t->getFirstChild();
 		
-		// note that this version jumps 'dumb'
-		// jumping into loops is legal, even then looping is not done
+		_t = f->GetNextSibling()->GetFirstChild();
 		
-		// set the jump target - also logs the jump
-		_t = static_cast<EnvUDT*>(callStack.back())->GotoTarget( g->targetIx);
-		_t = _t->GetNextSibling();
-		retCode=RC_OK;
+		EnvUDT* callStack_back = 
+		static_cast<EnvUDT*>(callStack.back());
+		
+		ForLoopInfoT& loopInfo = 
+		callStack_back->GetForLoopInfo( f->forLoopIx);
+		
+		v=l_simple_var(_t);
+		_t = _retTree;
+		
+		s=expr(_t);
+		auto_ptr<BaseGDL> s_guard(s);
+		_t = _retTree;
+		
+		delete loopInfo.endLoopVar;
+		loopInfo.endLoopVar=expr(_t);
+		
+		ProgNodeP b = _retTree;
+				
+		s->ForCheck( &loopInfo.endLoopVar);
+		
+		// ASSIGNMENT used here also
+		delete (*v);
+		(*v)= s_guard.release(); // s held in *v after this
 		
+		if( (*v)->ForCondUp( loopInfo.endLoopVar))
+		{
+		_retTree = b;
+		return RC_OK;
+		}
+		else
+		{
+		// skip if initial test fails
+		_retTree = f->GetNextSibling()->GetNextSibling();
+		return RC_OK;
+		}
+		
+		_t = __t33;
+		_t = _t->getNextSibling();
 		break;
 	}
-	case RETF:
+	case FOR_LOOP:
 	{
-		ProgNodeP __t38 = _t;
-		ProgNodeP tmp4_AST_in = _t;
-		match(antlr::RefAST(_t),RETF);
+		ProgNodeP __t34 = _t;
+		fl = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+		match(antlr::RefAST(_t),FOR_LOOP);
 		_t = _t->getFirstChild();
+		
+		EnvUDT* callStack_back = 
+		static_cast<EnvUDT*>(callStack.back());
+		
+		ForLoopInfoT& loopInfo = 
+		callStack_back->GetForLoopInfo( fl->forLoopIx);
+		
+		if( loopInfo.endLoopVar == NULL)
 		{
-		if (_t == ProgNodeP(antlr::nullAST) )
-			_t = ASTNULL;
-		if (((_tokenSet_1.member(_t->getType())))&&( !static_cast<EnvUDT*>(callStack.back())->LFun())) {
-			e=expr(_t);
-			_t = _retTree;
-			
-			delete returnValue;
-			returnValue=e;
-			retCode=RC_RETURN;
-			callStack.back()->RemoveLoc( e); // steal e from local list
-			
+		// non-initialized loop (GOTO)
+		_retTree = fl->GetNextSibling();
+		return RC_OK;
 		}
-		else if ((_tokenSet_2.member(_t->getType()))) {
-			eL=l_ret_expr(_t);
-			_t = _retTree;
-			
-			// returnValueL is otherwise owned
-			returnValueL=eL;
-			retCode=RC_RETURN;
-			
+		
+		// // problem:
+		// // EXECUTE may call DataListT.loc.resize(), as v points to the
+		// // old sequence v might be invalidated -> segfault
+		// // note that the value (*v) is preserved by resize()
+		
+		v=l_simple_var(_t);
+		_t = _retTree;
+		
+		(*v)->ForAdd();
+		if( (*v)->ForCondUp( loopInfo.endLoopVar))
+		{
+		_retTree = _t->GetNextSibling()->GetNextSibling();
+		return RC_OK;
 		}
-		else {
-			throw antlr::NoViableAltException(antlr::RefAST(_t));
+		else
+		{
+		delete loopInfo.endLoopVar;
+		loopInfo.endLoopVar = NULL;
+		_retTree = fl->GetNextSibling();
+		return RC_OK;
 		}
 		
-		}
-		_t = __t38;
+		
+		_t = __t34;
 		_t = _t->getNextSibling();
 		break;
 	}
-	case RETP:
+	case FOR_STEP:
 	{
-		ProgNodeP tmp5_AST_in = _t;
-		match(antlr::RefAST(_t),RETP);
-		_t = _t->getNextSibling();
+		ProgNodeP __t35 = _t;
+		fs = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+		match(antlr::RefAST(_t),FOR_STEP);
+		_t = _t->getFirstChild();
 		
-		retCode=RC_RETURN;
+		_t = fs->GetNextSibling()->GetFirstChild();
 		
-		break;
-	}
-	case BREAK:
-	{
-		ProgNodeP tmp6_AST_in = _t;
-		match(antlr::RefAST(_t),BREAK);
-		_t = _t->getNextSibling();
+		EnvUDT* callStack_back = 
+		static_cast<EnvUDT*>(callStack.back());
 		
-		retCode=RC_BREAK;
+		ForLoopInfoT& loopInfo = 
+		callStack_back->GetForLoopInfo( fs->forLoopIx);
 		
+		v=l_simple_var(_t);
+		_t = _retTree;
+		
+		s=expr(_t);
+		auto_ptr<BaseGDL> s_guard(s);
+		_t = _retTree;
+		
+		delete loopInfo.endLoopVar;
+		loopInfo.endLoopVar=expr(_t);
+		_t = _retTree;
+		
+		delete loopInfo.loopStepVar;
+		loopInfo.loopStepVar=expr(_t);
+		
+		ProgNodeP b = _retTree;
+				
+		s->ForCheck( &loopInfo.endLoopVar, &loopInfo.loopStepVar);
+		
+		// ASSIGNMENT used here also
+		delete (*v);
+		(*v)= s_guard.release(); // s held in *v after this
+		
+		if( loopInfo.loopStepVar->Sgn() == -1) 
+		{
+		if( (*v)->ForCondDown( loopInfo.endLoopVar))
+		{
+		_retTree = b;
+		return RC_OK;
+		}
+		}
+		else
+		{
+		if( (*v)->ForCondUp( loopInfo.endLoopVar))
+		{
+		_retTree = b;
+		return RC_OK;
+		}
+		}
+		
+		// skip if initial test fails
+		_retTree = f->GetNextSibling()->GetNextSibling();
+		return RC_OK;
+		
+		_t = __t35;
+		_t = _t->getNextSibling();
 		break;
 	}
-	case CONTINUE:
+	case FOR_STEP_LOOP:
 	{
-		ProgNodeP tmp7_AST_in = _t;
-		match(antlr::RefAST(_t),CONTINUE);
-		_t = _t->getNextSibling();
+		ProgNodeP __t36 = _t;
+		fsl = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+		match(antlr::RefAST(_t),FOR_STEP_LOOP);
+		_t = _t->getFirstChild();
+		
+		EnvUDT* callStack_back = 
+		static_cast<EnvUDT*>(callStack.back());
+		
+		ForLoopInfoT& loopInfo = 
+		callStack_back->GetForLoopInfo( fsl->forLoopIx);
+		
+		if( loopInfo.endLoopVar == NULL)
+		{
+		// non-initialized loop (GOTO)
+		_retTree = fsl->GetNextSibling();
+		return RC_OK;
+		}
+		
+		// // problem:
+		// // EXECUTE may call DataListT.loc.resize(), as v points to the
+		// // old sequence v might be invalidated -> segfault
+		// // note that the value (*v) is preserved by resize()
+		
+		v=l_simple_var(_t);
+		_t = _retTree;
 		
-		retCode=RC_CONTINUE;
+		ProgNodeP b = _t->GetNextSibling()->GetNextSibling()->GetNextSibling();
 		
+		(*v)->ForAdd(loopInfo.loopStepVar);
+		if( loopInfo.loopStepVar->Sgn() == -1) 
+		{
+		if( (*v)->ForCondDown( loopInfo.endLoopVar))
+		{
+		_retTree = b;
+		return RC_OK;
+		}
+		}
+		else
+		{
+		if( (*v)->ForCondUp( loopInfo.endLoopVar))
+		{
+		_retTree = b;
+		return RC_OK;
+		}
+		}
+		
+		delete loopInfo.endLoopVar;
+		loopInfo.endLoopVar = NULL;
+		delete loopInfo.loopStepVar;
+		loopInfo.loopStepVar = NULL;
+		_retTree = fsl->GetNextSibling();
+		return RC_OK;
+		
+		
+		_t = __t36;
+		_t = _t->getNextSibling();
 		break;
 	}
 	default:
@@ -1450,66 +1536,107 @@
 	return retCode;
 }
 
-BaseGDL*  GDLInterpreter::expr(ProgNodeP _t) {
-	BaseGDL* res;
-	ProgNodeP expr_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	
-		
-		assert( _t != NULL);
-	
-		if ( _t->getType() == FCALL_LIB) {
-	BaseGDL* res=lib_function_call(_t);
-			
-			if( callStack.back()->Contains( res)) 
-			res = res->Dup();
+ RetCode  GDLInterpreter::foreach_statement(ProgNodeP _t) {
+	 RetCode retCode;
+	ProgNodeP foreach_statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	ProgNodeP f = ProgNodeP(antlr::nullAST);
+	ProgNodeP fl = ProgNodeP(antlr::nullAST);
 	
-	return res;    		
-		}
-		else
-		{
-			return tmp_expr(_t);
-		}
+	BaseGDL** v;
+	BaseGDL* s;
+	retCode = RC_OK;
 	
 	
 	if (_t == ProgNodeP(antlr::nullAST) )
 		_t = ASTNULL;
 	switch ( _t->getType()) {
-	case ASSIGN:
-	case ASSIGN_REPLACE:
-	case ARRAYDEF:
-	case ARRAYEXPR:
-	case CONSTANT:
-	case DEREF:
-	case EXPR:
-	case FCALL:
-	case FCALL_LIB_RETNEW:
-	case MFCALL:
-	case MFCALL_PARENT:
-	case NSTRUC:
-	case NSTRUC_REF:
-	case POSTDEC:
-	case POSTINC:
-	case STRUC:
-	case SYSVAR:
-	case VAR:
-	case VARPTR:
-	case DEC:
-	case INC:
-	case DOT:
-	case QUESTION:
+	case FOREACH:
 	{
-		res=tmp_expr(_t);
+		ProgNodeP __t38 = _t;
+		f = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+		match(antlr::RefAST(_t),FOREACH);
+		_t = _t->getFirstChild();
+		
+		_t = f->GetNextSibling()->GetFirstChild();
+		
+		EnvUDT* callStack_back = 
+		static_cast<EnvUDT*>(callStack.back());
+		
+		ForLoopInfoT& loopInfo = 
+		callStack_back->GetForLoopInfo( f->forLoopIx);
+		
+		v=l_simple_var(_t);
 		_t = _retTree;
+		
+		delete loopInfo.endLoopVar;
+		loopInfo.endLoopVar=expr(_t);
+		
+		ProgNodeP b = _retTree;
+				
+		loopInfo.foreachIx = 0;
+		
+		// currently there are no empty arrays
+		//SizeT nEl = loopInfo.endLoopVar->N_Elements();
+		
+		// ASSIGNMENT used here also
+		delete (*v);
+		(*v) = loopInfo.endLoopVar->NewIx( 0);
+		
+		_retTree = b;
+		return RC_OK;
+		
+		_t = __t38;
+		_t = _t->getNextSibling();
 		break;
 	}
-	case FCALL_LIB:
+	case FOREACH_LOOP:
 	{
-		res=check_expr(_t);
+		ProgNodeP __t39 = _t;
+		fl = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+		match(antlr::RefAST(_t),FOREACH_LOOP);
+		_t = _t->getFirstChild();
+		
+		EnvUDT* callStack_back = 
+		static_cast<EnvUDT*>(callStack.back());
+		
+		ForLoopInfoT& loopInfo = 
+		callStack_back->GetForLoopInfo( fl->forLoopIx);
+		
+		if( loopInfo.endLoopVar == NULL)
+		{
+		// non-initialized loop (GOTO)
+		_retTree = fl->GetNextSibling();
+		return RC_OK;
+		}
+		
+		v=l_simple_var(_t);
 		_t = _retTree;
 		
-		if( callStack.back()->Contains( res)) 
-		res = res->Dup();
+		// skip expr
+		_t = _t->getNextSibling();
+		
+		++loopInfo.foreachIx;
+		
+		SizeT nEl = loopInfo.endLoopVar->N_Elements();
+		
+		if( loopInfo.foreachIx < nEl)
+		{
+		// ASSIGNMENT used here also
+		delete (*v);
+		(*v) = loopInfo.endLoopVar->NewIx( loopInfo.foreachIx);
+		
+		_retTree = _t;
+		return RC_OK;
+		}
+		
+		delete loopInfo.endLoopVar;
+		loopInfo.endLoopVar = NULL;
+		loopInfo.foreachIx = -1;
+		_retTree = fl->GetNextSibling();
+		return RC_OK;
 		
+		_t = __t39;
+		_t = _t->getNextSibling();
 		break;
 	}
 	default:
@@ -1518,70 +1645,209 @@
 	}
 	}
 	_retTree = _t;
-	return res;
+	return retCode;
 }
 
-BaseGDL**  GDLInterpreter::l_simple_var(ProgNodeP _t) {
-	BaseGDL** res;
-	ProgNodeP l_simple_var_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	ProgNodeP var = ProgNodeP(antlr::nullAST);
-	ProgNodeP varPtr = ProgNodeP(antlr::nullAST);
+ RetCode  GDLInterpreter::if_statement(ProgNodeP _t) {
+	 RetCode retCode;
+	ProgNodeP if_statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	ProgNodeP i = ProgNodeP(antlr::nullAST);
 	
-		assert( _t != NULL);
+	BaseGDL* e;
+	//    retCode = RC_OK; // not set if not executed
 	
-		if( _t->getType() == VAR)
-		{
-			ProgNodeP var = _t;
-	// 		match(antlr::RefAST(_t),VAR);
-			_t = _t->getNextSibling();
-			
-			
-			res=&callStack.back()->GetKW(var->varIx); 
-			
-		}
-		else
-		{
-			ProgNodeP varPtr = _t;
-	// 		match(antlr::RefAST(_t),VARPTR);
-			_t = _t->getNextSibling();
-			
-			res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
-			
-		}
 	
-		_retTree = _t;
-		return res;
+	ProgNodeP __t41 = _t;
+	i = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	match(antlr::RefAST(_t),IF);
+	_t = _t->getFirstChild();
+	e=expr(_t);
+	_t = _retTree;
+	
+	auto_ptr<BaseGDL> e_guard(e);
 	
+	//                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
 	
-	if (_t == ProgNodeP(antlr::nullAST) )
-		_t = ASTNULL;
-	switch ( _t->getType()) {
-	case VAR:
+	if( e->True())
 	{
-		var = _t;
-		match(antlr::RefAST(_t),VAR);
-		_t = _t->getNextSibling();
-		
-		
-		res=&callStack.back()->GetKW(var->varIx); 
-		
-		break;
+	_retTree = _t;
+	return RC_OK;
 	}
-	case VARPTR:
+	
+	_retTree = i->GetNextSibling();
+	return RC_OK;
+	
+	//                     retCode=statement(_t);
+	// //                     if( retCode != RC_OK) return retCode;
+	
+	//                         if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+	//                             !i->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+	//                         {
+	//                             // a jump (goto) occured out of this loop
+	//                             return retCode;
+	//                         }
+	
+	_t = __t41;
+	_t = _t->getNextSibling();
+	_retTree = _t;
+	return retCode;
+}
+
+ RetCode  GDLInterpreter::if_else_statement(ProgNodeP _t) {
+	 RetCode retCode;
+	ProgNodeP if_else_statement_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	ProgNodeP i = ProgNodeP(antlr::nullAST);
+	
+	BaseGDL* e;
+	retCode = RC_OK; // not set if not executed
+	
+	
+	ProgNodeP __t43 = _t;
+	i = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	match(antlr::RefAST(_t),IF_ELSE);
+	_t = _t->getFirstChild();
+	e=expr(_t);
+	_t = _retTree;
+	
+	auto_ptr<BaseGDL> e_guard(e);
+	
+	//                SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+	
+	if( e->True())
 	{
-		varPtr = _t;
-		match(antlr::RefAST(_t),VARPTR);
-		_t = _t->getNextSibling();
-		
-		res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
-		
-		break;
+	_retTree = _t->GetFirstChild();
+	return RC_OK;
 	}
-	default:
+	
+	_retTree = _t->GetNextSibling();
+	return RC_OK;
+	//             { 
+	//                 auto_ptr<BaseGDL> e_guard(e);
+	
+	//                 SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
+	
+	//                 if( e->True())
+	//                 {
+	//                     retCode=statement(_t);
+	// // //                    if( retCode != RC_OK) return retCode;
+	
+	//                     if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+	//                         !i->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+	//                     {
+	//                         // a jump (goto) occured out of this loop
+	//                         return retCode;
+	//                     }
+	//                 }
+	//                 else
+	//                 {
+	//                     _t=_t->GetNextSibling(); // jump over 1st statement
+	//                     retCode=statement(_t);
+	// // //                   if( retCode != RC_OK) return retCode;
+	
+	//                     if( (static_cast<EnvUDT*>(callStack.back())->NJump() != nJump) &&
+	//                         !i->LabelInRange( static_cast<EnvUDT*>(callStack.back())->LastJump()))
+	//                     {
+	//                         // a jump (goto) occured out of this loop
+	//                         return retCode;
+	//                     }
+	//                 }
+	
+	_t = __t43;
+	_t = _t->getNextSibling();
+	_retTree = _t;
+	return retCode;
+}
+
+BaseGDL**  GDLInterpreter::l_deref(ProgNodeP _t) {
+	BaseGDL** res;
+	ProgNodeP l_deref_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	
+		ProgNodeP retTree = _t->getNextSibling();
+	
+	auto_ptr<BaseGDL> e1_guard;
+	BaseGDL* e1;
+	ProgNodeP evalExpr = _t->getFirstChild();
+	if( NonCopyNode( evalExpr->getType()))
 	{
-		throw antlr::NoViableAltException(antlr::RefAST(_t));
+	e1 = evalExpr->EvalNC();
 	}
+	else if( evalExpr->getType() ==  GDLTokenTypes::FCALL_LIB)
+	{
+			e1=lib_function_call(evalExpr);
+	
+			if( e1 == NULL) // ROUTINE_NAMES
+				throw GDLException( evalExpr, "Undefined return value", true, false);
+			
+			if( !callStack.back()->Contains( e1)) 
+				e1_guard.reset( e1);
 	}
+	else
+	{
+	e1 = evalExpr->Eval();
+	e1_guard.reset(e1);
+	}
+	
+	if( e1 == NULL || e1->Type() != PTR)
+	throw GDLException( evalExpr, "Pointer type required"
+				" in this context: "+Name(e1),true,false);
+	
+	DPtrGDL* ptr=static_cast<DPtrGDL*>(e1);
+	
+	//     _t = _t->getFirstChild();
+	
+	//     BaseGDL* e1;
+	
+	// 	auto_ptr<BaseGDL> e1_guard;
+	
+	//     if( _t->getType() ==  GDLTokenTypes::FCALL_LIB)
+	//       {
+	// 		e1=lib_function_call(_t);
+	
+	// 		if( e1 == NULL) // ROUTINE_NAMES
+	// 			throw GDLException( _t, "Undefined return value", true, false);
+			
+	// 		if( !ProgNode::interpreter->callStack.back()->Contains( e1)) 
+	// 			e1_guard.reset( e1);
+	//       }
+	//     else
+	//       {
+	// 			e1=tmp_expr(_t);
+	// 			e1_guard.reset( e1);
+	//       }
+	
+	// 	DPtrGDL* ptr=dynamic_cast<DPtrGDL*>(e1);
+	// 	if( ptr == NULL)
+	// 	throw GDLException( _t, "Pointer type required"
+	// 	" in this context: "+Name(e1),true,false);
+		DPtr sc; 
+		if( !ptr->Scalar(sc))
+		throw GDLException( _t, "Expression must be a "
+		"scalar in this context: "+Name(e1),true,false);
+		if( sc == 0)
+		throw GDLException( _t, "Unable to dereference"
+		" NULL pointer: "+Name(e1),true,false);
+		
+		try{
+	res = &GetHeap(sc);
+		}
+		catch( HeapException)
+		{
+	throw GDLException( _t, "Invalid pointer: "+Name(e1),true,false);
+		}
+		
+		_retTree = retTree;
+		return res;
+	
+	
+	
+	ProgNodeP __t45 = _t;
+	ProgNodeP tmp33_AST_in = _t;
+	match(antlr::RefAST(_t),DEREF);
+	_t = _t->getFirstChild();
+	e1=expr(_t);
+	_t = _retTree;
+	_t = __t45;
+	_t = _t->getNextSibling();
 	_retTree = _t;
 	return res;
 }
@@ -1606,8 +1872,8 @@
 	}
 	case QUESTION:
 	{
-		ProgNodeP __t43 = _t;
-		ProgNodeP tmp8_AST_in = _t;
+		ProgNodeP __t47 = _t;
+		ProgNodeP tmp34_AST_in = _t;
 		match(antlr::RefAST(_t),QUESTION);
 		_t = _t->getFirstChild();
 		e1=expr(_t);
@@ -1624,10 +1890,16 @@
 		res=l_ret_expr(_t);
 		}
 		
-		_t = __t43;
+		_t = __t47;
 		_t = _t->getNextSibling();
 		break;
 	}
+	case ARRAYEXPR_MFCALL:
+	{
+		res=l_arrayexpr_mfcall_as_mfcall(_t);
+		_t = _retTree;
+		break;
+	}
 	case FCALL:
 	case FCALL_LIB:
 	case MFCALL:
@@ -1670,8 +1942,8 @@
 	}
 	case ASSIGN:
 	{
-		ProgNodeP __t44 = _t;
-		ProgNodeP tmp9_AST_in = _t;
+		ProgNodeP __t48 = _t;
+		ProgNodeP tmp35_AST_in = _t;
 		match(antlr::RefAST(_t),ASSIGN);
 		_t = _t->getFirstChild();
 		
@@ -1683,8 +1955,10 @@
 		switch ( _t->getType()) {
 		case ASSIGN:
 		case ASSIGN_REPLACE:
+		case ASSIGN_ARRAYEXPR_MFCALL:
 		case ARRAYDEF:
 		case ARRAYEXPR:
+		case ARRAYEXPR_MFCALL:
 		case CONSTANT:
 		case DEREF:
 		case EXPR:
@@ -1714,7 +1988,7 @@
 		}
 		case FCALL_LIB:
 		{
-			e1=check_expr(_t);
+			e1=lib_function_call(_t);
 			_t = _retTree;
 			
 			if( !callStack.back()->Contains( e1)) 
@@ -1738,14 +2012,90 @@
 		}
 		r_guard.release();
 		
-		_t = __t44;
+		_t = __t48;
+		_t = _t->getNextSibling();
+		break;
+	}
+	case ASSIGN_ARRAYEXPR_MFCALL:
+	{
+		ProgNodeP __t50 = _t;
+		ProgNodeP tmp36_AST_in = _t;
+		match(antlr::RefAST(_t),ASSIGN_ARRAYEXPR_MFCALL);
+		_t = _t->getFirstChild();
+		
+		auto_ptr<BaseGDL> r_guard;
+		
+		{
+		if (_t == ProgNodeP(antlr::nullAST) )
+			_t = ASTNULL;
+		switch ( _t->getType()) {
+		case ASSIGN:
+		case ASSIGN_REPLACE:
+		case ASSIGN_ARRAYEXPR_MFCALL:
+		case ARRAYDEF:
+		case ARRAYEXPR:
+		case ARRAYEXPR_MFCALL:
+		case CONSTANT:
+		case DEREF:
+		case EXPR:
+		case FCALL:
+		case FCALL_LIB_RETNEW:
+		case MFCALL:
+		case MFCALL_PARENT:
+		case NSTRUC:
+		case NSTRUC_REF:
+		case POSTDEC:
+		case POSTINC:
+		case STRUC:
+		case SYSVAR:
+		case VAR:
+		case VARPTR:
+		case DEC:
+		case INC:
+		case DOT:
+		case QUESTION:
+		{
+			e1=tmp_expr(_t);
+			_t = _retTree;
+			
+			r_guard.reset( e1);
+			
+			break;
+		}
+		case FCALL_LIB:
+		{
+			e1=lib_function_call(_t);
+			_t = _retTree;
+			
+			if( !callStack.back()->Contains( e1)) 
+			r_guard.reset( e1);
+			
+			break;
+		}
+		default:
+		{
+			throw antlr::NoViableAltException(antlr::RefAST(_t));
+		}
+		}
+		}
+		res=l_arrayexpr_mfcall_as_mfcall(_t);
+		_t = _retTree;
+		
+		if( e1 != (*res))
+		{
+		delete *res;
+		*res = e1;
+		}
+		r_guard.release();
+		
+		_t = __t50;
 		_t = _t->getNextSibling();
 		break;
 	}
 	case ASSIGN_REPLACE:
 	{
-		ProgNodeP __t46 = _t;
-		ProgNodeP tmp10_AST_in = _t;
+		ProgNodeP __t52 = _t;
+		ProgNodeP tmp37_AST_in = _t;
 		match(antlr::RefAST(_t),ASSIGN_REPLACE);
 		_t = _t->getFirstChild();
 		
@@ -1757,8 +2107,10 @@
 		switch ( _t->getType()) {
 		case ASSIGN:
 		case ASSIGN_REPLACE:
+		case ASSIGN_ARRAYEXPR_MFCALL:
 		case ARRAYDEF:
 		case ARRAYEXPR:
+		case ARRAYEXPR_MFCALL:
 		case CONSTANT:
 		case DEREF:
 		case EXPR:
@@ -1788,7 +2140,7 @@
 		}
 		case FCALL_LIB:
 		{
-			e1=check_expr(_t);
+			e1=lib_function_call(_t);
 			_t = _retTree;
 			
 			if( !callStack.back()->Contains( e1)) 
@@ -1812,14 +2164,14 @@
 		}
 		r_guard.release();
 		
-		_t = __t46;
+		_t = __t52;
 		_t = _t->getNextSibling();
 		break;
 	}
 	case ARRAYEXPR:
 	{
-		ProgNodeP __t48 = _t;
-		ProgNodeP tmp11_AST_in = _t;
+		ProgNodeP __t54 = _t;
+		ProgNodeP tmp38_AST_in = _t;
 		match(antlr::RefAST(_t),ARRAYEXPR);
 		_t = _t->getFirstChild();
 		
@@ -1827,14 +2179,14 @@
 		"Indexed expression not allowed as left-function"
 		" return value.",true,false);
 		
-		_t = __t48;
+		_t = __t54;
 		_t = _t->getNextSibling();
 		break;
 	}
 	case DOT:
 	{
-		ProgNodeP __t49 = _t;
-		ProgNodeP tmp12_AST_in = _t;
+		ProgNodeP __t55 = _t;
+		ProgNodeP tmp39_AST_in = _t;
 		match(antlr::RefAST(_t),DOT);
 		_t = _t->getFirstChild();
 		
@@ -1842,13 +2194,13 @@
 		"Struct expression not allowed as left-function"
 		" return value.",true,false);
 		
-		_t = __t49;
+		_t = __t55;
 		_t = _t->getNextSibling();
 		break;
 	}
 	case SYSVAR:
 	{
-		ProgNodeP tmp13_AST_in = _t;
+		ProgNodeP tmp40_AST_in = _t;
 		match(antlr::RefAST(_t),SYSVAR);
 		_t = _t->getNextSibling();
 		
@@ -1895,45 +2247,49 @@
 	_retTree = _t;
 	return res;
 }
-
-BaseGDL**  GDLInterpreter::l_deref(ProgNodeP _t) {
-	BaseGDL** res;
-	ProgNodeP l_deref_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+
+ BaseGDL**  GDLInterpreter::l_arrayexpr_mfcall_as_mfcall(ProgNodeP _t) {
+	 BaseGDL** res;
+	ProgNodeP l_arrayexpr_mfcall_as_mfcall_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	ProgNodeP mp2 = ProgNodeP(antlr::nullAST);
 	
-	BaseGDL*       e1;
+	// better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+	StackGuard<EnvStackT> guard(callStack);
+	BaseGDL *self;
+	EnvUDT*   newEnv;
 	
 	
-	ProgNodeP __t41 = _t;
-	ProgNodeP tmp14_AST_in = _t;
-	match(antlr::RefAST(_t),DEREF);
+	ProgNodeP __t161 = _t;
+	ProgNodeP tmp41_AST_in = _t;
+	match(antlr::RefAST(_t),ARRAYEXPR_MFCALL);
 	_t = _t->getFirstChild();
-	e1=expr(_t);
+	
+	_t = _t->getNextSibling(); // skip DOT
+	
+	self=expr(_t);
 	_t = _retTree;
+	mp2 = _t;
+	match(antlr::RefAST(_t),IDENTIFIER);
+	_t = _t->getNextSibling();
 	
-	auto_ptr<BaseGDL> e1_guard(e1);
+	auto_ptr<BaseGDL> self_guard(self);
 	
-	DPtrGDL* ptr=dynamic_cast<DPtrGDL*>(e1);
-	if( ptr == NULL)
-	throw GDLException( _t, "Pointer type required"
-	" in this context: "+Name(e1),true,false);
-	DPtr sc; 
-	if( !ptr->Scalar(sc))
-	throw GDLException( _t, "Expression must be a "
-	"scalar in this context: "+Name(e1),true,false);
-	if( sc == 0)
-	throw GDLException( _t, "Unable to dereference"
-	" NULL pointer: "+Name(e1),true,false);
+	newEnv=new EnvUDT( self, mp2, "", true);
 	
-	try{
-	res = &GetHeap(sc);
-	}
-	catch( HeapException)
-	{
-	throw GDLException( _t, "Invalid pointer: "+Name(e1),true,false);
-	}
+	self_guard.release();
 	
-	_t = __t41;
+	parameter_def(_t, newEnv);
+	_t = _retTree;
+	_t = __t161;
 	_t = _t->getNextSibling();
+	
+	// push environment onto call stack
+	callStack.push_back(newEnv);
+	
+	// make the call
+	res=call_lfun(static_cast<DSubUD*>(
+	newEnv->GetPro())->GetTree());
+	
 	_retTree = _t;
 	return res;
 }
@@ -1959,7 +2315,7 @@
 	switch ( _t->getType()) {
 	case FCALL_LIB:
 	{
-		ProgNodeP __t137 = _t;
+		ProgNodeP __t163 = _t;
 		fl = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 		match(antlr::RefAST(_t),FCALL_LIB);
 		_t = _t->getFirstChild();
@@ -1981,7 +2337,7 @@
 		throw GDLException( _t, "Library function must return a "
 		"l-value in this context: "+fl->getText());
 		
-		_t = __t137;
+		_t = __t163;
 		_t = _t->getNextSibling();
 		break;
 	}
@@ -1996,8 +2352,8 @@
 		switch ( _t->getType()) {
 		case MFCALL:
 		{
-			ProgNodeP __t140 = _t;
-			ProgNodeP tmp15_AST_in = _t;
+			ProgNodeP __t166 = _t;
+			ProgNodeP tmp42_AST_in = _t;
 			match(antlr::RefAST(_t),MFCALL);
 			_t = _t->getFirstChild();
 			self=expr(_t);
@@ -2014,14 +2370,14 @@
 			
 			parameter_def(_t, newEnv);
 			_t = _retTree;
-			_t = __t140;
+			_t = __t166;
 			_t = _t->getNextSibling();
 			break;
 		}
 		case MFCALL_PARENT:
 		{
-			ProgNodeP __t141 = _t;
-			ProgNodeP tmp16_AST_in = _t;
+			ProgNodeP __t167 = _t;
+			ProgNodeP tmp43_AST_in = _t;
 			match(antlr::RefAST(_t),MFCALL_PARENT);
 			_t = _t->getFirstChild();
 			self=expr(_t);
@@ -2042,13 +2398,13 @@
 			
 			parameter_def(_t, newEnv);
 			_t = _retTree;
-			_t = __t141;
+			_t = __t167;
 			_t = _t->getNextSibling();
 			break;
 		}
 		case FCALL:
 		{
-			ProgNodeP __t142 = _t;
+			ProgNodeP __t168 = _t;
 			f = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 			match(antlr::RefAST(_t),FCALL);
 			_t = _t->getFirstChild();
@@ -2059,7 +2415,7 @@
 			
 			parameter_def(_t, newEnv);
 			_t = _retTree;
-			_t = __t142;
+			_t = __t168;
 			_t = _t->getNextSibling();
 			break;
 		}
@@ -2093,6 +2449,7 @@
 	BaseGDL* res;
 	ProgNodeP tmp_expr_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	ProgNodeP q = ProgNodeP(antlr::nullAST);
+	ProgNodeP a = ProgNodeP(antlr::nullAST);
 	
 	BaseGDL*  e1;
 	BaseGDL** e2;
@@ -2115,19 +2472,23 @@
 	}
 	case QUESTION:
 	{
-		ProgNodeP __t114 = _t;
+		ProgNodeP __t125 = _t;
 		q = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 		match(antlr::RefAST(_t),QUESTION);
 		_t = _t->getFirstChild();
 		res = q->Eval();
-		_t = __t114;
+		_t = __t125;
 		_t = _t->getNextSibling();
 		break;
 	}
 	case ARRAYEXPR:
 	{
-		res=array_expr(_t);
-		_t = _retTree;
+		{
+		a = _t;
+		match(antlr::RefAST(_t),ARRAYEXPR);
+		_t = _t->getNextSibling();
+		res = a->Eval();
+		}
 		break;
 	}
 	case DOT:
@@ -2138,11 +2499,13 @@
 	}
 	case ASSIGN:
 	case ASSIGN_REPLACE:
+	case ASSIGN_ARRAYEXPR_MFCALL:
 	{
 		res=assign_expr(_t);
 		_t = _retTree;
 		break;
 	}
+	case ARRAYEXPR_MFCALL:
 	case FCALL:
 	case MFCALL:
 	case MFCALL_PARENT:
@@ -2199,12 +2562,56 @@
 	return res;
 }
 
-BaseGDL*  GDLInterpreter::check_expr(ProgNodeP _t) {
-	BaseGDL* res;
-	ProgNodeP check_expr_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+ BaseGDL*  GDLInterpreter::lib_function_call(ProgNodeP _t) {
+	 BaseGDL* res;
+	ProgNodeP lib_function_call_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	ProgNodeP fll = ProgNodeP(antlr::nullAST);
+	
+	// better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+	StackGuard<EnvStackT> guard(callStack);
+		
+		ProgNodeP rTree = _t->getNextSibling();
+	// 	match(antlr::RefAST(_t),FCALL_LIB);
+	
+	// 	match(antlr::RefAST(_t),IDENTIFIER);
+	
+		ProgNodeP& fl = _t;
+		EnvT* newEnv=new EnvT( fl, fl->libFun);//libFunList[fl->funIx]);
+		
+	parameter_def(_t->getFirstChild(), newEnv);
+	
+		// push id.pro onto call stack
+		callStack.push_back(newEnv);
+		// make the call
+		//BaseGDL* 
+	res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
+		// *** MUST always return a defined expression
+	//    if( res == NULL)
+	//       throw GDLException( _t, "");
+	
+		_retTree = rTree;
+		return res;
+	
+	
+	ProgNodeP __t141 = _t;
+	fll = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	match(antlr::RefAST(_t),FCALL_LIB);
+	_t = _t->getFirstChild();
+	
+	//EnvT* 
+	newEnv=new EnvT( fll, fll->libFun);//libFunList[fl->funIx]);
 	
-	res=lib_function_call(_t);
+	parameter_def(_t, newEnv);
 	_t = _retTree;
+	
+	// push id.pro onto call stack
+	callStack.push_back(newEnv);
+	// make the call
+	res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
+	//*** MUST always return a defined expression
+	
+	_t = __t141;
+	_t = _t->getNextSibling();
 	_retTree = _t;
 	return res;
 }
@@ -2212,100 +2619,130 @@
 BaseGDL*  GDLInterpreter::r_expr(ProgNodeP _t) {
 	BaseGDL* res;
 	ProgNodeP r_expr_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	ProgNodeP e = ProgNodeP(antlr::nullAST);
-	ProgNodeP a = ProgNodeP(antlr::nullAST);
-	ProgNodeP s = ProgNodeP(antlr::nullAST);
-	ProgNodeP n = ProgNodeP(antlr::nullAST);
-	ProgNodeP r = ProgNodeP(antlr::nullAST);
+	
+		switch ( _t->getType()) {
+		case EXPR:
+		case ARRAYDEF:
+		case STRUC:
+		case NSTRUC:
+		case NSTRUC_REF:
+		{
+			res = _t->Eval(); 
+			break;
+		}
+		case DEC:
+		{
+			res=l_decinc_expr( _t->getFirstChild(), DEC);
+			break;
+		}
+		case INC:
+		{
+			res=l_decinc_expr( _t->getFirstChild(), INC);
+			break;
+		}
+		case POSTDEC:
+		{
+			res=l_decinc_expr( _t->getFirstChild(), POSTDEC);
+			break;
+		}
+	//	case POSTINC:
+		default:
+		{
+			res=l_decinc_expr( _t->getFirstChild(), POSTINC);
+			break;
+		}
+	// 	default:
+	// 	{
+	// 		throw antlr::NoViableAltException(antlr::RefAST(_t));
+	// 	}
+		}
+		_retTree = _t->getNextSibling();
+		return res;
+	
 	
 	if (_t == ProgNodeP(antlr::nullAST) )
 		_t = ASTNULL;
 	switch ( _t->getType()) {
 	case EXPR:
 	{
-		e = _t;
+		ProgNodeP tmp44_AST_in = _t;
 		match(antlr::RefAST(_t),EXPR);
 		_t = _t->getNextSibling();
-		res = e->Eval();
 		break;
 	}
 	case ARRAYDEF:
 	{
-		a = _t;
+		ProgNodeP tmp45_AST_in = _t;
 		match(antlr::RefAST(_t),ARRAYDEF);
 		_t = _t->getNextSibling();
-		res = a->Eval(); _t=_retTree;
 		break;
 	}
 	case STRUC:
 	{
-		s = _t;
+		ProgNodeP tmp46_AST_in = _t;
 		match(antlr::RefAST(_t),STRUC);
 		_t = _t->getNextSibling();
-		res = s->Eval(); _t=_retTree;
 		break;
 	}
 	case NSTRUC:
 	{
-		n = _t;
+		ProgNodeP tmp47_AST_in = _t;
 		match(antlr::RefAST(_t),NSTRUC);
 		_t = _t->getNextSibling();
-		res = n->Eval(); _t=_retTree;
 		break;
 	}
 	case NSTRUC_REF:
 	{
-		r = _t;
+		ProgNodeP tmp48_AST_in = _t;
 		match(antlr::RefAST(_t),NSTRUC_REF);
 		_t = _t->getNextSibling();
-		res = r->Eval(); _t=_retTree;
 		break;
 	}
 	case DEC:
 	{
-		ProgNodeP __t85 = _t;
-		ProgNodeP tmp17_AST_in = _t;
+		ProgNodeP __t96 = _t;
+		ProgNodeP tmp49_AST_in = _t;
 		match(antlr::RefAST(_t),DEC);
 		_t = _t->getFirstChild();
 		res=l_decinc_expr(_t, DEC);
 		_t = _retTree;
-		_t = __t85;
+		_t = __t96;
 		_t = _t->getNextSibling();
 		break;
 	}
 	case INC:
 	{
-		ProgNodeP __t86 = _t;
-		ProgNodeP tmp18_AST_in = _t;
+		ProgNodeP __t97 = _t;
+		ProgNodeP tmp50_AST_in = _t;
 		match(antlr::RefAST(_t),INC);
 		_t = _t->getFirstChild();
 		res=l_decinc_expr(_t, INC);
 		_t = _retTree;
-		_t = __t86;
+		_t = __t97;
 		_t = _t->getNextSibling();
 		break;
 	}
 	case POSTDEC:
 	{
-		ProgNodeP __t87 = _t;
-		ProgNodeP tmp19_AST_in = _t;
+		ProgNodeP __t98 = _t;
+		ProgNodeP tmp51_AST_in = _t;
 		match(antlr::RefAST(_t),POSTDEC);
 		_t = _t->getFirstChild();
 		res=l_decinc_expr(_t, POSTDEC);
 		_t = _retTree;
-		_t = __t87;
+		_t = __t98;
 		_t = _t->getNextSibling();
 		break;
 	}
 	case POSTINC:
 	{
-		ProgNodeP __t88 = _t;
-		ProgNodeP tmp20_AST_in = _t;
+		ProgNodeP __t99 = _t;
+		ProgNodeP tmp52_AST_in = _t;
 		match(antlr::RefAST(_t),POSTINC);
 		_t = _t->getFirstChild();
 		res=l_decinc_expr(_t, POSTINC);
 		_t = _retTree;
-		_t = __t88;
+		_t = __t99;
 		_t = _t->getNextSibling();
 		break;
 	}
@@ -2323,12 +2760,9 @@
 	ProgNodeP constant_nocopy_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	ProgNodeP c = ProgNodeP(antlr::nullAST);
 	
-	
 		//BaseGDL* 
-	res = _t->cData; // no ->Dup(); 
-			
 		_retTree = _t->getNextSibling();
-		return res;
+		return _t->cData; // no ->Dup(); 
 	
 	
 	c = _t;
@@ -2405,34 +2839,26 @@
 BaseGDL**  GDLInterpreter::l_defined_simple_var(ProgNodeP _t) {
 	BaseGDL** res;
 	ProgNodeP l_defined_simple_var_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	ProgNodeP var = ProgNodeP(antlr::nullAST);
-	ProgNodeP varPtr = ProgNodeP(antlr::nullAST);
 	
 		if( _t->getType() == VAR)
 		{
-			var = _t;
 	// 		match(antlr::RefAST(_t),VAR);
-			_t = _t->getNextSibling();
-			
-			res=&callStack.back()->GetKW(var->varIx); 
+			res=&callStack.back()->GetKW(_t->varIx); 
 			if( *res == NULL)
-			throw GDLException( var, "Variable is undefined: "+
-			callStack.back()->GetString(var->varIx),true,false);
+			throw GDLException( _t, "Variable is undefined: "+
+			callStack.back()->GetString(_t->varIx),true,false);
 			
 		}
 		else
 		{
-			varPtr = _t;
 	// 		match(antlr::RefAST(_t),VARPTR);
-			_t = _t->getNextSibling();
-			
-			res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
+			res=&_t->var->Data(); // returns BaseGDL* of var (DVar*) 
 			if( *res == NULL)
 			throw GDLException( _t, "Variable is undefined: "+
 			callStack.back()->GetString( *res),true,false);
 			
 		}
-		_retTree = _t;
+		_retTree = _t->getNextSibling();
 		return res;
 	
 	
@@ -2441,28 +2867,16 @@
 	switch ( _t->getType()) {
 	case VAR:
 	{
-		var = _t;
+		ProgNodeP tmp53_AST_in = _t;
 		match(antlr::RefAST(_t),VAR);
 		_t = _t->getNextSibling();
-		
-		res=&callStack.back()->GetKW(var->varIx); 
-		if( *res == NULL)
-		throw GDLException( _t, "Variable is undefined: "+
-		callStack.back()->GetString(var->varIx),true,false);
-		
 		break;
 	}
 	case VARPTR:
 	{
-		varPtr = _t;
+		ProgNodeP tmp54_AST_in = _t;
 		match(antlr::RefAST(_t),VARPTR);
 		_t = _t->getNextSibling();
-		
-		res=&varPtr->var->Data(); // returns BaseGDL* of var (DVar*) 
-		if( *res == NULL)
-		throw GDLException( _t, "Variable is undefined: "+
-		callStack.back()->GetString( *res),true,false);
-		
 		break;
 	}
 	default:
@@ -2523,15 +2937,15 @@
 	switch ( _t->getType()) {
 	case ARRAYEXPR:
 	{
-		ProgNodeP __t52 = _t;
-		ProgNodeP tmp21_AST_in = _t;
+		ProgNodeP __t58 = _t;
+		ProgNodeP tmp55_AST_in = _t;
 		match(antlr::RefAST(_t),ARRAYEXPR);
 		_t = _t->getFirstChild();
 		e=l_decinc_indexable_expr(_t, dec_inc);
 		_t = _retTree;
 		aL=arrayindex_list(_t);
 		_t = _retTree;
-		_t = __t52;
+		_t = __t58;
 		_t = _t->getNextSibling();
 		
 		guard.reset( aL); 
@@ -2641,13 +3055,13 @@
 				case VARPTR:
 				{
 					s=indexable_expr(_t);
-					_t = _retTree;
+	//				_t = _retTree;
 					break;
 				}
 				case FCALL_LIB:
 				{
-					s=check_expr(_t);
-					_t = _retTree;
+					s=lib_function_call(_t);
+	//				_t = _retTree;
 					
 					if( !callStack.back()->Contains( s)) 
 					exprList.push_back( s);
@@ -2657,7 +3071,7 @@
 				default:
 				{
 					s=indexable_tmp_expr(_t);
-					_t = _retTree;
+	//				_t = _retTree;
 					exprList.push_back( s);
 					break;
 				}
@@ -2667,6 +3081,8 @@
 				ixExprList.push_back( s);
 				if( ixExprList.size() == nExpr)
 	break; // allows some manual tuning
+	
+	_t = _t->getNextSibling();
 		}
 	
 		aL->Init( ixExprList);
@@ -2675,7 +3091,7 @@
 		return aL;
 	
 	
-	ProgNodeP __t149 = _t;
+	ProgNodeP __t176 = _t;
 	ax = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	match(antlr::RefAST(_t),ARRAYIX);
 	_t = _t->getFirstChild();
@@ -2700,7 +3116,7 @@
 			}
 			case FCALL_LIB:
 			{
-				s=check_expr(_t);
+				s=lib_function_call(_t);
 				_t = _retTree;
 				
 				if( !callStack.back()->Contains( s)) 
@@ -2710,8 +3126,10 @@
 			}
 			case ASSIGN:
 			case ASSIGN_REPLACE:
+			case ASSIGN_ARRAYEXPR_MFCALL:
 			case ARRAYDEF:
 			case ARRAYEXPR:
+			case ARRAYEXPR_MFCALL:
 			case EXPR:
 			case FCALL:
 			case FCALL_LIB_RETNEW:
@@ -2740,13 +3158,13 @@
 			}
 		}
 		else {
-			goto _loop152;
+			goto _loop179;
 		}
 		
 	}
-	_loop152:;
+	_loop179:;
 	} // ( ... )*
-	_t = __t149;
+	_t = __t176;
 	_t = _t->getNextSibling();
 	_retTree = _t;
 	return aL;
@@ -2759,7 +3177,7 @@
 	ProgNodeP l_decinc_dot_expr_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	ProgNodeP dot = ProgNodeP(antlr::nullAST);
 	
-	ProgNodeP __t54 = _t;
+	ProgNodeP __t60 = _t;
 	dot = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	match(antlr::RefAST(_t),DOT);
 	_t = _t->getFirstChild();
@@ -2770,7 +3188,7 @@
 	l_dot_array_expr(_t, aD.get());
 	_t = _retTree;
 	{ // ( ... )+
-	int _cnt56=0;
+	int _cnt62=0;
 	for (;;) {
 		if (_t == ProgNodeP(antlr::nullAST) )
 			_t = ASTNULL;
@@ -2779,14 +3197,14 @@
 			_t = _retTree;
 		}
 		else {
-			if ( _cnt56>=1 ) { goto _loop56; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+			if ( _cnt62>=1 ) { goto _loop62; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 		}
 		
-		_cnt56++;
+		_cnt62++;
 	}
-	_loop56:;
+	_loop62:;
 	}  // ( ... )+
-	_t = __t54;
+	_t = __t60;
 	_t = _t->getNextSibling();
 	
 	if( dec_inc == DECSTATEMENT) 
@@ -2831,8 +3249,8 @@
 	switch ( _t->getType()) {
 	case ARRAYEXPR:
 	{
-		ProgNodeP __t69 = _t;
-		ProgNodeP tmp22_AST_in = _t;
+		ProgNodeP __t78 = _t;
+		ProgNodeP tmp56_AST_in = _t;
 		match(antlr::RefAST(_t),ARRAYEXPR);
 		_t = _t->getFirstChild();
 		rP=l_indexable_expr(_t);
@@ -2840,7 +3258,7 @@
 		aL=arrayindex_list(_t);
 		_t = _retTree;
 		guard.reset(aL);
-		_t = __t69;
+		_t = __t78;
 		_t = _t->getNextSibling();
 		
 		// check here for object and get struct
@@ -2871,6 +3289,7 @@
 		
 		break;
 	}
+	case ARRAYEXPR_MFCALL:
 	case DEREF:
 	case EXPR:
 	case FCALL:
@@ -2935,8 +3354,8 @@
 	switch ( _t->getType()) {
 	case ARRAYEXPR:
 	{
-		ProgNodeP __t99 = _t;
-		ProgNodeP tmp23_AST_in = _t;
+		ProgNodeP __t110 = _t;
+		ProgNodeP tmp57_AST_in = _t;
 		match(antlr::RefAST(_t),ARRAYEXPR);
 		_t = _t->getFirstChild();
 		tag_expr(_t, aD);
@@ -2944,7 +3363,7 @@
 		aL=arrayindex_list(_t);
 		_t = _retTree;
 		aD->AddIx(aL);
-		_t = __t99;
+		_t = __t110;
 		_t = _t->getNextSibling();
 		break;
 	}
@@ -2969,8 +3388,10 @@
 ) {
 	BaseGDL* res;
 	ProgNodeP l_decinc_expr_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	ProgNodeP mp2 = ProgNodeP(antlr::nullAST);
 	
 	BaseGDL*       e1;
+	ProgNodeP startNode = _t;
 	
 	
 	if (_t == ProgNodeP(antlr::nullAST) )
@@ -2978,8 +3399,8 @@
 	switch ( _t->getType()) {
 	case QUESTION:
 	{
-		ProgNodeP __t58 = _t;
-		ProgNodeP tmp24_AST_in = _t;
+		ProgNodeP __t64 = _t;
+		ProgNodeP tmp58_AST_in = _t;
 		match(antlr::RefAST(_t),QUESTION);
 		_t = _t->getFirstChild();
 		e1=expr(_t);
@@ -2997,14 +3418,14 @@
 		res=l_decinc_expr(_t, dec_inc);
 		}
 		
-		_t = __t58;
+		_t = __t64;
 		_t = _t->getNextSibling();
 		break;
 	}
 	case ASSIGN:
 	{
-		ProgNodeP __t59 = _t;
-		ProgNodeP tmp25_AST_in = _t;
+		ProgNodeP __t65 = _t;
+		ProgNodeP tmp59_AST_in = _t;
 		match(antlr::RefAST(_t),ASSIGN);
 		_t = _t->getFirstChild();
 		
@@ -3026,8 +3447,91 @@
 		}
 		case ASSIGN:
 		case ASSIGN_REPLACE:
+		case ASSIGN_ARRAYEXPR_MFCALL:
+		case ARRAYDEF:
+		case ARRAYEXPR:
+		case ARRAYEXPR_MFCALL:
+		case EXPR:
+		case FCALL:
+		case FCALL_LIB_RETNEW:
+		case MFCALL:
+		case MFCALL_PARENT:
+		case NSTRUC:
+		case NSTRUC_REF:
+		case POSTDEC:
+		case POSTINC:
+		case STRUC:
+		case DEC:
+		case INC:
+		case DOT:
+		case QUESTION:
+		{
+			e1=indexable_tmp_expr(_t);
+			_t = _retTree;
+			r_guard.reset( e1);
+			break;
+		}
+		case FCALL_LIB:
+		{
+			e1=lib_function_call(_t);
+			_t = _retTree;
+			
+			if( !callStack.back()->Contains( e1)) 
+			r_guard.reset( e1); // guard if no global data
+			
+			break;
+		}
+		default:
+		{
+			throw antlr::NoViableAltException(antlr::RefAST(_t));
+		}
+		}
+		}
+		
+		ProgNodeP l = _t;
+		
+		BaseGDL** tmp;
+		
+		tmp=l_expr(_t, e1);
+		_t = _retTree;
+		
+		_t = l;
+		
+		res=l_decinc_expr(_t, dec_inc);
+		_t = _retTree;
+		_t = __t65;
+		_t = _t->getNextSibling();
+		break;
+	}
+	case ASSIGN_ARRAYEXPR_MFCALL:
+	{
+		ProgNodeP __t67 = _t;
+		ProgNodeP tmp60_AST_in = _t;
+		match(antlr::RefAST(_t),ASSIGN_ARRAYEXPR_MFCALL);
+		_t = _t->getFirstChild();
+		
+		auto_ptr<BaseGDL> r_guard;
+		
+		{
+		if (_t == ProgNodeP(antlr::nullAST) )
+			_t = ASTNULL;
+		switch ( _t->getType()) {
+		case CONSTANT:
+		case DEREF:
+		case SYSVAR:
+		case VAR:
+		case VARPTR:
+		{
+			e1=indexable_expr(_t);
+			_t = _retTree;
+			break;
+		}
+		case ASSIGN:
+		case ASSIGN_REPLACE:
+		case ASSIGN_ARRAYEXPR_MFCALL:
 		case ARRAYDEF:
 		case ARRAYEXPR:
+		case ARRAYEXPR_MFCALL:
 		case EXPR:
 		case FCALL:
 		case FCALL_LIB_RETNEW:
@@ -3050,7 +3554,7 @@
 		}
 		case FCALL_LIB:
 		{
-			e1=check_expr(_t);
+			e1=lib_function_call(_t);
 			_t = _retTree;
 			
 			if( !callStack.back()->Contains( e1)) 
@@ -3065,25 +3569,51 @@
 		}
 		}
 		
-		ProgNodeP l = _t;
-		
-		BaseGDL** tmp;
-		
-		tmp=l_expr(_t, e1);
-		_t = _retTree;
-		
-		_t = l;
+		ProgNodeP l = _t;
+		
+		BaseGDL** tmp;
+		
+		// try MFCALL
+		try
+		{
+		
+		tmp=l_arrayexpr_mfcall_as_mfcall(l);
+		
+		if( e1 != (*tmp))
+		{
+		delete *tmp;
+		
+		if( r_guard.get() == e1)
+		*tmp = r_guard.release();
+		else          
+		*tmp = e1->Dup();
+		}
+		
+		res=l_decinc_expr( l, dec_inc);
+		}
+		catch( GDLException& ex)
+		{
+		// try ARRAYEXPR
+		try
+			                {
+		tmp=l_arrayexpr_mfcall_as_arrayexpr(l, e1);
+			                }
+		catch( GDLException& ex2)
+		{
+		throw GDLException(ex.toString() + " or "+ex2.toString());
+		}
+		
+		res=l_decinc_expr( l, dec_inc);
+		}
 		
-		res=l_decinc_expr(_t, dec_inc);
-		_t = _retTree;
-		_t = __t59;
+		_t = __t67;
 		_t = _t->getNextSibling();
 		break;
 	}
 	case ASSIGN_REPLACE:
 	{
-		ProgNodeP __t61 = _t;
-		ProgNodeP tmp26_AST_in = _t;
+		ProgNodeP __t69 = _t;
+		ProgNodeP tmp61_AST_in = _t;
 		match(antlr::RefAST(_t),ASSIGN_REPLACE);
 		_t = _t->getFirstChild();
 		
@@ -3095,8 +3625,10 @@
 		switch ( _t->getType()) {
 		case ASSIGN:
 		case ASSIGN_REPLACE:
+		case ASSIGN_ARRAYEXPR_MFCALL:
 		case ARRAYDEF:
 		case ARRAYEXPR:
+		case ARRAYEXPR_MFCALL:
 		case CONSTANT:
 		case DEREF:
 		case EXPR:
@@ -3126,7 +3658,7 @@
 		}
 		case FCALL_LIB:
 		{
-			e1=check_expr(_t);
+			e1=lib_function_call(_t);
 			_t = _retTree;
 			
 			if( !callStack.back()->Contains( e1)) 
@@ -3193,7 +3725,7 @@
 		
 		res=l_decinc_expr(_t, dec_inc);
 		_t = _retTree;
-		_t = __t61;
+		_t = __t69;
 		_t = _t->getNextSibling();
 		break;
 	}
@@ -3211,6 +3743,86 @@
 		_t = _retTree;
 		break;
 	}
+	case ARRAYEXPR_MFCALL:
+	{
+		ProgNodeP __t72 = _t;
+		ProgNodeP tmp62_AST_in = _t;
+		match(antlr::RefAST(_t),ARRAYEXPR_MFCALL);
+		_t = _t->getFirstChild();
+		
+		ProgNodeP mark = _t;
+		_t = _t->getNextSibling(); // step over DOT
+		
+		BaseGDL* self;
+		
+		self=expr(_t);
+		_t = _retTree;
+		mp2 = _t;
+		match(antlr::RefAST(_t),IDENTIFIER);
+		_t = _t->getNextSibling();
+		
+		auto_ptr<BaseGDL> self_guard(self);
+		
+		EnvUDT* newEnv;
+		
+		try {
+		newEnv=new EnvUDT( self, mp2, "", true);
+		self_guard.release();
+		}
+		catch( GDLException& ex)
+		{
+		_t = mark;
+		
+		res=l_decinc_dot_expr(_t, dec_inc);
+		
+		_retTree = startNode->getNextSibling();
+		return res;
+		}   
+		
+		parameter_def(_t, newEnv);
+		_t = _retTree;
+		
+		// push environment onto call stack
+		callStack.push_back(newEnv);
+		
+		// make the call
+		BaseGDL** ee=call_lfun(static_cast<DSubUD*>(
+		newEnv->GetPro())->GetTree());
+		
+		BaseGDL* e = *ee;
+		if( e == NULL)
+		throw GDLException( _t, "Variable is undefined: "+Name(ee),true,false);
+		
+		if( dec_inc == DECSTATEMENT) 
+		{
+		e->Dec(); 
+		res = NULL;
+		_retTree = startNode->getNextSibling();
+		return res;
+		}
+		if( dec_inc == INCSTATEMENT)
+		{
+		e->Inc();
+		res = NULL;
+		_retTree = startNode->getNextSibling();
+		return res;
+		}
+		
+		if( dec_inc == DEC) e->Dec();
+		else if( dec_inc == INC) e->Inc();
+		//          
+		res = e->Dup();
+		
+		if( dec_inc == POSTDEC) e->Dec();
+		else if( dec_inc == POSTINC) e->Inc();
+		
+		_retTree = startNode->getNextSibling();
+		return res;
+		
+		_t = __t72;
+		_t = _t->getNextSibling();
+		break;
+	}
 	case DOT:
 	{
 		res=l_decinc_dot_expr(_t, dec_inc);
@@ -3259,6 +3871,9 @@
 	BaseGDL* res;
 	ProgNodeP indexable_expr_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	
+		_retTree = _t->getNextSibling();
+	return _t->EvalNC();
+	
 	BaseGDL** e2;
 	
 	
@@ -3311,6 +3926,7 @@
 	BaseGDL* res;
 	ProgNodeP indexable_tmp_expr_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	ProgNodeP q = ProgNodeP(antlr::nullAST);
+	ProgNodeP a = ProgNodeP(antlr::nullAST);
 	
 	BaseGDL*  e1;
 	
@@ -3320,19 +3936,23 @@
 	switch ( _t->getType()) {
 	case QUESTION:
 	{
-		ProgNodeP __t109 = _t;
+		ProgNodeP __t120 = _t;
 		q = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 		match(antlr::RefAST(_t),QUESTION);
 		_t = _t->getFirstChild();
 		res = q->Eval();
-		_t = __t109;
+		_t = __t120;
 		_t = _t->getNextSibling();
 		break;
 	}
 	case ARRAYEXPR:
 	{
-		res=array_expr(_t);
-		_t = _retTree;
+		{
+		a = _t;
+		match(antlr::RefAST(_t),ARRAYEXPR);
+		_t = _t->getNextSibling();
+		res = a->Eval();
+		}
 		break;
 	}
 	case DOT:
@@ -3343,11 +3963,13 @@
 	}
 	case ASSIGN:
 	case ASSIGN_REPLACE:
+	case ASSIGN_ARRAYEXPR_MFCALL:
 	{
 		res=assign_expr(_t);
 		_t = _retTree;
 		break;
 	}
+	case ARRAYEXPR_MFCALL:
 	case FCALL:
 	case MFCALL:
 	case MFCALL_PARENT:
@@ -3400,8 +4022,8 @@
 	switch ( _t->getType()) {
 	case QUESTION:
 	{
-		ProgNodeP __t71 = _t;
-		ProgNodeP tmp27_AST_in = _t;
+		ProgNodeP __t80 = _t;
+		ProgNodeP tmp63_AST_in = _t;
 		match(antlr::RefAST(_t),QUESTION);
 		_t = _t->getFirstChild();
 		e1=expr(_t);
@@ -3419,14 +4041,14 @@
 		res=l_expr(_t, right);
 		}
 		
-		_t = __t71;
+		_t = __t80;
 		_t = _t->getNextSibling();
 		break;
 	}
 	case ASSIGN:
 	{
-		ProgNodeP __t72 = _t;
-		ProgNodeP tmp28_AST_in = _t;
+		ProgNodeP __t81 = _t;
+		ProgNodeP tmp64_AST_in = _t;
 		match(antlr::RefAST(_t),ASSIGN);
 		_t = _t->getFirstChild();
 		{
@@ -3445,8 +4067,10 @@
 		}
 		case ASSIGN:
 		case ASSIGN_REPLACE:
+		case ASSIGN_ARRAYEXPR_MFCALL:
 		case ARRAYDEF:
 		case ARRAYEXPR:
+		case ARRAYEXPR_MFCALL:
 		case EXPR:
 		case FCALL:
 		case FCALL_LIB_RETNEW:
@@ -3469,7 +4093,7 @@
 		}
 		case FCALL_LIB:
 		{
-			e1=check_expr(_t);
+			e1=lib_function_call(_t);
 			_t = _retTree;
 			
 			if( !callStack.back()->Contains( e1)) 
@@ -3486,14 +4110,108 @@
 		}
 		res=l_expr(_t, right);
 		_t = _retTree;
-		_t = __t72;
+		_t = __t81;
+		_t = _t->getNextSibling();
+		break;
+	}
+	case ASSIGN_ARRAYEXPR_MFCALL:
+	{
+		ProgNodeP __t83 = _t;
+		ProgNodeP tmp65_AST_in = _t;
+		match(antlr::RefAST(_t),ASSIGN_ARRAYEXPR_MFCALL);
+		_t = _t->getFirstChild();
+		{
+		if (_t == ProgNodeP(antlr::nullAST) )
+			_t = ASTNULL;
+		switch ( _t->getType()) {
+		case CONSTANT:
+		case DEREF:
+		case SYSVAR:
+		case VAR:
+		case VARPTR:
+		{
+			e1=indexable_expr(_t);
+			_t = _retTree;
+			break;
+		}
+		case ASSIGN:
+		case ASSIGN_REPLACE:
+		case ASSIGN_ARRAYEXPR_MFCALL:
+		case ARRAYDEF:
+		case ARRAYEXPR:
+		case ARRAYEXPR_MFCALL:
+		case EXPR:
+		case FCALL:
+		case FCALL_LIB_RETNEW:
+		case MFCALL:
+		case MFCALL_PARENT:
+		case NSTRUC:
+		case NSTRUC_REF:
+		case POSTDEC:
+		case POSTINC:
+		case STRUC:
+		case DEC:
+		case INC:
+		case DOT:
+		case QUESTION:
+		{
+			e1=indexable_tmp_expr(_t);
+			_t = _retTree;
+			delete e1;
+			break;
+		}
+		case FCALL_LIB:
+		{
+			e1=lib_function_call(_t);
+			_t = _retTree;
+			
+			if( !callStack.back()->Contains( e1)) 
+			delete e1; 
+			
+			break;
+		}
+		default:
+		{
+			throw antlr::NoViableAltException(antlr::RefAST(_t));
+		}
+		}
+		}
+		
+		ProgNodeP l = _t;
+		
+		// try MFCALL
+		try
+		{
+		
+		res=l_arrayexpr_mfcall_as_mfcall( l);
+		
+		if( right != (*res))
+		{
+		delete *res;
+		*res = right->Dup();
+		}
+		}
+		catch( GDLException& ex)
+		{
+		// try ARRAYEXPR
+		try
+			                {
+		res=l_arrayexpr_mfcall_as_arrayexpr(l, right);
+			                }
+		catch( GDLException& ex2)
+		{
+		throw GDLException(ex.toString() + " or "+ex2.toString());
+		}
+		}
+		
+		_t = __t83;
 		_t = _t->getNextSibling();
 		break;
 	}
 	case ASSIGN_REPLACE:
 	{
-		ProgNodeP __t74 = _t;
-		ProgNodeP tmp29_AST_in = _t;
+		ProgNodeP __t85 = _t;
+		ProgNodeP tmp66_AST_in = _t;
 		match(antlr::RefAST(_t),ASSIGN_REPLACE);
 		_t = _t->getFirstChild();
 		{
@@ -3502,8 +4220,10 @@
 		switch ( _t->getType()) {
 		case ASSIGN:
 		case ASSIGN_REPLACE:
+		case ASSIGN_ARRAYEXPR_MFCALL:
 		case ARRAYDEF:
 		case ARRAYEXPR:
+		case ARRAYEXPR_MFCALL:
 		case CONSTANT:
 		case DEREF:
 		case EXPR:
@@ -3534,7 +4254,7 @@
 		}
 		case FCALL_LIB:
 		{
-			e1=check_expr(_t);
+			e1=lib_function_call(_t);
 			_t = _retTree;
 			
 			if( !callStack.back()->Contains( e1)) 
@@ -3593,7 +4313,7 @@
 		*res = right->Dup();
 		}
 		
-		_t = __t74;
+		_t = __t85;
 		_t = _t->getNextSibling();
 		break;
 	}
@@ -3683,9 +4403,15 @@
 		
 		break;
 	}
+	case ARRAYEXPR_MFCALL:
+	{
+		res=l_arrayexpr_mfcall(_t, right);
+		_t = _retTree;
+		break;
+	}
 	case DOT:
 	{
-		ProgNodeP __t78 = _t;
+		ProgNodeP __t89 = _t;
 		dot = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 		match(antlr::RefAST(_t),DOT);
 		_t = _t->getFirstChild();
@@ -3696,7 +4422,7 @@
 		l_dot_array_expr(_t, aD.get());
 		_t = _retTree;
 		{ // ( ... )+
-		int _cnt80=0;
+		int _cnt91=0;
 		for (;;) {
 			if (_t == ProgNodeP(antlr::nullAST) )
 				_t = ASTNULL;
@@ -3705,14 +4431,14 @@
 				_t = _retTree;
 			}
 			else {
-				if ( _cnt80>=1 ) { goto _loop80; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+				if ( _cnt91>=1 ) { goto _loop91; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 			}
 			
-			_cnt80++;
+			_cnt91++;
 		}
-		_loop80:;
+		_loop91:;
 		}  // ( ... )+
-		_t = __t78;
+		_t = __t89;
 		_t = _t->getNextSibling();
 		
 		if( right == NULL)
@@ -3762,6 +4488,100 @@
 	return res;
 }
 
+BaseGDL**  GDLInterpreter::l_simple_var(ProgNodeP _t) {
+	BaseGDL** res;
+	ProgNodeP l_simple_var_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	
+		assert( _t != NULL);
+	
+		_retTree = _t->getNextSibling();
+	
+		if( _t->getType() == VAR)
+		{
+			return &callStack.back()->GetKW(_t->varIx); 
+	//		ProgNodeP var = _t;
+	// 		match(antlr::RefAST(_t),VAR);
+		}
+		else
+		{
+			return &_t->var->Data(); // returns BaseGDL* of var (DVar*) 
+	//		ProgNodeP varPtr = _t;
+	// 		match(antlr::RefAST(_t),VARPTR);
+		}
+		return res;
+	
+	
+	if (_t == ProgNodeP(antlr::nullAST) )
+		_t = ASTNULL;
+	switch ( _t->getType()) {
+	case VAR:
+	{
+		ProgNodeP tmp67_AST_in = _t;
+		match(antlr::RefAST(_t),VAR);
+		_t = _t->getNextSibling();
+		break;
+	}
+	case VARPTR:
+	{
+		ProgNodeP tmp68_AST_in = _t;
+		match(antlr::RefAST(_t),VARPTR);
+		_t = _t->getNextSibling();
+		break;
+	}
+	default:
+	{
+		throw antlr::NoViableAltException(antlr::RefAST(_t));
+	}
+	}
+	_retTree = _t;
+	return res;
+}
+
+void GDLInterpreter::parameter_def(ProgNodeP _t,
+	EnvBaseT* actEnv
+) {
+	ProgNodeP parameter_def_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	
+	auto_ptr<EnvBaseT> guard(actEnv); 
+	try{
+	
+	_retTree = _t;
+	while(_retTree != NULL) {
+	static_cast<ParameterNode*>(_retTree)->Parameter( actEnv);
+	}    
+	
+	actEnv->Extra(); // expand _EXTRA
+	
+	} 
+	catch( GDLException& e)
+	{
+	// update line number, currently set to caller->CallingNode()
+	// because actEnv is not on the stack yet, 
+	// report caller->Pro()'s name is ok, because we are not inside
+	// the call yet
+	e.SetErrorNodeP( actEnv->CallingNode());
+	throw e;
+	}
+	
+		guard.release();
+		
+	return;
+	
+	
+	{
+	ProgNodeP __t174 = _t;
+	ProgNodeP tmp69_AST_in = _t;
+	match(antlr::RefAST(_t),KEYDEF_REF);
+	_t = _t->getFirstChild();
+	ProgNodeP tmp70_AST_in = _t;
+	match(antlr::RefAST(_t),IDENTIFIER);
+	_t = _t->getNextSibling();
+	_t = __t174;
+	_t = _t->getNextSibling();
+	}
+	_retTree = _t;
+}
+
 BaseGDL**  GDLInterpreter::l_indexable_expr(ProgNodeP _t) {
 	BaseGDL** res;
 	ProgNodeP l_indexable_expr_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
@@ -3771,13 +4591,13 @@
 	switch ( _t->getType()) {
 	case EXPR:
 	{
-		ProgNodeP __t65 = _t;
-		ProgNodeP tmp30_AST_in = _t;
+		ProgNodeP __t74 = _t;
+		ProgNodeP tmp71_AST_in = _t;
 		match(antlr::RefAST(_t),EXPR);
 		_t = _t->getFirstChild();
 		res=l_expr(_t, NULL);
 		_t = _retTree;
-		_t = __t65;
+		_t = __t74;
 		_t = _t->getNextSibling();
 		
 		if( *res == NULL)
@@ -3798,6 +4618,16 @@
 		
 		break;
 	}
+	case ARRAYEXPR_MFCALL:
+	{
+		res=l_arrayexpr_mfcall_as_mfcall(_t);
+		_t = _retTree;
+		
+		if( *res == NULL)
+		throw GDLException( _t, "Variable is undefined: "+Name(res),true,false);
+		
+		break;
+	}
 	case DEREF:
 	{
 		res=l_deref(_t);
@@ -3840,8 +4670,8 @@
 	ArrayIndexListGuard guard;
 	
 	
-	ProgNodeP __t67 = _t;
-	ProgNodeP tmp31_AST_in = _t;
+	ProgNodeP __t76 = _t;
+	ProgNodeP tmp72_AST_in = _t;
 	match(antlr::RefAST(_t),ARRAYEXPR);
 	_t = _t->getFirstChild();
 	res=l_indexable_expr(_t);
@@ -3849,7 +4679,7 @@
 	aL=arrayindex_list(_t);
 	_t = _retTree;
 	guard.reset(aL);
-	_t = __t67;
+	_t = __t76;
 	_t = _t->getNextSibling();
 	
 	if( right == NULL)
@@ -3859,7 +4689,6 @@
 	aL->AssignAt( *res, right);
 	
 	//             aL->SetVariable( *res);
-	
 	//             if( (*res)->EqType( right))
 	//             {
 	//                 (*res)->AssignAt( right, aL); // assigns inplace
@@ -3868,7 +4697,6 @@
 	//             {
 	//                 BaseGDL* rConv = right->Convert2( (*res)->Type(), BaseGDL::COPY);
 	//                 auto_ptr<BaseGDL> conv_guard( rConv);
-	
 	//                 (*res)->AssignAt( rConv, aL); // assigns inplace
 	//             }
 	
@@ -3876,6 +4704,110 @@
 	return res;
 }
 
+BaseGDL**  GDLInterpreter::l_arrayexpr_mfcall(ProgNodeP _t,
+	BaseGDL* right
+) {
+	BaseGDL** res;
+	ProgNodeP l_arrayexpr_mfcall_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	ProgNodeP mp2 = ProgNodeP(antlr::nullAST);
+	ProgNodeP dot = ProgNodeP(antlr::nullAST);
+	
+	// better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+	StackGuard<EnvStackT> guard(callStack);
+	BaseGDL *self;
+	EnvUDT*  newEnv;
+	ProgNodeP startNode = _t;
+	
+	
+	ProgNodeP __t151 = _t;
+	ProgNodeP tmp73_AST_in = _t;
+	match(antlr::RefAST(_t),ARRAYEXPR_MFCALL);
+	_t = _t->getFirstChild();
+	
+	ProgNodeP mark = _t;
+	_t = _t->getNextSibling(); // skip DOT
+	
+	self=expr(_t);
+	_t = _retTree;
+	mp2 = _t;
+	match(antlr::RefAST(_t),IDENTIFIER);
+	_t = _t->getNextSibling();
+	
+	auto_ptr<BaseGDL> self_guard(self);
+	
+	try {
+	newEnv=new EnvUDT( self, mp2, "", true);
+	self_guard.release();
+	}
+	catch( GDLException& ex)
+	{
+	goto tryARRAYEXPR;
+	}
+	
+	parameter_def(_t, newEnv);
+	_t = _retTree;
+	_t = __t151;
+	_t = _t->getNextSibling();
+	
+	// push environment onto call stack
+	callStack.push_back(newEnv);
+	
+	// make the call
+	res=call_lfun(static_cast<DSubUD*>(
+	newEnv->GetPro())->GetTree());
+	
+	_retTree = startNode->getNextSibling();
+	return res;
+	
+	tryARRAYEXPR:;
+	_t = mark;
+	
+	ProgNodeP __t152 = _t;
+	dot = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	match(antlr::RefAST(_t),DOT);
+	_t = _t->getFirstChild();
+	
+	SizeT nDot=dot->nDot;
+	auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+	
+	l_dot_array_expr(_t, aD.get());
+	_t = _retTree;
+	{ // ( ... )+
+	int _cnt154=0;
+	for (;;) {
+		if (_t == ProgNodeP(antlr::nullAST) )
+			_t = ASTNULL;
+		if ((_t->getType() == ARRAYEXPR || _t->getType() == EXPR || _t->getType() == IDENTIFIER)) {
+			tag_array_expr(_t, aD.get());
+			_t = _retTree;
+		}
+		else {
+			if ( _cnt154>=1 ) { goto _loop154; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+		}
+		
+		_cnt154++;
+	}
+	_loop154:;
+	}  // ( ... )+
+	_t = __t152;
+	_t = _t->getNextSibling();
+	
+	if( right == NULL)
+	throw GDLException( _t, 
+	"Struct expression not allowed in this context.",
+	true,false);
+	
+	aD->Assign( right);
+	
+	res=NULL;
+	
+	_retTree = startNode->getNextSibling();
+	return res;
+	
+	_retTree = _t;
+	return res;
+}
+
 BaseGDL*  GDLInterpreter::array_expr(ProgNodeP _t) {
 	BaseGDL* res;
 	ProgNodeP array_expr_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
@@ -3891,9 +4823,158 @@
 	SizeT nExpr;
 	BaseGDL* s;
 	
+		ProgNodeP retTree = _t->getNextSibling();
+	//	match(antlr::RefAST(_t),ARRAYEXPR);
+		_t = _t->getFirstChild();
+		
+		switch ( _t->getType()) {
+		case VAR:
+		case CONSTANT:
+		case DEREF:
+		case SYSVAR:
+		case VARPTR:
+		{
+	r=_t->EvalNC();
+			//r=indexable_expr(_t);
+			_t = _t->getNextSibling(); //_retTree;
+			break;
+		}
+		case FCALL_LIB:
+		{
+			r=lib_function_call(_t);
+			_t = _t->getNextSibling();
+			
+			if( !callStack.back()->Contains( r)) 
+	r_guard.reset( r); // guard if no global data
+			
+			break;
+		}
+	// 	case ASSIGN:
+	// 	case ASSIGN_REPLACE:
+	// 	case ASSIGN_ARRAYEXPR_MFCALL:
+	// 	case ARRAYDEF:
+	// 	case ARRAYEXPR:
+	// 	case ARRAYEXPR_MFCALL:
+	// 	case EXPR:
+	// 	case FCALL:
+	// 	case FCALL_LIB_RETNEW:
+	// 	case MFCALL:
+	// 	case MFCALL_PARENT:
+	// 	case NSTRUC:
+	// 	case NSTRUC_REF:
+	// 	case POSTDEC:
+	// 	case POSTINC:
+	// 	case STRUC:
+	// 	case DEC:
+	// 	case INC:
+	// 	case DOT:
+	// 	case QUESTION:
+	default:
+		{
+			r=indexable_tmp_expr(_t);
+			_t = _retTree;
+			r_guard.reset( r);
+			break;
+		}
+		}
+		
 	
-	ProgNodeP __t90 = _t;
-	ProgNodeP tmp32_AST_in = _t;
+		aL = _t->arrIxList;
+		assert( aL != NULL);
+		guard.reset(aL);
+		
+	//    ax = _t
+	//	match(antlr::RefAST(_t),ARRAYIX);
+		_t = _t->getFirstChild();
+		
+		nExpr = aL->NParam();
+		
+		if( nExpr == 0)
+		{
+	goto empty;
+		}
+		//                 if( nExpr > 1)
+		//                 {
+		//                     ixExprList.reserve( nExpr);
+		//                     exprList.reserve( nExpr);
+		//                 }
+		//                if( nExpr == 0) goto empty;
+		
+		for (;;) {
+	//		if ((_tokenSet_1.member(_t->getType()))) {
+				switch ( _t->getType()) {
+				case VAR:
+				case CONSTANT:
+				case DEREF:
+				case SYSVAR:
+				case VARPTR:
+				{
+					s=_t->EvalNC();//indexable_expr(_t);
+					_t = _t->getNextSibling();//_retTree;
+					break;
+				}
+				case FCALL_LIB:
+				{
+					s=lib_function_call(_t);
+					_t = _retTree;
+					
+					if( !callStack.back()->Contains( s)) 
+					exprList.push_back( s);
+					
+					break;
+				}
+	// 			case ASSIGN:
+	// 			case ASSIGN_REPLACE:
+	// 			case ASSIGN_ARRAYEXPR_MFCALL:
+	// 			case ARRAYDEF:
+	// 			case ARRAYEXPR:
+	// 			case ARRAYEXPR_MFCALL:
+	// 			case EXPR:
+	// 			case FCALL:
+	// 			case FCALL_LIB_RETNEW:
+	// 			case MFCALL:
+	// 			case MFCALL_PARENT:
+	// 			case NSTRUC:
+	// 			case NSTRUC_REF:
+	// 			case POSTDEC:
+	// 			case POSTINC:
+	// 			case STRUC:
+	// 			case DEC:
+	// 			case INC:
+	// 			case DOT:
+	// 			case QUESTION:
+	default:
+				{
+					s=indexable_tmp_expr(_t);
+					_t = _retTree;
+					exprList.push_back( s);
+					break;
+				}
+				} // switch
+				
+				ixExprList.push_back( s);
+				if( ixExprList.size() == nExpr)
+	break; // finish
+				
+			} // for
+	// 		else {
+	// 			assert( 0);//goto _loop106;
+	// 		}
+			
+		empty:
+		//_retTree = ax;
+		res = aL->Index( r, ixExprList);
+		//                 aL->Init( ixExprList);
+		//                 aL->SetVariable( r);
+		//                 res=r->Index( aL);
+		//                ClearTmpList();
+	
+	_retTree = retTree;
+		return res;
+	
+	
+	ProgNodeP __t101 = _t;
+	ProgNodeP tmp74_AST_in = _t;
 	match(antlr::RefAST(_t),ARRAYEXPR);
 	_t = _t->getFirstChild();
 	{
@@ -3912,8 +4993,10 @@
 	}
 	case ASSIGN:
 	case ASSIGN_REPLACE:
+	case ASSIGN_ARRAYEXPR_MFCALL:
 	case ARRAYDEF:
 	case ARRAYEXPR:
+	case ARRAYEXPR_MFCALL:
 	case EXPR:
 	case FCALL:
 	case FCALL_LIB_RETNEW:
@@ -3936,7 +5019,7 @@
 	}
 	case FCALL_LIB:
 	{
-		r=check_expr(_t);
+		r=lib_function_call(_t);
 		_t = _retTree;
 		
 		if( !callStack.back()->Contains( r)) 
@@ -3950,7 +5033,7 @@
 	}
 	}
 	}
-	ProgNodeP __t92 = _t;
+	ProgNodeP __t103 = _t;
 	ax = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	match(antlr::RefAST(_t),ARRAYIX);
 	_t = _t->getFirstChild();
@@ -3964,7 +5047,7 @@
 	
 	if( nExpr == 0)
 	{
-	goto empty;
+	goto empty2;
 	}
 	//                 if( nExpr > 1)
 	//                 {
@@ -3994,7 +5077,7 @@
 			}
 			case FCALL_LIB:
 			{
-				s=check_expr(_t);
+				s=lib_function_call(_t);
 				_t = _retTree;
 				
 				if( !callStack.back()->Contains( s)) 
@@ -4004,8 +5087,10 @@
 			}
 			case ASSIGN:
 			case ASSIGN_REPLACE:
+			case ASSIGN_ARRAYEXPR_MFCALL:
 			case ARRAYDEF:
 			case ARRAYEXPR:
+			case ARRAYEXPR_MFCALL:
 			case EXPR:
 			case FCALL:
 			case FCALL_LIB_RETNEW:
@@ -4039,16 +5124,16 @@
 			
 		}
 		else {
-			goto _loop95;
+			goto _loop106;
 		}
 		
 	}
-	_loop95:;
+	_loop106:;
 	} // ( ... )*
-	_t = __t92;
+	_t = __t103;
 	_t = _t->getNextSibling();
 	
-	empty:
+	empty2:
 	//_retTree = ax;
 	res = aL->Index( r, ixExprList);
 	//                 aL->Init( ixExprList);
@@ -4056,7 +5141,7 @@
 	//                 res=r->Index( aL);
 	//                ClearTmpList();
 	
-	_t = __t90;
+	_t = __t101;
 	_t = _t->getNextSibling();
 	_retTree = _t;
 	return res;
@@ -4076,8 +5161,8 @@
 	switch ( _t->getType()) {
 	case EXPR:
 	{
-		ProgNodeP __t97 = _t;
-		ProgNodeP tmp33_AST_in = _t;
+		ProgNodeP __t108 = _t;
+		ProgNodeP tmp75_AST_in = _t;
 		match(antlr::RefAST(_t),EXPR);
 		_t = _t->getFirstChild();
 		e=expr(_t);
@@ -4093,7 +5178,7 @@
 		
 		aD->Add( tagIx);
 		
-		_t = __t97;
+		_t = __t108;
 		_t = _t->getNextSibling();
 		break;
 	}
@@ -4130,14 +5215,14 @@
 	switch ( _t->getType()) {
 	case EXPR:
 	{
-		ProgNodeP __t101 = _t;
-		ProgNodeP tmp34_AST_in = _t;
+		ProgNodeP __t112 = _t;
+		ProgNodeP tmp76_AST_in = _t;
 		match(antlr::RefAST(_t),EXPR);
 		_t = _t->getFirstChild();
 		res=expr(_t);
 		_t = _retTree;
 		aD->SetOwner( true);
-		_t = __t101;
+		_t = __t112;
 		_t = _t->getNextSibling();
 		break;
 	}
@@ -4227,8 +5312,8 @@
 	switch ( _t->getType()) {
 	case ARRAYEXPR:
 	{
-		ProgNodeP __t103 = _t;
-		ProgNodeP tmp35_AST_in = _t;
+		ProgNodeP __t114 = _t;
+		ProgNodeP tmp77_AST_in = _t;
 		match(antlr::RefAST(_t),ARRAYEXPR);
 		_t = _t->getFirstChild();
 		r=r_dot_indexable_expr(_t, aD);
@@ -4236,7 +5321,7 @@
 		aL=arrayindex_list(_t);
 		_t = _retTree;
 		guard.reset(aL);
-		_t = __t103;
+		_t = __t114;
 		_t = _t->getNextSibling();
 		
 		// check here for object and get struct
@@ -4356,14 +5441,14 @@
 		return res;
 	
 	
-	ProgNodeP __t105 = _t;
+	ProgNodeP __t116 = _t;
 	dot = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	match(antlr::RefAST(_t),DOT);
 	_t = _t->getFirstChild();
 	r_dot_array_expr(_t, aD.get());
 	_t = _retTree;
 	{ // ( ... )+
-	int _cnt107=0;
+	int _cnt118=0;
 	for (;;) {
 		if (_t == ProgNodeP(antlr::nullAST) )
 			_t = ASTNULL;
@@ -4372,14 +5457,14 @@
 			_t = _retTree;
 		}
 		else {
-			if ( _cnt107>=1 ) { goto _loop107; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+			if ( _cnt118>=1 ) { goto _loop118; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 		}
 		
-		_cnt107++;
+		_cnt118++;
 	}
-	_loop107:;
+	_loop118:;
 	}  // ( ... )+
-	_t = __t105;
+	_t = __t116;
 	_t = _t->getNextSibling();
 	_retTree = _t;
 	return res;
@@ -4392,9 +5477,9 @@
 	BaseGDL** l;
 	BaseGDL*  r;
 	
+		ProgNodeP startNode = _t;
 		if( _t->getType() == ASSIGN) 
 		{
-			ProgNodeP __t130 = _t;
 	// 		match(antlr::RefAST(_t),ASSIGN);
 			_t = _t->getFirstChild();
 			
@@ -4402,7 +5487,7 @@
 			
 			if( _t->getType() == FCALL_LIB)
 			{
-				res=check_expr(_t);
+				res=lib_function_call(_t);
 				_t = _retTree;
 				
 				if( !callStack.back()->Contains( res)) 
@@ -4426,12 +5511,73 @@
 			else
 			res = res->Dup();
 			
-			_t = __t130;
-			_t = _t->getNextSibling();
 		}
+	else if( _t->getType() == ASSIGN_ARRAYEXPR_MFCALL) 
+	{
+	
+			_t = _t->getFirstChild();
+			
+			auto_ptr<BaseGDL> r_guard;
+			
+			if( _t->getType() == FCALL_LIB)
+			{
+				res=lib_function_call(_t);
+				_t = _retTree;
+				
+				if( !callStack.back()->Contains( res)) 
+				r_guard.reset( res);
+				
+			}
+	else
+			{
+				res=tmp_expr(_t);
+				_t = _retTree;
+				
+				r_guard.reset( res);
+				
+			}
+	
+	ProgNodeP mark = _t;
+	
+	// try MFCALL
+	try
+	{
+	l=l_arrayexpr_mfcall_as_mfcall( mark);
+	
+	if( res != (*l))
+	{
+	delete *l;
+	*l = res->Dup();     
+			
+	if( r_guard.get() == res) // owner
+	{
+	r_guard.release(); 
+	}
+	else
+	res = res->Dup();
+	}
+	}
+	catch( GDLException& ex)
+	{
+	// try ARRAYEXPR
+	try
+		                {
+	l=l_arrayexpr_mfcall_as_arrayexpr(mark, res);
+	
+	if( r_guard.get() == res) // owner
+	r_guard.release();
+	else
+	res = res->Dup();
+		                }
+	catch( GDLException& ex2)
+	{
+	throw GDLException(ex.toString() + " or "+ex2.toString());
+	}
+	}
+	
+	}
 	else
 		{
-			ProgNodeP __t132 = _t;
 	// 		match(antlr::RefAST(_t),ASSIGN_REPLACE);
 			_t = _t->getFirstChild();
 			
@@ -4440,7 +5586,7 @@
 			if( _t->getType() == FCALL_LIB)
 			{
 	
-				res=check_expr(_t);
+				res=lib_function_call(_t);
 				_t = _retTree;
 				
 				if( !callStack.back()->Contains( res)) 
@@ -4491,24 +5637,94 @@
 			else
 			res = res->Dup();
 			}
-			
-			_t = __t132;
-			_t = _t->getNextSibling();
-		}
+	}
 	
-		_retTree = _t;
+		_retTree = startNode->getNextSibling();
 		return res;
 	
 	
-	
 	if (_t == ProgNodeP(antlr::nullAST) )
 		_t = ASTNULL;
 	switch ( _t->getType()) {
 	case ASSIGN:
 	{
-		ProgNodeP __t116 = _t;
-		ProgNodeP tmp36_AST_in = _t;
-		match(antlr::RefAST(_t),ASSIGN);
+		ProgNodeP __t128 = _t;
+		ProgNodeP tmp78_AST_in = _t;
+		match(antlr::RefAST(_t),ASSIGN);
+		_t = _t->getFirstChild();
+		
+		auto_ptr<BaseGDL> r_guard;
+		
+		{
+		if (_t == ProgNodeP(antlr::nullAST) )
+			_t = ASTNULL;
+		switch ( _t->getType()) {
+		case ASSIGN:
+		case ASSIGN_REPLACE:
+		case ASSIGN_ARRAYEXPR_MFCALL:
+		case ARRAYDEF:
+		case ARRAYEXPR:
+		case ARRAYEXPR_MFCALL:
+		case CONSTANT:
+		case DEREF:
+		case EXPR:
+		case FCALL:
+		case FCALL_LIB_RETNEW:
+		case MFCALL:
+		case MFCALL_PARENT:
+		case NSTRUC:
+		case NSTRUC_REF:
+		case POSTDEC:
+		case POSTINC:
+		case STRUC:
+		case SYSVAR:
+		case VAR:
+		case VARPTR:
+		case DEC:
+		case INC:
+		case DOT:
+		case QUESTION:
+		{
+			res=tmp_expr(_t);
+			_t = _retTree;
+			
+			r_guard.reset( res);
+			
+			break;
+		}
+		case FCALL_LIB:
+		{
+			res=lib_function_call(_t);
+			_t = _retTree;
+			
+			if( !callStack.back()->Contains( res)) 
+			r_guard.reset( res);
+			
+			break;
+		}
+		default:
+		{
+			throw antlr::NoViableAltException(antlr::RefAST(_t));
+		}
+		}
+		}
+		l=l_expr(_t, res);
+		_t = _retTree;
+		
+		if( r_guard.get() == res) // owner
+		r_guard.release();
+		else
+		res = res->Dup();
+		
+		_t = __t128;
+		_t = _t->getNextSibling();
+		break;
+	}
+	case ASSIGN_ARRAYEXPR_MFCALL:
+	{
+		ProgNodeP __t130 = _t;
+		ProgNodeP tmp79_AST_in = _t;
+		match(antlr::RefAST(_t),ASSIGN_ARRAYEXPR_MFCALL);
 		_t = _t->getFirstChild();
 		
 		auto_ptr<BaseGDL> r_guard;
@@ -4519,8 +5735,10 @@
 		switch ( _t->getType()) {
 		case ASSIGN:
 		case ASSIGN_REPLACE:
+		case ASSIGN_ARRAYEXPR_MFCALL:
 		case ARRAYDEF:
 		case ARRAYEXPR:
+		case ARRAYEXPR_MFCALL:
 		case CONSTANT:
 		case DEREF:
 		case EXPR:
@@ -4550,7 +5768,7 @@
 		}
 		case FCALL_LIB:
 		{
-			res=check_expr(_t);
+			res=lib_function_call(_t);
 			_t = _retTree;
 			
 			if( !callStack.back()->Contains( res)) 
@@ -4572,14 +5790,14 @@
 		else
 		res = res->Dup();
 		
-		_t = __t116;
+		_t = __t130;
 		_t = _t->getNextSibling();
 		break;
 	}
 	case ASSIGN_REPLACE:
 	{
-		ProgNodeP __t118 = _t;
-		ProgNodeP tmp37_AST_in = _t;
+		ProgNodeP __t132 = _t;
+		ProgNodeP tmp80_AST_in = _t;
 		match(antlr::RefAST(_t),ASSIGN_REPLACE);
 		_t = _t->getFirstChild();
 		
@@ -4591,8 +5809,10 @@
 		switch ( _t->getType()) {
 		case ASSIGN:
 		case ASSIGN_REPLACE:
+		case ASSIGN_ARRAYEXPR_MFCALL:
 		case ARRAYDEF:
 		case ARRAYEXPR:
+		case ARRAYEXPR_MFCALL:
 		case CONSTANT:
 		case DEREF:
 		case EXPR:
@@ -4622,7 +5842,7 @@
 		}
 		case FCALL_LIB:
 		{
-			res=check_expr(_t);
+			res=lib_function_call(_t);
 			_t = _retTree;
 			
 			if( !callStack.back()->Contains( res)) 
@@ -4682,7 +5902,7 @@
 		res = res->Dup();
 		}
 		
-		_t = __t118;
+		_t = __t132;
 		_t = _t->getNextSibling();
 		break;
 	}
@@ -4702,22 +5922,24 @@
 	ProgNodeP parent = ProgNodeP(antlr::nullAST);
 	ProgNodeP p = ProgNodeP(antlr::nullAST);
 	ProgNodeP f = ProgNodeP(antlr::nullAST);
+	ProgNodeP mp2 = ProgNodeP(antlr::nullAST);
 	
 	// better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
 	StackGuard<EnvStackT> guard(callStack);
 	BaseGDL *self;
-	EnvUDT*   newEnv;
+	EnvUDT*  newEnv;
+	ProgNodeP startNode = _t;
+	ProgNodeP mark;
 	
 	
 	{
-	{
 	if (_t == ProgNodeP(antlr::nullAST) )
 		_t = ASTNULL;
 	switch ( _t->getType()) {
 	case MFCALL:
 	{
-		ProgNodeP __t133 = _t;
-		ProgNodeP tmp38_AST_in = _t;
+		ProgNodeP __t146 = _t;
+		ProgNodeP tmp81_AST_in = _t;
 		match(antlr::RefAST(_t),MFCALL);
 		_t = _t->getFirstChild();
 		self=expr(_t);
@@ -4734,14 +5956,14 @@
 		
 		parameter_def(_t, newEnv);
 		_t = _retTree;
-		_t = __t133;
+		_t = __t146;
 		_t = _t->getNextSibling();
 		break;
 	}
 	case MFCALL_PARENT:
 	{
-		ProgNodeP __t134 = _t;
-		ProgNodeP tmp39_AST_in = _t;
+		ProgNodeP __t147 = _t;
+		ProgNodeP tmp82_AST_in = _t;
 		match(antlr::RefAST(_t),MFCALL_PARENT);
 		_t = _t->getFirstChild();
 		self=expr(_t);
@@ -4762,13 +5984,13 @@
 		
 		parameter_def(_t, newEnv);
 		_t = _retTree;
-		_t = __t134;
+		_t = __t147;
 		_t = _t->getNextSibling();
 		break;
 	}
 	case FCALL:
 	{
-		ProgNodeP __t135 = _t;
+		ProgNodeP __t148 = _t;
 		f = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 		match(antlr::RefAST(_t),FCALL);
 		_t = _t->getFirstChild();
@@ -4779,7 +6001,40 @@
 		
 		parameter_def(_t, newEnv);
 		_t = _retTree;
-		_t = __t135;
+		_t = __t148;
+		_t = _t->getNextSibling();
+		break;
+	}
+	case ARRAYEXPR_MFCALL:
+	{
+		ProgNodeP __t149 = _t;
+		ProgNodeP tmp83_AST_in = _t;
+		match(antlr::RefAST(_t),ARRAYEXPR_MFCALL);
+		_t = _t->getFirstChild();
+		
+		mark = _t;
+		_t = _t->getNextSibling(); // skip DOT
+		
+		self=expr(_t);
+		_t = _retTree;
+		mp2 = _t;
+		match(antlr::RefAST(_t),IDENTIFIER);
+		_t = _t->getNextSibling();
+		
+		auto_ptr<BaseGDL> self_guard(self);
+		
+		try {
+		newEnv=new EnvUDT( self, mp2);
+		self_guard.release();
+		}
+		catch( GDLException& ex)
+		{
+		goto tryARRAYEXPR;
+		}
+		
+		parameter_def(_t, newEnv);
+		_t = _retTree;
+		_t = __t149;
 		_t = _t->getNextSibling();
 		break;
 	}
@@ -4796,7 +6051,30 @@
 	// make the call
 	res=call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
 	
+	_retTree = startNode->getNextSibling();
+	return res;
+	
+	tryARRAYEXPR:;
+	//_t = mark;
+	
+	ProgNodeP dot = mark;
+	// 	match(antlr::RefAST(_t),DOT);
+	_t = mark->getFirstChild();
+		
+	SizeT nDot=dot->nDot;
+	auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+		
+	r_dot_array_expr(_t, aD.get());
+	_t = _retTree;
+	for (; _t != NULL;) {
+	tag_array_expr(_t, aD.get());
+	_t = _retTree;
 	}
+	res= aD->Resolve();
+	
+	_retTree = startNode->getNextSibling();
+	return res;
+	
 	_retTree = _t;
 	return res;
 }
@@ -4819,78 +6097,35 @@
 	// 	_t =_t->getFirstChild();
 		
 	// 	EnvT* newEnv=new EnvT( fl, fl->libFun);//libFunList[fl->funIx]);
-		
-		parameter_def(_t->getFirstChild(), newEnv);
-		
-		// push id.pro onto call stack
-		callStack.push_back(newEnv);
-		// make the call
-		//BaseGDL* 
-	res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
-		//*** MUST always return a defined expression
-		
-		_retTree = rTree;
-		return res;
-	
-	
-	ProgNodeP __t129 = _t;
-	fll = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	match(antlr::RefAST(_t),FCALL_LIB_RETNEW);
-	_t = _t->getFirstChild();
-	
-	//EnvT* 
-	newEnv=new EnvT( fll, fll->libFun);//libFunList[fl->funIx]);
-	
-	parameter_def(_t, newEnv);
-	_t = _retTree;
-	
-	// push id.pro onto call stack
-	callStack.push_back(newEnv);
-	// make the call
-	res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
-	//*** MUST always return a defined expression
-	
-	_t = __t129;
-	_t = _t->getNextSibling();
-	_retTree = _t;
-	return res;
-}
-
- BaseGDL*  GDLInterpreter::lib_function_call(ProgNodeP _t) {
-	 BaseGDL* res;
-	ProgNodeP lib_function_call_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	ProgNodeP fll = ProgNodeP(antlr::nullAST);
+	static int n_elementsIx = LibFunIx("N_ELEMENTS");
+	static DLibFun* n_elementsFun = libFunList[n_elementsIx];
 	
-	// better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
-	StackGuard<EnvStackT> guard(callStack);
-		
-		ProgNodeP rTree = _t->getNextSibling();
-	// 	match(antlr::RefAST(_t),FCALL_LIB);
+	if( _t->libFun == n_elementsFun)
+	{
+	parameter_def_n_elements(_t->getFirstChild(), newEnv);
+	}
+	else
+	{
+	parameter_def(_t->getFirstChild(), newEnv);
+	}
 	
-	// 	match(antlr::RefAST(_t),IDENTIFIER);
 	
-		ProgNodeP& fl = _t;
-		EnvT* newEnv=new EnvT( fl, fl->libFun);//libFunList[fl->funIx]);
-		
-		parameter_def(_t->getFirstChild(), newEnv);
+	//	parameter_def(_t->getFirstChild(), newEnv);
 		
 		// push id.pro onto call stack
 		callStack.push_back(newEnv);
 		// make the call
 		//BaseGDL* 
 	res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
-		// *** MUST always return a defined expression
-	//    if( res == NULL)
-	//       throw GDLException( _t, "");
-	
-	
+		//*** MUST always return a defined expression
+		
 		_retTree = rTree;
 		return res;
 	
 	
-	ProgNodeP __t127 = _t;
+	ProgNodeP __t143 = _t;
 	fll = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	match(antlr::RefAST(_t),FCALL_LIB);
+	match(antlr::RefAST(_t),FCALL_LIB_RETNEW);
 	_t = _t->getFirstChild();
 	
 	//EnvT* 
@@ -4905,7 +6140,7 @@
 	res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
 	//*** MUST always return a defined expression
 	
-	_t = __t127;
+	_t = __t143;
 	_t = _t->getNextSibling();
 	_retTree = _t;
 	return res;
@@ -4914,14 +6149,14 @@
 BaseGDL*  GDLInterpreter::constant(ProgNodeP _t) {
 	BaseGDL* res;
 	ProgNodeP constant_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	ProgNodeP c = ProgNodeP(antlr::nullAST);
 	
-	c = _t;
-	match(antlr::RefAST(_t),CONSTANT);
-	_t = _t->getNextSibling();
+		_retTree = _t->getNextSibling();
+		return _t->cData->Dup(); 
 	
-	res=c->cData->Dup(); 
 	
+	ProgNodeP tmp84_AST_in = _t;
+	match(antlr::RefAST(_t),CONSTANT);
+	_t = _t->getNextSibling();
 	_retTree = _t;
 	return res;
 }
@@ -5032,228 +6267,60 @@
 	return res;
 }
 
-void GDLInterpreter::parameter_def(ProgNodeP _t,
-	EnvBaseT* actEnv
+BaseGDL**  GDLInterpreter::l_arrayexpr_mfcall_as_arrayexpr(ProgNodeP _t,
+	BaseGDL* right
 ) {
-	ProgNodeP parameter_def_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
-	
-	auto_ptr<EnvBaseT> guard(actEnv); 
-	try{
-	
-	_retTree = _t;
-	while(_retTree != NULL) {
-	static_cast<ParameterNode*>(_retTree)->Parameter( actEnv);
-	}    
-	
-	actEnv->Extra(); // expand _EXTRA
-	
-	} 
-	catch( GDLException& e)
-	{
-	// update line number, currently set to caller->CallingNode()
-	// because actEnv is not on the stack yet, 
-	// report caller->Pro()'s name is ok, because we are not inside
-	// the call yet
-	e.SetErrorNodeP( actEnv->CallingNode());
-	throw e;
-	}
-	
-		guard.release();
-		
-	return;
-	
-	//     BaseGDL*  kval = NULL;
-	//     BaseGDL*  pval;
-	//     BaseGDL** kvalRef;
-	//     BaseGDL** pvalRef;
-	
-	// // 	while(_t != NULL) {
-	// // 		switch ( _t->getType()) {
-	// // 		case KEYDEF_REF:
-	// // 		{
-	// // 			ProgNodeP __t160 = _t;
-	
-	// // // 			match(antlr::RefAST(_t),KEYDEF_REF);
-	// // 			_t = _t->getFirstChild();
-	// // 			knameR = _t;
-	// // // 			match(antlr::RefAST(_t),IDENTIFIER);
-	// // 			_t = _t->getNextSibling();
-	// // 			kvalRef=ref_parameter(_t);
-	// // 			_t = _retTree;
-	// // 			// pass reference
-	// // 			actEnv->SetKeyword( knameR->getText(), kvalRef); 
-				
-	// // 			_t = __t160;
-	// // 			_t = _t->getNextSibling();
-	// // 			break;
-	// // 		}
-	// // 		case KEYDEF_REF_EXPR:
-	// // 		{
-	// // 			ProgNodeP __t161 = _t;
-	
-	// // // 			match(antlr::RefAST(_t),KEYDEF_REF_EXPR);
-	// // 			_t = _t->getFirstChild();
-	// // 			knameE = _t;
-	// // // 			match(antlr::RefAST(_t),IDENTIFIER);
-	// // 			_t = _t->getNextSibling();
-	// // 			kval=expr(_t);
-	// // 			_t = _retTree;
-	// // 			kvalRef=ref_parameter(_t);
-	// // 			_t = _retTree;
-	// // 			// pass reference
-	// // 			delete kval;
-	// // 			actEnv->SetKeyword( knameE->getText(), kvalRef); 
-				
-	// // 			_t = __t161;
-	// // 			_t = _t->getNextSibling();
-	// // 			break;
-	// // 		}
-	// // 		case KEYDEF:
-	// // 		{
-	// // 			ProgNodeP __t162 = _t;
-	
-	// // // 			match(antlr::RefAST(_t),KEYDEF);
-	// // 			_t = _t->getFirstChild();
-	// // 			kname = _t;
-	// // // 			match(antlr::RefAST(_t),IDENTIFIER);
-	// // 			_t = _t->getNextSibling();
-	// // 			kval=expr(_t);
-	// // 			_t = _retTree;
-	// // 			// pass value
-	// // 			actEnv->SetKeyword( kname->getText(), kval);
-				
-	// // 			_t = __t162;
-	// // 			_t = _t->getNextSibling();
-	// // 			break;
-	// // 		}
-	// // 		case REF:
-	// // 		{
-	// // 			ProgNodeP __t163 = _t;
-	
-	// // // 			match(antlr::RefAST(_t),REF);
-	// // 			_t = _t->getFirstChild();
-	// // 			pvalRef=ref_parameter(_t);
-	// // 			_t = _retTree;
-	// // 			// pass reference
-	// // 			actEnv->SetNextPar(pvalRef); 
-				
-	// // 			_t = __t163;
-	// // 			_t = _t->getNextSibling();
-	// // 			break;
-	// // 		}
-	// // 		case REF_EXPR:
-	// // 		{
-	// // 			ProgNodeP __t164 = _t;
-	
-	// // // 			match(antlr::RefAST(_t),REF_EXPR);
-	// // 			_t = _t->getFirstChild();
-	// // 			pval=expr(_t);
-	// // 			_t = _retTree;
-	// // 			pvalRef=ref_parameter(_t);
-	// // 			_t = _retTree;
-	// // 			// pass reference
-	// // 			delete pval;
-	// // 			actEnv->SetNextPar(pvalRef); 
-				
-	// // 			_t = __t164;
-	// // 			_t = _t->getNextSibling();
-	// // 			break;
-	// // 		}
-	// //  		case KEYDEF_REF_CHECK:
-	// // 		{
-	// // 			ProgNodeP __t165 = _t;
-	
-	// // // 			match(antlr::RefAST(_t),KEYDEF_REF_CHECK);
-	// // 			_t = _t->getFirstChild();
-	// // 			knameCk = _t;
-	// // // 			match(antlr::RefAST(_t),IDENTIFIER);
-	// // 			_t = _t->getNextSibling();
-	// // 			kval=check_expr(_t);
-	// // 			_t = _retTree;
-				
-	// // 			kvalRef = callStack.back()->GetPtrTo( kval);
-	// // 			if( kvalRef != NULL)
-	// // 			{   // pass reference
-	// // 			actEnv->SetKeyword(knameCk->getText(), kvalRef); 
-	// // 			}
-	// // 			else 
-	// // 			{   // pass value
-	// // 			actEnv->SetKeyword(knameCk->getText(), kval); 
-	// // 			}
-				
-	// // 			_t = __t165;
-	// // 			_t = _t->getNextSibling();
-	// // 			break;
-	// // 		}
-	// // 		case REF_CHECK:
-	// // 		{
-	// // 			ProgNodeP __t166 = _t;
-	
-	// // // 			match(antlr::RefAST(_t),REF_CHECK);
-	// // 			_t = _t->getFirstChild();
-	// // 			pval=check_expr(_t);
-	// // 			_t = _retTree;
-				
-	// // 			pvalRef = callStack.back()->GetPtrTo( pval);
-	// // 			if( pvalRef != NULL)
-	// // 			{   // pass reference
-	// // 			actEnv->SetNextPar( pvalRef); 
-	// // 			}
-	// // 			else 
-	// // 			{   // pass value
-	// // 			actEnv->SetNextPar( pval); 
-	// // 			}
-				
-	// // 			_t = __t166;
-	// // 			_t = _t->getNextSibling();
-	// // 			break;
-	// // 		}
-	// // 		default:
-	// // 		{
-	// // 			pval=expr(_t);
-	// //  			_t = _retTree;
-				
-	// // 			// pass value
-	// // 			actEnv->SetNextPar(pval); 
-				
-	// // 			break;
-	// // 		}
-	
-	// // 		} // switch
-	// //     } // while
-	
-		
-	// // 	actEnv->Extra(); // expand _EXTRA
-	// // 	guard.release();
-		
-	// // 	_retTree = _t;
+	BaseGDL** res;
+	ProgNodeP l_arrayexpr_mfcall_as_arrayexpr_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	ProgNodeP dot = ProgNodeP(antlr::nullAST);
 	
-	// //     return;
+	ProgNodeP __t156 = _t;
+	ProgNodeP tmp85_AST_in = _t;
+	match(antlr::RefAST(_t),ARRAYEXPR_MFCALL);
+	_t = _t->getFirstChild();
+	ProgNodeP __t157 = _t;
+	dot = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	match(antlr::RefAST(_t),DOT);
+	_t = _t->getFirstChild();
 	
+	SizeT nDot=dot->nDot;
+	auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
 	
-	{ // ( ... )*
+	l_dot_array_expr(_t, aD.get());
+	_t = _retTree;
+	{ // ( ... )+
+	int _cnt159=0;
 	for (;;) {
 		if (_t == ProgNodeP(antlr::nullAST) )
 			_t = ASTNULL;
-		if ((_t->getType() == KEYDEF_REF)) {
-			ProgNodeP __t146 = _t;
-			ProgNodeP tmp40_AST_in = _t;
-			match(antlr::RefAST(_t),KEYDEF_REF);
-			_t = _t->getFirstChild();
-			ProgNodeP tmp41_AST_in = _t;
-			match(antlr::RefAST(_t),IDENTIFIER);
-			_t = _t->getNextSibling();
-			_t = __t146;
-			_t = _t->getNextSibling();
+		if ((_t->getType() == ARRAYEXPR || _t->getType() == EXPR || _t->getType() == IDENTIFIER)) {
+			tag_array_expr(_t, aD.get());
+			_t = _retTree;
 		}
 		else {
-			goto _loop147;
+			if ( _cnt159>=1 ) { goto _loop159; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 		}
 		
+		_cnt159++;
 	}
-	_loop147:;
-	} // ( ... )*
+	_loop159:;
+	}  // ( ... )+
+	_t = __t157;
+	_t = _t->getNextSibling();
+	_t = __t156;
+	_t = _t->getNextSibling();
+	
+	if( right == NULL)
+	throw GDLException( _t, 
+	"Struct expression not allowed in this context.",
+	true,false);
+	
+	aD->Assign( right);
+	
+	res=NULL;
+	
 	_retTree = _t;
+	return res;
 }
 
  BaseGDL**  GDLInterpreter::ref_parameter(ProgNodeP _t) {
@@ -5305,6 +6372,71 @@
 	return ret;
 }
 
+void GDLInterpreter::parameter_def_n_elements(ProgNodeP _t,
+	EnvBaseT* actEnv
+) {
+	ProgNodeP parameter_def_n_elements_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
+	
+	auto_ptr<EnvBaseT> guard(actEnv); 
+	_retTree = _t;
+	//     bool interruptEnableIn = interruptEnable;
+	if( _retTree != NULL)
+	{
+	if( _retTree->getType() == REF ||
+	_retTree->getType() == REF_EXPR ||
+	_retTree->getType() == REF_CHECK ||
+	_retTree->getType() == PARAEXPR)
+	{
+	try{
+	//                     interruptEnable = false;
+	static_cast<ParameterNode*>(_retTree)->Parameter( actEnv);
+	//                     interruptEnable = interruptEnableIn;
+	} 
+	catch( GDLException& e)
+	{
+	//                         interruptEnable = interruptEnableIn;
+	if( actEnv->NParam() == 0) 
+	{
+	BaseGDL* nP = NULL;
+	actEnv->SetNextPar( nP);
+	}
+	}
+	}
+	}
+	try{
+	while(_retTree != NULL) {
+	static_cast<ParameterNode*>(_retTree)->Parameter( actEnv);
+	}    
+	}
+	catch( GDLException& e)
+	{
+	// update line number, currently set to caller->CallingNode()
+	// because actEnv is not on the stack yet, 
+	// report caller->Pro()'s name is ok, because we are not inside
+	// the call yet
+	e.SetErrorNodeP( actEnv->CallingNode());
+	throw e;
+	}
+	
+	actEnv->Extra(); // expand _EXTRA
+	
+		guard.release();
+		
+	return;
+	
+	
+	ProgNodeP __t171 = _t;
+	ProgNodeP tmp86_AST_in = _t;
+	match(antlr::RefAST(_t),KEYDEF_REF_EXPR);
+	_t = _t->getFirstChild();
+	ProgNodeP tmp87_AST_in = _t;
+	match(antlr::RefAST(_t),IDENTIFIER);
+	_t = _t->getNextSibling();
+	_t = __t171;
+	_t = _t->getNextSibling();
+	_retTree = _t;
+}
+
 void GDLInterpreter::initializeASTFactory( antlr::ASTFactory& )
 {
 }
@@ -5317,6 +6449,7 @@
 	"ASSIGN",
 	"ASSIGN_INPLACE",
 	"ASSIGN_REPLACE",
+	"ASSIGN_ARRAYEXPR_MFCALL",
 	"ARRAYDEF",
 	"ARRAYDEF_CONST",
 	"ARRAYIX",
@@ -5327,8 +6460,10 @@
 	"ARRAYIX_RANGE_S",
 	"ARRAYEXPR",
 	"ARRAYEXPR_FN",
+	"ARRAYEXPR_MFCALL",
 	"BLOCK",
 	"BREAK",
+	"CSBLOCK",
 	"CONTINUE",
 	"COMMONDECL",
 	"COMMONDEF",
@@ -5336,7 +6471,12 @@
 	"DEREF",
 	"ELSEBLK",
 	"EXPR",
+	"\"for\"",
 	"FOR_STEP",
+	"\"foreach\"",
+	"FOR_LOOP",
+	"FOR_STEP_LOOP",
+	"FOREACH_LOOP",
 	"FCALL",
 	"FCALL_LIB",
 	"FCALL_LIB_RETNEW",
@@ -5370,6 +6510,8 @@
 	"REF",
 	"REF_CHECK",
 	"REF_EXPR",
+	"\"repeat\"",
+	"REPEAT_LOOP",
 	"RETURN",
 	"RETF",
 	"RETP",
@@ -5378,6 +6520,7 @@
 	"UMINUS",
 	"VAR",
 	"VARPTR",
+	"\"while\"",
 	"IDENTIFIER",
 	"\"and\"",
 	"\"begin\"",
@@ -5390,12 +6533,12 @@
 	"\"endcase\"",
 	"\"endelse\"",
 	"\"endfor\"",
+	"\"endforeach\"",
 	"\"endif\"",
 	"\"endrep\"",
 	"\"endswitch\"",
 	"\"endwhile\"",
 	"\"eq\"",
-	"\"for\"",
 	"\"forward_function\"",
 	"\"function\"",
 	"\"ge\"",
@@ -5412,11 +6555,9 @@
 	"\"on_ioerror\"",
 	"\"or\"",
 	"\"pro\"",
-	"\"repeat\"",
 	"\"switch\"",
 	"\"then\"",
 	"\"until\"",
-	"\"while\"",
 	"\"xor\"",
 	"METHOD",
 	"COMMA",
@@ -5528,20 +6669,17 @@
 	0
 };
 
-const unsigned long GDLInterpreter::_tokenSet_0_data_[] = { 2283536544UL, 3222143200UL, 339738880UL, 788880UL, 0UL, 0UL, 0UL, 0UL };
-// ASSIGN ASSIGN_REPLACE BLOCK BREAK CONTINUE FOR_STEP IF_ELSE LABEL MPCALL 
-// MPCALL_PARENT ON_IOERROR_NULL PCALL PCALL_LIB RETF RETP "case" "for" 
-// "goto" "if" "on_ioerror" "repeat" "switch" "while" DEC INC 
+const unsigned long GDLInterpreter::_tokenSet_0_data_[] = { 3232760224UL, 234938511UL, 557920UL, 402948256UL, 0UL, 0UL, 0UL, 0UL };
+// ASSIGN ASSIGN_REPLACE ASSIGN_ARRAYEXPR_MFCALL BLOCK BREAK CONTINUE "for" 
+// FOR_STEP "foreach" FOR_LOOP FOR_STEP_LOOP FOREACH_LOOP IF_ELSE LABEL 
+// MPCALL MPCALL_PARENT ON_IOERROR_NULL PCALL PCALL_LIB "repeat" REPEAT_LOOP 
+// RETF RETP "while" "case" "goto" "if" "on_ioerror" "switch" DEC INC 
 const antlr::BitSet GDLInterpreter::_tokenSet_0(_tokenSet_0_data_,8);
-const unsigned long GDLInterpreter::_tokenSet_1_data_[] = { 1971388832UL, 12683520UL, 27UL, 786432UL, 0UL, 16777216UL, 16UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
-// ASSIGN ASSIGN_REPLACE ARRAYDEF ARRAYEXPR CONSTANT DEREF EXPR FCALL FCALL_LIB 
-// FCALL_LIB_RETNEW MFCALL MFCALL_PARENT NSTRUC NSTRUC_REF POSTDEC POSTINC 
-// STRUC SYSVAR VAR VARPTR DEC INC DOT QUESTION 
+const unsigned long GDLInterpreter::_tokenSet_1_data_[] = { 738853792UL, 3246981232UL, 27648UL, 402653184UL, 0UL, 0UL, 8194UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+// ASSIGN ASSIGN_REPLACE ASSIGN_ARRAYEXPR_MFCALL ARRAYDEF ARRAYEXPR ARRAYEXPR_MFCALL 
+// CONSTANT DEREF EXPR FCALL FCALL_LIB FCALL_LIB_RETNEW MFCALL MFCALL_PARENT 
+// NSTRUC NSTRUC_REF POSTDEC POSTINC STRUC SYSVAR VAR VARPTR DEC INC DOT 
+// QUESTION 
 const antlr::BitSet GDLInterpreter::_tokenSet_1(_tokenSet_1_data_,16);
-const unsigned long GDLInterpreter::_tokenSet_2_data_[] = { 897647008UL, 12683520UL, 27UL, 786432UL, 0UL, 16777216UL, 16UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
-// ASSIGN ASSIGN_REPLACE ARRAYDEF ARRAYEXPR CONSTANT DEREF EXPR FCALL FCALL_LIB 
-// MFCALL MFCALL_PARENT NSTRUC NSTRUC_REF POSTDEC POSTINC STRUC SYSVAR 
-// VAR VARPTR DEC INC DOT QUESTION 
-const antlr::BitSet GDLInterpreter::_tokenSet_2(_tokenSet_2_data_,16);
 
 
Only in gdl-0.9rc4/src: GDLInterpreter.cvs.cpp
Only in gdl-0.9rc4/src: GDLInterpreterHack.cpp
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/GDLInterpreter.hpp cvs/gdl/src/GDLInterpreter.hpp
--- gdl-0.9rc4/src/GDLInterpreter.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/GDLInterpreter.hpp	2010-05-21 10:23:54.437967544 -0600
@@ -33,6 +33,7 @@
 // print out AST tree
 //#define GDL_DEBUG
 //#undef GDL_DEBUG
+//#define GDL_DEBUG_HEAP
 
 
 class CUSTOM_API GDLInterpreter : public antlr::TreeParser, public GDLInterpreterTokenTypes
@@ -50,23 +51,35 @@
     friend class NSTRUCNode;
     friend class NSTRUC_REFNode;
     friend class ASSIGNNode;
+    friend class ASSIGN_ARRAYEXPR_MFCALLNode;
     friend class ASSIGN_REPLACENode;
-friend class PCALL_LIBNode;//: public CommandNode
-friend class MPCALLNode;//: public CommandNode
-friend class MPCALL_PARENTNode;//: public CommandNode
-friend class PCALLNode;//: public CommandNode
-
-  friend class KEYDEFNode;
-  friend class KEYDEF_REFNode;
-  friend class KEYDEF_REF_CHECKNode;
-  friend class KEYDEF_REF_EXPRNode;
-  friend class REFNode;
-  friend class REF_CHECKNode;
-  friend class REF_EXPRNode;
-  friend class ParameterNode;
+    friend class PCALL_LIBNode;//: public CommandNode
+    friend class MPCALLNode;//: public CommandNode
+    friend class MPCALL_PARENTNode;//: public CommandNode
+    friend class PCALLNode;//: public CommandNode
+    friend class RETFNode;
+    friend class RETPNode;
+    friend class FORNode;
+    friend class FOR_LOOPNode;
+    friend class FOREACHNode;
+    friend class FOREACH_LOOPNode;
+    friend class FOR_STEPNode;
+    friend class FOR_STEP_LOOPNode;
+    
+    friend class KEYDEFNode;
+    friend class KEYDEF_REFNode;
+    friend class KEYDEF_REF_CHECKNode;
+    friend class KEYDEF_REF_EXPRNode;
+    friend class REFNode;
+    friend class REF_CHECKNode;
+    friend class REF_EXPRNode;
+    friend class ParameterNode;
 
 public: 
+
 //     RetCode returnCode;    
+    ProgNodeP GetNULLProgNodeP() const { return NULLProgNodeP;}
+
 
     void SetRetTree( ProgNodeP rT)
     {
@@ -77,13 +90,13 @@
 //         this->returnCode = rC;
 //     }
     
-    enum RetCode {
-        RC_OK=0,
-        RC_BREAK,
-        RC_CONTINUE,
-        RC_RETURN, 
-        RC_ABORT, // checked as retCode >= RC_RETURN
-    };  
+//     enum RetCode {
+//         RC_OK=0,
+//         RC_BREAK,
+//         RC_CONTINUE,
+//         RC_RETURN, 
+//         RC_ABORT, // checked as retCode >= RC_RETURN
+//     };  
 
     // code in: dinterpreter.cpp
     static bool SearchCompilePro(const std::string& pro);
@@ -94,9 +107,12 @@
     DStructGDL* ObjectStruct( BaseGDL* self, ProgNodeP mp);
     DStructGDL* ObjectStructCheckAccess( BaseGDL* self, ProgNodeP mp);
 
-private: 
     // code in: dinterpreter.cpp
     static void SetFunIx( ProgNodeP f); // triggers read/compile
+
+
+private: 
+
     static void SetProIx( ProgNodeP f); // triggers read/compile
     static void AdjustTypes( BaseGDL*&, BaseGDL*&);
 
@@ -132,14 +148,24 @@
     
     // code in: dinterpreter.cpp
 //    static bool CompleteFileName(std::string& fn); -> str.cpp
-    static bool CompileFile(const std::string& f, const std::string& untilPro=""); 
+
     BaseGDL*  returnValue;  // holding the return value for functions
     BaseGDL** returnValueL; // holding the return value for l_functions
 
     bool interruptEnable;
 
-    typedef std::map<SizeT, BaseGDL*> HeapT;
-    typedef std::map<SizeT, DStructGDL*> ObjHeapT;
+public:
+    static bool CompileFile(const std::string& f, const std::string& untilPro=""); 
+
+    typedef RefHeap<BaseGDL> RefBaseGDL;
+    typedef RefHeap<DStructGDL> RefDStructGDL;
+
+    typedef std::map<SizeT, RefBaseGDL> HeapT;
+    typedef std::map<SizeT, RefDStructGDL> ObjHeapT;
+
+protected:
+//     typedef std::map<SizeT, BaseGDL*> HeapT;
+//     typedef std::map<SizeT, DStructGDL*> ObjHeapT;
 
     // the following must be all static because several interpreter might be active
     // the heap for all dynamic variables
@@ -168,7 +194,7 @@
         SizeT tmpIx=objHeapIx;
         for( SizeT i=0; i<n; i++)
         objHeap.insert( objHeap.end(),
-            std::pair<SizeT, DStructGDL*>( objHeapIx++, var));
+            std::pair<SizeT, RefDStructGDL>( objHeapIx++, (DStructGDL*)var));
         return tmpIx;
     }
     SizeT NewHeap( SizeT n=1, BaseGDL* var=NULL)
@@ -176,7 +202,7 @@
         SizeT tmpIx=heapIx;
         for( SizeT i=0; i<n; i++)
         heap.insert( heap.end(),
-            std::pair<SizeT, BaseGDL*>( heapIx++, var));
+            std::pair<SizeT, RefBaseGDL>( heapIx++, var));
         return tmpIx;
     }
     static void FreeObjHeap( DObj id)
@@ -186,11 +212,16 @@
             ObjHeapT::iterator it=objHeap.find( id);
             if  ( it != objHeap.end()) 
             { 
-                delete (*it).second;
+                delete (*it).second.get();
                 objHeap.erase( id);
             }
         }
     }
+    static void FreeObjHeapDirect( DObj id, ObjHeapT::iterator it)
+    {
+        delete (*it).second.get();
+        objHeap.erase( id);
+    }
     static void FreeHeap( DPtr id)
     {
         if( id != 0)
@@ -198,11 +229,16 @@
                 HeapT::iterator it=heap.find( id);
                 if( it != heap.end()) 
                     { 
-                        delete (*it).second;
+                        delete (*it).second.get();
                         heap.erase( id); 
                     }
             }
     }
+    static void FreeHeapDirect( DPtr id, HeapT::iterator it)
+    {
+        delete (*it).second.get();
+        heap.erase( id); 
+    }
 
    static void FreeHeap( DPtrGDL* p)
     {
@@ -214,19 +250,176 @@
        }
     }
 
+   static void DecRef( DPtr id)
+    {
+        if( id != 0)
+            {
+#ifdef GDL_DEBUG_HEAP
+                std::cout << "-- <PtrHeapVar" << id << ">" << std::endl; 
+#endif
+                HeapT::iterator it=heap.find( id);
+                if( it != heap.end()) 
+                    { 
+                        if( (*it).second.Dec())
+                            {
+                                std::cout << "Out of scope (garbage collected): <PtrHeapVar" << id 
+                                          << ">"
+                                          << " at: " << callStack.back()->GetProName()
+                                          << "  line: " << callStack.back()->GetLineNumber()
+                                          << std::endl; 
+                                FreeHeapDirect( id, it);
+                            }
+#ifdef GDL_DEBUG_HEAP
+                        else
+std::cout << "<PtrHeapVar" << id << "> = " << (*it).second.Count() << std::endl; 
+#endif
+                    }
+            }
+    }
+   static void DecRef( DPtrGDL* p)
+    {
+        SizeT nEl=p->N_Elements();
+        for( SizeT ix=0; ix < nEl; ix++)
+        {
+            DPtr id= (*p)[ix];
+            DecRef( id);
+       }
+    }
+   static void DecRefObj( DObj id)
+    {
+        if( id != 0)
+            {
+#ifdef GDL_DEBUG_HEAP
+std::cout << "-- <ObjHeapVar" << id << ">" << std::endl; 
+#endif
+                ObjHeapT::iterator it=objHeap.find( id);
+                if( it != objHeap.end()) 
+                    { 
+                       if( (*it).second.Dec())
+                           {
+                               std::cout << "Out of scope (garbage collected): <ObjHeapVar" << id 
+                                          << ">"
+                                          << " at: " << callStack.back()->GetProName()
+                                          << "  line: " << callStack.back()->GetLineNumber()
+                                          << std::endl; 
+                               callStack.back()->ObjCleanup( id);
+//                             FreeObjHeapDirect( id, it);
+                           }
+#ifdef GDL_DEBUG_HEAP
+                        else
+std::cout << "<ObjHeapVar" << id << "> = " << (*it).second.Count() << std::endl; 
+#endif
+                        
+                     }
+            }
+    }
+   static void DecRefObj( DObjGDL* p)
+    {
+        SizeT nEl=p->N_Elements();
+        for( SizeT ix=0; ix < nEl; ix++)
+        {
+            DObj id= (*p)[ix];
+            DecRefObj( id);
+       }
+    }
+   static void IncRef( DPtr id)
+    {
+        if( id != 0)
+            {
+#ifdef GDL_DEBUG_HEAP
+std::cout << "++ <PtrHeapVar" << id << ">" << std::endl; 
+#endif
+                HeapT::iterator it=heap.find( id);
+                if( it != heap.end()) 
+                    { 
+                        (*it).second.Inc(); 
+#ifdef GDL_DEBUG_HEAP
+std::cout << "<PtrHeapVar" << id << "> = " << (*it).second.Count() << std::endl; 
+#endif
+                    }
+            }
+    }
+   static void AddRef( DPtr id, SizeT add)
+    {
+        if( id != 0)
+            {
+#ifdef GDL_DEBUG_HEAP
+std::cout << add << " + <PtrHeapVar" << id << ">" << std::endl; 
+#endif
+                HeapT::iterator it=heap.find( id);
+                if( it != heap.end()) 
+                    { 
+                        (*it).second.Add(add); 
+                    }
+            }
+    }
+   static void IncRef( DPtrGDL* p)
+    {
+        SizeT nEl=p->N_Elements();
+        for( SizeT ix=0; ix < nEl; ix++)
+        {
+            DPtr id= (*p)[ix];
+            IncRef( id);
+       }
+    }
+   static void IncRefObj( DObj id)
+    {
+        if( id != 0)
+            {
+#ifdef GDL_DEBUG_HEAP
+std::cout << "++ <ObjHeapVar" << id << ">" << std::endl; 
+#endif
+                ObjHeapT::iterator it=objHeap.find( id);
+                if( it != objHeap.end()) 
+                    { 
+                        (*it).second.Inc(); 
+                    }
+            }
+    }
+   static void AddRefObj( DObj id, SizeT add)
+    {
+        if( id != 0)
+            {
+#ifdef GDL_DEBUG_HEAP
+std::cout << add << " + <ObjHeapVar" << id << ">" << std::endl; 
+#endif
+                ObjHeapT::iterator it=objHeap.find( id);
+                if( it != objHeap.end()) 
+                    { 
+                        (*it).second.Add(add); 
+                    }
+            }
+    }
+   static void IncRefObj( DObjGDL* p)
+    {
+        SizeT nEl=p->N_Elements();
+        for( SizeT ix=0; ix < nEl; ix++)
+        {
+            DObj id= (*p)[ix];
+            IncRefObj( id);
+       }
+    }
+
     class HeapException {};
 
     static BaseGDL*& GetHeap( DPtr ID)
     {
         HeapT::iterator it=heap.find( ID);
         if( it == heap.end()) throw HeapException();
-        return it->second;
+        return it->second.get();
     }
     static DStructGDL*& GetObjHeap( DObj ID)
     {
         ObjHeapT::iterator it=objHeap.find( ID);
         if( it == objHeap.end()) throw HeapException();
-        return it->second;
+        return it->second.get();
+    }
+    static DStructGDL*& GetObjHeap( DObj ID, ObjHeapT::iterator& it)
+    {
+//         ObjHeapT::iterator it=objHeap.find( ID);
+        it=objHeap.find( ID);
+        if( it == objHeap.end()) throw HeapException();
+        return it->second.get();
     }
 
     static bool PtrValid( DPtr ID)
@@ -240,6 +433,15 @@
         return heap.size();
     }
 
+    static DPtr FindInHeap( BaseGDL** p)
+    {
+        for( HeapT::iterator it=heap.begin(); it != heap.end(); ++it)
+        {
+            if( &it->second.get() == p)
+                return it->first;
+        }
+        return 0;
+    }
     static DPtrGDL* GetAllHeap()
     {
         SizeT nEl = heap.size();
@@ -248,6 +450,21 @@
         SizeT i=0;
         for( HeapT::iterator it=heap.begin(); it != heap.end(); ++it)
         {
+            IncRef( it->first);
+            (*ret)[ i++] = it->first;
+        }
+        return ret;
+    }
+
+    // no ref counting here
+    static std::vector<DPtr>* GetAllHeapSTL()
+    {
+        SizeT nEl = heap.size();
+        if( nEl == 0) return new std::vector<DPtr>();
+        std::vector<DPtr>* ret = new std::vector<DPtr>( nEl);
+        SizeT i=0;
+        for( HeapT::iterator it=heap.begin(); it != heap.end(); ++it)
+        {
             (*ret)[ i++] = it->first;
         }
         return ret;
@@ -264,6 +481,15 @@
         return objHeap.size();
     }
 
+//     static DObj FindInObjHeap( BaseGDL** p)
+//     {
+//         for( ObjHeapT::iterator it=objHeap.begin(); it != objHeap.end(); ++it)
+//         {
+//             if( &it->second == reinterpret_cast<DStructGDL**>(p))
+//                 return it->first;
+//         }
+//         return 0;
+//     }
     static DObjGDL* GetAllObjHeap()
     {
         SizeT nEl = objHeap.size();
@@ -272,6 +498,21 @@
         SizeT i=0;
         for( ObjHeapT::iterator it=objHeap.begin(); it != objHeap.end(); ++it)
         {
+            IncRefObj( it->first);
+            (*ret)[ i++] = it->first;
+        }
+        return ret;
+    }
+
+    // no ref counting here
+    static std::vector<DObj>* GetAllObjHeapSTL()
+    {
+        SizeT nEl = objHeap.size();
+        if( nEl == 0) return new std::vector<DObj>();
+        std::vector<DObj>* ret = new std::vector<DObj>( nEl);
+        SizeT i=0;
+        for( ObjHeapT::iterator it=objHeap.begin(); it != objHeap.end(); ++it)
+        {
             (*ret)[ i++] = it->first;
         }
         return ret;
@@ -285,7 +526,12 @@
 
     static const std::string Name( BaseGDL** p) // const
     {
-        return "<(Find name not implemented yet)>";
+        assert( *p == NULL);
+        DPtr h = FindInHeap( p);
+        if( h != 0) return std::string("<PtrHeapVar")+i2s(h)+">";
+//         DObj o = FindInObjHeap( p);
+//         if( o != 0) return std::string("<ObjHeapVar")+i2s(o)+">";
+        return "<(ptr to undefined expression not found on the heap)>";
     }
 
     // compiler (lexer, parser, treeparser) def in dinterpreter.cpp
@@ -439,29 +685,30 @@
 	{
 		return GDLInterpreter::tokenNames;
 	}
-	public:  GDLInterpreter::RetCode  interactive(ProgNodeP _t);
-	public:  GDLInterpreter::RetCode  statement(ProgNodeP _t);
-	public:  GDLInterpreter::RetCode  execute(ProgNodeP _t);
-	public:  GDLInterpreter::RetCode  statement_list(ProgNodeP _t);
+	public:  RetCode  interactive(ProgNodeP _t);
+	public:  RetCode  statement(ProgNodeP _t);
+	public:  RetCode  execute(ProgNodeP _t);
+	public:  RetCode  statement_list(ProgNodeP _t);
 	public:  BaseGDL*  call_fun(ProgNodeP _t);
 	public:  BaseGDL**  call_lfun(ProgNodeP _t);
 	public: void call_pro(ProgNodeP _t);
-	public:  GDLInterpreter::RetCode  for_statement(ProgNodeP _t);
-	public:  GDLInterpreter::RetCode  repeat_statement(ProgNodeP _t);
-	public:  GDLInterpreter::RetCode  while_statement(ProgNodeP _t);
-	public:  GDLInterpreter::RetCode  if_statement(ProgNodeP _t);
-	public:  GDLInterpreter::RetCode  if_else_statement(ProgNodeP _t);
-	public:  GDLInterpreter::RetCode  case_statement(ProgNodeP _t);
-	public:  GDLInterpreter::RetCode  switch_statement(ProgNodeP _t);
-	public:  GDLInterpreter::RetCode  block(ProgNodeP _t);
-	public:  GDLInterpreter::RetCode  jump_statement(ProgNodeP _t);
+	public:  RetCode  block(ProgNodeP _t);
+	public:  RetCode  switch_statement(ProgNodeP _t);
 	public: BaseGDL*  expr(ProgNodeP _t);
-	public: BaseGDL**  l_simple_var(ProgNodeP _t);
-	public: BaseGDL**  l_ret_expr(ProgNodeP _t);
+	public:  RetCode  case_statement(ProgNodeP _t);
+	public:  RetCode  repeat_statement(ProgNodeP _t);
+	public:  RetCode  repeat_loop_statement(ProgNodeP _t);
+	public:  RetCode  while_statement(ProgNodeP _t);
+	public:  RetCode  for_statement(ProgNodeP _t);
+	public:  RetCode  foreach_statement(ProgNodeP _t);
+	public:  RetCode  if_statement(ProgNodeP _t);
+	public:  RetCode  if_else_statement(ProgNodeP _t);
 	public: BaseGDL**  l_deref(ProgNodeP _t);
+	public: BaseGDL**  l_ret_expr(ProgNodeP _t);
+	public:  BaseGDL**  l_arrayexpr_mfcall_as_mfcall(ProgNodeP _t);
 	public:  BaseGDL**  l_function_call(ProgNodeP _t);
 	public: BaseGDL*  tmp_expr(ProgNodeP _t);
-	public: BaseGDL*  check_expr(ProgNodeP _t);
+	public:  BaseGDL*  lib_function_call(ProgNodeP _t);
 	public: BaseGDL*  r_expr(ProgNodeP _t);
 	public: BaseGDL*  constant_nocopy(ProgNodeP _t);
 	public: BaseGDL*  l_decinc_indexable_expr(ProgNodeP _t,
@@ -490,10 +737,17 @@
 	public: BaseGDL**  l_expr(ProgNodeP _t,
 		BaseGDL* right
 	);
+	public: BaseGDL**  l_simple_var(ProgNodeP _t);
+	public: void parameter_def(ProgNodeP _t,
+		EnvBaseT* actEnv
+	);
 	public: BaseGDL**  l_indexable_expr(ProgNodeP _t);
 	public: BaseGDL**  l_array_expr(ProgNodeP _t,
 		BaseGDL* right
 	);
+	public: BaseGDL**  l_arrayexpr_mfcall(ProgNodeP _t,
+		BaseGDL* right
+	);
 	public: BaseGDL*  array_expr(ProgNodeP _t);
 	public: void tag_expr(ProgNodeP _t,
 		DotAccessDescT* aD
@@ -509,14 +763,16 @@
 	public: BaseGDL*  assign_expr(ProgNodeP _t);
 	public:  BaseGDL*  function_call(ProgNodeP _t);
 	public:  BaseGDL*  lib_function_call_retnew(ProgNodeP _t);
-	public:  BaseGDL*  lib_function_call(ProgNodeP _t);
 	public: BaseGDL*  constant(ProgNodeP _t);
 	public: BaseGDL*  simple_var(ProgNodeP _t);
 	public: BaseGDL*  sys_var(ProgNodeP _t);
-	public: void parameter_def(ProgNodeP _t,
-		EnvBaseT* actEnv
+	public: BaseGDL**  l_arrayexpr_mfcall_as_arrayexpr(ProgNodeP _t,
+		BaseGDL* right
 	);
 	public:  BaseGDL**  ref_parameter(ProgNodeP _t);
+	public: void parameter_def_n_elements(ProgNodeP _t,
+		EnvBaseT* actEnv
+	);
 public:
 	antlr::RefAST getAST()
 	{
@@ -529,10 +785,10 @@
 private:
 	static const char* tokenNames[];
 #ifndef NO_STATIC_CONSTS
-	static const int NUM_TOKENS = 216;
+	static const int NUM_TOKENS = 225;
 #else
 	enum {
-		NUM_TOKENS = 216
+		NUM_TOKENS = 225
 	};
 #endif
 	
@@ -540,8 +796,6 @@
 	static const antlr::BitSet _tokenSet_0;
 	static const unsigned long _tokenSet_1_data_[];
 	static const antlr::BitSet _tokenSet_1;
-	static const unsigned long _tokenSet_2_data_[];
-	static const antlr::BitSet _tokenSet_2;
 };
 
 #endif /*INC_GDLInterpreter_hpp_*/
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/GDLInterpreterTokenTypes.hpp cvs/gdl/src/GDLInterpreterTokenTypes.hpp
--- gdl-0.9rc4/src/GDLInterpreterTokenTypes.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/GDLInterpreterTokenTypes.hpp	2010-04-22 09:50:40.000000000 -0600
@@ -16,214 +16,223 @@
 		ASSIGN = 5,
 		ASSIGN_INPLACE = 6,
 		ASSIGN_REPLACE = 7,
-		ARRAYDEF = 8,
-		ARRAYDEF_CONST = 9,
-		ARRAYIX = 10,
-		ARRAYIX_ALL = 11,
-		ARRAYIX_ORANGE = 12,
-		ARRAYIX_RANGE = 13,
-		ARRAYIX_ORANGE_S = 14,
-		ARRAYIX_RANGE_S = 15,
-		ARRAYEXPR = 16,
-		ARRAYEXPR_FN = 17,
-		BLOCK = 18,
-		BREAK = 19,
-		CONTINUE = 20,
-		COMMONDECL = 21,
-		COMMONDEF = 22,
-		CONSTANT = 23,
-		DEREF = 24,
-		ELSEBLK = 25,
-		EXPR = 26,
-		FOR_STEP = 27,
-		FCALL = 28,
-		FCALL_LIB = 29,
-		FCALL_LIB_RETNEW = 30,
-		IF_ELSE = 31,
-		KEYDECL = 32,
-		KEYDEF = 33,
-		KEYDEF_REF = 34,
-		KEYDEF_REF_CHECK = 35,
-		KEYDEF_REF_EXPR = 36,
-		LABEL = 37,
-		MPCALL = 38,
-		MPCALL_PARENT = 39,
-		MFCALL = 40,
-		MFCALL_LIB = 41,
-		MFCALL_LIB_RETNEW = 42,
-		MFCALL_PARENT = 43,
-		MFCALL_PARENT_LIB = 44,
-		MFCALL_PARENT_LIB_RETNEW = 45,
-		NOP = 46,
-		NSTRUC = 47,
-		NSTRUC_REF = 48,
-		ON_IOERROR_NULL = 49,
-		PCALL = 50,
-		PCALL_LIB = 51,
-		PARADECL = 52,
-		PARAEXPR = 53,
-		POSTDEC = 54,
-		POSTINC = 55,
-		DECSTATEMENT = 56,
-		INCSTATEMENT = 57,
-		REF = 58,
-		REF_CHECK = 59,
-		REF_EXPR = 60,
-		RETURN = 61,
-		RETF = 62,
-		RETP = 63,
-		STRUC = 64,
-		SYSVAR = 65,
-		UMINUS = 66,
-		VAR = 67,
-		VARPTR = 68,
-		IDENTIFIER = 69,
-		AND_OP = 70,
-		BEGIN = 71,
-		CASE = 72,
-		COMMON = 73,
-		COMPILE_OPT = 74,
-		DO = 75,
-		ELSE = 76,
-		END = 77,
-		ENDCASE = 78,
-		ENDELSE = 79,
-		ENDFOR = 80,
-		ENDIF = 81,
-		ENDREP = 82,
-		ENDSWITCH = 83,
-		ENDWHILE = 84,
-		EQ_OP = 85,
-		FOR = 86,
-		FORWARD = 87,
-		FUNCTION = 88,
-		GE_OP = 89,
-		GOTO = 90,
-		GT_OP = 91,
-		IF = 92,
-		INHERITS = 93,
-		LE_OP = 94,
-		LT_OP = 95,
-		MOD_OP = 96,
-		NE_OP = 97,
-		NOT_OP = 98,
-		OF = 99,
-		ON_IOERROR = 100,
-		OR_OP = 101,
-		PRO = 102,
-		REPEAT = 103,
-		SWITCH = 104,
-		THEN = 105,
-		UNTIL = 106,
-		WHILE = 107,
-		XOR_OP = 108,
-		METHOD = 109,
-		COMMA = 110,
-		COLON = 111,
-		END_U = 112,
-		EQUAL = 113,
-		DEC = 114,
-		INC = 115,
-		AND_OP_EQ = 116,
-		ASTERIX_EQ = 117,
-		EQ_OP_EQ = 118,
-		GE_OP_EQ = 119,
-		GTMARK_EQ = 120,
-		GT_OP_EQ = 121,
-		LE_OP_EQ = 122,
-		LTMARK_EQ = 123,
-		LT_OP_EQ = 124,
-		MATRIX_OP1_EQ = 125,
-		MATRIX_OP2_EQ = 126,
-		MINUS_EQ = 127,
-		MOD_OP_EQ = 128,
-		NE_OP_EQ = 129,
-		OR_OP_EQ = 130,
-		PLUS_EQ = 131,
-		POW_EQ = 132,
-		SLASH_EQ = 133,
-		XOR_OP_EQ = 134,
-		MEMBER = 135,
-		LBRACE = 136,
-		RBRACE = 137,
-		SLASH = 138,
-		LSQUARE = 139,
-		RSQUARE = 140,
-		SYSVARNAME = 141,
-		EXCLAMATION = 142,
-		LCURLY = 143,
-		RCURLY = 144,
-		CONSTANT_HEX_BYTE = 145,
-		CONSTANT_HEX_LONG = 146,
-		CONSTANT_HEX_LONG64 = 147,
-		CONSTANT_HEX_INT = 148,
-		CONSTANT_HEX_I = 149,
-		CONSTANT_HEX_ULONG = 150,
-		CONSTANT_HEX_ULONG64 = 151,
-		CONSTANT_HEX_UI = 152,
-		CONSTANT_HEX_UINT = 153,
-		CONSTANT_BYTE = 154,
-		CONSTANT_LONG = 155,
-		CONSTANT_LONG64 = 156,
-		CONSTANT_INT = 157,
-		CONSTANT_I = 158,
-		CONSTANT_ULONG = 159,
-		CONSTANT_ULONG64 = 160,
-		CONSTANT_UI = 161,
-		CONSTANT_UINT = 162,
-		CONSTANT_OCT_BYTE = 163,
-		CONSTANT_OCT_LONG = 164,
-		CONSTANT_OCT_LONG64 = 165,
-		CONSTANT_OCT_INT = 166,
-		CONSTANT_OCT_I = 167,
-		CONSTANT_OCT_ULONG = 168,
-		CONSTANT_OCT_ULONG64 = 169,
-		CONSTANT_OCT_UI = 170,
-		CONSTANT_OCT_UINT = 171,
-		CONSTANT_FLOAT = 172,
-		CONSTANT_DOUBLE = 173,
-		CONSTANT_BIN_BYTE = 174,
-		CONSTANT_BIN_LONG = 175,
-		CONSTANT_BIN_LONG64 = 176,
-		CONSTANT_BIN_INT = 177,
-		CONSTANT_BIN_I = 178,
-		CONSTANT_BIN_ULONG = 179,
-		CONSTANT_BIN_ULONG64 = 180,
-		CONSTANT_BIN_UI = 181,
-		CONSTANT_BIN_UINT = 182,
-		ASTERIX = 183,
-		DOT = 184,
-		STRING_LITERAL = 185,
-		POW = 186,
-		MATRIX_OP1 = 187,
-		MATRIX_OP2 = 188,
-		PLUS = 189,
-		MINUS = 190,
-		LTMARK = 191,
-		GTMARK = 192,
-		LOG_NEG = 193,
-		LOG_AND = 194,
-		LOG_OR = 195,
-		QUESTION = 196,
-		STRING = 197,
-		INCLUDE = 198,
-		EOL = 199,
-		W = 200,
-		D = 201,
-		L = 202,
-		H = 203,
-		O = 204,
-		B = 205,
-		EXP = 206,
-		DBL_E = 207,
-		DBL = 208,
-		CONSTANT_OR_STRING_LITERAL = 209,
-		COMMENT = 210,
-		END_MARKER = 211,
-		WHITESPACE = 212,
-		SKIP_LINES = 213,
-		CONT_STATEMENT = 214,
-		END_OF_LINE = 215,
+		ASSIGN_ARRAYEXPR_MFCALL = 8,
+		ARRAYDEF = 9,
+		ARRAYDEF_CONST = 10,
+		ARRAYIX = 11,
+		ARRAYIX_ALL = 12,
+		ARRAYIX_ORANGE = 13,
+		ARRAYIX_RANGE = 14,
+		ARRAYIX_ORANGE_S = 15,
+		ARRAYIX_RANGE_S = 16,
+		ARRAYEXPR = 17,
+		ARRAYEXPR_FN = 18,
+		ARRAYEXPR_MFCALL = 19,
+		BLOCK = 20,
+		BREAK = 21,
+		CSBLOCK = 22,
+		CONTINUE = 23,
+		COMMONDECL = 24,
+		COMMONDEF = 25,
+		CONSTANT = 26,
+		DEREF = 27,
+		ELSEBLK = 28,
+		EXPR = 29,
+		FOR = 30,
+		FOR_STEP = 31,
+		FOREACH = 32,
+		FOR_LOOP = 33,
+		FOR_STEP_LOOP = 34,
+		FOREACH_LOOP = 35,
+		FCALL = 36,
+		FCALL_LIB = 37,
+		FCALL_LIB_RETNEW = 38,
+		IF_ELSE = 39,
+		KEYDECL = 40,
+		KEYDEF = 41,
+		KEYDEF_REF = 42,
+		KEYDEF_REF_CHECK = 43,
+		KEYDEF_REF_EXPR = 44,
+		LABEL = 45,
+		MPCALL = 46,
+		MPCALL_PARENT = 47,
+		MFCALL = 48,
+		MFCALL_LIB = 49,
+		MFCALL_LIB_RETNEW = 50,
+		MFCALL_PARENT = 51,
+		MFCALL_PARENT_LIB = 52,
+		MFCALL_PARENT_LIB_RETNEW = 53,
+		NOP = 54,
+		NSTRUC = 55,
+		NSTRUC_REF = 56,
+		ON_IOERROR_NULL = 57,
+		PCALL = 58,
+		PCALL_LIB = 59,
+		PARADECL = 60,
+		PARAEXPR = 61,
+		POSTDEC = 62,
+		POSTINC = 63,
+		DECSTATEMENT = 64,
+		INCSTATEMENT = 65,
+		REF = 66,
+		REF_CHECK = 67,
+		REF_EXPR = 68,
+		REPEAT = 69,
+		REPEAT_LOOP = 70,
+		RETURN = 71,
+		RETF = 72,
+		RETP = 73,
+		STRUC = 74,
+		SYSVAR = 75,
+		UMINUS = 76,
+		VAR = 77,
+		VARPTR = 78,
+		WHILE = 79,
+		IDENTIFIER = 80,
+		AND_OP = 81,
+		BEGIN = 82,
+		CASE = 83,
+		COMMON = 84,
+		COMPILE_OPT = 85,
+		DO = 86,
+		ELSE = 87,
+		END = 88,
+		ENDCASE = 89,
+		ENDELSE = 90,
+		ENDFOR = 91,
+		ENDFOREACH = 92,
+		ENDIF = 93,
+		ENDREP = 94,
+		ENDSWITCH = 95,
+		ENDWHILE = 96,
+		EQ_OP = 97,
+		FORWARD = 98,
+		FUNCTION = 99,
+		GE_OP = 100,
+		GOTO = 101,
+		GT_OP = 102,
+		IF = 103,
+		INHERITS = 104,
+		LE_OP = 105,
+		LT_OP = 106,
+		MOD_OP = 107,
+		NE_OP = 108,
+		NOT_OP = 109,
+		OF = 110,
+		ON_IOERROR = 111,
+		OR_OP = 112,
+		PRO = 113,
+		SWITCH = 114,
+		THEN = 115,
+		UNTIL = 116,
+		XOR_OP = 117,
+		METHOD = 118,
+		COMMA = 119,
+		COLON = 120,
+		END_U = 121,
+		EQUAL = 122,
+		DEC = 123,
+		INC = 124,
+		AND_OP_EQ = 125,
+		ASTERIX_EQ = 126,
+		EQ_OP_EQ = 127,
+		GE_OP_EQ = 128,
+		GTMARK_EQ = 129,
+		GT_OP_EQ = 130,
+		LE_OP_EQ = 131,
+		LTMARK_EQ = 132,
+		LT_OP_EQ = 133,
+		MATRIX_OP1_EQ = 134,
+		MATRIX_OP2_EQ = 135,
+		MINUS_EQ = 136,
+		MOD_OP_EQ = 137,
+		NE_OP_EQ = 138,
+		OR_OP_EQ = 139,
+		PLUS_EQ = 140,
+		POW_EQ = 141,
+		SLASH_EQ = 142,
+		XOR_OP_EQ = 143,
+		MEMBER = 144,
+		LBRACE = 145,
+		RBRACE = 146,
+		SLASH = 147,
+		LSQUARE = 148,
+		RSQUARE = 149,
+		SYSVARNAME = 150,
+		EXCLAMATION = 151,
+		LCURLY = 152,
+		RCURLY = 153,
+		CONSTANT_HEX_BYTE = 154,
+		CONSTANT_HEX_LONG = 155,
+		CONSTANT_HEX_LONG64 = 156,
+		CONSTANT_HEX_INT = 157,
+		CONSTANT_HEX_I = 158,
+		CONSTANT_HEX_ULONG = 159,
+		CONSTANT_HEX_ULONG64 = 160,
+		CONSTANT_HEX_UI = 161,
+		CONSTANT_HEX_UINT = 162,
+		CONSTANT_BYTE = 163,
+		CONSTANT_LONG = 164,
+		CONSTANT_LONG64 = 165,
+		CONSTANT_INT = 166,
+		CONSTANT_I = 167,
+		CONSTANT_ULONG = 168,
+		CONSTANT_ULONG64 = 169,
+		CONSTANT_UI = 170,
+		CONSTANT_UINT = 171,
+		CONSTANT_OCT_BYTE = 172,
+		CONSTANT_OCT_LONG = 173,
+		CONSTANT_OCT_LONG64 = 174,
+		CONSTANT_OCT_INT = 175,
+		CONSTANT_OCT_I = 176,
+		CONSTANT_OCT_ULONG = 177,
+		CONSTANT_OCT_ULONG64 = 178,
+		CONSTANT_OCT_UI = 179,
+		CONSTANT_OCT_UINT = 180,
+		CONSTANT_FLOAT = 181,
+		CONSTANT_DOUBLE = 182,
+		CONSTANT_BIN_BYTE = 183,
+		CONSTANT_BIN_LONG = 184,
+		CONSTANT_BIN_LONG64 = 185,
+		CONSTANT_BIN_INT = 186,
+		CONSTANT_BIN_I = 187,
+		CONSTANT_BIN_ULONG = 188,
+		CONSTANT_BIN_ULONG64 = 189,
+		CONSTANT_BIN_UI = 190,
+		CONSTANT_BIN_UINT = 191,
+		ASTERIX = 192,
+		DOT = 193,
+		STRING_LITERAL = 194,
+		POW = 195,
+		MATRIX_OP1 = 196,
+		MATRIX_OP2 = 197,
+		PLUS = 198,
+		MINUS = 199,
+		LTMARK = 200,
+		GTMARK = 201,
+		LOG_NEG = 202,
+		LOG_AND = 203,
+		LOG_OR = 204,
+		QUESTION = 205,
+		STRING = 206,
+		INCLUDE = 207,
+		EOL = 208,
+		W = 209,
+		D = 210,
+		L = 211,
+		H = 212,
+		O = 213,
+		B = 214,
+		EXP = 215,
+		DBL_E = 216,
+		DBL = 217,
+		CONSTANT_OR_STRING_LITERAL = 218,
+		COMMENT = 219,
+		END_MARKER = 220,
+		WHITESPACE = 221,
+		SKIP_LINES = 222,
+		CONT_STATEMENT = 223,
+		END_OF_LINE = 224,
 		NULL_TREE_LOOKAHEAD = 3
 	};
 #ifdef __cplusplus
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/GDLInterpreterTokenTypes.txt cvs/gdl/src/GDLInterpreterTokenTypes.txt
--- gdl-0.9rc4/src/GDLInterpreterTokenTypes.txt	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/GDLInterpreterTokenTypes.txt	2010-04-22 09:50:40.000000000 -0600
@@ -4,211 +4,220 @@
 ASSIGN=5
 ASSIGN_INPLACE=6
 ASSIGN_REPLACE=7
-ARRAYDEF=8
-ARRAYDEF_CONST=9
-ARRAYIX=10
-ARRAYIX_ALL=11
-ARRAYIX_ORANGE=12
-ARRAYIX_RANGE=13
-ARRAYIX_ORANGE_S=14
-ARRAYIX_RANGE_S=15
-ARRAYEXPR=16
-ARRAYEXPR_FN=17
-BLOCK=18
-BREAK=19
-CONTINUE=20
-COMMONDECL=21
-COMMONDEF=22
-CONSTANT=23
-DEREF=24
-ELSEBLK=25
-EXPR=26
-FOR_STEP=27
-FCALL=28
-FCALL_LIB=29
-FCALL_LIB_RETNEW=30
-IF_ELSE=31
-KEYDECL=32
-KEYDEF=33
-KEYDEF_REF=34
-KEYDEF_REF_CHECK=35
-KEYDEF_REF_EXPR=36
-LABEL=37
-MPCALL=38
-MPCALL_PARENT=39
-MFCALL=40
-MFCALL_LIB=41
-MFCALL_LIB_RETNEW=42
-MFCALL_PARENT=43
-MFCALL_PARENT_LIB=44
-MFCALL_PARENT_LIB_RETNEW=45
-NOP=46
-NSTRUC=47
-NSTRUC_REF=48
-ON_IOERROR_NULL=49
-PCALL=50
-PCALL_LIB=51
-PARADECL=52
-PARAEXPR=53
-POSTDEC=54
-POSTINC=55
-DECSTATEMENT=56
-INCSTATEMENT=57
-REF=58
-REF_CHECK=59
-REF_EXPR=60
-RETURN=61
-RETF=62
-RETP=63
-STRUC=64
-SYSVAR=65
-UMINUS=66
-VAR=67
-VARPTR=68
-IDENTIFIER=69
-AND_OP="and"=70
-BEGIN="begin"=71
-CASE="case"=72
-COMMON="common"=73
-COMPILE_OPT="compile_opt"=74
-DO="do"=75
-ELSE="else"=76
-END="end"=77
-ENDCASE="endcase"=78
-ENDELSE="endelse"=79
-ENDFOR="endfor"=80
-ENDIF="endif"=81
-ENDREP="endrep"=82
-ENDSWITCH="endswitch"=83
-ENDWHILE="endwhile"=84
-EQ_OP="eq"=85
-FOR="for"=86
-FORWARD="forward_function"=87
-FUNCTION="function"=88
-GE_OP="ge"=89
-GOTO="goto"=90
-GT_OP="gt"=91
-IF="if"=92
-INHERITS="inherits"=93
-LE_OP="le"=94
-LT_OP="lt"=95
-MOD_OP="mod"=96
-NE_OP="ne"=97
-NOT_OP="not"=98
-OF="of"=99
-ON_IOERROR="on_ioerror"=100
-OR_OP="or"=101
-PRO="pro"=102
-REPEAT="repeat"=103
-SWITCH="switch"=104
-THEN="then"=105
-UNTIL="until"=106
-WHILE="while"=107
-XOR_OP="xor"=108
-METHOD=109
-COMMA=110
-COLON=111
-END_U=112
-EQUAL=113
-DEC=114
-INC=115
-AND_OP_EQ=116
-ASTERIX_EQ=117
-EQ_OP_EQ=118
-GE_OP_EQ=119
-GTMARK_EQ=120
-GT_OP_EQ=121
-LE_OP_EQ=122
-LTMARK_EQ=123
-LT_OP_EQ=124
-MATRIX_OP1_EQ=125
-MATRIX_OP2_EQ=126
-MINUS_EQ=127
-MOD_OP_EQ=128
-NE_OP_EQ=129
-OR_OP_EQ=130
-PLUS_EQ=131
-POW_EQ=132
-SLASH_EQ=133
-XOR_OP_EQ=134
-MEMBER=135
-LBRACE=136
-RBRACE=137
-SLASH=138
-LSQUARE=139
-RSQUARE=140
-SYSVARNAME=141
-EXCLAMATION=142
-LCURLY=143
-RCURLY=144
-CONSTANT_HEX_BYTE=145
-CONSTANT_HEX_LONG=146
-CONSTANT_HEX_LONG64=147
-CONSTANT_HEX_INT=148
-CONSTANT_HEX_I=149
-CONSTANT_HEX_ULONG=150
-CONSTANT_HEX_ULONG64=151
-CONSTANT_HEX_UI=152
-CONSTANT_HEX_UINT=153
-CONSTANT_BYTE=154
-CONSTANT_LONG=155
-CONSTANT_LONG64=156
-CONSTANT_INT=157
-CONSTANT_I=158
-CONSTANT_ULONG=159
-CONSTANT_ULONG64=160
-CONSTANT_UI=161
-CONSTANT_UINT=162
-CONSTANT_OCT_BYTE=163
-CONSTANT_OCT_LONG=164
-CONSTANT_OCT_LONG64=165
-CONSTANT_OCT_INT=166
-CONSTANT_OCT_I=167
-CONSTANT_OCT_ULONG=168
-CONSTANT_OCT_ULONG64=169
-CONSTANT_OCT_UI=170
-CONSTANT_OCT_UINT=171
-CONSTANT_FLOAT=172
-CONSTANT_DOUBLE=173
-CONSTANT_BIN_BYTE=174
-CONSTANT_BIN_LONG=175
-CONSTANT_BIN_LONG64=176
-CONSTANT_BIN_INT=177
-CONSTANT_BIN_I=178
-CONSTANT_BIN_ULONG=179
-CONSTANT_BIN_ULONG64=180
-CONSTANT_BIN_UI=181
-CONSTANT_BIN_UINT=182
-ASTERIX=183
-DOT=184
-STRING_LITERAL=185
-POW=186
-MATRIX_OP1=187
-MATRIX_OP2=188
-PLUS=189
-MINUS=190
-LTMARK=191
-GTMARK=192
-LOG_NEG=193
-LOG_AND=194
-LOG_OR=195
-QUESTION=196
-STRING=197
-INCLUDE=198
-EOL=199
-W=200
-D=201
-L=202
-H=203
-O=204
-B=205
-EXP=206
-DBL_E=207
-DBL=208
-CONSTANT_OR_STRING_LITERAL=209
-COMMENT=210
-END_MARKER=211
-WHITESPACE=212
-SKIP_LINES=213
-CONT_STATEMENT=214
-END_OF_LINE=215
+ASSIGN_ARRAYEXPR_MFCALL=8
+ARRAYDEF=9
+ARRAYDEF_CONST=10
+ARRAYIX=11
+ARRAYIX_ALL=12
+ARRAYIX_ORANGE=13
+ARRAYIX_RANGE=14
+ARRAYIX_ORANGE_S=15
+ARRAYIX_RANGE_S=16
+ARRAYEXPR=17
+ARRAYEXPR_FN=18
+ARRAYEXPR_MFCALL=19
+BLOCK=20
+BREAK=21
+CSBLOCK=22
+CONTINUE=23
+COMMONDECL=24
+COMMONDEF=25
+CONSTANT=26
+DEREF=27
+ELSEBLK=28
+EXPR=29
+FOR="for"=30
+FOR_STEP=31
+FOREACH="foreach"=32
+FOR_LOOP=33
+FOR_STEP_LOOP=34
+FOREACH_LOOP=35
+FCALL=36
+FCALL_LIB=37
+FCALL_LIB_RETNEW=38
+IF_ELSE=39
+KEYDECL=40
+KEYDEF=41
+KEYDEF_REF=42
+KEYDEF_REF_CHECK=43
+KEYDEF_REF_EXPR=44
+LABEL=45
+MPCALL=46
+MPCALL_PARENT=47
+MFCALL=48
+MFCALL_LIB=49
+MFCALL_LIB_RETNEW=50
+MFCALL_PARENT=51
+MFCALL_PARENT_LIB=52
+MFCALL_PARENT_LIB_RETNEW=53
+NOP=54
+NSTRUC=55
+NSTRUC_REF=56
+ON_IOERROR_NULL=57
+PCALL=58
+PCALL_LIB=59
+PARADECL=60
+PARAEXPR=61
+POSTDEC=62
+POSTINC=63
+DECSTATEMENT=64
+INCSTATEMENT=65
+REF=66
+REF_CHECK=67
+REF_EXPR=68
+REPEAT="repeat"=69
+REPEAT_LOOP=70
+RETURN=71
+RETF=72
+RETP=73
+STRUC=74
+SYSVAR=75
+UMINUS=76
+VAR=77
+VARPTR=78
+WHILE="while"=79
+IDENTIFIER=80
+AND_OP="and"=81
+BEGIN="begin"=82
+CASE="case"=83
+COMMON="common"=84
+COMPILE_OPT="compile_opt"=85
+DO="do"=86
+ELSE="else"=87
+END="end"=88
+ENDCASE="endcase"=89
+ENDELSE="endelse"=90
+ENDFOR="endfor"=91
+ENDFOREACH="endforeach"=92
+ENDIF="endif"=93
+ENDREP="endrep"=94
+ENDSWITCH="endswitch"=95
+ENDWHILE="endwhile"=96
+EQ_OP="eq"=97
+FORWARD="forward_function"=98
+FUNCTION="function"=99
+GE_OP="ge"=100
+GOTO="goto"=101
+GT_OP="gt"=102
+IF="if"=103
+INHERITS="inherits"=104
+LE_OP="le"=105
+LT_OP="lt"=106
+MOD_OP="mod"=107
+NE_OP="ne"=108
+NOT_OP="not"=109
+OF="of"=110
+ON_IOERROR="on_ioerror"=111
+OR_OP="or"=112
+PRO="pro"=113
+SWITCH="switch"=114
+THEN="then"=115
+UNTIL="until"=116
+XOR_OP="xor"=117
+METHOD=118
+COMMA=119
+COLON=120
+END_U=121
+EQUAL=122
+DEC=123
+INC=124
+AND_OP_EQ=125
+ASTERIX_EQ=126
+EQ_OP_EQ=127
+GE_OP_EQ=128
+GTMARK_EQ=129
+GT_OP_EQ=130
+LE_OP_EQ=131
+LTMARK_EQ=132
+LT_OP_EQ=133
+MATRIX_OP1_EQ=134
+MATRIX_OP2_EQ=135
+MINUS_EQ=136
+MOD_OP_EQ=137
+NE_OP_EQ=138
+OR_OP_EQ=139
+PLUS_EQ=140
+POW_EQ=141
+SLASH_EQ=142
+XOR_OP_EQ=143
+MEMBER=144
+LBRACE=145
+RBRACE=146
+SLASH=147
+LSQUARE=148
+RSQUARE=149
+SYSVARNAME=150
+EXCLAMATION=151
+LCURLY=152
+RCURLY=153
+CONSTANT_HEX_BYTE=154
+CONSTANT_HEX_LONG=155
+CONSTANT_HEX_LONG64=156
+CONSTANT_HEX_INT=157
+CONSTANT_HEX_I=158
+CONSTANT_HEX_ULONG=159
+CONSTANT_HEX_ULONG64=160
+CONSTANT_HEX_UI=161
+CONSTANT_HEX_UINT=162
+CONSTANT_BYTE=163
+CONSTANT_LONG=164
+CONSTANT_LONG64=165
+CONSTANT_INT=166
+CONSTANT_I=167
+CONSTANT_ULONG=168
+CONSTANT_ULONG64=169
+CONSTANT_UI=170
+CONSTANT_UINT=171
+CONSTANT_OCT_BYTE=172
+CONSTANT_OCT_LONG=173
+CONSTANT_OCT_LONG64=174
+CONSTANT_OCT_INT=175
+CONSTANT_OCT_I=176
+CONSTANT_OCT_ULONG=177
+CONSTANT_OCT_ULONG64=178
+CONSTANT_OCT_UI=179
+CONSTANT_OCT_UINT=180
+CONSTANT_FLOAT=181
+CONSTANT_DOUBLE=182
+CONSTANT_BIN_BYTE=183
+CONSTANT_BIN_LONG=184
+CONSTANT_BIN_LONG64=185
+CONSTANT_BIN_INT=186
+CONSTANT_BIN_I=187
+CONSTANT_BIN_ULONG=188
+CONSTANT_BIN_ULONG64=189
+CONSTANT_BIN_UI=190
+CONSTANT_BIN_UINT=191
+ASTERIX=192
+DOT=193
+STRING_LITERAL=194
+POW=195
+MATRIX_OP1=196
+MATRIX_OP2=197
+PLUS=198
+MINUS=199
+LTMARK=200
+GTMARK=201
+LOG_NEG=202
+LOG_AND=203
+LOG_OR=204
+QUESTION=205
+STRING=206
+INCLUDE=207
+EOL=208
+W=209
+D=210
+L=211
+H=212
+O=213
+B=214
+EXP=215
+DBL_E=216
+DBL=217
+CONSTANT_OR_STRING_LITERAL=218
+COMMENT=219
+END_MARKER=220
+WHITESPACE=221
+SKIP_LINES=222
+CONT_STATEMENT=223
+END_OF_LINE=224
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdljournal.cpp cvs/gdl/src/gdljournal.cpp
--- gdl-0.9rc4/src/gdljournal.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdljournal.cpp	2010-04-16 11:22:53.000000000 -0600
@@ -87,12 +87,12 @@
       //message  
       DStructGDL* version = SysVar::Version();
       
-      static unsigned releaseTag = version->Desc()->TagIndex( "RELEASE");
+/*      static unsigned releaseTag = version->Desc()->TagIndex( "RELEASE");*/
       static unsigned osTag = version->Desc()->TagIndex( "OS");
       static unsigned archTag = version->Desc()->TagIndex( "ARCH");
       static unsigned mTag = version->Desc()->TagIndex( "MEMORY_BITS");
-      DString release = 
-	(*static_cast<DStringGDL*>( version->GetTag( releaseTag, 0)))[0];
+/*      DString release = 
+	(*static_cast<DStringGDL*>( version->GetTag( releaseTag, 0)))[0];*/
       DString os = 
 	(*static_cast<DStringGDL*>( version->GetTag( osTag, 0)))[0];
       DString arch = 
@@ -100,7 +100,7 @@
       DInt m = 
 	(*static_cast<DIntGDL*>( version->GetTag( mTag, 0)))[0];
       
-      write_journal_comment( "GDL Version "+release+" ("+os+" "+arch+" m"+
+      write_journal_comment( string("GDL Version ")+VERSION/*release*/+" ("+os+" "+arch+" m"+
 			     i2s(m)+")");
       
       string user = GetEnvString( "USER");
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/GDLLexer.cpp cvs/gdl/src/GDLLexer.cpp
--- gdl-0.9rc4/src/GDLLexer.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/GDLLexer.cpp	2010-04-22 09:50:40.000000000 -0600
@@ -36,45 +36,47 @@
 
 void GDLLexer::initLiterals()
 {
-	literals["endcase"] = 78;
-	literals["case"] = 72;
-	literals["repeat"] = 103;
-	literals["ne"] = 97;
-	literals["end"] = 77;
-	literals["le"] = 94;
-	literals["then"] = 105;
-	literals["begin"] = 71;
-	literals["endswitch"] = 83;
-	literals["and"] = 70;
-	literals["endrep"] = 82;
-	literals["not"] = 98;
-	literals["on_ioerror"] = 100;
-	literals["mod"] = 96;
-	literals["do"] = 75;
-	literals["function"] = 88;
-	literals["endfor"] = 80;
-	literals["gt"] = 91;
-	literals["inherits"] = 93;
-	literals["of"] = 99;
-	literals["or"] = 101;
-	literals["if"] = 92;
-	literals["pro"] = 102;
-	literals["xor"] = 108;
-	literals["compile_opt"] = 74;
-	literals["ge"] = 89;
-	literals["goto"] = 90;
-	literals["for"] = 86;
-	literals["eq"] = 85;
-	literals["forward_function"] = 87;
-	literals["endelse"] = 79;
-	literals["until"] = 106;
-	literals["else"] = 76;
-	literals["lt"] = 95;
-	literals["endwhile"] = 84;
-	literals["switch"] = 104;
-	literals["common"] = 73;
-	literals["endif"] = 81;
-	literals["while"] = 107;
+	literals["endcase"] = 89;
+	literals["case"] = 83;
+	literals["repeat"] = 69;
+	literals["endforeach"] = 92;
+	literals["ne"] = 108;
+	literals["end"] = 88;
+	literals["le"] = 105;
+	literals["then"] = 115;
+	literals["begin"] = 82;
+	literals["endswitch"] = 95;
+	literals["and"] = 81;
+	literals["endrep"] = 94;
+	literals["not"] = 109;
+	literals["on_ioerror"] = 111;
+	literals["mod"] = 107;
+	literals["do"] = 86;
+	literals["function"] = 99;
+	literals["endfor"] = 91;
+	literals["gt"] = 102;
+	literals["inherits"] = 104;
+	literals["of"] = 110;
+	literals["or"] = 112;
+	literals["if"] = 103;
+	literals["pro"] = 113;
+	literals["xor"] = 117;
+	literals["compile_opt"] = 85;
+	literals["ge"] = 100;
+	literals["goto"] = 101;
+	literals["for"] = 30;
+	literals["eq"] = 97;
+	literals["forward_function"] = 98;
+	literals["foreach"] = 32;
+	literals["endelse"] = 90;
+	literals["until"] = 116;
+	literals["else"] = 87;
+	literals["lt"] = 106;
+	literals["endwhile"] = 96;
+	literals["switch"] = 114;
+	literals["common"] = 84;
+	literals["endif"] = 93;
+	literals["while"] = 79;
 }
 
 antlr::RefToken GDLLexer::nextToken()
@@ -398,11 +400,11 @@
 			}
 		}
 		else {
-			goto _loop228;
+			goto _loop259;
 		}
 		
 	}
-	_loop228:;
+	_loop259:;
 	} // ( ... )*
 	if ( _createToken && _token==antlr::nullToken && _ttype!=antlr::Token::SKIP ) {
 	   _token = makeToken(_ttype);
@@ -1150,10 +1152,10 @@
 	std::string::size_type _saveIndex;
 	
 	{
-	bool synPredMatched280 = false;
+	bool synPredMatched311 = false;
 	if (((LA(1) == 0xd /* '\r' */ ) && (LA(2) == 0xa /* '\n' */ ) && (true))) {
-		int _m280 = mark();
-		synPredMatched280 = true;
+		int _m311 = mark();
+		synPredMatched311 = true;
 		inputState->guessing++;
 		try {
 			{
@@ -1161,12 +1163,12 @@
 			}
 		}
 		catch (antlr::RecognitionException& pe) {
-			synPredMatched280 = false;
+			synPredMatched311 = false;
 		}
-		rewind(_m280);
+		rewind(_m311);
 		inputState->guessing--;
 	}
-	if ( synPredMatched280 ) {
+	if ( synPredMatched311 ) {
 		match("\r\n");
 	}
 	else if ((LA(1) == 0xa /* '\n' */ )) {
@@ -1417,18 +1419,18 @@
 		}
 		}
 		{ // ( ... )+
-		int _cnt298=0;
+		int _cnt329=0;
 		for (;;) {
 			if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 				mD(false);
 			}
 			else {
-				if ( _cnt298>=1 ) { goto _loop298; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+				if ( _cnt329>=1 ) { goto _loop329; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 			}
 			
-			_cnt298++;
+			_cnt329++;
 		}
-		_loop298:;
+		_loop329:;
 		}  // ( ... )+
 	}
 	else {
@@ -1502,18 +1504,18 @@
 		}
 		}
 		{ // ( ... )+
-		int _cnt305=0;
+		int _cnt336=0;
 		for (;;) {
 			if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 				mD(false);
 			}
 			else {
-				if ( _cnt305>=1 ) { goto _loop305; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+				if ( _cnt336>=1 ) { goto _loop336; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 			}
 			
-			_cnt305++;
+			_cnt336++;
 		}
-		_loop305:;
+		_loop336:;
 		}  // ( ... )+
 	}
 	else {
@@ -1937,27 +1939,27 @@
 	_ttype = CONSTANT_OR_STRING_LITERAL;
 	std::string::size_type _saveIndex;
 	
-	bool synPredMatched351 = false;
+	bool synPredMatched382 = false;
 	if (((LA(1) == 0x27 /* '\'' */ ) && (_tokenSet_4.member(LA(2))) && (_tokenSet_5.member(LA(3))))) {
-		int _m351 = mark();
-		synPredMatched351 = true;
+		int _m382 = mark();
+		synPredMatched382 = true;
 		inputState->guessing++;
 		try {
 			{
 			match('\'' /* charlit */ );
 			{ // ( ... )+
-			int _cnt349=0;
+			int _cnt380=0;
 			for (;;) {
 				if ((_tokenSet_4.member(LA(1)))) {
 					mH(false);
 				}
 				else {
-					if ( _cnt349>=1 ) { goto _loop349; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+					if ( _cnt380>=1 ) { goto _loop380; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 				}
 				
-				_cnt349++;
+				_cnt380++;
 			}
-			_loop349:;
+			_loop380:;
 			}  // ( ... )+
 			match('\'' /* charlit */ );
 			{
@@ -1993,29 +1995,29 @@
 			}
 		}
 		catch (antlr::RecognitionException& pe) {
-			synPredMatched351 = false;
+			synPredMatched382 = false;
 		}
-		rewind(_m351);
+		rewind(_m382);
 		inputState->guessing--;
 	}
-	if ( synPredMatched351 ) {
+	if ( synPredMatched382 ) {
 		{
 		_saveIndex = text.length();
 		match('\'' /* charlit */ );
 		text.erase(_saveIndex);
 		{ // ( ... )+
-		int _cnt354=0;
+		int _cnt385=0;
 		for (;;) {
 			if ((_tokenSet_4.member(LA(1)))) {
 				mH(false);
 			}
 			else {
-				if ( _cnt354>=1 ) { goto _loop354; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+				if ( _cnt385>=1 ) { goto _loop385; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 			}
 			
-			_cnt354++;
+			_cnt385++;
 		}
-		_loop354:;
+		_loop385:;
 		}  // ( ... )+
 		_saveIndex = text.length();
 		match('\'' /* charlit */ );
@@ -2112,27 +2114,27 @@
 		}
 	}
 	else {
-		bool synPredMatched360 = false;
+		bool synPredMatched391 = false;
 		if (((LA(1) == 0x27 /* '\'' */ ) && ((LA(2) >= 0x30 /* '0' */  && LA(2) <= 0x37 /* '7' */ )) && (_tokenSet_6.member(LA(3))))) {
-			int _m360 = mark();
-			synPredMatched360 = true;
+			int _m391 = mark();
+			synPredMatched391 = true;
 			inputState->guessing++;
 			try {
 				{
 				match('\'' /* charlit */ );
 				{ // ( ... )+
-				int _cnt358=0;
+				int _cnt389=0;
 				for (;;) {
 					if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x37 /* '7' */ ))) {
 						mO(false);
 					}
 					else {
-						if ( _cnt358>=1 ) { goto _loop358; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+						if ( _cnt389>=1 ) { goto _loop389; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 					}
 					
-					_cnt358++;
+					_cnt389++;
 				}
-				_loop358:;
+				_loop389:;
 				}  // ( ... )+
 				match('\'' /* charlit */ );
 				{
@@ -2159,29 +2161,29 @@
 				}
 			}
 			catch (antlr::RecognitionException& pe) {
-				synPredMatched360 = false;
+				synPredMatched391 = false;
 			}
-			rewind(_m360);
+			rewind(_m391);
 			inputState->guessing--;
 		}
-		if ( synPredMatched360 ) {
+		if ( synPredMatched391 ) {
 			{
 			_saveIndex = text.length();
 			match('\'' /* charlit */ );
 			text.erase(_saveIndex);
 			{ // ( ... )+
-			int _cnt363=0;
+			int _cnt394=0;
 			for (;;) {
 				if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x37 /* '7' */ ))) {
 					mO(false);
 				}
 				else {
-					if ( _cnt363>=1 ) { goto _loop363; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+					if ( _cnt394>=1 ) { goto _loop394; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 				}
 				
-				_cnt363++;
+				_cnt394++;
 			}
-			_loop363:;
+			_loop394:;
 			}  // ( ... )+
 			_saveIndex = text.length();
 			match('\'' /* charlit */ );
@@ -2278,27 +2280,27 @@
 			}
 		}
 		else {
-			bool synPredMatched369 = false;
+			bool synPredMatched400 = false;
 			if (((LA(1) == 0x27 /* '\'' */ ) && (LA(2) == 0x30 /* '0' */  || LA(2) == 0x31 /* '1' */ ) && (LA(3) == 0x27 /* '\'' */  || LA(3) == 0x30 /* '0' */  || LA(3) == 0x31 /* '1' */ ))) {
-				int _m369 = mark();
-				synPredMatched369 = true;
+				int _m400 = mark();
+				synPredMatched400 = true;
 				inputState->guessing++;
 				try {
 					{
 					match('\'' /* charlit */ );
 					{ // ( ... )+
-					int _cnt367=0;
+					int _cnt398=0;
 					for (;;) {
 						if ((LA(1) == 0x30 /* '0' */  || LA(1) == 0x31 /* '1' */ )) {
 							mB(false);
 						}
 						else {
-							if ( _cnt367>=1 ) { goto _loop367; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+							if ( _cnt398>=1 ) { goto _loop398; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 						}
 						
-						_cnt367++;
+						_cnt398++;
 					}
-					_loop367:;
+					_loop398:;
 					}  // ( ... )+
 					match('\'' /* charlit */ );
 					{
@@ -2325,29 +2327,29 @@
 					}
 				}
 				catch (antlr::RecognitionException& pe) {
-					synPredMatched369 = false;
+					synPredMatched400 = false;
 				}
-				rewind(_m369);
+				rewind(_m400);
 				inputState->guessing--;
 			}
-			if ( synPredMatched369 ) {
+			if ( synPredMatched400 ) {
 				{
 				_saveIndex = text.length();
 				match('\'' /* charlit */ );
 				text.erase(_saveIndex);
 				{ // ( ... )+
-				int _cnt372=0;
+				int _cnt403=0;
 				for (;;) {
 					if ((LA(1) == 0x30 /* '0' */  || LA(1) == 0x31 /* '1' */ )) {
 						mB(false);
 					}
 					else {
-						if ( _cnt372>=1 ) { goto _loop372; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+						if ( _cnt403>=1 ) { goto _loop403; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 					}
 					
-					_cnt372++;
+					_cnt403++;
 				}
-				_loop372:;
+				_loop403:;
 				}  // ( ... )+
 				_saveIndex = text.length();
 				match('\'' /* charlit */ );
@@ -2444,27 +2446,27 @@
 				}
 			}
 			else {
-				bool synPredMatched342 = false;
+				bool synPredMatched373 = false;
 				if (((LA(1) == 0x22 /* '\"' */ ) && ((LA(2) >= 0x30 /* '0' */  && LA(2) <= 0x37 /* '7' */ )) && (true))) {
-					int _m342 = mark();
-					synPredMatched342 = true;
+					int _m373 = mark();
+					synPredMatched373 = true;
 					inputState->guessing++;
 					try {
 						{
 						match('\"' /* charlit */ );
 						{ // ( ... )+
-						int _cnt340=0;
+						int _cnt371=0;
 						for (;;) {
 							if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x37 /* '7' */ ))) {
 								mO(false);
 							}
 							else {
-								if ( _cnt340>=1 ) { goto _loop340; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+								if ( _cnt371>=1 ) { goto _loop371; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 							}
 							
-							_cnt340++;
+							_cnt371++;
 						}
-						_loop340:;
+						_loop371:;
 						}  // ( ... )+
 						{
 						switch ( LA(1)) {
@@ -2503,29 +2505,29 @@
 						}
 					}
 					catch (antlr::RecognitionException& pe) {
-						synPredMatched342 = false;
+						synPredMatched373 = false;
 					}
-					rewind(_m342);
+					rewind(_m373);
 					inputState->guessing--;
 				}
-				if ( synPredMatched342 ) {
+				if ( synPredMatched373 ) {
 					{
 					_saveIndex = text.length();
 					match('\"' /* charlit */ );
 					text.erase(_saveIndex);
 					{ // ( ... )+
-					int _cnt345=0;
+					int _cnt376=0;
 					for (;;) {
 						if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x37 /* '7' */ ))) {
 							mO(false);
 						}
 						else {
-							if ( _cnt345>=1 ) { goto _loop345; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+							if ( _cnt376>=1 ) { goto _loop376; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 						}
 						
-						_cnt345++;
+						_cnt376++;
 					}
-					_loop345:;
+					_loop376:;
 					}  // ( ... )+
 					if ( inputState->guessing==0 ) {
 						_ttype=CONSTANT_OCT_I;
@@ -2616,10 +2618,10 @@
 					}
 				}
 				else {
-					bool synPredMatched393 = false;
+					bool synPredMatched424 = false;
 					if (((_tokenSet_7.member(LA(1))) && (_tokenSet_8.member(LA(2))) && (true))) {
-						int _m393 = mark();
-						synPredMatched393 = true;
+						int _m424 = mark();
+						synPredMatched424 = true;
 						inputState->guessing++;
 						try {
 							{
@@ -2637,18 +2639,18 @@
 							{
 								{
 								{ // ( ... )+
-								int _cnt385=0;
+								int _cnt416=0;
 								for (;;) {
 									if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 										mD(false);
 									}
 									else {
-										if ( _cnt385>=1 ) { goto _loop385; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+										if ( _cnt416>=1 ) { goto _loop416; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 									}
 									
-									_cnt385++;
+									_cnt416++;
 								}
-								_loop385:;
+								_loop416:;
 								}  // ( ... )+
 								{
 								switch ( LA(1)) {
@@ -2666,11 +2668,11 @@
 											mD(false);
 										}
 										else {
-											goto _loop388;
+											goto _loop419;
 										}
 										
 									}
-									_loop388:;
+									_loop419:;
 									} // ( ... )*
 									{
 									mDBL(false);
@@ -2690,18 +2692,18 @@
 							{
 								match('.' /* charlit */ );
 								{ // ( ... )+
-								int _cnt391=0;
+								int _cnt422=0;
 								for (;;) {
 									if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 										mD(false);
 									}
 									else {
-										if ( _cnt391>=1 ) { goto _loop391; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+										if ( _cnt422>=1 ) { goto _loop422; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 									}
 									
-									_cnt391++;
+									_cnt422++;
 								}
-								_loop391:;
+								_loop422:;
 								}  // ( ... )+
 								{
 								mDBL(false);
@@ -2716,12 +2718,12 @@
 							}
 						}
 						catch (antlr::RecognitionException& pe) {
-							synPredMatched393 = false;
+							synPredMatched424 = false;
 						}
-						rewind(_m393);
+						rewind(_m424);
 						inputState->guessing--;
 					}
-					if ( synPredMatched393 ) {
+					if ( synPredMatched424 ) {
 						{
 						switch ( LA(1)) {
 						case 0x30 /* '0' */ :
@@ -2737,18 +2739,18 @@
 						{
 							{
 							{ // ( ... )+
-							int _cnt397=0;
+							int _cnt428=0;
 							for (;;) {
 								if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 									mD(false);
 								}
 								else {
-									if ( _cnt397>=1 ) { goto _loop397; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+									if ( _cnt428>=1 ) { goto _loop428; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 								}
 								
-								_cnt397++;
+								_cnt428++;
 							}
-							_loop397:;
+							_loop428:;
 							}  // ( ... )+
 							{
 							switch ( LA(1)) {
@@ -2766,11 +2768,11 @@
 										mD(false);
 									}
 									else {
-										goto _loop400;
+										goto _loop431;
 									}
 									
 								}
-								_loop400:;
+								_loop431:;
 								} // ( ... )*
 								{
 								mDBL(false);
@@ -2790,18 +2792,18 @@
 						{
 							match('.' /* charlit */ );
 							{ // ( ... )+
-							int _cnt403=0;
+							int _cnt434=0;
 							for (;;) {
 								if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 									mD(false);
 								}
 								else {
-									if ( _cnt403>=1 ) { goto _loop403; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+									if ( _cnt434>=1 ) { goto _loop434; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 								}
 								
-								_cnt403++;
+								_cnt434++;
 							}
-							_loop403:;
+							_loop434:;
 							}  // ( ... )+
 							{
 							mDBL(false);
@@ -2819,10 +2821,10 @@
 						}
 					}
 					else {
-						bool synPredMatched416 = false;
+						bool synPredMatched447 = false;
 						if (((_tokenSet_7.member(LA(1))) && (_tokenSet_9.member(LA(2))) && (true))) {
-							int _m416 = mark();
-							synPredMatched416 = true;
+							int _m447 = mark();
+							synPredMatched447 = true;
 							inputState->guessing++;
 							try {
 								{
@@ -2840,18 +2842,18 @@
 								{
 									{
 									{ // ( ... )+
-									int _cnt408=0;
+									int _cnt439=0;
 									for (;;) {
 										if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 											mD(false);
 										}
 										else {
-											if ( _cnt408>=1 ) { goto _loop408; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+											if ( _cnt439>=1 ) { goto _loop439; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 										}
 										
-										_cnt408++;
+										_cnt439++;
 									}
-									_loop408:;
+									_loop439:;
 									}  // ( ... )+
 									{
 									switch ( LA(1)) {
@@ -2869,11 +2871,11 @@
 												mD(false);
 											}
 											else {
-												goto _loop411;
+												goto _loop442;
 											}
 											
 										}
-										_loop411:;
+										_loop442:;
 										} // ( ... )*
 										{
 										if ((LA(1) == 0x65 /* 'e' */ )) {
@@ -2898,18 +2900,18 @@
 								{
 									match('.' /* charlit */ );
 									{ // ( ... )+
-									int _cnt414=0;
+									int _cnt445=0;
 									for (;;) {
 										if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 											mD(false);
 										}
 										else {
-											if ( _cnt414>=1 ) { goto _loop414; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+											if ( _cnt445>=1 ) { goto _loop445; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 										}
 										
-										_cnt414++;
+										_cnt445++;
 									}
-									_loop414:;
+									_loop445:;
 									}  // ( ... )+
 									{
 									if ((LA(1) == 0x65 /* 'e' */ )) {
@@ -2929,12 +2931,12 @@
 								}
 							}
 							catch (antlr::RecognitionException& pe) {
-								synPredMatched416 = false;
+								synPredMatched447 = false;
 							}
-							rewind(_m416);
+							rewind(_m447);
 							inputState->guessing--;
 						}
-						if ( synPredMatched416 ) {
+						if ( synPredMatched447 ) {
 							{
 							switch ( LA(1)) {
 							case 0x30 /* '0' */ :
@@ -2950,18 +2952,18 @@
 							{
 								{
 								{ // ( ... )+
-								int _cnt420=0;
+								int _cnt451=0;
 								for (;;) {
 									if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 										mD(false);
 									}
 									else {
-										if ( _cnt420>=1 ) { goto _loop420; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+										if ( _cnt451>=1 ) { goto _loop451; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 									}
 									
-									_cnt420++;
+									_cnt451++;
 								}
-								_loop420:;
+								_loop451:;
 								}  // ( ... )+
 								{
 								switch ( LA(1)) {
@@ -2979,11 +2981,11 @@
 											mD(false);
 										}
 										else {
-											goto _loop423;
+											goto _loop454;
 										}
 										
 									}
-									_loop423:;
+									_loop454:;
 									} // ( ... )*
 									{
 									if ((LA(1) == 0x65 /* 'e' */ )) {
@@ -3008,18 +3010,18 @@
 							{
 								match('.' /* charlit */ );
 								{ // ( ... )+
-								int _cnt426=0;
+								int _cnt457=0;
 								for (;;) {
 									if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 										mD(false);
 									}
 									else {
-										if ( _cnt426>=1 ) { goto _loop426; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+										if ( _cnt457>=1 ) { goto _loop457; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 									}
 									
-									_cnt426++;
+									_cnt457++;
 								}
-								_loop426:;
+								_loop457:;
 								}  // ( ... )+
 								{
 								if ((LA(1) == 0x65 /* 'e' */ )) {
@@ -3059,11 +3061,11 @@
 									}
 								}
 								else {
-									goto _loop376;
+									goto _loop407;
 								}
 								
 							}
-							_loop376:;
+							_loop407:;
 							} // ( ... )*
 							{
 							if ((LA(1) == 0x22 /* '\"' */ )) {
@@ -3097,11 +3099,11 @@
 									}
 								}
 								else {
-									goto _loop380;
+									goto _loop411;
 								}
 								
 							}
-							_loop380:;
+							_loop411:;
 							} // ( ... )*
 							{
 							if ((LA(1) == 0x27 /* '\'' */ )) {
@@ -3125,18 +3127,18 @@
 						}
 						else if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ )) && (true) && (true)) {
 							{ // ( ... )+
-							int _cnt429=0;
+							int _cnt460=0;
 							for (;;) {
 								if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 									mD(false);
 								}
 								else {
-									if ( _cnt429>=1 ) { goto _loop429; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+									if ( _cnt460>=1 ) { goto _loop460; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 								}
 								
-								_cnt429++;
+								_cnt460++;
 							}
-							_loop429:;
+							_loop460:;
 							}  // ( ... )+
 							if ( inputState->guessing==0 ) {
 								_ttype=CONSTANT_I;
@@ -3253,11 +3255,11 @@
 			}
 		}
 		else {
-			goto _loop435;
+			goto _loop466;
 		}
 		
 	}
-	_loop435:;
+	_loop466:;
 	} // ( ... )*
 	if ( inputState->guessing==0 ) {
 		_ttype=antlr::Token::SKIP;
@@ -3333,11 +3335,11 @@
 		}
 		default:
 		{
-			goto _loop439;
+			goto _loop470;
 		}
 		}
 	}
-	_loop439:;
+	_loop470:;
 	} // ( ... )*
 	if ( inputState->guessing==0 ) {
 		
@@ -3363,7 +3365,7 @@
 	match('!' /* charlit */ );
 	}
 	{ // ( ... )+
-	int _cnt443=0;
+	int _cnt474=0;
 	for (;;) {
 		switch ( LA(1)) {
 		case 0x5f /* '_' */ :
@@ -3418,12 +3420,12 @@
 		}
 		default:
 		{
-			if ( _cnt443>=1 ) { goto _loop443; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+			if ( _cnt474>=1 ) { goto _loop474; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 		}
 		}
-		_cnt443++;
+		_cnt474++;
 	}
-	_loop443:;
+	_loop474:;
 	}  // ( ... )+
 	if ( inputState->guessing==0 ) {
 		
@@ -3462,18 +3464,18 @@
 	std::string::size_type _saveIndex;
 	
 	{ // ( ... )+
-	int _cnt447=0;
+	int _cnt478=0;
 	for (;;) {
 		if ((LA(1) == 0x9 /* '\t' */  || LA(1) == 0xc /* '\14' */  || LA(1) == 0x20 /* ' ' */ )) {
 			mW(false);
 		}
 		else {
-			if ( _cnt447>=1 ) { goto _loop447; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+			if ( _cnt478>=1 ) { goto _loop478; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 		}
 		
-		_cnt447++;
+		_cnt478++;
 	}
-	_loop447:;
+	_loop478:;
 	}  // ( ... )+
 	if ( inputState->guessing==0 ) {
 		_ttype=antlr::Token::SKIP;
@@ -3514,11 +3516,11 @@
 		}
 		default:
 		{
-			goto _loop450;
+			goto _loop481;
 		}
 		}
 	}
-	_loop450:;
+	_loop481:;
 	} // ( ... )*
 	if ( _createToken && _token==antlr::nullToken && _ttype!=antlr::Token::SKIP ) {
 	   _token = makeToken(_ttype);
@@ -3542,11 +3544,11 @@
 			}
 		}
 		else {
-			goto _loop454;
+			goto _loop485;
 		}
 		
 	}
-	_loop454:;
+	_loop485:;
 	} // ( ... )*
 	mEOL(false);
 	mSKIP_LINES(false);
@@ -3602,6 +3604,7 @@
 // 0xae 0xaf 0xb0 0xb1 0xb2 0xb3 0xb4 0xb5 0xb6 0xb7 0xb8 0xb9 0xba 0xbb 
 // 0xbc 0xbd 0xbe 0xbf 0xc0 0xc1 0xc2 0xc3 0xc4 0xc5 0xc6 0xc7 0xc8 0xc9 
 // 0xca 0xcb 0xcc 0xcd 0xce 0xcf 0xd0 0xd1 0xd2 0xd3 0xd4 0xd5 0xd6 0xd7 
+// 0xd8 0xd9 0xda 0xdb 0xdc 0xdd 0xde 0xdf 0xe0 
 const antlr::BitSet GDLLexer::_tokenSet_2(_tokenSet_2_data_,16);
 const unsigned long GDLLexer::_tokenSet_3_data_[] = { 0UL, 67053568UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // + - 0 1 2 3 4 5 6 7 8 9 
@@ -3635,7 +3638,8 @@
 // 0xa1 0xa2 0xa3 0xa4 0xa5 0xa6 0xa7 0xa8 0xa9 0xaa 0xab 0xac 0xad 0xae 
 // 0xaf 0xb0 0xb1 0xb2 0xb3 0xb4 0xb5 0xb6 0xb7 0xb8 0xb9 0xba 0xbb 0xbc 
 // 0xbd 0xbe 0xbf 0xc0 0xc1 0xc2 0xc3 0xc4 0xc5 0xc6 0xc7 0xc8 0xc9 0xca 
-// 0xcb 0xcc 0xcd 0xce 0xcf 0xd0 0xd1 0xd2 0xd3 0xd4 0xd5 0xd6 0xd7 
+// 0xcb 0xcc 0xcd 0xce 0xcf 0xd0 0xd1 0xd2 0xd3 0xd4 0xd5 0xd6 0xd7 0xd8 
+// 0xd9 0xda 0xdb 0xdc 0xdd 0xde 0xdf 0xe0 
 const antlr::BitSet GDLLexer::_tokenSet_10(_tokenSet_10_data_,16);
 const unsigned long GDLLexer::_tokenSet_11_data_[] = { 4294958072UL, 4294967167UL, 4294967295UL, 4294967295UL, 4294967295UL, 4294967295UL, 4294967295UL, 4294967295UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // 0x3 0x4 0x5 0x6 0x7 0x8 0x9 0xb 0xc 0xe 0xf 0x10 0x11 0x12 0x13 0x14 
@@ -3648,6 +3652,7 @@
 // 0xa1 0xa2 0xa3 0xa4 0xa5 0xa6 0xa7 0xa8 0xa9 0xaa 0xab 0xac 0xad 0xae 
 // 0xaf 0xb0 0xb1 0xb2 0xb3 0xb4 0xb5 0xb6 0xb7 0xb8 0xb9 0xba 0xbb 0xbc 
 // 0xbd 0xbe 0xbf 0xc0 0xc1 0xc2 0xc3 0xc4 0xc5 0xc6 0xc7 0xc8 0xc9 0xca 
-// 0xcb 0xcc 0xcd 0xce 0xcf 0xd0 0xd1 0xd2 0xd3 0xd4 0xd5 0xd6 0xd7 
+// 0xcb 0xcc 0xcd 0xce 0xcf 0xd0 0xd1 0xd2 0xd3 0xd4 0xd5 0xd6 0xd7 0xd8 
+// 0xd9 0xda 0xdb 0xdc 0xdd 0xde 0xdf 0xe0 
 const antlr::BitSet GDLLexer::_tokenSet_11(_tokenSet_11_data_,16);
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/GDLLexer.hpp cvs/gdl/src/GDLLexer.hpp
--- gdl-0.9rc4/src/GDLLexer.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/GDLLexer.hpp	2010-04-22 09:50:40.000000000 -0600
@@ -28,7 +28,7 @@
 //#include "dinterpreter.hpp"
 
 // defintion in dinterpreter.cpp
-void SetActualCompileOpt( unsigned int cOpt);
+//void SetActualCompileOpt( unsigned int cOpt);
 
 class CUSTOM_API GDLLexer : public antlr::CharScanner, public GDLTokenTypes
 {
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/GDLParser.cpp cvs/gdl/src/GDLParser.cpp
--- gdl-0.9rc4/src/GDLParser.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/GDLParser.cpp	2010-04-22 09:50:40.000000000 -0600
@@ -62,6 +62,8 @@
 	RefDNode ende_AST = RefDNode(antlr::nullAST);
 	antlr::RefToken  endf = antlr::nullToken;
 	RefDNode endf_AST = RefDNode(antlr::nullAST);
+	antlr::RefToken  endfe = antlr::nullToken;
+	RefDNode endfe_AST = RefDNode(antlr::nullAST);
 	antlr::RefToken  endi = antlr::nullToken;
 	RefDNode endi_AST = RefDNode(antlr::nullAST);
 	antlr::RefToken  endr = antlr::nullToken;
@@ -74,6 +76,8 @@
 	RefDNode eq_AST = RefDNode(antlr::nullAST);
 	antlr::RefToken  f = antlr::nullToken;
 	RefDNode f_AST = RefDNode(antlr::nullAST);
+	antlr::RefToken  fe = antlr::nullToken;
+	RefDNode fe_AST = RefDNode(antlr::nullAST);
 	antlr::RefToken  fo = antlr::nullToken;
 	RefDNode fo_AST = RefDNode(antlr::nullAST);
 	antlr::RefToken  fu = antlr::nullToken;
@@ -285,6 +289,20 @@
 		identifier_AST = RefDNode(currentAST.root);
 		break;
 	}
+	case ENDFOREACH:
+	{
+		endfe = LT(1);
+		if ( inputState->guessing == 0 ) {
+			endfe_AST = astFactory->create(endfe);
+			astFactory->addASTChild(currentAST, antlr::RefAST(endfe_AST));
+		}
+		match(ENDFOREACH);
+		if ( inputState->guessing==0 ) {
+			endf_AST->setType( IDENTIFIER);
+		}
+		identifier_AST = RefDNode(currentAST.root);
+		break;
+	}
 	case ENDIF:
 	{
 		endi = LT(1);
@@ -369,6 +387,20 @@
 		identifier_AST = RefDNode(currentAST.root);
 		break;
 	}
+	case FOREACH:
+	{
+		fe = LT(1);
+		if ( inputState->guessing == 0 ) {
+			fe_AST = astFactory->create(fe);
+			astFactory->addASTChild(currentAST, antlr::RefAST(fe_AST));
+		}
+		match(FOREACH);
+		if ( inputState->guessing==0 ) {
+			f_AST->setType( IDENTIFIER);
+		}
+		identifier_AST = RefDNode(currentAST.root);
+		break;
+	}
 	case FORWARD:
 	{
 		fo = LT(1);
@@ -758,20 +790,21 @@
 		} // ( ... )*
 		{
 		switch ( LA(1)) {
+		case FOR:
+		case FOREACH:
+		case REPEAT:
+		case WHILE:
 		case IDENTIFIER:
 		case BEGIN:
 		case CASE:
 		case COMMON:
 		case COMPILE_OPT:
-		case FOR:
 		case FORWARD:
 		case GOTO:
 		case IF:
 		case INHERITS:
 		case ON_IOERROR:
-		case REPEAT:
 		case SWITCH:
-		case WHILE:
 		case END_U:
 		case DEC:
 		case INC:
@@ -998,20 +1031,21 @@
 	}
 	{
 	switch ( LA(1)) {
+	case FOR:
+	case FOREACH:
+	case REPEAT:
+	case WHILE:
 	case IDENTIFIER:
 	case BEGIN:
 	case CASE:
 	case COMMON:
 	case COMPILE_OPT:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case INHERITS:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case END_U:
 	case DEC:
 	case INC:
@@ -1114,20 +1148,21 @@
 	}
 	{
 	switch ( LA(1)) {
+	case FOR:
+	case FOREACH:
+	case REPEAT:
+	case WHILE:
 	case IDENTIFIER:
 	case BEGIN:
 	case CASE:
 	case COMMON:
 	case COMPILE_OPT:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case INHERITS:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case END_U:
 	case DEC:
 	case INC:
@@ -1177,13 +1212,16 @@
 	{
 	switch ( LA(1)) {
 	case antlr::Token::EOF_TYPE:
+	case FOR:
+	case FOREACH:
+	case REPEAT:
+	case WHILE:
 	case IDENTIFIER:
 	case BEGIN:
 	case CASE:
 	case COMMON:
 	case COMPILE_OPT:
 	case ELSE:
-	case FOR:
 	case FORWARD:
 	case FUNCTION:
 	case GOTO:
@@ -1191,10 +1229,8 @@
 	case INHERITS:
 	case ON_IOERROR:
 	case PRO:
-	case REPEAT:
 	case SWITCH:
 	case UNTIL:
-	case WHILE:
 	case END_U:
 	case DEC:
 	case INC:
@@ -1251,7 +1287,7 @@
 	RefDNode statement_list_AST = RefDNode(antlr::nullAST);
 	
 	{ // ( ... )+
-	int _cnt72=0;
+	int _cnt73=0;
 	for (;;) {
 		if ((LA(1) == END_U)) {
 			end_unit();
@@ -1280,12 +1316,12 @@
 			}
 		}
 		else {
-			if ( _cnt72>=1 ) { goto _loop72; } else {throw antlr::NoViableAltException(LT(1), getFilename());}
+			if ( _cnt73>=1 ) { goto _loop73; } else {throw antlr::NoViableAltException(LT(1), getFilename());}
 		}
 		
-		_cnt72++;
+		_cnt73++;
 	}
-	_loop72:;
+	_loop73:;
 	}  // ( ... )+
 	statement_list_AST = RefDNode(currentAST.root);
 	returnAST = statement_list_AST;
@@ -1481,6 +1517,7 @@
 				case ENDCASE:
 				case ENDELSE:
 				case ENDFOR:
+				case ENDFOREACH:
 				case ENDIF:
 				case ENDREP:
 				case ENDSWITCH:
@@ -1493,12 +1530,15 @@
 					break;
 				}
 				case antlr::Token::EOF_TYPE:
+				case FOR:
+				case FOREACH:
+				case REPEAT:
+				case WHILE:
 				case IDENTIFIER:
 				case BEGIN:
 				case CASE:
 				case COMMON:
 				case COMPILE_OPT:
-				case FOR:
 				case FORWARD:
 				case FUNCTION:
 				case GOTO:
@@ -1506,9 +1546,7 @@
 				case INHERITS:
 				case ON_IOERROR:
 				case PRO:
-				case REPEAT:
 				case SWITCH:
-				case WHILE:
 				case END_U:
 				case DEC:
 				case INC:
@@ -1526,20 +1564,21 @@
 				}
 				break;
 			}
+			case FOR:
+			case FOREACH:
+			case REPEAT:
+			case WHILE:
 			case IDENTIFIER:
 			case BEGIN:
 			case CASE:
 			case COMMON:
 			case COMPILE_OPT:
-			case FOR:
 			case FORWARD:
 			case GOTO:
 			case IF:
 			case INHERITS:
 			case ON_IOERROR:
-			case REPEAT:
 			case SWITCH:
-			case WHILE:
 			case DEC:
 			case INC:
 			case LBRACE:
@@ -1696,21 +1735,30 @@
 		match(ENDFOR);
 		break;
 	}
-	case ENDWHILE:
+	case ENDFOREACH:
 	{
 		RefDNode tmp28_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
 			tmp28_AST = astFactory->create(LT(1));
 		}
-		match(ENDWHILE);
+		match(ENDFOREACH);
 		break;
 	}
-	case ENDREP:
+	case ENDWHILE:
 	{
 		RefDNode tmp29_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
 			tmp29_AST = astFactory->create(LT(1));
 		}
+		match(ENDWHILE);
+		break;
+	}
+	case ENDREP:
+	{
+		RefDNode tmp30_AST = RefDNode(antlr::nullAST);
+		if ( inputState->guessing == 0 ) {
+			tmp30_AST = astFactory->create(LT(1));
+		}
 		match(ENDREP);
 		break;
 	}
@@ -1759,6 +1807,9 @@
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
 	RefDNode statement_AST = RefDNode(antlr::nullAST);
+	RefDNode d1_AST = RefDNode(antlr::nullAST);
+	RefDNode d2_AST = RefDNode(antlr::nullAST);
+	RefDNode d3_AST = RefDNode(antlr::nullAST);
 	
 	bool parent=false;
 	
@@ -1771,20 +1822,20 @@
 		switch ( LA(1)) {
 		case DEC:
 		{
-			RefDNode tmp33_AST = RefDNode(antlr::nullAST);
+			RefDNode tmp34_AST = RefDNode(antlr::nullAST);
 			if ( inputState->guessing == 0 ) {
-				tmp33_AST = astFactory->create(LT(1));
-				astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp33_AST));
+				tmp34_AST = astFactory->create(LT(1));
+				astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp34_AST));
 			}
 			match(DEC);
 			break;
 		}
 		case INC:
 		{
-			RefDNode tmp34_AST = RefDNode(antlr::nullAST);
+			RefDNode tmp35_AST = RefDNode(antlr::nullAST);
 			if ( inputState->guessing == 0 ) {
-				tmp34_AST = astFactory->create(LT(1));
-				astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp34_AST));
+				tmp35_AST = astFactory->create(LT(1));
+				astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp35_AST));
 			}
 			match(INC);
 			break;
@@ -1811,6 +1862,15 @@
 		statement_AST = RefDNode(currentAST.root);
 		break;
 	}
+	case FOREACH:
+	{
+		foreach_statement();
+		if (inputState->guessing==0) {
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
+		statement_AST = RefDNode(currentAST.root);
+		break;
+	}
 	case REPEAT:
 	{
 		repeat_statement();
@@ -1894,10 +1954,10 @@
 		break;
 	}
 	default:
-		bool synPredMatched82 = false;
+		bool synPredMatched83 = false;
 		if (((LA(1) == LBRACE) && (_tokenSet_4.member(LA(2))))) {
-			int _m82 = mark();
-			synPredMatched82 = true;
+			int _m83 = mark();
+			synPredMatched83 = true;
 			inputState->guessing++;
 			try {
 				{
@@ -1905,12 +1965,12 @@
 				}
 			}
 			catch (antlr::RecognitionException& pe) {
-				synPredMatched82 = false;
+				synPredMatched83 = false;
 			}
-			rewind(_m82);
+			rewind(_m83);
 			inputState->guessing--;
 		}
-		if ( synPredMatched82 ) {
+		if ( synPredMatched83 ) {
 			assign_expr();
 			if (inputState->guessing==0) {
 				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
@@ -1919,20 +1979,20 @@
 			switch ( LA(1)) {
 			case DEC:
 			{
-				RefDNode tmp35_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp36_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp35_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp35_AST));
+					tmp36_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp36_AST));
 				}
 				match(DEC);
 				break;
 			}
 			case INC:
 			{
-				RefDNode tmp36_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp37_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp36_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp36_AST));
+					tmp37_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp37_AST));
 				}
 				match(INC);
 				break;
@@ -1951,24 +2011,42 @@
 			}
 			statement_AST = RefDNode(currentAST.root);
 		}
-		else if ((_tokenSet_4.member(LA(1))) && (_tokenSet_5.member(LA(2)))) {
-			{
-			deref_expr();
-			if (inputState->guessing==0) {
-				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		else {
+			bool synPredMatched86 = false;
+			if (((_tokenSet_4.member(LA(1))) && (_tokenSet_5.member(LA(2))))) {
+				int _m86 = mark();
+				synPredMatched86 = true;
+				inputState->guessing++;
+				try {
+					{
+					deref_dot_expr_keeplast();
+					match(IDENTIFIER);
+					match(COMMA);
+					}
+				}
+				catch (antlr::RecognitionException& pe) {
+					synPredMatched86 = false;
+				}
+				rewind(_m86);
+				inputState->guessing--;
 			}
-			{
-			switch ( LA(1)) {
-			case EQUAL:
-			{
-				match(EQUAL);
-				expr();
+			if ( synPredMatched86 ) {
+				deref_dot_expr_keeplast();
+				if (inputState->guessing==0) {
+					d1_AST = returnAST;
+					astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+				}
+				formal_procedure_call();
 				if (inputState->guessing==0) {
 					astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 				}
 				if ( inputState->guessing==0 ) {
 					statement_AST = RefDNode(currentAST.root);
-					statement_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(statement_AST))));
+					
+					statement_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MPCALL,"mpcall")))->add(antlr::RefAST(statement_AST))));
+					statement_AST->SetLine( d1_AST->getLine());
+					
+					
 					currentAST.root = statement_AST;
 					if ( statement_AST!=RefDNode(antlr::nullAST) &&
 						statement_AST->getFirstChild() != RefDNode(antlr::nullAST) )
@@ -1977,327 +2055,567 @@
 						currentAST.child = statement_AST;
 					currentAST.advanceChildToEnd();
 				}
-				break;
+				statement_AST = RefDNode(currentAST.root);
 			}
-			case AND_OP_EQ:
-			case ASTERIX_EQ:
-			case EQ_OP_EQ:
-			case GE_OP_EQ:
-			case GTMARK_EQ:
-			case GT_OP_EQ:
-			case LE_OP_EQ:
-			case LTMARK_EQ:
-			case LT_OP_EQ:
-			case MATRIX_OP1_EQ:
-			case MATRIX_OP2_EQ:
-			case MINUS_EQ:
-			case MOD_OP_EQ:
-			case NE_OP_EQ:
-			case OR_OP_EQ:
-			case PLUS_EQ:
-			case POW_EQ:
-			case SLASH_EQ:
-			case XOR_OP_EQ:
-			{
-				{
-				switch ( LA(1)) {
-				case AND_OP_EQ:
-				{
-					RefDNode tmp38_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp38_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp38_AST));
-					}
-					match(AND_OP_EQ);
-					break;
-				}
-				case ASTERIX_EQ:
-				{
-					RefDNode tmp39_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp39_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp39_AST));
-					}
-					match(ASTERIX_EQ);
-					break;
-				}
-				case EQ_OP_EQ:
-				{
-					RefDNode tmp40_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp40_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp40_AST));
-					}
-					match(EQ_OP_EQ);
-					break;
-				}
-				case GE_OP_EQ:
-				{
-					RefDNode tmp41_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp41_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp41_AST));
-					}
-					match(GE_OP_EQ);
-					break;
-				}
-				case GTMARK_EQ:
-				{
-					RefDNode tmp42_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp42_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp42_AST));
-					}
-					match(GTMARK_EQ);
-					break;
-				}
-				case GT_OP_EQ:
-				{
-					RefDNode tmp43_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp43_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp43_AST));
-					}
-					match(GT_OP_EQ);
-					break;
-				}
-				case LE_OP_EQ:
-				{
-					RefDNode tmp44_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp44_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp44_AST));
-					}
-					match(LE_OP_EQ);
-					break;
-				}
-				case LTMARK_EQ:
-				{
-					RefDNode tmp45_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp45_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp45_AST));
-					}
-					match(LTMARK_EQ);
-					break;
-				}
-				case LT_OP_EQ:
-				{
-					RefDNode tmp46_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp46_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp46_AST));
-					}
-					match(LT_OP_EQ);
-					break;
-				}
-				case MATRIX_OP1_EQ:
-				{
-					RefDNode tmp47_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp47_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp47_AST));
-					}
-					match(MATRIX_OP1_EQ);
-					break;
-				}
-				case MATRIX_OP2_EQ:
-				{
-					RefDNode tmp48_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp48_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp48_AST));
-					}
-					match(MATRIX_OP2_EQ);
-					break;
-				}
-				case MINUS_EQ:
-				{
-					RefDNode tmp49_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp49_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp49_AST));
-					}
-					match(MINUS_EQ);
-					break;
-				}
-				case MOD_OP_EQ:
-				{
-					RefDNode tmp50_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp50_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp50_AST));
-					}
-					match(MOD_OP_EQ);
-					break;
-				}
-				case NE_OP_EQ:
-				{
-					RefDNode tmp51_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp51_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp51_AST));
-					}
-					match(NE_OP_EQ);
-					break;
-				}
-				case OR_OP_EQ:
-				{
-					RefDNode tmp52_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp52_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp52_AST));
-					}
-					match(OR_OP_EQ);
-					break;
-				}
-				case PLUS_EQ:
-				{
-					RefDNode tmp53_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp53_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp53_AST));
-					}
-					match(PLUS_EQ);
-					break;
-				}
-				case POW_EQ:
-				{
-					RefDNode tmp54_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp54_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp54_AST));
-					}
-					match(POW_EQ);
-					break;
-				}
-				case SLASH_EQ:
-				{
-					RefDNode tmp55_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp55_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp55_AST));
-					}
-					match(SLASH_EQ);
-					break;
-				}
-				case XOR_OP_EQ:
-				{
-					RefDNode tmp56_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp56_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp56_AST));
+			else {
+				bool synPredMatched88 = false;
+				if (((_tokenSet_4.member(LA(1))) && (_tokenSet_5.member(LA(2))))) {
+					int _m88 = mark();
+					synPredMatched88 = true;
+					inputState->guessing++;
+					try {
+						{
+						deref_dot_expr_keeplast();
+						baseclass_method();
+						}
 					}
-					match(XOR_OP_EQ);
-					break;
-				}
-				default:
-				{
-					throw antlr::NoViableAltException(LT(1), getFilename());
-				}
-				}
-				}
-				expr();
-				if (inputState->guessing==0) {
-					astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-				}
-				break;
-			}
-			case DEC:
-			case INC:
-			{
-				{
-				switch ( LA(1)) {
-				case DEC:
-				{
-					RefDNode tmp57_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp57_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp57_AST));
+					catch (antlr::RecognitionException& pe) {
+						synPredMatched88 = false;
 					}
-					match(DEC);
-					break;
+					rewind(_m88);
+					inputState->guessing--;
 				}
-				case INC:
-				{
-					RefDNode tmp58_AST = RefDNode(antlr::nullAST);
-					if ( inputState->guessing == 0 ) {
-						tmp58_AST = astFactory->create(LT(1));
-						astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp58_AST));
+				if ( synPredMatched88 ) {
+					deref_dot_expr_keeplast();
+					if (inputState->guessing==0) {
+						d2_AST = returnAST;
+						astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 					}
-					match(INC);
-					break;
-				}
-				default:
-				{
-					throw antlr::NoViableAltException(LT(1), getFilename());
-				}
-				}
-				}
-				break;
-			}
-			case MEMBER:
-			{
-				match(MEMBER);
-				{
-				if ((LA(1) == IDENTIFIER) && (LA(2) == METHOD)) {
 					baseclass_method();
 					if (inputState->guessing==0) {
 						astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 					}
+					formal_procedure_call();
+					if (inputState->guessing==0) {
+						astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+					}
 					if ( inputState->guessing==0 ) {
-						parent=true;
+						statement_AST = RefDNode(currentAST.root);
+						
+						statement_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MPCALL_PARENT,"mpcall::")))->add(antlr::RefAST(statement_AST))));
+						statement_AST->SetLine( d2_AST->getLine());
+						
+						currentAST.root = statement_AST;
+						if ( statement_AST!=RefDNode(antlr::nullAST) &&
+							statement_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+							  currentAST.child = statement_AST->getFirstChild();
+						else
+							currentAST.child = statement_AST;
+						currentAST.advanceChildToEnd();
 					}
-				}
-				else if ((LA(1) == IDENTIFIER) && (_tokenSet_6.member(LA(2)))) {
+					statement_AST = RefDNode(currentAST.root);
 				}
 				else {
-					throw antlr::NoViableAltException(LT(1), getFilename());
-				}
-				
-				}
-				formal_procedure_call();
-				if (inputState->guessing==0) {
-					astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-				}
-				if ( inputState->guessing==0 ) {
-					statement_AST = RefDNode(currentAST.root);
-					
-					if( parent)
-					statement_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MPCALL_PARENT,"mpcall::")))->add(antlr::RefAST(statement_AST))));
-					else
-					statement_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MPCALL,"mpcall")))->add(antlr::RefAST(statement_AST))));
-					
-					currentAST.root = statement_AST;
-					if ( statement_AST!=RefDNode(antlr::nullAST) &&
-						statement_AST->getFirstChild() != RefDNode(antlr::nullAST) )
-						  currentAST.child = statement_AST->getFirstChild();
-					else
-						currentAST.child = statement_AST;
-					currentAST.advanceChildToEnd();
-				}
-				break;
-			}
-			default:
-			{
-				throw antlr::NoViableAltException(LT(1), getFilename());
-			}
-			}
-			}
-			}
-			statement_AST = RefDNode(currentAST.root);
-		}
-		else if ((LA(1) == IDENTIFIER) && (_tokenSet_6.member(LA(2)))) {
-			procedure_call();
-			if (inputState->guessing==0) {
-				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-			}
-			statement_AST = RefDNode(currentAST.root);
-		}
+					bool synPredMatched91 = false;
+					if (((_tokenSet_4.member(LA(1))) && (_tokenSet_6.member(LA(2))))) {
+						int _m91 = mark();
+						synPredMatched91 = true;
+						inputState->guessing++;
+						try {
+							{
+							deref_expr();
+							{
+							switch ( LA(1)) {
+							case EQUAL:
+							{
+								match(EQUAL);
+								break;
+							}
+							case AND_OP_EQ:
+							{
+								match(AND_OP_EQ);
+								break;
+							}
+							case ASTERIX_EQ:
+							{
+								match(ASTERIX_EQ);
+								break;
+							}
+							case EQ_OP_EQ:
+							{
+								match(EQ_OP_EQ);
+								break;
+							}
+							case GE_OP_EQ:
+							{
+								match(GE_OP_EQ);
+								break;
+							}
+							case GTMARK_EQ:
+							{
+								match(GTMARK_EQ);
+								break;
+							}
+							case GT_OP_EQ:
+							{
+								match(GT_OP_EQ);
+								break;
+							}
+							case LE_OP_EQ:
+							{
+								match(LE_OP_EQ);
+								break;
+							}
+							case LTMARK_EQ:
+							{
+								match(LTMARK_EQ);
+								break;
+							}
+							case LT_OP_EQ:
+							{
+								match(LT_OP_EQ);
+								break;
+							}
+							case MATRIX_OP1_EQ:
+							{
+								match(MATRIX_OP1_EQ);
+								break;
+							}
+							case MATRIX_OP2_EQ:
+							{
+								match(MATRIX_OP2_EQ);
+								break;
+							}
+							case MINUS_EQ:
+							{
+								match(MINUS_EQ);
+								break;
+							}
+							case MOD_OP_EQ:
+							{
+								match(MOD_OP_EQ);
+								break;
+							}
+							case NE_OP_EQ:
+							{
+								match(NE_OP_EQ);
+								break;
+							}
+							case OR_OP_EQ:
+							{
+								match(OR_OP_EQ);
+								break;
+							}
+							case PLUS_EQ:
+							{
+								match(PLUS_EQ);
+								break;
+							}
+							case POW_EQ:
+							{
+								match(POW_EQ);
+								break;
+							}
+							case SLASH_EQ:
+							{
+								match(SLASH_EQ);
+								break;
+							}
+							case XOR_OP_EQ:
+							{
+								match(XOR_OP_EQ);
+								break;
+							}
+							case DEC:
+							{
+								match(DEC);
+								break;
+							}
+							case INC:
+							{
+								match(INC);
+								break;
+							}
+							case MEMBER:
+							{
+								match(MEMBER);
+								break;
+							}
+							default:
+							{
+								throw antlr::NoViableAltException(LT(1), getFilename());
+							}
+							}
+							}
+							}
+						}
+						catch (antlr::RecognitionException& pe) {
+							synPredMatched91 = false;
+						}
+						rewind(_m91);
+						inputState->guessing--;
+					}
+					if ( synPredMatched91 ) {
+						deref_expr();
+						if (inputState->guessing==0) {
+							astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+						}
+						{
+						switch ( LA(1)) {
+						case EQUAL:
+						{
+							match(EQUAL);
+							expr();
+							if (inputState->guessing==0) {
+								astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+							}
+							if ( inputState->guessing==0 ) {
+								statement_AST = RefDNode(currentAST.root);
+								statement_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(statement_AST))));
+								currentAST.root = statement_AST;
+								if ( statement_AST!=RefDNode(antlr::nullAST) &&
+									statement_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+									  currentAST.child = statement_AST->getFirstChild();
+								else
+									currentAST.child = statement_AST;
+								currentAST.advanceChildToEnd();
+							}
+							break;
+						}
+						case AND_OP_EQ:
+						case ASTERIX_EQ:
+						case EQ_OP_EQ:
+						case GE_OP_EQ:
+						case GTMARK_EQ:
+						case GT_OP_EQ:
+						case LE_OP_EQ:
+						case LTMARK_EQ:
+						case LT_OP_EQ:
+						case MATRIX_OP1_EQ:
+						case MATRIX_OP2_EQ:
+						case MINUS_EQ:
+						case MOD_OP_EQ:
+						case NE_OP_EQ:
+						case OR_OP_EQ:
+						case PLUS_EQ:
+						case POW_EQ:
+						case SLASH_EQ:
+						case XOR_OP_EQ:
+						{
+							{
+							switch ( LA(1)) {
+							case AND_OP_EQ:
+							{
+								RefDNode tmp39_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp39_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp39_AST));
+								}
+								match(AND_OP_EQ);
+								break;
+							}
+							case ASTERIX_EQ:
+							{
+								RefDNode tmp40_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp40_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp40_AST));
+								}
+								match(ASTERIX_EQ);
+								break;
+							}
+							case EQ_OP_EQ:
+							{
+								RefDNode tmp41_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp41_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp41_AST));
+								}
+								match(EQ_OP_EQ);
+								break;
+							}
+							case GE_OP_EQ:
+							{
+								RefDNode tmp42_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp42_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp42_AST));
+								}
+								match(GE_OP_EQ);
+								break;
+							}
+							case GTMARK_EQ:
+							{
+								RefDNode tmp43_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp43_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp43_AST));
+								}
+								match(GTMARK_EQ);
+								break;
+							}
+							case GT_OP_EQ:
+							{
+								RefDNode tmp44_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp44_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp44_AST));
+								}
+								match(GT_OP_EQ);
+								break;
+							}
+							case LE_OP_EQ:
+							{
+								RefDNode tmp45_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp45_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp45_AST));
+								}
+								match(LE_OP_EQ);
+								break;
+							}
+							case LTMARK_EQ:
+							{
+								RefDNode tmp46_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp46_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp46_AST));
+								}
+								match(LTMARK_EQ);
+								break;
+							}
+							case LT_OP_EQ:
+							{
+								RefDNode tmp47_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp47_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp47_AST));
+								}
+								match(LT_OP_EQ);
+								break;
+							}
+							case MATRIX_OP1_EQ:
+							{
+								RefDNode tmp48_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp48_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp48_AST));
+								}
+								match(MATRIX_OP1_EQ);
+								break;
+							}
+							case MATRIX_OP2_EQ:
+							{
+								RefDNode tmp49_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp49_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp49_AST));
+								}
+								match(MATRIX_OP2_EQ);
+								break;
+							}
+							case MINUS_EQ:
+							{
+								RefDNode tmp50_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp50_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp50_AST));
+								}
+								match(MINUS_EQ);
+								break;
+							}
+							case MOD_OP_EQ:
+							{
+								RefDNode tmp51_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp51_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp51_AST));
+								}
+								match(MOD_OP_EQ);
+								break;
+							}
+							case NE_OP_EQ:
+							{
+								RefDNode tmp52_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp52_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp52_AST));
+								}
+								match(NE_OP_EQ);
+								break;
+							}
+							case OR_OP_EQ:
+							{
+								RefDNode tmp53_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp53_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp53_AST));
+								}
+								match(OR_OP_EQ);
+								break;
+							}
+							case PLUS_EQ:
+							{
+								RefDNode tmp54_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp54_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp54_AST));
+								}
+								match(PLUS_EQ);
+								break;
+							}
+							case POW_EQ:
+							{
+								RefDNode tmp55_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp55_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp55_AST));
+								}
+								match(POW_EQ);
+								break;
+							}
+							case SLASH_EQ:
+							{
+								RefDNode tmp56_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp56_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp56_AST));
+								}
+								match(SLASH_EQ);
+								break;
+							}
+							case XOR_OP_EQ:
+							{
+								RefDNode tmp57_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp57_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp57_AST));
+								}
+								match(XOR_OP_EQ);
+								break;
+							}
+							default:
+							{
+								throw antlr::NoViableAltException(LT(1), getFilename());
+							}
+							}
+							}
+							expr();
+							if (inputState->guessing==0) {
+								astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+							}
+							break;
+						}
+						case DEC:
+						case INC:
+						{
+							{
+							switch ( LA(1)) {
+							case DEC:
+							{
+								RefDNode tmp58_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp58_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp58_AST));
+								}
+								match(DEC);
+								break;
+							}
+							case INC:
+							{
+								RefDNode tmp59_AST = RefDNode(antlr::nullAST);
+								if ( inputState->guessing == 0 ) {
+									tmp59_AST = astFactory->create(LT(1));
+									astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp59_AST));
+								}
+								match(INC);
+								break;
+							}
+							default:
+							{
+								throw antlr::NoViableAltException(LT(1), getFilename());
+							}
+							}
+							}
+							break;
+						}
+						case MEMBER:
+						{
+							match(MEMBER);
+							{
+							if ((LA(1) == IDENTIFIER) && (LA(2) == METHOD)) {
+								baseclass_method();
+								if (inputState->guessing==0) {
+									astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+								}
+								if ( inputState->guessing==0 ) {
+									parent=true;
+								}
+							}
+							else if ((LA(1) == IDENTIFIER) && (_tokenSet_7.member(LA(2)))) {
+							}
+							else {
+								throw antlr::NoViableAltException(LT(1), getFilename());
+							}
+							
+							}
+							formal_procedure_call();
+							if (inputState->guessing==0) {
+								astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+							}
+							if ( inputState->guessing==0 ) {
+								statement_AST = RefDNode(currentAST.root);
+								
+								if( parent)
+								statement_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MPCALL_PARENT,"mpcall::")))->add(antlr::RefAST(statement_AST))));
+								else
+								statement_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MPCALL,"mpcall")))->add(antlr::RefAST(statement_AST))));
+								
+								currentAST.root = statement_AST;
+								if ( statement_AST!=RefDNode(antlr::nullAST) &&
+									statement_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+									  currentAST.child = statement_AST->getFirstChild();
+								else
+									currentAST.child = statement_AST;
+								currentAST.advanceChildToEnd();
+							}
+							break;
+						}
+						default:
+						{
+							throw antlr::NoViableAltException(LT(1), getFilename());
+						}
+						}
+						}
+						statement_AST = RefDNode(currentAST.root);
+					}
+					else if ((_tokenSet_4.member(LA(1))) && (_tokenSet_5.member(LA(2)))) {
+						deref_dot_expr_keeplast();
+						if (inputState->guessing==0) {
+							d3_AST = returnAST;
+							astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+						}
+						formal_procedure_call();
+						if (inputState->guessing==0) {
+							astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+						}
+						if ( inputState->guessing==0 ) {
+							statement_AST = RefDNode(currentAST.root);
+							
+							statement_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MPCALL,"mpcall")))->add(antlr::RefAST(statement_AST))));
+							statement_AST->SetLine( d3_AST->getLine());
+							
+							currentAST.root = statement_AST;
+							if ( statement_AST!=RefDNode(antlr::nullAST) &&
+								statement_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+								  currentAST.child = statement_AST->getFirstChild();
+							else
+								currentAST.child = statement_AST;
+							currentAST.advanceChildToEnd();
+						}
+						statement_AST = RefDNode(currentAST.root);
+					}
+					else if ((LA(1) == IDENTIFIER) && (_tokenSet_7.member(LA(2)))) {
+						procedure_call();
+						if (inputState->guessing==0) {
+							astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+						}
+						statement_AST = RefDNode(currentAST.root);
+					}
 	else {
 		throw antlr::NoViableAltException(LT(1), getFilename());
 	}
-	}
+	}}}}
 	returnAST = statement_AST;
 }
 
@@ -2309,10 +2627,10 @@
 	int numBranch=0;
 	
 	
-	RefDNode tmp60_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp61_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp60_AST = astFactory->create(LT(1));
-		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp60_AST));
+		tmp61_AST = astFactory->create(LT(1));
+		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp61_AST));
 	}
 	match(SWITCH);
 	expr();
@@ -2396,7 +2714,7 @@
 	}
 	{ // ( ... )*
 	for (;;) {
-		if ((_tokenSet_7.member(LA(1)))) {
+		if ((_tokenSet_8.member(LA(1)))) {
 			switch_body();
 			if (inputState->guessing==0) {
 				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
@@ -2420,7 +2738,7 @@
 	}
 	if ( inputState->guessing==0 ) {
 		
-		tmp60_AST->SetNumBranch(numBranch);
+		tmp61_AST->SetNumBranch(numBranch);
 		
 	}
 	switch_statement_AST = RefDNode(currentAST.root);
@@ -2440,10 +2758,10 @@
 	switch ( LA(1)) {
 	case QUESTION:
 	{
-		RefDNode tmp62_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp63_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp62_AST = astFactory->create(LT(1));
-			astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp62_AST));
+			tmp63_AST = astFactory->create(LT(1));
+			astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp63_AST));
 		}
 		match(QUESTION);
 		expr();
@@ -2548,19 +2866,20 @@
 		match(COLON);
 		{
 		switch ( LA(1)) {
+		case FOR:
+		case FOREACH:
+		case REPEAT:
+		case WHILE:
 		case IDENTIFIER:
 		case CASE:
 		case COMMON:
 		case COMPILE_OPT:
-		case FOR:
 		case FORWARD:
 		case GOTO:
 		case IF:
 		case INHERITS:
 		case ON_IOERROR:
-		case REPEAT:
 		case SWITCH:
-		case WHILE:
 		case DEC:
 		case INC:
 		case LBRACE:
@@ -2620,19 +2939,20 @@
 		match(COLON);
 		{
 		switch ( LA(1)) {
+		case FOR:
+		case FOREACH:
+		case REPEAT:
+		case WHILE:
 		case IDENTIFIER:
 		case CASE:
 		case COMMON:
 		case COMPILE_OPT:
-		case FOR:
 		case FORWARD:
 		case GOTO:
 		case IF:
 		case INHERITS:
 		case ON_IOERROR:
-		case REPEAT:
 		case SWITCH:
-		case WHILE:
 		case DEC:
 		case INC:
 		case LBRACE:
@@ -2702,18 +3022,18 @@
 	switch ( LA(1)) {
 	case ENDSWITCH:
 	{
-		RefDNode tmp69_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp70_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp69_AST = astFactory->create(LT(1));
+			tmp70_AST = astFactory->create(LT(1));
 		}
 		match(ENDSWITCH);
 		break;
 	}
 	case END:
 	{
-		RefDNode tmp70_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp71_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp70_AST = astFactory->create(LT(1));
+			tmp71_AST = astFactory->create(LT(1));
 		}
 		match(END);
 		break;
@@ -2740,9 +3060,9 @@
 	}
 	case ENDELSE:
 	{
-		RefDNode tmp71_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp72_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp71_AST = astFactory->create(LT(1));
+			tmp72_AST = astFactory->create(LT(1));
 		}
 		match(ENDELSE);
 		break;
@@ -2763,10 +3083,10 @@
 	int numBranch=0;
 	
 	
-	RefDNode tmp72_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp73_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp72_AST = astFactory->create(LT(1));
-		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp72_AST));
+		tmp73_AST = astFactory->create(LT(1));
+		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp73_AST));
 	}
 	match(CASE);
 	expr();
@@ -2850,7 +3170,7 @@
 	}
 	{ // ( ... )*
 	for (;;) {
-		if ((_tokenSet_7.member(LA(1)))) {
+		if ((_tokenSet_8.member(LA(1)))) {
 			case_body();
 			if (inputState->guessing==0) {
 				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
@@ -2874,7 +3194,7 @@
 	}
 	if ( inputState->guessing==0 ) {
 		
-		tmp72_AST->SetNumBranch(numBranch);
+		tmp73_AST->SetNumBranch(numBranch);
 		
 	}
 	case_statement_AST = RefDNode(currentAST.root);
@@ -2947,19 +3267,20 @@
 		match(COLON);
 		{
 		switch ( LA(1)) {
+		case FOR:
+		case FOREACH:
+		case REPEAT:
+		case WHILE:
 		case IDENTIFIER:
 		case CASE:
 		case COMMON:
 		case COMPILE_OPT:
-		case FOR:
 		case FORWARD:
 		case GOTO:
 		case IF:
 		case INHERITS:
 		case ON_IOERROR:
-		case REPEAT:
 		case SWITCH:
-		case WHILE:
 		case DEC:
 		case INC:
 		case LBRACE:
@@ -3019,19 +3340,20 @@
 		match(COLON);
 		{
 		switch ( LA(1)) {
+		case FOR:
+		case FOREACH:
+		case REPEAT:
+		case WHILE:
 		case IDENTIFIER:
 		case CASE:
 		case COMMON:
 		case COMPILE_OPT:
-		case FOR:
 		case FORWARD:
 		case GOTO:
 		case IF:
 		case INHERITS:
 		case ON_IOERROR:
-		case REPEAT:
 		case SWITCH:
-		case WHILE:
 		case DEC:
 		case INC:
 		case LBRACE:
@@ -3101,18 +3423,18 @@
 	switch ( LA(1)) {
 	case ENDCASE:
 	{
-		RefDNode tmp79_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp80_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp79_AST = astFactory->create(LT(1));
+			tmp80_AST = astFactory->create(LT(1));
 		}
 		match(ENDCASE);
 		break;
 	}
 	case END:
 	{
-		RefDNode tmp80_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp81_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp80_AST = astFactory->create(LT(1));
+			tmp81_AST = astFactory->create(LT(1));
 		}
 		match(END);
 		break;
@@ -3139,9 +3461,9 @@
 	}
 	case ENDELSE:
 	{
-		RefDNode tmp81_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp82_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp81_AST = astFactory->create(LT(1));
+			tmp82_AST = astFactory->create(LT(1));
 		}
 		match(ENDELSE);
 		break;
@@ -3159,20 +3481,20 @@
 	antlr::ASTPair currentAST;
 	RefDNode identifier_list_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode tmp82_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp83_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp82_AST = astFactory->create(LT(1));
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp82_AST));
+		tmp83_AST = astFactory->create(LT(1));
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp83_AST));
 	}
 	match(IDENTIFIER);
 	{ // ( ... )*
 	for (;;) {
 		if ((LA(1) == COMMA)) {
 			match(COMMA);
-			RefDNode tmp84_AST = RefDNode(antlr::nullAST);
+			RefDNode tmp85_AST = RefDNode(antlr::nullAST);
 			if ( inputState->guessing == 0 ) {
-				tmp84_AST = astFactory->create(LT(1));
-				astFactory->addASTChild(currentAST, antlr::RefAST(tmp84_AST));
+				tmp85_AST = astFactory->create(LT(1));
+				astFactory->addASTChild(currentAST, antlr::RefAST(tmp85_AST));
 			}
 			match(IDENTIFIER);
 		}
@@ -3192,17 +3514,17 @@
 	antlr::ASTPair currentAST;
 	RefDNode keyword_declaration_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode tmp85_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp86_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp85_AST = astFactory->create(LT(1));
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp85_AST));
+		tmp86_AST = astFactory->create(LT(1));
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp86_AST));
 	}
 	match(IDENTIFIER);
 	match(EQUAL);
-	RefDNode tmp87_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp88_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp87_AST = astFactory->create(LT(1));
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp87_AST));
+		tmp88_AST = astFactory->create(LT(1));
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp88_AST));
 	}
 	match(IDENTIFIER);
 	if ( inputState->guessing==0 ) {
@@ -3275,9 +3597,9 @@
 	antlr::RefToken  ii = antlr::nullToken;
 	RefDNode ii_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode tmp88_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp89_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp88_AST = astFactory->create(LT(1));
+		tmp89_AST = astFactory->create(LT(1));
 	}
 	match(COMPILE_OPT);
 	i = LT(1);
@@ -3293,9 +3615,9 @@
 	{ // ( ... )*
 	for (;;) {
 		if ((LA(1) == COMMA)) {
-			RefDNode tmp89_AST = RefDNode(antlr::nullAST);
+			RefDNode tmp90_AST = RefDNode(antlr::nullAST);
 			if ( inputState->guessing == 0 ) {
-				tmp89_AST = astFactory->create(LT(1));
+				tmp90_AST = astFactory->create(LT(1));
 			}
 			match(COMMA);
 			ii = LT(1);
@@ -3319,26 +3641,35 @@
 	returnAST = compile_opt_AST;
 }
 
-void GDLParser::endfor_mark() {
+void GDLParser::endforeach_mark() {
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
-	RefDNode endfor_mark_AST = RefDNode(antlr::nullAST);
+	RefDNode endforeach_mark_AST = RefDNode(antlr::nullAST);
 	
 	switch ( LA(1)) {
+	case ENDFOREACH:
+	{
+		RefDNode tmp91_AST = RefDNode(antlr::nullAST);
+		if ( inputState->guessing == 0 ) {
+			tmp91_AST = astFactory->create(LT(1));
+		}
+		match(ENDFOREACH);
+		break;
+	}
 	case ENDFOR:
 	{
-		RefDNode tmp90_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp92_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp90_AST = astFactory->create(LT(1));
+			tmp92_AST = astFactory->create(LT(1));
 		}
 		match(ENDFOR);
 		break;
 	}
 	case END:
 	{
-		RefDNode tmp91_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp93_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp91_AST = astFactory->create(LT(1));
+			tmp93_AST = astFactory->create(LT(1));
 		}
 		match(END);
 		break;
@@ -3348,29 +3679,61 @@
 		throw antlr::NoViableAltException(LT(1), getFilename());
 	}
 	}
-	returnAST = endfor_mark_AST;
+	returnAST = endforeach_mark_AST;
 }
 
-void GDLParser::endrep_mark() {
+void GDLParser::endfor_mark() {
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
-	RefDNode endrep_mark_AST = RefDNode(antlr::nullAST);
+	RefDNode endfor_mark_AST = RefDNode(antlr::nullAST);
 	
 	switch ( LA(1)) {
-	case ENDREP:
+	case ENDFOR:
 	{
-		RefDNode tmp92_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp94_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp92_AST = astFactory->create(LT(1));
+			tmp94_AST = astFactory->create(LT(1));
 		}
-		match(ENDREP);
+		match(ENDFOR);
 		break;
 	}
 	case END:
 	{
-		RefDNode tmp93_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp95_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp93_AST = astFactory->create(LT(1));
+			tmp95_AST = astFactory->create(LT(1));
+		}
+		match(END);
+		break;
+	}
+	default:
+	{
+		throw antlr::NoViableAltException(LT(1), getFilename());
+	}
+	}
+	returnAST = endfor_mark_AST;
+}
+
+void GDLParser::endrep_mark() {
+	returnAST = RefDNode(antlr::nullAST);
+	antlr::ASTPair currentAST;
+	RefDNode endrep_mark_AST = RefDNode(antlr::nullAST);
+	
+	switch ( LA(1)) {
+	case ENDREP:
+	{
+		RefDNode tmp96_AST = RefDNode(antlr::nullAST);
+		if ( inputState->guessing == 0 ) {
+			tmp96_AST = astFactory->create(LT(1));
+		}
+		match(ENDREP);
+		break;
+	}
+	case END:
+	{
+		RefDNode tmp97_AST = RefDNode(antlr::nullAST);
+		if ( inputState->guessing == 0 ) {
+			tmp97_AST = astFactory->create(LT(1));
 		}
 		match(END);
 		break;
@@ -3391,18 +3754,18 @@
 	switch ( LA(1)) {
 	case ENDWHILE:
 	{
-		RefDNode tmp94_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp98_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp94_AST = astFactory->create(LT(1));
+			tmp98_AST = astFactory->create(LT(1));
 		}
 		match(ENDWHILE);
 		break;
 	}
 	case END:
 	{
-		RefDNode tmp95_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp99_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp95_AST = astFactory->create(LT(1));
+			tmp99_AST = astFactory->create(LT(1));
 		}
 		match(END);
 		break;
@@ -3423,18 +3786,18 @@
 	switch ( LA(1)) {
 	case ENDIF:
 	{
-		RefDNode tmp96_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp100_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp96_AST = astFactory->create(LT(1));
+			tmp100_AST = astFactory->create(LT(1));
 		}
 		match(ENDIF);
 		break;
 	}
 	case END:
 	{
-		RefDNode tmp97_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp101_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp97_AST = astFactory->create(LT(1));
+			tmp101_AST = astFactory->create(LT(1));
 		}
 		match(END);
 		break;
@@ -3455,18 +3818,18 @@
 	switch ( LA(1)) {
 	case ENDELSE:
 	{
-		RefDNode tmp98_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp102_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp98_AST = astFactory->create(LT(1));
+			tmp102_AST = astFactory->create(LT(1));
 		}
 		match(ENDELSE);
 		break;
 	}
 	case END:
 	{
-		RefDNode tmp99_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp103_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp99_AST = astFactory->create(LT(1));
+			tmp103_AST = astFactory->create(LT(1));
 		}
 		match(END);
 		break;
@@ -3485,19 +3848,20 @@
 	RefDNode compound_statement_AST = RefDNode(antlr::nullAST);
 	
 	switch ( LA(1)) {
+	case FOR:
+	case FOREACH:
+	case REPEAT:
+	case WHILE:
 	case IDENTIFIER:
 	case CASE:
 	case COMMON:
 	case COMPILE_OPT:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case INHERITS:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case DEC:
 	case INC:
 	case LBRACE:
@@ -3550,7 +3914,7 @@
 	RefDNode label_statement_AST = RefDNode(antlr::nullAST);
 	
 	{ // ( ... )+
-	int _cnt76=0;
+	int _cnt77=0;
 	for (;;) {
 		if ((LA(1) == IDENTIFIER) && (LA(2) == COLON)) {
 			label();
@@ -3559,29 +3923,30 @@
 			}
 		}
 		else {
-			if ( _cnt76>=1 ) { goto _loop76; } else {throw antlr::NoViableAltException(LT(1), getFilename());}
+			if ( _cnt77>=1 ) { goto _loop77; } else {throw antlr::NoViableAltException(LT(1), getFilename());}
 		}
 		
-		_cnt76++;
+		_cnt77++;
 	}
-	_loop76:;
+	_loop77:;
 	}  // ( ... )+
 	{
 	switch ( LA(1)) {
+	case FOR:
+	case FOREACH:
+	case REPEAT:
+	case WHILE:
 	case IDENTIFIER:
 	case BEGIN:
 	case CASE:
 	case COMMON:
 	case COMPILE_OPT:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case INHERITS:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case DEC:
 	case INC:
 	case LBRACE:
@@ -3613,16 +3978,16 @@
 	antlr::ASTPair currentAST;
 	RefDNode label_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode tmp101_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp105_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp101_AST = astFactory->create(LT(1));
-		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp101_AST));
+		tmp105_AST = astFactory->create(LT(1));
+		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp105_AST));
 	}
 	match(IDENTIFIER);
-	RefDNode tmp102_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp106_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp102_AST = astFactory->create(LT(1));
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp102_AST));
+		tmp106_AST = astFactory->create(LT(1));
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp106_AST));
 	}
 	match(COLON);
 	label_AST = RefDNode(currentAST.root);
@@ -3634,10 +3999,10 @@
 	antlr::ASTPair currentAST;
 	RefDNode baseclass_method_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode tmp103_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp107_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp103_AST = astFactory->create(LT(1));
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp103_AST));
+		tmp107_AST = astFactory->create(LT(1));
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp107_AST));
 	}
 	match(IDENTIFIER);
 	match(METHOD);
@@ -3676,6 +4041,123 @@
 	returnAST = assign_expr_AST;
 }
 
+void GDLParser::deref_dot_expr_keeplast() {
+	returnAST = RefDNode(antlr::nullAST);
+	antlr::ASTPair currentAST;
+	RefDNode deref_dot_expr_keeplast_AST = RefDNode(antlr::nullAST);
+	RefDNode a1_AST = RefDNode(antlr::nullAST);
+	
+	RefDNode dot;
+	int nDot;
+	
+	
+	switch ( LA(1)) {
+	case IDENTIFIER:
+	case INHERITS:
+	case LBRACE:
+	case SYSVARNAME:
+	{
+		array_expr_1st();
+		if (inputState->guessing==0) {
+			a1_AST = returnAST;
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
+		{
+		nDot=tag_access_keeplast();
+		if (inputState->guessing==0) {
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
+		if ( inputState->guessing==0 ) {
+			deref_dot_expr_keeplast_AST = RefDNode(currentAST.root);
+			
+			if( --nDot > 0)
+			{
+			dot=astFactory->create(DOT,".");
+			dot->SetNDot( nDot);    
+			dot->SetLine( a1_AST->getLine());
+			deref_dot_expr_keeplast_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(dot))->add(antlr::RefAST(deref_dot_expr_keeplast_AST))));
+			}
+			
+			currentAST.root = deref_dot_expr_keeplast_AST;
+			if ( deref_dot_expr_keeplast_AST!=RefDNode(antlr::nullAST) &&
+				deref_dot_expr_keeplast_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+				  currentAST.child = deref_dot_expr_keeplast_AST->getFirstChild();
+			else
+				currentAST.child = deref_dot_expr_keeplast_AST;
+			currentAST.advanceChildToEnd();
+		}
+		}
+		deref_dot_expr_keeplast_AST = RefDNode(currentAST.root);
+		break;
+	}
+	case ASTERIX:
+	{
+		match(ASTERIX);
+		deref_dot_expr_keeplast();
+		if (inputState->guessing==0) {
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
+		if ( inputState->guessing==0 ) {
+			deref_dot_expr_keeplast_AST = RefDNode(currentAST.root);
+			deref_dot_expr_keeplast_AST = 
+						RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(DEREF,"deref")))->add(antlr::RefAST(deref_dot_expr_keeplast_AST))));
+			currentAST.root = deref_dot_expr_keeplast_AST;
+			if ( deref_dot_expr_keeplast_AST!=RefDNode(antlr::nullAST) &&
+				deref_dot_expr_keeplast_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+				  currentAST.child = deref_dot_expr_keeplast_AST->getFirstChild();
+			else
+				currentAST.child = deref_dot_expr_keeplast_AST;
+			currentAST.advanceChildToEnd();
+		}
+		deref_dot_expr_keeplast_AST = RefDNode(currentAST.root);
+		break;
+	}
+	default:
+	{
+		throw antlr::NoViableAltException(LT(1), getFilename());
+	}
+	}
+	returnAST = deref_dot_expr_keeplast_AST;
+}
+
+void GDLParser::formal_procedure_call() {
+	returnAST = RefDNode(antlr::nullAST);
+	antlr::ASTPair currentAST;
+	RefDNode formal_procedure_call_AST = RefDNode(antlr::nullAST);
+	
+	RefDNode tmp113_AST = RefDNode(antlr::nullAST);
+	if ( inputState->guessing == 0 ) {
+		tmp113_AST = astFactory->create(LT(1));
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp113_AST));
+	}
+	match(IDENTIFIER);
+	{
+	switch ( LA(1)) {
+	case COMMA:
+	{
+		match(COMMA);
+		parameter_def_list();
+		if (inputState->guessing==0) {
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
+		break;
+	}
+	case ELSE:
+	case UNTIL:
+	case END_U:
+	{
+		break;
+	}
+	default:
+	{
+		throw antlr::NoViableAltException(LT(1), getFilename());
+	}
+	}
+	}
+	formal_procedure_call_AST = RefDNode(currentAST.root);
+	returnAST = formal_procedure_call_AST;
+}
+
 void GDLParser::deref_expr() {
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
@@ -3835,44 +4317,6 @@
 	returnAST = deref_expr_AST;
 }
 
-void GDLParser::formal_procedure_call() {
-	returnAST = RefDNode(antlr::nullAST);
-	antlr::ASTPair currentAST;
-	RefDNode formal_procedure_call_AST = RefDNode(antlr::nullAST);
-	
-	RefDNode tmp109_AST = RefDNode(antlr::nullAST);
-	if ( inputState->guessing == 0 ) {
-		tmp109_AST = astFactory->create(LT(1));
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp109_AST));
-	}
-	match(IDENTIFIER);
-	{
-	switch ( LA(1)) {
-	case COMMA:
-	{
-		match(COMMA);
-		parameter_def_list();
-		if (inputState->guessing==0) {
-			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		}
-		break;
-	}
-	case ELSE:
-	case UNTIL:
-	case END_U:
-	{
-		break;
-	}
-	default:
-	{
-		throw antlr::NoViableAltException(LT(1), getFilename());
-	}
-	}
-	}
-	formal_procedure_call_AST = RefDNode(currentAST.root);
-	returnAST = formal_procedure_call_AST;
-}
-
 void GDLParser::procedure_call() {
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
@@ -3888,7 +4332,7 @@
 	}
 	match(IDENTIFIER);
 	{
-	if (((_tokenSet_6.member(LA(1))) && (_tokenSet_1.member(LA(2))))&&(id->getText() == "RETURN")) {
+	if (((_tokenSet_7.member(LA(1))) && (_tokenSet_1.member(LA(2))))&&(id->getText() == "RETURN")) {
 		{
 		switch ( LA(1)) {
 		case COMMA:
@@ -3959,7 +4403,7 @@
 			currentAST.advanceChildToEnd();
 		}
 	}
-	else if ((_tokenSet_6.member(LA(1))) && (_tokenSet_8.member(LA(2)))) {
+	else if ((_tokenSet_7.member(LA(1))) && (_tokenSet_9.member(LA(2)))) {
 		{
 		switch ( LA(1)) {
 		case COMMA:
@@ -4011,16 +4455,16 @@
 	antlr::ASTPair currentAST;
 	RefDNode for_statement_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode tmp113_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp118_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp113_AST = astFactory->create(LT(1));
-		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp113_AST));
+		tmp118_AST = astFactory->create(LT(1));
+		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp118_AST));
 	}
 	match(FOR);
-	RefDNode tmp114_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp119_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp114_AST = astFactory->create(LT(1));
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp114_AST));
+		tmp119_AST = astFactory->create(LT(1));
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp119_AST));
 	}
 	match(IDENTIFIER);
 	match(EQUAL);
@@ -4063,15 +4507,46 @@
 	returnAST = for_statement_AST;
 }
 
+void GDLParser::foreach_statement() {
+	returnAST = RefDNode(antlr::nullAST);
+	antlr::ASTPair currentAST;
+	RefDNode foreach_statement_AST = RefDNode(antlr::nullAST);
+	
+	RefDNode tmp124_AST = RefDNode(antlr::nullAST);
+	if ( inputState->guessing == 0 ) {
+		tmp124_AST = astFactory->create(LT(1));
+		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp124_AST));
+	}
+	match(FOREACH);
+	RefDNode tmp125_AST = RefDNode(antlr::nullAST);
+	if ( inputState->guessing == 0 ) {
+		tmp125_AST = astFactory->create(LT(1));
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp125_AST));
+	}
+	match(IDENTIFIER);
+	match(OF);
+	expr();
+	if (inputState->guessing==0) {
+		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+	}
+	match(DO);
+	foreach_block();
+	if (inputState->guessing==0) {
+		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+	}
+	foreach_statement_AST = RefDNode(currentAST.root);
+	returnAST = foreach_statement_AST;
+}
+
 void GDLParser::repeat_statement() {
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
 	RefDNode repeat_statement_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode tmp119_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp128_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp119_AST = astFactory->create(LT(1));
-		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp119_AST));
+		tmp128_AST = astFactory->create(LT(1));
+		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp128_AST));
 	}
 	match(REPEAT);
 	repeat_block();
@@ -4092,10 +4567,10 @@
 	antlr::ASTPair currentAST;
 	RefDNode while_statement_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode tmp121_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp130_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp121_AST = astFactory->create(LT(1));
-		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp121_AST));
+		tmp130_AST = astFactory->create(LT(1));
+		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp130_AST));
 	}
 	match(WHILE);
 	expr();
@@ -4119,17 +4594,17 @@
 	switch ( LA(1)) {
 	case GOTO:
 	{
-		RefDNode tmp123_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp132_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp123_AST = astFactory->create(LT(1));
-			astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp123_AST));
+			tmp132_AST = astFactory->create(LT(1));
+			astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp132_AST));
 		}
 		match(GOTO);
 		match(COMMA);
-		RefDNode tmp125_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp134_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp125_AST = astFactory->create(LT(1));
-			astFactory->addASTChild(currentAST, antlr::RefAST(tmp125_AST));
+			tmp134_AST = astFactory->create(LT(1));
+			astFactory->addASTChild(currentAST, antlr::RefAST(tmp134_AST));
 		}
 		match(IDENTIFIER);
 		jump_statement_AST = RefDNode(currentAST.root);
@@ -4137,17 +4612,17 @@
 	}
 	case ON_IOERROR:
 	{
-		RefDNode tmp126_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp135_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp126_AST = astFactory->create(LT(1));
-			astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp126_AST));
+			tmp135_AST = astFactory->create(LT(1));
+			astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp135_AST));
 		}
 		match(ON_IOERROR);
 		match(COMMA);
-		RefDNode tmp128_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp137_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp128_AST = astFactory->create(LT(1));
-			astFactory->addASTChild(currentAST, antlr::RefAST(tmp128_AST));
+			tmp137_AST = astFactory->create(LT(1));
+			astFactory->addASTChild(currentAST, antlr::RefAST(tmp137_AST));
 		}
 		match(IDENTIFIER);
 		jump_statement_AST = RefDNode(currentAST.root);
@@ -4166,10 +4641,10 @@
 	antlr::ASTPair currentAST;
 	RefDNode if_statement_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode tmp129_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp138_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp129_AST = astFactory->create(LT(1));
-		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp129_AST));
+		tmp138_AST = astFactory->create(LT(1));
+		astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp138_AST));
 	}
 	match(IF);
 	expr();
@@ -4208,19 +4683,20 @@
 	RefDNode stl_AST = RefDNode(antlr::nullAST);
 	
 	switch ( LA(1)) {
+	case FOR:
+	case FOREACH:
+	case REPEAT:
+	case WHILE:
 	case IDENTIFIER:
 	case CASE:
 	case COMMON:
 	case COMPILE_OPT:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case INHERITS:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case DEC:
 	case INC:
 	case LBRACE:
@@ -4286,19 +4762,20 @@
 	RefDNode while_block_AST = RefDNode(antlr::nullAST);
 	
 	switch ( LA(1)) {
+	case FOR:
+	case FOREACH:
+	case REPEAT:
+	case WHILE:
 	case IDENTIFIER:
 	case CASE:
 	case COMMON:
 	case COMPILE_OPT:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case INHERITS:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case DEC:
 	case INC:
 	case LBRACE:
@@ -4353,19 +4830,101 @@
 	RefDNode stl_AST = RefDNode(antlr::nullAST);
 	
 	switch ( LA(1)) {
+	case FOR:
+	case FOREACH:
+	case REPEAT:
+	case WHILE:
+	case IDENTIFIER:
+	case CASE:
+	case COMMON:
+	case COMPILE_OPT:
+	case FORWARD:
+	case GOTO:
+	case IF:
+	case INHERITS:
+	case ON_IOERROR:
+	case SWITCH:
+	case DEC:
+	case INC:
+	case LBRACE:
+	case SYSVARNAME:
+	case ASTERIX:
+	{
+		statement();
+		if (inputState->guessing==0) {
+			st_AST = returnAST;
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
+		if ( inputState->guessing==0 ) {
+			for_block_AST = RefDNode(currentAST.root);
+			for_block_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(BLOCK,"block")))->add(antlr::RefAST(st_AST))));
+			currentAST.root = for_block_AST;
+			if ( for_block_AST!=RefDNode(antlr::nullAST) &&
+				for_block_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+				  currentAST.child = for_block_AST->getFirstChild();
+			else
+				currentAST.child = for_block_AST;
+			currentAST.advanceChildToEnd();
+		}
+		for_block_AST = RefDNode(currentAST.root);
+		break;
+	}
+	case BEGIN:
+	{
+		match(BEGIN);
+		statement_list();
+		if (inputState->guessing==0) {
+			stl_AST = returnAST;
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
+		endfor_mark();
+		if (inputState->guessing==0) {
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
+		if ( inputState->guessing==0 ) {
+			for_block_AST = RefDNode(currentAST.root);
+			for_block_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(BLOCK,"block")))->add(antlr::RefAST(stl_AST))));
+			currentAST.root = for_block_AST;
+			if ( for_block_AST!=RefDNode(antlr::nullAST) &&
+				for_block_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+				  currentAST.child = for_block_AST->getFirstChild();
+			else
+				currentAST.child = for_block_AST;
+			currentAST.advanceChildToEnd();
+		}
+		for_block_AST = RefDNode(currentAST.root);
+		break;
+	}
+	default:
+	{
+		throw antlr::NoViableAltException(LT(1), getFilename());
+	}
+	}
+	returnAST = for_block_AST;
+}
+
+void GDLParser::foreach_block() {
+	returnAST = RefDNode(antlr::nullAST);
+	antlr::ASTPair currentAST;
+	RefDNode foreach_block_AST = RefDNode(antlr::nullAST);
+	RefDNode st_AST = RefDNode(antlr::nullAST);
+	RefDNode stl_AST = RefDNode(antlr::nullAST);
+	
+	switch ( LA(1)) {
+	case FOR:
+	case FOREACH:
+	case REPEAT:
+	case WHILE:
 	case IDENTIFIER:
 	case CASE:
 	case COMMON:
 	case COMPILE_OPT:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case INHERITS:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case DEC:
 	case INC:
 	case LBRACE:
@@ -4378,17 +4937,17 @@
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 		}
 		if ( inputState->guessing==0 ) {
-			for_block_AST = RefDNode(currentAST.root);
-			for_block_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(BLOCK,"block")))->add(antlr::RefAST(st_AST))));
-			currentAST.root = for_block_AST;
-			if ( for_block_AST!=RefDNode(antlr::nullAST) &&
-				for_block_AST->getFirstChild() != RefDNode(antlr::nullAST) )
-				  currentAST.child = for_block_AST->getFirstChild();
+			foreach_block_AST = RefDNode(currentAST.root);
+			foreach_block_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(BLOCK,"block")))->add(antlr::RefAST(st_AST))));
+			currentAST.root = foreach_block_AST;
+			if ( foreach_block_AST!=RefDNode(antlr::nullAST) &&
+				foreach_block_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+				  currentAST.child = foreach_block_AST->getFirstChild();
 			else
-				currentAST.child = for_block_AST;
+				currentAST.child = foreach_block_AST;
 			currentAST.advanceChildToEnd();
 		}
-		for_block_AST = RefDNode(currentAST.root);
+		foreach_block_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case BEGIN:
@@ -4399,22 +4958,22 @@
 			stl_AST = returnAST;
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 		}
-		endfor_mark();
+		endforeach_mark();
 		if (inputState->guessing==0) {
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 		}
 		if ( inputState->guessing==0 ) {
-			for_block_AST = RefDNode(currentAST.root);
-			for_block_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(BLOCK,"block")))->add(antlr::RefAST(stl_AST))));
-			currentAST.root = for_block_AST;
-			if ( for_block_AST!=RefDNode(antlr::nullAST) &&
-				for_block_AST->getFirstChild() != RefDNode(antlr::nullAST) )
-				  currentAST.child = for_block_AST->getFirstChild();
+			foreach_block_AST = RefDNode(currentAST.root);
+			foreach_block_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(BLOCK,"block")))->add(antlr::RefAST(stl_AST))));
+			currentAST.root = foreach_block_AST;
+			if ( foreach_block_AST!=RefDNode(antlr::nullAST) &&
+				foreach_block_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+				  currentAST.child = foreach_block_AST->getFirstChild();
 			else
-				currentAST.child = for_block_AST;
+				currentAST.child = foreach_block_AST;
 			currentAST.advanceChildToEnd();
 		}
-		for_block_AST = RefDNode(currentAST.root);
+		foreach_block_AST = RefDNode(currentAST.root);
 		break;
 	}
 	default:
@@ -4422,7 +4981,7 @@
 		throw antlr::NoViableAltException(LT(1), getFilename());
 	}
 	}
-	returnAST = for_block_AST;
+	returnAST = foreach_block_AST;
 }
 
 void GDLParser::if_block() {
@@ -4431,19 +4990,20 @@
 	RefDNode if_block_AST = RefDNode(antlr::nullAST);
 	
 	switch ( LA(1)) {
+	case FOR:
+	case FOREACH:
+	case REPEAT:
+	case WHILE:
 	case IDENTIFIER:
 	case CASE:
 	case COMMON:
 	case COMPILE_OPT:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case INHERITS:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case DEC:
 	case INC:
 	case LBRACE:
@@ -4496,19 +5056,20 @@
 	RefDNode else_block_AST = RefDNode(antlr::nullAST);
 	
 	switch ( LA(1)) {
+	case FOR:
+	case FOREACH:
+	case REPEAT:
+	case WHILE:
 	case IDENTIFIER:
 	case CASE:
 	case COMMON:
 	case COMPILE_OPT:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case INHERITS:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case DEC:
 	case INC:
 	case LBRACE:
@@ -4574,11 +5135,11 @@
 			}
 		}
 		else {
-			goto _loop113;
+			goto _loop122;
 		}
 		
 	}
-	_loop113:;
+	_loop122:;
 	} // ( ... )*
 	parameter_def_list_AST = RefDNode(currentAST.root);
 	returnAST = parameter_def_list_AST;
@@ -4589,15 +5150,19 @@
 	antlr::ASTPair currentAST;
 	RefDNode formal_function_call_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode tmp138_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp148_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp138_AST = astFactory->create(LT(1));
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp138_AST));
+		tmp148_AST = astFactory->create(LT(1));
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp148_AST));
 	}
 	match(IDENTIFIER);
 	match(LBRACE);
 	{
 	switch ( LA(1)) {
+	case FOR:
+	case FOREACH:
+	case REPEAT:
+	case WHILE:
 	case IDENTIFIER:
 	case AND_OP:
 	case BEGIN:
@@ -4610,12 +5175,12 @@
 	case ENDCASE:
 	case ENDELSE:
 	case ENDFOR:
+	case ENDFOREACH:
 	case ENDIF:
 	case ENDREP:
 	case ENDSWITCH:
 	case ENDWHILE:
 	case EQ_OP:
-	case FOR:
 	case FORWARD:
 	case FUNCTION:
 	case GE_OP:
@@ -4632,11 +5197,9 @@
 	case ON_IOERROR:
 	case OR_OP:
 	case PRO:
-	case REPEAT:
 	case SWITCH:
 	case THEN:
 	case UNTIL:
-	case WHILE:
 	case XOR_OP:
 	case DEC:
 	case INC:
@@ -4716,7 +5279,7 @@
 	RefDNode parameter_def_AST = RefDNode(antlr::nullAST);
 	RefDNode id_AST = RefDNode(antlr::nullAST);
 	
-	if (((LA(1) >= IDENTIFIER && LA(1) <= XOR_OP)) && (LA(2) == EQUAL)) {
+	if ((_tokenSet_10.member(LA(1))) && (LA(2) == EQUAL)) {
 		identifier();
 		if (inputState->guessing==0) {
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
@@ -4740,7 +5303,7 @@
 		}
 		parameter_def_AST = RefDNode(currentAST.root);
 	}
-	else if ((_tokenSet_9.member(LA(1))) && (_tokenSet_10.member(LA(2)))) {
+	else if ((_tokenSet_11.member(LA(1))) && (_tokenSet_12.member(LA(2)))) {
 		expr();
 		if (inputState->guessing==0) {
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
@@ -4814,11 +5377,11 @@
 			}
 		}
 		else {
-			goto _loop116;
+			goto _loop125;
 		}
 		
 	}
-	_loop116:;
+	_loop125:;
 	} // ( ... )*
 	match(RSQUARE);
 	if ( inputState->guessing==0 ) {
@@ -4856,10 +5419,10 @@
 	switch ( LA(1)) {
 	case IDENTIFIER:
 	{
-		RefDNode tmp146_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp156_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp146_AST = astFactory->create(LT(1));
-			astFactory->addASTChild(currentAST, antlr::RefAST(tmp146_AST));
+			tmp156_AST = astFactory->create(LT(1));
+			astFactory->addASTChild(currentAST, antlr::RefAST(tmp156_AST));
 		}
 		match(IDENTIFIER);
 		break;
@@ -4920,7 +5483,7 @@
 	
 	match(LCURLY);
 	{
-	if ((_tokenSet_11.member(LA(1))) && (LA(2) == COMMA || LA(2) == RCURLY)) {
+	if ((_tokenSet_13.member(LA(1))) && (LA(2) == COMMA || LA(2) == RCURLY)) {
 		struct_identifier();
 		if (inputState->guessing==0) {
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
@@ -4960,7 +5523,7 @@
 			currentAST.advanceChildToEnd();
 		}
 	}
-	else if ((_tokenSet_11.member(LA(1))) && (LA(2) == COLON)) {
+	else if ((_tokenSet_13.member(LA(1))) && (LA(2) == COLON)) {
 		tag_def_list();
 		if (inputState->guessing==0) {
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
@@ -5007,11 +5570,11 @@
 			}
 		}
 		else {
-			goto _loop136;
+			goto _loop145;
 		}
 		
 	}
-	_loop136:;
+	_loop145:;
 	} // ( ... )*
 	named_tag_def_list_AST = RefDNode(currentAST.root);
 	returnAST = named_tag_def_list_AST;
@@ -5036,11 +5599,11 @@
 			}
 		}
 		else {
-			goto _loop125;
+			goto _loop134;
 		}
 		
 	}
-	_loop125:;
+	_loop134:;
 	} // ( ... )*
 	tag_def_list_AST = RefDNode(currentAST.root);
 	returnAST = tag_def_list_AST;
@@ -5069,14 +5632,14 @@
 	antlr::ASTPair currentAST;
 	RefDNode ntag_def_AST = RefDNode(antlr::nullAST);
 	
-	if ((_tokenSet_11.member(LA(1))) && (LA(2) == COLON)) {
+	if ((_tokenSet_13.member(LA(1))) && (LA(2) == COLON)) {
 		tag_def();
 		if (inputState->guessing==0) {
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 		}
 		ntag_def_AST = RefDNode(currentAST.root);
 	}
-	else if ((_tokenSet_9.member(LA(1))) && (_tokenSet_12.member(LA(2)))) {
+	else if ((_tokenSet_11.member(LA(1))) && (_tokenSet_14.member(LA(2)))) {
 		expr();
 		if (inputState->guessing==0) {
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
@@ -5109,11 +5672,11 @@
 			}
 		}
 		else {
-			goto _loop129;
+			goto _loop138;
 		}
 		
 	}
-	_loop129:;
+	_loop138:;
 	} // ( ... )*
 	ntag_defs_AST = RefDNode(currentAST.root);
 	returnAST = ntag_defs_AST;
@@ -5125,10 +5688,10 @@
 	RefDNode named_tag_def_entry_AST = RefDNode(antlr::nullAST);
 	
 	{
-	bool synPredMatched133 = false;
-	if (((LA(1) == INHERITS) && (_tokenSet_11.member(LA(2))))) {
-		int _m133 = mark();
-		synPredMatched133 = true;
+	bool synPredMatched142 = false;
+	if (((LA(1) == INHERITS) && (_tokenSet_13.member(LA(2))))) {
+		int _m142 = mark();
+		synPredMatched142 = true;
 		inputState->guessing++;
 		try {
 			{
@@ -5136,16 +5699,16 @@
 			}
 		}
 		catch (antlr::RecognitionException& pe) {
-			synPredMatched133 = false;
+			synPredMatched142 = false;
 		}
-		rewind(_m133);
+		rewind(_m142);
 		inputState->guessing--;
 	}
-	if ( synPredMatched133 ) {
-		RefDNode tmp155_AST = RefDNode(antlr::nullAST);
+	if ( synPredMatched142 ) {
+		RefDNode tmp165_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp155_AST = astFactory->create(LT(1));
-			astFactory->addASTChild(currentAST, antlr::RefAST(tmp155_AST));
+			tmp165_AST = astFactory->create(LT(1));
+			astFactory->addASTChild(currentAST, antlr::RefAST(tmp165_AST));
 		}
 		match(INHERITS);
 		struct_identifier();
@@ -5153,7 +5716,7 @@
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 		}
 	}
-	else if ((_tokenSet_13.member(LA(1))) && (_tokenSet_14.member(LA(2)))) {
+	else if ((_tokenSet_15.member(LA(1))) && (_tokenSet_16.member(LA(2)))) {
 		ntag_def();
 		if (inputState->guessing==0) {
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
@@ -6179,11 +6742,11 @@
 				}
 			}
 			else {
-				goto _loop140;
+				goto _loop149;
 			}
 			
 		}
-		_loop140:;
+		_loop149:;
 		} // ( ... )*
 		match(RSQUARE);
 		arrayindex_list_AST = RefDNode(currentAST.root);
@@ -6206,11 +6769,11 @@
 				}
 			}
 			else {
-				goto _loop142;
+				goto _loop151;
 			}
 			
 		}
-		_loop142:;
+		_loop151:;
 		} // ( ... )*
 		match(RBRACE);
 		arrayindex_list_AST = RefDNode(currentAST.root);
@@ -6230,10 +6793,10 @@
 	RefDNode arrayindex_AST = RefDNode(antlr::nullAST);
 	
 	{
-	bool synPredMatched148 = false;
+	bool synPredMatched157 = false;
 	if (((LA(1) == ASTERIX) && (LA(2) == COMMA || LA(2) == RBRACE || LA(2) == RSQUARE))) {
-		int _m148 = mark();
-		synPredMatched148 = true;
+		int _m157 = mark();
+		synPredMatched157 = true;
 		inputState->guessing++;
 		try {
 			{
@@ -6264,18 +6827,18 @@
 			}
 		}
 		catch (antlr::RecognitionException& pe) {
-			synPredMatched148 = false;
+			synPredMatched157 = false;
 		}
-		rewind(_m148);
+		rewind(_m157);
 		inputState->guessing--;
 	}
-	if ( synPredMatched148 ) {
+	if ( synPredMatched157 ) {
 		all();
 		if (inputState->guessing==0) {
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 		}
 	}
-	else if ((_tokenSet_9.member(LA(1))) && (_tokenSet_15.member(LA(2)))) {
+	else if ((_tokenSet_11.member(LA(1))) && (_tokenSet_17.member(LA(2)))) {
 		expr();
 		if (inputState->guessing==0) {
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
@@ -6286,10 +6849,10 @@
 		{
 			match(COLON);
 			{
-			bool synPredMatched153 = false;
-			if (((LA(1) == ASTERIX) && (_tokenSet_16.member(LA(2))))) {
-				int _m153 = mark();
-				synPredMatched153 = true;
+			bool synPredMatched162 = false;
+			if (((LA(1) == ASTERIX) && (_tokenSet_18.member(LA(2))))) {
+				int _m162 = mark();
+				synPredMatched162 = true;
 				inputState->guessing++;
 				try {
 					{
@@ -6325,18 +6888,18 @@
 					}
 				}
 				catch (antlr::RecognitionException& pe) {
-					synPredMatched153 = false;
+					synPredMatched162 = false;
 				}
-				rewind(_m153);
+				rewind(_m162);
 				inputState->guessing--;
 			}
-			if ( synPredMatched153 ) {
+			if ( synPredMatched162 ) {
 				all();
 				if (inputState->guessing==0) {
 					astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 				}
 			}
-			else if ((_tokenSet_9.member(LA(1))) && (_tokenSet_15.member(LA(2)))) {
+			else if ((_tokenSet_11.member(LA(1))) && (_tokenSet_17.member(LA(2)))) {
 				expr();
 				if (inputState->guessing==0) {
 					astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
@@ -6353,10 +6916,10 @@
 			{
 				match(COLON);
 				{
-				bool synPredMatched158 = false;
+				bool synPredMatched167 = false;
 				if (((LA(1) == ASTERIX) && (LA(2) == COMMA || LA(2) == RBRACE || LA(2) == RSQUARE))) {
-					int _m158 = mark();
-					synPredMatched158 = true;
+					int _m167 = mark();
+					synPredMatched167 = true;
 					inputState->guessing++;
 					try {
 						{
@@ -6387,12 +6950,12 @@
 						}
 					}
 					catch (antlr::RecognitionException& pe) {
-						synPredMatched158 = false;
+						synPredMatched167 = false;
 					}
-					rewind(_m158);
+					rewind(_m167);
 					inputState->guessing--;
 				}
-				if ( synPredMatched158 ) {
+				if ( synPredMatched167 ) {
 					match(ASTERIX);
 					if ( inputState->guessing==0 ) {
 						
@@ -6401,7 +6964,7 @@
 						
 					}
 				}
-				else if ((_tokenSet_9.member(LA(1))) && (_tokenSet_17.member(LA(2)))) {
+				else if ((_tokenSet_11.member(LA(1))) && (_tokenSet_19.member(LA(2)))) {
 					expr();
 					if (inputState->guessing==0) {
 						astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
@@ -6466,9 +7029,9 @@
 	antlr::ASTPair currentAST;
 	RefDNode all_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode tmp165_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp175_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp165_AST = astFactory->create(LT(1));
+		tmp175_AST = astFactory->create(LT(1));
 	}
 	match(ASTERIX);
 	if ( inputState->guessing==0 ) {
@@ -6490,10 +7053,10 @@
 	antlr::ASTPair currentAST;
 	RefDNode sysvar_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode tmp166_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp176_AST = RefDNode(antlr::nullAST);
 	if ( inputState->guessing == 0 ) {
-		tmp166_AST = astFactory->create(LT(1));
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp166_AST));
+		tmp176_AST = astFactory->create(LT(1));
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp176_AST));
 	}
 	match(SYSVARNAME);
 	if ( inputState->guessing==0 ) {
@@ -6768,10 +7331,10 @@
 	switch ( LA(1)) {
 	case IDENTIFIER:
 	{
-		RefDNode tmp169_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp179_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp169_AST = astFactory->create(LT(1));
-			astFactory->addASTChild(currentAST, antlr::RefAST(tmp169_AST));
+			tmp179_AST = astFactory->create(LT(1));
+			astFactory->addASTChild(currentAST, antlr::RefAST(tmp179_AST));
 		}
 		match(IDENTIFIER);
 		array_expr_nth_sub_AST = RefDNode(currentAST.root);
@@ -6864,10 +7427,10 @@
 	switch ( LA(1)) {
 	case IDENTIFIER:
 	{
-		RefDNode tmp170_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp180_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp170_AST = astFactory->create(LT(1));
-			astFactory->addASTChild(currentAST, antlr::RefAST(tmp170_AST));
+			tmp180_AST = astFactory->create(LT(1));
+			astFactory->addASTChild(currentAST, antlr::RefAST(tmp180_AST));
 		}
 		match(IDENTIFIER);
 		tag_array_expr_nth_sub_AST = RefDNode(currentAST.root);
@@ -7033,6 +7596,63 @@
 	returnAST = tag_array_expr_nth_AST;
 }
 
+int  GDLParser::tag_access_keeplast() {
+	int nDot;
+	returnAST = RefDNode(antlr::nullAST);
+	antlr::ASTPair currentAST;
+	RefDNode tag_access_keeplast_AST = RefDNode(antlr::nullAST);
+	
+	int t;
+	bool parent = false;
+	nDot=1;
+	
+	
+	match(DOT);
+	{
+	bool synPredMatched184 = false;
+	if (((_tokenSet_20.member(LA(1))) && (_tokenSet_5.member(LA(2))))) {
+		int _m184 = mark();
+		synPredMatched184 = true;
+		inputState->guessing++;
+		try {
+			{
+			tag_array_expr_nth();
+			tag_access_keeplast();
+			}
+		}
+		catch (antlr::RecognitionException& pe) {
+			synPredMatched184 = false;
+		}
+		rewind(_m184);
+		inputState->guessing--;
+	}
+	if ( synPredMatched184 ) {
+		{
+		tag_array_expr_nth();
+		if (inputState->guessing==0) {
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
+		t=tag_access_keeplast();
+		if (inputState->guessing==0) {
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
+		if ( inputState->guessing==0 ) {
+			nDot += t;
+		}
+		}
+	}
+	else if ((LA(1) == IDENTIFIER) && (_tokenSet_21.member(LA(2)))) {
+	}
+	else {
+		throw antlr::NoViableAltException(LT(1), getFilename());
+	}
+	
+	}
+	tag_access_keeplast_AST = RefDNode(currentAST.root);
+	returnAST = tag_access_keeplast_AST;
+	return nDot;
+}
+
 SizeT  GDLParser::tag_access() {
 	SizeT nDot;
 	returnAST = RefDNode(antlr::nullAST);
@@ -7043,12 +7663,12 @@
 	
 	
 	{ // ( ... )+
-	int _cnt174=0;
+	int _cnt190=0;
 	for (;;) {
 		if ((LA(1) == DOT)) {
 			match(DOT);
 			if ( inputState->guessing==0 ) {
-				nDot++;
+				++nDot;
 			}
 			tag_array_expr_nth();
 			if (inputState->guessing==0) {
@@ -7056,113 +7676,86 @@
 			}
 		}
 		else {
-			if ( _cnt174>=1 ) { goto _loop174; } else {throw antlr::NoViableAltException(LT(1), getFilename());}
+			if ( _cnt190>=1 ) { goto _loop190; } else {throw antlr::NoViableAltException(LT(1), getFilename());}
 		}
 		
-		_cnt174++;
+		_cnt190++;
 	}
-	_loop174:;
+	_loop190:;
 	}  // ( ... )+
 	tag_access_AST = RefDNode(currentAST.root);
 	returnAST = tag_access_AST;
 	return nDot;
 }
 
-void GDLParser::array_expr_fn() {
+void GDLParser::deref_dot_expr() {
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
-	RefDNode array_expr_fn_AST = RefDNode(antlr::nullAST);
-	RefDNode v_AST = RefDNode(antlr::nullAST);
-	RefDNode al_AST = RefDNode(antlr::nullAST);
+	RefDNode deref_dot_expr_AST = RefDNode(antlr::nullAST);
+	RefDNode a1_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode dot, t;
+	RefDNode dot;
 	SizeT nDot;
 	
 	
-	var();
-	if (inputState->guessing==0) {
-		v_AST = returnAST;
-	}
-	arrayindex_list();
-	if (inputState->guessing==0) {
-		al_AST = returnAST;
-	}
-	{
 	switch ( LA(1)) {
-	case DOT:
+	case IDENTIFIER:
+	case INHERITS:
+	case LBRACE:
+	case SYSVARNAME:
 	{
+		array_expr_1st();
+		if (inputState->guessing==0) {
+			a1_AST = returnAST;
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
+		{
 		nDot=tag_access();
+		if (inputState->guessing==0) {
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
 		if ( inputState->guessing==0 ) {
-			array_expr_fn_AST = RefDNode(currentAST.root);
-			// -> do so 
-			t= RefDNode(returnAST);    
+			deref_dot_expr_AST = RefDNode(currentAST.root);
+			
 			
 			dot=astFactory->create(DOT,".");
 			dot->SetNDot( nDot);    
-			dot->SetLine( al_AST->getLine());
+			dot->SetLine( a1_AST->getLine());
 			
-			array_expr_fn_AST = 
-				  		RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(dot))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ARRAYEXPR,"arrayexpr")))->add(antlr::RefAST(v_AST))->add(antlr::RefAST(al_AST))))))->add(antlr::RefAST(t))));
-			currentAST.root = array_expr_fn_AST;
-			if ( array_expr_fn_AST!=RefDNode(antlr::nullAST) &&
-				array_expr_fn_AST->getFirstChild() != RefDNode(antlr::nullAST) )
-				  currentAST.child = array_expr_fn_AST->getFirstChild();
+			deref_dot_expr_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(dot))->add(antlr::RefAST(deref_dot_expr_AST))));
+			
+			currentAST.root = deref_dot_expr_AST;
+			if ( deref_dot_expr_AST!=RefDNode(antlr::nullAST) &&
+				deref_dot_expr_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+				  currentAST.child = deref_dot_expr_AST->getFirstChild();
 			else
-				currentAST.child = array_expr_fn_AST;
+				currentAST.child = deref_dot_expr_AST;
 			currentAST.advanceChildToEnd();
 		}
+		}
+		deref_dot_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
-	case antlr::Token::EOF_TYPE:
-	case AND_OP:
-	case DO:
-	case ELSE:
-	case EQ_OP:
-	case GE_OP:
-	case GT_OP:
-	case LE_OP:
-	case LT_OP:
-	case MOD_OP:
-	case NE_OP:
-	case OF:
-	case OR_OP:
-	case THEN:
-	case UNTIL:
-	case XOR_OP:
-	case COMMA:
-	case COLON:
-	case END_U:
-	case DEC:
-	case INC:
-	case MEMBER:
-	case RBRACE:
-	case SLASH:
-	case RSQUARE:
-	case RCURLY:
 	case ASTERIX:
-	case POW:
-	case MATRIX_OP1:
-	case MATRIX_OP2:
-	case PLUS:
-	case MINUS:
-	case LTMARK:
-	case GTMARK:
-	case LOG_AND:
-	case LOG_OR:
-	case QUESTION:
 	{
+		match(ASTERIX);
+		deref_dot_expr();
+		if (inputState->guessing==0) {
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
 		if ( inputState->guessing==0 ) {
-			array_expr_fn_AST = RefDNode(currentAST.root);
-			array_expr_fn_AST = 
-				  		RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ARRAYEXPR_FN,"arrayexpr_fn")))->add(antlr::RefAST(v_AST))->add(antlr::RefAST(al_AST))));
-			currentAST.root = array_expr_fn_AST;
-			if ( array_expr_fn_AST!=RefDNode(antlr::nullAST) &&
-				array_expr_fn_AST->getFirstChild() != RefDNode(antlr::nullAST) )
-				  currentAST.child = array_expr_fn_AST->getFirstChild();
+			deref_dot_expr_AST = RefDNode(currentAST.root);
+			deref_dot_expr_AST = 
+						RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(DEREF,"deref")))->add(antlr::RefAST(deref_dot_expr_AST))));
+			currentAST.root = deref_dot_expr_AST;
+			if ( deref_dot_expr_AST!=RefDNode(antlr::nullAST) &&
+				deref_dot_expr_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+				  currentAST.child = deref_dot_expr_AST->getFirstChild();
 			else
-				currentAST.child = array_expr_fn_AST;
+				currentAST.child = deref_dot_expr_AST;
 			currentAST.advanceChildToEnd();
 		}
+		deref_dot_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	default:
@@ -7170,8 +7763,7 @@
 		throw antlr::NoViableAltException(LT(1), getFilename());
 	}
 	}
-	}
-	returnAST = array_expr_fn_AST;
+	returnAST = deref_dot_expr_AST;
 }
 
 bool  GDLParser::member_function_call() {
@@ -7186,10 +7778,10 @@
 	match(MEMBER);
 	{
 	if ((LA(1) == IDENTIFIER) && (LA(2) == METHOD)) {
-		RefDNode tmp173_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp185_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp173_AST = astFactory->create(LT(1));
-			astFactory->addASTChild(currentAST, antlr::RefAST(tmp173_AST));
+			tmp185_AST = astFactory->create(LT(1));
+			astFactory->addASTChild(currentAST, antlr::RefAST(tmp185_AST));
 		}
 		match(IDENTIFIER);
 		match(METHOD);
@@ -7213,10 +7805,36 @@
 	return parent;
 }
 
+void GDLParser::member_function_call_dot() {
+	returnAST = RefDNode(antlr::nullAST);
+	antlr::ASTPair currentAST;
+	RefDNode member_function_call_dot_AST = RefDNode(antlr::nullAST);
+	
+	match(DOT);
+	{
+	RefDNode tmp188_AST = RefDNode(antlr::nullAST);
+	if ( inputState->guessing == 0 ) {
+		tmp188_AST = astFactory->create(LT(1));
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp188_AST));
+	}
+	match(IDENTIFIER);
+	match(METHOD);
+	}
+	formal_function_call();
+	if (inputState->guessing==0) {
+		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+	}
+	member_function_call_dot_AST = RefDNode(currentAST.root);
+	returnAST = member_function_call_dot_AST;
+}
+
 void GDLParser::primary_expr() {
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
 	RefDNode primary_expr_AST = RefDNode(antlr::nullAST);
+	RefDNode d1_AST = RefDNode(antlr::nullAST);
+	RefDNode d2_AST = RefDNode(antlr::nullAST);
+	RefDNode d3_AST = RefDNode(antlr::nullAST);
 	antlr::RefToken  sl = antlr::nullToken;
 	RefDNode sl_AST = RefDNode(antlr::nullAST);
 	
@@ -7288,196 +7906,131 @@
 	{
 		numeric_constant();
 		if (inputState->guessing==0) {
-			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		}
-		primary_expr_AST = RefDNode(currentAST.root);
-		break;
-	}
-	case LSQUARE:
-	{
-		array_def();
-		if (inputState->guessing==0) {
-			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		}
-		primary_expr_AST = RefDNode(currentAST.root);
-		break;
-	}
-	case LCURLY:
-	{
-		struct_def();
-		if (inputState->guessing==0) {
-			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		}
-		primary_expr_AST = RefDNode(currentAST.root);
-		break;
-	}
-	default:
-		bool synPredMatched186 = false;
-		if (((LA(1) == IDENTIFIER || LA(1) == INHERITS) && (LA(2) == LBRACE || LA(2) == LSQUARE))) {
-			int _m186 = mark();
-			synPredMatched186 = true;
-			inputState->guessing++;
-			try {
-				{
-				match(IDENTIFIER);
-				match(LBRACE);
-				expr();
-				{ // ( ... )*
-				for (;;) {
-					if ((LA(1) == COMMA)) {
-						match(COMMA);
-						expr();
-					}
-					else {
-						goto _loop185;
-					}
-					
-				}
-				_loop185:;
-				} // ( ... )*
-				match(RBRACE);
-				}
-			}
-			catch (antlr::RecognitionException& pe) {
-				synPredMatched186 = false;
-			}
-			rewind(_m186);
-			inputState->guessing--;
-		}
-		if ( synPredMatched186 ) {
-			{
-			if (((LA(1) == IDENTIFIER) && (LA(2) == LBRACE))&&( IsFun(LT(1)))) {
-				formal_function_call();
-				if (inputState->guessing==0) {
-					astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-				}
-				if ( inputState->guessing==0 ) {
-					primary_expr_AST = RefDNode(currentAST.root);
-					primary_expr_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(FCALL,"fcall")))->add(antlr::RefAST(primary_expr_AST))));
-					currentAST.root = primary_expr_AST;
-					if ( primary_expr_AST!=RefDNode(antlr::nullAST) &&
-						primary_expr_AST->getFirstChild() != RefDNode(antlr::nullAST) )
-						  currentAST.child = primary_expr_AST->getFirstChild();
-					else
-						currentAST.child = primary_expr_AST;
-					currentAST.advanceChildToEnd();
-				}
-			}
-			else if ((LA(1) == IDENTIFIER || LA(1) == INHERITS) && (LA(2) == LBRACE || LA(2) == LSQUARE)) {
-				array_expr_fn();
-				if (inputState->guessing==0) {
-					astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-				}
-				{
-				switch ( LA(1)) {
-				case MEMBER:
-				{
-					parent=member_function_call();
-					if (inputState->guessing==0) {
-						astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-					}
-					if ( inputState->guessing==0 ) {
-						primary_expr_AST = RefDNode(currentAST.root);
-						
-						if( parent)
-						{
-						primary_expr_AST = 
-						RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MFCALL_PARENT,"mfcall::")))->add(antlr::RefAST(primary_expr_AST))));
-						}
-						else
-						{
-						primary_expr_AST = 
-						RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MFCALL,"mfcall")))->add(antlr::RefAST(primary_expr_AST))));
-						}
-						
-						currentAST.root = primary_expr_AST;
-						if ( primary_expr_AST!=RefDNode(antlr::nullAST) &&
-							primary_expr_AST->getFirstChild() != RefDNode(antlr::nullAST) )
-							  currentAST.child = primary_expr_AST->getFirstChild();
-						else
-							currentAST.child = primary_expr_AST;
-						currentAST.advanceChildToEnd();
-					}
-					break;
-				}
-				case antlr::Token::EOF_TYPE:
-				case AND_OP:
-				case DO:
-				case ELSE:
-				case EQ_OP:
-				case GE_OP:
-				case GT_OP:
-				case LE_OP:
-				case LT_OP:
-				case MOD_OP:
-				case NE_OP:
-				case OF:
-				case OR_OP:
-				case THEN:
-				case UNTIL:
-				case XOR_OP:
-				case COMMA:
-				case COLON:
-				case END_U:
-				case DEC:
-				case INC:
-				case RBRACE:
-				case SLASH:
-				case RSQUARE:
-				case RCURLY:
-				case ASTERIX:
-				case POW:
-				case MATRIX_OP1:
-				case MATRIX_OP2:
-				case PLUS:
-				case MINUS:
-				case LTMARK:
-				case GTMARK:
-				case LOG_AND:
-				case LOG_OR:
-				case QUESTION:
-				{
-					break;
-				}
-				default:
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
+		primary_expr_AST = RefDNode(currentAST.root);
+		break;
+	}
+	case LSQUARE:
+	{
+		array_def();
+		if (inputState->guessing==0) {
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
+		primary_expr_AST = RefDNode(currentAST.root);
+		break;
+	}
+	case LCURLY:
+	{
+		struct_def();
+		if (inputState->guessing==0) {
+			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		}
+		primary_expr_AST = RefDNode(currentAST.root);
+		break;
+	}
+	default:
+		bool synPredMatched204 = false;
+		if (((_tokenSet_4.member(LA(1))) && (_tokenSet_5.member(LA(2))))) {
+			int _m204 = mark();
+			synPredMatched204 = true;
+			inputState->guessing++;
+			try {
 				{
-					throw antlr::NoViableAltException(LT(1), getFilename());
-				}
-				}
+				deref_dot_expr_keeplast();
+				baseclass_method();
 				}
 			}
-			else {
-				throw antlr::NoViableAltException(LT(1), getFilename());
+			catch (antlr::RecognitionException& pe) {
+				synPredMatched204 = false;
 			}
-			
+			rewind(_m204);
+			inputState->guessing--;
+		}
+		if ( synPredMatched204 ) {
+			deref_dot_expr_keeplast();
+			if (inputState->guessing==0) {
+				d1_AST = returnAST;
+				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+			}
+			baseclass_method();
+			if (inputState->guessing==0) {
+				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+			}
+			formal_function_call();
+			if (inputState->guessing==0) {
+				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+			}
+			if ( inputState->guessing==0 ) {
+				primary_expr_AST = RefDNode(currentAST.root);
+				
+				primary_expr_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MFCALL_PARENT,"mfcall::")))->add(antlr::RefAST(primary_expr_AST))));
+				
+				currentAST.root = primary_expr_AST;
+				if ( primary_expr_AST!=RefDNode(antlr::nullAST) &&
+					primary_expr_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+					  currentAST.child = primary_expr_AST->getFirstChild();
+				else
+					currentAST.child = primary_expr_AST;
+				currentAST.advanceChildToEnd();
 			}
 			primary_expr_AST = RefDNode(currentAST.root);
 		}
 		else {
-			bool synPredMatched190 = false;
-			if (((LA(1) == IDENTIFIER) && (LA(2) == LBRACE))) {
-				int _m190 = mark();
-				synPredMatched190 = true;
+			bool synPredMatched209 = false;
+			if (((_tokenSet_4.member(LA(1))) && (_tokenSet_5.member(LA(2))))) {
+				int _m209 = mark();
+				synPredMatched209 = true;
 				inputState->guessing++;
 				try {
 					{
-					formal_function_call();
+					deref_dot_expr_keeplast();
+					{
+					match(IDENTIFIER);
+					match(LBRACE);
+					expr();
+					{ // ( ... )*
+					for (;;) {
+						if ((LA(1) == COMMA)) {
+							match(COMMA);
+							expr();
+						}
+						else {
+							goto _loop208;
+						}
+						
+					}
+					_loop208:;
+					} // ( ... )*
+					match(RBRACE);
+					}
 					}
 				}
 				catch (antlr::RecognitionException& pe) {
-					synPredMatched190 = false;
+					synPredMatched209 = false;
 				}
-				rewind(_m190);
+				rewind(_m209);
 				inputState->guessing--;
 			}
-			if ( synPredMatched190 ) {
-				formal_function_call();
+			if ( synPredMatched209 ) {
+				deref_dot_expr_keeplast();
+				if (inputState->guessing==0) {
+					d2_AST = returnAST;
+					astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+				}
+				RefDNode tmp190_AST = RefDNode(antlr::nullAST);
+				if ( inputState->guessing == 0 ) {
+					tmp190_AST = astFactory->create(LT(1));
+					astFactory->addASTChild(currentAST, antlr::RefAST(tmp190_AST));
+				}
+				match(IDENTIFIER);
+				arrayindex_list();
 				if (inputState->guessing==0) {
 					astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 				}
 				if ( inputState->guessing==0 ) {
 					primary_expr_AST = RefDNode(currentAST.root);
-					primary_expr_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(FCALL,"fcall")))->add(antlr::RefAST(primary_expr_AST))));
+					primary_expr_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(ARRAYEXPR_MFCALL,"arrayexpr_mfcall")))->add(antlr::RefAST(primary_expr_AST))));
 					currentAST.root = primary_expr_AST;
 					if ( primary_expr_AST!=RefDNode(antlr::nullAST) &&
 						primary_expr_AST->getFirstChild() != RefDNode(antlr::nullAST) )
@@ -7489,115 +8042,375 @@
 				primary_expr_AST = RefDNode(currentAST.root);
 			}
 			else {
-				bool synPredMatched192 = false;
-				if (((_tokenSet_4.member(LA(1))) && (_tokenSet_18.member(LA(2))))) {
-					int _m192 = mark();
-					synPredMatched192 = true;
+				bool synPredMatched211 = false;
+				if (((_tokenSet_4.member(LA(1))) && (_tokenSet_5.member(LA(2))))) {
+					int _m211 = mark();
+					synPredMatched211 = true;
 					inputState->guessing++;
 					try {
 						{
-						deref_expr();
+						deref_dot_expr_keeplast();
+						formal_function_call();
 						}
 					}
 					catch (antlr::RecognitionException& pe) {
-						synPredMatched192 = false;
+						synPredMatched211 = false;
 					}
-					rewind(_m192);
+					rewind(_m211);
 					inputState->guessing--;
 				}
-				if ( synPredMatched192 ) {
-					deref_expr();
+				if ( synPredMatched211 ) {
+					deref_dot_expr_keeplast();
 					if (inputState->guessing==0) {
+						d3_AST = returnAST;
 						astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 					}
-					{
-					switch ( LA(1)) {
-					case MEMBER:
-					{
-						parent=member_function_call();
+					formal_function_call();
+					if (inputState->guessing==0) {
+						astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+					}
+					if ( inputState->guessing==0 ) {
+						primary_expr_AST = RefDNode(currentAST.root);
+						primary_expr_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MFCALL,"mfcall")))->add(antlr::RefAST(primary_expr_AST))));
+						currentAST.root = primary_expr_AST;
+						if ( primary_expr_AST!=RefDNode(antlr::nullAST) &&
+							primary_expr_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+							  currentAST.child = primary_expr_AST->getFirstChild();
+						else
+							currentAST.child = primary_expr_AST;
+						currentAST.advanceChildToEnd();
+					}
+					primary_expr_AST = RefDNode(currentAST.root);
+				}
+				else {
+					bool synPredMatched213 = false;
+					if (((_tokenSet_4.member(LA(1))) && (_tokenSet_22.member(LA(2))))) {
+						int _m213 = mark();
+						synPredMatched213 = true;
+						inputState->guessing++;
+						try {
+							{
+							deref_dot_expr();
+							}
+						}
+						catch (antlr::RecognitionException& pe) {
+							synPredMatched213 = false;
+						}
+						rewind(_m213);
+						inputState->guessing--;
+					}
+					if ( synPredMatched213 ) {
+						deref_expr();
 						if (inputState->guessing==0) {
 							astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 						}
-						if ( inputState->guessing==0 ) {
-							primary_expr_AST = RefDNode(currentAST.root);
-							
-							if( parent)
-							{
-							primary_expr_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MFCALL_PARENT,"mfcall::")))->add(antlr::RefAST(primary_expr_AST))));
+						{
+						switch ( LA(1)) {
+						case MEMBER:
+						{
+							parent=member_function_call();
+							if (inputState->guessing==0) {
+								astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 							}
-							else
+							if ( inputState->guessing==0 ) {
+								primary_expr_AST = RefDNode(currentAST.root);
+								
+								if( parent)
+								{
+								primary_expr_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MFCALL_PARENT,"mfcall::")))->add(antlr::RefAST(primary_expr_AST))));
+								}
+								else
+								{
+								primary_expr_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MFCALL,"mfcall")))->add(antlr::RefAST(primary_expr_AST))));
+								}
+								
+								currentAST.root = primary_expr_AST;
+								if ( primary_expr_AST!=RefDNode(antlr::nullAST) &&
+									primary_expr_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+									  currentAST.child = primary_expr_AST->getFirstChild();
+								else
+									currentAST.child = primary_expr_AST;
+								currentAST.advanceChildToEnd();
+							}
+							break;
+						}
+						case antlr::Token::EOF_TYPE:
+						case AND_OP:
+						case DO:
+						case ELSE:
+						case EQ_OP:
+						case GE_OP:
+						case GT_OP:
+						case LE_OP:
+						case LT_OP:
+						case MOD_OP:
+						case NE_OP:
+						case OF:
+						case OR_OP:
+						case THEN:
+						case UNTIL:
+						case XOR_OP:
+						case COMMA:
+						case COLON:
+						case END_U:
+						case DEC:
+						case INC:
+						case RBRACE:
+						case SLASH:
+						case RSQUARE:
+						case RCURLY:
+						case ASTERIX:
+						case POW:
+						case MATRIX_OP1:
+						case MATRIX_OP2:
+						case PLUS:
+						case MINUS:
+						case LTMARK:
+						case GTMARK:
+						case LOG_AND:
+						case LOG_OR:
+						case QUESTION:
+						{
+							break;
+						}
+						default:
+						{
+							throw antlr::NoViableAltException(LT(1), getFilename());
+						}
+						}
+						}
+						primary_expr_AST = RefDNode(currentAST.root);
+					}
+					else {
+						bool synPredMatched218 = false;
+						if (((LA(1) == IDENTIFIER || LA(1) == INHERITS) && (LA(2) == LBRACE || LA(2) == LSQUARE))) {
+							int _m218 = mark();
+							synPredMatched218 = true;
+							inputState->guessing++;
+							try {
+								{
+								match(IDENTIFIER);
+								match(LBRACE);
+								expr();
+								{ // ( ... )*
+								for (;;) {
+									if ((LA(1) == COMMA)) {
+										match(COMMA);
+										expr();
+									}
+									else {
+										goto _loop217;
+									}
+									
+								}
+								_loop217:;
+								} // ( ... )*
+								match(RBRACE);
+								}
+							}
+							catch (antlr::RecognitionException& pe) {
+								synPredMatched218 = false;
+							}
+							rewind(_m218);
+							inputState->guessing--;
+						}
+						if ( synPredMatched218 ) {
 							{
-							primary_expr_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MFCALL,"mfcall")))->add(antlr::RefAST(primary_expr_AST))));
+							if (((LA(1) == IDENTIFIER) && (LA(2) == LBRACE))&&( IsFun(LT(1)))) {
+								formal_function_call();
+								if (inputState->guessing==0) {
+									astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+								}
+								if ( inputState->guessing==0 ) {
+									primary_expr_AST = RefDNode(currentAST.root);
+									
+									//                 if( StrUpCase(#i->getText) == "N_ELEMENTS")
+									//                     #primary_expr = #([FCALL_LIB_N_ELEMENTS, "fcall_n_elements"], #primary_expr);
+									//                 else
+									primary_expr_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(FCALL,"fcall")))->add(antlr::RefAST(primary_expr_AST))));
+									
+									currentAST.root = primary_expr_AST;
+									if ( primary_expr_AST!=RefDNode(antlr::nullAST) &&
+										primary_expr_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+										  currentAST.child = primary_expr_AST->getFirstChild();
+									else
+										currentAST.child = primary_expr_AST;
+									currentAST.advanceChildToEnd();
+								}
+							}
+							else if ((LA(1) == IDENTIFIER || LA(1) == INHERITS) && (LA(2) == LBRACE || LA(2) == LSQUARE)) {
+								var();
+								if (inputState->guessing==0) {
+									astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+								}
+								arrayindex_list();
+								if (inputState->guessing==0) {
+									astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+								}
+								if ( inputState->guessing==0 ) {
+									primary_expr_AST = RefDNode(currentAST.root);
+									primary_expr_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(ARRAYEXPR_FN,"arrayexpr_fn")))->add(antlr::RefAST(primary_expr_AST))));
+									currentAST.root = primary_expr_AST;
+									if ( primary_expr_AST!=RefDNode(antlr::nullAST) &&
+										primary_expr_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+										  currentAST.child = primary_expr_AST->getFirstChild();
+									else
+										currentAST.child = primary_expr_AST;
+									currentAST.advanceChildToEnd();
+								}
+							}
+							else {
+								throw antlr::NoViableAltException(LT(1), getFilename());
 							}
 							
-							currentAST.root = primary_expr_AST;
-							if ( primary_expr_AST!=RefDNode(antlr::nullAST) &&
-								primary_expr_AST->getFirstChild() != RefDNode(antlr::nullAST) )
-								  currentAST.child = primary_expr_AST->getFirstChild();
-							else
-								currentAST.child = primary_expr_AST;
-							currentAST.advanceChildToEnd();
+							}
+							primary_expr_AST = RefDNode(currentAST.root);
 						}
-						break;
-					}
-					case antlr::Token::EOF_TYPE:
-					case AND_OP:
-					case DO:
-					case ELSE:
-					case EQ_OP:
-					case GE_OP:
-					case GT_OP:
-					case LE_OP:
-					case LT_OP:
-					case MOD_OP:
-					case NE_OP:
-					case OF:
-					case OR_OP:
-					case THEN:
-					case UNTIL:
-					case XOR_OP:
-					case COMMA:
-					case COLON:
-					case END_U:
-					case DEC:
-					case INC:
-					case RBRACE:
-					case SLASH:
-					case RSQUARE:
-					case RCURLY:
-					case ASTERIX:
-					case POW:
-					case MATRIX_OP1:
-					case MATRIX_OP2:
-					case PLUS:
-					case MINUS:
-					case LTMARK:
-					case GTMARK:
-					case LOG_AND:
-					case LOG_OR:
-					case QUESTION:
-					{
-						break;
-					}
-					default:
-					{
-						throw antlr::NoViableAltException(LT(1), getFilename());
-					}
-					}
-					}
-					primary_expr_AST = RefDNode(currentAST.root);
-				}
-				else if ((LA(1) == LBRACE) && (_tokenSet_4.member(LA(2)))) {
-					assign_expr();
-					if (inputState->guessing==0) {
-						astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-					}
-					primary_expr_AST = RefDNode(currentAST.root);
-				}
+						else {
+							bool synPredMatched221 = false;
+							if (((LA(1) == IDENTIFIER) && (LA(2) == LBRACE))) {
+								int _m221 = mark();
+								synPredMatched221 = true;
+								inputState->guessing++;
+								try {
+									{
+									formal_function_call();
+									}
+								}
+								catch (antlr::RecognitionException& pe) {
+									synPredMatched221 = false;
+								}
+								rewind(_m221);
+								inputState->guessing--;
+							}
+							if ( synPredMatched221 ) {
+								formal_function_call();
+								if (inputState->guessing==0) {
+									astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+								}
+								if ( inputState->guessing==0 ) {
+									primary_expr_AST = RefDNode(currentAST.root);
+									primary_expr_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(FCALL,"fcall")))->add(antlr::RefAST(primary_expr_AST))));
+									currentAST.root = primary_expr_AST;
+									if ( primary_expr_AST!=RefDNode(antlr::nullAST) &&
+										primary_expr_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+										  currentAST.child = primary_expr_AST->getFirstChild();
+									else
+										currentAST.child = primary_expr_AST;
+									currentAST.advanceChildToEnd();
+								}
+								primary_expr_AST = RefDNode(currentAST.root);
+							}
+							else {
+								bool synPredMatched223 = false;
+								if (((_tokenSet_4.member(LA(1))) && (_tokenSet_22.member(LA(2))))) {
+									int _m223 = mark();
+									synPredMatched223 = true;
+									inputState->guessing++;
+									try {
+										{
+										deref_expr();
+										}
+									}
+									catch (antlr::RecognitionException& pe) {
+										synPredMatched223 = false;
+									}
+									rewind(_m223);
+									inputState->guessing--;
+								}
+								if ( synPredMatched223 ) {
+									deref_expr();
+									if (inputState->guessing==0) {
+										astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+									}
+									{
+									switch ( LA(1)) {
+									case MEMBER:
+									{
+										parent=member_function_call();
+										if (inputState->guessing==0) {
+											astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+										}
+										if ( inputState->guessing==0 ) {
+											primary_expr_AST = RefDNode(currentAST.root);
+											
+											if( parent)
+											{
+											primary_expr_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MFCALL_PARENT,"mfcall::")))->add(antlr::RefAST(primary_expr_AST))));
+											}
+											else
+											{
+											primary_expr_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(MFCALL,"mfcall")))->add(antlr::RefAST(primary_expr_AST))));
+											}
+											
+											currentAST.root = primary_expr_AST;
+											if ( primary_expr_AST!=RefDNode(antlr::nullAST) &&
+												primary_expr_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+												  currentAST.child = primary_expr_AST->getFirstChild();
+											else
+												currentAST.child = primary_expr_AST;
+											currentAST.advanceChildToEnd();
+										}
+										break;
+									}
+									case antlr::Token::EOF_TYPE:
+									case AND_OP:
+									case DO:
+									case ELSE:
+									case EQ_OP:
+									case GE_OP:
+									case GT_OP:
+									case LE_OP:
+									case LT_OP:
+									case MOD_OP:
+									case NE_OP:
+									case OF:
+									case OR_OP:
+									case THEN:
+									case UNTIL:
+									case XOR_OP:
+									case COMMA:
+									case COLON:
+									case END_U:
+									case DEC:
+									case INC:
+									case RBRACE:
+									case SLASH:
+									case RSQUARE:
+									case RCURLY:
+									case ASTERIX:
+									case POW:
+									case MATRIX_OP1:
+									case MATRIX_OP2:
+									case PLUS:
+									case MINUS:
+									case LTMARK:
+									case GTMARK:
+									case LOG_AND:
+									case LOG_OR:
+									case QUESTION:
+									{
+										break;
+									}
+									default:
+									{
+										throw antlr::NoViableAltException(LT(1), getFilename());
+									}
+									}
+									}
+									primary_expr_AST = RefDNode(currentAST.root);
+								}
+								else if ((LA(1) == LBRACE) && (_tokenSet_4.member(LA(2)))) {
+									assign_expr();
+									if (inputState->guessing==0) {
+										astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+									}
+									primary_expr_AST = RefDNode(currentAST.root);
+								}
 	else {
 		throw antlr::NoViableAltException(LT(1), getFilename());
 	}
-	}}}
+	}}}}}}}
 	returnAST = primary_expr_AST;
 }
 
@@ -7738,10 +8551,10 @@
 	}
 	case INC:
 	{
-		RefDNode tmp175_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp191_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp175_AST = astFactory->create(LT(1));
-			astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp175_AST));
+			tmp191_AST = astFactory->create(LT(1));
+			astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp191_AST));
 		}
 		match(INC);
 		primary_expr();
@@ -7753,10 +8566,10 @@
 	}
 	case DEC:
 	{
-		RefDNode tmp176_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp192_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp176_AST = astFactory->create(LT(1));
-			astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp176_AST));
+			tmp192_AST = astFactory->create(LT(1));
+			astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp192_AST));
 		}
 		match(DEC);
 		primary_expr();
@@ -7786,10 +8599,10 @@
 	{ // ( ... )*
 	for (;;) {
 		if ((LA(1) == POW)) {
-			RefDNode tmp177_AST = RefDNode(antlr::nullAST);
+			RefDNode tmp193_AST = RefDNode(antlr::nullAST);
 			if ( inputState->guessing == 0 ) {
-				tmp177_AST = astFactory->create(LT(1));
-				astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp177_AST));
+				tmp193_AST = astFactory->create(LT(1));
+				astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp193_AST));
 			}
 			match(POW);
 			decinc_expr();
@@ -7798,11 +8611,11 @@
 			}
 		}
 		else {
-			goto _loop198;
+			goto _loop229;
 		}
 		
 	}
-	_loop198:;
+	_loop229:;
 	} // ( ... )*
 	exponential_expr_AST = RefDNode(currentAST.root);
 	returnAST = exponential_expr_AST;
@@ -7819,55 +8632,55 @@
 	}
 	{ // ( ... )*
 	for (;;) {
-		if ((_tokenSet_19.member(LA(1)))) {
+		if ((_tokenSet_23.member(LA(1)))) {
 			{
 			switch ( LA(1)) {
 			case ASTERIX:
 			{
-				RefDNode tmp178_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp194_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp178_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp178_AST));
+					tmp194_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp194_AST));
 				}
 				match(ASTERIX);
 				break;
 			}
 			case MATRIX_OP1:
 			{
-				RefDNode tmp179_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp195_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp179_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp179_AST));
+					tmp195_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp195_AST));
 				}
 				match(MATRIX_OP1);
 				break;
 			}
 			case MATRIX_OP2:
 			{
-				RefDNode tmp180_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp196_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp180_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp180_AST));
+					tmp196_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp196_AST));
 				}
 				match(MATRIX_OP2);
 				break;
 			}
 			case SLASH:
 			{
-				RefDNode tmp181_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp197_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp181_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp181_AST));
+					tmp197_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp197_AST));
 				}
 				match(SLASH);
 				break;
 			}
 			case MOD_OP:
 			{
-				RefDNode tmp182_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp198_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp182_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp182_AST));
+					tmp198_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp198_AST));
 				}
 				match(MOD_OP);
 				break;
@@ -7884,11 +8697,11 @@
 			}
 		}
 		else {
-			goto _loop202;
+			goto _loop233;
 		}
 		
 	}
-	_loop202:;
+	_loop233:;
 	} // ( ... )*
 	multiplicative_expr_AST = RefDNode(currentAST.root);
 	returnAST = multiplicative_expr_AST;
@@ -8083,40 +8896,40 @@
 			switch ( LA(1)) {
 			case PLUS:
 			{
-				RefDNode tmp184_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp200_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp184_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp184_AST));
+					tmp200_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp200_AST));
 				}
 				match(PLUS);
 				break;
 			}
 			case MINUS:
 			{
-				RefDNode tmp185_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp201_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp185_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp185_AST));
+					tmp201_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp201_AST));
 				}
 				match(MINUS);
 				break;
 			}
 			case LTMARK:
 			{
-				RefDNode tmp186_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp202_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp186_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp186_AST));
+					tmp202_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp202_AST));
 				}
 				match(LTMARK);
 				break;
 			}
 			case GTMARK:
 			{
-				RefDNode tmp187_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp203_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp187_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp187_AST));
+					tmp203_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp203_AST));
 				}
 				match(GTMARK);
 				break;
@@ -8201,11 +9014,11 @@
 			}
 		}
 		else {
-			goto _loop209;
+			goto _loop240;
 		}
 		
 	}
-	_loop209:;
+	_loop240:;
 	} // ( ... )*
 	additive_expr_AST = RefDNode(currentAST.root);
 	returnAST = additive_expr_AST;
@@ -8219,10 +9032,10 @@
 	switch ( LA(1)) {
 	case NOT_OP:
 	{
-		RefDNode tmp188_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp204_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp188_AST = astFactory->create(LT(1));
-			astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp188_AST));
+			tmp204_AST = astFactory->create(LT(1));
+			astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp204_AST));
 		}
 		match(NOT_OP);
 		multiplicative_expr();
@@ -8234,10 +9047,10 @@
 	}
 	case LOG_NEG:
 	{
-		RefDNode tmp189_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp205_AST = RefDNode(antlr::nullAST);
 		if ( inputState->guessing == 0 ) {
-			tmp189_AST = astFactory->create(LT(1));
-			astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp189_AST));
+			tmp205_AST = astFactory->create(LT(1));
+			astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp205_AST));
 		}
 		match(LOG_NEG);
 		multiplicative_expr();
@@ -8266,65 +9079,65 @@
 	}
 	{ // ( ... )*
 	for (;;) {
-		if ((_tokenSet_20.member(LA(1)))) {
+		if ((_tokenSet_24.member(LA(1)))) {
 			{
 			switch ( LA(1)) {
 			case EQ_OP:
 			{
-				RefDNode tmp190_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp206_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp190_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp190_AST));
+					tmp206_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp206_AST));
 				}
 				match(EQ_OP);
 				break;
 			}
 			case NE_OP:
 			{
-				RefDNode tmp191_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp207_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp191_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp191_AST));
+					tmp207_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp207_AST));
 				}
 				match(NE_OP);
 				break;
 			}
 			case LE_OP:
 			{
-				RefDNode tmp192_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp208_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp192_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp192_AST));
+					tmp208_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp208_AST));
 				}
 				match(LE_OP);
 				break;
 			}
 			case LT_OP:
 			{
-				RefDNode tmp193_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp209_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp193_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp193_AST));
+					tmp209_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp209_AST));
 				}
 				match(LT_OP);
 				break;
 			}
 			case GE_OP:
 			{
-				RefDNode tmp194_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp210_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp194_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp194_AST));
+					tmp210_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp210_AST));
 				}
 				match(GE_OP);
 				break;
 			}
 			case GT_OP:
 			{
-				RefDNode tmp195_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp211_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp195_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp195_AST));
+					tmp211_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp211_AST));
 				}
 				match(GT_OP);
 				break;
@@ -8341,11 +9154,11 @@
 			}
 		}
 		else {
-			goto _loop214;
+			goto _loop245;
 		}
 		
 	}
-	_loop214:;
+	_loop245:;
 	} // ( ... )*
 	relational_expr_AST = RefDNode(currentAST.root);
 	returnAST = relational_expr_AST;
@@ -8367,30 +9180,30 @@
 			switch ( LA(1)) {
 			case AND_OP:
 			{
-				RefDNode tmp196_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp212_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp196_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp196_AST));
+					tmp212_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp212_AST));
 				}
 				match(AND_OP);
 				break;
 			}
 			case OR_OP:
 			{
-				RefDNode tmp197_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp213_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp197_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp197_AST));
+					tmp213_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp213_AST));
 				}
 				match(OR_OP);
 				break;
 			}
 			case XOR_OP:
 			{
-				RefDNode tmp198_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp214_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp198_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp198_AST));
+					tmp214_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp214_AST));
 				}
 				match(XOR_OP);
 				break;
@@ -8407,11 +9220,11 @@
 			}
 		}
 		else {
-			goto _loop218;
+			goto _loop249;
 		}
 		
 	}
-	_loop218:;
+	_loop249:;
 	} // ( ... )*
 	boolean_expr_AST = RefDNode(currentAST.root);
 	returnAST = boolean_expr_AST;
@@ -8433,20 +9246,20 @@
 			switch ( LA(1)) {
 			case LOG_AND:
 			{
-				RefDNode tmp199_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp215_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp199_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp199_AST));
+					tmp215_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp215_AST));
 				}
 				match(LOG_AND);
 				break;
 			}
 			case LOG_OR:
 			{
-				RefDNode tmp200_AST = RefDNode(antlr::nullAST);
+				RefDNode tmp216_AST = RefDNode(antlr::nullAST);
 				if ( inputState->guessing == 0 ) {
-					tmp200_AST = astFactory->create(LT(1));
-					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp200_AST));
+					tmp216_AST = astFactory->create(LT(1));
+					astFactory->makeASTRoot(currentAST, antlr::RefAST(tmp216_AST));
 				}
 				match(LOG_OR);
 				break;
@@ -8463,11 +9276,11 @@
 			}
 		}
 		else {
-			goto _loop222;
+			goto _loop253;
 		}
 		
 	}
-	_loop222:;
+	_loop253:;
 	} // ( ... )*
 	logical_expr_AST = RefDNode(currentAST.root);
 	returnAST = logical_expr_AST;
@@ -8475,7 +9288,7 @@
 
 void GDLParser::initializeASTFactory( antlr::ASTFactory& factory )
 {
-	factory.setMaxNodeType(215);
+	factory.setMaxNodeType(224);
 }
 const char* GDLParser::tokenNames[] = {
 	"<0>",
@@ -8486,6 +9299,7 @@
 	"ASSIGN",
 	"ASSIGN_INPLACE",
 	"ASSIGN_REPLACE",
+	"ASSIGN_ARRAYEXPR_MFCALL",
 	"ARRAYDEF",
 	"ARRAYDEF_CONST",
 	"ARRAYIX",
@@ -8496,8 +9310,10 @@
 	"ARRAYIX_RANGE_S",
 	"ARRAYEXPR",
 	"ARRAYEXPR_FN",
+	"ARRAYEXPR_MFCALL",
 	"BLOCK",
 	"BREAK",
+	"CSBLOCK",
 	"CONTINUE",
 	"COMMONDECL",
 	"COMMONDEF",
@@ -8505,7 +9321,12 @@
 	"DEREF",
 	"ELSEBLK",
 	"EXPR",
+	"\"for\"",
 	"FOR_STEP",
+	"\"foreach\"",
+	"FOR_LOOP",
+	"FOR_STEP_LOOP",
+	"FOREACH_LOOP",
 	"FCALL",
 	"FCALL_LIB",
 	"FCALL_LIB_RETNEW",
@@ -8539,6 +9360,8 @@
 	"REF",
 	"REF_CHECK",
 	"REF_EXPR",
+	"\"repeat\"",
+	"REPEAT_LOOP",
 	"RETURN",
 	"RETF",
 	"RETP",
@@ -8547,6 +9370,7 @@
 	"UMINUS",
 	"VAR",
 	"VARPTR",
+	"\"while\"",
 	"IDENTIFIER",
 	"\"and\"",
 	"\"begin\"",
@@ -8559,12 +9383,12 @@
 	"\"endcase\"",
 	"\"endelse\"",
 	"\"endfor\"",
+	"\"endforeach\"",
 	"\"endif\"",
 	"\"endrep\"",
 	"\"endswitch\"",
 	"\"endwhile\"",
 	"\"eq\"",
-	"\"for\"",
 	"\"forward_function\"",
 	"\"function\"",
 	"\"ge\"",
@@ -8581,11 +9405,9 @@
 	"\"on_ioerror\"",
 	"\"or\"",
 	"\"pro\"",
-	"\"repeat\"",
 	"\"switch\"",
 	"\"then\"",
 	"\"until\"",
-	"\"while\"",
 	"\"xor\"",
 	"METHOD",
 	"COMMA",
@@ -8697,39 +9519,40 @@
 	0
 };
 
-const unsigned long GDLParser::_tokenSet_0_data_[] = { 2UL, 0UL, 901777312UL, 854480UL, 8448UL, 8388608UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
-// EOF IDENTIFIER "begin" "case" "common" "compile_opt" "for" "forward_function" 
-// "function" "goto" "if" "inherits" "on_ioerror" "pro" "repeat" "switch" 
-// "while" END_U DEC INC LBRACE SYSVARNAME ASTERIX 
-const antlr::BitSet GDLParser::_tokenSet_0(_tokenSet_0_data_,12);
-const unsigned long GDLParser::_tokenSet_1_data_[] = { 2UL, 0UL, 903870368UL, 854484UL, 4294879488UL, 1660944383UL, 2UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
-// EOF IDENTIFIER "begin" "case" "common" "compile_opt" "else" "end" "endcase" 
-// "endelse" "endfor" "endif" "endrep" "endswitch" "endwhile" "for" "forward_function" 
-// "function" "goto" "if" "inherits" "not" "on_ioerror" "pro" "repeat" 
-// "switch" "while" END_U DEC INC LBRACE LSQUARE SYSVARNAME LCURLY CONSTANT_HEX_BYTE 
-// CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 CONSTANT_HEX_INT CONSTANT_HEX_I 
-// CONSTANT_HEX_ULONG CONSTANT_HEX_ULONG64 CONSTANT_HEX_UI CONSTANT_HEX_UINT 
-// CONSTANT_BYTE CONSTANT_LONG CONSTANT_LONG64 CONSTANT_INT CONSTANT_I 
-// CONSTANT_ULONG CONSTANT_ULONG64 CONSTANT_UI CONSTANT_UINT CONSTANT_OCT_BYTE 
-// CONSTANT_OCT_LONG CONSTANT_OCT_LONG64 CONSTANT_OCT_INT CONSTANT_OCT_I 
-// CONSTANT_OCT_ULONG CONSTANT_OCT_ULONG64 CONSTANT_OCT_UI CONSTANT_OCT_UINT 
-// CONSTANT_FLOAT CONSTANT_DOUBLE CONSTANT_BIN_BYTE CONSTANT_BIN_LONG CONSTANT_BIN_LONG64 
+const unsigned long GDLParser::_tokenSet_0_data_[] = { 1073741826UL, 1UL, 4030496UL, 436634028UL, 4325376UL, 0UL, 1UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+// EOF "for" "foreach" "repeat" "while" IDENTIFIER "begin" "case" "common" 
+// "compile_opt" "forward_function" "function" "goto" "if" "inherits" "on_ioerror" 
+// "pro" "switch" END_U DEC INC LBRACE SYSVARNAME ASTERIX 
+const antlr::BitSet GDLParser::_tokenSet_0(_tokenSet_0_data_,16);
+const unsigned long GDLParser::_tokenSet_1_data_[] = { 1073741826UL, 1UL, 4290609184UL, 436642221UL, 4250009600UL, 4294967295UL, 1221UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+// EOF "for" "foreach" "repeat" "while" IDENTIFIER "begin" "case" "common" 
+// "compile_opt" "else" "end" "endcase" "endelse" "endfor" "endforeach" 
+// "endif" "endrep" "endswitch" "endwhile" "forward_function" "function" 
+// "goto" "if" "inherits" "not" "on_ioerror" "pro" "switch" END_U DEC INC 
+// LBRACE LSQUARE SYSVARNAME LCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG 
+// CONSTANT_HEX_LONG64 CONSTANT_HEX_INT CONSTANT_HEX_I CONSTANT_HEX_ULONG 
+// CONSTANT_HEX_ULONG64 CONSTANT_HEX_UI CONSTANT_HEX_UINT CONSTANT_BYTE 
+// CONSTANT_LONG CONSTANT_LONG64 CONSTANT_INT CONSTANT_I CONSTANT_ULONG 
+// CONSTANT_ULONG64 CONSTANT_UI CONSTANT_UINT CONSTANT_OCT_BYTE CONSTANT_OCT_LONG 
+// CONSTANT_OCT_LONG64 CONSTANT_OCT_INT CONSTANT_OCT_I CONSTANT_OCT_ULONG 
+// CONSTANT_OCT_ULONG64 CONSTANT_OCT_UI CONSTANT_OCT_UINT CONSTANT_FLOAT 
+// CONSTANT_DOUBLE CONSTANT_BIN_BYTE CONSTANT_BIN_LONG CONSTANT_BIN_LONG64 
 // CONSTANT_BIN_INT CONSTANT_BIN_I CONSTANT_BIN_ULONG CONSTANT_BIN_ULONG64 
 // CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX STRING_LITERAL PLUS MINUS 
 // LOG_NEG 
 const antlr::BitSet GDLParser::_tokenSet_1(_tokenSet_1_data_,16);
-const unsigned long GDLParser::_tokenSet_2_data_[] = { 0UL, 0UL, 885000096UL, 788880UL, 8448UL, 8388608UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
-// IDENTIFIER "begin" "case" "common" "compile_opt" "for" "forward_function" 
-// "goto" "if" "inherits" "on_ioerror" "repeat" "switch" "while" DEC INC 
-// LBRACE SYSVARNAME ASTERIX 
-const antlr::BitSet GDLParser::_tokenSet_2(_tokenSet_2_data_,12);
-const unsigned long GDLParser::_tokenSet_3_data_[] = { 0UL, 0UL, 885000096UL, 4294920596UL, 4294879743UL, 1677721599UL, 2UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
-// IDENTIFIER "begin" "case" "common" "compile_opt" "for" "forward_function" 
-// "goto" "if" "inherits" "not" "on_ioerror" "repeat" "switch" "while" 
-// COMMA END_U EQUAL DEC INC AND_OP_EQ ASTERIX_EQ EQ_OP_EQ GE_OP_EQ GTMARK_EQ 
-// GT_OP_EQ LE_OP_EQ LTMARK_EQ LT_OP_EQ MATRIX_OP1_EQ MATRIX_OP2_EQ MINUS_EQ 
-// MOD_OP_EQ NE_OP_EQ OR_OP_EQ PLUS_EQ POW_EQ SLASH_EQ XOR_OP_EQ MEMBER 
-// LBRACE LSQUARE SYSVARNAME LCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG 
+const unsigned long GDLParser::_tokenSet_2_data_[] = { 1073741824UL, 1UL, 4030496UL, 402948516UL, 4325376UL, 0UL, 1UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+// "for" "foreach" "repeat" "while" IDENTIFIER "begin" "case" "common" 
+// "compile_opt" "forward_function" "goto" "if" "inherits" "on_ioerror" 
+// "switch" DEC INC LBRACE SYSVARNAME ASTERIX 
+const antlr::BitSet GDLParser::_tokenSet_2(_tokenSet_2_data_,16);
+const unsigned long GDLParser::_tokenSet_3_data_[] = { 1073741824UL, 1UL, 4030496UL, 4270104996UL, 4250140671UL, 4294967295UL, 1223UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+// "for" "foreach" "repeat" "while" IDENTIFIER "begin" "case" "common" 
+// "compile_opt" "forward_function" "goto" "if" "inherits" "not" "on_ioerror" 
+// "switch" COMMA END_U EQUAL DEC INC AND_OP_EQ ASTERIX_EQ EQ_OP_EQ GE_OP_EQ 
+// GTMARK_EQ GT_OP_EQ LE_OP_EQ LTMARK_EQ LT_OP_EQ MATRIX_OP1_EQ MATRIX_OP2_EQ 
+// MINUS_EQ MOD_OP_EQ NE_OP_EQ OR_OP_EQ PLUS_EQ POW_EQ SLASH_EQ XOR_OP_EQ 
+// MEMBER LBRACE LSQUARE SYSVARNAME LCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG 
 // CONSTANT_HEX_LONG64 CONSTANT_HEX_INT CONSTANT_HEX_I CONSTANT_HEX_ULONG 
 // CONSTANT_HEX_ULONG64 CONSTANT_HEX_UI CONSTANT_HEX_UINT CONSTANT_BYTE 
 // CONSTANT_LONG CONSTANT_LONG64 CONSTANT_INT CONSTANT_I CONSTANT_ULONG 
@@ -8741,10 +9564,23 @@
 // CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX DOT STRING_LITERAL PLUS MINUS 
 // LOG_NEG 
 const antlr::BitSet GDLParser::_tokenSet_3(_tokenSet_3_data_,16);
-const unsigned long GDLParser::_tokenSet_4_data_[] = { 0UL, 0UL, 536870944UL, 0UL, 8448UL, 8388608UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_4_data_[] = { 0UL, 0UL, 65536UL, 256UL, 4325376UL, 0UL, 1UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "inherits" LBRACE SYSVARNAME ASTERIX 
-const antlr::BitSet GDLParser::_tokenSet_4(_tokenSet_4_data_,12);
-const unsigned long GDLParser::_tokenSet_5_data_[] = { 0UL, 0UL, 536870944UL, 4294836228UL, 4294879743UL, 1677721599UL, 2UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const antlr::BitSet GDLParser::_tokenSet_4(_tokenSet_4_data_,16);
+const unsigned long GDLParser::_tokenSet_5_data_[] = { 0UL, 0UL, 65536UL, 402661632UL, 4250009600UL, 4294967295UL, 1223UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+// IDENTIFIER "inherits" "not" DEC INC LBRACE LSQUARE SYSVARNAME LCURLY 
+// CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 CONSTANT_HEX_INT 
+// CONSTANT_HEX_I CONSTANT_HEX_ULONG CONSTANT_HEX_ULONG64 CONSTANT_HEX_UI 
+// CONSTANT_HEX_UINT CONSTANT_BYTE CONSTANT_LONG CONSTANT_LONG64 CONSTANT_INT 
+// CONSTANT_I CONSTANT_ULONG CONSTANT_ULONG64 CONSTANT_UI CONSTANT_UINT 
+// CONSTANT_OCT_BYTE CONSTANT_OCT_LONG CONSTANT_OCT_LONG64 CONSTANT_OCT_INT 
+// CONSTANT_OCT_I CONSTANT_OCT_ULONG CONSTANT_OCT_ULONG64 CONSTANT_OCT_UI 
+// CONSTANT_OCT_UINT CONSTANT_FLOAT CONSTANT_DOUBLE CONSTANT_BIN_BYTE CONSTANT_BIN_LONG 
+// CONSTANT_BIN_LONG64 CONSTANT_BIN_INT CONSTANT_BIN_I CONSTANT_BIN_ULONG 
+// CONSTANT_BIN_ULONG64 CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX DOT STRING_LITERAL 
+// PLUS MINUS LOG_NEG 
+const antlr::BitSet GDLParser::_tokenSet_5(_tokenSet_5_data_,16);
+const unsigned long GDLParser::_tokenSet_6_data_[] = { 0UL, 0UL, 65536UL, 4227866880UL, 4250140671UL, 4294967295UL, 1223UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "inherits" "not" EQUAL DEC INC AND_OP_EQ ASTERIX_EQ EQ_OP_EQ 
 // GE_OP_EQ GTMARK_EQ GT_OP_EQ LE_OP_EQ LTMARK_EQ LT_OP_EQ MATRIX_OP1_EQ 
 // MATRIX_OP2_EQ MINUS_EQ MOD_OP_EQ NE_OP_EQ OR_OP_EQ PLUS_EQ POW_EQ SLASH_EQ 
@@ -8759,11 +9595,11 @@
 // CONSTANT_BIN_INT CONSTANT_BIN_I CONSTANT_BIN_ULONG CONSTANT_BIN_ULONG64 
 // CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX DOT STRING_LITERAL PLUS MINUS 
 // LOG_NEG 
-const antlr::BitSet GDLParser::_tokenSet_5(_tokenSet_5_data_,16);
-const unsigned long GDLParser::_tokenSet_6_data_[] = { 0UL, 0UL, 4096UL, 82944UL, 0UL, 0UL, 0UL, 0UL };
+const antlr::BitSet GDLParser::_tokenSet_6(_tokenSet_6_data_,16);
+const unsigned long GDLParser::_tokenSet_7_data_[] = { 0UL, 0UL, 8388608UL, 42991616UL, 0UL, 0UL, 0UL, 0UL };
 // "else" "until" COMMA END_U 
-const antlr::BitSet GDLParser::_tokenSet_6(_tokenSet_6_data_,8);
-const unsigned long GDLParser::_tokenSet_7_data_[] = { 0UL, 0UL, 536875040UL, 786436UL, 4294879488UL, 1660944383UL, 2UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const antlr::BitSet GDLParser::_tokenSet_7(_tokenSet_7_data_,8);
+const unsigned long GDLParser::_tokenSet_8_data_[] = { 0UL, 0UL, 8454144UL, 402661632UL, 4250009600UL, 4294967295UL, 1221UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "else" "inherits" "not" DEC INC LBRACE LSQUARE SYSVARNAME 
 // LCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 CONSTANT_HEX_INT 
 // CONSTANT_HEX_I CONSTANT_HEX_ULONG CONSTANT_HEX_ULONG64 CONSTANT_HEX_UI 
@@ -8775,25 +9611,33 @@
 // CONSTANT_BIN_LONG64 CONSTANT_BIN_INT CONSTANT_BIN_I CONSTANT_BIN_ULONG 
 // CONSTANT_BIN_ULONG64 CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX STRING_LITERAL 
 // PLUS MINUS LOG_NEG 
-const antlr::BitSet GDLParser::_tokenSet_7(_tokenSet_7_data_,16);
-const unsigned long GDLParser::_tokenSet_8_data_[] = { 2UL, 0UL, 4294967264UL, 860159UL, 4294880512UL, 1660944383UL, 2UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
-// EOF IDENTIFIER "and" "begin" "case" "common" "compile_opt" "do" "else" 
-// "end" "endcase" "endelse" "endfor" "endif" "endrep" "endswitch" "endwhile" 
-// "eq" "for" "forward_function" "function" "ge" "goto" "gt" "if" "inherits" 
-// "le" "lt" "mod" "ne" "not" "of" "on_ioerror" "or" "pro" "repeat" "switch" 
-// "then" "until" "while" "xor" END_U DEC INC LBRACE SLASH LSQUARE SYSVARNAME 
-// LCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 CONSTANT_HEX_INT 
-// CONSTANT_HEX_I CONSTANT_HEX_ULONG CONSTANT_HEX_ULONG64 CONSTANT_HEX_UI 
-// CONSTANT_HEX_UINT CONSTANT_BYTE CONSTANT_LONG CONSTANT_LONG64 CONSTANT_INT 
-// CONSTANT_I CONSTANT_ULONG CONSTANT_ULONG64 CONSTANT_UI CONSTANT_UINT 
-// CONSTANT_OCT_BYTE CONSTANT_OCT_LONG CONSTANT_OCT_LONG64 CONSTANT_OCT_INT 
-// CONSTANT_OCT_I CONSTANT_OCT_ULONG CONSTANT_OCT_ULONG64 CONSTANT_OCT_UI 
-// CONSTANT_OCT_UINT CONSTANT_FLOAT CONSTANT_DOUBLE CONSTANT_BIN_BYTE CONSTANT_BIN_LONG 
-// CONSTANT_BIN_LONG64 CONSTANT_BIN_INT CONSTANT_BIN_I CONSTANT_BIN_ULONG 
-// CONSTANT_BIN_ULONG64 CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX STRING_LITERAL 
-// PLUS MINUS LOG_NEG 
 const antlr::BitSet GDLParser::_tokenSet_8(_tokenSet_8_data_,16);
-const unsigned long GDLParser::_tokenSet_9_data_[] = { 0UL, 0UL, 536870944UL, 786436UL, 4294879488UL, 1660944383UL, 2UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_9_data_[] = { 1073741826UL, 1UL, 4294934560UL, 440401919UL, 4250533888UL, 4294967295UL, 1221UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+// EOF "for" "foreach" "repeat" "while" IDENTIFIER "and" "begin" "case" 
+// "common" "compile_opt" "do" "else" "end" "endcase" "endelse" "endfor" 
+// "endforeach" "endif" "endrep" "endswitch" "endwhile" "eq" "forward_function" 
+// "function" "ge" "goto" "gt" "if" "inherits" "le" "lt" "mod" "ne" "not" 
+// "of" "on_ioerror" "or" "pro" "switch" "then" "until" "xor" END_U DEC 
+// INC LBRACE SLASH LSQUARE SYSVARNAME LCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG 
+// CONSTANT_HEX_LONG64 CONSTANT_HEX_INT CONSTANT_HEX_I CONSTANT_HEX_ULONG 
+// CONSTANT_HEX_ULONG64 CONSTANT_HEX_UI CONSTANT_HEX_UINT CONSTANT_BYTE 
+// CONSTANT_LONG CONSTANT_LONG64 CONSTANT_INT CONSTANT_I CONSTANT_ULONG 
+// CONSTANT_ULONG64 CONSTANT_UI CONSTANT_UINT CONSTANT_OCT_BYTE CONSTANT_OCT_LONG 
+// CONSTANT_OCT_LONG64 CONSTANT_OCT_INT CONSTANT_OCT_I CONSTANT_OCT_ULONG 
+// CONSTANT_OCT_ULONG64 CONSTANT_OCT_UI CONSTANT_OCT_UINT CONSTANT_FLOAT 
+// CONSTANT_DOUBLE CONSTANT_BIN_BYTE CONSTANT_BIN_LONG CONSTANT_BIN_LONG64 
+// CONSTANT_BIN_INT CONSTANT_BIN_I CONSTANT_BIN_ULONG CONSTANT_BIN_ULONG64 
+// CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX STRING_LITERAL PLUS MINUS 
+// LOG_NEG 
+const antlr::BitSet GDLParser::_tokenSet_9(_tokenSet_9_data_,16);
+const unsigned long GDLParser::_tokenSet_10_data_[] = { 1073741824UL, 1UL, 4294934560UL, 4194303UL, 0UL, 0UL, 0UL, 0UL };
+// "for" "foreach" "repeat" "while" IDENTIFIER "and" "begin" "case" "common" 
+// "compile_opt" "do" "else" "end" "endcase" "endelse" "endfor" "endforeach" 
+// "endif" "endrep" "endswitch" "endwhile" "eq" "forward_function" "function" 
+// "ge" "goto" "gt" "if" "inherits" "le" "lt" "mod" "ne" "not" "of" "on_ioerror" 
+// "or" "pro" "switch" "then" "until" "xor" 
+const antlr::BitSet GDLParser::_tokenSet_10(_tokenSet_10_data_,8);
+const unsigned long GDLParser::_tokenSet_11_data_[] = { 0UL, 0UL, 65536UL, 402661632UL, 4250009600UL, 4294967295UL, 1221UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "inherits" "not" DEC INC LBRACE LSQUARE SYSVARNAME LCURLY 
 // CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 CONSTANT_HEX_INT 
 // CONSTANT_HEX_I CONSTANT_HEX_ULONG CONSTANT_HEX_ULONG64 CONSTANT_HEX_UI 
@@ -8805,8 +9649,8 @@
 // CONSTANT_BIN_LONG64 CONSTANT_BIN_INT CONSTANT_BIN_I CONSTANT_BIN_ULONG 
 // CONSTANT_BIN_ULONG64 CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX STRING_LITERAL 
 // PLUS MINUS LOG_NEG 
-const antlr::BitSet GDLParser::_tokenSet_9(_tokenSet_9_data_,16);
-const unsigned long GDLParser::_tokenSet_10_data_[] = { 0UL, 0UL, 3927969888UL, 873511UL, 4294897536UL, 4294967295UL, 31UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const antlr::BitSet GDLParser::_tokenSet_11(_tokenSet_11_data_,16);
+const unsigned long GDLParser::_tokenSet_12_data_[] = { 0UL, 0UL, 8585216UL, 447823698UL, 4259250176UL, 4294967295UL, 16383UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "and" "else" "eq" "ge" "gt" "inherits" "le" "lt" "mod" "ne" 
 // "not" "or" "until" "xor" COMMA END_U DEC INC MEMBER LBRACE RBRACE SLASH 
 // LSQUARE SYSVARNAME EXCLAMATION LCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG 
@@ -8820,11 +9664,11 @@
 // CONSTANT_BIN_INT CONSTANT_BIN_I CONSTANT_BIN_ULONG CONSTANT_BIN_ULONG64 
 // CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX DOT STRING_LITERAL POW MATRIX_OP1 
 // MATRIX_OP2 PLUS MINUS LTMARK GTMARK LOG_NEG LOG_AND LOG_OR QUESTION 
-const antlr::BitSet GDLParser::_tokenSet_10(_tokenSet_10_data_,16);
-const unsigned long GDLParser::_tokenSet_11_data_[] = { 0UL, 0UL, 536870944UL, 0UL, 24576UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const antlr::BitSet GDLParser::_tokenSet_12(_tokenSet_12_data_,16);
+const unsigned long GDLParser::_tokenSet_13_data_[] = { 0UL, 0UL, 65536UL, 256UL, 12582912UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "inherits" SYSVARNAME EXCLAMATION 
-const antlr::BitSet GDLParser::_tokenSet_11(_tokenSet_11_data_,12);
-const unsigned long GDLParser::_tokenSet_12_data_[] = { 2UL, 0UL, 3927965792UL, 806951UL, 4294962560UL, 4294967295UL, 31UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const antlr::BitSet GDLParser::_tokenSet_13(_tokenSet_13_data_,12);
+const unsigned long GDLParser::_tokenSet_14_data_[] = { 2UL, 0UL, 196608UL, 413220690UL, 4292542464UL, 4294967295UL, 16383UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // EOF IDENTIFIER "and" "eq" "ge" "gt" "inherits" "le" "lt" "mod" "ne" 
 // "not" "or" "xor" COMMA DEC INC MEMBER LBRACE SLASH LSQUARE SYSVARNAME 
 // EXCLAMATION LCURLY RCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 
@@ -8838,8 +9682,8 @@
 // CONSTANT_BIN_ULONG CONSTANT_BIN_ULONG64 CONSTANT_BIN_UI CONSTANT_BIN_UINT 
 // ASTERIX DOT STRING_LITERAL POW MATRIX_OP1 MATRIX_OP2 PLUS MINUS LTMARK 
 // GTMARK LOG_NEG LOG_AND LOG_OR QUESTION 
-const antlr::BitSet GDLParser::_tokenSet_12(_tokenSet_12_data_,16);
-const unsigned long GDLParser::_tokenSet_13_data_[] = { 0UL, 0UL, 536870944UL, 786436UL, 4294895872UL, 1660944383UL, 2UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const antlr::BitSet GDLParser::_tokenSet_14(_tokenSet_14_data_,16);
+const unsigned long GDLParser::_tokenSet_15_data_[] = { 0UL, 0UL, 65536UL, 402661632UL, 4258398208UL, 4294967295UL, 1221UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "inherits" "not" DEC INC LBRACE LSQUARE SYSVARNAME EXCLAMATION 
 // LCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 CONSTANT_HEX_INT 
 // CONSTANT_HEX_I CONSTANT_HEX_ULONG CONSTANT_HEX_ULONG64 CONSTANT_HEX_UI 
@@ -8851,8 +9695,8 @@
 // CONSTANT_BIN_LONG64 CONSTANT_BIN_INT CONSTANT_BIN_I CONSTANT_BIN_ULONG 
 // CONSTANT_BIN_ULONG64 CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX STRING_LITERAL 
 // PLUS MINUS LOG_NEG 
-const antlr::BitSet GDLParser::_tokenSet_13(_tokenSet_13_data_,16);
-const unsigned long GDLParser::_tokenSet_14_data_[] = { 0UL, 0UL, 3927965792UL, 839719UL, 4294962560UL, 4294967295UL, 31UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const antlr::BitSet GDLParser::_tokenSet_15(_tokenSet_15_data_,16);
+const unsigned long GDLParser::_tokenSet_16_data_[] = { 0UL, 0UL, 196608UL, 429997906UL, 4292542464UL, 4294967295UL, 16383UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "and" "eq" "ge" "gt" "inherits" "le" "lt" "mod" "ne" "not" 
 // "or" "xor" COMMA COLON DEC INC MEMBER LBRACE SLASH LSQUARE SYSVARNAME 
 // EXCLAMATION LCURLY RCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 
@@ -8866,8 +9710,8 @@
 // CONSTANT_BIN_ULONG CONSTANT_BIN_ULONG64 CONSTANT_BIN_UI CONSTANT_BIN_UINT 
 // ASTERIX DOT STRING_LITERAL POW MATRIX_OP1 MATRIX_OP2 PLUS MINUS LTMARK 
 // GTMARK LOG_NEG LOG_AND LOG_OR QUESTION 
-const antlr::BitSet GDLParser::_tokenSet_14(_tokenSet_14_data_,16);
-const unsigned long GDLParser::_tokenSet_15_data_[] = { 0UL, 0UL, 3927965792UL, 839719UL, 4294901632UL, 4294967295UL, 31UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const antlr::BitSet GDLParser::_tokenSet_16(_tokenSet_16_data_,16);
+const unsigned long GDLParser::_tokenSet_17_data_[] = { 0UL, 0UL, 196608UL, 429997906UL, 4261347328UL, 4294967295UL, 16383UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "and" "eq" "ge" "gt" "inherits" "le" "lt" "mod" "ne" "not" 
 // "or" "xor" COMMA COLON DEC INC MEMBER LBRACE RBRACE SLASH LSQUARE RSQUARE 
 // SYSVARNAME EXCLAMATION LCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 
@@ -8881,11 +9725,11 @@
 // CONSTANT_BIN_ULONG CONSTANT_BIN_ULONG64 CONSTANT_BIN_UI CONSTANT_BIN_UINT 
 // ASTERIX DOT STRING_LITERAL POW MATRIX_OP1 MATRIX_OP2 PLUS MINUS LTMARK 
 // GTMARK LOG_NEG LOG_AND LOG_OR QUESTION 
-const antlr::BitSet GDLParser::_tokenSet_15(_tokenSet_15_data_,16);
-const unsigned long GDLParser::_tokenSet_16_data_[] = { 0UL, 0UL, 0UL, 49152UL, 4608UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const antlr::BitSet GDLParser::_tokenSet_17(_tokenSet_17_data_,16);
+const unsigned long GDLParser::_tokenSet_18_data_[] = { 0UL, 0UL, 0UL, 25165824UL, 2359296UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // COMMA COLON RBRACE RSQUARE 
-const antlr::BitSet GDLParser::_tokenSet_16(_tokenSet_16_data_,12);
-const unsigned long GDLParser::_tokenSet_17_data_[] = { 0UL, 0UL, 3927965792UL, 806951UL, 4294901632UL, 4294967295UL, 31UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const antlr::BitSet GDLParser::_tokenSet_18(_tokenSet_18_data_,12);
+const unsigned long GDLParser::_tokenSet_19_data_[] = { 0UL, 0UL, 196608UL, 413220690UL, 4261347328UL, 4294967295UL, 16383UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "and" "eq" "ge" "gt" "inherits" "le" "lt" "mod" "ne" "not" 
 // "or" "xor" COMMA DEC INC MEMBER LBRACE RBRACE SLASH LSQUARE RSQUARE 
 // SYSVARNAME EXCLAMATION LCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 
@@ -8899,8 +9743,14 @@
 // CONSTANT_BIN_ULONG CONSTANT_BIN_ULONG64 CONSTANT_BIN_UI CONSTANT_BIN_UINT 
 // ASTERIX DOT STRING_LITERAL POW MATRIX_OP1 MATRIX_OP2 PLUS MINUS LTMARK 
 // GTMARK LOG_NEG LOG_AND LOG_OR QUESTION 
-const antlr::BitSet GDLParser::_tokenSet_17(_tokenSet_17_data_,16);
-const unsigned long GDLParser::_tokenSet_18_data_[] = { 2UL, 0UL, 3927971936UL, 906799UL, 4294950784UL, 4294967295UL, 31UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const antlr::BitSet GDLParser::_tokenSet_19(_tokenSet_19_data_,16);
+const unsigned long GDLParser::_tokenSet_20_data_[] = { 0UL, 0UL, 65536UL, 0UL, 12713984UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+// IDENTIFIER LBRACE SYSVARNAME EXCLAMATION 
+const antlr::BitSet GDLParser::_tokenSet_20(_tokenSet_20_data_,12);
+const unsigned long GDLParser::_tokenSet_21_data_[] = { 0UL, 0UL, 8388608UL, 47185920UL, 1179648UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+// "else" "until" METHOD COMMA END_U LBRACE LSQUARE 
+const antlr::BitSet GDLParser::_tokenSet_21(_tokenSet_21_data_,12);
+const unsigned long GDLParser::_tokenSet_22_data_[] = { 2UL, 0UL, 12779520UL, 465141586UL, 4286513152UL, 4294967295UL, 16383UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // EOF IDENTIFIER "and" "do" "else" "eq" "ge" "gt" "inherits" "le" "lt" 
 // "mod" "ne" "not" "of" "or" "then" "until" "xor" COMMA COLON END_U DEC 
 // INC MEMBER LBRACE RBRACE SLASH LSQUARE RSQUARE SYSVARNAME LCURLY RCURLY 
@@ -8915,12 +9765,12 @@
 // CONSTANT_BIN_ULONG64 CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX DOT STRING_LITERAL 
 // POW MATRIX_OP1 MATRIX_OP2 PLUS MINUS LTMARK GTMARK LOG_NEG LOG_AND LOG_OR 
 // QUESTION 
-const antlr::BitSet GDLParser::_tokenSet_18(_tokenSet_18_data_,16);
-const unsigned long GDLParser::_tokenSet_19_data_[] = { 0UL, 0UL, 0UL, 1UL, 1024UL, 411041792UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const antlr::BitSet GDLParser::_tokenSet_22(_tokenSet_22_data_,16);
+const unsigned long GDLParser::_tokenSet_23_data_[] = { 0UL, 0UL, 0UL, 2048UL, 524288UL, 0UL, 49UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // "mod" SLASH ASTERIX MATRIX_OP1 MATRIX_OP2 
-const antlr::BitSet GDLParser::_tokenSet_19(_tokenSet_19_data_,12);
-const unsigned long GDLParser::_tokenSet_20_data_[] = { 0UL, 0UL, 3391094784UL, 2UL, 0UL, 0UL, 0UL, 0UL };
+const antlr::BitSet GDLParser::_tokenSet_23(_tokenSet_23_data_,16);
+const unsigned long GDLParser::_tokenSet_24_data_[] = { 0UL, 0UL, 0UL, 5714UL, 0UL, 0UL, 0UL, 0UL };
 // "eq" "ge" "gt" "le" "lt" "ne" 
-const antlr::BitSet GDLParser::_tokenSet_20(_tokenSet_20_data_,8);
+const antlr::BitSet GDLParser::_tokenSet_24(_tokenSet_24_data_,8);
 
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/GDLParser.hpp cvs/gdl/src/GDLParser.hpp
--- gdl-0.9rc4/src/GDLParser.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/GDLParser.hpp	2010-04-22 09:50:40.000000000 -0600
@@ -28,7 +28,7 @@
 //#include "dinterpreter.hpp"
 
 // defintion in dinterpreter.cpp
-void SetActualCompileOpt( unsigned int cOpt);
+//void SetActualCompileOpt( unsigned int cOpt);
 
 class CUSTOM_API GDLParser : public antlr::LLkParser, public GDLTokenTypes
 {
@@ -61,7 +61,7 @@
         else if( opt == "IDL2")              compileOpt |= IDL2;
         else if( opt == "STRICTARRSUBS")     compileOpt |= STRICTARRSUBS;
         else throw GDLException("Unrecognised COMPILE_OPT option: "+opt);
-        SetActualCompileOpt( compileOpt);
+//        SetActualCompileOpt( compileOpt);
     }
 
     std::string subName; // name of procedure function to be compiled ("" -> all file)
@@ -132,6 +132,7 @@
 	public: void keyword_declaration();
 	public: std::string  object_name();
 	public: void compile_opt();
+	public: void endforeach_mark();
 	public: void endfor_mark();
 	public: void endrep_mark();
 	public: void endwhile_mark();
@@ -142,10 +143,12 @@
 	public: void label();
 	public: void baseclass_method();
 	public: void assign_expr();
-	public: void deref_expr();
+	public: void deref_dot_expr_keeplast();
 	public: void formal_procedure_call();
+	public: void deref_expr();
 	public: void procedure_call();
 	public: void for_statement();
+	public: void foreach_statement();
 	public: void repeat_statement();
 	public: void while_statement();
 	public: void jump_statement();
@@ -153,6 +156,7 @@
 	public: void repeat_block();
 	public: void while_block();
 	public: void for_block();
+	public: void foreach_block();
 	public: void if_block();
 	public: void else_block();
 	public: void parameter_def_list();
@@ -180,9 +184,11 @@
 	public: void array_expr_nth();
 	public: void tag_array_expr_nth_sub();
 	public: void tag_array_expr_nth();
+	public: int  tag_access_keeplast();
 	public: SizeT  tag_access();
-	public: void array_expr_fn();
+	public: void deref_dot_expr();
 	public: bool  member_function_call();
+	public: void member_function_call_dot();
 	public: void primary_expr();
 	public: void decinc_expr();
 	public: void exponential_expr();
@@ -204,10 +210,10 @@
 private:
 	static const char* tokenNames[];
 #ifndef NO_STATIC_CONSTS
-	static const int NUM_TOKENS = 216;
+	static const int NUM_TOKENS = 225;
 #else
 	enum {
-		NUM_TOKENS = 216
+		NUM_TOKENS = 225
 	};
 #endif
 	
@@ -253,6 +259,14 @@
 	static const antlr::BitSet _tokenSet_19;
 	static const unsigned long _tokenSet_20_data_[];
 	static const antlr::BitSet _tokenSet_20;
+	static const unsigned long _tokenSet_21_data_[];
+	static const antlr::BitSet _tokenSet_21;
+	static const unsigned long _tokenSet_22_data_[];
+	static const antlr::BitSet _tokenSet_22;
+	static const unsigned long _tokenSet_23_data_[];
+	static const antlr::BitSet _tokenSet_23;
+	static const unsigned long _tokenSet_24_data_[];
+	static const antlr::BitSet _tokenSet_24;
 };
 
 #endif /*INC_GDLParser_hpp_*/
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdlpsstream.cpp cvs/gdl/src/gdlpsstream.cpp
--- gdl-0.9rc4/src/gdlpsstream.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdlpsstream.cpp	2010-04-16 11:22:53.000000000 -0600
@@ -25,6 +25,6 @@
 
 void GDLPSStream::Init()
 {
-  plstream::init();
+   plstream::init();
 }
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdlpsstream.hpp cvs/gdl/src/gdlpsstream.hpp
--- gdl-0.9rc4/src/gdlpsstream.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdlpsstream.hpp	2010-04-16 11:22:53.000000000 -0600
@@ -29,8 +29,7 @@
   }
 
   ~GDLPSStream()
-  {
-  }
+  {}
  
   //  void eop() {};
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdlpython.cpp cvs/gdl/src/gdlpython.cpp
--- gdl-0.9rc4/src/gdlpython.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdlpython.cpp	2010-04-16 11:22:53.000000000 -0600
@@ -20,7 +20,7 @@
 //#include "includefirst.hpp"
 
 // this part contains variable conversion stuff
-// used by both GDL embedded in pythjon and python embedded in GDL
+// used by both GDL embedded in python and python embedded in GDL
 //#if defined(USE_PYTHON) || defined(PYTHON_MODULE)
 
 //#include <deque>
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdlsvgstream.cpp cvs/gdl/src/gdlsvgstream.cpp
--- gdl-0.9rc4/src/gdlsvgstream.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdlsvgstream.cpp	2010-04-16 11:22:53.000000000 -0600
@@ -22,5 +22,5 @@
 
 void GDLSVGStream::Init()
 {
-  plstream::init();
+   plstream::init();
 }
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/GDLTokenTypes.hpp cvs/gdl/src/GDLTokenTypes.hpp
--- gdl-0.9rc4/src/GDLTokenTypes.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/GDLTokenTypes.hpp	2010-04-22 09:50:40.000000000 -0600
@@ -16,214 +16,223 @@
 		ASSIGN = 5,
 		ASSIGN_INPLACE = 6,
 		ASSIGN_REPLACE = 7,
-		ARRAYDEF = 8,
-		ARRAYDEF_CONST = 9,
-		ARRAYIX = 10,
-		ARRAYIX_ALL = 11,
-		ARRAYIX_ORANGE = 12,
-		ARRAYIX_RANGE = 13,
-		ARRAYIX_ORANGE_S = 14,
-		ARRAYIX_RANGE_S = 15,
-		ARRAYEXPR = 16,
-		ARRAYEXPR_FN = 17,
-		BLOCK = 18,
-		BREAK = 19,
-		CONTINUE = 20,
-		COMMONDECL = 21,
-		COMMONDEF = 22,
-		CONSTANT = 23,
-		DEREF = 24,
-		ELSEBLK = 25,
-		EXPR = 26,
-		FOR_STEP = 27,
-		FCALL = 28,
-		FCALL_LIB = 29,
-		FCALL_LIB_RETNEW = 30,
-		IF_ELSE = 31,
-		KEYDECL = 32,
-		KEYDEF = 33,
-		KEYDEF_REF = 34,
-		KEYDEF_REF_CHECK = 35,
-		KEYDEF_REF_EXPR = 36,
-		LABEL = 37,
-		MPCALL = 38,
-		MPCALL_PARENT = 39,
-		MFCALL = 40,
-		MFCALL_LIB = 41,
-		MFCALL_LIB_RETNEW = 42,
-		MFCALL_PARENT = 43,
-		MFCALL_PARENT_LIB = 44,
-		MFCALL_PARENT_LIB_RETNEW = 45,
-		NOP = 46,
-		NSTRUC = 47,
-		NSTRUC_REF = 48,
-		ON_IOERROR_NULL = 49,
-		PCALL = 50,
-		PCALL_LIB = 51,
-		PARADECL = 52,
-		PARAEXPR = 53,
-		POSTDEC = 54,
-		POSTINC = 55,
-		DECSTATEMENT = 56,
-		INCSTATEMENT = 57,
-		REF = 58,
-		REF_CHECK = 59,
-		REF_EXPR = 60,
-		RETURN = 61,
-		RETF = 62,
-		RETP = 63,
-		STRUC = 64,
-		SYSVAR = 65,
-		UMINUS = 66,
-		VAR = 67,
-		VARPTR = 68,
-		IDENTIFIER = 69,
-		AND_OP = 70,
-		BEGIN = 71,
-		CASE = 72,
-		COMMON = 73,
-		COMPILE_OPT = 74,
-		DO = 75,
-		ELSE = 76,
-		END = 77,
-		ENDCASE = 78,
-		ENDELSE = 79,
-		ENDFOR = 80,
-		ENDIF = 81,
-		ENDREP = 82,
-		ENDSWITCH = 83,
-		ENDWHILE = 84,
-		EQ_OP = 85,
-		FOR = 86,
-		FORWARD = 87,
-		FUNCTION = 88,
-		GE_OP = 89,
-		GOTO = 90,
-		GT_OP = 91,
-		IF = 92,
-		INHERITS = 93,
-		LE_OP = 94,
-		LT_OP = 95,
-		MOD_OP = 96,
-		NE_OP = 97,
-		NOT_OP = 98,
-		OF = 99,
-		ON_IOERROR = 100,
-		OR_OP = 101,
-		PRO = 102,
-		REPEAT = 103,
-		SWITCH = 104,
-		THEN = 105,
-		UNTIL = 106,
-		WHILE = 107,
-		XOR_OP = 108,
-		METHOD = 109,
-		COMMA = 110,
-		COLON = 111,
-		END_U = 112,
-		EQUAL = 113,
-		DEC = 114,
-		INC = 115,
-		AND_OP_EQ = 116,
-		ASTERIX_EQ = 117,
-		EQ_OP_EQ = 118,
-		GE_OP_EQ = 119,
-		GTMARK_EQ = 120,
-		GT_OP_EQ = 121,
-		LE_OP_EQ = 122,
-		LTMARK_EQ = 123,
-		LT_OP_EQ = 124,
-		MATRIX_OP1_EQ = 125,
-		MATRIX_OP2_EQ = 126,
-		MINUS_EQ = 127,
-		MOD_OP_EQ = 128,
-		NE_OP_EQ = 129,
-		OR_OP_EQ = 130,
-		PLUS_EQ = 131,
-		POW_EQ = 132,
-		SLASH_EQ = 133,
-		XOR_OP_EQ = 134,
-		MEMBER = 135,
-		LBRACE = 136,
-		RBRACE = 137,
-		SLASH = 138,
-		LSQUARE = 139,
-		RSQUARE = 140,
-		SYSVARNAME = 141,
-		EXCLAMATION = 142,
-		LCURLY = 143,
-		RCURLY = 144,
-		CONSTANT_HEX_BYTE = 145,
-		CONSTANT_HEX_LONG = 146,
-		CONSTANT_HEX_LONG64 = 147,
-		CONSTANT_HEX_INT = 148,
-		CONSTANT_HEX_I = 149,
-		CONSTANT_HEX_ULONG = 150,
-		CONSTANT_HEX_ULONG64 = 151,
-		CONSTANT_HEX_UI = 152,
-		CONSTANT_HEX_UINT = 153,
-		CONSTANT_BYTE = 154,
-		CONSTANT_LONG = 155,
-		CONSTANT_LONG64 = 156,
-		CONSTANT_INT = 157,
-		CONSTANT_I = 158,
-		CONSTANT_ULONG = 159,
-		CONSTANT_ULONG64 = 160,
-		CONSTANT_UI = 161,
-		CONSTANT_UINT = 162,
-		CONSTANT_OCT_BYTE = 163,
-		CONSTANT_OCT_LONG = 164,
-		CONSTANT_OCT_LONG64 = 165,
-		CONSTANT_OCT_INT = 166,
-		CONSTANT_OCT_I = 167,
-		CONSTANT_OCT_ULONG = 168,
-		CONSTANT_OCT_ULONG64 = 169,
-		CONSTANT_OCT_UI = 170,
-		CONSTANT_OCT_UINT = 171,
-		CONSTANT_FLOAT = 172,
-		CONSTANT_DOUBLE = 173,
-		CONSTANT_BIN_BYTE = 174,
-		CONSTANT_BIN_LONG = 175,
-		CONSTANT_BIN_LONG64 = 176,
-		CONSTANT_BIN_INT = 177,
-		CONSTANT_BIN_I = 178,
-		CONSTANT_BIN_ULONG = 179,
-		CONSTANT_BIN_ULONG64 = 180,
-		CONSTANT_BIN_UI = 181,
-		CONSTANT_BIN_UINT = 182,
-		ASTERIX = 183,
-		DOT = 184,
-		STRING_LITERAL = 185,
-		POW = 186,
-		MATRIX_OP1 = 187,
-		MATRIX_OP2 = 188,
-		PLUS = 189,
-		MINUS = 190,
-		LTMARK = 191,
-		GTMARK = 192,
-		LOG_NEG = 193,
-		LOG_AND = 194,
-		LOG_OR = 195,
-		QUESTION = 196,
-		STRING = 197,
-		INCLUDE = 198,
-		EOL = 199,
-		W = 200,
-		D = 201,
-		L = 202,
-		H = 203,
-		O = 204,
-		B = 205,
-		EXP = 206,
-		DBL_E = 207,
-		DBL = 208,
-		CONSTANT_OR_STRING_LITERAL = 209,
-		COMMENT = 210,
-		END_MARKER = 211,
-		WHITESPACE = 212,
-		SKIP_LINES = 213,
-		CONT_STATEMENT = 214,
-		END_OF_LINE = 215,
+		ASSIGN_ARRAYEXPR_MFCALL = 8,
+		ARRAYDEF = 9,
+		ARRAYDEF_CONST = 10,
+		ARRAYIX = 11,
+		ARRAYIX_ALL = 12,
+		ARRAYIX_ORANGE = 13,
+		ARRAYIX_RANGE = 14,
+		ARRAYIX_ORANGE_S = 15,
+		ARRAYIX_RANGE_S = 16,
+		ARRAYEXPR = 17,
+		ARRAYEXPR_FN = 18,
+		ARRAYEXPR_MFCALL = 19,
+		BLOCK = 20,
+		BREAK = 21,
+		CSBLOCK = 22,
+		CONTINUE = 23,
+		COMMONDECL = 24,
+		COMMONDEF = 25,
+		CONSTANT = 26,
+		DEREF = 27,
+		ELSEBLK = 28,
+		EXPR = 29,
+		FOR = 30,
+		FOR_STEP = 31,
+		FOREACH = 32,
+		FOR_LOOP = 33,
+		FOR_STEP_LOOP = 34,
+		FOREACH_LOOP = 35,
+		FCALL = 36,
+		FCALL_LIB = 37,
+		FCALL_LIB_RETNEW = 38,
+		IF_ELSE = 39,
+		KEYDECL = 40,
+		KEYDEF = 41,
+		KEYDEF_REF = 42,
+		KEYDEF_REF_CHECK = 43,
+		KEYDEF_REF_EXPR = 44,
+		LABEL = 45,
+		MPCALL = 46,
+		MPCALL_PARENT = 47,
+		MFCALL = 48,
+		MFCALL_LIB = 49,
+		MFCALL_LIB_RETNEW = 50,
+		MFCALL_PARENT = 51,
+		MFCALL_PARENT_LIB = 52,
+		MFCALL_PARENT_LIB_RETNEW = 53,
+		NOP = 54,
+		NSTRUC = 55,
+		NSTRUC_REF = 56,
+		ON_IOERROR_NULL = 57,
+		PCALL = 58,
+		PCALL_LIB = 59,
+		PARADECL = 60,
+		PARAEXPR = 61,
+		POSTDEC = 62,
+		POSTINC = 63,
+		DECSTATEMENT = 64,
+		INCSTATEMENT = 65,
+		REF = 66,
+		REF_CHECK = 67,
+		REF_EXPR = 68,
+		REPEAT = 69,
+		REPEAT_LOOP = 70,
+		RETURN = 71,
+		RETF = 72,
+		RETP = 73,
+		STRUC = 74,
+		SYSVAR = 75,
+		UMINUS = 76,
+		VAR = 77,
+		VARPTR = 78,
+		WHILE = 79,
+		IDENTIFIER = 80,
+		AND_OP = 81,
+		BEGIN = 82,
+		CASE = 83,
+		COMMON = 84,
+		COMPILE_OPT = 85,
+		DO = 86,
+		ELSE = 87,
+		END = 88,
+		ENDCASE = 89,
+		ENDELSE = 90,
+		ENDFOR = 91,
+		ENDFOREACH = 92,
+		ENDIF = 93,
+		ENDREP = 94,
+		ENDSWITCH = 95,
+		ENDWHILE = 96,
+		EQ_OP = 97,
+		FORWARD = 98,
+		FUNCTION = 99,
+		GE_OP = 100,
+		GOTO = 101,
+		GT_OP = 102,
+		IF = 103,
+		INHERITS = 104,
+		LE_OP = 105,
+		LT_OP = 106,
+		MOD_OP = 107,
+		NE_OP = 108,
+		NOT_OP = 109,
+		OF = 110,
+		ON_IOERROR = 111,
+		OR_OP = 112,
+		PRO = 113,
+		SWITCH = 114,
+		THEN = 115,
+		UNTIL = 116,
+		XOR_OP = 117,
+		METHOD = 118,
+		COMMA = 119,
+		COLON = 120,
+		END_U = 121,
+		EQUAL = 122,
+		DEC = 123,
+		INC = 124,
+		AND_OP_EQ = 125,
+		ASTERIX_EQ = 126,
+		EQ_OP_EQ = 127,
+		GE_OP_EQ = 128,
+		GTMARK_EQ = 129,
+		GT_OP_EQ = 130,
+		LE_OP_EQ = 131,
+		LTMARK_EQ = 132,
+		LT_OP_EQ = 133,
+		MATRIX_OP1_EQ = 134,
+		MATRIX_OP2_EQ = 135,
+		MINUS_EQ = 136,
+		MOD_OP_EQ = 137,
+		NE_OP_EQ = 138,
+		OR_OP_EQ = 139,
+		PLUS_EQ = 140,
+		POW_EQ = 141,
+		SLASH_EQ = 142,
+		XOR_OP_EQ = 143,
+		MEMBER = 144,
+		LBRACE = 145,
+		RBRACE = 146,
+		SLASH = 147,
+		LSQUARE = 148,
+		RSQUARE = 149,
+		SYSVARNAME = 150,
+		EXCLAMATION = 151,
+		LCURLY = 152,
+		RCURLY = 153,
+		CONSTANT_HEX_BYTE = 154,
+		CONSTANT_HEX_LONG = 155,
+		CONSTANT_HEX_LONG64 = 156,
+		CONSTANT_HEX_INT = 157,
+		CONSTANT_HEX_I = 158,
+		CONSTANT_HEX_ULONG = 159,
+		CONSTANT_HEX_ULONG64 = 160,
+		CONSTANT_HEX_UI = 161,
+		CONSTANT_HEX_UINT = 162,
+		CONSTANT_BYTE = 163,
+		CONSTANT_LONG = 164,
+		CONSTANT_LONG64 = 165,
+		CONSTANT_INT = 166,
+		CONSTANT_I = 167,
+		CONSTANT_ULONG = 168,
+		CONSTANT_ULONG64 = 169,
+		CONSTANT_UI = 170,
+		CONSTANT_UINT = 171,
+		CONSTANT_OCT_BYTE = 172,
+		CONSTANT_OCT_LONG = 173,
+		CONSTANT_OCT_LONG64 = 174,
+		CONSTANT_OCT_INT = 175,
+		CONSTANT_OCT_I = 176,
+		CONSTANT_OCT_ULONG = 177,
+		CONSTANT_OCT_ULONG64 = 178,
+		CONSTANT_OCT_UI = 179,
+		CONSTANT_OCT_UINT = 180,
+		CONSTANT_FLOAT = 181,
+		CONSTANT_DOUBLE = 182,
+		CONSTANT_BIN_BYTE = 183,
+		CONSTANT_BIN_LONG = 184,
+		CONSTANT_BIN_LONG64 = 185,
+		CONSTANT_BIN_INT = 186,
+		CONSTANT_BIN_I = 187,
+		CONSTANT_BIN_ULONG = 188,
+		CONSTANT_BIN_ULONG64 = 189,
+		CONSTANT_BIN_UI = 190,
+		CONSTANT_BIN_UINT = 191,
+		ASTERIX = 192,
+		DOT = 193,
+		STRING_LITERAL = 194,
+		POW = 195,
+		MATRIX_OP1 = 196,
+		MATRIX_OP2 = 197,
+		PLUS = 198,
+		MINUS = 199,
+		LTMARK = 200,
+		GTMARK = 201,
+		LOG_NEG = 202,
+		LOG_AND = 203,
+		LOG_OR = 204,
+		QUESTION = 205,
+		STRING = 206,
+		INCLUDE = 207,
+		EOL = 208,
+		W = 209,
+		D = 210,
+		L = 211,
+		H = 212,
+		O = 213,
+		B = 214,
+		EXP = 215,
+		DBL_E = 216,
+		DBL = 217,
+		CONSTANT_OR_STRING_LITERAL = 218,
+		COMMENT = 219,
+		END_MARKER = 220,
+		WHITESPACE = 221,
+		SKIP_LINES = 222,
+		CONT_STATEMENT = 223,
+		END_OF_LINE = 224,
 		NULL_TREE_LOOKAHEAD = 3
 	};
 #ifdef __cplusplus
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/GDLTokenTypes.txt cvs/gdl/src/GDLTokenTypes.txt
--- gdl-0.9rc4/src/GDLTokenTypes.txt	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/GDLTokenTypes.txt	2010-04-22 09:50:40.000000000 -0600
@@ -4,211 +4,220 @@
 ASSIGN=5
 ASSIGN_INPLACE=6
 ASSIGN_REPLACE=7
-ARRAYDEF=8
-ARRAYDEF_CONST=9
-ARRAYIX=10
-ARRAYIX_ALL=11
-ARRAYIX_ORANGE=12
-ARRAYIX_RANGE=13
-ARRAYIX_ORANGE_S=14
-ARRAYIX_RANGE_S=15
-ARRAYEXPR=16
-ARRAYEXPR_FN=17
-BLOCK=18
-BREAK=19
-CONTINUE=20
-COMMONDECL=21
-COMMONDEF=22
-CONSTANT=23
-DEREF=24
-ELSEBLK=25
-EXPR=26
-FOR_STEP=27
-FCALL=28
-FCALL_LIB=29
-FCALL_LIB_RETNEW=30
-IF_ELSE=31
-KEYDECL=32
-KEYDEF=33
-KEYDEF_REF=34
-KEYDEF_REF_CHECK=35
-KEYDEF_REF_EXPR=36
-LABEL=37
-MPCALL=38
-MPCALL_PARENT=39
-MFCALL=40
-MFCALL_LIB=41
-MFCALL_LIB_RETNEW=42
-MFCALL_PARENT=43
-MFCALL_PARENT_LIB=44
-MFCALL_PARENT_LIB_RETNEW=45
-NOP=46
-NSTRUC=47
-NSTRUC_REF=48
-ON_IOERROR_NULL=49
-PCALL=50
-PCALL_LIB=51
-PARADECL=52
-PARAEXPR=53
-POSTDEC=54
-POSTINC=55
-DECSTATEMENT=56
-INCSTATEMENT=57
-REF=58
-REF_CHECK=59
-REF_EXPR=60
-RETURN=61
-RETF=62
-RETP=63
-STRUC=64
-SYSVAR=65
-UMINUS=66
-VAR=67
-VARPTR=68
-IDENTIFIER=69
-AND_OP="and"=70
-BEGIN="begin"=71
-CASE="case"=72
-COMMON="common"=73
-COMPILE_OPT="compile_opt"=74
-DO="do"=75
-ELSE="else"=76
-END="end"=77
-ENDCASE="endcase"=78
-ENDELSE="endelse"=79
-ENDFOR="endfor"=80
-ENDIF="endif"=81
-ENDREP="endrep"=82
-ENDSWITCH="endswitch"=83
-ENDWHILE="endwhile"=84
-EQ_OP="eq"=85
-FOR="for"=86
-FORWARD="forward_function"=87
-FUNCTION="function"=88
-GE_OP="ge"=89
-GOTO="goto"=90
-GT_OP="gt"=91
-IF="if"=92
-INHERITS="inherits"=93
-LE_OP="le"=94
-LT_OP="lt"=95
-MOD_OP="mod"=96
-NE_OP="ne"=97
-NOT_OP="not"=98
-OF="of"=99
-ON_IOERROR="on_ioerror"=100
-OR_OP="or"=101
-PRO="pro"=102
-REPEAT="repeat"=103
-SWITCH="switch"=104
-THEN="then"=105
-UNTIL="until"=106
-WHILE="while"=107
-XOR_OP="xor"=108
-METHOD=109
-COMMA=110
-COLON=111
-END_U=112
-EQUAL=113
-DEC=114
-INC=115
-AND_OP_EQ=116
-ASTERIX_EQ=117
-EQ_OP_EQ=118
-GE_OP_EQ=119
-GTMARK_EQ=120
-GT_OP_EQ=121
-LE_OP_EQ=122
-LTMARK_EQ=123
-LT_OP_EQ=124
-MATRIX_OP1_EQ=125
-MATRIX_OP2_EQ=126
-MINUS_EQ=127
-MOD_OP_EQ=128
-NE_OP_EQ=129
-OR_OP_EQ=130
-PLUS_EQ=131
-POW_EQ=132
-SLASH_EQ=133
-XOR_OP_EQ=134
-MEMBER=135
-LBRACE=136
-RBRACE=137
-SLASH=138
-LSQUARE=139
-RSQUARE=140
-SYSVARNAME=141
-EXCLAMATION=142
-LCURLY=143
-RCURLY=144
-CONSTANT_HEX_BYTE=145
-CONSTANT_HEX_LONG=146
-CONSTANT_HEX_LONG64=147
-CONSTANT_HEX_INT=148
-CONSTANT_HEX_I=149
-CONSTANT_HEX_ULONG=150
-CONSTANT_HEX_ULONG64=151
-CONSTANT_HEX_UI=152
-CONSTANT_HEX_UINT=153
-CONSTANT_BYTE=154
-CONSTANT_LONG=155
-CONSTANT_LONG64=156
-CONSTANT_INT=157
-CONSTANT_I=158
-CONSTANT_ULONG=159
-CONSTANT_ULONG64=160
-CONSTANT_UI=161
-CONSTANT_UINT=162
-CONSTANT_OCT_BYTE=163
-CONSTANT_OCT_LONG=164
-CONSTANT_OCT_LONG64=165
-CONSTANT_OCT_INT=166
-CONSTANT_OCT_I=167
-CONSTANT_OCT_ULONG=168
-CONSTANT_OCT_ULONG64=169
-CONSTANT_OCT_UI=170
-CONSTANT_OCT_UINT=171
-CONSTANT_FLOAT=172
-CONSTANT_DOUBLE=173
-CONSTANT_BIN_BYTE=174
-CONSTANT_BIN_LONG=175
-CONSTANT_BIN_LONG64=176
-CONSTANT_BIN_INT=177
-CONSTANT_BIN_I=178
-CONSTANT_BIN_ULONG=179
-CONSTANT_BIN_ULONG64=180
-CONSTANT_BIN_UI=181
-CONSTANT_BIN_UINT=182
-ASTERIX=183
-DOT=184
-STRING_LITERAL=185
-POW=186
-MATRIX_OP1=187
-MATRIX_OP2=188
-PLUS=189
-MINUS=190
-LTMARK=191
-GTMARK=192
-LOG_NEG=193
-LOG_AND=194
-LOG_OR=195
-QUESTION=196
-STRING=197
-INCLUDE=198
-EOL=199
-W=200
-D=201
-L=202
-H=203
-O=204
-B=205
-EXP=206
-DBL_E=207
-DBL=208
-CONSTANT_OR_STRING_LITERAL=209
-COMMENT=210
-END_MARKER=211
-WHITESPACE=212
-SKIP_LINES=213
-CONT_STATEMENT=214
-END_OF_LINE=215
+ASSIGN_ARRAYEXPR_MFCALL=8
+ARRAYDEF=9
+ARRAYDEF_CONST=10
+ARRAYIX=11
+ARRAYIX_ALL=12
+ARRAYIX_ORANGE=13
+ARRAYIX_RANGE=14
+ARRAYIX_ORANGE_S=15
+ARRAYIX_RANGE_S=16
+ARRAYEXPR=17
+ARRAYEXPR_FN=18
+ARRAYEXPR_MFCALL=19
+BLOCK=20
+BREAK=21
+CSBLOCK=22
+CONTINUE=23
+COMMONDECL=24
+COMMONDEF=25
+CONSTANT=26
+DEREF=27
+ELSEBLK=28
+EXPR=29
+FOR="for"=30
+FOR_STEP=31
+FOREACH="foreach"=32
+FOR_LOOP=33
+FOR_STEP_LOOP=34
+FOREACH_LOOP=35
+FCALL=36
+FCALL_LIB=37
+FCALL_LIB_RETNEW=38
+IF_ELSE=39
+KEYDECL=40
+KEYDEF=41
+KEYDEF_REF=42
+KEYDEF_REF_CHECK=43
+KEYDEF_REF_EXPR=44
+LABEL=45
+MPCALL=46
+MPCALL_PARENT=47
+MFCALL=48
+MFCALL_LIB=49
+MFCALL_LIB_RETNEW=50
+MFCALL_PARENT=51
+MFCALL_PARENT_LIB=52
+MFCALL_PARENT_LIB_RETNEW=53
+NOP=54
+NSTRUC=55
+NSTRUC_REF=56
+ON_IOERROR_NULL=57
+PCALL=58
+PCALL_LIB=59
+PARADECL=60
+PARAEXPR=61
+POSTDEC=62
+POSTINC=63
+DECSTATEMENT=64
+INCSTATEMENT=65
+REF=66
+REF_CHECK=67
+REF_EXPR=68
+REPEAT="repeat"=69
+REPEAT_LOOP=70
+RETURN=71
+RETF=72
+RETP=73
+STRUC=74
+SYSVAR=75
+UMINUS=76
+VAR=77
+VARPTR=78
+WHILE="while"=79
+IDENTIFIER=80
+AND_OP="and"=81
+BEGIN="begin"=82
+CASE="case"=83
+COMMON="common"=84
+COMPILE_OPT="compile_opt"=85
+DO="do"=86
+ELSE="else"=87
+END="end"=88
+ENDCASE="endcase"=89
+ENDELSE="endelse"=90
+ENDFOR="endfor"=91
+ENDFOREACH="endforeach"=92
+ENDIF="endif"=93
+ENDREP="endrep"=94
+ENDSWITCH="endswitch"=95
+ENDWHILE="endwhile"=96
+EQ_OP="eq"=97
+FORWARD="forward_function"=98
+FUNCTION="function"=99
+GE_OP="ge"=100
+GOTO="goto"=101
+GT_OP="gt"=102
+IF="if"=103
+INHERITS="inherits"=104
+LE_OP="le"=105
+LT_OP="lt"=106
+MOD_OP="mod"=107
+NE_OP="ne"=108
+NOT_OP="not"=109
+OF="of"=110
+ON_IOERROR="on_ioerror"=111
+OR_OP="or"=112
+PRO="pro"=113
+SWITCH="switch"=114
+THEN="then"=115
+UNTIL="until"=116
+XOR_OP="xor"=117
+METHOD=118
+COMMA=119
+COLON=120
+END_U=121
+EQUAL=122
+DEC=123
+INC=124
+AND_OP_EQ=125
+ASTERIX_EQ=126
+EQ_OP_EQ=127
+GE_OP_EQ=128
+GTMARK_EQ=129
+GT_OP_EQ=130
+LE_OP_EQ=131
+LTMARK_EQ=132
+LT_OP_EQ=133
+MATRIX_OP1_EQ=134
+MATRIX_OP2_EQ=135
+MINUS_EQ=136
+MOD_OP_EQ=137
+NE_OP_EQ=138
+OR_OP_EQ=139
+PLUS_EQ=140
+POW_EQ=141
+SLASH_EQ=142
+XOR_OP_EQ=143
+MEMBER=144
+LBRACE=145
+RBRACE=146
+SLASH=147
+LSQUARE=148
+RSQUARE=149
+SYSVARNAME=150
+EXCLAMATION=151
+LCURLY=152
+RCURLY=153
+CONSTANT_HEX_BYTE=154
+CONSTANT_HEX_LONG=155
+CONSTANT_HEX_LONG64=156
+CONSTANT_HEX_INT=157
+CONSTANT_HEX_I=158
+CONSTANT_HEX_ULONG=159
+CONSTANT_HEX_ULONG64=160
+CONSTANT_HEX_UI=161
+CONSTANT_HEX_UINT=162
+CONSTANT_BYTE=163
+CONSTANT_LONG=164
+CONSTANT_LONG64=165
+CONSTANT_INT=166
+CONSTANT_I=167
+CONSTANT_ULONG=168
+CONSTANT_ULONG64=169
+CONSTANT_UI=170
+CONSTANT_UINT=171
+CONSTANT_OCT_BYTE=172
+CONSTANT_OCT_LONG=173
+CONSTANT_OCT_LONG64=174
+CONSTANT_OCT_INT=175
+CONSTANT_OCT_I=176
+CONSTANT_OCT_ULONG=177
+CONSTANT_OCT_ULONG64=178
+CONSTANT_OCT_UI=179
+CONSTANT_OCT_UINT=180
+CONSTANT_FLOAT=181
+CONSTANT_DOUBLE=182
+CONSTANT_BIN_BYTE=183
+CONSTANT_BIN_LONG=184
+CONSTANT_BIN_LONG64=185
+CONSTANT_BIN_INT=186
+CONSTANT_BIN_I=187
+CONSTANT_BIN_ULONG=188
+CONSTANT_BIN_ULONG64=189
+CONSTANT_BIN_UI=190
+CONSTANT_BIN_UINT=191
+ASTERIX=192
+DOT=193
+STRING_LITERAL=194
+POW=195
+MATRIX_OP1=196
+MATRIX_OP2=197
+PLUS=198
+MINUS=199
+LTMARK=200
+GTMARK=201
+LOG_NEG=202
+LOG_AND=203
+LOG_OR=204
+QUESTION=205
+STRING=206
+INCLUDE=207
+EOL=208
+W=209
+D=210
+L=211
+H=212
+O=213
+B=214
+EXP=215
+DBL_E=216
+DBL=217
+CONSTANT_OR_STRING_LITERAL=218
+COMMENT=219
+END_MARKER=220
+WHITESPACE=221
+SKIP_LINES=222
+CONT_STATEMENT=223
+END_OF_LINE=224
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/GDLTreeParser.cpp cvs/gdl/src/GDLTreeParser.cpp
--- gdl-0.9rc4/src/GDLTreeParser.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/GDLTreeParser.cpp	2010-04-22 09:50:40.000000000 -0600
@@ -103,20 +103,21 @@
 		case CONTINUE:
 		case COMMONDECL:
 		case COMMONDEF:
+		case FOR:
+		case FOREACH:
 		case MPCALL:
 		case MPCALL_PARENT:
 		case PCALL:
+		case REPEAT:
 		case RETURN:
+		case WHILE:
 		case IDENTIFIER:
 		case CASE:
-		case FOR:
 		case FORWARD:
 		case GOTO:
 		case IF:
 		case ON_IOERROR:
-		case REPEAT:
 		case SWITCH:
-		case WHILE:
 		case DEC:
 		case INC:
 		case AND_OP_EQ:
@@ -254,21 +255,22 @@
 	case CONTINUE:
 	case COMMONDECL:
 	case COMMONDEF:
+	case FOR:
+	case FOREACH:
 	case MPCALL:
 	case MPCALL_PARENT:
 	case PCALL:
 	case PARADECL:
+	case REPEAT:
 	case RETURN:
+	case WHILE:
 	case IDENTIFIER:
 	case CASE:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case DEC:
 	case INC:
 	case AND_OP_EQ:
@@ -319,20 +321,21 @@
 	case CONTINUE:
 	case COMMONDECL:
 	case COMMONDEF:
+	case FOR:
+	case FOREACH:
 	case MPCALL:
 	case MPCALL_PARENT:
 	case PCALL:
+	case REPEAT:
 	case RETURN:
+	case WHILE:
 	case IDENTIFIER:
 	case CASE:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case DEC:
 	case INC:
 	case AND_OP_EQ:
@@ -373,20 +376,21 @@
 	case CONTINUE:
 	case COMMONDECL:
 	case COMMONDEF:
+	case FOR:
+	case FOREACH:
 	case MPCALL:
 	case MPCALL_PARENT:
 	case PCALL:
+	case REPEAT:
 	case RETURN:
+	case WHILE:
 	case IDENTIFIER:
 	case CASE:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case DEC:
 	case INC:
 	case AND_OP_EQ:
@@ -491,21 +495,22 @@
 	case CONTINUE:
 	case COMMONDECL:
 	case COMMONDEF:
+	case FOR:
+	case FOREACH:
 	case MPCALL:
 	case MPCALL_PARENT:
 	case PCALL:
 	case PARADECL:
+	case REPEAT:
 	case RETURN:
+	case WHILE:
 	case IDENTIFIER:
 	case CASE:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case DEC:
 	case INC:
 	case AND_OP_EQ:
@@ -556,20 +561,21 @@
 	case CONTINUE:
 	case COMMONDECL:
 	case COMMONDEF:
+	case FOR:
+	case FOREACH:
 	case MPCALL:
 	case MPCALL_PARENT:
 	case PCALL:
+	case REPEAT:
 	case RETURN:
+	case WHILE:
 	case IDENTIFIER:
 	case CASE:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case DEC:
 	case INC:
 	case AND_OP_EQ:
@@ -610,20 +616,21 @@
 	case CONTINUE:
 	case COMMONDECL:
 	case COMMONDEF:
+	case FOR:
+	case FOREACH:
 	case MPCALL:
 	case MPCALL_PARENT:
 	case PCALL:
+	case REPEAT:
 	case RETURN:
+	case WHILE:
 	case IDENTIFIER:
 	case CASE:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case DEC:
 	case INC:
 	case AND_OP_EQ:
@@ -825,7 +832,7 @@
 	RefDNode statement_list_AST = RefDNode(antlr::nullAST);
 	
 	{ // ( ... )+
-	int _cnt54=0;
+	int _cnt57=0;
 	for (;;) {
 		if (_t == RefDNode(antlr::nullAST) )
 			_t = ASTNULL;
@@ -836,19 +843,20 @@
 		case CONTINUE:
 		case COMMONDECL:
 		case COMMONDEF:
+		case FOR:
+		case FOREACH:
 		case MPCALL:
 		case MPCALL_PARENT:
 		case PCALL:
+		case REPEAT:
 		case RETURN:
+		case WHILE:
 		case CASE:
-		case FOR:
 		case FORWARD:
 		case GOTO:
 		case IF:
 		case ON_IOERROR:
-		case REPEAT:
 		case SWITCH:
-		case WHILE:
 		case DEC:
 		case INC:
 		case AND_OP_EQ:
@@ -885,12 +893,12 @@
 		}
 		default:
 		{
-			if ( _cnt54>=1 ) { goto _loop54; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+			if ( _cnt57>=1 ) { goto _loop57; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 		}
 		}
-		_cnt54++;
+		_cnt57++;
 	}
-	_loop54:;
+	_loop57:;
 	}  // ( ... )+
 	statement_list_AST = RefDNode(currentAST.root);
 	returnAST = statement_list_AST;
@@ -1007,6 +1015,14 @@
 		statement_AST = RefDNode(currentAST.root);
 		break;
 	}
+	case FOREACH:
+	{
+		foreach_statement(_t);
+		_t = _retTree;
+		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		statement_AST = RefDNode(currentAST.root);
+		break;
+	}
 	case REPEAT:
 	{
 		repeat_statement(_t);
@@ -1084,13 +1100,13 @@
 	}
 	case DEC:
 	{
-		RefDNode __t56 = _t;
+		RefDNode __t59 = _t;
 		RefDNode tmp6_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp6_AST_in = RefDNode(antlr::nullAST);
 		tmp6_AST = astFactory->create(antlr::RefAST(_t));
 		tmp6_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp6_AST));
-		antlr::ASTPair __currentAST56 = currentAST;
+		antlr::ASTPair __currentAST59 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),DEC);
@@ -1098,21 +1114,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST56;
-		_t = __t56;
+		currentAST = __currentAST59;
+		_t = __t59;
 		_t = _t->getNextSibling();
 		statement_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case INC:
 	{
-		RefDNode __t57 = _t;
+		RefDNode __t60 = _t;
 		RefDNode tmp7_AST = RefDNode(antlr::nullAST);
 		RefDNode tmp7_AST_in = RefDNode(antlr::nullAST);
 		tmp7_AST = astFactory->create(antlr::RefAST(_t));
 		tmp7_AST_in = _t;
 		astFactory->addASTChild(currentAST, antlr::RefAST(tmp7_AST));
-		antlr::ASTPair __currentAST57 = currentAST;
+		antlr::ASTPair __currentAST60 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),INC);
@@ -1120,8 +1136,8 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST57;
-		_t = __t57;
+		currentAST = __currentAST60;
+		_t = __t60;
 		_t = _t->getNextSibling();
 		statement_AST = RefDNode(currentAST.root);
 		break;
@@ -1262,6 +1278,8 @@
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
 	RefDNode caseswitch_body_AST = RefDNode(antlr::nullAST);
+	RefDNode b = RefDNode(antlr::nullAST);
+	RefDNode b_AST = RefDNode(antlr::nullAST);
 	
 	if (_t == RefDNode(antlr::nullAST) )
 		_t = ASTNULL;
@@ -1269,16 +1287,16 @@
 	case BLOCK:
 	{
 		RefDNode __t34 = _t;
-		RefDNode tmp12_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp12_AST_in = RefDNode(antlr::nullAST);
-		tmp12_AST = astFactory->create(antlr::RefAST(_t));
-		tmp12_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp12_AST));
+		b = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
+		RefDNode b_AST_in = RefDNode(antlr::nullAST);
+		b_AST = astFactory->create(antlr::RefAST(b));
+		astFactory->addASTChild(currentAST, antlr::RefAST(b_AST));
 		antlr::ASTPair __currentAST34 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),BLOCK);
 		_t = _t->getFirstChild();
+		b_AST->setType(CSBLOCK);b_AST->setText("csblock");
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
@@ -1292,20 +1310,21 @@
 		case CONTINUE:
 		case COMMONDECL:
 		case COMMONDEF:
+		case FOR:
+		case FOREACH:
 		case MPCALL:
 		case MPCALL_PARENT:
 		case PCALL:
+		case REPEAT:
 		case RETURN:
+		case WHILE:
 		case IDENTIFIER:
 		case CASE:
-		case FOR:
 		case FORWARD:
 		case GOTO:
 		case IF:
 		case ON_IOERROR:
-		case REPEAT:
 		case SWITCH:
-		case WHILE:
 		case DEC:
 		case INC:
 		case AND_OP_EQ:
@@ -1352,11 +1371,11 @@
 	case ELSEBLK:
 	{
 		RefDNode __t36 = _t;
-		RefDNode tmp13_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp13_AST_in = RefDNode(antlr::nullAST);
-		tmp13_AST = astFactory->create(antlr::RefAST(_t));
-		tmp13_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp13_AST));
+		RefDNode tmp12_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp12_AST_in = RefDNode(antlr::nullAST);
+		tmp12_AST = astFactory->create(antlr::RefAST(_t));
+		tmp12_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp12_AST));
 		antlr::ASTPair __currentAST36 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
@@ -1372,20 +1391,21 @@
 		case CONTINUE:
 		case COMMONDECL:
 		case COMMONDEF:
+		case FOR:
+		case FOREACH:
 		case MPCALL:
 		case MPCALL_PARENT:
 		case PCALL:
+		case REPEAT:
 		case RETURN:
+		case WHILE:
 		case IDENTIFIER:
 		case CASE:
-		case FOR:
 		case FORWARD:
 		case GOTO:
 		case IF:
 		case ON_IOERROR:
-		case REPEAT:
 		case SWITCH:
-		case WHILE:
 		case DEC:
 		case INC:
 		case AND_OP_EQ:
@@ -1460,13 +1480,13 @@
 	}
 	case DOT:
 	{
-		RefDNode __t199 = _t;
-		RefDNode tmp14_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp14_AST_in = RefDNode(antlr::nullAST);
-		tmp14_AST = astFactory->create(antlr::RefAST(_t));
-		tmp14_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp14_AST));
-		antlr::ASTPair __currentAST199 = currentAST;
+		RefDNode __t206 = _t;
+		RefDNode tmp13_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp13_AST_in = RefDNode(antlr::nullAST);
+		tmp13_AST = astFactory->create(antlr::RefAST(_t));
+		tmp13_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp13_AST));
+		antlr::ASTPair __currentAST206 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),DOT);
@@ -1475,7 +1495,7 @@
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 		{ // ( ... )+
-		int _cnt201=0;
+		int _cnt208=0;
 		for (;;) {
 			if (_t == RefDNode(antlr::nullAST) )
 				_t = ASTNULL;
@@ -1485,28 +1505,28 @@
 				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 			}
 			else {
-				if ( _cnt201>=1 ) { goto _loop201; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+				if ( _cnt208>=1 ) { goto _loop208; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 			}
 			
-			_cnt201++;
+			_cnt208++;
 		}
-		_loop201:;
+		_loop208:;
 		}  // ( ... )+
-		currentAST = __currentAST199;
-		_t = __t199;
+		currentAST = __currentAST206;
+		_t = __t206;
 		_t = _t->getNextSibling();
 		expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case DEREF:
 	{
-		RefDNode __t202 = _t;
-		RefDNode tmp15_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp15_AST_in = RefDNode(antlr::nullAST);
-		tmp15_AST = astFactory->create(antlr::RefAST(_t));
-		tmp15_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp15_AST));
-		antlr::ASTPair __currentAST202 = currentAST;
+		RefDNode __t209 = _t;
+		RefDNode tmp14_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp14_AST_in = RefDNode(antlr::nullAST);
+		tmp14_AST = astFactory->create(antlr::RefAST(_t));
+		tmp14_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp14_AST));
+		antlr::ASTPair __currentAST209 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),DEREF);
@@ -1514,8 +1534,8 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST202;
-		_t = __t202;
+		currentAST = __currentAST209;
+		_t = __t209;
 		_t = _t->getNextSibling();
 		expr_AST = RefDNode(currentAST.root);
 		break;
@@ -1524,6 +1544,7 @@
 	case ARRAYDEF:
 	case ARRAYDEF_CONST:
 	case ARRAYEXPR_FN:
+	case ARRAYEXPR_MFCALL:
 	case CONSTANT:
 	case FCALL:
 	case MFCALL:
@@ -1701,13 +1722,17 @@
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
 	RefDNode block_AST = RefDNode(antlr::nullAST);
+	RefDNode b = RefDNode(antlr::nullAST);
+	RefDNode b_AST = RefDNode(antlr::nullAST);
+	
+	//    int labelStart = comp.NDefLabel();
+	
 	
 	RefDNode __t47 = _t;
-	RefDNode tmp16_AST = RefDNode(antlr::nullAST);
-	RefDNode tmp16_AST_in = RefDNode(antlr::nullAST);
-	tmp16_AST = astFactory->create(antlr::RefAST(_t));
-	tmp16_AST_in = _t;
-	astFactory->addASTChild(currentAST, antlr::RefAST(tmp16_AST));
+	b = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
+	RefDNode b_AST_in = RefDNode(antlr::nullAST);
+	b_AST = astFactory->create(antlr::RefAST(b));
+	astFactory->addASTChild(currentAST, antlr::RefAST(b_AST));
 	antlr::ASTPair __currentAST47 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
@@ -1723,20 +1748,21 @@
 	case CONTINUE:
 	case COMMONDECL:
 	case COMMONDEF:
+	case FOR:
+	case FOREACH:
 	case MPCALL:
 	case MPCALL_PARENT:
 	case PCALL:
+	case REPEAT:
 	case RETURN:
+	case WHILE:
 	case IDENTIFIER:
 	case CASE:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case DEC:
 	case INC:
 	case AND_OP_EQ:
@@ -1777,6 +1803,9 @@
 	currentAST = __currentAST47;
 	_t = __t47;
 	_t = _t->getNextSibling();
+	
+	//            #b->SetLabelRange( labelStart, comp.NDefLabel());
+	
 	block_AST = RefDNode(currentAST.root);
 	returnAST = block_AST;
 	_retTree = _t;
@@ -1787,14 +1816,15 @@
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
 	RefDNode unblock_AST = RefDNode(antlr::nullAST);
+	RefDNode b = RefDNode(antlr::nullAST);
+	RefDNode b_AST = RefDNode(antlr::nullAST);
 	RefDNode s_AST = RefDNode(antlr::nullAST);
 	RefDNode s = RefDNode(antlr::nullAST);
 	
 	RefDNode __t50 = _t;
-	RefDNode tmp17_AST = RefDNode(antlr::nullAST);
-	RefDNode tmp17_AST_in = RefDNode(antlr::nullAST);
-	tmp17_AST = astFactory->create(antlr::RefAST(_t));
-	tmp17_AST_in = _t;
+	b = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
+	RefDNode b_AST_in = RefDNode(antlr::nullAST);
+	b_AST = astFactory->create(antlr::RefAST(b));
 	antlr::ASTPair __currentAST50 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
@@ -1810,20 +1840,21 @@
 	case CONTINUE:
 	case COMMONDECL:
 	case COMMONDEF:
+	case FOR:
+	case FOREACH:
 	case MPCALL:
 	case MPCALL_PARENT:
 	case PCALL:
+	case REPEAT:
 	case RETURN:
+	case WHILE:
 	case IDENTIFIER:
 	case CASE:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case DEC:
 	case INC:
 	case AND_OP_EQ:
@@ -1863,6 +1894,15 @@
 	}
 	case 3:
 	{
+		unblock_AST = RefDNode(currentAST.root);
+		unblock_AST = b_AST;
+		currentAST.root = unblock_AST;
+		if ( unblock_AST!=RefDNode(antlr::nullAST) &&
+			unblock_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+			  currentAST.child = unblock_AST->getFirstChild();
+		else
+			currentAST.child = unblock_AST;
+		currentAST.advanceChildToEnd();
 		break;
 	}
 	default:
@@ -1878,6 +1918,104 @@
 	_retTree = _t;
 }
 
+void GDLTreeParser::unblock_empty(RefDNode _t) {
+	RefDNode unblock_empty_AST_in = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
+	returnAST = RefDNode(antlr::nullAST);
+	antlr::ASTPair currentAST;
+	RefDNode unblock_empty_AST = RefDNode(antlr::nullAST);
+	RefDNode b = RefDNode(antlr::nullAST);
+	RefDNode b_AST = RefDNode(antlr::nullAST);
+	RefDNode s_AST = RefDNode(antlr::nullAST);
+	RefDNode s = RefDNode(antlr::nullAST);
+	
+	RefDNode __t53 = _t;
+	b = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
+	RefDNode b_AST_in = RefDNode(antlr::nullAST);
+	b_AST = astFactory->create(antlr::RefAST(b));
+	antlr::ASTPair __currentAST53 = currentAST;
+	currentAST.root = currentAST.child;
+	currentAST.child = RefDNode(antlr::nullAST);
+	match(antlr::RefAST(_t),BLOCK);
+	_t = _t->getFirstChild();
+	{
+	if (_t == RefDNode(antlr::nullAST) )
+		_t = ASTNULL;
+	switch ( _t->getType()) {
+	case ASSIGN:
+	case BLOCK:
+	case BREAK:
+	case CONTINUE:
+	case COMMONDECL:
+	case COMMONDEF:
+	case FOR:
+	case FOREACH:
+	case MPCALL:
+	case MPCALL_PARENT:
+	case PCALL:
+	case REPEAT:
+	case RETURN:
+	case WHILE:
+	case IDENTIFIER:
+	case CASE:
+	case FORWARD:
+	case GOTO:
+	case IF:
+	case ON_IOERROR:
+	case SWITCH:
+	case DEC:
+	case INC:
+	case AND_OP_EQ:
+	case ASTERIX_EQ:
+	case EQ_OP_EQ:
+	case GE_OP_EQ:
+	case GTMARK_EQ:
+	case GT_OP_EQ:
+	case LE_OP_EQ:
+	case LTMARK_EQ:
+	case LT_OP_EQ:
+	case MATRIX_OP1_EQ:
+	case MATRIX_OP2_EQ:
+	case MINUS_EQ:
+	case MOD_OP_EQ:
+	case NE_OP_EQ:
+	case OR_OP_EQ:
+	case PLUS_EQ:
+	case POW_EQ:
+	case SLASH_EQ:
+	case XOR_OP_EQ:
+	{
+		s = (_t == ASTNULL) ? RefDNode(antlr::nullAST) : _t;
+		statement_list(_t);
+		_t = _retTree;
+		s_AST = returnAST;
+		unblock_empty_AST = RefDNode(currentAST.root);
+		unblock_empty_AST = s_AST;
+		currentAST.root = unblock_empty_AST;
+		if ( unblock_empty_AST!=RefDNode(antlr::nullAST) &&
+			unblock_empty_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+			  currentAST.child = unblock_empty_AST->getFirstChild();
+		else
+			currentAST.child = unblock_empty_AST;
+		currentAST.advanceChildToEnd();
+		break;
+	}
+	case 3:
+	{
+		break;
+	}
+	default:
+	{
+		throw antlr::NoViableAltException(antlr::RefAST(_t));
+	}
+	}
+	}
+	currentAST = __currentAST53;
+	_t = __t53;
+	_t = _t->getNextSibling();
+	returnAST = unblock_empty_AST;
+	_retTree = _t;
+}
+
 void GDLTreeParser::label(RefDNode _t) {
 	RefDNode label_AST_in = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	returnAST = RefDNode(antlr::nullAST);
@@ -1886,23 +2024,23 @@
 	RefDNode i = RefDNode(antlr::nullAST);
 	RefDNode i_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode __t66 = _t;
+	RefDNode __t71 = _t;
 	i = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode i_AST_in = RefDNode(antlr::nullAST);
 	i_AST = astFactory->create(antlr::RefAST(i));
-	antlr::ASTPair __currentAST66 = currentAST;
+	antlr::ASTPair __currentAST71 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),IDENTIFIER);
 	_t = _t->getFirstChild();
-	RefDNode tmp18_AST = RefDNode(antlr::nullAST);
-	RefDNode tmp18_AST_in = RefDNode(antlr::nullAST);
-	tmp18_AST = astFactory->create(antlr::RefAST(_t));
-	tmp18_AST_in = _t;
+	RefDNode tmp15_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp15_AST_in = RefDNode(antlr::nullAST);
+	tmp15_AST = astFactory->create(antlr::RefAST(_t));
+	tmp15_AST_in = _t;
 	match(antlr::RefAST(_t),COLON);
 	_t = _t->getNextSibling();
-	currentAST = __currentAST66;
-	_t = __t66;
+	currentAST = __currentAST71;
+	_t = __t71;
 	_t = _t->getNextSibling();
 	label_AST = RefDNode(currentAST.root);
 	
@@ -1933,11 +2071,11 @@
 	RefDNode r_AST = RefDNode(antlr::nullAST);
 	RefDNode r = RefDNode(antlr::nullAST);
 	
-	RefDNode __t116 = _t;
+	RefDNode __t121 = _t;
 	a = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode a_AST_in = RefDNode(antlr::nullAST);
 	a_AST = astFactory->create(antlr::RefAST(a));
-	antlr::ASTPair __currentAST116 = currentAST;
+	antlr::ASTPair __currentAST121 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),ASSIGN);
@@ -1950,8 +2088,8 @@
 	expr(_t);
 	_t = _retTree;
 	r_AST = returnAST;
-	currentAST = __currentAST116;
-	_t = __t116;
+	currentAST = __currentAST121;
+	_t = __t121;
 	_t = _t->getNextSibling();
 	assign_expr_statement_AST = RefDNode(currentAST.root);
 	
@@ -2108,11 +2246,11 @@
 	switch ( _t->getType()) {
 	case AND_OP_EQ:
 	{
-		RefDNode __t119 = _t;
+		RefDNode __t124 = _t;
 		a1 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a1_AST_in = RefDNode(antlr::nullAST);
 		a1_AST = astFactory->create(antlr::RefAST(a1));
-		antlr::ASTPair __currentAST119 = currentAST;
+		antlr::ASTPair __currentAST124 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),AND_OP_EQ);
@@ -2125,8 +2263,8 @@
 		expr(_t);
 		_t = _retTree;
 		r1_AST = returnAST;
-		currentAST = __currentAST119;
-		_t = __t119;
+		currentAST = __currentAST124;
+		_t = __t124;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l1_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(AND_OP,"and")))->add(antlr::RefAST(l1_AST))->add(antlr::RefAST(r1_AST))))))->add(antlr::RefAST(RemoveNextSibling(l1_AST)))));
@@ -2141,11 +2279,11 @@
 	}
 	case ASTERIX_EQ:
 	{
-		RefDNode __t120 = _t;
+		RefDNode __t125 = _t;
 		a2 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a2_AST_in = RefDNode(antlr::nullAST);
 		a2_AST = astFactory->create(antlr::RefAST(a2));
-		antlr::ASTPair __currentAST120 = currentAST;
+		antlr::ASTPair __currentAST125 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ASTERIX_EQ);
@@ -2158,8 +2296,8 @@
 		expr(_t);
 		_t = _retTree;
 		r2_AST = returnAST;
-		currentAST = __currentAST120;
-		_t = __t120;
+		currentAST = __currentAST125;
+		_t = __t125;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l2_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASTERIX,"*")))->add(antlr::RefAST(l2_AST))->add(antlr::RefAST(r2_AST))))))->add(antlr::RefAST(RemoveNextSibling(l2_AST)))));
@@ -2174,11 +2312,11 @@
 	}
 	case EQ_OP_EQ:
 	{
-		RefDNode __t121 = _t;
+		RefDNode __t126 = _t;
 		a3 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a3_AST_in = RefDNode(antlr::nullAST);
 		a3_AST = astFactory->create(antlr::RefAST(a3));
-		antlr::ASTPair __currentAST121 = currentAST;
+		antlr::ASTPair __currentAST126 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),EQ_OP_EQ);
@@ -2191,8 +2329,8 @@
 		expr(_t);
 		_t = _retTree;
 		r3_AST = returnAST;
-		currentAST = __currentAST121;
-		_t = __t121;
+		currentAST = __currentAST126;
+		_t = __t126;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l3_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(EQ_OP,"eq")))->add(antlr::RefAST(l3_AST))->add(antlr::RefAST(r3_AST))))))->add(antlr::RefAST(RemoveNextSibling(l3_AST)))));
@@ -2207,11 +2345,11 @@
 	}
 	case GE_OP_EQ:
 	{
-		RefDNode __t122 = _t;
+		RefDNode __t127 = _t;
 		a4 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a4_AST_in = RefDNode(antlr::nullAST);
 		a4_AST = astFactory->create(antlr::RefAST(a4));
-		antlr::ASTPair __currentAST122 = currentAST;
+		antlr::ASTPair __currentAST127 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),GE_OP_EQ);
@@ -2224,8 +2362,8 @@
 		expr(_t);
 		_t = _retTree;
 		r4_AST = returnAST;
-		currentAST = __currentAST122;
-		_t = __t122;
+		currentAST = __currentAST127;
+		_t = __t127;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l4_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(GE_OP,"ge")))->add(antlr::RefAST(l4_AST))->add(antlr::RefAST(r4_AST))))))->add(antlr::RefAST(RemoveNextSibling(l4_AST)))));
@@ -2240,11 +2378,11 @@
 	}
 	case GTMARK_EQ:
 	{
-		RefDNode __t123 = _t;
+		RefDNode __t128 = _t;
 		a5 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a5_AST_in = RefDNode(antlr::nullAST);
 		a5_AST = astFactory->create(antlr::RefAST(a5));
-		antlr::ASTPair __currentAST123 = currentAST;
+		antlr::ASTPair __currentAST128 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),GTMARK_EQ);
@@ -2257,8 +2395,8 @@
 		expr(_t);
 		_t = _retTree;
 		r5_AST = returnAST;
-		currentAST = __currentAST123;
-		_t = __t123;
+		currentAST = __currentAST128;
+		_t = __t128;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l5_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(GTMARK,">")))->add(antlr::RefAST(l5_AST))->add(antlr::RefAST(r5_AST))))))->add(antlr::RefAST(RemoveNextSibling(l5_AST)))));
@@ -2273,11 +2411,11 @@
 	}
 	case GT_OP_EQ:
 	{
-		RefDNode __t124 = _t;
+		RefDNode __t129 = _t;
 		a6 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a6_AST_in = RefDNode(antlr::nullAST);
 		a6_AST = astFactory->create(antlr::RefAST(a6));
-		antlr::ASTPair __currentAST124 = currentAST;
+		antlr::ASTPair __currentAST129 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),GT_OP_EQ);
@@ -2290,8 +2428,8 @@
 		expr(_t);
 		_t = _retTree;
 		r6_AST = returnAST;
-		currentAST = __currentAST124;
-		_t = __t124;
+		currentAST = __currentAST129;
+		_t = __t129;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l6_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(GT_OP,"gt")))->add(antlr::RefAST(l6_AST))->add(antlr::RefAST(r6_AST))))))->add(antlr::RefAST(RemoveNextSibling(l6_AST)))));
@@ -2306,11 +2444,11 @@
 	}
 	case LE_OP_EQ:
 	{
-		RefDNode __t125 = _t;
+		RefDNode __t130 = _t;
 		a7 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a7_AST_in = RefDNode(antlr::nullAST);
 		a7_AST = astFactory->create(antlr::RefAST(a7));
-		antlr::ASTPair __currentAST125 = currentAST;
+		antlr::ASTPair __currentAST130 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LE_OP_EQ);
@@ -2323,8 +2461,8 @@
 		expr(_t);
 		_t = _retTree;
 		r7_AST = returnAST;
-		currentAST = __currentAST125;
-		_t = __t125;
+		currentAST = __currentAST130;
+		_t = __t130;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l7_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(LE_OP,"le")))->add(antlr::RefAST(l7_AST))->add(antlr::RefAST(r7_AST))))))->add(antlr::RefAST(RemoveNextSibling(l7_AST)))));
@@ -2339,11 +2477,11 @@
 	}
 	case LTMARK_EQ:
 	{
-		RefDNode __t126 = _t;
+		RefDNode __t131 = _t;
 		a8 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a8_AST_in = RefDNode(antlr::nullAST);
 		a8_AST = astFactory->create(antlr::RefAST(a8));
-		antlr::ASTPair __currentAST126 = currentAST;
+		antlr::ASTPair __currentAST131 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LTMARK_EQ);
@@ -2356,8 +2494,8 @@
 		expr(_t);
 		_t = _retTree;
 		r8_AST = returnAST;
-		currentAST = __currentAST126;
-		_t = __t126;
+		currentAST = __currentAST131;
+		_t = __t131;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l8_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(LTMARK,"<")))->add(antlr::RefAST(l8_AST))->add(antlr::RefAST(r8_AST))))))->add(antlr::RefAST(RemoveNextSibling(l8_AST)))));
@@ -2372,11 +2510,11 @@
 	}
 	case LT_OP_EQ:
 	{
-		RefDNode __t127 = _t;
+		RefDNode __t132 = _t;
 		a9 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a9_AST_in = RefDNode(antlr::nullAST);
 		a9_AST = astFactory->create(antlr::RefAST(a9));
-		antlr::ASTPair __currentAST127 = currentAST;
+		antlr::ASTPair __currentAST132 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LT_OP_EQ);
@@ -2389,8 +2527,8 @@
 		expr(_t);
 		_t = _retTree;
 		r9_AST = returnAST;
-		currentAST = __currentAST127;
-		_t = __t127;
+		currentAST = __currentAST132;
+		_t = __t132;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l9_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(LT_OP,"lt")))->add(antlr::RefAST(l9_AST))->add(antlr::RefAST(r9_AST))))))->add(antlr::RefAST(RemoveNextSibling(l9_AST)))));
@@ -2405,11 +2543,11 @@
 	}
 	case MATRIX_OP1_EQ:
 	{
-		RefDNode __t128 = _t;
+		RefDNode __t133 = _t;
 		a10 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a10_AST_in = RefDNode(antlr::nullAST);
 		a10_AST = astFactory->create(antlr::RefAST(a10));
-		antlr::ASTPair __currentAST128 = currentAST;
+		antlr::ASTPair __currentAST133 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MATRIX_OP1_EQ);
@@ -2422,8 +2560,8 @@
 		expr(_t);
 		_t = _retTree;
 		r10_AST = returnAST;
-		currentAST = __currentAST128;
-		_t = __t128;
+		currentAST = __currentAST133;
+		_t = __t133;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l10_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(MATRIX_OP1,"#")))->add(antlr::RefAST(l10_AST))->add(antlr::RefAST(r10_AST))))))->add(antlr::RefAST(RemoveNextSibling(l10_AST)))));
@@ -2438,11 +2576,11 @@
 	}
 	case MATRIX_OP2_EQ:
 	{
-		RefDNode __t129 = _t;
+		RefDNode __t134 = _t;
 		a11 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a11_AST_in = RefDNode(antlr::nullAST);
 		a11_AST = astFactory->create(antlr::RefAST(a11));
-		antlr::ASTPair __currentAST129 = currentAST;
+		antlr::ASTPair __currentAST134 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MATRIX_OP2_EQ);
@@ -2455,8 +2593,8 @@
 		expr(_t);
 		_t = _retTree;
 		r11_AST = returnAST;
-		currentAST = __currentAST129;
-		_t = __t129;
+		currentAST = __currentAST134;
+		_t = __t134;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l11_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(MATRIX_OP2,"##")))->add(antlr::RefAST(l11_AST))->add(antlr::RefAST(r11_AST))))))->add(antlr::RefAST(RemoveNextSibling(l11_AST)))));
@@ -2471,11 +2609,11 @@
 	}
 	case MINUS_EQ:
 	{
-		RefDNode __t130 = _t;
+		RefDNode __t135 = _t;
 		a12 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a12_AST_in = RefDNode(antlr::nullAST);
 		a12_AST = astFactory->create(antlr::RefAST(a12));
-		antlr::ASTPair __currentAST130 = currentAST;
+		antlr::ASTPair __currentAST135 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MINUS_EQ);
@@ -2488,8 +2626,8 @@
 		expr(_t);
 		_t = _retTree;
 		r12_AST = returnAST;
-		currentAST = __currentAST130;
-		_t = __t130;
+		currentAST = __currentAST135;
+		_t = __t135;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l12_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(MINUS,"-")))->add(antlr::RefAST(l12_AST))->add(antlr::RefAST(r12_AST))))))->add(antlr::RefAST(RemoveNextSibling(l12_AST)))));
@@ -2504,11 +2642,11 @@
 	}
 	case MOD_OP_EQ:
 	{
-		RefDNode __t131 = _t;
+		RefDNode __t136 = _t;
 		a13 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a13_AST_in = RefDNode(antlr::nullAST);
 		a13_AST = astFactory->create(antlr::RefAST(a13));
-		antlr::ASTPair __currentAST131 = currentAST;
+		antlr::ASTPair __currentAST136 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MOD_OP_EQ);
@@ -2521,8 +2659,8 @@
 		expr(_t);
 		_t = _retTree;
 		r13_AST = returnAST;
-		currentAST = __currentAST131;
-		_t = __t131;
+		currentAST = __currentAST136;
+		_t = __t136;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l13_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(MOD_OP,"mod")))->add(antlr::RefAST(l13_AST))->add(antlr::RefAST(r13_AST))))))->add(antlr::RefAST(RemoveNextSibling(l13_AST)))));
@@ -2537,11 +2675,11 @@
 	}
 	case NE_OP_EQ:
 	{
-		RefDNode __t132 = _t;
+		RefDNode __t137 = _t;
 		a14 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a14_AST_in = RefDNode(antlr::nullAST);
 		a14_AST = astFactory->create(antlr::RefAST(a14));
-		antlr::ASTPair __currentAST132 = currentAST;
+		antlr::ASTPair __currentAST137 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),NE_OP_EQ);
@@ -2554,8 +2692,8 @@
 		expr(_t);
 		_t = _retTree;
 		r14_AST = returnAST;
-		currentAST = __currentAST132;
-		_t = __t132;
+		currentAST = __currentAST137;
+		_t = __t137;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l14_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(NE_OP,"ne")))->add(antlr::RefAST(l14_AST))->add(antlr::RefAST(r14_AST))))))->add(antlr::RefAST(RemoveNextSibling(l14_AST)))));
@@ -2570,11 +2708,11 @@
 	}
 	case OR_OP_EQ:
 	{
-		RefDNode __t133 = _t;
+		RefDNode __t138 = _t;
 		a15 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a15_AST_in = RefDNode(antlr::nullAST);
 		a15_AST = astFactory->create(antlr::RefAST(a15));
-		antlr::ASTPair __currentAST133 = currentAST;
+		antlr::ASTPair __currentAST138 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),OR_OP_EQ);
@@ -2587,8 +2725,8 @@
 		expr(_t);
 		_t = _retTree;
 		r15_AST = returnAST;
-		currentAST = __currentAST133;
-		_t = __t133;
+		currentAST = __currentAST138;
+		_t = __t138;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l15_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(OR_OP,"or")))->add(antlr::RefAST(l15_AST))->add(antlr::RefAST(r15_AST))))))->add(antlr::RefAST(RemoveNextSibling(l15_AST)))));
@@ -2603,11 +2741,11 @@
 	}
 	case PLUS_EQ:
 	{
-		RefDNode __t134 = _t;
+		RefDNode __t139 = _t;
 		a16 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a16_AST_in = RefDNode(antlr::nullAST);
 		a16_AST = astFactory->create(antlr::RefAST(a16));
-		antlr::ASTPair __currentAST134 = currentAST;
+		antlr::ASTPair __currentAST139 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),PLUS_EQ);
@@ -2620,8 +2758,8 @@
 		expr(_t);
 		_t = _retTree;
 		r16_AST = returnAST;
-		currentAST = __currentAST134;
-		_t = __t134;
+		currentAST = __currentAST139;
+		_t = __t139;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l16_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(PLUS,"+")))->add(antlr::RefAST(l16_AST))->add(antlr::RefAST(r16_AST))))))->add(antlr::RefAST(RemoveNextSibling(l16_AST)))));
@@ -2636,11 +2774,11 @@
 	}
 	case POW_EQ:
 	{
-		RefDNode __t135 = _t;
+		RefDNode __t140 = _t;
 		a17 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a17_AST_in = RefDNode(antlr::nullAST);
 		a17_AST = astFactory->create(antlr::RefAST(a17));
-		antlr::ASTPair __currentAST135 = currentAST;
+		antlr::ASTPair __currentAST140 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),POW_EQ);
@@ -2653,8 +2791,8 @@
 		expr(_t);
 		_t = _retTree;
 		r17_AST = returnAST;
-		currentAST = __currentAST135;
-		_t = __t135;
+		currentAST = __currentAST140;
+		_t = __t140;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l17_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(POW,"^")))->add(antlr::RefAST(l17_AST))->add(antlr::RefAST(r17_AST))))))->add(antlr::RefAST(RemoveNextSibling(l17_AST)))));
@@ -2669,11 +2807,11 @@
 	}
 	case SLASH_EQ:
 	{
-		RefDNode __t136 = _t;
+		RefDNode __t141 = _t;
 		a18 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a18_AST_in = RefDNode(antlr::nullAST);
 		a18_AST = astFactory->create(antlr::RefAST(a18));
-		antlr::ASTPair __currentAST136 = currentAST;
+		antlr::ASTPair __currentAST141 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),SLASH_EQ);
@@ -2686,8 +2824,8 @@
 		expr(_t);
 		_t = _retTree;
 		r18_AST = returnAST;
-		currentAST = __currentAST136;
-		_t = __t136;
+		currentAST = __currentAST141;
+		_t = __t141;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l18_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(SLASH,"/")))->add(antlr::RefAST(l18_AST))->add(antlr::RefAST(r18_AST))))))->add(antlr::RefAST(RemoveNextSibling(l18_AST)))));
@@ -2702,11 +2840,11 @@
 	}
 	case XOR_OP_EQ:
 	{
-		RefDNode __t137 = _t;
+		RefDNode __t142 = _t;
 		a19 = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a19_AST_in = RefDNode(antlr::nullAST);
 		a19_AST = astFactory->create(antlr::RefAST(a19));
-		antlr::ASTPair __currentAST137 = currentAST;
+		antlr::ASTPair __currentAST142 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),XOR_OP_EQ);
@@ -2719,8 +2857,8 @@
 		expr(_t);
 		_t = _retTree;
 		r19_AST = returnAST;
-		currentAST = __currentAST137;
-		_t = __t137;
+		currentAST = __currentAST142;
+		_t = __t142;
 		_t = _t->getNextSibling();
 		comp_assign_expr_AST = RefDNode(currentAST.root);
 		l=l19_AST; comp_assign_expr_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ASSIGN,":=")))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(XOR_OP,"xor")))->add(antlr::RefAST(l19_AST))->add(antlr::RefAST(r19_AST))))))->add(antlr::RefAST(RemoveNextSibling(l19_AST)))));
@@ -2762,13 +2900,13 @@
 	switch ( _t->getType()) {
 	case MPCALL:
 	{
-		RefDNode __t76 = _t;
-		RefDNode tmp19_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp19_AST_in = RefDNode(antlr::nullAST);
-		tmp19_AST = astFactory->create(antlr::RefAST(_t));
-		tmp19_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp19_AST));
-		antlr::ASTPair __currentAST76 = currentAST;
+		RefDNode __t81 = _t;
+		RefDNode tmp16_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp16_AST_in = RefDNode(antlr::nullAST);
+		tmp16_AST = astFactory->create(antlr::RefAST(_t));
+		tmp16_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp16_AST));
+		antlr::ASTPair __currentAST81 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MPCALL);
@@ -2776,31 +2914,31 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		RefDNode tmp20_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp20_AST_in = RefDNode(antlr::nullAST);
-		tmp20_AST = astFactory->create(antlr::RefAST(_t));
-		tmp20_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp20_AST));
+		RefDNode tmp17_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp17_AST_in = RefDNode(antlr::nullAST);
+		tmp17_AST = astFactory->create(antlr::RefAST(_t));
+		tmp17_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp17_AST));
 		match(antlr::RefAST(_t),IDENTIFIER);
 		_t = _t->getNextSibling();
 		parameter_def(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST76;
-		_t = __t76;
+		currentAST = __currentAST81;
+		_t = __t81;
 		_t = _t->getNextSibling();
 		procedure_call_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case MPCALL_PARENT:
 	{
-		RefDNode __t77 = _t;
-		RefDNode tmp21_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp21_AST_in = RefDNode(antlr::nullAST);
-		tmp21_AST = astFactory->create(antlr::RefAST(_t));
-		tmp21_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp21_AST));
-		antlr::ASTPair __currentAST77 = currentAST;
+		RefDNode __t82 = _t;
+		RefDNode tmp18_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp18_AST_in = RefDNode(antlr::nullAST);
+		tmp18_AST = astFactory->create(antlr::RefAST(_t));
+		tmp18_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp18_AST));
+		antlr::ASTPair __currentAST82 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MPCALL_PARENT);
@@ -2808,37 +2946,37 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		RefDNode tmp22_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp22_AST_in = RefDNode(antlr::nullAST);
-		tmp22_AST = astFactory->create(antlr::RefAST(_t));
-		tmp22_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp22_AST));
+		RefDNode tmp19_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp19_AST_in = RefDNode(antlr::nullAST);
+		tmp19_AST = astFactory->create(antlr::RefAST(_t));
+		tmp19_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp19_AST));
 		match(antlr::RefAST(_t),IDENTIFIER);
 		_t = _t->getNextSibling();
-		RefDNode tmp23_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp23_AST_in = RefDNode(antlr::nullAST);
-		tmp23_AST = astFactory->create(antlr::RefAST(_t));
-		tmp23_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp23_AST));
+		RefDNode tmp20_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp20_AST_in = RefDNode(antlr::nullAST);
+		tmp20_AST = astFactory->create(antlr::RefAST(_t));
+		tmp20_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp20_AST));
 		match(antlr::RefAST(_t),IDENTIFIER);
 		_t = _t->getNextSibling();
 		parameter_def(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST77;
-		_t = __t77;
+		currentAST = __currentAST82;
+		_t = __t82;
 		_t = _t->getNextSibling();
 		procedure_call_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case PCALL:
 	{
-		RefDNode __t78 = _t;
+		RefDNode __t83 = _t;
 		p = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode p_AST_in = RefDNode(antlr::nullAST);
 		p_AST = astFactory->create(antlr::RefAST(p));
 		astFactory->addASTChild(currentAST, antlr::RefAST(p_AST));
-		antlr::ASTPair __currentAST78 = currentAST;
+		antlr::ASTPair __currentAST83 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),PCALL);
@@ -2868,8 +3006,8 @@
 		id_AST->SetProIx(i);
 		}
 		
-		currentAST = __currentAST78;
-		_t = __t78;
+		currentAST = __currentAST83;
+		_t = __t83;
 		_t = _t->getNextSibling();
 		procedure_call_AST = RefDNode(currentAST.root);
 		break;
@@ -2897,12 +3035,12 @@
 	int labelStart = comp.NDefLabel();
 	
 	
-	RefDNode __t63 = _t;
+	RefDNode __t66 = _t;
 	f = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode f_AST_in = RefDNode(antlr::nullAST);
 	f_AST = astFactory->create(antlr::RefAST(f));
 	astFactory->addASTChild(currentAST, antlr::RefAST(f_AST));
-	antlr::ASTPair __currentAST63 = currentAST;
+	antlr::ASTPair __currentAST66 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),FOR);
@@ -2934,6 +3072,7 @@
 	case ARRAYDEF_CONST:
 	case ARRAYEXPR:
 	case ARRAYEXPR_FN:
+	case ARRAYEXPR_MFCALL:
 	case CONSTANT:
 	case DEREF:
 	case EXPR:
@@ -3013,11 +3152,11 @@
 	}
 	}
 	}
-	unblock(_t);
+	unblock_empty(_t);
 	_t = _retTree;
 	astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-	currentAST = __currentAST63;
-	_t = __t63;
+	currentAST = __currentAST66;
+	_t = __t66;
 	_t = _t->getNextSibling();
 	
 	f_AST->SetLabelRange( labelStart, comp.NDefLabel());
@@ -3027,6 +3166,59 @@
 	_retTree = _t;
 }
 
+void GDLTreeParser::foreach_statement(RefDNode _t) {
+	RefDNode foreach_statement_AST_in = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
+	returnAST = RefDNode(antlr::nullAST);
+	antlr::ASTPair currentAST;
+	RefDNode foreach_statement_AST = RefDNode(antlr::nullAST);
+	RefDNode f = RefDNode(antlr::nullAST);
+	RefDNode f_AST = RefDNode(antlr::nullAST);
+	RefDNode i = RefDNode(antlr::nullAST);
+	RefDNode i_AST = RefDNode(antlr::nullAST);
+	
+	StackSizeGuard<IDList> guard( loopVarStack);
+	int labelStart = comp.NDefLabel();
+	
+	
+	RefDNode __t69 = _t;
+	f = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
+	RefDNode f_AST_in = RefDNode(antlr::nullAST);
+	f_AST = astFactory->create(antlr::RefAST(f));
+	astFactory->addASTChild(currentAST, antlr::RefAST(f_AST));
+	antlr::ASTPair __currentAST69 = currentAST;
+	currentAST.root = currentAST.child;
+	currentAST.child = RefDNode(antlr::nullAST);
+	match(antlr::RefAST(_t),FOREACH);
+	_t = _t->getFirstChild();
+	i = _t;
+	RefDNode i_AST_in = RefDNode(antlr::nullAST);
+	i_AST = astFactory->create(antlr::RefAST(i));
+	astFactory->addASTChild(currentAST, antlr::RefAST(i_AST));
+	match(antlr::RefAST(_t),IDENTIFIER);
+	_t = _t->getNextSibling();
+	
+	i_AST->setType(VAR);
+	comp.Var(i_AST);	
+	
+	loopVarStack.push_back(i_AST->getText());
+	
+	expr(_t);
+	_t = _retTree;
+	astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+	unblock_empty(_t);
+	_t = _retTree;
+	astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+	currentAST = __currentAST69;
+	_t = __t69;
+	_t = _t->getNextSibling();
+	
+	f_AST->SetLabelRange( labelStart, comp.NDefLabel());
+	
+	foreach_statement_AST = RefDNode(currentAST.root);
+	returnAST = foreach_statement_AST;
+	_retTree = _t;
+}
+
 void GDLTreeParser::repeat_statement(RefDNode _t) {
 	RefDNode repeat_statement_AST_in = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	returnAST = RefDNode(antlr::nullAST);
@@ -3042,25 +3234,25 @@
 	int labelStart = comp.NDefLabel();
 	
 	
-	RefDNode __t59 = _t;
+	RefDNode __t62 = _t;
 	r = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode r_AST_in = RefDNode(antlr::nullAST);
 	r_AST = astFactory->create(antlr::RefAST(r));
-	antlr::ASTPair __currentAST59 = currentAST;
+	antlr::ASTPair __currentAST62 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),REPEAT);
 	_t = _t->getFirstChild();
 	b = (_t == ASTNULL) ? RefDNode(antlr::nullAST) : _t;
-	unblock(_t);
+	unblock_empty(_t);
 	_t = _retTree;
 	b_AST = returnAST;
 	e = (_t == ASTNULL) ? RefDNode(antlr::nullAST) : _t;
 	expr(_t);
 	_t = _retTree;
 	e_AST = returnAST;
-	currentAST = __currentAST59;
-	_t = __t59;
+	currentAST = __currentAST62;
+	_t = __t62;
 	_t = _t->getNextSibling();
 	repeat_statement_AST = RefDNode(currentAST.root);
 	
@@ -3095,11 +3287,11 @@
 	int labelStart = comp.NDefLabel();
 	
 	
-	RefDNode __t61 = _t;
+	RefDNode __t64 = _t;
 	w = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode w_AST_in = RefDNode(antlr::nullAST);
 	w_AST = astFactory->create(antlr::RefAST(w));
-	antlr::ASTPair __currentAST61 = currentAST;
+	antlr::ASTPair __currentAST64 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),WHILE);
@@ -3112,8 +3304,8 @@
 	statement(_t);
 	_t = _retTree;
 	s_AST = returnAST;
-	currentAST = __currentAST61;
-	_t = __t61;
+	currentAST = __currentAST64;
+	_t = __t64;
 	_t = _t->getNextSibling();
 	while_statement_AST = RefDNode(currentAST.root);
 	
@@ -3156,11 +3348,11 @@
 	switch ( _t->getType()) {
 	case GOTO:
 	{
-		RefDNode __t68 = _t;
+		RefDNode __t73 = _t;
 		g = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode g_AST_in = RefDNode(antlr::nullAST);
 		g_AST = astFactory->create(antlr::RefAST(g));
-		antlr::ASTPair __currentAST68 = currentAST;
+		antlr::ASTPair __currentAST73 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),GOTO);
@@ -3170,8 +3362,8 @@
 		i1_AST = astFactory->create(antlr::RefAST(i1));
 		match(antlr::RefAST(_t),IDENTIFIER);
 		_t = _t->getNextSibling();
-		currentAST = __currentAST68;
-		_t = __t68;
+		currentAST = __currentAST73;
+		_t = __t73;
 		_t = _t->getNextSibling();
 		jump_statement_AST = RefDNode(currentAST.root);
 		
@@ -3191,11 +3383,11 @@
 	}
 	case RETURN:
 	{
-		RefDNode __t69 = _t;
+		RefDNode __t74 = _t;
 		r = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode r_AST_in = RefDNode(antlr::nullAST);
 		r_AST = astFactory->create(antlr::RefAST(r));
-		antlr::ASTPair __currentAST69 = currentAST;
+		antlr::ASTPair __currentAST74 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),RETURN);
@@ -3210,6 +3402,7 @@
 		case ARRAYDEF_CONST:
 		case ARRAYEXPR:
 		case ARRAYEXPR_FN:
+		case ARRAYEXPR_MFCALL:
 		case CONSTANT:
 		case DEREF:
 		case EXPR:
@@ -3287,16 +3480,29 @@
 		}
 		}
 		}
-		currentAST = __currentAST69;
-		_t = __t69;
+		currentAST = __currentAST74;
+		_t = __t74;
 		_t = _t->getNextSibling();
 		jump_statement_AST = RefDNode(currentAST.root);
 		
 			  if( comp.IsFun())
 			  	{
-				if( !exprThere)	throw GDLException(	_t, 
+				if( !exprThere)	throw GDLException(	r, 
 		"Return statement in functions "
 		"must have 1 value.");
+		
+		//         // wrong: this is only true for l_function as return value
+		//         // a ARRAYEXPR_MFCALL can only be a MFCALL here -> change tree
+		//         if( #e->getType() == ARRAYEXPR_MFCALL)
+		//             {
+		//                 #e->setType( MFCALL);
+		//                 #e->setText( "mfcall");
+		//                 RefDNode mfc;
+		//                 mfc = #e->getFirstChild();
+		//                 mfc = mfc->getNextSibling();
+		//                 #e->setFirstChild( antlr::RefAST(mfc));             
+		//             }
+		
 				jump_statement_AST=RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(RETF,"retf")))->add(antlr::RefAST(e_AST))));
 		jump_statement_AST->SetLine(r->getLine()); 
 				}
@@ -3320,11 +3526,11 @@
 	}
 	case ON_IOERROR:
 	{
-		RefDNode __t71 = _t;
+		RefDNode __t76 = _t;
 		o = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode o_AST_in = RefDNode(antlr::nullAST);
 		o_AST = astFactory->create(antlr::RefAST(o));
-		antlr::ASTPair __currentAST71 = currentAST;
+		antlr::ASTPair __currentAST76 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ON_IOERROR);
@@ -3334,8 +3540,8 @@
 		i2_AST = astFactory->create(antlr::RefAST(i2));
 		match(antlr::RefAST(_t),IDENTIFIER);
 		_t = _t->getNextSibling();
-		currentAST = __currentAST71;
-		_t = __t71;
+		currentAST = __currentAST76;
+		_t = __t76;
 		_t = _t->getNextSibling();
 		jump_statement_AST = RefDNode(currentAST.root);
 		
@@ -3385,14 +3591,15 @@
 	RefDNode s2_AST = RefDNode(antlr::nullAST);
 	RefDNode s2 = RefDNode(antlr::nullAST);
 	
-	int labelStart = comp.NDefLabel();
+	//     int labelStart = comp.NDefLabel();
+	RefDNode block;
 	
 	
-	RefDNode __t73 = _t;
+	RefDNode __t78 = _t;
 	i = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode i_AST_in = RefDNode(antlr::nullAST);
 	i_AST = astFactory->create(antlr::RefAST(i));
-	antlr::ASTPair __currentAST73 = currentAST;
+	antlr::ASTPair __currentAST78 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),IF);
@@ -3413,7 +3620,7 @@
 	{
 		if_statement_AST = RefDNode(currentAST.root);
 		
-		i_AST->SetLabelRange( labelStart, comp.NDefLabel());
+		//         #i->SetLabelRange( labelStart, comp.NDefLabel());
 		if_statement_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(i_AST))->add(antlr::RefAST(e_AST))->add(antlr::RefAST(s1_AST))));
 		
 		currentAST.root = if_statement_AST;
@@ -3431,19 +3638,20 @@
 	case CONTINUE:
 	case COMMONDECL:
 	case COMMONDEF:
+	case FOR:
+	case FOREACH:
 	case MPCALL:
 	case MPCALL_PARENT:
 	case PCALL:
+	case REPEAT:
 	case RETURN:
+	case WHILE:
 	case CASE:
-	case FOR:
 	case FORWARD:
 	case GOTO:
 	case IF:
 	case ON_IOERROR:
-	case REPEAT:
 	case SWITCH:
-	case WHILE:
 	case DEC:
 	case INC:
 	case AND_OP_EQ:
@@ -3474,7 +3682,14 @@
 		
 		i_AST->setText( "if_else");
 		i_AST->setType( IF_ELSE);
-		i_AST->SetLabelRange( labelStart, comp.NDefLabel());
+		//         #i->SetLabelRange( labelStart, comp.NDefLabel());
+		if( s1_AST->getType() != BLOCK)
+		{
+		block = astFactory->create(BLOCK,"block");
+		block->SetLine( s1_AST->getLine());
+		if_statement_AST=RefDNode(astFactory->make((new antlr::ASTArray(4))->add(antlr::RefAST(i_AST))->add(antlr::RefAST(e_AST))->add(antlr::RefAST(RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(block))->add(antlr::RefAST(s1_AST))))))->add(antlr::RefAST(s2_AST))));
+		}
+		else
 		if_statement_AST=RefDNode(astFactory->make((new antlr::ASTArray(4))->add(antlr::RefAST(i_AST))->add(antlr::RefAST(e_AST))->add(antlr::RefAST(s1_AST))->add(antlr::RefAST(s2_AST))));
 		
 		currentAST.root = if_statement_AST;
@@ -3492,8 +3707,8 @@
 	}
 	}
 	}
-	currentAST = __currentAST73;
-	_t = __t73;
+	currentAST = __currentAST78;
+	_t = __t78;
 	_t = _t->getNextSibling();
 	returnAST = if_statement_AST;
 	_retTree = _t;
@@ -3522,6 +3737,7 @@
 		case ARRAYDEF_CONST:
 		case ARRAYEXPR:
 		case ARRAYEXPR_FN:
+		case ARRAYEXPR_MFCALL:
 		case CONSTANT:
 		case DEREF:
 		case EXPR:
@@ -3589,11 +3805,11 @@
 		}
 		default:
 		{
-			goto _loop81;
+			goto _loop86;
 		}
 		}
 	}
-	_loop81:;
+	_loop86:;
 	} // ( ... )*
 	parameter_def_AST = RefDNode(currentAST.root);
 	returnAST = parameter_def_AST;
@@ -3615,11 +3831,11 @@
 	RefDNode variable;
 	
 	
-	RefDNode __t83 = _t;
+	RefDNode __t88 = _t;
 	d = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode d_AST_in = RefDNode(antlr::nullAST);
 	d_AST = astFactory->create(antlr::RefAST(d));
-	antlr::ASTPair __currentAST83 = currentAST;
+	antlr::ASTPair __currentAST88 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),KEYDEF);
@@ -3652,10 +3868,13 @@
 	else 
 	{
 	int t = k_AST->getType();
-	if( t == FCALL_LIB || t == MFCALL_LIB || 
-	t == MFCALL_PARENT_LIB ||
-	t == FCALL_LIB_RETNEW || t == MFCALL_LIB_RETNEW || 
-	t == MFCALL_PARENT_LIB_RETNEW) 
+	if( t == FCALL_LIB || t == MFCALL_LIB || //t == FCALL_LIB_N_ELEMENTS ||
+	
+	t == MFCALL_PARENT_LIB //||
+	//                          t == FCALL_LIB_RETNEW || t == MFCALL_LIB_RETNEW || 
+	//                          t == MFCALL_PARENT_LIB_RETNEW //||
+	//                          t == ARRARYEXPR_MFCALL_LIB // MFCALL_LIB or VAR or DEREF 
+	)
 	{
 	d_AST=astFactory->create(KEYDEF_REF_CHECK,"keydef_ref_check");
 	key_parameter_AST=RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(d_AST))->add(antlr::RefAST(i_AST))->add(antlr::RefAST(k_AST))));
@@ -3678,8 +3897,8 @@
 	else
 		currentAST.child = key_parameter_AST;
 	currentAST.advanceChildToEnd();
-	currentAST = __currentAST83;
-	_t = __t83;
+	currentAST = __currentAST88;
+	_t = __t88;
 	_t = _t->getNextSibling();
 	returnAST = key_parameter_AST;
 	_retTree = _t;
@@ -3717,10 +3936,12 @@
 	else 
 	{
 	int t = e_AST->getType();
-	if( t == FCALL_LIB || t == MFCALL_LIB || 
-	t == MFCALL_PARENT_LIB ||
-	t == FCALL_LIB_RETNEW || t == MFCALL_LIB_RETNEW || 
-	t == MFCALL_PARENT_LIB_RETNEW) 
+	if( t == FCALL_LIB || t == MFCALL_LIB || //t == FCALL_LIB_N_ELEMENTS ||
+	t == MFCALL_PARENT_LIB //||
+	//                      t == FCALL_LIB_RETNEW || t == MFCALL_LIB_RETNEW || 
+	//                      t == MFCALL_PARENT_LIB_RETNEW
+	//                      t == ARRARYEXPR_MFCALL_LIB // MFCALL_LIB or VAR or DEREF 
+	) 
 	{
 	// something like: CALLAPRO,reform(a,/OVERWRITE)
 	pos_parameter_AST=RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(REF_CHECK,"ref_check")))->add(antlr::RefAST(e_AST))));
@@ -3761,12 +3982,12 @@
 	switch ( _t->getType()) {
 	case ARRAYDEF:
 	{
-		RefDNode __t86 = _t;
+		RefDNode __t91 = _t;
 		a = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode a_AST_in = RefDNode(antlr::nullAST);
 		a_AST = astFactory->create(antlr::RefAST(a));
 		astFactory->addASTChild(currentAST, antlr::RefAST(a_AST));
-		antlr::ASTPair __currentAST86 = currentAST;
+		antlr::ASTPair __currentAST91 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ARRAYDEF);
@@ -3783,14 +4004,14 @@
 				/*check for constant expression*/
 			}
 			else {
-				goto _loop88;
+				goto _loop93;
 			}
 			
 		}
-		_loop88:;
+		_loop93:;
 		} // ( ... )*
-		currentAST = __currentAST86;
-		_t = __t86;
+		currentAST = __currentAST91;
+		_t = __t91;
 		_t = _t->getNextSibling();
 		
 		// better check here as then CONSTANT is propagated
@@ -3831,12 +4052,12 @@
 	}
 	case ARRAYDEF_CONST:
 	{
-		RefDNode __t89 = _t;
+		RefDNode __t94 = _t;
 		aa = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode aa_AST_in = RefDNode(antlr::nullAST);
 		aa_AST = astFactory->create(antlr::RefAST(aa));
 		astFactory->addASTChild(currentAST, antlr::RefAST(aa_AST));
-		antlr::ASTPair __currentAST89 = currentAST;
+		antlr::ASTPair __currentAST94 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ARRAYDEF_CONST);
@@ -3852,14 +4073,14 @@
 				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 			}
 			else {
-				goto _loop91;
+				goto _loop96;
 			}
 			
 		}
-		_loop91:;
+		_loop96:;
 		} // ( ... )*
-		currentAST = __currentAST89;
-		_t = __t89;
+		currentAST = __currentAST94;
+		_t = __t94;
 		_t = _t->getNextSibling();
 		
 		depth=0;
@@ -3917,21 +4138,21 @@
 	switch ( _t->getType()) {
 	case NSTRUC_REF:
 	{
-		RefDNode __t93 = _t;
+		RefDNode __t98 = _t;
 		n = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode n_AST_in = RefDNode(antlr::nullAST);
 		n_AST = astFactory->create(antlr::RefAST(n));
 		astFactory->addASTChild(currentAST, antlr::RefAST(n_AST));
-		antlr::ASTPair __currentAST93 = currentAST;
+		antlr::ASTPair __currentAST98 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),NSTRUC_REF);
 		_t = _t->getFirstChild();
-		RefDNode tmp24_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp24_AST_in = RefDNode(antlr::nullAST);
-		tmp24_AST = astFactory->create(antlr::RefAST(_t));
-		tmp24_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp24_AST));
+		RefDNode tmp21_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp21_AST_in = RefDNode(antlr::nullAST);
+		tmp21_AST = astFactory->create(antlr::RefAST(_t));
+		tmp21_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp21_AST));
 		match(antlr::RefAST(_t),IDENTIFIER);
 		_t = _t->getNextSibling();
 		{
@@ -3943,6 +4164,7 @@
 		case ARRAYDEF_CONST:
 		case ARRAYEXPR:
 		case ARRAYEXPR_FN:
+		case ARRAYEXPR_MFCALL:
 		case CONSTANT:
 		case DEREF:
 		case EXPR:
@@ -4006,7 +4228,7 @@
 		case QUESTION:
 		{
 			{ // ( ... )+
-			int _cnt96=0;
+			int _cnt101=0;
 			for (;;) {
 				if (_t == RefDNode(antlr::nullAST) )
 					_t = ASTNULL;
@@ -4016,6 +4238,7 @@
 				case ARRAYDEF_CONST:
 				case ARRAYEXPR:
 				case ARRAYEXPR_FN:
+				case ARRAYEXPR_MFCALL:
 				case CONSTANT:
 				case DEREF:
 				case EXPR:
@@ -4084,11 +4307,11 @@
 				}
 				case IDENTIFIER:
 				{
-					RefDNode tmp25_AST = RefDNode(antlr::nullAST);
-					RefDNode tmp25_AST_in = RefDNode(antlr::nullAST);
-					tmp25_AST = astFactory->create(antlr::RefAST(_t));
-					tmp25_AST_in = _t;
-					astFactory->addASTChild(currentAST, antlr::RefAST(tmp25_AST));
+					RefDNode tmp22_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp22_AST_in = RefDNode(antlr::nullAST);
+					tmp22_AST = astFactory->create(antlr::RefAST(_t));
+					tmp22_AST_in = _t;
+					astFactory->addASTChild(currentAST, antlr::RefAST(tmp22_AST));
 					match(antlr::RefAST(_t),IDENTIFIER);
 					_t = _t->getNextSibling();
 					expr(_t);
@@ -4098,30 +4321,30 @@
 				}
 				case INHERITS:
 				{
-					RefDNode tmp26_AST = RefDNode(antlr::nullAST);
-					RefDNode tmp26_AST_in = RefDNode(antlr::nullAST);
-					tmp26_AST = astFactory->create(antlr::RefAST(_t));
-					tmp26_AST_in = _t;
-					astFactory->addASTChild(currentAST, antlr::RefAST(tmp26_AST));
+					RefDNode tmp23_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp23_AST_in = RefDNode(antlr::nullAST);
+					tmp23_AST = astFactory->create(antlr::RefAST(_t));
+					tmp23_AST_in = _t;
+					astFactory->addASTChild(currentAST, antlr::RefAST(tmp23_AST));
 					match(antlr::RefAST(_t),INHERITS);
 					_t = _t->getNextSibling();
-					RefDNode tmp27_AST = RefDNode(antlr::nullAST);
-					RefDNode tmp27_AST_in = RefDNode(antlr::nullAST);
-					tmp27_AST = astFactory->create(antlr::RefAST(_t));
-					tmp27_AST_in = _t;
-					astFactory->addASTChild(currentAST, antlr::RefAST(tmp27_AST));
+					RefDNode tmp24_AST = RefDNode(antlr::nullAST);
+					RefDNode tmp24_AST_in = RefDNode(antlr::nullAST);
+					tmp24_AST = astFactory->create(antlr::RefAST(_t));
+					tmp24_AST_in = _t;
+					astFactory->addASTChild(currentAST, antlr::RefAST(tmp24_AST));
 					match(antlr::RefAST(_t),IDENTIFIER);
 					_t = _t->getNextSibling();
 					break;
 				}
 				default:
 				{
-					if ( _cnt96>=1 ) { goto _loop96; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+					if ( _cnt101>=1 ) { goto _loop101; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 				}
 				}
-				_cnt96++;
+				_cnt101++;
 			}
-			_loop96:;
+			_loop101:;
 			}  // ( ... )+
 			
 			// set to nstruct if defined here
@@ -4141,27 +4364,27 @@
 		}
 		}
 		}
-		currentAST = __currentAST93;
-		_t = __t93;
+		currentAST = __currentAST98;
+		_t = __t98;
 		_t = _t->getNextSibling();
 		struct_def_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case STRUC:
 	{
-		RefDNode __t97 = _t;
-		RefDNode tmp28_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp28_AST_in = RefDNode(antlr::nullAST);
-		tmp28_AST = astFactory->create(antlr::RefAST(_t));
-		tmp28_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp28_AST));
-		antlr::ASTPair __currentAST97 = currentAST;
+		RefDNode __t102 = _t;
+		RefDNode tmp25_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp25_AST_in = RefDNode(antlr::nullAST);
+		tmp25_AST = astFactory->create(antlr::RefAST(_t));
+		tmp25_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp25_AST));
+		antlr::ASTPair __currentAST102 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),STRUC);
 		_t = _t->getFirstChild();
 		{ // ( ... )+
-		int _cnt99=0;
+		int _cnt104=0;
 		for (;;) {
 			if (_t == RefDNode(antlr::nullAST) )
 				_t = ASTNULL;
@@ -4171,15 +4394,15 @@
 				astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 			}
 			else {
-				if ( _cnt99>=1 ) { goto _loop99; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+				if ( _cnt104>=1 ) { goto _loop104; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 			}
 			
-			_cnt99++;
+			_cnt104++;
 		}
-		_loop99:;
+		_loop104:;
 		}  // ( ... )+
-		currentAST = __currentAST97;
-		_t = __t97;
+		currentAST = __currentAST102;
+		_t = __t102;
 		_t = _t->getNextSibling();
 		struct_def_AST = RefDNode(currentAST.root);
 		break;
@@ -4199,11 +4422,11 @@
 	antlr::ASTPair currentAST;
 	RefDNode tag_def_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode tmp29_AST = RefDNode(antlr::nullAST);
-	RefDNode tmp29_AST_in = RefDNode(antlr::nullAST);
-	tmp29_AST = astFactory->create(antlr::RefAST(_t));
-	tmp29_AST_in = _t;
-	astFactory->addASTChild(currentAST, antlr::RefAST(tmp29_AST));
+	RefDNode tmp26_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp26_AST_in = RefDNode(antlr::nullAST);
+	tmp26_AST = astFactory->create(antlr::RefAST(_t));
+	tmp26_AST_in = _t;
+	astFactory->addASTChild(currentAST, antlr::RefAST(tmp26_AST));
 	match(antlr::RefAST(_t),IDENTIFIER);
 	_t = _t->getNextSibling();
 	expr(_t);
@@ -4234,12 +4457,12 @@
 	
 	
 	{
-	RefDNode __t103 = _t;
-	RefDNode tmp30_AST = RefDNode(antlr::nullAST);
-	RefDNode tmp30_AST_in = RefDNode(antlr::nullAST);
-	tmp30_AST = astFactory->create(antlr::RefAST(_t));
-	tmp30_AST_in = _t;
-	antlr::ASTPair __currentAST103 = currentAST;
+	RefDNode __t108 = _t;
+	RefDNode tmp27_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp27_AST_in = RefDNode(antlr::nullAST);
+	tmp27_AST = astFactory->create(antlr::RefAST(_t));
+	tmp27_AST_in = _t;
+	antlr::ASTPair __currentAST108 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),ARRAYIX);
@@ -4250,10 +4473,10 @@
 	switch ( _t->getType()) {
 	case ALL:
 	{
-		RefDNode tmp31_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp31_AST_in = RefDNode(antlr::nullAST);
-		tmp31_AST = astFactory->create(antlr::RefAST(_t));
-		tmp31_AST_in = _t;
+		RefDNode tmp28_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp28_AST_in = RefDNode(antlr::nullAST);
+		tmp28_AST = astFactory->create(antlr::RefAST(_t));
+		tmp28_AST_in = _t;
 		match(antlr::RefAST(_t),ALL);
 		_t = _t->getNextSibling();
 		
@@ -4266,6 +4489,7 @@
 	case ARRAYDEF_CONST:
 	case ARRAYEXPR:
 	case ARRAYEXPR_FN:
+	case ARRAYEXPR_MFCALL:
 	case CONSTANT:
 	case DEREF:
 	case EXPR:
@@ -4380,10 +4604,10 @@
 		}
 		case ALL:
 		{
-			RefDNode tmp32_AST = RefDNode(antlr::nullAST);
-			RefDNode tmp32_AST_in = RefDNode(antlr::nullAST);
-			tmp32_AST = astFactory->create(antlr::RefAST(_t));
-			tmp32_AST_in = _t;
+			RefDNode tmp29_AST = RefDNode(antlr::nullAST);
+			RefDNode tmp29_AST_in = RefDNode(antlr::nullAST);
+			tmp29_AST = astFactory->create(antlr::RefAST(_t));
+			tmp29_AST_in = _t;
 			match(antlr::RefAST(_t),ALL);
 			_t = _t->getNextSibling();
 			{
@@ -4419,6 +4643,7 @@
 			case ARRAYDEF_CONST:
 			case ARRAYEXPR:
 			case ARRAYEXPR_FN:
+			case ARRAYEXPR_MFCALL:
 			case CONSTANT:
 			case DEREF:
 			case EXPR:
@@ -4521,6 +4746,7 @@
 		case ARRAYDEF_CONST:
 		case ARRAYEXPR:
 		case ARRAYEXPR_FN:
+		case ARRAYEXPR_MFCALL:
 		case CONSTANT:
 		case DEREF:
 		case EXPR:
@@ -4620,6 +4846,7 @@
 			case ARRAYDEF_CONST:
 			case ARRAYEXPR:
 			case ARRAYEXPR_FN:
+			case ARRAYEXPR_MFCALL:
 			case CONSTANT:
 			case DEREF:
 			case EXPR:
@@ -4731,8 +4958,8 @@
 	}
 	}
 	}
-	currentAST = __currentAST103;
-	_t = __t103;
+	currentAST = __currentAST108;
+	_t = __t108;
 	_t = _t->getNextSibling();
 	}
 	returnAST = arrayindex_AST;
@@ -4751,7 +4978,7 @@
 	
 	
 	{ // ( ... )+
-	int _cnt111=0;
+	int _cnt116=0;
 	for (;;) {
 		if (_t == RefDNode(antlr::nullAST) )
 			_t = ASTNULL;
@@ -4761,12 +4988,12 @@
 			astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 		}
 		else {
-			if ( _cnt111>=1 ) { goto _loop111; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+			if ( _cnt116>=1 ) { goto _loop116; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 		}
 		
-		_cnt111++;
+		_cnt116++;
 	}
-	_loop111:;
+	_loop116:;
 	}  // ( ... )+
 	arrayindex_list_AST = RefDNode(currentAST.root);
 	
@@ -4854,11 +5081,11 @@
 	RefDNode r_AST = RefDNode(antlr::nullAST);
 	RefDNode r = RefDNode(antlr::nullAST);
 	
-	RefDNode __t114 = _t;
+	RefDNode __t119 = _t;
 	a = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode a_AST_in = RefDNode(antlr::nullAST);
 	a_AST = astFactory->create(antlr::RefAST(a));
-	antlr::ASTPair __currentAST114 = currentAST;
+	antlr::ASTPair __currentAST119 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),ASSIGN);
@@ -4871,8 +5098,8 @@
 	expr(_t);
 	_t = _retTree;
 	r_AST = returnAST;
-	currentAST = __currentAST114;
-	_t = __t114;
+	currentAST = __currentAST119;
+	_t = __t119;
 	_t = _t->getNextSibling();
 	assign_expr_AST = RefDNode(currentAST.root);
 	
@@ -4909,15 +5136,16 @@
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
 	RefDNode sysvar_AST = RefDNode(antlr::nullAST);
+	RefDNode s = RefDNode(antlr::nullAST);
+	RefDNode s_AST = RefDNode(antlr::nullAST);
 	RefDNode i = RefDNode(antlr::nullAST);
 	RefDNode i_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode __t139 = _t;
-	RefDNode tmp33_AST = RefDNode(antlr::nullAST);
-	RefDNode tmp33_AST_in = RefDNode(antlr::nullAST);
-	tmp33_AST = astFactory->create(antlr::RefAST(_t));
-	tmp33_AST_in = _t;
-	antlr::ASTPair __currentAST139 = currentAST;
+	RefDNode __t144 = _t;
+	s = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
+	RefDNode s_AST_in = RefDNode(antlr::nullAST);
+	s_AST = astFactory->create(antlr::RefAST(s));
+	antlr::ASTPair __currentAST144 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),SYSVAR);
@@ -4927,14 +5155,15 @@
 	i_AST = astFactory->create(antlr::RefAST(i));
 	match(antlr::RefAST(_t),SYSVARNAME);
 	_t = _t->getNextSibling();
-	currentAST = __currentAST139;
-	_t = __t139;
+	currentAST = __currentAST144;
+	_t = __t144;
 	_t = _t->getNextSibling();
 	sysvar_AST = RefDNode(currentAST.root);
 	
 	std::string sysVarName = i->getText();
 	// here we create the real sysvar node      
 		  sysvar_AST=astFactory->create(SYSVAR, sysVarName.substr(1));
+	sysvar_AST->SetLine(s->getLine());
 	//	  #sysvar=#[SYSVAR,i->getText()];
 		  comp.SysVar(sysvar_AST); // sets var to NULL
 		
@@ -4954,15 +5183,16 @@
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
 	RefDNode var_AST = RefDNode(antlr::nullAST);
+	RefDNode v = RefDNode(antlr::nullAST);
+	RefDNode v_AST = RefDNode(antlr::nullAST);
 	RefDNode i = RefDNode(antlr::nullAST);
 	RefDNode i_AST = RefDNode(antlr::nullAST);
 	
-	RefDNode __t141 = _t;
-	RefDNode tmp34_AST = RefDNode(antlr::nullAST);
-	RefDNode tmp34_AST_in = RefDNode(antlr::nullAST);
-	tmp34_AST = astFactory->create(antlr::RefAST(_t));
-	tmp34_AST_in = _t;
-	antlr::ASTPair __currentAST141 = currentAST;
+	RefDNode __t146 = _t;
+	v = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
+	RefDNode v_AST_in = RefDNode(antlr::nullAST);
+	v_AST = astFactory->create(antlr::RefAST(v));
+	antlr::ASTPair __currentAST146 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),VAR);
@@ -4972,12 +5202,13 @@
 	i_AST = astFactory->create(antlr::RefAST(i));
 	match(antlr::RefAST(_t),IDENTIFIER);
 	_t = _t->getNextSibling();
-	currentAST = __currentAST141;
-	_t = __t141;
+	currentAST = __currentAST146;
+	_t = __t146;
 	_t = _t->getNextSibling();
 	var_AST = RefDNode(currentAST.root);
 	
 		  var_AST=astFactory->create(VAR,i->getText());
+	var_AST->SetLine(v->getLine());
 	//	  #var=#[VAR,i->getText()];
 		  comp.Var(var_AST);	
 		
@@ -4992,26 +5223,26 @@
 	_retTree = _t;
 }
 
-void GDLTreeParser::arrayindex_list_to_expression_list(RefDNode _t) {
-	RefDNode arrayindex_list_to_expression_list_AST_in = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
+void GDLTreeParser::arrayindex_list_to_parameter_list(RefDNode _t) {
+	RefDNode arrayindex_list_to_parameter_list_AST_in = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
-	RefDNode arrayindex_list_to_expression_list_AST = RefDNode(antlr::nullAST);
+	RefDNode arrayindex_list_to_parameter_list_AST = RefDNode(antlr::nullAST);
 	RefDNode e_AST = RefDNode(antlr::nullAST);
 	RefDNode e = RefDNode(antlr::nullAST);
 	
 	{ // ( ... )+
-	int _cnt145=0;
+	int _cnt150=0;
 	for (;;) {
 		if (_t == RefDNode(antlr::nullAST) )
 			_t = ASTNULL;
 		if ((_t->getType() == ARRAYIX)) {
-			RefDNode __t144 = _t;
-			RefDNode tmp35_AST = RefDNode(antlr::nullAST);
-			RefDNode tmp35_AST_in = RefDNode(antlr::nullAST);
-			tmp35_AST = astFactory->create(antlr::RefAST(_t));
-			tmp35_AST_in = _t;
-			antlr::ASTPair __currentAST144 = currentAST;
+			RefDNode __t149 = _t;
+			RefDNode tmp30_AST = RefDNode(antlr::nullAST);
+			RefDNode tmp30_AST_in = RefDNode(antlr::nullAST);
+			tmp30_AST = astFactory->create(antlr::RefAST(_t));
+			tmp30_AST_in = _t;
+			antlr::ASTPair __currentAST149 = currentAST;
 			currentAST.root = currentAST.child;
 			currentAST.child = RefDNode(antlr::nullAST);
 			match(antlr::RefAST(_t),ARRAYIX);
@@ -5020,31 +5251,31 @@
 			pos_parameter(_t);
 			_t = _retTree;
 			e_AST = returnAST;
-			currentAST = __currentAST144;
-			_t = __t144;
+			currentAST = __currentAST149;
+			_t = __t149;
 			_t = _t->getNextSibling();
-			arrayindex_list_to_expression_list_AST = RefDNode(currentAST.root);
+			arrayindex_list_to_parameter_list_AST = RefDNode(currentAST.root);
 			
-			arrayindex_list_to_expression_list_AST=
-			RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(NULL))->add(antlr::RefAST(arrayindex_list_to_expression_list_AST))->add(antlr::RefAST(e_AST))));
+			arrayindex_list_to_parameter_list_AST=
+			RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(NULL))->add(antlr::RefAST(arrayindex_list_to_parameter_list_AST))->add(antlr::RefAST(e_AST))));
 			
-			currentAST.root = arrayindex_list_to_expression_list_AST;
-			if ( arrayindex_list_to_expression_list_AST!=RefDNode(antlr::nullAST) &&
-				arrayindex_list_to_expression_list_AST->getFirstChild() != RefDNode(antlr::nullAST) )
-				  currentAST.child = arrayindex_list_to_expression_list_AST->getFirstChild();
+			currentAST.root = arrayindex_list_to_parameter_list_AST;
+			if ( arrayindex_list_to_parameter_list_AST!=RefDNode(antlr::nullAST) &&
+				arrayindex_list_to_parameter_list_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+				  currentAST.child = arrayindex_list_to_parameter_list_AST->getFirstChild();
 			else
-				currentAST.child = arrayindex_list_to_expression_list_AST;
+				currentAST.child = arrayindex_list_to_parameter_list_AST;
 			currentAST.advanceChildToEnd();
 		}
 		else {
-			if ( _cnt145>=1 ) { goto _loop145; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
+			if ( _cnt150>=1 ) { goto _loop150; } else {throw antlr::NoViableAltException(antlr::RefAST(_t));}
 		}
 		
-		_cnt145++;
+		_cnt150++;
 	}
-	_loop145:;
+	_loop150:;
 	}  // ( ... )+
-	returnAST = arrayindex_list_to_expression_list_AST;
+	returnAST = arrayindex_list_to_parameter_list_AST;
 	_retTree = _t;
 }
 
@@ -5066,21 +5297,21 @@
 	bool isVar;
 	
 	
-	RefDNode __t147 = _t;
-	RefDNode tmp36_AST = RefDNode(antlr::nullAST);
-	RefDNode tmp36_AST_in = RefDNode(antlr::nullAST);
-	tmp36_AST = astFactory->create(antlr::RefAST(_t));
-	tmp36_AST_in = _t;
-	antlr::ASTPair __currentAST147 = currentAST;
+	RefDNode __t152 = _t;
+	RefDNode tmp31_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp31_AST_in = RefDNode(antlr::nullAST);
+	tmp31_AST = astFactory->create(antlr::RefAST(_t));
+	tmp31_AST_in = _t;
+	antlr::ASTPair __currentAST152 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),ARRAYEXPR_FN);
 	_t = _t->getFirstChild();
-	RefDNode __t148 = _t;
+	RefDNode __t153 = _t;
 	va = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode va_AST_in = RefDNode(antlr::nullAST);
 	va_AST = astFactory->create(antlr::RefAST(va));
-	antlr::ASTPair __currentAST148 = currentAST;
+	antlr::ASTPair __currentAST153 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),VAR);
@@ -5090,8 +5321,8 @@
 	id_AST = astFactory->create(antlr::RefAST(id));
 	match(antlr::RefAST(_t),IDENTIFIER);
 	_t = _t->getNextSibling();
-	currentAST = __currentAST148;
-	_t = __t148;
+	currentAST = __currentAST153;
+	_t = __t153;
 	_t = _t->getNextSibling();
 	
 	id_text=id_AST->getText(); 
@@ -5110,7 +5341,7 @@
 	}
 	else if ((_t->getType() == ARRAYIX)) {
 		el = (_t == ASTNULL) ? RefDNode(antlr::nullAST) : _t;
-		arrayindex_list_to_expression_list(_t);
+		arrayindex_list_to_parameter_list(_t);
 		_t = _retTree;
 		el_AST = returnAST;
 	}
@@ -5132,16 +5363,16 @@
 	if( libFunList[ i]->RetNew())
 	{
 	id_AST->setType( FCALL_LIB_RETNEW);
-	arrayexpr_fn_AST=
+	arrayexpr_fn_AST =
 	RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(id_AST))->add(antlr::RefAST(el_AST))));
-	//                        #([/*FCALL_LIB_RETNEW,"fcall_lib_retnew"],*/ id, el);
+	//                              #([/*FCALL_LIB_RETNEW,"fcall_lib_retnew"],*/ id, el);
 	}
 	else
 	{
 	id_AST->setType( FCALL_LIB);
-	arrayexpr_fn_AST=
+	arrayexpr_fn_AST =
 	RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(id_AST))->add(antlr::RefAST(el_AST))));
-	//                        #(/*[FCALL_LIB,"fcall_lib"],*/ id, el);
+	//                              #(/*[FCALL_LIB,"fcall_lib"],*/ id, el);
 	}
 	}
 	else
@@ -5175,13 +5406,125 @@
 	else
 		currentAST.child = arrayexpr_fn_AST;
 	currentAST.advanceChildToEnd();
-	currentAST = __currentAST147;
-	_t = __t147;
+	currentAST = __currentAST152;
+	_t = __t152;
 	_t = _t->getNextSibling();
 	returnAST = arrayexpr_fn_AST;
 	_retTree = _t;
 }
 
+void GDLTreeParser::arrayexpr_mfcall(RefDNode _t) {
+	RefDNode arrayexpr_mfcall_AST_in = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
+	returnAST = RefDNode(antlr::nullAST);
+	antlr::ASTPair currentAST;
+	RefDNode arrayexpr_mfcall_AST = RefDNode(antlr::nullAST);
+	RefDNode a = RefDNode(antlr::nullAST);
+	RefDNode a_AST = RefDNode(antlr::nullAST);
+	RefDNode e_AST = RefDNode(antlr::nullAST);
+	RefDNode e = RefDNode(antlr::nullAST);
+	RefDNode i = RefDNode(antlr::nullAST);
+	RefDNode i_AST = RefDNode(antlr::nullAST);
+	RefDNode e2_AST = RefDNode(antlr::nullAST);
+	RefDNode e2 = RefDNode(antlr::nullAST);
+	RefDNode i2 = RefDNode(antlr::nullAST);
+	RefDNode i2_AST = RefDNode(antlr::nullAST);
+	RefDNode a2_AST = RefDNode(antlr::nullAST);
+	RefDNode a2 = RefDNode(antlr::nullAST);
+	
+	RefDNode __t156 = _t;
+	a = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
+	RefDNode a_AST_in = RefDNode(antlr::nullAST);
+	a_AST = astFactory->create(antlr::RefAST(a));
+	antlr::ASTPair __currentAST156 = currentAST;
+	currentAST.root = currentAST.child;
+	currentAST.child = RefDNode(antlr::nullAST);
+	match(antlr::RefAST(_t),ARRAYEXPR_MFCALL);
+	_t = _t->getFirstChild();
+	
+	RefDNode mark = _t; // mark
+	
+	e = (_t == ASTNULL) ? RefDNode(antlr::nullAST) : _t;
+	expr(_t);
+	_t = _retTree;
+	e_AST = returnAST;
+	i = _t;
+	RefDNode i_AST_in = RefDNode(antlr::nullAST);
+	i_AST = astFactory->create(antlr::RefAST(i));
+	match(antlr::RefAST(_t),IDENTIFIER);
+	_t = _t->getNextSibling();
+	
+	bool success = true;
+	RefDNode first;
+		            try {
+	arrayindex_list(_t);
+	
+	RefDNode al = returnAST;
+	RefDNode ae = RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(ARRAYEXPR,"arrayexpr")))->add(antlr::RefAST(i_AST))->add(antlr::RefAST(al))));
+	
+	if( e->getType() == DOT)
+	{
+	int nDot = e_AST->GetNDot();
+	e_AST->SetNDot( ++nDot);
+	
+	e_AST->addChild( ae);
+	
+	first = e_AST;
+	}
+	else
+	{
+	RefDNode dot = RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(astFactory->create(DOT,".")))->add(antlr::RefAST(e_AST))->add(antlr::RefAST(ae))));
+	dot->SetNDot( 1);
+	
+	first = dot;
+	}
+	}
+	catch( GDLException& ex)
+	{
+	Message( "Ambiguity resolved: member function call "
+	"due to invalid array index.");
+	
+	success = false;
+	
+	a_AST->setType( MFCALL);
+	a_AST->setText( "mfcall");
+	}
+	
+	_t = mark; // rewind to parse again 
+	
+	e2 = (_t == ASTNULL) ? RefDNode(antlr::nullAST) : _t;
+	expr(_t);
+	_t = _retTree;
+	e2_AST = returnAST;
+	i2 = _t;
+	RefDNode i2_AST_in = RefDNode(antlr::nullAST);
+	i2_AST = astFactory->create(antlr::RefAST(i2));
+	match(antlr::RefAST(_t),IDENTIFIER);
+	_t = _t->getNextSibling();
+	a2 = (_t == ASTNULL) ? RefDNode(antlr::nullAST) : _t;
+	arrayindex_list_to_parameter_list(_t);
+	_t = _retTree;
+	a2_AST = returnAST;
+	arrayexpr_mfcall_AST = RefDNode(currentAST.root);
+	
+	if( success)
+	arrayexpr_mfcall_AST = RefDNode(astFactory->make((new antlr::ASTArray(5))->add(antlr::RefAST(a_AST))->add(antlr::RefAST(first))->add(antlr::RefAST(e2_AST))->add(antlr::RefAST(i2_AST))->add(antlr::RefAST(a2_AST))));
+	else
+	arrayexpr_mfcall_AST = RefDNode(astFactory->make((new antlr::ASTArray(4))->add(antlr::RefAST(a_AST))->add(antlr::RefAST(e2_AST))->add(antlr::RefAST(i2_AST))->add(antlr::RefAST(a2_AST))));
+	
+	currentAST.root = arrayexpr_mfcall_AST;
+	if ( arrayexpr_mfcall_AST!=RefDNode(antlr::nullAST) &&
+		arrayexpr_mfcall_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+		  currentAST.child = arrayexpr_mfcall_AST->getFirstChild();
+	else
+		currentAST.child = arrayexpr_mfcall_AST;
+	currentAST.advanceChildToEnd();
+	currentAST = __currentAST156;
+	_t = __t156;
+	_t = _t->getNextSibling();
+	returnAST = arrayexpr_mfcall_AST;
+	_retTree = _t;
+}
+
 void GDLTreeParser::primary_expr(RefDNode _t) {
 	RefDNode primary_expr_AST_in = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	returnAST = RefDNode(antlr::nullAST);
@@ -5193,6 +5536,7 @@
 	RefDNode id_AST = RefDNode(antlr::nullAST);
 	
 	int dummy;
+	RefDNode mark;
 	
 	
 	if (_t == RefDNode(antlr::nullAST) )
@@ -5232,15 +5576,23 @@
 		primary_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
+	case ARRAYEXPR_MFCALL:
+	{
+		arrayexpr_mfcall(_t);
+		_t = _retTree;
+		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
+		primary_expr_AST = RefDNode(currentAST.root);
+		break;
+	}
 	case MFCALL:
 	{
-		RefDNode __t151 = _t;
-		RefDNode tmp37_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp37_AST_in = RefDNode(antlr::nullAST);
-		tmp37_AST = astFactory->create(antlr::RefAST(_t));
-		tmp37_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp37_AST));
-		antlr::ASTPair __currentAST151 = currentAST;
+		RefDNode __t158 = _t;
+		RefDNode tmp32_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp32_AST_in = RefDNode(antlr::nullAST);
+		tmp32_AST = astFactory->create(antlr::RefAST(_t));
+		tmp32_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp32_AST));
+		antlr::ASTPair __currentAST158 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MFCALL);
@@ -5248,31 +5600,31 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		RefDNode tmp38_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp38_AST_in = RefDNode(antlr::nullAST);
-		tmp38_AST = astFactory->create(antlr::RefAST(_t));
-		tmp38_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp38_AST));
+		RefDNode tmp33_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp33_AST_in = RefDNode(antlr::nullAST);
+		tmp33_AST = astFactory->create(antlr::RefAST(_t));
+		tmp33_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp33_AST));
 		match(antlr::RefAST(_t),IDENTIFIER);
 		_t = _t->getNextSibling();
 		parameter_def(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST151;
-		_t = __t151;
+		currentAST = __currentAST158;
+		_t = __t158;
 		_t = _t->getNextSibling();
 		primary_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case MFCALL_PARENT:
 	{
-		RefDNode __t152 = _t;
-		RefDNode tmp39_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp39_AST_in = RefDNode(antlr::nullAST);
-		tmp39_AST = astFactory->create(antlr::RefAST(_t));
-		tmp39_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp39_AST));
-		antlr::ASTPair __currentAST152 = currentAST;
+		RefDNode __t159 = _t;
+		RefDNode tmp34_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp34_AST_in = RefDNode(antlr::nullAST);
+		tmp34_AST = astFactory->create(antlr::RefAST(_t));
+		tmp34_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp34_AST));
+		antlr::ASTPair __currentAST159 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MFCALL_PARENT);
@@ -5280,37 +5632,37 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		RefDNode tmp40_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp40_AST_in = RefDNode(antlr::nullAST);
-		tmp40_AST = astFactory->create(antlr::RefAST(_t));
-		tmp40_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp40_AST));
+		RefDNode tmp35_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp35_AST_in = RefDNode(antlr::nullAST);
+		tmp35_AST = astFactory->create(antlr::RefAST(_t));
+		tmp35_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp35_AST));
 		match(antlr::RefAST(_t),IDENTIFIER);
 		_t = _t->getNextSibling();
-		RefDNode tmp41_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp41_AST_in = RefDNode(antlr::nullAST);
-		tmp41_AST = astFactory->create(antlr::RefAST(_t));
-		tmp41_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp41_AST));
+		RefDNode tmp36_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp36_AST_in = RefDNode(antlr::nullAST);
+		tmp36_AST = astFactory->create(antlr::RefAST(_t));
+		tmp36_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp36_AST));
 		match(antlr::RefAST(_t),IDENTIFIER);
 		_t = _t->getNextSibling();
 		parameter_def(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST152;
-		_t = __t152;
+		currentAST = __currentAST159;
+		_t = __t159;
 		_t = _t->getNextSibling();
 		primary_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case FCALL:
 	{
-		RefDNode __t153 = _t;
+		RefDNode __t160 = _t;
 		f = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 		RefDNode f_AST_in = RefDNode(antlr::nullAST);
 		f_AST = astFactory->create(antlr::RefAST(f));
 		astFactory->addASTChild(currentAST, antlr::RefAST(f_AST));
-		antlr::ASTPair __currentAST153 = currentAST;
+		antlr::ASTPair __currentAST160 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),FCALL);
@@ -5328,6 +5680,16 @@
 		int i=LibFunIx(id->getText());
 		if( i != -1)
 		{
+		// N_ELEMENTS must handle exceptions during parameter evaluation
+		//                     if( StrUpCase( #id->getText()) == "N_ELEMENTS")
+		//                     {
+		//                     #f->setType(FCALL_LIB_N_ELEMENTS);
+		//                     #f->setText(#id->getText());
+		//                     #f->SetLibFun( libFunList[i]);
+		//                         //                    #id->SetFunIx(i);
+		//                     }
+		//                     else
+		{
 		if( libFunList[ i]->RetNew())
 		{
 		f_AST->setType(FCALL_LIB_RETNEW);
@@ -5343,6 +5705,7 @@
 		//                    #id->SetFunIx(i);
 		}
 		}
+		}
 		else
 		{
 		// then search user defined functions
@@ -5352,8 +5715,8 @@
 		f_AST->SetFunIx(i);
 		}
 		
-		currentAST = __currentAST153;
-		_t = __t153;
+		currentAST = __currentAST160;
+		_t = __t160;
 		_t = _t->getNextSibling();
 		primary_expr_AST = RefDNode(currentAST.root);
 		break;
@@ -5368,11 +5731,11 @@
 	}
 	case CONSTANT:
 	{
-		RefDNode tmp42_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp42_AST_in = RefDNode(antlr::nullAST);
-		tmp42_AST = astFactory->create(antlr::RefAST(_t));
-		tmp42_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp42_AST));
+		RefDNode tmp37_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp37_AST_in = RefDNode(antlr::nullAST);
+		tmp37_AST = astFactory->create(antlr::RefAST(_t));
+		tmp37_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp37_AST));
 		match(antlr::RefAST(_t),CONSTANT);
 		_t = _t->getNextSibling();
 		primary_expr_AST = RefDNode(currentAST.root);
@@ -5416,13 +5779,13 @@
 	switch ( _t->getType()) {
 	case QUESTION:
 	{
-		RefDNode __t155 = _t;
-		RefDNode tmp43_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp43_AST_in = RefDNode(antlr::nullAST);
-		tmp43_AST = astFactory->create(antlr::RefAST(_t));
-		tmp43_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp43_AST));
-		antlr::ASTPair __currentAST155 = currentAST;
+		RefDNode __t162 = _t;
+		RefDNode tmp38_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp38_AST_in = RefDNode(antlr::nullAST);
+		tmp38_AST = astFactory->create(antlr::RefAST(_t));
+		tmp38_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp38_AST));
+		antlr::ASTPair __currentAST162 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),QUESTION);
@@ -5436,21 +5799,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST155;
-		_t = __t155;
+		currentAST = __currentAST162;
+		_t = __t162;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case AND_OP:
 	{
-		RefDNode __t156 = _t;
-		RefDNode tmp44_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp44_AST_in = RefDNode(antlr::nullAST);
-		tmp44_AST = astFactory->create(antlr::RefAST(_t));
-		tmp44_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp44_AST));
-		antlr::ASTPair __currentAST156 = currentAST;
+		RefDNode __t163 = _t;
+		RefDNode tmp39_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp39_AST_in = RefDNode(antlr::nullAST);
+		tmp39_AST = astFactory->create(antlr::RefAST(_t));
+		tmp39_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp39_AST));
+		antlr::ASTPair __currentAST163 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),AND_OP);
@@ -5461,21 +5824,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST156;
-		_t = __t156;
+		currentAST = __currentAST163;
+		_t = __t163;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case OR_OP:
 	{
-		RefDNode __t157 = _t;
-		RefDNode tmp45_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp45_AST_in = RefDNode(antlr::nullAST);
-		tmp45_AST = astFactory->create(antlr::RefAST(_t));
-		tmp45_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp45_AST));
-		antlr::ASTPair __currentAST157 = currentAST;
+		RefDNode __t164 = _t;
+		RefDNode tmp40_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp40_AST_in = RefDNode(antlr::nullAST);
+		tmp40_AST = astFactory->create(antlr::RefAST(_t));
+		tmp40_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp40_AST));
+		antlr::ASTPair __currentAST164 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),OR_OP);
@@ -5486,21 +5849,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST157;
-		_t = __t157;
+		currentAST = __currentAST164;
+		_t = __t164;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case XOR_OP:
 	{
-		RefDNode __t158 = _t;
-		RefDNode tmp46_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp46_AST_in = RefDNode(antlr::nullAST);
-		tmp46_AST = astFactory->create(antlr::RefAST(_t));
-		tmp46_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp46_AST));
-		antlr::ASTPair __currentAST158 = currentAST;
+		RefDNode __t165 = _t;
+		RefDNode tmp41_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp41_AST_in = RefDNode(antlr::nullAST);
+		tmp41_AST = astFactory->create(antlr::RefAST(_t));
+		tmp41_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp41_AST));
+		antlr::ASTPair __currentAST165 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),XOR_OP);
@@ -5511,21 +5874,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST158;
-		_t = __t158;
+		currentAST = __currentAST165;
+		_t = __t165;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case LOG_AND:
 	{
-		RefDNode __t159 = _t;
-		RefDNode tmp47_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp47_AST_in = RefDNode(antlr::nullAST);
-		tmp47_AST = astFactory->create(antlr::RefAST(_t));
-		tmp47_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp47_AST));
-		antlr::ASTPair __currentAST159 = currentAST;
+		RefDNode __t166 = _t;
+		RefDNode tmp42_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp42_AST_in = RefDNode(antlr::nullAST);
+		tmp42_AST = astFactory->create(antlr::RefAST(_t));
+		tmp42_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp42_AST));
+		antlr::ASTPair __currentAST166 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LOG_AND);
@@ -5536,21 +5899,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST159;
-		_t = __t159;
+		currentAST = __currentAST166;
+		_t = __t166;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case LOG_OR:
 	{
-		RefDNode __t160 = _t;
-		RefDNode tmp48_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp48_AST_in = RefDNode(antlr::nullAST);
-		tmp48_AST = astFactory->create(antlr::RefAST(_t));
-		tmp48_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp48_AST));
-		antlr::ASTPair __currentAST160 = currentAST;
+		RefDNode __t167 = _t;
+		RefDNode tmp43_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp43_AST_in = RefDNode(antlr::nullAST);
+		tmp43_AST = astFactory->create(antlr::RefAST(_t));
+		tmp43_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp43_AST));
+		antlr::ASTPair __currentAST167 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LOG_OR);
@@ -5561,21 +5924,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST160;
-		_t = __t160;
+		currentAST = __currentAST167;
+		_t = __t167;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case EQ_OP:
 	{
-		RefDNode __t161 = _t;
-		RefDNode tmp49_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp49_AST_in = RefDNode(antlr::nullAST);
-		tmp49_AST = astFactory->create(antlr::RefAST(_t));
-		tmp49_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp49_AST));
-		antlr::ASTPair __currentAST161 = currentAST;
+		RefDNode __t168 = _t;
+		RefDNode tmp44_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp44_AST_in = RefDNode(antlr::nullAST);
+		tmp44_AST = astFactory->create(antlr::RefAST(_t));
+		tmp44_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp44_AST));
+		antlr::ASTPair __currentAST168 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),EQ_OP);
@@ -5586,21 +5949,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST161;
-		_t = __t161;
+		currentAST = __currentAST168;
+		_t = __t168;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case NE_OP:
 	{
-		RefDNode __t162 = _t;
-		RefDNode tmp50_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp50_AST_in = RefDNode(antlr::nullAST);
-		tmp50_AST = astFactory->create(antlr::RefAST(_t));
-		tmp50_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp50_AST));
-		antlr::ASTPair __currentAST162 = currentAST;
+		RefDNode __t169 = _t;
+		RefDNode tmp45_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp45_AST_in = RefDNode(antlr::nullAST);
+		tmp45_AST = astFactory->create(antlr::RefAST(_t));
+		tmp45_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp45_AST));
+		antlr::ASTPair __currentAST169 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),NE_OP);
@@ -5611,21 +5974,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST162;
-		_t = __t162;
+		currentAST = __currentAST169;
+		_t = __t169;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case LE_OP:
 	{
-		RefDNode __t163 = _t;
-		RefDNode tmp51_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp51_AST_in = RefDNode(antlr::nullAST);
-		tmp51_AST = astFactory->create(antlr::RefAST(_t));
-		tmp51_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp51_AST));
-		antlr::ASTPair __currentAST163 = currentAST;
+		RefDNode __t170 = _t;
+		RefDNode tmp46_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp46_AST_in = RefDNode(antlr::nullAST);
+		tmp46_AST = astFactory->create(antlr::RefAST(_t));
+		tmp46_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp46_AST));
+		antlr::ASTPair __currentAST170 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LE_OP);
@@ -5636,21 +5999,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST163;
-		_t = __t163;
+		currentAST = __currentAST170;
+		_t = __t170;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case LT_OP:
 	{
-		RefDNode __t164 = _t;
-		RefDNode tmp52_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp52_AST_in = RefDNode(antlr::nullAST);
-		tmp52_AST = astFactory->create(antlr::RefAST(_t));
-		tmp52_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp52_AST));
-		antlr::ASTPair __currentAST164 = currentAST;
+		RefDNode __t171 = _t;
+		RefDNode tmp47_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp47_AST_in = RefDNode(antlr::nullAST);
+		tmp47_AST = astFactory->create(antlr::RefAST(_t));
+		tmp47_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp47_AST));
+		antlr::ASTPair __currentAST171 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LT_OP);
@@ -5661,21 +6024,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST164;
-		_t = __t164;
+		currentAST = __currentAST171;
+		_t = __t171;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case GE_OP:
 	{
-		RefDNode __t165 = _t;
-		RefDNode tmp53_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp53_AST_in = RefDNode(antlr::nullAST);
-		tmp53_AST = astFactory->create(antlr::RefAST(_t));
-		tmp53_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp53_AST));
-		antlr::ASTPair __currentAST165 = currentAST;
+		RefDNode __t172 = _t;
+		RefDNode tmp48_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp48_AST_in = RefDNode(antlr::nullAST);
+		tmp48_AST = astFactory->create(antlr::RefAST(_t));
+		tmp48_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp48_AST));
+		antlr::ASTPair __currentAST172 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),GE_OP);
@@ -5686,21 +6049,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST165;
-		_t = __t165;
+		currentAST = __currentAST172;
+		_t = __t172;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case GT_OP:
 	{
-		RefDNode __t166 = _t;
-		RefDNode tmp54_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp54_AST_in = RefDNode(antlr::nullAST);
-		tmp54_AST = astFactory->create(antlr::RefAST(_t));
-		tmp54_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp54_AST));
-		antlr::ASTPair __currentAST166 = currentAST;
+		RefDNode __t173 = _t;
+		RefDNode tmp49_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp49_AST_in = RefDNode(antlr::nullAST);
+		tmp49_AST = astFactory->create(antlr::RefAST(_t));
+		tmp49_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp49_AST));
+		antlr::ASTPair __currentAST173 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),GT_OP);
@@ -5711,21 +6074,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST166;
-		_t = __t166;
+		currentAST = __currentAST173;
+		_t = __t173;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case NOT_OP:
 	{
-		RefDNode __t167 = _t;
-		RefDNode tmp55_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp55_AST_in = RefDNode(antlr::nullAST);
-		tmp55_AST = astFactory->create(antlr::RefAST(_t));
-		tmp55_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp55_AST));
-		antlr::ASTPair __currentAST167 = currentAST;
+		RefDNode __t174 = _t;
+		RefDNode tmp50_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp50_AST_in = RefDNode(antlr::nullAST);
+		tmp50_AST = astFactory->create(antlr::RefAST(_t));
+		tmp50_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp50_AST));
+		antlr::ASTPair __currentAST174 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),NOT_OP);
@@ -5733,21 +6096,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST167;
-		_t = __t167;
+		currentAST = __currentAST174;
+		_t = __t174;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case PLUS:
 	{
-		RefDNode __t168 = _t;
-		RefDNode tmp56_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp56_AST_in = RefDNode(antlr::nullAST);
-		tmp56_AST = astFactory->create(antlr::RefAST(_t));
-		tmp56_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp56_AST));
-		antlr::ASTPair __currentAST168 = currentAST;
+		RefDNode __t175 = _t;
+		RefDNode tmp51_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp51_AST_in = RefDNode(antlr::nullAST);
+		tmp51_AST = astFactory->create(antlr::RefAST(_t));
+		tmp51_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp51_AST));
+		antlr::ASTPair __currentAST175 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),PLUS);
@@ -5758,21 +6121,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST168;
-		_t = __t168;
+		currentAST = __currentAST175;
+		_t = __t175;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case MINUS:
 	{
-		RefDNode __t169 = _t;
-		RefDNode tmp57_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp57_AST_in = RefDNode(antlr::nullAST);
-		tmp57_AST = astFactory->create(antlr::RefAST(_t));
-		tmp57_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp57_AST));
-		antlr::ASTPair __currentAST169 = currentAST;
+		RefDNode __t176 = _t;
+		RefDNode tmp52_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp52_AST_in = RefDNode(antlr::nullAST);
+		tmp52_AST = astFactory->create(antlr::RefAST(_t));
+		tmp52_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp52_AST));
+		antlr::ASTPair __currentAST176 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MINUS);
@@ -5783,21 +6146,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST169;
-		_t = __t169;
+		currentAST = __currentAST176;
+		_t = __t176;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case LTMARK:
 	{
-		RefDNode __t170 = _t;
-		RefDNode tmp58_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp58_AST_in = RefDNode(antlr::nullAST);
-		tmp58_AST = astFactory->create(antlr::RefAST(_t));
-		tmp58_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp58_AST));
-		antlr::ASTPair __currentAST170 = currentAST;
+		RefDNode __t177 = _t;
+		RefDNode tmp53_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp53_AST_in = RefDNode(antlr::nullAST);
+		tmp53_AST = astFactory->create(antlr::RefAST(_t));
+		tmp53_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp53_AST));
+		antlr::ASTPair __currentAST177 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LTMARK);
@@ -5808,21 +6171,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST170;
-		_t = __t170;
+		currentAST = __currentAST177;
+		_t = __t177;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case GTMARK:
 	{
-		RefDNode __t171 = _t;
-		RefDNode tmp59_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp59_AST_in = RefDNode(antlr::nullAST);
-		tmp59_AST = astFactory->create(antlr::RefAST(_t));
-		tmp59_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp59_AST));
-		antlr::ASTPair __currentAST171 = currentAST;
+		RefDNode __t178 = _t;
+		RefDNode tmp54_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp54_AST_in = RefDNode(antlr::nullAST);
+		tmp54_AST = astFactory->create(antlr::RefAST(_t));
+		tmp54_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp54_AST));
+		antlr::ASTPair __currentAST178 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),GTMARK);
@@ -5833,8 +6196,8 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST171;
-		_t = __t171;
+		currentAST = __currentAST178;
+		_t = __t178;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
@@ -5849,13 +6212,13 @@
 	}
 	case LOG_NEG:
 	{
-		RefDNode __t172 = _t;
-		RefDNode tmp60_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp60_AST_in = RefDNode(antlr::nullAST);
-		tmp60_AST = astFactory->create(antlr::RefAST(_t));
-		tmp60_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp60_AST));
-		antlr::ASTPair __currentAST172 = currentAST;
+		RefDNode __t179 = _t;
+		RefDNode tmp55_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp55_AST_in = RefDNode(antlr::nullAST);
+		tmp55_AST = astFactory->create(antlr::RefAST(_t));
+		tmp55_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp55_AST));
+		antlr::ASTPair __currentAST179 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),LOG_NEG);
@@ -5863,21 +6226,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST172;
-		_t = __t172;
+		currentAST = __currentAST179;
+		_t = __t179;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case ASTERIX:
 	{
-		RefDNode __t173 = _t;
-		RefDNode tmp61_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp61_AST_in = RefDNode(antlr::nullAST);
-		tmp61_AST = astFactory->create(antlr::RefAST(_t));
-		tmp61_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp61_AST));
-		antlr::ASTPair __currentAST173 = currentAST;
+		RefDNode __t180 = _t;
+		RefDNode tmp56_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp56_AST_in = RefDNode(antlr::nullAST);
+		tmp56_AST = astFactory->create(antlr::RefAST(_t));
+		tmp56_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp56_AST));
+		antlr::ASTPair __currentAST180 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ASTERIX);
@@ -5888,21 +6251,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST173;
-		_t = __t173;
+		currentAST = __currentAST180;
+		_t = __t180;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case MATRIX_OP1:
 	{
-		RefDNode __t174 = _t;
-		RefDNode tmp62_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp62_AST_in = RefDNode(antlr::nullAST);
-		tmp62_AST = astFactory->create(antlr::RefAST(_t));
-		tmp62_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp62_AST));
-		antlr::ASTPair __currentAST174 = currentAST;
+		RefDNode __t181 = _t;
+		RefDNode tmp57_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp57_AST_in = RefDNode(antlr::nullAST);
+		tmp57_AST = astFactory->create(antlr::RefAST(_t));
+		tmp57_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp57_AST));
+		antlr::ASTPair __currentAST181 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MATRIX_OP1);
@@ -5913,21 +6276,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST174;
-		_t = __t174;
+		currentAST = __currentAST181;
+		_t = __t181;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case MATRIX_OP2:
 	{
-		RefDNode __t175 = _t;
-		RefDNode tmp63_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp63_AST_in = RefDNode(antlr::nullAST);
-		tmp63_AST = astFactory->create(antlr::RefAST(_t));
-		tmp63_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp63_AST));
-		antlr::ASTPair __currentAST175 = currentAST;
+		RefDNode __t182 = _t;
+		RefDNode tmp58_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp58_AST_in = RefDNode(antlr::nullAST);
+		tmp58_AST = astFactory->create(antlr::RefAST(_t));
+		tmp58_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp58_AST));
+		antlr::ASTPair __currentAST182 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MATRIX_OP2);
@@ -5938,21 +6301,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST175;
-		_t = __t175;
+		currentAST = __currentAST182;
+		_t = __t182;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case SLASH:
 	{
-		RefDNode __t176 = _t;
-		RefDNode tmp64_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp64_AST_in = RefDNode(antlr::nullAST);
-		tmp64_AST = astFactory->create(antlr::RefAST(_t));
-		tmp64_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp64_AST));
-		antlr::ASTPair __currentAST176 = currentAST;
+		RefDNode __t183 = _t;
+		RefDNode tmp59_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp59_AST_in = RefDNode(antlr::nullAST);
+		tmp59_AST = astFactory->create(antlr::RefAST(_t));
+		tmp59_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp59_AST));
+		antlr::ASTPair __currentAST183 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),SLASH);
@@ -5963,21 +6326,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST176;
-		_t = __t176;
+		currentAST = __currentAST183;
+		_t = __t183;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case MOD_OP:
 	{
-		RefDNode __t177 = _t;
-		RefDNode tmp65_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp65_AST_in = RefDNode(antlr::nullAST);
-		tmp65_AST = astFactory->create(antlr::RefAST(_t));
-		tmp65_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp65_AST));
-		antlr::ASTPair __currentAST177 = currentAST;
+		RefDNode __t184 = _t;
+		RefDNode tmp60_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp60_AST_in = RefDNode(antlr::nullAST);
+		tmp60_AST = astFactory->create(antlr::RefAST(_t));
+		tmp60_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp60_AST));
+		antlr::ASTPair __currentAST184 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),MOD_OP);
@@ -5988,21 +6351,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST177;
-		_t = __t177;
+		currentAST = __currentAST184;
+		_t = __t184;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case POW:
 	{
-		RefDNode __t178 = _t;
-		RefDNode tmp66_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp66_AST_in = RefDNode(antlr::nullAST);
-		tmp66_AST = astFactory->create(antlr::RefAST(_t));
-		tmp66_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp66_AST));
-		antlr::ASTPair __currentAST178 = currentAST;
+		RefDNode __t185 = _t;
+		RefDNode tmp61_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp61_AST_in = RefDNode(antlr::nullAST);
+		tmp61_AST = astFactory->create(antlr::RefAST(_t));
+		tmp61_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp61_AST));
+		antlr::ASTPair __currentAST185 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),POW);
@@ -6013,21 +6376,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST178;
-		_t = __t178;
+		currentAST = __currentAST185;
+		_t = __t185;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case DEC:
 	{
-		RefDNode __t179 = _t;
-		RefDNode tmp67_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp67_AST_in = RefDNode(antlr::nullAST);
-		tmp67_AST = astFactory->create(antlr::RefAST(_t));
-		tmp67_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp67_AST));
-		antlr::ASTPair __currentAST179 = currentAST;
+		RefDNode __t186 = _t;
+		RefDNode tmp62_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp62_AST_in = RefDNode(antlr::nullAST);
+		tmp62_AST = astFactory->create(antlr::RefAST(_t));
+		tmp62_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp62_AST));
+		antlr::ASTPair __currentAST186 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),DEC);
@@ -6035,21 +6398,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST179;
-		_t = __t179;
+		currentAST = __currentAST186;
+		_t = __t186;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case INC:
 	{
-		RefDNode __t180 = _t;
-		RefDNode tmp68_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp68_AST_in = RefDNode(antlr::nullAST);
-		tmp68_AST = astFactory->create(antlr::RefAST(_t));
-		tmp68_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp68_AST));
-		antlr::ASTPair __currentAST180 = currentAST;
+		RefDNode __t187 = _t;
+		RefDNode tmp63_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp63_AST_in = RefDNode(antlr::nullAST);
+		tmp63_AST = astFactory->create(antlr::RefAST(_t));
+		tmp63_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp63_AST));
+		antlr::ASTPair __currentAST187 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),INC);
@@ -6057,21 +6420,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST180;
-		_t = __t180;
+		currentAST = __currentAST187;
+		_t = __t187;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case POSTDEC:
 	{
-		RefDNode __t181 = _t;
-		RefDNode tmp69_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp69_AST_in = RefDNode(antlr::nullAST);
-		tmp69_AST = astFactory->create(antlr::RefAST(_t));
-		tmp69_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp69_AST));
-		antlr::ASTPair __currentAST181 = currentAST;
+		RefDNode __t188 = _t;
+		RefDNode tmp64_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp64_AST_in = RefDNode(antlr::nullAST);
+		tmp64_AST = astFactory->create(antlr::RefAST(_t));
+		tmp64_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp64_AST));
+		antlr::ASTPair __currentAST188 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),POSTDEC);
@@ -6079,21 +6442,21 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST181;
-		_t = __t181;
+		currentAST = __currentAST188;
+		_t = __t188;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
 	}
 	case POSTINC:
 	{
-		RefDNode __t182 = _t;
-		RefDNode tmp70_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp70_AST_in = RefDNode(antlr::nullAST);
-		tmp70_AST = astFactory->create(antlr::RefAST(_t));
-		tmp70_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp70_AST));
-		antlr::ASTPair __currentAST182 = currentAST;
+		RefDNode __t189 = _t;
+		RefDNode tmp65_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp65_AST_in = RefDNode(antlr::nullAST);
+		tmp65_AST = astFactory->create(antlr::RefAST(_t));
+		tmp65_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp65_AST));
+		antlr::ASTPair __currentAST189 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),POSTINC);
@@ -6101,8 +6464,8 @@
 		expr(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST182;
-		_t = __t182;
+		currentAST = __currentAST189;
+		_t = __t189;
 		_t = _t->getNextSibling();
 		op_expr_AST = RefDNode(currentAST.root);
 		break;
@@ -6111,6 +6474,7 @@
 	case ARRAYDEF:
 	case ARRAYDEF_CONST:
 	case ARRAYEXPR_FN:
+	case ARRAYEXPR_MFCALL:
 	case CONSTANT:
 	case FCALL:
 	case MFCALL:
@@ -6162,12 +6526,12 @@
 	RefDNode e_AST = RefDNode(antlr::nullAST);
 	RefDNode e = RefDNode(antlr::nullAST);
 	
-	RefDNode __t184 = _t;
+	RefDNode __t191 = _t;
 	u = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode u_AST_in = RefDNode(antlr::nullAST);
 	u_AST = astFactory->create(antlr::RefAST(u));
 	astFactory->addASTChild(currentAST, antlr::RefAST(u_AST));
-	antlr::ASTPair __currentAST184 = currentAST;
+	antlr::ASTPair __currentAST191 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),UMINUS);
@@ -6177,8 +6541,8 @@
 	_t = _retTree;
 	e_AST = returnAST;
 	astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-	currentAST = __currentAST184;
-	_t = __t184;
+	currentAST = __currentAST191;
+	_t = __t191;
 	_t = _t->getNextSibling();
 	uminus_AST = RefDNode(currentAST.root);
 	
@@ -6216,11 +6580,11 @@
 	RefDNode ex_AST = RefDNode(antlr::nullAST);
 	RefDNode ex = RefDNode(antlr::nullAST);
 	
-	RefDNode __t186 = _t;
+	RefDNode __t193 = _t;
 	e = (_t == RefDNode(ASTNULL)) ? RefDNode(antlr::nullAST) : _t;
 	RefDNode e_AST_in = RefDNode(antlr::nullAST);
 	e_AST = astFactory->create(antlr::RefAST(e));
-	antlr::ASTPair __currentAST186 = currentAST;
+	antlr::ASTPair __currentAST193 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),EXPR);
@@ -6229,8 +6593,8 @@
 	expr(_t);
 	_t = _retTree;
 	ex_AST = returnAST;
-	currentAST = __currentAST186;
-	_t = __t186;
+	currentAST = __currentAST193;
+	_t = __t193;
 	_t = _t->getNextSibling();
 	brace_expr_AST = RefDNode(currentAST.root);
 	
@@ -6257,12 +6621,12 @@
 	RefDNode ex_AST = RefDNode(antlr::nullAST);
 	RefDNode ex = RefDNode(antlr::nullAST);
 	
-	RefDNode __t188 = _t;
-	RefDNode tmp71_AST = RefDNode(antlr::nullAST);
-	RefDNode tmp71_AST_in = RefDNode(antlr::nullAST);
-	tmp71_AST = astFactory->create(antlr::RefAST(_t));
-	tmp71_AST_in = _t;
-	antlr::ASTPair __currentAST188 = currentAST;
+	RefDNode __t195 = _t;
+	RefDNode tmp66_AST = RefDNode(antlr::nullAST);
+	RefDNode tmp66_AST_in = RefDNode(antlr::nullAST);
+	tmp66_AST = astFactory->create(antlr::RefAST(_t));
+	tmp66_AST_in = _t;
+	antlr::ASTPair __currentAST195 = currentAST;
 	currentAST.root = currentAST.child;
 	currentAST.child = RefDNode(antlr::nullAST);
 	match(antlr::RefAST(_t),EXPR);
@@ -6271,8 +6635,8 @@
 	expr(_t);
 	_t = _retTree;
 	ex_AST = returnAST;
-	currentAST = __currentAST188;
-	_t = __t188;
+	currentAST = __currentAST195;
+	_t = __t195;
 	_t = _t->getNextSibling();
 	unbrace_expr_AST = RefDNode(currentAST.root);
 	
@@ -6344,13 +6708,13 @@
 	switch ( _t->getType()) {
 	case ARRAYEXPR:
 	{
-		RefDNode __t191 = _t;
-		RefDNode tmp72_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp72_AST_in = RefDNode(antlr::nullAST);
-		tmp72_AST = astFactory->create(antlr::RefAST(_t));
-		tmp72_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp72_AST));
-		antlr::ASTPair __currentAST191 = currentAST;
+		RefDNode __t198 = _t;
+		RefDNode tmp67_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp67_AST_in = RefDNode(antlr::nullAST);
+		tmp67_AST = astFactory->create(antlr::RefAST(_t));
+		tmp67_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp67_AST));
+		antlr::ASTPair __currentAST198 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ARRAYEXPR);
@@ -6361,8 +6725,8 @@
 		arrayindex_list(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST191;
-		_t = __t191;
+		currentAST = __currentAST198;
+		_t = __t198;
 		_t = _t->getNextSibling();
 		array_expr_AST = RefDNode(currentAST.root);
 		break;
@@ -6439,13 +6803,13 @@
 	switch ( _t->getType()) {
 	case ARRAYEXPR:
 	{
-		RefDNode __t194 = _t;
-		RefDNode tmp73_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp73_AST_in = RefDNode(antlr::nullAST);
-		tmp73_AST = astFactory->create(antlr::RefAST(_t));
-		tmp73_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp73_AST));
-		antlr::ASTPair __currentAST194 = currentAST;
+		RefDNode __t201 = _t;
+		RefDNode tmp68_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp68_AST_in = RefDNode(antlr::nullAST);
+		tmp68_AST = astFactory->create(antlr::RefAST(_t));
+		tmp68_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp68_AST));
+		antlr::ASTPair __currentAST201 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ARRAYEXPR);
@@ -6456,8 +6820,8 @@
 		arrayindex_list(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST194;
-		_t = __t194;
+		currentAST = __currentAST201;
+		_t = __t201;
 		_t = _t->getNextSibling();
 		tag_array_expr_1st_AST = RefDNode(currentAST.root);
 		break;
@@ -6500,11 +6864,11 @@
 	}
 	case IDENTIFIER:
 	{
-		RefDNode tmp74_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp74_AST_in = RefDNode(antlr::nullAST);
-		tmp74_AST = astFactory->create(antlr::RefAST(_t));
-		tmp74_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp74_AST));
+		RefDNode tmp69_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp69_AST_in = RefDNode(antlr::nullAST);
+		tmp69_AST = astFactory->create(antlr::RefAST(_t));
+		tmp69_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp69_AST));
 		match(antlr::RefAST(_t),IDENTIFIER);
 		_t = _t->getNextSibling();
 		tag_expr_AST = RefDNode(currentAST.root);
@@ -6530,13 +6894,13 @@
 	switch ( _t->getType()) {
 	case ARRAYEXPR:
 	{
-		RefDNode __t197 = _t;
-		RefDNode tmp75_AST = RefDNode(antlr::nullAST);
-		RefDNode tmp75_AST_in = RefDNode(antlr::nullAST);
-		tmp75_AST = astFactory->create(antlr::RefAST(_t));
-		tmp75_AST_in = _t;
-		astFactory->addASTChild(currentAST, antlr::RefAST(tmp75_AST));
-		antlr::ASTPair __currentAST197 = currentAST;
+		RefDNode __t204 = _t;
+		RefDNode tmp70_AST = RefDNode(antlr::nullAST);
+		RefDNode tmp70_AST_in = RefDNode(antlr::nullAST);
+		tmp70_AST = astFactory->create(antlr::RefAST(_t));
+		tmp70_AST_in = _t;
+		astFactory->addASTChild(currentAST, antlr::RefAST(tmp70_AST));
+		antlr::ASTPair __currentAST204 = currentAST;
 		currentAST.root = currentAST.child;
 		currentAST.child = RefDNode(antlr::nullAST);
 		match(antlr::RefAST(_t),ARRAYEXPR);
@@ -6547,8 +6911,8 @@
 		arrayindex_list(_t);
 		_t = _retTree;
 		astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-		currentAST = __currentAST197;
-		_t = __t197;
+		currentAST = __currentAST204;
+		_t = __t204;
 		_t = _t->getNextSibling();
 		tag_array_expr_AST = RefDNode(currentAST.root);
 		break;
@@ -6573,7 +6937,7 @@
 
 void GDLTreeParser::initializeASTFactory( antlr::ASTFactory& factory )
 {
-	factory.setMaxNodeType(215);
+	factory.setMaxNodeType(224);
 }
 const char* GDLTreeParser::tokenNames[] = {
 	"<0>",
@@ -6584,6 +6948,7 @@
 	"ASSIGN",
 	"ASSIGN_INPLACE",
 	"ASSIGN_REPLACE",
+	"ASSIGN_ARRAYEXPR_MFCALL",
 	"ARRAYDEF",
 	"ARRAYDEF_CONST",
 	"ARRAYIX",
@@ -6594,8 +6959,10 @@
 	"ARRAYIX_RANGE_S",
 	"ARRAYEXPR",
 	"ARRAYEXPR_FN",
+	"ARRAYEXPR_MFCALL",
 	"BLOCK",
 	"BREAK",
+	"CSBLOCK",
 	"CONTINUE",
 	"COMMONDECL",
 	"COMMONDEF",
@@ -6603,7 +6970,12 @@
 	"DEREF",
 	"ELSEBLK",
 	"EXPR",
+	"\"for\"",
 	"FOR_STEP",
+	"\"foreach\"",
+	"FOR_LOOP",
+	"FOR_STEP_LOOP",
+	"FOREACH_LOOP",
 	"FCALL",
 	"FCALL_LIB",
 	"FCALL_LIB_RETNEW",
@@ -6637,6 +7009,8 @@
 	"REF",
 	"REF_CHECK",
 	"REF_EXPR",
+	"\"repeat\"",
+	"REPEAT_LOOP",
 	"RETURN",
 	"RETF",
 	"RETP",
@@ -6645,6 +7019,7 @@
 	"UMINUS",
 	"VAR",
 	"VARPTR",
+	"\"while\"",
 	"IDENTIFIER",
 	"\"and\"",
 	"\"begin\"",
@@ -6657,12 +7032,12 @@
 	"\"endcase\"",
 	"\"endelse\"",
 	"\"endfor\"",
+	"\"endforeach\"",
 	"\"endif\"",
 	"\"endrep\"",
 	"\"endswitch\"",
 	"\"endwhile\"",
 	"\"eq\"",
-	"\"for\"",
 	"\"forward_function\"",
 	"\"function\"",
 	"\"ge\"",
@@ -6679,11 +7054,9 @@
 	"\"on_ioerror\"",
 	"\"or\"",
 	"\"pro\"",
-	"\"repeat\"",
 	"\"switch\"",
 	"\"then\"",
 	"\"until\"",
-	"\"while\"",
 	"\"xor\"",
 	"METHOD",
 	"COMMA",
@@ -6795,21 +7168,23 @@
 	0
 };
 
-const unsigned long GDLTreeParser::_tokenSet_0_data_[] = { 8126496UL, 537133248UL, 348127488UL, 4294707600UL, 127UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
-// ASSIGN BLOCK BREAK CONTINUE COMMONDECL COMMONDEF MPCALL MPCALL_PARENT 
-// PCALL RETURN "case" "for" "forward_function" "goto" "if" "on_ioerror" 
-// "repeat" "switch" "while" DEC INC AND_OP_EQ ASTERIX_EQ EQ_OP_EQ GE_OP_EQ 
-// GTMARK_EQ GT_OP_EQ LE_OP_EQ LTMARK_EQ LT_OP_EQ MATRIX_OP1_EQ MATRIX_OP2_EQ 
-// MINUS_EQ MOD_OP_EQ NE_OP_EQ OR_OP_EQ PLUS_EQ POW_EQ SLASH_EQ XOR_OP_EQ 
+const unsigned long GDLTreeParser::_tokenSet_0_data_[] = { 1135607840UL, 67158017UL, 557216UL, 4161044644UL, 65535UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+// ASSIGN BLOCK BREAK CONTINUE COMMONDECL COMMONDEF "for" "foreach" MPCALL 
+// MPCALL_PARENT PCALL "repeat" RETURN "while" "case" "forward_function" 
+// "goto" "if" "on_ioerror" "switch" DEC INC AND_OP_EQ ASTERIX_EQ EQ_OP_EQ 
+// GE_OP_EQ GTMARK_EQ GT_OP_EQ LE_OP_EQ LTMARK_EQ LT_OP_EQ MATRIX_OP1_EQ 
+// MATRIX_OP2_EQ MINUS_EQ MOD_OP_EQ NE_OP_EQ OR_OP_EQ PLUS_EQ POW_EQ SLASH_EQ 
+// XOR_OP_EQ 
 const antlr::BitSet GDLTreeParser::_tokenSet_0(_tokenSet_0_data_,12);
-const unsigned long GDLTreeParser::_tokenSet_1_data_[] = { 360907552UL, 12650752UL, 3391094863UL, 4294709287UL, 1151UL, 4253024256UL, 31UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
-// ASSIGN ARRAYDEF ARRAYDEF_CONST ARRAYEXPR ARRAYEXPR_FN CONSTANT DEREF 
-// EXPR FCALL MFCALL MFCALL_PARENT NSTRUC_REF POSTDEC POSTINC STRUC SYSVAR 
-// UMINUS VAR "and" "eq" "ge" "gt" "le" "lt" "mod" "ne" "not" "or" "xor" 
-// DEC INC AND_OP_EQ ASTERIX_EQ EQ_OP_EQ GE_OP_EQ GTMARK_EQ GT_OP_EQ LE_OP_EQ 
-// LTMARK_EQ LT_OP_EQ MATRIX_OP1_EQ MATRIX_OP2_EQ MINUS_EQ MOD_OP_EQ NE_OP_EQ 
-// OR_OP_EQ PLUS_EQ POW_EQ SLASH_EQ XOR_OP_EQ SLASH ASTERIX DOT POW MATRIX_OP1 
-// MATRIX_OP2 PLUS MINUS LTMARK GTMARK LOG_NEG LOG_AND LOG_OR QUESTION 
+const unsigned long GDLTreeParser::_tokenSet_1_data_[] = { 739116576UL, 3238592528UL, 146432UL, 4162928210UL, 589823UL, 0UL, 16379UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+// ASSIGN ARRAYDEF ARRAYDEF_CONST ARRAYEXPR ARRAYEXPR_FN ARRAYEXPR_MFCALL 
+// CONSTANT DEREF EXPR FCALL MFCALL MFCALL_PARENT NSTRUC_REF POSTDEC POSTINC 
+// STRUC SYSVAR UMINUS VAR "and" "eq" "ge" "gt" "le" "lt" "mod" "ne" "not" 
+// "or" "xor" DEC INC AND_OP_EQ ASTERIX_EQ EQ_OP_EQ GE_OP_EQ GTMARK_EQ 
+// GT_OP_EQ LE_OP_EQ LTMARK_EQ LT_OP_EQ MATRIX_OP1_EQ MATRIX_OP2_EQ MINUS_EQ 
+// MOD_OP_EQ NE_OP_EQ OR_OP_EQ PLUS_EQ POW_EQ SLASH_EQ XOR_OP_EQ SLASH 
+// ASTERIX DOT POW MATRIX_OP1 MATRIX_OP2 PLUS MINUS LTMARK GTMARK LOG_NEG 
+// LOG_AND LOG_OR QUESTION 
 const antlr::BitSet GDLTreeParser::_tokenSet_1(_tokenSet_1_data_,16);
 
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/GDLTreeParser.hpp cvs/gdl/src/GDLTreeParser.hpp
--- gdl-0.9rc4/src/GDLTreeParser.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/GDLTreeParser.hpp	2010-04-22 09:50:40.000000000 -0600
@@ -67,21 +67,29 @@
     {
         if( LoopVar( lN))
             {
-                Warning( "Warning: Assignment to FOR loop variable detected.");
+                Warning( "Warning: Assignment to loop variable detected.");
             }
         int lT = lN->getType();
         if( lT == FCALL || lT == MFCALL || lT == MFCALL_PARENT ||
-            lT == FCALL_LIB || 
+            lT == FCALL_LIB ||
+//            lT == FCALL_LIB_N_ELEMENTS ||
             lT == FCALL_LIB_RETNEW || 
             lT == MFCALL_LIB || 
             lT == MFCALL_LIB_RETNEW || 
             lT == MFCALL_PARENT_LIB ||
             lT == MFCALL_PARENT_LIB_RETNEW ||
-            lT == DEREF || lT == VAR || lT == VARPTR)
+            lT == DEREF || lT == VAR || lT == VARPTR 
+            )
         {
             aN->setType( ASSIGN_REPLACE);
             aN->setText( "r=");
         }
+        if( lT == ARRAYEXPR_MFCALL) // is MFCALL or DOT 
+        {
+            aN->setType( ASSIGN_ARRAYEXPR_MFCALL);
+            aN->setText( "?=");
+        }
+
     }
     
     bool SelfAssignment( RefDNode& lN, RefDNode& rN)
@@ -160,11 +168,13 @@
 	public: void case_statement(RefDNode _t);
 	public: void block(RefDNode _t);
 	public: void unblock(RefDNode _t);
+	public: void unblock_empty(RefDNode _t);
 	public: void label(RefDNode _t);
 	public: void assign_expr_statement(RefDNode _t);
 	public: void comp_assign_expr(RefDNode _t);
 	public: void procedure_call(RefDNode _t);
 	public: void for_statement(RefDNode _t);
+	public: void foreach_statement(RefDNode _t);
 	public: void repeat_statement(RefDNode _t);
 	public: void while_statement(RefDNode _t);
 	public: void jump_statement(RefDNode _t);
@@ -183,8 +193,9 @@
 	public: void assign_expr(RefDNode _t);
 	public: void sysvar(RefDNode _t);
 	public: void var(RefDNode _t);
-	public: void arrayindex_list_to_expression_list(RefDNode _t);
+	public: void arrayindex_list_to_parameter_list(RefDNode _t);
 	public: void arrayexpr_fn(RefDNode _t);
+	public: void arrayexpr_mfcall(RefDNode _t);
 	public: void primary_expr(RefDNode _t);
 	public: void op_expr(RefDNode _t);
 	public: void uminus(RefDNode _t);
@@ -208,10 +219,10 @@
 private:
 	static const char* tokenNames[];
 #ifndef NO_STATIC_CONSTS
-	static const int NUM_TOKENS = 216;
+	static const int NUM_TOKENS = 225;
 #else
 	enum {
-		NUM_TOKENS = 216
+		NUM_TOKENS = 225
 	};
 #endif
 	
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/GDLTreeParserTokenTypes.hpp cvs/gdl/src/GDLTreeParserTokenTypes.hpp
--- gdl-0.9rc4/src/GDLTreeParserTokenTypes.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/GDLTreeParserTokenTypes.hpp	2010-04-22 09:50:40.000000000 -0600
@@ -16,214 +16,223 @@
 		ASSIGN = 5,
 		ASSIGN_INPLACE = 6,
 		ASSIGN_REPLACE = 7,
-		ARRAYDEF = 8,
-		ARRAYDEF_CONST = 9,
-		ARRAYIX = 10,
-		ARRAYIX_ALL = 11,
-		ARRAYIX_ORANGE = 12,
-		ARRAYIX_RANGE = 13,
-		ARRAYIX_ORANGE_S = 14,
-		ARRAYIX_RANGE_S = 15,
-		ARRAYEXPR = 16,
-		ARRAYEXPR_FN = 17,
-		BLOCK = 18,
-		BREAK = 19,
-		CONTINUE = 20,
-		COMMONDECL = 21,
-		COMMONDEF = 22,
-		CONSTANT = 23,
-		DEREF = 24,
-		ELSEBLK = 25,
-		EXPR = 26,
-		FOR_STEP = 27,
-		FCALL = 28,
-		FCALL_LIB = 29,
-		FCALL_LIB_RETNEW = 30,
-		IF_ELSE = 31,
-		KEYDECL = 32,
-		KEYDEF = 33,
-		KEYDEF_REF = 34,
-		KEYDEF_REF_CHECK = 35,
-		KEYDEF_REF_EXPR = 36,
-		LABEL = 37,
-		MPCALL = 38,
-		MPCALL_PARENT = 39,
-		MFCALL = 40,
-		MFCALL_LIB = 41,
-		MFCALL_LIB_RETNEW = 42,
-		MFCALL_PARENT = 43,
-		MFCALL_PARENT_LIB = 44,
-		MFCALL_PARENT_LIB_RETNEW = 45,
-		NOP = 46,
-		NSTRUC = 47,
-		NSTRUC_REF = 48,
-		ON_IOERROR_NULL = 49,
-		PCALL = 50,
-		PCALL_LIB = 51,
-		PARADECL = 52,
-		PARAEXPR = 53,
-		POSTDEC = 54,
-		POSTINC = 55,
-		DECSTATEMENT = 56,
-		INCSTATEMENT = 57,
-		REF = 58,
-		REF_CHECK = 59,
-		REF_EXPR = 60,
-		RETURN = 61,
-		RETF = 62,
-		RETP = 63,
-		STRUC = 64,
-		SYSVAR = 65,
-		UMINUS = 66,
-		VAR = 67,
-		VARPTR = 68,
-		IDENTIFIER = 69,
-		AND_OP = 70,
-		BEGIN = 71,
-		CASE = 72,
-		COMMON = 73,
-		COMPILE_OPT = 74,
-		DO = 75,
-		ELSE = 76,
-		END = 77,
-		ENDCASE = 78,
-		ENDELSE = 79,
-		ENDFOR = 80,
-		ENDIF = 81,
-		ENDREP = 82,
-		ENDSWITCH = 83,
-		ENDWHILE = 84,
-		EQ_OP = 85,
-		FOR = 86,
-		FORWARD = 87,
-		FUNCTION = 88,
-		GE_OP = 89,
-		GOTO = 90,
-		GT_OP = 91,
-		IF = 92,
-		INHERITS = 93,
-		LE_OP = 94,
-		LT_OP = 95,
-		MOD_OP = 96,
-		NE_OP = 97,
-		NOT_OP = 98,
-		OF = 99,
-		ON_IOERROR = 100,
-		OR_OP = 101,
-		PRO = 102,
-		REPEAT = 103,
-		SWITCH = 104,
-		THEN = 105,
-		UNTIL = 106,
-		WHILE = 107,
-		XOR_OP = 108,
-		METHOD = 109,
-		COMMA = 110,
-		COLON = 111,
-		END_U = 112,
-		EQUAL = 113,
-		DEC = 114,
-		INC = 115,
-		AND_OP_EQ = 116,
-		ASTERIX_EQ = 117,
-		EQ_OP_EQ = 118,
-		GE_OP_EQ = 119,
-		GTMARK_EQ = 120,
-		GT_OP_EQ = 121,
-		LE_OP_EQ = 122,
-		LTMARK_EQ = 123,
-		LT_OP_EQ = 124,
-		MATRIX_OP1_EQ = 125,
-		MATRIX_OP2_EQ = 126,
-		MINUS_EQ = 127,
-		MOD_OP_EQ = 128,
-		NE_OP_EQ = 129,
-		OR_OP_EQ = 130,
-		PLUS_EQ = 131,
-		POW_EQ = 132,
-		SLASH_EQ = 133,
-		XOR_OP_EQ = 134,
-		MEMBER = 135,
-		LBRACE = 136,
-		RBRACE = 137,
-		SLASH = 138,
-		LSQUARE = 139,
-		RSQUARE = 140,
-		SYSVARNAME = 141,
-		EXCLAMATION = 142,
-		LCURLY = 143,
-		RCURLY = 144,
-		CONSTANT_HEX_BYTE = 145,
-		CONSTANT_HEX_LONG = 146,
-		CONSTANT_HEX_LONG64 = 147,
-		CONSTANT_HEX_INT = 148,
-		CONSTANT_HEX_I = 149,
-		CONSTANT_HEX_ULONG = 150,
-		CONSTANT_HEX_ULONG64 = 151,
-		CONSTANT_HEX_UI = 152,
-		CONSTANT_HEX_UINT = 153,
-		CONSTANT_BYTE = 154,
-		CONSTANT_LONG = 155,
-		CONSTANT_LONG64 = 156,
-		CONSTANT_INT = 157,
-		CONSTANT_I = 158,
-		CONSTANT_ULONG = 159,
-		CONSTANT_ULONG64 = 160,
-		CONSTANT_UI = 161,
-		CONSTANT_UINT = 162,
-		CONSTANT_OCT_BYTE = 163,
-		CONSTANT_OCT_LONG = 164,
-		CONSTANT_OCT_LONG64 = 165,
-		CONSTANT_OCT_INT = 166,
-		CONSTANT_OCT_I = 167,
-		CONSTANT_OCT_ULONG = 168,
-		CONSTANT_OCT_ULONG64 = 169,
-		CONSTANT_OCT_UI = 170,
-		CONSTANT_OCT_UINT = 171,
-		CONSTANT_FLOAT = 172,
-		CONSTANT_DOUBLE = 173,
-		CONSTANT_BIN_BYTE = 174,
-		CONSTANT_BIN_LONG = 175,
-		CONSTANT_BIN_LONG64 = 176,
-		CONSTANT_BIN_INT = 177,
-		CONSTANT_BIN_I = 178,
-		CONSTANT_BIN_ULONG = 179,
-		CONSTANT_BIN_ULONG64 = 180,
-		CONSTANT_BIN_UI = 181,
-		CONSTANT_BIN_UINT = 182,
-		ASTERIX = 183,
-		DOT = 184,
-		STRING_LITERAL = 185,
-		POW = 186,
-		MATRIX_OP1 = 187,
-		MATRIX_OP2 = 188,
-		PLUS = 189,
-		MINUS = 190,
-		LTMARK = 191,
-		GTMARK = 192,
-		LOG_NEG = 193,
-		LOG_AND = 194,
-		LOG_OR = 195,
-		QUESTION = 196,
-		STRING = 197,
-		INCLUDE = 198,
-		EOL = 199,
-		W = 200,
-		D = 201,
-		L = 202,
-		H = 203,
-		O = 204,
-		B = 205,
-		EXP = 206,
-		DBL_E = 207,
-		DBL = 208,
-		CONSTANT_OR_STRING_LITERAL = 209,
-		COMMENT = 210,
-		END_MARKER = 211,
-		WHITESPACE = 212,
-		SKIP_LINES = 213,
-		CONT_STATEMENT = 214,
-		END_OF_LINE = 215,
+		ASSIGN_ARRAYEXPR_MFCALL = 8,
+		ARRAYDEF = 9,
+		ARRAYDEF_CONST = 10,
+		ARRAYIX = 11,
+		ARRAYIX_ALL = 12,
+		ARRAYIX_ORANGE = 13,
+		ARRAYIX_RANGE = 14,
+		ARRAYIX_ORANGE_S = 15,
+		ARRAYIX_RANGE_S = 16,
+		ARRAYEXPR = 17,
+		ARRAYEXPR_FN = 18,
+		ARRAYEXPR_MFCALL = 19,
+		BLOCK = 20,
+		BREAK = 21,
+		CSBLOCK = 22,
+		CONTINUE = 23,
+		COMMONDECL = 24,
+		COMMONDEF = 25,
+		CONSTANT = 26,
+		DEREF = 27,
+		ELSEBLK = 28,
+		EXPR = 29,
+		FOR = 30,
+		FOR_STEP = 31,
+		FOREACH = 32,
+		FOR_LOOP = 33,
+		FOR_STEP_LOOP = 34,
+		FOREACH_LOOP = 35,
+		FCALL = 36,
+		FCALL_LIB = 37,
+		FCALL_LIB_RETNEW = 38,
+		IF_ELSE = 39,
+		KEYDECL = 40,
+		KEYDEF = 41,
+		KEYDEF_REF = 42,
+		KEYDEF_REF_CHECK = 43,
+		KEYDEF_REF_EXPR = 44,
+		LABEL = 45,
+		MPCALL = 46,
+		MPCALL_PARENT = 47,
+		MFCALL = 48,
+		MFCALL_LIB = 49,
+		MFCALL_LIB_RETNEW = 50,
+		MFCALL_PARENT = 51,
+		MFCALL_PARENT_LIB = 52,
+		MFCALL_PARENT_LIB_RETNEW = 53,
+		NOP = 54,
+		NSTRUC = 55,
+		NSTRUC_REF = 56,
+		ON_IOERROR_NULL = 57,
+		PCALL = 58,
+		PCALL_LIB = 59,
+		PARADECL = 60,
+		PARAEXPR = 61,
+		POSTDEC = 62,
+		POSTINC = 63,
+		DECSTATEMENT = 64,
+		INCSTATEMENT = 65,
+		REF = 66,
+		REF_CHECK = 67,
+		REF_EXPR = 68,
+		REPEAT = 69,
+		REPEAT_LOOP = 70,
+		RETURN = 71,
+		RETF = 72,
+		RETP = 73,
+		STRUC = 74,
+		SYSVAR = 75,
+		UMINUS = 76,
+		VAR = 77,
+		VARPTR = 78,
+		WHILE = 79,
+		IDENTIFIER = 80,
+		AND_OP = 81,
+		BEGIN = 82,
+		CASE = 83,
+		COMMON = 84,
+		COMPILE_OPT = 85,
+		DO = 86,
+		ELSE = 87,
+		END = 88,
+		ENDCASE = 89,
+		ENDELSE = 90,
+		ENDFOR = 91,
+		ENDFOREACH = 92,
+		ENDIF = 93,
+		ENDREP = 94,
+		ENDSWITCH = 95,
+		ENDWHILE = 96,
+		EQ_OP = 97,
+		FORWARD = 98,
+		FUNCTION = 99,
+		GE_OP = 100,
+		GOTO = 101,
+		GT_OP = 102,
+		IF = 103,
+		INHERITS = 104,
+		LE_OP = 105,
+		LT_OP = 106,
+		MOD_OP = 107,
+		NE_OP = 108,
+		NOT_OP = 109,
+		OF = 110,
+		ON_IOERROR = 111,
+		OR_OP = 112,
+		PRO = 113,
+		SWITCH = 114,
+		THEN = 115,
+		UNTIL = 116,
+		XOR_OP = 117,
+		METHOD = 118,
+		COMMA = 119,
+		COLON = 120,
+		END_U = 121,
+		EQUAL = 122,
+		DEC = 123,
+		INC = 124,
+		AND_OP_EQ = 125,
+		ASTERIX_EQ = 126,
+		EQ_OP_EQ = 127,
+		GE_OP_EQ = 128,
+		GTMARK_EQ = 129,
+		GT_OP_EQ = 130,
+		LE_OP_EQ = 131,
+		LTMARK_EQ = 132,
+		LT_OP_EQ = 133,
+		MATRIX_OP1_EQ = 134,
+		MATRIX_OP2_EQ = 135,
+		MINUS_EQ = 136,
+		MOD_OP_EQ = 137,
+		NE_OP_EQ = 138,
+		OR_OP_EQ = 139,
+		PLUS_EQ = 140,
+		POW_EQ = 141,
+		SLASH_EQ = 142,
+		XOR_OP_EQ = 143,
+		MEMBER = 144,
+		LBRACE = 145,
+		RBRACE = 146,
+		SLASH = 147,
+		LSQUARE = 148,
+		RSQUARE = 149,
+		SYSVARNAME = 150,
+		EXCLAMATION = 151,
+		LCURLY = 152,
+		RCURLY = 153,
+		CONSTANT_HEX_BYTE = 154,
+		CONSTANT_HEX_LONG = 155,
+		CONSTANT_HEX_LONG64 = 156,
+		CONSTANT_HEX_INT = 157,
+		CONSTANT_HEX_I = 158,
+		CONSTANT_HEX_ULONG = 159,
+		CONSTANT_HEX_ULONG64 = 160,
+		CONSTANT_HEX_UI = 161,
+		CONSTANT_HEX_UINT = 162,
+		CONSTANT_BYTE = 163,
+		CONSTANT_LONG = 164,
+		CONSTANT_LONG64 = 165,
+		CONSTANT_INT = 166,
+		CONSTANT_I = 167,
+		CONSTANT_ULONG = 168,
+		CONSTANT_ULONG64 = 169,
+		CONSTANT_UI = 170,
+		CONSTANT_UINT = 171,
+		CONSTANT_OCT_BYTE = 172,
+		CONSTANT_OCT_LONG = 173,
+		CONSTANT_OCT_LONG64 = 174,
+		CONSTANT_OCT_INT = 175,
+		CONSTANT_OCT_I = 176,
+		CONSTANT_OCT_ULONG = 177,
+		CONSTANT_OCT_ULONG64 = 178,
+		CONSTANT_OCT_UI = 179,
+		CONSTANT_OCT_UINT = 180,
+		CONSTANT_FLOAT = 181,
+		CONSTANT_DOUBLE = 182,
+		CONSTANT_BIN_BYTE = 183,
+		CONSTANT_BIN_LONG = 184,
+		CONSTANT_BIN_LONG64 = 185,
+		CONSTANT_BIN_INT = 186,
+		CONSTANT_BIN_I = 187,
+		CONSTANT_BIN_ULONG = 188,
+		CONSTANT_BIN_ULONG64 = 189,
+		CONSTANT_BIN_UI = 190,
+		CONSTANT_BIN_UINT = 191,
+		ASTERIX = 192,
+		DOT = 193,
+		STRING_LITERAL = 194,
+		POW = 195,
+		MATRIX_OP1 = 196,
+		MATRIX_OP2 = 197,
+		PLUS = 198,
+		MINUS = 199,
+		LTMARK = 200,
+		GTMARK = 201,
+		LOG_NEG = 202,
+		LOG_AND = 203,
+		LOG_OR = 204,
+		QUESTION = 205,
+		STRING = 206,
+		INCLUDE = 207,
+		EOL = 208,
+		W = 209,
+		D = 210,
+		L = 211,
+		H = 212,
+		O = 213,
+		B = 214,
+		EXP = 215,
+		DBL_E = 216,
+		DBL = 217,
+		CONSTANT_OR_STRING_LITERAL = 218,
+		COMMENT = 219,
+		END_MARKER = 220,
+		WHITESPACE = 221,
+		SKIP_LINES = 222,
+		CONT_STATEMENT = 223,
+		END_OF_LINE = 224,
 		NULL_TREE_LOOKAHEAD = 3
 	};
 #ifdef __cplusplus
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/GDLTreeParserTokenTypes.txt cvs/gdl/src/GDLTreeParserTokenTypes.txt
--- gdl-0.9rc4/src/GDLTreeParserTokenTypes.txt	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/GDLTreeParserTokenTypes.txt	2010-04-22 09:50:40.000000000 -0600
@@ -4,211 +4,220 @@
 ASSIGN=5
 ASSIGN_INPLACE=6
 ASSIGN_REPLACE=7
-ARRAYDEF=8
-ARRAYDEF_CONST=9
-ARRAYIX=10
-ARRAYIX_ALL=11
-ARRAYIX_ORANGE=12
-ARRAYIX_RANGE=13
-ARRAYIX_ORANGE_S=14
-ARRAYIX_RANGE_S=15
-ARRAYEXPR=16
-ARRAYEXPR_FN=17
-BLOCK=18
-BREAK=19
-CONTINUE=20
-COMMONDECL=21
-COMMONDEF=22
-CONSTANT=23
-DEREF=24
-ELSEBLK=25
-EXPR=26
-FOR_STEP=27
-FCALL=28
-FCALL_LIB=29
-FCALL_LIB_RETNEW=30
-IF_ELSE=31
-KEYDECL=32
-KEYDEF=33
-KEYDEF_REF=34
-KEYDEF_REF_CHECK=35
-KEYDEF_REF_EXPR=36
-LABEL=37
-MPCALL=38
-MPCALL_PARENT=39
-MFCALL=40
-MFCALL_LIB=41
-MFCALL_LIB_RETNEW=42
-MFCALL_PARENT=43
-MFCALL_PARENT_LIB=44
-MFCALL_PARENT_LIB_RETNEW=45
-NOP=46
-NSTRUC=47
-NSTRUC_REF=48
-ON_IOERROR_NULL=49
-PCALL=50
-PCALL_LIB=51
-PARADECL=52
-PARAEXPR=53
-POSTDEC=54
-POSTINC=55
-DECSTATEMENT=56
-INCSTATEMENT=57
-REF=58
-REF_CHECK=59
-REF_EXPR=60
-RETURN=61
-RETF=62
-RETP=63
-STRUC=64
-SYSVAR=65
-UMINUS=66
-VAR=67
-VARPTR=68
-IDENTIFIER=69
-AND_OP="and"=70
-BEGIN="begin"=71
-CASE="case"=72
-COMMON="common"=73
-COMPILE_OPT="compile_opt"=74
-DO="do"=75
-ELSE="else"=76
-END="end"=77
-ENDCASE="endcase"=78
-ENDELSE="endelse"=79
-ENDFOR="endfor"=80
-ENDIF="endif"=81
-ENDREP="endrep"=82
-ENDSWITCH="endswitch"=83
-ENDWHILE="endwhile"=84
-EQ_OP="eq"=85
-FOR="for"=86
-FORWARD="forward_function"=87
-FUNCTION="function"=88
-GE_OP="ge"=89
-GOTO="goto"=90
-GT_OP="gt"=91
-IF="if"=92
-INHERITS="inherits"=93
-LE_OP="le"=94
-LT_OP="lt"=95
-MOD_OP="mod"=96
-NE_OP="ne"=97
-NOT_OP="not"=98
-OF="of"=99
-ON_IOERROR="on_ioerror"=100
-OR_OP="or"=101
-PRO="pro"=102
-REPEAT="repeat"=103
-SWITCH="switch"=104
-THEN="then"=105
-UNTIL="until"=106
-WHILE="while"=107
-XOR_OP="xor"=108
-METHOD=109
-COMMA=110
-COLON=111
-END_U=112
-EQUAL=113
-DEC=114
-INC=115
-AND_OP_EQ=116
-ASTERIX_EQ=117
-EQ_OP_EQ=118
-GE_OP_EQ=119
-GTMARK_EQ=120
-GT_OP_EQ=121
-LE_OP_EQ=122
-LTMARK_EQ=123
-LT_OP_EQ=124
-MATRIX_OP1_EQ=125
-MATRIX_OP2_EQ=126
-MINUS_EQ=127
-MOD_OP_EQ=128
-NE_OP_EQ=129
-OR_OP_EQ=130
-PLUS_EQ=131
-POW_EQ=132
-SLASH_EQ=133
-XOR_OP_EQ=134
-MEMBER=135
-LBRACE=136
-RBRACE=137
-SLASH=138
-LSQUARE=139
-RSQUARE=140
-SYSVARNAME=141
-EXCLAMATION=142
-LCURLY=143
-RCURLY=144
-CONSTANT_HEX_BYTE=145
-CONSTANT_HEX_LONG=146
-CONSTANT_HEX_LONG64=147
-CONSTANT_HEX_INT=148
-CONSTANT_HEX_I=149
-CONSTANT_HEX_ULONG=150
-CONSTANT_HEX_ULONG64=151
-CONSTANT_HEX_UI=152
-CONSTANT_HEX_UINT=153
-CONSTANT_BYTE=154
-CONSTANT_LONG=155
-CONSTANT_LONG64=156
-CONSTANT_INT=157
-CONSTANT_I=158
-CONSTANT_ULONG=159
-CONSTANT_ULONG64=160
-CONSTANT_UI=161
-CONSTANT_UINT=162
-CONSTANT_OCT_BYTE=163
-CONSTANT_OCT_LONG=164
-CONSTANT_OCT_LONG64=165
-CONSTANT_OCT_INT=166
-CONSTANT_OCT_I=167
-CONSTANT_OCT_ULONG=168
-CONSTANT_OCT_ULONG64=169
-CONSTANT_OCT_UI=170
-CONSTANT_OCT_UINT=171
-CONSTANT_FLOAT=172
-CONSTANT_DOUBLE=173
-CONSTANT_BIN_BYTE=174
-CONSTANT_BIN_LONG=175
-CONSTANT_BIN_LONG64=176
-CONSTANT_BIN_INT=177
-CONSTANT_BIN_I=178
-CONSTANT_BIN_ULONG=179
-CONSTANT_BIN_ULONG64=180
-CONSTANT_BIN_UI=181
-CONSTANT_BIN_UINT=182
-ASTERIX=183
-DOT=184
-STRING_LITERAL=185
-POW=186
-MATRIX_OP1=187
-MATRIX_OP2=188
-PLUS=189
-MINUS=190
-LTMARK=191
-GTMARK=192
-LOG_NEG=193
-LOG_AND=194
-LOG_OR=195
-QUESTION=196
-STRING=197
-INCLUDE=198
-EOL=199
-W=200
-D=201
-L=202
-H=203
-O=204
-B=205
-EXP=206
-DBL_E=207
-DBL=208
-CONSTANT_OR_STRING_LITERAL=209
-COMMENT=210
-END_MARKER=211
-WHITESPACE=212
-SKIP_LINES=213
-CONT_STATEMENT=214
-END_OF_LINE=215
+ASSIGN_ARRAYEXPR_MFCALL=8
+ARRAYDEF=9
+ARRAYDEF_CONST=10
+ARRAYIX=11
+ARRAYIX_ALL=12
+ARRAYIX_ORANGE=13
+ARRAYIX_RANGE=14
+ARRAYIX_ORANGE_S=15
+ARRAYIX_RANGE_S=16
+ARRAYEXPR=17
+ARRAYEXPR_FN=18
+ARRAYEXPR_MFCALL=19
+BLOCK=20
+BREAK=21
+CSBLOCK=22
+CONTINUE=23
+COMMONDECL=24
+COMMONDEF=25
+CONSTANT=26
+DEREF=27
+ELSEBLK=28
+EXPR=29
+FOR="for"=30
+FOR_STEP=31
+FOREACH="foreach"=32
+FOR_LOOP=33
+FOR_STEP_LOOP=34
+FOREACH_LOOP=35
+FCALL=36
+FCALL_LIB=37
+FCALL_LIB_RETNEW=38
+IF_ELSE=39
+KEYDECL=40
+KEYDEF=41
+KEYDEF_REF=42
+KEYDEF_REF_CHECK=43
+KEYDEF_REF_EXPR=44
+LABEL=45
+MPCALL=46
+MPCALL_PARENT=47
+MFCALL=48
+MFCALL_LIB=49
+MFCALL_LIB_RETNEW=50
+MFCALL_PARENT=51
+MFCALL_PARENT_LIB=52
+MFCALL_PARENT_LIB_RETNEW=53
+NOP=54
+NSTRUC=55
+NSTRUC_REF=56
+ON_IOERROR_NULL=57
+PCALL=58
+PCALL_LIB=59
+PARADECL=60
+PARAEXPR=61
+POSTDEC=62
+POSTINC=63
+DECSTATEMENT=64
+INCSTATEMENT=65
+REF=66
+REF_CHECK=67
+REF_EXPR=68
+REPEAT="repeat"=69
+REPEAT_LOOP=70
+RETURN=71
+RETF=72
+RETP=73
+STRUC=74
+SYSVAR=75
+UMINUS=76
+VAR=77
+VARPTR=78
+WHILE="while"=79
+IDENTIFIER=80
+AND_OP="and"=81
+BEGIN="begin"=82
+CASE="case"=83
+COMMON="common"=84
+COMPILE_OPT="compile_opt"=85
+DO="do"=86
+ELSE="else"=87
+END="end"=88
+ENDCASE="endcase"=89
+ENDELSE="endelse"=90
+ENDFOR="endfor"=91
+ENDFOREACH="endforeach"=92
+ENDIF="endif"=93
+ENDREP="endrep"=94
+ENDSWITCH="endswitch"=95
+ENDWHILE="endwhile"=96
+EQ_OP="eq"=97
+FORWARD="forward_function"=98
+FUNCTION="function"=99
+GE_OP="ge"=100
+GOTO="goto"=101
+GT_OP="gt"=102
+IF="if"=103
+INHERITS="inherits"=104
+LE_OP="le"=105
+LT_OP="lt"=106
+MOD_OP="mod"=107
+NE_OP="ne"=108
+NOT_OP="not"=109
+OF="of"=110
+ON_IOERROR="on_ioerror"=111
+OR_OP="or"=112
+PRO="pro"=113
+SWITCH="switch"=114
+THEN="then"=115
+UNTIL="until"=116
+XOR_OP="xor"=117
+METHOD=118
+COMMA=119
+COLON=120
+END_U=121
+EQUAL=122
+DEC=123
+INC=124
+AND_OP_EQ=125
+ASTERIX_EQ=126
+EQ_OP_EQ=127
+GE_OP_EQ=128
+GTMARK_EQ=129
+GT_OP_EQ=130
+LE_OP_EQ=131
+LTMARK_EQ=132
+LT_OP_EQ=133
+MATRIX_OP1_EQ=134
+MATRIX_OP2_EQ=135
+MINUS_EQ=136
+MOD_OP_EQ=137
+NE_OP_EQ=138
+OR_OP_EQ=139
+PLUS_EQ=140
+POW_EQ=141
+SLASH_EQ=142
+XOR_OP_EQ=143
+MEMBER=144
+LBRACE=145
+RBRACE=146
+SLASH=147
+LSQUARE=148
+RSQUARE=149
+SYSVARNAME=150
+EXCLAMATION=151
+LCURLY=152
+RCURLY=153
+CONSTANT_HEX_BYTE=154
+CONSTANT_HEX_LONG=155
+CONSTANT_HEX_LONG64=156
+CONSTANT_HEX_INT=157
+CONSTANT_HEX_I=158
+CONSTANT_HEX_ULONG=159
+CONSTANT_HEX_ULONG64=160
+CONSTANT_HEX_UI=161
+CONSTANT_HEX_UINT=162
+CONSTANT_BYTE=163
+CONSTANT_LONG=164
+CONSTANT_LONG64=165
+CONSTANT_INT=166
+CONSTANT_I=167
+CONSTANT_ULONG=168
+CONSTANT_ULONG64=169
+CONSTANT_UI=170
+CONSTANT_UINT=171
+CONSTANT_OCT_BYTE=172
+CONSTANT_OCT_LONG=173
+CONSTANT_OCT_LONG64=174
+CONSTANT_OCT_INT=175
+CONSTANT_OCT_I=176
+CONSTANT_OCT_ULONG=177
+CONSTANT_OCT_ULONG64=178
+CONSTANT_OCT_UI=179
+CONSTANT_OCT_UINT=180
+CONSTANT_FLOAT=181
+CONSTANT_DOUBLE=182
+CONSTANT_BIN_BYTE=183
+CONSTANT_BIN_LONG=184
+CONSTANT_BIN_LONG64=185
+CONSTANT_BIN_INT=186
+CONSTANT_BIN_I=187
+CONSTANT_BIN_ULONG=188
+CONSTANT_BIN_ULONG64=189
+CONSTANT_BIN_UI=190
+CONSTANT_BIN_UINT=191
+ASTERIX=192
+DOT=193
+STRING_LITERAL=194
+POW=195
+MATRIX_OP1=196
+MATRIX_OP2=197
+PLUS=198
+MINUS=199
+LTMARK=200
+GTMARK=201
+LOG_NEG=202
+LOG_AND=203
+LOG_OR=204
+QUESTION=205
+STRING=206
+INCLUDE=207
+EOL=208
+W=209
+D=210
+L=211
+H=212
+O=213
+B=214
+EXP=215
+DBL_E=216
+DBL=217
+CONSTANT_OR_STRING_LITERAL=218
+COMMENT=219
+END_MARKER=220
+WHITESPACE=221
+SKIP_LINES=222
+CONT_STATEMENT=223
+END_OF_LINE=224
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdlwidget.cpp cvs/gdl/src/gdlwidget.cpp
--- gdl-0.9rc4/src/gdlwidget.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdlwidget.cpp	2010-07-07 14:41:01.896003888 -0600
@@ -13,13 +13,18 @@
  *   the Free Software Foundation; either version 2 of the License, or     *
  *   (at your option) any later version.                                   *
  *                                                                         *
+
  ***************************************************************************/
 
+#include <memory> 
+
 #include "includefirst.hpp"
 
 #include "basegdl.hpp"
 #include "dstructgdl.hpp"
 
+#include "dinterpreter.hpp"
+
 #ifdef HAVE_LIBWXWIDGETS
 
 #include "gdlwidget.hpp"
@@ -32,6 +37,7 @@
 
 BEGIN_EVENT_TABLE(GDLFrame, wxFrame)
   EVT_BUTTON( wxID_ANY, GDLFrame::OnButton)
+  EVT_RADIOBUTTON(wxID_ANY, GDLFrame::OnRadioButton)
   EVT_IDLE( GDLFrame::OnIdle)
 END_EVENT_TABLE()
 
@@ -62,7 +68,7 @@
       exit(2);
     }
   }
-  std::cout << "Creating Sizer in getSizer: " << *sizer << std::endl;
+  //  std::cout << "Creating Sizer in getSizer: " << *sizer << std::endl;
 }
 
 // next are the abstraction to access all widgets only by their
@@ -102,6 +108,22 @@
   return widget;
 }
 
+// base widget ID from ID
+WidgetIDT GDLWidget::GetBase( WidgetIDT widID)
+{
+  GDLWidget *widget, *parent;
+  WidgetIDT parentID;
+
+  parentID = widID;
+  while ( 1) {
+    widget = GetWidget( parentID);
+    if ( widget->parent == 0) 
+      return parentID; 
+    else 
+      parentID = widget->parent;
+  }
+}
+
 void GDLWidget::SetManaged( bool manval)
 {
   managed = manval;
@@ -109,20 +131,55 @@
 
 void GDLWidget::SetMap( bool mapval)
 {
-  std::cout << "set map: " << mapval << std::endl;
+  //  std::cout << "set map: " << mapval << std::endl;
   map = mapval;
 }
 
+void GDLWidget::SetExclusiveMode( int exclusiveval)
+{
+  exclusiveMode = exclusiveval;
+}
+
 void GDLWidget::SetUvalue( BaseGDL *uV)
 {
   uValue = uV;
 }
 
+void GDLWidget::SetVvalue( BaseGDL *vV)
+{
+  vValue = vV;
+}
+
 void GDLWidget::SetWidgetType( DString wType)
 {
   widgetType = wType;
 }
 
+void GDLWidget::SetButtonOff()
+{
+  buttonSet = false;
+}
+
+void GDLWidget::SetButtonOn()
+{
+  buttonSet = true;
+}
+
+void GDLWidget::SetUname( DString uname)
+{
+  uName = uname;
+}
+
+void GDLWidget::SetProValue( DString provalue)
+{
+  proValue = provalue;
+}
+
+void GDLWidget::SetFuncValue( DString funcvalue)
+{
+  funcValue = funcvalue;
+}
+
 //void GDLWidget::SetSizer( wxSizer *sizer)
 //{
 //  widgetSizer = sizer;
@@ -241,10 +298,10 @@
 }
 
 
-GDLWidget::GDLWidget( WidgetIDT p, BaseGDL* uV, bool s, bool mp,
+GDLWidget::GDLWidget( WidgetIDT p, BaseGDL* uV, BaseGDL* vV, bool s, bool mp,
 		      DLong xO, DLong yO, DLong xS, DLong yS): 
   wxWidget( NULL),
-  parent( p), uValue( uV), sensitive( s), map( mp),
+  parent( p), uValue( uV), vValue( vV), sensitive( s), map( mp),
   xOffset( xO), yOffset( yO), xSize( xS), ySize( yS)
 {
   managed = false;
@@ -269,12 +326,14 @@
       base->RemoveChild( widgetID);
     }
   delete uValue;
+  delete vValue;
   WidgetRemove( widgetID);
 }
 
-GDLWidgetBase::GDLWidgetBase( WidgetIDT p, BaseGDL* uV, bool s, bool mp,
+GDLWidgetBase::GDLWidgetBase( WidgetIDT p, BaseGDL* uV, BaseGDL* vV, 
+			      bool s, bool mp,
 			      DLong xO, DLong yO, DLong xS, DLong yS): 
-  GDLWidget( p, uV, s, mp, xO, yO, xS, yS)
+  GDLWidget( p, uV, vV, s, mp, xO, yO, xS, yS)
 {}
 
 GDLWidgetBase::GDLWidgetBase( WidgetIDT parentID, 
@@ -298,10 +357,10 @@
 			      DLong xsize, DLong ysize,
 			      DLong scr_xsize, DLong scr_ysize,
 			      DLong x_scroll_size, DLong y_scroll_size):
-  GDLWidget( parentID, uvalue, sensitive, map, xoffset, yoffset, 0, 0),
+  GDLWidget( parentID, uvalue, NULL, sensitive, map, xoffset, yoffset, 0, 0),
   modal( modal_), mbarID( mBarID)
 {
-  std::cout << "In GDLWidgetBase::GDLWidgetBase: " << widgetID << std::endl;
+  //  std::cout << "In GDLWidgetBase::GDLWidgetBase: " << widgetID << std::endl;
 
   xmanActCom = false;
   wxWindow *wxParent = NULL;
@@ -334,7 +393,7 @@
 
     wxPanel *panel = new wxPanel( frame, wxID_ANY);
     widgetPanel = panel;
-    std::cout << "Creating Panel: " << panel << std::endl;
+    //    std::cout << "Creating Panel: " << panel << std::endl;
 
     getSizer( col, row, frameBox, panel, sizerPtr);
     widgetSizer = *sizerPtr;
@@ -344,12 +403,13 @@
     panel->SetSizer( *sizerPtr);
 
     this->SetMap( mapWid);
+
   } else {
     // If parent base widget exists ....
     GDLWidget* gdlParent = GetWidget( parent);
     wxParent = static_cast< wxWindow*>( gdlParent->WxWidget());
-    std::cout << "Getting Parent: " << parent << " " << gdlParent << " " 
-	      << wxParent << std::endl;
+    //    std::cout << "Getting Parent: " << parent << " " << gdlParent << " " 
+    //      << wxParent << std::endl;
 
     wxPanel *panel = gdlParent->GetPanel();
     widgetPanel = panel;
@@ -359,6 +419,13 @@
     if ( mapWid) mapWid = gdlParent->GetMap();
     this->SetMap( mapWid);
 
+    // Set exclusiveMode
+    // If exclusive then set to -1 to signal first radiobutton
+    if ( exclusiveMode == 1)
+      this->SetExclusiveMode( -exclusiveMode);
+    else
+      this->SetExclusiveMode(  exclusiveMode);
+
     if ( mapWid) {
       if ( frameBox == 0) {
 	if ( row == 0) {
@@ -383,16 +450,16 @@
       }
 
       widgetSizer = sizer;
-      std::cout << "Creating Sizer2: " << sizer << std::endl;
+      //      std::cout << "Creating Sizer2: " << sizer << std::endl;
     
       if ( frameBox == 0) {
 	wxBoxSizer *parentSizer = (wxBoxSizer *) gdlParent->GetSizer();
-	std::cout << "Getting Parent Sizer:" << parentSizer << std::endl;
+	//    std::cout << "Getting Parent Sizer:" << parentSizer << std::endl;
 	parentSizer->Add( sizer, 0, wxEXPAND|wxALL, 5);
       } else {
 	wxStaticBoxSizer *parentSizer = 
 	  (wxStaticBoxSizer *) gdlParent->GetSizer();
-	std::cout << "Getting Parent Sizer:" << parentSizer << std::endl;
+	//    std::cout << "Getting Parent Sizer:" << parentSizer << std::endl;
 	parentSizer->Add( sizer, 0, wxEXPAND|wxALL, 5);
       }
 
@@ -415,7 +482,7 @@
   // Note: iterator for loop doesn't work when deleting widget
   cIter cI = children.begin();
   for( SizeT i=0; i<children.size(); i++) {
-    delete GetWidget( *cI++);
+    //delete GetWidget( *cI++);
   }
 
   // if TLB destroy wxWidget 
@@ -452,39 +519,58 @@
 
 void  GDLWidgetBase::SetEventPro( DString eventPro)
 {
+  std::cout << "Setting up event handler: " << eventPro.c_str() << std::endl;
   eventHandler = eventPro;
 }
 
 
 
 GDLWidgetButton::GDLWidgetButton( WidgetIDT p, BaseGDL *uV, DString value):
-  GDLWidget( p, uV, 0, 0, 0, 0, 0)
+  GDLWidget( p, uV, NULL, 0, 0, 0, 0, 0)
 {
-  std::cout << "In Button: " << widgetID << " " << p << std::endl;
-
   GDLWidget* gdlParent = GetWidget( p);
   wxWindow *wxParent = static_cast< wxWindow*>( gdlParent->WxWidget());
-  //  std::cout << "Getting Parent: " << p << " " << gdlParent << " " << wxParent << std::endl;
+
+  //  std::cout << "In Button: " << widgetID << " Parent: " << p << " xMode:" <<
+  //gdlParent->GetExclusiveMode() << " " << value << std::endl;
 
 
   if (gdlParent->GetMap()) {
     wxPanel *panel = gdlParent->GetPanel();
-    wxButton *button = new wxButton( panel, widgetID, wxString(value.c_str(), wxConvUTF8));
 
+    wxButton *button;
+    wxRadioButton *radioButton;
+    wxCheckBox *checkBox;
     wxBoxSizer *boxSizer = (wxBoxSizer *) gdlParent->GetSizer();
-    std::cout << "Getting Sizer: " << boxSizer << std::endl;
-    boxSizer->Add( button, 0, wxEXPAND | wxALL, 5);
+
+    if ( gdlParent->GetExclusiveMode() == 0) {
+      button = new wxButton( panel, widgetID, wxString(value.c_str(), wxConvUTF8));
+      boxSizer->Add( button, 0, wxEXPAND | wxALL, 5);
+    } else if ( gdlParent->GetExclusiveMode() == -1) {
+      radioButton = new wxRadioButton( panel, widgetID, wxString( value.c_str(), wxConvUTF8),
+				       wxDefaultPosition, wxDefaultSize,
+				       wxRB_GROUP);
+      gdlParent->SetExclusiveMode( 1);
+      boxSizer->Add( radioButton, 0, wxEXPAND | wxALL, 5);
+    } else if ( gdlParent->GetExclusiveMode() == 1) {
+      radioButton = new wxRadioButton( panel, widgetID, wxString(value.c_str(), wxConvUTF8));
+      boxSizer->Add( radioButton, 0, wxEXPAND | wxALL, 5);
+    } else if ( gdlParent->GetExclusiveMode() == 2) {
+      checkBox = new wxCheckBox( panel, wxID_ANY, wxString(value.c_str(), wxConvUTF8));
+      boxSizer->Add( checkBox, 0, wxEXPAND | wxALL, 5);
+    }
 
     if ( wxParent != NULL) {
-      std::cout << "SetSizeHints: " << wxParent << std::endl;
+      //      std::cout << "SetSizeHints: " << wxParent << std::endl;
       boxSizer->SetSizeHints( wxParent);
     }
   } // GetMap()
 
+
   // Generate event structure
   DStructGDL*  widgbut = new DStructGDL( "WIDGET_BUTTON");
   widgbut->InitTag("ID", DLongGDL( widgetID));
-  widgbut->InitTag("TOP", DLongGDL( p));
+  widgbut->InitTag("TOP", DLongGDL( GDLWidget::GetBase( p)));
   widgbut->InitTag("HANDLER", DLongGDL( 0));
   widgbut->InitTag("SELECT", DLongGDL( 0));
 
@@ -508,11 +594,60 @@
    (s->GetTag(s->Desc()->TagIndex("SELECT"), 0)))[0] = 0;
 }
 
+//GDLWidgetDropList::GDLWidgetDropList( WidgetIDT p, BaseGDL *uV, DStringGDL *value,
+GDLWidgetDropList::GDLWidgetDropList( WidgetIDT p, BaseGDL *uV, BaseGDL *value,
+				      DString title, DLong xSize, DLong style):
+  GDLWidget( p, uV, NULL, 0, 0, 0, 0, 0)
+{
+  //  std::cout << "In DropList: " << widgetID << " " << p << std::endl;
+
+  GDLWidget* gdlParent = GetWidget( p);
+  wxWindow *wxParent = static_cast< wxWindow*>( gdlParent->WxWidget());
+
+  wxComboBox *combo;
+
+  if (gdlParent->GetMap()) {
+    wxPanel *panel = gdlParent->GetPanel();
+
+    DStringGDL* val = static_cast<DStringGDL*>( value);
+
+    DLong n= val->N_Elements();
+    wxString *choices = new wxString[n];
+    for( SizeT i=0; i<n; ++i) choices[i] = wxString((*val)[i].c_str(), wxConvUTF8);
+
+    combo = new wxComboBox( panel, widgetID, wxString( choices[0].c_str(), wxConvUTF8),
+			    wxDefaultPosition, wxDefaultSize,
+			    n, choices, style);
+
+    wxBoxSizer *boxSizer = (wxBoxSizer *) gdlParent->GetSizer();
+    boxSizer->Add( combo, 0, wxEXPAND | wxALL, 5);
+
+    if ( wxParent != NULL) {
+      //      std::cout << "SetSizeHints: " << wxParent << std::endl;
+      boxSizer->SetSizeHints( wxParent);
+    }
+  } // GetMap()
+
+  // Generate event structure
+  DStructGDL*  widgdlist = new DStructGDL( "WIDGET_DROPLIST");
+  widgdlist->InitTag("ID", DLongGDL( widgetID));
+  widgdlist->InitTag("TOP", DLongGDL( p));
+  widgdlist->InitTag("HANDLER", DLongGDL( 0));
+  widgdlist->InitTag("SELECT", DLongGDL( 0));
+
+  // Push event structure into event variable list
+  std::ostringstream varname;
+  varname << "WDLIST" << this->WidgetID();
+  DVar *v = new DVar( varname.rdbuf()->str().c_str(), widgdlist);
+  eventVarList.push_back(v);
+}
+
+
 GDLWidgetText::GDLWidgetText( WidgetIDT p, BaseGDL *uV, DString value,
 			      DLong xSize):
-  GDLWidget( p, uV, 0, 0, 0, 0, 0)
+  GDLWidget( p, uV, NULL, 0, 0, 0, 0, 0)
 {
-  std::cout << "In Text: " << widgetID << " " << p << std::endl;
+  //  std::cout << "In Text: " << widgetID << " " << p << std::endl;
 
   GDLWidget* gdlParent = GetWidget( p);
   wxWindow *wxParent = static_cast< wxWindow*>( gdlParent->WxWidget());
@@ -520,14 +655,14 @@
 
   if (gdlParent->GetMap()) {
     wxPanel *panel = gdlParent->GetPanel();
-    text = new wxTextCtrl( panel, widgetID, wxString(value.c_str(), wxConvUTF8),
+    text = new wxTextCtrl( panel, widgetID, wxString( value.c_str(), wxConvUTF8),
 			   wxDefaultPosition, wxSize( xSize*5, wxDefaultCoord) );
 
     wxBoxSizer *boxSizer = (wxBoxSizer *) gdlParent->GetSizer();
     boxSizer->Add( text, 0, wxEXPAND | wxALL, 5);
 
     if ( wxParent != NULL) {
-      std::cout << "SetSizeHints: " << wxParent << std::endl;
+      //      std::cout << "SetSizeHints: " << wxParent << std::endl;
       boxSizer->SetSizeHints( wxParent);
     }
   } // GetMap()
@@ -549,7 +684,7 @@
 
 void GDLWidgetText::SetTextValue( DString value)
 {
-  text->SetValue(wxString(value.c_str(), wxConvUTF8));
+  text->SetValue( wxString( value.c_str(), wxConvUTF8));
   //  text->Refresh(); 
   //wxMilliSleep(700); 
  }
@@ -557,46 +692,32 @@
 
 GDLWidgetLabel::GDLWidgetLabel( WidgetIDT p, BaseGDL *uV, DString value,
 				DLong xSize):
-  GDLWidget( p, uV, 0, 0, 0, 0, 0)
+  GDLWidget( p, uV, NULL, 0, 0, 0, 0, 0)
 {
-  std::cout << "In Label: " << widgetID << " " << p << std::endl;
+  //  std::cout << "In Label: " << widgetID << " " << p << std::endl;
 
   GDLWidget* gdlParent = GetWidget( p);
   wxWindow *wxParent = static_cast< wxWindow*>( gdlParent->WxWidget());
   
   if ( gdlParent->GetMap()) {
     wxPanel *panel = gdlParent->GetPanel();
-    label = new wxStaticText( panel, wxID_ANY, wxString(value.c_str(), wxConvUTF8),
+    label = new wxStaticText( panel, wxID_ANY, wxString( value.c_str(), wxConvUTF8),
 			      wxPoint(10, 10), wxDefaultSize, wxALIGN_CENTRE);
 
     wxBoxSizer *boxSizer = (wxBoxSizer *) gdlParent->GetSizer();
     boxSizer->Add( label, 0, wxEXPAND | wxALL, 5);
 
     if ( wxParent != NULL) {
-      std::cout << "SetSizeHints: " << wxParent << std::endl;
+      //      std::cout << "SetSizeHints: " << wxParent << std::endl;
       boxSizer->SetSizeHints( wxParent);
     }
   } // GetMap()
 
-  /*
-  // Generate event structure
-  DStructGDL*  widgtxt = new DStructGDL( "WIDGET_TEXT");
-  widgtxt->InitTag("ID", DLongGDL( widgetID));
-  widgtxt->InitTag("TOP", DLongGDL( p));
-  widgtxt->InitTag("HANDLER", DLongGDL( 0));
-  widgtxt->InitTag("SELECT", DLongGDL( 0));
-
-  // Push event structure into event variable list
-  std::ostringstream varname;
-  varname << "WTXT" << this->WidgetID();
-  DVar *v = new DVar( varname.rdbuf()->str().c_str(), widgtxt);
-  eventVarList.push_back(v);
-  */
 }
 
 void GDLWidgetLabel::SetLabelValue( DString value)
 {
-  label->SetLabel(wxString(value.c_str(), wxConvUTF8));
+  label->SetLabel( wxString( value.c_str(), wxConvUTF8));
  }
 
 // *** GDLFrame ***
@@ -612,6 +733,13 @@
 
   std::cout << "in OnButton: " << event.GetId() << std::endl;
 
+  // Get XmanagerActiveCommand status
+  WidgetIDT baseWidgetID = GDLWidget::GetBase( event.GetId());
+  // std::cout << "Base Widget ID: " << baseWidgetID << std::endl;
+  GDLWidget *baseWidget = GDLWidget::GetWidget( baseWidgetID);
+  bool xmanActCom = baseWidget->GetXmanagerActiveCommand();
+  //std::cout << "xmanActCom: " << xmanActCom << std::endl;
+
   // Form button event variable name
   std::ostringstream varname;
   varname << "WBUT" << event.GetId();
@@ -619,14 +747,84 @@
   // Find name and set SELECT tag to 1
   DVar *var=FindInVarList( eventVarList, varname.rdbuf()->str().c_str());
   DStructGDL* s = static_cast<DStructGDL*>( var->Data());
+
   (*static_cast<DLongGDL*>
    (s->GetTag(s->Desc()->TagIndex("SELECT"), 0)))[0] = 1;
 
+  if ( xmanActCom == true) {
+    DString eventHandler;
+    eventHandler = baseWidget->GetEventPro();
+    eventHandler = StrUpCase( eventHandler);
+
+    int proIx = ProIx( eventHandler); 
+    DSub *sub =  proList[ proIx];
+    EnvBaseT* e;
+    e = new EnvUDT( NULL, sub);
+    std::auto_ptr< EnvBaseT> e_guard( e);
+    StackSizeGuard<EnvStackT> guard( GDLInterpreter::CallStack());
+    GDLInterpreter::CallStack().push_back( e);
+
+    EnvBaseT* caller;
+    caller = e->Caller();
+    e->Interpreter()->CallStack().pop_back();
+
+    DLong id, top, handler, select;
+    id = (*static_cast<DLongGDL*>
+	  (s->GetTag(s->Desc()->TagIndex("ID"), 0)))[0];
+    top = (*static_cast<DLongGDL*>
+	   (s->GetTag(s->Desc()->TagIndex("TOP"), 0)))[0];
+    handler = (*static_cast<DLongGDL*>
+	       (s->GetTag(s->Desc()->TagIndex("HANDLER"), 0)))[0];
+
+    // Build event handler command
+    std::ostringstream ostr;
+    ostr << "EV={WIDGET_BUTTON, ";
+    ostr << "ID: " << id << "L, TOP: " << top << "L, ";
+    ostr << "HANDLER: " << handler << "L, SELECT: " << select << "L } ";
+    ostr << "& " << eventHandler.c_str() << ", EV";
+
+    DString line = ostr.rdbuf()->str();
+    std::istringstream istr(line+"\n");
+
+    RefDNode theAST;
+
+    GDLLexer lexer(istr, "", GDLParser::NONE);
+    GDLParser& parser = lexer.Parser();
+    parser.interactive();
+
+    theAST = parser.getAST();
+    RefDNode trAST;
+    GDLTreeParser treeParser( caller);
+    treeParser.interactive(theAST);
+    trAST = treeParser.getAST();
+
+    ProgNodeP progAST = ProgNode::NewProgNode( trAST);
+    std::auto_ptr< ProgNode> progAST_guard( progAST);
+
+    // necessary for correct FOR loop handling
+    assert( dynamic_cast<EnvUDT*>(caller) != NULL);
+    EnvUDT* env = static_cast<EnvUDT*>(caller);
+    int nForLoopsIn = env->NForLoops();
+    int nForLoops = ProgNode::NumberForLoops( progAST, nForLoopsIn);
+    env->ResizeForLoops( nForLoops);
+    env->ResizeForLoops( nForLoopsIn);
+
+    RetCode retCode =
+      caller->Interpreter()->execute( progAST);
+  }
+
   // Pause 50 millisecs then refresh widget
   wxMilliSleep( 50);
   Refresh();
 }
 
+void GDLFrame::OnRadioButton( wxCommandEvent& event)
+{
+  std::cout << "in OnRadioButton: " << event.GetId() << std::endl;
+
+
+}
+
 void GDLFrame::OnIdle( wxIdleEvent&)
 {
   //  std::cout << "In OnIdle" << std::endl;
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdlwidget.hpp cvs/gdl/src/gdlwidget.hpp
--- gdl-0.9rc4/src/gdlwidget.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdlwidget.hpp	2010-06-03 09:06:38.425800749 -0600
@@ -73,6 +73,7 @@
   // get widget from ID
   static GDLWidget* GetWidget( WidgetIDT widID);
   static GDLWidget* GetParent( WidgetIDT widID);
+  static WidgetIDT GetBase( WidgetIDT widID);
 
   static void Init(); // GUI intialization upon GDL startup
 
@@ -84,23 +85,31 @@
   WidgetIDT    widgetID;  // own index to widgetList
   WidgetIDT    parent;    // parent ID (0 for TLBs)
   BaseGDL*     uValue;    // the UVALUE
+  BaseGDL*     vValue;    // the VVALUE
   bool         sensitive;
   bool         managed;
   bool         map;
+  bool         buttonSet;
+  int          exclusiveMode;
   DLong        xOffset, yOffset, xSize, ySize;
   wxSizer*     topWidgetSizer;
   wxSizer*     widgetSizer;
   wxPanel*     widgetPanel;
   DString      widgetType;
+  DString      uName;
+  DString      proValue;
+  DString      funcValue;
 
 public:
-  GDLWidget( WidgetIDT p=0, BaseGDL* uV=NULL, bool s=true, bool mp=true,
+  GDLWidget( WidgetIDT p=0, BaseGDL* uV=NULL, BaseGDL* vV=NULL,
+	     bool s=true, bool mp=true,
 	     DLong xO=-1, DLong yO=-1, DLong xS=-1, DLong yS=-1);
   virtual ~GDLWidget();
 
   wxObject* WxWidget() { return wxWidget;}
 
   BaseGDL* GetUvalue() { return uValue;}
+  BaseGDL* GetVvalue() { return vValue;}
 
   virtual void Realize( bool) {} 
   virtual DLong GetChild( DLong) {};
@@ -125,10 +134,27 @@
   bool GetMap() { return map;}
   void SetMap( bool);
 
+  int  GetExclusiveMode() { return exclusiveMode;}
+  void SetExclusiveMode( int);
+
   void SetUvalue( BaseGDL *);
+  void SetVvalue( BaseGDL *);
 
   void SetWidgetType( DString);
   DString GetWidgetType() { return widgetType;}
+
+  void SetButtonOff();
+  void SetButtonOn();
+  bool GetButtonSet() { return buttonSet;}
+
+  void SetUname( DString);
+  DString GetUname() { return uName;}
+
+  void SetProValue( DString);
+  DString GetProValue() { return proValue;}
+
+  void SetFuncValue( DString);
+  DString GetFuncValue() { return funcValue;}
 };
 
 
@@ -145,6 +171,18 @@
 };
 
 
+// droplist widget **************************************************
+class GDLWidgetDropList: public GDLWidget
+{
+public:
+  //  GDLWidgetDropList( WidgetIDT p, BaseGDL *uV, DStringGDL *value,
+  //	     DString title, DLong xSize, DLong style);
+  GDLWidgetDropList( WidgetIDT p, BaseGDL *uV, BaseGDL *value,
+		     DString title, DLong xSize, DLong style);
+  void SetSelectOff();
+};
+
+
 // text widget **************************************************
 class GDLWidgetText: public GDLWidget
 {
@@ -210,6 +248,7 @@
 
   GDLWidgetBase( WidgetIDT p=0,           // parent
 		 BaseGDL* uV=NULL,        // UVALUE
+		 BaseGDL* vV=NULL,        // VVALUE
 		 bool s=true,             // SENSITIVE
 		 bool mp=true,             // MAP
 		 DLong xO=-1, DLong yO=-1,  // offset 
@@ -245,12 +284,12 @@
 
   // event handlers (these functions should _not_ be virtual)
   void OnButton( wxCommandEvent& event);
+  void OnRadioButton( wxCommandEvent& event);
   void OnIdle( wxIdleEvent& event);
 
 private:
     // any class wishing to process wxWidgets events must use this macro
   DECLARE_EVENT_TABLE()
-;
 };
 
 #endif
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdlwinstream.hpp cvs/gdl/src/gdlwinstream.hpp
--- gdl-0.9rc4/src/gdlwinstream.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdlwinstream.hpp	2010-07-07 14:41:01.947940818 -0600
@@ -22,8 +22,8 @@
 
 class GDLWINStream: public GDLGStream
 {
-  Atom wm_protocols;
-  Atom wm_delete_window;
+  //Atom wm_protocols;
+  //Atom wm_delete_window;
 
   PLStream* pls;
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdlxstream.cpp cvs/gdl/src/gdlxstream.cpp
--- gdl-0.9rc4/src/gdlxstream.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdlxstream.cpp	2010-07-07 14:41:01.951944077 -0600
@@ -16,14 +16,18 @@
  ***************************************************************************/
 
 #include "includefirst.hpp"
-
 #include <iostream>
 
 #include "graphics.hpp"
 #include "gdlxstream.hpp"
 
+#ifndef HAVE_X
+#else
+
 using namespace std;
 
+// bool GDLXStream::plstreamInitCalled = false;
+
 void GDLXStream::Init()
 {
   // plstream::init() calls exit() if it cannot establish a connection with X-server
@@ -36,9 +40,13 @@
     }
     XCloseDisplay(display);
   }
- 
-  plstream::init();
 
+//      if( !plstreamInitCalled)
+//    {
+		this->plstream::init();
+//  		plstreamInitCalled = true;
+// 	}
+		
   //  set_stream(); // private
   plgpls( &pls);
   XwDev *dev = (XwDev *) pls->dev;
@@ -55,9 +63,37 @@
 {
   if( !valid) return;
 
+  // dummy call to get private function set_stream() called
+//   char dummy;
+//   gesc( &dummy);
+// 
+//   plgpls( &pls);
+
   XwDev *dev = (XwDev *) pls->dev;
+
+// 	if( dev == NULL)
+// 		this->plstream::init();
+// 
+//   plgpls( &pls);
+//   
+//   dev = (XwDev *) pls->dev;
+
+	if( dev == NULL)
+	{
+		cerr << "X window invalid." << endl;
+		valid = false;
+		return;
+    }
+    
   XwDisplay *xwd = (XwDisplay *) dev->xwd;
   
+	if( xwd == NULL)
+	{
+		cerr << "X window not set." << endl;
+		valid = false;
+		return;
+    }
+    
   XEvent event;
   if( XCheckTypedWindowEvent( xwd->display, dev->window, 
 			      ClientMessage, &event))
@@ -156,3 +192,5 @@
   XwDisplay *xwd = (XwDisplay *) dev->xwd;
   XLowerWindow(dev->xwd->display, dev->window);
 }
+
+#endif
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdlxstream.hpp cvs/gdl/src/gdlxstream.hpp
--- gdl-0.9rc4/src/gdlxstream.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdlxstream.hpp	2010-07-07 14:41:01.960941359 -0600
@@ -20,6 +20,9 @@
 
 #include "gdlgstream.hpp"
 
+#ifndef HAVE_X
+#else
+
 class GDLXStream: public GDLGStream
 {
   Atom wm_protocols;
@@ -28,14 +31,14 @@
   PLStream* pls;
 
 public:
-  GDLXStream( int nx, int ny):
-    GDLGStream( nx, ny, "xwin")
+  GDLXStream( int nx, int ny)
+    : GDLGStream( nx, ny, "xwin")
+//    , plstreamInitCalled( false)
   {
   }
 
   ~GDLXStream()
-  {
-  }
+  {}
   
   void Init();
   void EventHandler();
@@ -51,3 +54,5 @@
 };
 
 #endif
+
+#endif
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gdlzstream.cpp cvs/gdl/src/gdlzstream.cpp
--- gdl-0.9rc4/src/gdlzstream.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gdlzstream.cpp	2010-04-16 11:22:53.000000000 -0600
@@ -43,6 +43,6 @@
 
 void GDLZStream::Init()
 {
-  plstream::init();
+   plstream::init();
 }
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/graphics.cpp cvs/gdl/src/graphics.cpp
--- gdl-0.9rc4/src/graphics.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/graphics.cpp	2010-07-07 14:41:01.965944617 -0600
@@ -23,9 +23,9 @@
 #include "objects.hpp"
 #include "graphics.hpp"
 #ifdef _MSC_VER
-#include "devicewin.hpp"
+#  include "devicewin.hpp"
 #else
-#include "devicex.hpp"
+#  include "devicex.hpp"
 #endif
 #include "deviceps.hpp"
 #include "devicesvg.hpp"
@@ -147,7 +147,10 @@
 #ifdef _MSC_VER
   deviceList.push_back( new DeviceWIN());
 #else
+#  ifndef HAVE_X
+#  else
   deviceList.push_back( new DeviceX());
+#  endif
 #endif
   deviceList.push_back( new DevicePS());
   deviceList.push_back( new DeviceSVG());
@@ -156,12 +159,18 @@
 #ifdef _MSC_VER
   if( !SetDevice( "WIN")) 
 #else
+#  ifndef HAVE_X
+#  else
   if( !SetDevice( "X")) 
+#  endif
 #endif
+#  ifndef HAVE_X
+#  else
     {
     cerr << "Error initializing graphics." << endl;
     exit( EXIT_FAILURE);
     }
+#  endif
 }
 
 void Graphics::DestroyDevices()
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/grib.cpp cvs/gdl/src/grib.cpp
--- gdl-0.9rc4/src/grib.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/grib.cpp	2010-04-22 09:50:41.000000000 -0600
@@ -1,5 +1,5 @@
 /***************************************************************************
-                          grib_fun.cpp  -  GRIB GDL library function
+                          grib.cpp  -  GRIB GDL library function
                              -------------------
     begin                : Jan 18 2009
     copyright            : (C) 2009 by Sylwester Arabas
@@ -27,7 +27,7 @@
 #include "grib.hpp"
 
 #ifdef USE_GRIB
-#  include "grib_api.h"
+#  include <grib_api.h>
 #  include <map>
 #endif
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/grib.hpp cvs/gdl/src/grib.hpp
--- gdl-0.9rc4/src/grib.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/grib.hpp	2010-04-22 09:50:41.000000000 -0600
@@ -15,8 +15,8 @@
  *                                                                         *
  ***************************************************************************/
 
-#ifndef GRIB_FUN_HPP_
-#define GRIB_FUN_HPP_
+#ifndef GRIB_HPP_
+#define GRIB_HPP_
 
 #include "datatypes.hpp"
 #include "envt.hpp"
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gshhs.cpp cvs/gdl/src/gshhs.cpp
--- gdl-0.9rc4/src/gshhs.cpp	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/gshhs.cpp	2010-05-21 10:23:57.505905593 -0600
@@ -0,0 +1,288 @@
+/***************************************************************************
+                          gshhs.cpp  -  GSHHS-related routines
+                             -------------------
+    begin                : Apr 18 2010
+    copyright            : (C) 2010 by Sylwester Arabas 
+                           based on the GPL-licensed code (see note below)
+                           by P. Wessel and W. H. F. Smith
+    email                : slayoo@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#else
+// default: assume we have GSHHS
+#define USE_GSHHS 1
+#endif
+
+#include "includefirst.hpp"
+#include "gshhs.hpp"
+#include "plotting.hpp"
+#include "math_utl.hpp"
+
+#ifdef USE_GSHHS
+#  include <gshhs.h>
+#endif
+
+namespace lib {
+
+  using namespace std;
+
+  void map_continents(EnvT* e)
+  {
+#ifndef USE_GSHHS
+    e->Throw("GDL was compiled without support for GSHHS");
+#else
+
+    // mapping init
+    bool mapSet = false;
+#ifdef USE_LIBPROJ4
+    LPTYPE idata;
+    XYTYPE odata;
+    get_mapset(mapSet);
+    if (mapSet) 
+    {
+      ref = map_init();
+      if (ref == NULL) e->Throw( "Projection initialization failed.");
+    }
+#endif
+    if (!mapSet) 
+      e->Throw("Map transform not established (MAP_SET).");
+
+    // plotting init
+    GDLGStream* actStream = GetPlotStream(e);
+
+    gkw_color(e, actStream);
+
+    actStream->NoSub();
+
+    DDouble *sx, *sy; 
+    GetSFromPlotStructs(&sx, &sy); 
+    
+    DFloat *wx, *wy; 
+    GetWFromPlotStructs(&wx, &wy); 
+
+    DDouble xStart, xEnd, yStart, yEnd;
+    DataCoordLimits(sx, sy, wx, wy, &xStart, &xEnd, &yStart, &yEnd);
+
+    actStream->vpor(wx[0], wx[1], wy[0], wy[1]);
+    actStream->wind( xStart, xEnd, yStart, yEnd);
+
+    // GDL stuff
+    static int riversIx = e->KeywordIx("RIVERS");
+    bool kw_rivers = e->KeywordSet(riversIx);
+    static int countriesIx = e->KeywordIx("COUNTRIES");
+    bool kw_countries = e->KeywordSet(countriesIx);
+    static int hiresIx = e->KeywordIx("HIRES");
+    bool kw_hires = e->KeywordSet(hiresIx);
+    static int fillIx = e->KeywordIx("FILL_CONTINENTS");
+    bool kw_fill = e->KeywordSet(fillIx);
+ 
+    // SA: the code below is based on the gshhs.c by Paul Wessel
+    // here's the original copyright notice:
+
+    /*
+     *	Copyright (c) 1996-2009 by P. Wessel and W. H. F. Smith
+     *	See COPYING file for copying and redistribution conditions.
+     *
+     * PROGRAM:	gshhs.c
+     * AUTHOR:	Paul Wessel (pwessel@hawaii.edu)
+     * CREATED:	JAN. 28, 1996
+     * PURPOSE:	To extract ASCII data from the binary GSHHS shoreline data
+     *		as described in the 1996 Wessel & Smith JGR Data Analysis Note.
+     * VERSION:	1.1 (Byte flipping added)
+     *		1.2 18-MAY-1999:
+     *		   Explicit binary open for DOS systems
+     *		   POSIX.1 compliant
+     *		1.3 08-NOV-1999: Released under GNU GPL
+     *		1.4 05-SEPT-2000: Made a GMT supplement; FLIP no longer needed
+     *		1.5 14-SEPT-2004: Updated to deal with latest GSHHS database (1.3)
+     *		1.6 02-MAY-2006: Updated to deal with latest GSHHS database (1.4)
+     *		1.7 11-NOV-2006: Fixed bug in computing level (&& vs &)
+     *		1.8 31-MAR-2007: Updated to deal with latest GSHHS database (1.5)
+     *		1.9 27-AUG-2007: Handle line data as well as polygon data
+     *		1.10 15-FEB-2008: Updated to deal with latest GSHHS database (1.6)
+     *		1.12 15-JUN-2009: Now contains information on container polygon,
+     *				the polygons ancestor in the full resolution, and
+     *				a flag to tell if a lake is a riverlake.
+     *				Updated to deal with latest GSHHS database (2.0)
+     *
+     *	This program is free software; you can redistribute it and/or modify
+     *	it under the terms of the GNU General Public License as published by
+     *	the Free Software Foundation; version 2 of the License.
+     *
+     *	This program is distributed in the hope that it will be useful,
+     *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+     *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+     *	GNU General Public License for more details.
+     *
+     *	Contact info: www.soest.hawaii.edu/pwessel 
+     */
+
+    string dir = string(GDLDATADIR) + "/../gshhs/"; 
+    enum set {continents, countries, rivers, coasts};
+    string sufix = kw_hires ? "_h.b" : "_c.b";
+
+    vector<string> files(4);
+    files[continents] = dir + "gshhs" + sufix;
+    files[countries] = dir + "wdb_borders" + sufix;
+    files[rivers] = dir + "wdb_rivers" + sufix;
+    files[coasts] = dir + "gshhs" + sufix;
+
+    for (int i = 0; i < files.size(); ++i)
+    {
+      if (kw_fill && i != continents) continue; 
+
+      if (i == countries && !kw_countries) continue;
+      if (i == rivers && !kw_rivers) continue;
+      // TODO: coasts, continents
+
+      FILE *fp = NULL;
+      if ((fp = fopen (files[i].c_str(), "rb")) == NULL ) 
+        e->Throw("GSHHS: Could not open file: " + files[i]); 
+
+      struct GSHHS h;
+      int n_read = fread((void *)&h, (size_t)sizeof (struct GSHHS), (size_t)1, fp);
+      int version = (h.flag >> 8) & 255;
+      int flip = (version != GSHHS_DATA_RELEASE);	/* Take as sign that byte-swabbing is needed */
+  	
+      int max_east = 270000000;
+      while (n_read == 1) 
+      {
+        if (flip) 
+        {
+          h.id = swabi4((unsigned int)h.id);
+          h.n = swabi4((unsigned int)h.n);
+          h.west = swabi4((unsigned int)h.west);
+          h.east = swabi4((unsigned int)h.east);
+          h.south = swabi4((unsigned int)h.south);
+          h.north = swabi4((unsigned int)h.north);
+          h.area = swabi4((unsigned int)h.area);
+          h.area_full = swabi4((unsigned int)h.area_full);
+          h.flag  = swabi4((unsigned int)h.flag);
+          h.container = swabi4((unsigned int)h.container);
+          h.ancestor = swabi4((unsigned int)h.ancestor);
+        }
+  
+        int level = h.flag & 255;                    // Level is 1-4 
+        version = (h.flag >> 8) & 255;               // Version is 1-7 
+        int greenwich = (h.flag >> 16) & 1;          // Greenwich is 0 or 1 
+        int src = (h.flag >> 24) & 1;                // Greenwich is 0 (WDBII) or 1 (WVS) 
+        int river = (h.flag >> 25) & 1;              // River is 0 (not river) or 1 (is river) 
+        double ww = h.west  * GSHHS_SCL;             // Convert from microdegrees to degrees 
+        double ee = h.east  * GSHHS_SCL;
+        double ss = h.south * GSHHS_SCL;
+        double nn = h.north * GSHHS_SCL;
+        char source = (src == 1) ? 'W' : 'C';        // Either WVS or CIA (WDBII) pedigree 
+        if (river) source = tolower ((int)source);   // Lower case c means river-lake 
+        int line = (h.area) ? 0 : 1;                 // Either Polygon (0) or Line (1) (if no area) 
+
+        /*
+        double area = 0.1 * h.area;                  // Now im km^2 
+        double f_area = 0.1 * h.area_full;           // Now im km^2 
+  
+        char kind[2] = {'P', 'L'};
+        char c = kind[line];
+        if (line)
+        {
+          printf ("%c %6d%8d%2d%2c%10.5f%10.5f%10.5f%10.5f\n", c, h.id, h.n, level, source, ww, ee, ss, nn);
+        }
+        else 
+        {
+          char ancestor[8], container[8];
+          (h.container == -1) ? sprintf (container, "-") : sprintf (container, "%6d", h.container);
+          (h.ancestor == -1) ? sprintf (ancestor, "-") : sprintf (ancestor, "%6d", h.ancestor);
+          printf ("%c %6d%8d%2d%2c%13.3f%13.3f%10.5f%10.5f%10.5f%10.5f %s %s\n", c, h.id, h.n, level, source, area, f_area, ww, ee, ss, nn, container, ancestor);
+        }
+        */
+
+        double lon_last, lat_last;
+        PLFLT *lons, *lats;
+        if (kw_fill && !line)
+        {
+          lons = (PLFLT*)malloc(h.n * sizeof(PLFLT));
+          if (lons == NULL) 
+            e->Throw("Failed to allocate memory (lons)");
+          lats = (PLFLT*)malloc(h.n * sizeof(PLFLT));
+          if (lats == NULL) 
+            e->Throw("Failed to allocate memory (lats)");
+        }
+        for (int k = 0; k < h.n; k++) 
+        {
+          struct POINT p;
+          if (fread ((void *)&p, (size_t)sizeof(struct POINT), (size_t)1, fp) != 1) 
+          {
+            e->Throw("Error reading file" + files[i] + " for " + (line ? "line" : "polygon") 
+              + i2s(h.id) + ", point " + i2s(k));
+          }
+          
+          if (!(line && kw_fill))
+          {
+            // byte order
+            if (flip) 
+            {
+              p.x = swabi4((unsigned int)p.x);
+              p.y = swabi4((unsigned int)p.y);
+            }
+  
+            // value scaling
+            double lon = p.x * GSHHS_SCL;
+            if ((greenwich && p.x > max_east) || (h.west > 180000000)) lon -= 360.0;
+            double lat = p.y * GSHHS_SCL;
+  
+#ifdef USE_LIBPROJ4
+            // map projection
+            if (mapSet) // ... always true
+            {
+              idata.lam = lon * DEG_TO_RAD;
+              idata.phi = lat * DEG_TO_RAD;
+              odata = PJ_FWD(idata, ref);
+              lon = odata.x;
+              lat = odata.y;
+            }
+#endif
+
+            // drawing line or recording data for drawing a polygon afterwards
+            if (!kw_fill)
+            {
+              if (k != 0) actStream->join(lon_last, lat_last, lon, lat);
+              lon_last = lon;
+              lat_last = lat;
+            }
+            else
+            {
+              lons[k] = lon;
+              lats[k] = lat;
+            }
+          }
+        }
+        if (kw_fill && !line) 
+        {
+          actStream->fill(h.n, lons, lats); // TODO: PL_MAXPOLY is 256 :(
+          free(lons);
+          free(lats);
+        }
+        max_east = 180000000;	/* Only Eurasia needs 270 */
+        n_read = fread((void *)&h, (size_t)sizeof (struct GSHHS), (size_t)1, fp);
+      }
+		
+      fclose(fp);
+    }
+
+    actStream->lsty(1); //reset linestyle
+    actStream->flush(); 
+
+#endif
+  }
+
+} // namespace
+
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gshhs.hpp cvs/gdl/src/gshhs.hpp
--- gdl-0.9rc4/src/gshhs.hpp	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/gshhs.hpp	2010-05-21 10:23:57.508906751 -0600
@@ -0,0 +1,30 @@
+/***************************************************************************
+                          gshhs.hpp  -  GSHHS-related routines
+                             -------------------
+    begin                : Apr 18 2010
+    copyright            : (C) 2010 by Sylwester Arabas
+    email                : slayoo@users.sf.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef GSHHS_HPP_
+#define GSHHS_HPP_
+
+#include "datatypes.hpp"
+#include "envt.hpp"
+
+namespace lib {
+
+  void map_continents(EnvT* e);
+
+} // namespace
+
+#endif
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gsl_fun.cpp cvs/gdl/src/gsl_fun.cpp
--- gdl-0.9rc4/src/gsl_fun.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gsl_fun.cpp	2010-07-07 14:41:01.993944813 -0600
@@ -68,6 +68,9 @@
 // zeropoly
 #include <gsl/gsl_poly.h>
 
+// spher_harm
+#include <gsl/gsl_sf_legendre.h>
+
 #define LOG10E 0.434294
 
 namespace lib {
@@ -556,6 +559,7 @@
 
 	fft_1d( p0, &(*res)[0], nEl, offset, stride, 
 		direct, dbl, dimension);
+
     } else if ( p0->Rank() == 2) {
       stride=p0->Dim(0);
       for( SizeT i=0; i<p0->Dim(0); ++i) {
@@ -621,17 +625,21 @@
 
     double direct=-1.0;
 
+
     if( nParam == 0)
       e->Throw( 
 			  "Incorrect number of arguments.");
 
-    BaseGDL* p0 = e->GetNumericArrayParDefined( 0);
+
+    //BaseGDL* p0 = e->GetNumericArrayParDefined( 0); 
+    BaseGDL* p0 = e->GetParDefined( 0);
 
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
       e->Throw( 
 			  "Variable is undefined: "+e->GetParString(0));
   
+
     if( nParam == 2) {
       BaseGDL* p1 = e->GetPar( 1);
       if (p1->N_Elements() > 1)
@@ -639,11 +647,14 @@
 			    "Expression must be a scalar or 1 element array: "
 			    +e->GetParString(1));
 
+
+
       DDoubleGDL* direction = 
 	static_cast<DDoubleGDL*>(p1->Convert2( DOUBLE, BaseGDL::COPY));
       direct = GSL_SIGN((*direction)[0]);
     }
 
+
     if( e->KeywordSet(0)) dbl = 1;
     if( e->KeywordSet(1)) direct = +1.0;
     if( e->KeywordSet(2)) overwrite = 1;
@@ -659,12 +670,14 @@
 
     if( p0->Type() == COMPLEXDBL || p0->Type() == DOUBLE || dbl) { 
 
+	//cout << "if 1" << endl;
       return fft_template< DComplexDblGDL> (p0, nEl, dbl, overwrite, 
 					    direct, dimension);
 
     }
     else if( p0->Type() == COMPLEX) {
 
+	//cout << "if 2" << endl;
       DComplexGDL* res;
 
       return fft_template< DComplexGDL> (p0, nEl, dbl, overwrite, 
@@ -678,15 +691,20 @@
 	     p0->Type() == UINT ||
 	     p0->Type() == BYTE) {
 
+	//cout << "if 3" << endl;
       overwrite = 0;
       return fft_template< DComplexGDL> (p0, nEl, dbl, overwrite, 
 					 direct, dimension);
 
     } else {
-      DFloatGDL* res = static_cast<DFloatGDL*>
-	(p0->Convert2( FLOAT, BaseGDL::COPY));
+	//cout << "else" << endl;
 
-      return res;
+      overwrite = 0;
+      DComplexGDL* p0C = static_cast<DComplexGDL*>
+	(p0->Convert2( COMPLEX, BaseGDL::COPY));
+      auto_ptr<BaseGDL> guard_p0C( p0C); 
+      return fft_template< DComplexGDL> (p0C, nEl, dbl, overwrite, 
+					 direct,dimension); 
 
     }
   }
@@ -1149,7 +1167,7 @@
     if (input != NULL)
       if (input->N_Elements() < nbins)
 	e->Throw( 
-			    "HISTOGRAM: Expression " +e->GetString(inputIx) + 
+			    "Expression " +e->GetString(inputIx) + 
 			    " does not have enough elements.");
       else if (input->N_Elements() > nbins)
 	nbins = input->N_Elements();
@@ -1202,8 +1220,7 @@
     if( e->KeywordPresent( 7)) {
 
       if (input != NULL)
-	e->Throw( 
-			    "HISTOGRAM: Conflicting keywords.");
+	e->Throw("Conflicting keywords.");
 
       DULong k = 0;
       multimap< size_t, SizeT> bin_j;
@@ -1459,8 +1476,7 @@
     SizeT nParam=e->NParam();
 
     if( nParam < 2)
-      e->Throw( 
-			  "INTERPOLATE: Incorrect number of arguments.");
+      e->Throw("Incorrect number of arguments.");
 
     BaseGDL* p0 = e->GetParDefined( 0);
     BaseGDL* p1 = e->GetParDefined( 1);
@@ -1479,8 +1495,7 @@
     auto_ptr<BaseGDL> guard3;
 
     if( p0->Rank() < nParam-1)
-      e->Throw( 
-	    "INTERPOLATE: Number of parameters must agree with dimensions of argument.");
+      e->Throw("Number of parameters must agree with dimensions of argument.");
 
     bool cubic = false;
     if ( e->KeywordSet(0)) cubic = true;
@@ -1495,13 +1510,11 @@
     // If not GRID then check that rank and dims match
     if ( nParam == 3 && !grid) {
       if (p1->Rank() != p2->Rank())
-	e->Throw( 
-	      "INTERPOLATE: Coordinate arrays must have same length if Grid not set.");
+	e->Throw("Coordinate arrays must have same length if Grid not set.");
       else {
 	for( SizeT i=0; i<p1->Rank(); ++i) {
 	  if (p1->Dim(i) != p2->Dim(i))
-	    e->Throw( 
-		  "INTERPOLATE: Coordinate arrays must have same length if Grid not set.");
+	    e->Throw("Coordinate arrays must have same length if Grid not set.");
 	}
       }
     }
@@ -1644,8 +1657,7 @@
     if( nParam == 3) {
 
       if( cubic)
-	e->Throw( 
-	      "INTERPOLATE: Bicubic interpolation not yet supported.");
+	e->Throw("Bicubic interpolation not yet supported.");
 
       if ( p1->Type() == DOUBLE) 
 	p1D = static_cast<DDoubleGDL*> ( p1);
@@ -1695,8 +1707,7 @@
     if( nParam == 4) {
 
       if( cubic)
-	e->Throw( 
-	      "INTERPOLATE: Bicubic interpolation not supported.");
+	e->Throw("Bicubic interpolation not supported.");
 
       if ( p1->Type() == DOUBLE) 
 	p1D = static_cast<DDoubleGDL*> ( p1);
@@ -1856,26 +1867,22 @@
 
   void la_trired_pro( EnvT* e)
   {
-    SizeT nParam=e->NParam();
+    SizeT nParam=e->NParam(3);
     float f32;
     double f64;
 
-    if( nParam != 3)
-      e->Throw( 
-			  "LA_TRIRED: Incorrect number of arguments.");
+//     if( nParam != 3)
+//       e->Throw( 
+// 			  "LA_TRIRED: Incorrect number of arguments.");
 
     BaseGDL* p0 = e->GetNumericArrayParDefined( 0);
 
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
-      e->Throw( 
-			  "LA_TRIRED: Variable is undefined: "+ 
-			  e->GetParString(0));
+      e->Throw("Variable is undefined: "+ e->GetParString(0));
     
     if (p0->Dim(0) != p0->Dim(1))
-      e->Throw( 
-			  "LA_TRIRED: Input must be a square matrix: "+ 
-			  e->GetParString(0));
+      e->Throw("Input must be a square matrix: "+ e->GetParString(0));
 
     if( p0->Type() == COMPLEX)
       {
@@ -2796,6 +2803,110 @@
     );   
   }
 
+  // SA: GDL implementation of LEGENDRE uses gsl_sf_legendre_Plm, while SPHER_HARM implem. 
+  //     below uses gsl_sf_legendre_sphPlm which is intended for use with sph. harms
+  template <class T_theta, class T_phi, class T_res>
+  void spher_harm_helper_helper_helper(EnvT *e, T_theta *theta, T_phi *phi, T_res *res, 
+    int l, int m, int step_theta, int step_phi, SizeT length)
+  {
+    double sign = (m < 0 && m % 2 == -1) ? -1. : 1.;
+    // SA: I haven't found any L,M values which GSL would not accept...
+    //gsl_sf_result sphPlm;
+    for (SizeT j = 0; j < length; ++j) 
+    {
+      /*
+        if (GSL_SUCCESS != gsl_sf_legendre_sphPlm_e(l, abs(m), cos(theta[j * step_theta]), &sphPlm))
+          e->Throw("GSL refused to compute Legendre polynomial value for the given L,M pair");
+        res[j] = sign * sphPlm.val;
+      */
+      res[j] = sign * gsl_sf_legendre_sphPlm(l, abs(m), cos(theta[j * step_theta]));
+      res[j] *= exp(complex<T_phi>(0., m * phi[j * step_phi]));
+    }
+  }
+  template <class T_phi, class T_res>
+  void spher_harm_helper_helper(EnvT* e, BaseGDL *theta, T_phi *phi, T_res *res,
+    int l, int m, int step_theta, int step_phi, SizeT length)
+  {
+    if (theta->Type() == DOUBLE || theta->Type() == COMPLEXDBL)
+    {
+      DDoubleGDL *theta_ = e->GetParAs<DDoubleGDL>(0);
+      spher_harm_helper_helper_helper(e, &((*theta_)[0]), phi, res, l, m, step_theta, step_phi, length);
+    }
+    else
+    {
+      DFloatGDL *theta_ = e->GetParAs<DFloatGDL>(0);
+      spher_harm_helper_helper_helper(e, &((*theta_)[0]), phi, res, l, m, step_theta, step_phi, length);
+    }
+  }
+  template <class T_res>
+  void spher_harm_helper(EnvT* e, BaseGDL *theta, BaseGDL *phi, T_res *res, 
+    int l, int m, int step_theta, int step_phi, SizeT length)
+  {
+    if (phi->Type() == DOUBLE || phi->Type() == COMPLEXDBL)
+    {
+      DDoubleGDL *phi_ = e->GetParAs<DDoubleGDL>(1);
+      spher_harm_helper_helper(e, theta, &((*phi_)[0]), res, l, m, step_theta, step_phi, length);
+    }
+    else 
+    {
+      DFloatGDL *phi_ = e->GetParAs<DFloatGDL>(1);
+      spher_harm_helper_helper(e, theta, &((*phi_)[0]), res, l, m, step_theta, step_phi, length);
+    }
+  }
+  BaseGDL* spher_harm(EnvT* e)
+  {
+    // sanity checks etc
+    SizeT nParam=e->NParam(4);   
+    
+    BaseGDL *theta = e->GetNumericParDefined(0);
+    BaseGDL *phi = e->GetNumericParDefined(1);
+
+    int step_theta = 1, step_phi = 1;
+    SizeT length = theta->N_Elements();
+    if (theta->N_Elements() != phi->N_Elements())
+    {
+      if (
+        (theta->N_Elements() > 1 && phi->Rank() != 0) ||
+        (phi->N_Elements() > 1 && theta->Rank() != 0)
+      ) e->Throw("Theta (1st arg.) or Phi (2nd arg.) must be scalar, or have the same number of values");
+      if (theta->N_Elements() > 1) step_phi = 0;
+      else
+      {
+        step_theta = 0;
+        length = phi->N_Elements();
+      }
+    }
+
+    DLong l;
+    e->AssureLongScalarPar(2, l);
+    if (l < 0) e->Throw("L (3rd arg.) must be greater than or equal to zero");
+  
+    DLong m;
+    e->AssureLongScalarPar(3, m);
+    if (abs(m) > l) e->Throw("M (4th arg.) must be in the range [-L, L]");
+
+    // allocating (and guarding) memory
+    BaseGDL *res;
+    bool dbl = e->KeywordSet(0) || theta->Type() == DOUBLE || phi->Type() == DOUBLE;
+    {
+      dimension dim = dimension(length);
+      if (phi->Rank() == 0 && theta->Rank() == 0) dim.Remove(0);
+      if (dbl) res = new DComplexDblGDL(dim);
+      else res = new DComplexGDL(dim);
+    }
+    auto_ptr<BaseGDL> res_guard(res);
+
+    // computing the result 
+    if (dbl) 
+      spher_harm_helper(e, theta, phi, &((*static_cast<DComplexDblGDL*>(res))[0]), l, m, step_theta, step_phi, length);
+    else
+      spher_harm_helper(e, theta, phi, &((*static_cast<DComplexGDL*>(res))[0]), l, m, step_theta, step_phi, length);
+    
+    // returning
+    res_guard.release();
+    return res;
+  }
+
 } // namespace
 
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gsl_fun.hpp cvs/gdl/src/gsl_fun.hpp
--- gdl-0.9rc4/src/gsl_fun.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gsl_fun.hpp	2010-06-03 09:06:38.720801837 -0600
@@ -55,6 +55,7 @@
   BaseGDL* binomialcoef(EnvT* e);
   BaseGDL* wtn(EnvT* e);
   BaseGDL* zeropoly(EnvT* e);
+  BaseGDL* spher_harm(EnvT* e);
 
 } // namespace
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/gzstream.hpp cvs/gdl/src/gzstream.hpp
--- gdl-0.9rc4/src/gzstream.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/gzstream.hpp	2010-07-07 14:41:01.999004852 -0600
@@ -18,8 +18,8 @@
 // ============================================================================
 //
 // File          : gzstream.h
-// Revision      : $Revision: 1.2 $
-// Revision_date : $Date: 2009/11/18 23:22:49 $
+// Revision      : $Revision: 1.3 $
+// Revision_date : $Date: 2010/06/29 09:17:52 $
 // Author(s)     : Deepak Bandyopadhyay, Lutz Kettner
 // 
 // Standard streambuf implementation following Nicolai Josuttis, "The 
@@ -72,6 +72,9 @@
     virtual int     overflow( int c = EOF);
     virtual int     underflow();
     virtual int     sync();
+    std::streampos pubseekpos(std::streampos sp, std::ios_base::openmode which=std::ios_base::in|std::ios_base::out);
+    std::streampos pubseekoff(std::streamoff off, std::ios_base::seekdir way, std::ios_base::openmode which=std::ios_base::in|std::ios_base::out);
+
 };
 
 class gzstreambase : virtual public std::ios {
@@ -101,6 +104,9 @@
     void open( const char* name, int open_mode = std::ios::in) {
         gzstreambase::open( name, open_mode);
     }
+    igzstream& seekg(std::streampos); 
+    igzstream& seekg(std::streamoff, std::ios_base::seekdir);
+
 };
 
 class ogzstream : public gzstreambase, public std::ostream {
@@ -112,6 +118,8 @@
     void open( const char* name, int open_mode = std::ios::out) {
         gzstreambase::open( name, open_mode);
     }
+    ogzstream& seekp(std::streampos); 
+    ogzstream& seekp(std::streamoff, std::ios_base::seekdir);
 };
 
 #ifdef GZSTREAM_NAMESPACE
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/hdf_pro.cpp cvs/gdl/src/hdf_pro.cpp
--- gdl-0.9rc4/src/hdf_pro.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/hdf_pro.cpp	2010-04-16 11:22:53.000000000 -0600
@@ -49,7 +49,7 @@
 
   void hdf_sd_getdata_pro( EnvT* e)
   {
-    SizeT nParam=e->NParam();
+    SizeT nParam=e->NParam(2);
     char fieldname[256];
     int32 rank;
     int32 dims[MAXRANK];
@@ -124,7 +124,6 @@
       }
     }
 
-
     // Reverse order of edges for setting up GDL array(
     for( SizeT i = 0; i < rank/2; i++) {
       int32 tempedge = edges[i];
@@ -539,7 +538,7 @@
 
   void hdf_vg_gettrs_pro( EnvT* e)
   {
-    SizeT nParam=e->NParam();
+    SizeT nParam=e->NParam(3);
     char groupname[256];
     int32 nentries;
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/initsysvar.cpp cvs/gdl/src/initsysvar.cpp
--- gdl-0.9rc4/src/initsysvar.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/initsysvar.cpp	2010-04-16 11:22:53.000000000 -0600
@@ -40,7 +40,7 @@
 
   // the index of some system variables
   UInt pathIx, promptIx, edit_inputIx, quietIx, 
-    dIx, pIx, xIx, yIx, zIx, vIx, cIx, MouseIx,
+    dIx, pIx, xIx, yIx, zIx, vIx, gdlIx, cIx, MouseIx,
     errorStateIx, errorIx, errIx, err_stringIx, valuesIx,
     journalIx, exceptIx, mapIx, cpuIx, dirIx, stimeIx, warnIx;
 
@@ -353,9 +353,10 @@
     sysVarList.push_back( order);
 
     // !GDL (to allow distinguish IDL/GDL with DEFSYSV, '!gdl', exists=exists )
-    DStringGDL *gdlData = new DStringGDL( "GDL");
-    DVar *gdl = new DVar( "GDL", gdlData);
-    sysVarList.push_back( gdl);
+    DStructGDL*  gdlStruct = new DStructGDL( "!GNUDATALANGUAGE");
+    gdlStruct->NewTag("RELEASE", new DStringGDL( VERSION));
+    DVar *gdl        = new DVar( "GDL", gdlStruct);
+    sysVarList.push_back(gdl);
     sysVarRdOnlyList.push_back( gdl); // make it read only
 
     // !DPI
@@ -444,7 +445,7 @@
     vIx                = sysVarList.size();
     sysVarList.push_back(v);
     sysVarRdOnlyList.push_back(v);
-
+    
     // !Mouse
     DStructGDL*  MouseData = new DStructGDL( "!MOUSE");
     MouseData->NewTag("X", new DLongGDL( 0));
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/io.cpp cvs/gdl/src/io.cpp
--- gdl-0.9rc4/src/io.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/io.cpp	2010-07-07 14:41:02.003005126 -0600
@@ -26,15 +26,18 @@
 
 const string StreamInfo( ios* searchStream)
 {
+  if( dynamic_cast<istringstream*>( searchStream)  != NULL)
+	return "Unit: 0, <stdin> (redirected)";
+	
   if( searchStream == &cin) return "Unit: 0, <stdin>";
   if( searchStream == &cout) return "Unit: -1, <stdout>";
   if( searchStream == &cerr) return "Unit: -2, <stderr>";
   for( SizeT i=0; i<fileUnits.size(); i++)
     {
       if( fileUnits[ i].anyStream != NULL &&  fileUnits[ i].anyStream->FStream() == searchStream)
-	{
-	  return "Unit: "+i2s(i+1)+", File: "+fileUnits[ i].Name();
-	}
+		{
+			return "Unit: "+i2s(i+1)+", File: "+fileUnits[ i].Name();
+		}
     }
   return "Internal error: Stream not found.";
 }
@@ -85,7 +88,7 @@
 	  delete ogzStream;
 	  ogzStream = NULL;
 	}
-      if( (mode_ & std::ios::in))
+      if( (mode_ & std::ios::in) && !(mode_ & std::ios::out))
 	{
 	  if( igzStream == NULL)
 	    igzStream = new igzstream();
@@ -133,6 +136,8 @@
 		      SizeT width_,
 		      bool f77_, bool compress_)
 {
+    string expName = name_;
+    WordExp( expName);
  
   f77 = f77_;
 
@@ -146,11 +151,11 @@
   if( anyStream == NULL)
 	anyStream = new AnyStream();
 
-  name=name_;
+  name=expName;
   mode=mode_;
   compress = compress_;
 
-  anyStream->Open(name_,mode_,compress_);
+  anyStream->Open(expName,mode_,compress_);
   
   swapEndian = swapEndian_;
   deleteOnClose = dOC;
@@ -564,6 +569,43 @@
     return 0;
 }
 
+std::streampos gzstreambuf::pubseekpos(std::streampos sp, std::ios_base::openmode which)
+{
+	if(is_open())
+	{
+		if((which==std::ios_base::in && this->mode & std::ios::in) || /* read mode : ok */
+			(which==std::ios_base::out && this->mode & std::ios::out &&
+			static_cast<z_off_t>(sp)>=gztell(this->file))) /* write mode : seek forward only */
+		{
+			z_off_t off=gzseek(this->file,static_cast<z_off_t>(sp),SEEK_SET);
+			if(which==std::ios_base::in)
+				setg(buffer+buf4,buffer+buf4,buffer+buf4);
+			return off;
+		}
+		else return static_cast<std::streampos>(gztell(this->file)); /* Just don't Seek, no error */
+	}
+	return -1;
+}
+
+std::streampos gzstreambuf::pubseekoff(std::streamoff off, std::ios_base::seekdir way, std::ios_base::openmode which)
+{
+	if(is_open() && way!=std::ios_base::end) /* No seek with SEEK_END */
+	{
+		if((which==std::ios_base::in && this->mode & std::ios::in) || /* read mode : ok */
+			(which==std::ios_base::out && this->mode & std::ios::out && /* write mode : ok if */
+			((way==std::ios_base::cur && off>=0) || /* SEEK_CUR with positive offset */
+				(way==std::ios_base::beg && static_cast<z_off_t>(off)>=gztell(this->file))))) /* or SEEK_SET which go forward */
+		{
+			z_off_t off=gzseek(this->file,static_cast<z_off_t>(off),(way==std::ios_base::beg?SEEK_SET:SEEK_CUR));
+			if(which==std::ios_base::in)
+				setg(buffer+buf4,buffer+buf4,buffer+buf4);
+			return off;
+		}
+		else return static_cast<std::streampos>(gztell(this->file)); /* Just don't Seek, no error */
+	}
+	return -1;
+}
+
 // --------------------------------------
 // class gzstreambase:
 // --------------------------------------
@@ -588,6 +630,46 @@
             clear( rdstate() | std::ios::badbit);
 }
 
+// --------------------------------------
+// class igzstream:
+// --------------------------------------
+
+igzstream& igzstream::seekg(std::streampos pos) 
+{
+	if(rdbuf()->pubseekpos(pos,ios_base::in)==std::streampos(-1))
+		this->setstate(std::ios_base::badbit);
+	else this->setstate(std::ios_base::goodbit);
+	return *this;
+}
+
+igzstream& igzstream::seekg(std::streamoff off, std::ios_base::seekdir dir)
+{ 
+	if(rdbuf()->pubseekoff(off,dir,ios_base::in)==std::streampos(-1))
+		this->setstate(std::ios_base::badbit);
+	else this->setstate(std::ios_base::goodbit);
+	return *this;
+}
+
+// --------------------------------------
+// class ogzstream:
+// --------------------------------------
+
+ogzstream& ogzstream::seekp(std::streampos pos) 
+{
+	if(rdbuf()->pubseekpos(pos,ios_base::out)==std::streampos(-1))
+		this->setstate(std::ios_base::badbit);
+	else this->setstate(std::ios_base::goodbit);
+	return *this;
+}
+
+ogzstream& ogzstream::seekp(std::streamoff off, std::ios_base::seekdir dir)
+{ 
+	if(rdbuf()->pubseekoff(off,dir,ios_base::out)==std::streampos(-1))
+		this->setstate(std::ios_base::badbit);
+	else this->setstate(std::ios_base::goodbit);
+	return *this;
+}
+
 #ifdef GZSTREAM_NAMESPACE
 } // namespace GZSTREAM_NAMESPACE
 #endif
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/io.hpp cvs/gdl/src/io.hpp
--- gdl-0.9rc4/src/io.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/io.hpp	2010-04-16 11:22:53.000000000 -0600
@@ -4,7 +4,7 @@
    begin                : July 22 2002
    copyright            : (C) 2002 by Marc Schellens
    email                : m_schellens@users.sf.net
-***************************************************************************/
+***************************************************************************/ 
 
 /* *************************************************************************
  *                                                                         *
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/lapack.cpp cvs/gdl/src/lapack.cpp
--- gdl-0.9rc4/src/lapack.cpp	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/lapack.cpp	2010-02-02 14:26:59.000000000 -0700
@@ -0,0 +1,19 @@
+/***************************************************************************
+                          lapack.cpp  -  lapack routines
+                             -------------------
+    begin                : January 31 2010
+    copyright            : (C) 2010y Marc Schellens
+    email                : m_schellens@users.sf.net
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+//#include <lapackpp.h>
+
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/libinit.cpp cvs/gdl/src/libinit.cpp
--- gdl-0.9rc4/src/libinit.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/libinit.cpp	2010-07-07 14:41:02.016942647 -0600
@@ -38,7 +38,7 @@
 #include "gsl_fun.hpp"
 
 #ifdef USE_PYTHON
-#include "gdlpython.hpp"
+#  include "gdlpython.hpp"
 #endif
 
 #include "grib.hpp"
@@ -316,9 +316,10 @@
   new DLibPro(lib::writeu,string("WRITEU"),-1,writeuKey);
   new DLibPro(lib::readu,string("READU"),-1,writeuKey);
 
-  const string resolve_routineKey[]={"EITHER","IS_FUNCTION",KLISTEND};
+  const string resolve_routineWarnKey[]={"EITHER","IS_FUNCTION","NO_RECOMPILE",KLISTEND};
+  const string resolve_routineKey[]={KLISTEND};
   new DLibPro(lib::resolve_routine,string("RESOLVE_ROUTINE"),1,
-	      resolve_routineKey);
+	      NULL, resolve_routineWarnKey);
 
   const string assocKey[]={"PACKED",KLISTEND};
   new DLibFunRetNew(lib::assoc,string("ASSOC"),3,assocKey);
@@ -394,13 +395,13 @@
   const string whereKey[]={"COMPLEMENT","NCOMPLEMENT",KLISTEND};
   new DLibFunRetNew(lib::where,string("WHERE"),2,whereKey);
 
-  const string totalKey[]={"CUMULATIVE","DOUBLE","NAN","INTEGER",KLISTEND};
+  const string totalKey[]={"CUMULATIVE","DOUBLE","NAN","INTEGER","PRESERVE_TYPE",KLISTEND};
   new DLibFunRetNew(lib::total,string("TOTAL"),2,totalKey,NULL,true);
 
-  const string productKey[]={"CUMULATIVE","NAN",KLISTEND};
+  const string productKey[]={"CUMULATIVE","NAN","INTEGER","PRESERVE_TYPE",KLISTEND};
   new DLibFunRetNew(lib::product,string("PRODUCT"),2,productKey,NULL,true);
 
-  new DLibFunRetNew(lib::n_params,string("N_PARAMS"),1); // IDL allows one paramter
+  new DLibFunRetNew(lib::n_params,string("N_PARAMS"),1); // IDL allows one parameter
   new DLibFunRetNew(lib::keyword_set,string("KEYWORD_SET"),1);
 
   const string array_equalKey[]={"NO_TYPECONV",KLISTEND};
@@ -428,13 +429,12 @@
 //   new DLibFun(lib::max_fun,string("MAX"),2,maxKey);
 
 #ifdef USE_PYTHON
-
   const string python_funKey[]={"ARGV","DEFAULTRETURNVALUE",KLISTEND};
   new DLibFun(lib::gdlpython_fun,string("PYTHON"),-1,python_funKey);
 
   const string python_proKey[]={"ARGV",KLISTEND};
   new DLibPro(lib::gdlpython_pro,string("PYTHON"),-1,python_proKey);
-#endif  
+#endif
 
   // graphics *******************************************************
   const string windowKey[]={"COLORS","FREE","PIXMAP","RETAIN","TITLE",
@@ -461,7 +461,8 @@
     {
       "CLOSE_FILE","FILENAME","LANDSCAPE","PORTRAIT",
       "DECOMPOSED","GET_DECOMPOSED","Z_BUFFERING","SET_RESOLUTION",
-      "SET_CHARACTER_SIZE","GET_VISUAL_DEPTH","XSIZE","YSIZE","COLOR",KLISTEND
+      "SET_CHARACTER_SIZE","GET_VISUAL_DEPTH","XSIZE","YSIZE",
+      "COLOR","GET_SCREEN_SIZE","INCHES",KLISTEND
     };
   const string deviceWarnKey[] = {"RETAIN", KLISTEND};
   new DLibPro(lib::device,string("DEVICE"),0, deviceKey, deviceWarnKey);
@@ -723,6 +724,14 @@
     };
   new DLibPro(lib::xyouts, string("XYOUTS"), 3, xyoutsKey);
 
+  const string polyfillKey[]=
+    {
+      "COLOR","DATA","NORMAL","DEVICE","CLIP","NOCLIP",
+      /*"LINE_FILL","SPACING","LINESTYLE","ORIENTATION","THICK",*/
+      KLISTEND
+    };
+  new DLibPro(lib::polyfill, string("POLYFILL"), 3, polyfillKey);
+
   new DLibPro(lib::erase,string("ERASE"),1);
   
   const string laguerreKey[]={"DOUBLE","COEFFICIENTS",KLISTEND};
@@ -793,6 +802,10 @@
   new DLibFun(lib::wtn, string("WTN"), 2, wtnKey);
   const string zeropolyKey[] = {"DOUBLE", "COMPANION", "JENKINS_TRAUB", KLISTEND };
   new DLibFun(lib::zeropoly, string("IMSL_ZEROPOLY"), 1, zeropolyKey);
+  const string spher_harmKey[] = {"DOUBLE", KLISTEND };
+  new DLibFun(lib::spher_harm, string("SPHER_HARM"), 4, spher_harmKey);
+  const string gdl_erfinvKey[] = {"DOUBLE", KLISTEND };
+  new DLibFun(lib::gdl_erfinv_fun, string("GDL_ERFINV"), 1, gdl_erfinvKey);
 
   // sort lists
   sort( libFunList.begin(), libFunList.end(), CompLibFunName());
Only in gdl-0.9rc4/src: libinit.cpp.orig
Only in gdl-0.9rc4/src: libinit.cpp.rej
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/libinit_jmg.cpp cvs/gdl/src/libinit_jmg.cpp
--- gdl-0.9rc4/src/libinit_jmg.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/libinit_jmg.cpp	2010-05-21 10:23:57.887907432 -0600
@@ -50,11 +50,14 @@
 #include "fftw.hpp"
 #endif
 
+#include "gshhs.hpp"
+
 using namespace std;
 
 void LibInit_jmg()
 {
   const char KLISTEND[] = "";
+
   // the following by Joel Gales <jomoga@users.sourceforge.net>
   const string sizeKey[]={"L64","DIMENSIONS","FILE_LUN","N_DIMENSIONS",
 			  "N_ELEMENTS","STRUCTURE","TNAME","TYPE",KLISTEND};
@@ -89,8 +92,9 @@
 			       "LOCATIONS",KLISTEND};
   new DLibFun(lib::histogram_fun,string("HISTOGRAM"),1,histogramKey);
 
-  const string interpolateKey[]={"CUBIC","GRID","MISSING",KLISTEND};
-  new DLibFun(lib::interpolate_fun,string("INTERPOLATE"),4,interpolateKey);
+  const string interpolateKey[]={"CUBIC","GRID",KLISTEND};
+  const string interpolateWarnKey[]={"MISSING",KLISTEND};
+  new DLibFun(lib::interpolate_fun,string("INTERPOLATE"),4,interpolateKey,interpolateWarnKey);
 
   const string la_triredKey[]={"DOUBLE","UPPER",KLISTEND};
   new DLibPro(lib::la_trired_pro,string("LA_TRIRED"),3,la_triredKey);
@@ -112,8 +116,19 @@
   const string map_proj_inverseKey[]={"RADIANS",KLISTEND};
   new DLibFun(lib::map_proj_inverse_fun,
 	      string("MAP_PROJ_INVERSE"),3,map_proj_inverseKey);
+
 #endif
 
+  // SA: GSHHS dataset
+  // TODO: COASTS, CONTINENTS, ORIENTATION, LIMIT,
+  //       MAP_STRUCTURE, MLINESTYLE, MLINETHICK, SPACING, T3D, ZVALUE
+  const string map_continentsKey[] = {"COLOR", "RIVERS", "COUNTRIES", 
+    "HIRES", "FILL_CONTINENTS", KLISTEND};
+  const string map_continentsWarnKey[] = {"USA", KLISTEND};
+  new DLibPro(lib::map_continents, string("MAP_CONTINENTS"), 0, 
+    map_continentsKey, map_continentsWarnKey);
+
+
   const string convert_coordKey[]={"DATA","DEVICE","NORMAL","T3D","DOUBLE",
 				   "TO_DATA","TO_DEVICE","TO_NORMAL",KLISTEND};
   new DLibFun(lib::convert_coord,string("CONVERT_COORD"),3,convert_coordKey);
@@ -247,14 +262,19 @@
 
 #ifdef HAVE_LIBWXWIDGETS
   const string widget_baseKey[] = {"ALIGN_BOTTOM","ALIGN_CENTER","ALIGN_LEFT","ALIGN_RIGHT","ALIGN_TOP","MBAR","MODAL","BASE_ALIGN_BOTTOM","BASE_ALIGN_CENTER","BASE_ALIGN_LEFT","BASE_ALIGN_RIGHT","BASE_ALIGN_TOP","COLUMN","ROW","CONTEXT_EVENTS","CONTEXT_MENU","EVENT_FUNC","EVENT_PRO","EXCLUSIVE","NONEXCLUSIVE","FLOATING","FRAME","FUNC_GET_VALUE","GRID_LAYOUT","GROUP_LEADER","KBRD_FOCUS_EVENTS","KILL_NOTIFY","MAP","NO_COPY","NOTIFY_REALIZE","PRO_SET_VALUE","SCR_XSIZE","SCR_YSIZE","SCROLL","SENSITIVE","SPACE","TITLE","TLB_FRAME_ATTR","TLB_ICONIFY_EVENTS","TLB_KILL_REQUEST_EVENTS","TLB_MOVE_EVENTS","TLB_SIZE_EVENTS","TOOLBAR","TRACKING_EVENTS","UNITS","UNAME","UVALUE","XOFFSET","XPAD","XSIZE","X_SCROLL_SIZE","YOFFSET","YPAD","YSIZE","Y_SCROLL_SIZE","DISPLAY_NAME","RESOURCE_NAME","RNAME_MBAR",KLISTEND};
-  new DLibFun(lib::widget_base,string("WIDGET_BASE"),0,widget_baseKey);
+  new DLibFun(lib::widget_base,string("WIDGET_BASE"),1,widget_baseKey);
 
   const string widget_buttonKey[] = {"ACCELERATOR","ALIGN_CENTER","ALIGN_LEFT","ALIGN_RIGHT","BITMAP","CHECKED_MENU","DYNAMIC_RESIZE","EVENT_FUNC","EVENT_PRO","FONT","FRAME","FUNC_GET_VALUE","GROUP_LEADER","HELP","KILL_NOTIFY","MENU","NO_COPY","NO_RELEASE","NOTIFY_REALIZE","PRO_SET_VALUE","PUSHBUTTON_EVENTS","SCR_XSIZE","SCR_YSIZE","SENSITIVE","SEPARATOR","TAB_MODE","TOOLTIP","TRACKING_EVENTS","UNAME","UNITS","UVALUE","VALUE","X_BITMAP_EXTRA","XOFFSET","XSIZE","YOFFSET","YSIZE",KLISTEND};
   new DLibFun(lib::widget_button,string("WIDGET_BUTTON"),1,widget_buttonKey);
 
+  const string widget_droplistKey[] = {"DYNAMIC_RESIZE","EVENT_FUNC","EVENT_PRO","FONT","FRAME","FUNC_GET_VALUE","GROUP_LEADER","KILL_NOTIFY","NO_COPY","NOTIFY_REALIZE","PRO_SET_VALUE","RESOURCE_NAME","SCR_XSIZE","SCR_YSIZE","SENSITIVE","TAB_MODE","TITLE","TRACKING_EVENTS","UNAME","UNITS","UVALUE","VALUE","XOFFSET","XSIZE","YOFFSET","YSIZE",KLISTEND};
+  new DLibFun(lib::widget_droplist,string("WIDGET_DROPLIST"),1,widget_droplistKey);
+
   const string widget_textKey[] = {"ALL_EVENTS","CONTEXT_EVENTS","EDITABLE","EVENT_FUNC","EVENT_PRO","FONT","FRAME","FUNC_GET_VALUE","GROUP_LEADER","IGNORE_ACCELERATORS","KBRD_FOCUS_EVENTS","KILL_NOTIFY","NO_COPY","NO_NEWLINE","NOTIFY_REALIZE","PRO_SET_VALUE","RESOURCE_NAME","SCR_XSIZE","SCR_YSIZE","SCROLL","SENSITIVE","TAB_MODE","TRACKING_EVENTS","UNAME","UNITS","UVALUE","VALUE","WRAP","XOFFSET","XSIZE","YOFFSET","YSIZE",KLISTEND};
   new DLibFun(lib::widget_text,string("WIDGET_TEXT"),1,widget_textKey);
 
+  const string widget_labelKey[] = {"ALL_EVENTS","CONTEXT_EVENTS","EDITABLE","EVENT_FUNC","EVENT_PRO","FONT","FRAME","FUNC_GET_VALUE","GROUP_LEADER","IGNORE_ACCELERATORS","KBRD_FOCUS_EVENTS","KILL_NOTIFY","NO_COPY","NO_NEWLINE","NOTIFY_REALIZE","PRO_SET_VALUE","RESOURCE_NAME","SCR_XSIZE","SCR_YSIZE","SCROLL","SENSITIVE","TAB_MODE","TRACKING_EVENTS","UNAME","UNITS","UVALUE","VALUE","WRAP","XOFFSET","XSIZE","YOFFSET","YSIZE",KLISTEND};
+  new DLibFun(lib::widget_label,string("WIDGET_LABEL"),1,widget_labelKey);
 
   const string widget_infoKey[] = {"VALID","MODAL","MANAGED","XMANAGER_BLOCK","CHILD","VERSION",
 				   KLISTEND};
@@ -266,8 +286,11 @@
 
   const string widget_controlKey[] = {"REALIZE","MANAGED","EVENT_PRO",
 				      "XMANAGER_ACTIVE_COMMAND","DESTROY",
-				      "GET_UVALUE","SET_UVALUE","SET_VALUE","MAP",
-				      KLISTEND};
+				      "GET_UVALUE","SET_UVALUE","SET_VALUE",
+				      "MAP","FUNC_GET_VALUE","PRO_SET_VALUE",
+				      "SET_UNAME","NO_COPY","SET_BUTTON",
+				      "SET_DROPLIST_SELECT","SENSITIVE",
+				      "GET_VALUE",KLISTEND};
   new DLibPro(lib::widget_control,string("WIDGET_CONTROL"),1, 
 	      widget_controlKey);
 #endif
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/magick_cl.cpp cvs/gdl/src/magick_cl.cpp
--- gdl-0.9rc4/src/magick_cl.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/magick_cl.cpp	2010-04-16 11:22:53.000000000 -0600
@@ -124,6 +124,8 @@
     try{
       DString filename;
       e->AssureScalarPar<DStringGDL>(0,filename);
+
+      WordExp( filename);
       
       Image a;
       try 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/Makefile.am cvs/gdl/src/Makefile.am
--- gdl-0.9rc4/src/Makefile.am	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/Makefile.am	2010-05-21 10:23:54.639968000 -0600
@@ -43,7 +43,8 @@
 		convol_inc1.cpp convol_inc2.cpp sigfpehandler.cpp sigfpehandler.hpp devicez.hpp \
 		gdlzstream.cpp gdlzstream.hpp gdlwidget.hpp arrayindexlistt.hpp arrayindex.cpp \
 		fftw.cpp fftw.hpp mpi.cpp mpi.hpp plot3d_nr.cpp grib.cpp grib.hpp \
-                prognode.cpp prognodeexpr.cpp strassenmatrix.hpp
+                prognode.cpp prognodeexpr.cpp strassenmatrix.hpp datatypesref.cpp lapack.cpp \
+                gshhs.cpp gshhs.hpp newprognode.cpp
 # Makefile.am Makefile.in 
 
 
@@ -51,7 +52,7 @@
 # standalone program
 if !BUILDASLIBRARY
 bin_PROGRAMS = gdl
-gdl_SOURCES = $(cpp_hpp_files) gdl.cpp
+gdl_SOURCES = $(cpp_hpp_files) gdl.cpp lapack.cpp newprognode.cpp
 # trigger basename generation
 gdl_CXXFLAGS = $(AM_CXXFLAGS)
 # the library search path.
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/Makefile.in cvs/gdl/src/Makefile.in
--- gdl-0.9rc4/src/Makefile.in	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/Makefile.in	2010-05-21 10:23:54.650967800 -0600
@@ -121,7 +121,8 @@
 	gdlzstream.hpp gdlwidget.hpp arrayindexlistt.hpp \
 	arrayindex.cpp fftw.cpp fftw.hpp mpi.cpp mpi.hpp plot3d_nr.cpp \
 	grib.cpp grib.hpp prognode.cpp prognodeexpr.cpp \
-	strassenmatrix.hpp pythongdl.cpp
+	strassenmatrix.hpp datatypesref.cpp lapack.cpp gshhs.cpp \
+	gshhs.hpp newprognode.cpp pythongdl.cpp
 am__objects_1 = assocdata.lo basic_fun_cl.lo basic_fun.lo \
 	basic_fun_jmg.lo basic_op.lo basic_pro.lo basic_pro_jmg.lo \
 	CFMTLexer.lo color.lo convert2.lo datatypes.lo dcommon.lo \
@@ -143,7 +144,8 @@
 	image.lo gdljournal.lo convol.lo convol_inc0.lo convol_inc1.lo \
 	convol_inc2.lo sigfpehandler.lo gdlzstream.lo arrayindex.lo \
 	fftw.lo mpi.lo plot3d_nr.lo grib.lo prognode.lo \
-	prognodeexpr.lo
+	prognodeexpr.lo datatypesref.lo lapack.lo gshhs.lo \
+	newprognode.lo
 @BUILDASLIBRARY_TRUE@am_libgdl_la_OBJECTS = $(am__objects_1) \
 @BUILDASLIBRARY_TRUE@	pythongdl.lo
 libgdl_la_OBJECTS = $(am_libgdl_la_OBJECTS)
@@ -200,7 +202,8 @@
 	gdlzstream.hpp gdlwidget.hpp arrayindexlistt.hpp \
 	arrayindex.cpp fftw.cpp fftw.hpp mpi.cpp mpi.hpp plot3d_nr.cpp \
 	grib.cpp grib.hpp prognode.cpp prognodeexpr.cpp \
-	strassenmatrix.hpp gdl.cpp
+	strassenmatrix.hpp datatypesref.cpp lapack.cpp gshhs.cpp \
+	gshhs.hpp newprognode.cpp gdl.cpp
 am__objects_2 = gdl-assocdata.$(OBJEXT) gdl-basic_fun_cl.$(OBJEXT) \
 	gdl-basic_fun.$(OBJEXT) gdl-basic_fun_jmg.$(OBJEXT) \
 	gdl-basic_op.$(OBJEXT) gdl-basic_pro.$(OBJEXT) \
@@ -246,9 +249,12 @@
 	gdl-sigfpehandler.$(OBJEXT) gdl-gdlzstream.$(OBJEXT) \
 	gdl-arrayindex.$(OBJEXT) gdl-fftw.$(OBJEXT) gdl-mpi.$(OBJEXT) \
 	gdl-plot3d_nr.$(OBJEXT) gdl-grib.$(OBJEXT) \
-	gdl-prognode.$(OBJEXT) gdl-prognodeexpr.$(OBJEXT)
+	gdl-prognode.$(OBJEXT) gdl-prognodeexpr.$(OBJEXT) \
+	gdl-datatypesref.$(OBJEXT) gdl-lapack.$(OBJEXT) \
+	gdl-gshhs.$(OBJEXT) gdl-newprognode.$(OBJEXT)
 @BUILDASLIBRARY_FALSE@am_gdl_OBJECTS = $(am__objects_2) \
-@BUILDASLIBRARY_FALSE@	gdl-gdl.$(OBJEXT)
+@BUILDASLIBRARY_FALSE@	gdl-gdl.$(OBJEXT) gdl-lapack.$(OBJEXT) \
+@BUILDASLIBRARY_FALSE@	gdl-newprognode.$(OBJEXT)
 gdl_OBJECTS = $(am_gdl_OBJECTS)
 @BUILDASLIBRARY_FALSE@gdl_DEPENDENCIES =  \
 @BUILDASLIBRARY_FALSE@	$(top_builddir)/src/antlr/libantlr.a
@@ -491,9 +497,10 @@
 		convol_inc1.cpp convol_inc2.cpp sigfpehandler.cpp sigfpehandler.hpp devicez.hpp \
 		gdlzstream.cpp gdlzstream.hpp gdlwidget.hpp arrayindexlistt.hpp arrayindex.cpp \
 		fftw.cpp fftw.hpp mpi.cpp mpi.hpp plot3d_nr.cpp grib.cpp grib.hpp \
-                prognode.cpp prognodeexpr.cpp strassenmatrix.hpp
+                prognode.cpp prognodeexpr.cpp strassenmatrix.hpp datatypesref.cpp lapack.cpp \
+                gshhs.cpp gshhs.hpp newprognode.cpp
 
-@BUILDASLIBRARY_FALSE@gdl_SOURCES = $(cpp_hpp_files) gdl.cpp
+@BUILDASLIBRARY_FALSE@gdl_SOURCES = $(cpp_hpp_files) gdl.cpp lapack.cpp newprognode.cpp
 # trigger basename generation
 @BUILDASLIBRARY_FALSE@gdl_CXXFLAGS = $(AM_CXXFLAGS)
 # the library search path.
@@ -654,6 +661,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/convol_inc1.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/convol_inc2.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/datatypes.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/datatypesref.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dcommon.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dcompiler.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/default_io.Plo@am__quote@
@@ -693,6 +701,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-convol_inc1.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-convol_inc2.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-datatypes.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-datatypesref.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-dcommon.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-dcompiler.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-default_io.Po@am__quote@
@@ -722,6 +731,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-getfmtast.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-graphics.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-grib.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-gshhs.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-gsl_fun.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-hdf5_fun.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-hdf_fun.Po@am__quote@
@@ -731,6 +741,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-initct.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-initsysvar.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-io.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-lapack.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-libinit.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-libinit_ac.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-libinit_cl.Po@am__quote@
@@ -751,6 +762,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-ncdf_dim_cl.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-ncdf_var_cl.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-new.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-newprognode.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-objects.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-ofmt.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-plot3d_nr.Po@am__quote@
@@ -780,6 +792,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/getfmtast.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/graphics.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/grib.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gshhs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gsl_fun.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hdf5_fun.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hdf_fun.Plo@am__quote@
@@ -789,6 +802,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/initct.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/initsysvar.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/io.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lapack.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libinit.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libinit_ac.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libinit_cl.Plo@am__quote@
@@ -809,6 +823,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ncdf_dim_cl.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ncdf_var_cl.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/new.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/newprognode.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/objects.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ofmt.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/plot3d_nr.Plo@am__quote@
@@ -2205,6 +2220,62 @@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -c -o gdl-prognodeexpr.obj `if test -f 'prognodeexpr.cpp'; then $(CYGPATH_W) 'prognodeexpr.cpp'; else $(CYGPATH_W) '$(srcdir)/prognodeexpr.cpp'; fi`
 
+gdl-datatypesref.o: datatypesref.cpp
+@am__fastdepCXX_TRUE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -MT gdl-datatypesref.o -MD -MP -MF $(DEPDIR)/gdl-datatypesref.Tpo -c -o gdl-datatypesref.o `test -f 'datatypesref.cpp' || echo '$(srcdir)/'`datatypesref.cpp
+@am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/gdl-datatypesref.Tpo $(DEPDIR)/gdl-datatypesref.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='datatypesref.cpp' object='gdl-datatypesref.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -c -o gdl-datatypesref.o `test -f 'datatypesref.cpp' || echo '$(srcdir)/'`datatypesref.cpp
+
+gdl-datatypesref.obj: datatypesref.cpp
+@am__fastdepCXX_TRUE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -MT gdl-datatypesref.obj -MD -MP -MF $(DEPDIR)/gdl-datatypesref.Tpo -c -o gdl-datatypesref.obj `if test -f 'datatypesref.cpp'; then $(CYGPATH_W) 'datatypesref.cpp'; else $(CYGPATH_W) '$(srcdir)/datatypesref.cpp'; fi`
+@am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/gdl-datatypesref.Tpo $(DEPDIR)/gdl-datatypesref.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='datatypesref.cpp' object='gdl-datatypesref.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -c -o gdl-datatypesref.obj `if test -f 'datatypesref.cpp'; then $(CYGPATH_W) 'datatypesref.cpp'; else $(CYGPATH_W) '$(srcdir)/datatypesref.cpp'; fi`
+
+gdl-lapack.o: lapack.cpp
+@am__fastdepCXX_TRUE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -MT gdl-lapack.o -MD -MP -MF $(DEPDIR)/gdl-lapack.Tpo -c -o gdl-lapack.o `test -f 'lapack.cpp' || echo '$(srcdir)/'`lapack.cpp
+@am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/gdl-lapack.Tpo $(DEPDIR)/gdl-lapack.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='lapack.cpp' object='gdl-lapack.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -c -o gdl-lapack.o `test -f 'lapack.cpp' || echo '$(srcdir)/'`lapack.cpp
+
+gdl-lapack.obj: lapack.cpp
+@am__fastdepCXX_TRUE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -MT gdl-lapack.obj -MD -MP -MF $(DEPDIR)/gdl-lapack.Tpo -c -o gdl-lapack.obj `if test -f 'lapack.cpp'; then $(CYGPATH_W) 'lapack.cpp'; else $(CYGPATH_W) '$(srcdir)/lapack.cpp'; fi`
+@am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/gdl-lapack.Tpo $(DEPDIR)/gdl-lapack.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='lapack.cpp' object='gdl-lapack.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -c -o gdl-lapack.obj `if test -f 'lapack.cpp'; then $(CYGPATH_W) 'lapack.cpp'; else $(CYGPATH_W) '$(srcdir)/lapack.cpp'; fi`
+
+gdl-gshhs.o: gshhs.cpp
+@am__fastdepCXX_TRUE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -MT gdl-gshhs.o -MD -MP -MF $(DEPDIR)/gdl-gshhs.Tpo -c -o gdl-gshhs.o `test -f 'gshhs.cpp' || echo '$(srcdir)/'`gshhs.cpp
+@am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/gdl-gshhs.Tpo $(DEPDIR)/gdl-gshhs.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='gshhs.cpp' object='gdl-gshhs.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -c -o gdl-gshhs.o `test -f 'gshhs.cpp' || echo '$(srcdir)/'`gshhs.cpp
+
+gdl-gshhs.obj: gshhs.cpp
+@am__fastdepCXX_TRUE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -MT gdl-gshhs.obj -MD -MP -MF $(DEPDIR)/gdl-gshhs.Tpo -c -o gdl-gshhs.obj `if test -f 'gshhs.cpp'; then $(CYGPATH_W) 'gshhs.cpp'; else $(CYGPATH_W) '$(srcdir)/gshhs.cpp'; fi`
+@am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/gdl-gshhs.Tpo $(DEPDIR)/gdl-gshhs.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='gshhs.cpp' object='gdl-gshhs.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -c -o gdl-gshhs.obj `if test -f 'gshhs.cpp'; then $(CYGPATH_W) 'gshhs.cpp'; else $(CYGPATH_W) '$(srcdir)/gshhs.cpp'; fi`
+
+gdl-newprognode.o: newprognode.cpp
+@am__fastdepCXX_TRUE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -MT gdl-newprognode.o -MD -MP -MF $(DEPDIR)/gdl-newprognode.Tpo -c -o gdl-newprognode.o `test -f 'newprognode.cpp' || echo '$(srcdir)/'`newprognode.cpp
+@am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/gdl-newprognode.Tpo $(DEPDIR)/gdl-newprognode.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='newprognode.cpp' object='gdl-newprognode.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -c -o gdl-newprognode.o `test -f 'newprognode.cpp' || echo '$(srcdir)/'`newprognode.cpp
+
+gdl-newprognode.obj: newprognode.cpp
+@am__fastdepCXX_TRUE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -MT gdl-newprognode.obj -MD -MP -MF $(DEPDIR)/gdl-newprognode.Tpo -c -o gdl-newprognode.obj `if test -f 'newprognode.cpp'; then $(CYGPATH_W) 'newprognode.cpp'; else $(CYGPATH_W) '$(srcdir)/newprognode.cpp'; fi`
+@am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/gdl-newprognode.Tpo $(DEPDIR)/gdl-newprognode.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='newprognode.cpp' object='gdl-newprognode.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -c -o gdl-newprognode.obj `if test -f 'newprognode.cpp'; then $(CYGPATH_W) 'newprognode.cpp'; else $(CYGPATH_W) '$(srcdir)/newprognode.cpp'; fi`
+
 gdl-gdl.o: gdl.cpp
 @am__fastdepCXX_TRUE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -MT gdl-gdl.o -MD -MP -MF $(DEPDIR)/gdl-gdl.Tpo -c -o gdl-gdl.o `test -f 'gdl.cpp' || echo '$(srcdir)/'`gdl.cpp
 @am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/gdl-gdl.Tpo $(DEPDIR)/gdl-gdl.Po
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/math_fun_ac.cpp cvs/gdl/src/math_fun_ac.cpp
--- gdl-0.9rc4/src/math_fun_ac.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/math_fun_ac.cpp	2010-06-03 09:06:39.532739607 -0600
@@ -7,6 +7,10 @@
 
 ****************************************************************************/
 
+
+
+
+
 /***************************************************************************
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -539,15 +543,16 @@
 	return res;
       }
     }
+
     // we also check wether X input array is well ordered ...
     double step;
     int flag_skip=0;
-    for (count = 1; count < nElpYpos; ++count) {
+    for (count = 1; count < nElpXpos; ++count) {
       step=(*Xpos)[count]-(*Xpos)[count-1];
       if (step < 0.0) {
 	if (flag_skip == 0) {
 	  cout << "SPL_INIT (warning): at least one x[n+1]-x[n] step is negative: X is assumed to be ordered" << endl;
-	  flag_skip == 1;
+	  flag_skip = 1; 
 	}
       }
       if (abs(step) == 0.0) {
@@ -560,15 +565,23 @@
     // may be we will have to check the size of these arrays ?
     
     BaseGDL* Yderiv0=e->GetKW(e->KeywordIx("YP0"));
-    if(Yderiv0 !=NULL) cout << "SPL_INIT: sorry Keyword YP0 not ready now"<< endl;
-    BaseGDL* YderivN=e->GetKW(e->KeywordIx("YPN_1"));
-    if(Yderiv0 !=NULL) cout << "SPL_INIT: sorry Keyword YPN_1 not ready now"<< endl;
+    DDoubleGDL* YP0;
+
 
-    (*res)[0] =0.;	
-    (*res)[nElpXpos-1] =0.;	
-    (*U)[0] =0.;	
+    if(Yderiv0 !=NULL && !isinf((*(YP0=e->GetKWAs<DDoubleGDL>(e->KeywordIx("YP0"))))[0] )){ 
+    // first derivative at the point X0 is defined and different to Inf
+      (*res)[0]=-0.5;
+      (*U)[0] = ( 3. / ((*Xpos)[1]-(*Xpos)[0])) * (((*Ypos)[1]-(*Ypos)[0]) / 
+                ((*Xpos)[1]-(*Xpos)[0]) - (*YP0)[0] );
+
+    }else{ 
+      // YP0 is omitted or equal to Inf
+      (*res)[0]=0.;
+      (*U)[0]=0.;
+    }
+    
     
-    double psig, pu, x, xm, xp, y, ym, yp, p;
+    double psig, pu, x, xm, xp, y, ym, yp, p, dx, qn;
 
     for (count = 1; count < nElpXpos-1; ++count) {
       x=(*Xpos)[count];
@@ -586,14 +599,31 @@
       (*U)[count]=(6.00*pu-psig*(*U)[count-1])/p;
     }
 
-    //    for (SizeT count = 0; count < nElpXpos; ++count) {
-    //  cout<< " : " << count << " " << (*res)[count]  << " " << (*U)[count] << endl;
-    //}
+    BaseGDL* YderivN=e->GetKW(e->KeywordIx("YPN_1"));
+    DDoubleGDL* YPN;
+
+    if(YderivN !=NULL && !isinf((*(YPN=e->GetKWAs<DDoubleGDL>(e->KeywordIx("YPN_1"))))[0] )){ 
+    // first derivative at the point XN-1 is defined and different to Inf 
+      (*res)[nElpXpos-1] =0.;
+      qn=0.5;
+
+      dx=((*Xpos)[nElpXpos-1]-(*Xpos)[nElpXpos-2]);
+      (*U)[nElpXpos-1]= (3./dx)*((*YPN)[0]-((*Ypos)[nElpXpos-1]-(*Ypos)[nElpXpos-2])/dx);
+
+    }else{
+    // YPN_1 is omitted or equal to Inf
+      qn=0.;
+      (*U)[nElpXpos-1]=0.;
+    } 
 
-    for (count = nElpXpos-2; count > 0; count--)
-      (*res)[count] =(*res)[count]*(*res)[count+1]+(*U)[count];
+    (*res)[nElpXpos-1] =((*U)[nElpXpos-1]-qn*(*U)[nElpXpos-2])/(qn*(*res)[nElpXpos-2]+ 1.);
 
+    for (count = nElpXpos-2; count != -1; --count){
+       (*res)[count] =(*res)[count]*(*res)[count+1]+(*U)[count];
+    }
+      
     GM_CV0();
+    
   }
   
   BaseGDL* spl_interp_fun( EnvT* e)
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/math_fun.cpp cvs/gdl/src/math_fun.cpp
--- gdl-0.9rc4/src/math_fun.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/math_fun.cpp	2010-07-07 14:41:02.045002917 -0600
@@ -4,7 +4,7 @@
     begin                : July 22 2002
     copyright            : (C) 2002 by Marc Schellens
     email                : m_schellens@users.sf.net
- ***************************************************************************/
+***************************************************************************/
 
 /***************************************************************************
  *                                                                         *
@@ -57,13 +57,13 @@
   void FromToGSL(  srcT* src, destT* dest, SizeT nEl)
   {
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+    {
 #pragma omp for
-    for( SizeT d = 0; d<nEl; ++d)
-      {
-	dest[ d] = src[ d];
-      }
-}
+      for( SizeT d = 0; d<nEl; ++d)
+	{
+	  dest[ d] = src[ d];
+	}
+    }
   }
 
   void svdc( EnvT* e)
@@ -212,13 +212,13 @@
     T* res = new T( p0C->Dim(), BaseGDL::NOZERO);
     SizeT nEl = p0->N_Elements();
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+    {
 #pragma omp for
-    for( SizeT i=0; i<nEl; ++i)
-      {
-	(*res)[ i] = sin((*p0C)[ i]); 
-      }
-}
+      for( SizeT i=0; i<nEl; ++i)
+	{
+	  (*res)[ i] = sin((*p0C)[ i]); 
+	}
+    }
     return res;
   }
 
@@ -231,28 +231,28 @@
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
       e->Throw( 
-			  "Variable is undefined: "+e->GetParString(0));
+	       "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX)
-	return sin_fun_template< DComplexGDL>( p0);
+      return sin_fun_template< DComplexGDL>( p0);
     else if( p0->Type() == COMPLEXDBL)
-	return sin_fun_template< DComplexDblGDL>( p0);
+      return sin_fun_template< DComplexDblGDL>( p0);
     else if( p0->Type() == DOUBLE)
-	return sin_fun_template< DDoubleGDL>( p0);
+      return sin_fun_template< DDoubleGDL>( p0);
     else if( p0->Type() == FLOAT)
-	return sin_fun_template< DFloatGDL>( p0);
+      return sin_fun_template< DFloatGDL>( p0);
     else 
       {
 	DFloatGDL* res = static_cast<DFloatGDL*>
 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = sin((*res)[ i]); 
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = sin((*res)[ i]); 
+	    }
+	}
 	return res;
       }
   }
@@ -264,13 +264,13 @@
     T* res = new T( p0C->Dim(), BaseGDL::NOZERO);
     SizeT nEl = p0->N_Elements();
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+    {
 #pragma omp for
-    for( SizeT i=0; i<nEl; ++i)
-      {
-	(*res)[ i] = cos((*p0C)[ i]); 
-      }
-}
+      for( SizeT i=0; i<nEl; ++i)
+	{
+	  (*res)[ i] = cos((*p0C)[ i]); 
+	}
+    }
     return res;
   }
 
@@ -280,53 +280,71 @@
 
     if( nParam == 0)
       e->Throw( 
-			  "Incorrect number of arguments.");
+	       "Incorrect number of arguments.");
 
     BaseGDL* p0 = e->GetParDefined( 0);//, "COS");
 
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
       e->Throw( 
-			  "Variable is undefined: "+e->GetParString(0));
+	       "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX)
-	return cos_fun_template< DComplexGDL>( p0);
+      return cos_fun_template< DComplexGDL>( p0);
     else if( p0->Type() == COMPLEXDBL)
-	return cos_fun_template< DComplexDblGDL>( p0);
+      return cos_fun_template< DComplexDblGDL>( p0);
     else if( p0->Type() == DOUBLE)
-	return cos_fun_template< DDoubleGDL>( p0);
+      return cos_fun_template< DDoubleGDL>( p0);
     else if( p0->Type() == FLOAT)
-	return cos_fun_template< DFloatGDL>( p0);
+      return cos_fun_template< DFloatGDL>( p0);
     else 
       {
 	DFloatGDL* res = static_cast<DFloatGDL*>
 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = cos((*res)[ i]); 
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = cos((*res)[ i]); 
+	    }
+	}
 	return res;
       }
   }
 
-  template< typename T>
+template< typename T>
   BaseGDL* tan_fun_template( BaseGDL* p0)
   {
     T* p0C = static_cast<T*>( p0);
     T* res = new T( p0C->Dim(), BaseGDL::NOZERO);
     SizeT nEl = p0->N_Elements();
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+    {
 #pragma omp for
-    for( SizeT i=0; i<nEl; ++i)
-      {
-	(*res)[ i] = tan((*p0C)[ i]); 
-      }
-}
+      for( SizeT i=0; i<nEl; ++i)
+	{
+	  (*res)[ i] = tan((*p0C)[ i]); 
+	}
+    }
+    return res;
+  }
+
+template<>
+  BaseGDL* tan_fun_template< DComplexGDL>( BaseGDL* p0)
+  {
+  typedef DComplexGDL T;
+    T* p0C = static_cast<T*>( p0);
+    T* res = new T( p0C->Dim(), BaseGDL::NOZERO);
+    SizeT nEl = p0->N_Elements();
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+    {
+#pragma omp for
+      for( SizeT i=0; i<nEl; ++i)
+	{
+	  (*res)[ i] = tan(static_cast<DComplexDbl>((*p0C)[ i]));
+	}
+    }
     return res;
   }
 
@@ -336,35 +354,35 @@
 
     if( nParam == 0)
       e->Throw( 
-			  "Incorrect number of arguments.");
+	       "Incorrect number of arguments.");
 
     BaseGDL* p0 = e->GetParDefined( 0);//, "TAN");
 
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
       e->Throw( 
-			  "Variable is undefined: "+e->GetParString(0));
+	       "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX)
-	return tan_fun_template< DComplexGDL>( p0);
+      return tan_fun_template< DComplexGDL>( p0);
     else if( p0->Type() == COMPLEXDBL)
-	return tan_fun_template< DComplexDblGDL>( p0);
+      return tan_fun_template< DComplexDblGDL>( p0);
     else if( p0->Type() == DOUBLE)
-	return tan_fun_template< DDoubleGDL>( p0);
+      return tan_fun_template< DDoubleGDL>( p0);
     else if( p0->Type() == FLOAT)
-	return tan_fun_template< DFloatGDL>( p0);
+      return tan_fun_template< DFloatGDL>( p0);
     else 
       {
 	DFloatGDL* res = static_cast<DFloatGDL*>
 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = tan((*res)[ i]); 
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = tan((*res)[ i]); 
+	    }
+	}
 	return res;
       }
   }
@@ -376,13 +394,13 @@
     T* res = new T( p0C->Dim(), BaseGDL::NOZERO);
     SizeT nEl = p0->N_Elements();
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+    {
 #pragma omp for
-    for( SizeT i=0; i<nEl; ++i)
-      {
-	(*res)[ i] = sinh((*p0C)[ i]); 
-      }
-}
+      for( SizeT i=0; i<nEl; ++i)
+	{
+	  (*res)[ i] = sinh((*p0C)[ i]); 
+	}
+    }
     return res;
   }
 
@@ -392,35 +410,35 @@
 
     if( nParam == 0)
       e->Throw( 
-			  "Incorrect number of arguments.");
+	       "Incorrect number of arguments.");
 
     BaseGDL* p0 = e->GetParDefined( 0);//, "SINH");
 
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
       e->Throw( 
-			  "Variable is undefined: "+e->GetParString(0));
+	       "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX)
-	return sinh_fun_template< DComplexGDL>( p0);
+      return sinh_fun_template< DComplexGDL>( p0);
     else if( p0->Type() == COMPLEXDBL)
-	return sinh_fun_template< DComplexDblGDL>( p0);
+      return sinh_fun_template< DComplexDblGDL>( p0);
     else if( p0->Type() == DOUBLE)
-	return sinh_fun_template< DDoubleGDL>( p0);
+      return sinh_fun_template< DDoubleGDL>( p0);
     else if( p0->Type() == FLOAT)
-	return sinh_fun_template< DFloatGDL>( p0);
+      return sinh_fun_template< DFloatGDL>( p0);
     else 
       {
 	DFloatGDL* res = static_cast<DFloatGDL*>
 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = sinh((*res)[ i]); 
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = sinh((*res)[ i]); 
+	    }
+	}
 	return res;
       }
   }
@@ -432,13 +450,13 @@
     T* res = new T( p0C->Dim(), BaseGDL::NOZERO);
     SizeT nEl = p0->N_Elements();
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+    {
 #pragma omp for
-    for( SizeT i=0; i<nEl; ++i)
-      {
-	(*res)[ i] = cosh((*p0C)[ i]); 
-      }
-}
+      for( SizeT i=0; i<nEl; ++i)
+	{
+	  (*res)[ i] = cosh((*p0C)[ i]); 
+	}
+    }
     return res;
   }
 
@@ -448,35 +466,35 @@
 
     if( nParam == 0)
       e->Throw( 
-			  "Incorrect number of arguments.");
+	       "Incorrect number of arguments.");
 
     BaseGDL* p0 = e->GetParDefined( 0);//, "COSH");
 
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
       e->Throw( 
-			  "Variable is undefined: "+e->GetParString(0));
+	       "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX)
-	return cosh_fun_template< DComplexGDL>( p0);
+      return cosh_fun_template< DComplexGDL>( p0);
     else if( p0->Type() == COMPLEXDBL)
-	return cosh_fun_template< DComplexDblGDL>( p0);
+      return cosh_fun_template< DComplexDblGDL>( p0);
     else if( p0->Type() == DOUBLE)
-	return cosh_fun_template< DDoubleGDL>( p0);
+      return cosh_fun_template< DDoubleGDL>( p0);
     else if( p0->Type() == FLOAT)
-	return cosh_fun_template< DFloatGDL>( p0);
+      return cosh_fun_template< DFloatGDL>( p0);
     else 
       {
 	DFloatGDL* res = static_cast<DFloatGDL*>
 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = cosh((*res)[ i]); 
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = cosh((*res)[ i]); 
+	    }
+	}
 	return res;
       }
   }
@@ -488,13 +506,13 @@
     T* res = new T( p0C->Dim(), BaseGDL::NOZERO);
     SizeT nEl = p0->N_Elements();
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+    {
 #pragma omp for
-    for( SizeT i=0; i<nEl; ++i)
-      {
-	(*res)[ i] = tanh((*p0C)[ i]); 
-      }
-}
+      for( SizeT i=0; i<nEl; ++i)
+	{
+	  (*res)[ i] = tanh((*p0C)[ i]); 
+	}
+    }
     return res;
   }
 
@@ -504,35 +522,35 @@
 
     if( nParam == 0)
       e->Throw( 
-			  "Incorrect number of arguments.");
+	       "Incorrect number of arguments.");
 
     BaseGDL* p0 = e->GetParDefined( 0);//, "TANH");
 
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
       e->Throw( 
-			  "Variable is undefined: "+e->GetParString(0));
+	       "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX)
-	return tanh_fun_template< DComplexGDL>( p0);
+      return tanh_fun_template< DComplexGDL>( p0);
     else if( p0->Type() == COMPLEXDBL)
-	return tanh_fun_template< DComplexDblGDL>( p0);
+      return tanh_fun_template< DComplexDblGDL>( p0);
     else if( p0->Type() == DOUBLE)
-	return tanh_fun_template< DDoubleGDL>( p0);
+      return tanh_fun_template< DDoubleGDL>( p0);
     else if( p0->Type() == FLOAT)
-	return tanh_fun_template< DFloatGDL>( p0);
+      return tanh_fun_template< DFloatGDL>( p0);
     else 
       {
 	DFloatGDL* res = static_cast<DFloatGDL*>
 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = tanh((*res)[ i]); 
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = tanh((*res)[ i]); 
+	    }
+	}
 	return res;
       }
   }
@@ -546,25 +564,25 @@
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
       e->Throw( 
-			  "Variable is undefined: "+e->GetParString(0));
+	       "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX || p0->Type() == COMPLEXDBL)
       {
 	e->Throw( 
-			    "Operation illegal with complex type.");
+		 "Operation illegal with complex type.");
       }
     else if( p0->Type() == DOUBLE)
       {
 	DDoubleGDL* p0D = static_cast<DDoubleGDL*>( p0);
 	DDoubleGDL* res = new DDoubleGDL( p0->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = asin((*p0D)[ i]); 
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = asin((*p0D)[ i]); 
+	    }
+	}
 	return res;
       }
     else if( p0->Type() == FLOAT)
@@ -572,13 +590,13 @@
 	DFloatGDL* p0F = static_cast<DFloatGDL*>( p0);
 	DFloatGDL* res = new DFloatGDL( p0->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = asin((*p0F)[ i]); 
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = asin((*p0F)[ i]); 
+	    }
+	}
 	return res;
       }
     else 
@@ -586,13 +604,13 @@
 	DFloatGDL* res = static_cast<DFloatGDL*>
 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = asin((*res)[ i]); 
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = asin((*res)[ i]); 
+	    }
+	}
 	return res;
       }
   }
@@ -606,25 +624,25 @@
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
       e->Throw( 
-			  "Variable is undefined: "+e->GetParString(0));
+	       "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX || p0->Type() == COMPLEXDBL)
       {
 	e->Throw( 
-			    "Operation illegal with complex type.");
+		 "Operation illegal with complex type.");
       }
     else if( p0->Type() == DOUBLE)
       {
 	DDoubleGDL* p0D = static_cast<DDoubleGDL*>( p0);
 	DDoubleGDL* res = new DDoubleGDL( p0->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = acos((*p0D)[ i]); 
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = acos((*p0D)[ i]); 
+	    }
+	}
 	return res;
       }
     else if( p0->Type() == FLOAT)
@@ -632,26 +650,26 @@
 	DFloatGDL* p0F = static_cast<DFloatGDL*>( p0);
 	DFloatGDL* res = new DFloatGDL( p0->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = acos((*p0F)[ i]); 
-	  }
-}	return res;
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = acos((*p0F)[ i]); 
+	    }
+	}	return res;
       }
     else 
       {
 	DFloatGDL* res = static_cast<DFloatGDL*>
 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = acos((*res)[ i]); 
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = acos((*res)[ i]); 
+	    }
+	}
 	return res;
       }
   }
@@ -660,6 +678,10 @@
   template< typename C>
   inline C atanC(const C& c)
   {
+//     double x = c.real();
+//     double x2 = x * x;
+//     double y = c.imag();
+//     return C(0.5 * atan2(2.0*x, 1.0 - x2 - y*y), 0.25 * log( (x2 + (y+1)*(y+1)) / (x2 + (y-1)*(y-1)) ));
     const C i(0.0,1.0);
     const C one(1.0,0.0);
     return log( (one + i * c) / (one - i * c)) / (C(2.0,0.0)*i);
@@ -681,18 +703,18 @@
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
       e->Throw( 
-			  "Variable is undefined: "+e->GetParString(0));
+	       "Variable is undefined: "+e->GetParString(0));
     
     if( nParam == 2)
       {
 	BaseGDL* p1 = e->GetPar( 1);
 	if( p1 == NULL)
 	  e->Throw( 
-			      "Variable is undefined: "+e->GetParString(1));
+		   "Variable is undefined: "+e->GetParString(1));
 	SizeT nEl1 = p1->N_Elements();
 	if( nEl1 == 0)
 	  e->Throw( 
-			      "Variable is undefined: "+e->GetParString(1));
+		   "Variable is undefined: "+e->GetParString(1));
 	
 	DType t = (DTypeOrder[ p0->Type()] > DTypeOrder[ p1->Type()])? p0->Type() : p1->Type();
  
@@ -707,7 +729,7 @@
 	SizeT nElMin = p0dim ? nEl : nEl1;
         SizeT i, zero = 0, *i0, *i1;
         i0 = p0->Rank() == 0 ? &zero : &i, 
-        i1 = p1->Rank() == 0 ? &zero : &i;
+	  i1 = p1->Rank() == 0 ? &zero : &i;
 
 	if( t == COMPLEX)
 	  {
@@ -795,7 +817,7 @@
 
 	    DFloatGDL* res = new DFloatGDL( dim, BaseGDL::NOZERO);
 	    for (i = 0; i < nElMin; ++i) (*res)[i] = 
-              (float)atan2((double)(*p0F)[*i0], (double)(*p1F)[*i1]); 
+					   (float)atan2((double)(*p0F)[*i0], (double)(*p1F)[*i1]); 
 	    return res;
 	  }
 	else 
@@ -825,65 +847,67 @@
 	    DComplexGDL* p0C = static_cast<DComplexGDL*>( p0);
 	    DFloatGDL* res = new DFloatGDL( p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	    {
 #pragma omp for
-	    for( SizeT i=0; i<nEl; ++i)
-	      {
-		DComplex& C = (*p0C)[ i];
-		(*res)[ i] = (float)atan2((double)C.imag(), (double)C.real());
-	      }
-}
+	      for( SizeT i=0; i<nEl; ++i)
+		{
+		  DComplex& C = (*p0C)[ i];
+		  (*res)[ i] = (float)atan2((double)C.imag(), (double)C.real());
+		}
+	    }
 	    return res;
 	  }
 	else if( p0->Type() == COMPLEX)
-        {
-	  DComplexGDL* p0C = static_cast<DComplexGDL*>( p0);
-	  DComplexGDL* res = new DComplexGDL( p0->Dim(), BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
-#pragma omp for
-	  for( SizeT i=0; i<nEl; ++i) (*res)[ i] = atanC((*p0C)[ i]); 
-}
-          return res;
-        }  
+	  {
+	    DComplexGDL* p0C = static_cast<DComplexGDL*>( p0);
+	    DComplexGDL* res = new DComplexGDL( p0->Dim(), BaseGDL::NOZERO);
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+	    {
+#pragma omp for
+	      for( SizeT i=0; i<nEl; ++i) (
+			*res)[ i] = atanC((*p0C)[ i]);
+	    }
+	    return res;
+	  }  
 	else if( p0->Type() == COMPLEXDBL && e->KeywordSet(phaseIx))
 	  {
 	    DComplexDblGDL* p0C = static_cast<DComplexDblGDL*>( p0);
 	    DDoubleGDL* res = new DDoubleGDL( p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	    {
 #pragma omp for
-	    for( SizeT i=0; i<nEl; ++i)
-	      {
-		DComplexDbl& C = (*p0C)[ i];
-		(*res)[ i] = atan2( C.imag(), C.real());
-	      }
-}
+	       for( SizeT i=0; i<nEl; ++i)
+	      	      {
+	      		DComplexDbl& C = (*p0C)[ i];
+	      		(*res)[ i] = atan2( C.imag(), C.real());
+	      	      }
+	    }
 	    return res;
 	  }
 	else if( p0->Type() == COMPLEXDBL)
-        {
-	  DComplexDblGDL* p0C = static_cast<DComplexDblGDL*>( p0);
-	  DComplexDblGDL* res = new DComplexDblGDL( p0->Dim(), BaseGDL::NOZERO);
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
-#pragma omp for
-	  for( SizeT i=0; i<nEl; ++i) (*res)[ i] = atanC((*p0C)[ i]); 
-}
-          return res;
-        }  
+	  {
+	    DComplexDblGDL* p0C = static_cast<DComplexDblGDL*>( p0);
+	    DComplexDblGDL* res = new DComplexDblGDL( p0->Dim(), BaseGDL::NOZERO);
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+	    {
+#pragma omp for
+	      for( SizeT i=0; i<nEl; ++i)
+			(*res)[ i] = atanC((*p0C)[ i]);
+	    }
+	    return res;
+	  }  
 	else if( p0->Type() == DOUBLE)
 	  {
 	    DDoubleGDL* p0D = static_cast<DDoubleGDL*>( p0);
 	    DDoubleGDL* res = new DDoubleGDL( p0->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	    {
 #pragma omp for
-	    for( SizeT i=0; i<nEl; ++i)
-	      {
-		(*res)[ i] = atan((*p0D)[ i]); 
-	      }
-}
+	      for( SizeT i=0; i<nEl; ++i)
+		{
+		  (*res)[ i] = atan((*p0D)[ i]); 
+		}
+	    }
 	    return res;
 	  }
 	else if( p0->Type() == FLOAT)
@@ -891,13 +915,13 @@
 	    DFloatGDL* p0F = static_cast<DFloatGDL*>( p0);
 	    DFloatGDL* res = new DFloatGDL( p0->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	    {
 #pragma omp for
-	    for( SizeT i=0; i<nEl; ++i)
-	      {
-		(*res)[ i] = atan((*p0F)[ i]); 
-	      }
-}
+	      for( SizeT i=0; i<nEl; ++i)
+		{
+		  (*res)[ i] = atan((*p0F)[ i]); 
+		}
+	    }
 	    return res;
 	  }
 	else 
@@ -905,30 +929,30 @@
 	    DFloatGDL* res = static_cast<DFloatGDL*>
 	      (p0->Convert2( FLOAT, BaseGDL::COPY));
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	    {
 #pragma omp for
-	    for( SizeT i=0; i<nEl; ++i)
-	      {
-		(*res)[ i] = atan((*res)[ i]); 
-	      }
-}
+	      for( SizeT i=0; i<nEl; ++i)
+		{
+		  (*res)[ i] = atan((*res)[ i]); 
+		}
+	    }
 	    return res;
 	  }
       }
   }
 
-//   template< typename T>
-//   BaseGDL* alog_fun_template( BaseGDL* p0)
-//   {
-//     T* p0C = static_cast<T*>( p0);
-//     T* res = new T( p0C->Dim(), BaseGDL::NOZERO);
-//     SizeT nEl = p0->N_Elements();
-//     for( SizeT i=0; i<nEl; ++i)
-//       {
-// 	(*res)[ i] = log((*p0C)[ i]); 
-//       }
-//     return res;
-//   }
+  //   template< typename T>
+  //   BaseGDL* alog_fun_template( BaseGDL* p0)
+  //   {
+  //     T* p0C = static_cast<T*>( p0);
+  //     T* res = new T( p0C->Dim(), BaseGDL::NOZERO);
+  //     SizeT nEl = p0->N_Elements();
+  //     for( SizeT i=0; i<nEl; ++i)
+  //       {
+  // 	(*res)[ i] = log((*p0C)[ i]); 
+  //       }
+  //     return res;
+  //   }
 
   BaseGDL* alog_fun( EnvT* e)
   {
@@ -948,68 +972,68 @@
 	}
       else
 	return p0->Log(); //alog_fun_template< DComplexGDL>( p0);
-//     else if( p0->Type() == COMPLEXDBL)
-//       return p0->Log(); //alog_fun_template< DComplexDblGDL>( p0);
-//     else if( p0->Type() == DOUBLE)
-//       return p0->Log(); //alog_fun_template< DDoubleGDL>( p0);
-//     else if( p0->Type() == FLOAT)
-//       return p0->Log(); //alog_fun_template< DFloatGDL>( p0);
+    //     else if( p0->Type() == COMPLEXDBL)
+    //       return p0->Log(); //alog_fun_template< DComplexDblGDL>( p0);
+    //     else if( p0->Type() == DOUBLE)
+    //       return p0->Log(); //alog_fun_template< DDoubleGDL>( p0);
+    //     else if( p0->Type() == FLOAT)
+    //       return p0->Log(); //alog_fun_template< DFloatGDL>( p0);
     else 
       {
 	DFloatGDL* res = static_cast<DFloatGDL*>
 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
 	res->LogThis();
-// 	for( SizeT i=0; i<nEl; ++i)
-// 	  {
-// 	    (*res)[ i] = log((*res)[ i]); 
-// 	  }
+	// 	for( SizeT i=0; i<nEl; ++i)
+	// 	  {
+	// 	    (*res)[ i] = log((*res)[ i]); 
+	// 	  }
 	return res;
       }
   }
 
-//   template< typename T>
-//   BaseGDL* alog10_fun_template( BaseGDL* p0)
-//   {
-//     T* p0C = static_cast<T*>( p0);
-//     T* res = new T( p0C->Dim(), BaseGDL::NOZERO);
-//     SizeT nEl = p0->N_Elements();
-//     for( SizeT i=0; i<nEl; ++i)
-//       {
-// 	(*res)[ i] = log10((*p0C)[ i]); 
-//       }
-//     return res;
-//   }
-
-//   BaseGDL* alog10_fun( EnvT* e)
-//   {
-//     e->NParam( 1);//, "ALOG10");
-
-//     BaseGDL* p0 = e->GetParDefined( 0);//, "ALOG10");
-
-//     SizeT nEl = p0->N_Elements();
-//     if( nEl == 0)
-//       e->Throw( 
-// 			  "ALOG10: Variable is undefined: "+e->GetParString(0));
-    
-//     if( p0->Type() == COMPLEX)
-// 	return alog10_fun_template< DComplexGDL>( p0);
-//     else if( p0->Type() == COMPLEXDBL)
-// 	return alog10_fun_template< DComplexDblGDL>( p0);
-//     else if( p0->Type() == DOUBLE)
-// 	return alog10_fun_template< DDoubleGDL>( p0);
-//     else if( p0->Type() == FLOAT)
-// 	return alog10_fun_template< DFloatGDL>( p0);
-//     else 
-//       {
-// 	DFloatGDL* res = static_cast<DFloatGDL*>
-// 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
-// 	for( SizeT i=0; i<nEl; ++i)
-// 	  {
-// 	    (*res)[ i] = log10((*res)[ i]); 
-// 	  }
-// 	return res;
-//       }
-//   }
+  //   template< typename T>
+  //   BaseGDL* alog10_fun_template( BaseGDL* p0)
+  //   {
+  //     T* p0C = static_cast<T*>( p0);
+  //     T* res = new T( p0C->Dim(), BaseGDL::NOZERO);
+  //     SizeT nEl = p0->N_Elements();
+  //     for( SizeT i=0; i<nEl; ++i)
+  //       {
+  // 	(*res)[ i] = log10((*p0C)[ i]); 
+  //       }
+  //     return res;
+  //   }
+
+  //   BaseGDL* alog10_fun( EnvT* e)
+  //   {
+  //     e->NParam( 1);//, "ALOG10");
+
+  //     BaseGDL* p0 = e->GetParDefined( 0);//, "ALOG10");
+
+  //     SizeT nEl = p0->N_Elements();
+  //     if( nEl == 0)
+  //       e->Throw( 
+  // 			  "ALOG10: Variable is undefined: "+e->GetParString(0));
+    
+  //     if( p0->Type() == COMPLEX)
+  // 	return alog10_fun_template< DComplexGDL>( p0);
+  //     else if( p0->Type() == COMPLEXDBL)
+  // 	return alog10_fun_template< DComplexDblGDL>( p0);
+  //     else if( p0->Type() == DOUBLE)
+  // 	return alog10_fun_template< DDoubleGDL>( p0);
+  //     else if( p0->Type() == FLOAT)
+  // 	return alog10_fun_template< DFloatGDL>( p0);
+  //     else 
+  //       {
+  // 	DFloatGDL* res = static_cast<DFloatGDL*>
+  // 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
+  // 	for( SizeT i=0; i<nEl; ++i)
+  // 	  {
+  // 	    (*res)[ i] = log10((*res)[ i]); 
+  // 	  }
+  // 	return res;
+  //       }
+  //   }
 
   BaseGDL* alog10_fun( EnvT* e)
   {
@@ -1046,13 +1070,13 @@
     T* res = new T( p0C->Dim(), BaseGDL::NOZERO);
     SizeT nEl = p0->N_Elements();
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+    {
 #pragma omp for
-    for( SizeT i=0; i<nEl; ++i)
-      {
-	(*res)[ i] = sqrt((*p0C)[ i]); 
-      }
-}
+      for( SizeT i=0; i<nEl; ++i)
+	{
+	  (*res)[ i] = sqrt((*p0C)[ i]); 
+	}
+    }
     return res;
   }
 
@@ -1065,28 +1089,28 @@
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
       e->Throw( 
-			  "SQRT: Variable is undefined: "+e->GetParString(0));
+	       "SQRT: Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX)
-	return sqrt_fun_template< DComplexGDL>( p0);
+      return sqrt_fun_template< DComplexGDL>( p0);
     else if( p0->Type() == COMPLEXDBL)
-	return sqrt_fun_template< DComplexDblGDL>( p0);
+      return sqrt_fun_template< DComplexDblGDL>( p0);
     else if( p0->Type() == DOUBLE)
-	return sqrt_fun_template< DDoubleGDL>( p0);
+      return sqrt_fun_template< DDoubleGDL>( p0);
     else if( p0->Type() == FLOAT)
-	return sqrt_fun_template< DFloatGDL>( p0);
+      return sqrt_fun_template< DFloatGDL>( p0);
     else 
       {
 	DFloatGDL* res = static_cast<DFloatGDL*>
 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = sqrt( (*res)[ i]); 
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = sqrt( (*res)[ i]); 
+	    }
+	}
 	return res;
       }
   }
@@ -1099,13 +1123,13 @@
     T* res = new T( p0C->Dim(), BaseGDL::NOZERO);
     SizeT nEl = p0->N_Elements();
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+    {
 #pragma omp for
-    for( SizeT i=0; i<nEl; ++i)
-      {
-	(*res)[ i] = abs((*p0C)[ i]); 
-      }
-}
+      for( SizeT i=0; i<nEl; ++i)
+	{
+	  (*res)[ i] = abs((*p0C)[ i]); 
+	}
+    }
     return res;
   }
 
@@ -1125,16 +1149,16 @@
 	DFloatGDL* res = new DFloatGDL(p0C->Dim(), BaseGDL::NOZERO);
 	SizeT nEl = p0->N_Elements();
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-// 	    DComplex& C = (*p0C)[ i];
-// 	    float Creal = C.real(), Cimag = C.imag();
-// 	    (*res)[ i] = sqrt(Creal*Creal + Cimag*Cimag);
- 	    (*res)[ i] = abs( (*p0C)[ i]); //sqrt(Creal*Creal + Cimag*Cimag);
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      // 	    DComplex& C = (*p0C)[ i];
+	      // 	    float Creal = C.real(), Cimag = C.imag();
+	      // 	    (*res)[ i] = sqrt(Creal*Creal + Cimag*Cimag);
+	      (*res)[ i] = abs( (*p0C)[ i]); //sqrt(Creal*Creal + Cimag*Cimag);
+	    }
+	}
 	return res;
       }
     else if( p0->Type() == COMPLEXDBL)
@@ -1143,28 +1167,28 @@
 	DDoubleGDL* res = new DDoubleGDL(p0C->Dim(), BaseGDL::NOZERO);
 	SizeT nEl = p0->N_Elements();
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-// 	    DComplexDbl& C = (*p0C)[ i];
-// 	    double Creal = C.real(), Cimag = C.imag();
-// 	    (*res)[ i] = sqrt(Creal*Creal + Cimag*Cimag);
- 	    (*res)[ i] = abs( (*p0C)[ i]); //sqrt(Creal*Creal + Cimag*Cimag);
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      // 	    DComplexDbl& C = (*p0C)[ i];
+	      // 	    double Creal = C.real(), Cimag = C.imag();
+	      // 	    (*res)[ i] = sqrt(Creal*Creal + Cimag*Cimag);
+	      (*res)[ i] = abs( (*p0C)[ i]); //sqrt(Creal*Creal + Cimag*Cimag);
+	    }
+	}
 	return res;
       }
     else if( p0->Type() == DOUBLE)
-	return abs_fun_template< DDoubleGDL>( p0);
+      return abs_fun_template< DDoubleGDL>( p0);
     else if( p0->Type() == FLOAT)
-	return abs_fun_template< DFloatGDL>( p0);
+      return abs_fun_template< DFloatGDL>( p0);
     else if( p0->Type() == LONG64)
-	return abs_fun_template< DLong64GDL>( p0);
+      return abs_fun_template< DLong64GDL>( p0);
     else if( p0->Type() == LONG)
-	return abs_fun_template< DLongGDL>( p0);
+      return abs_fun_template< DLongGDL>( p0);
     else if( p0->Type() == INT)
-	return abs_fun_template< DIntGDL>( p0);
+      return abs_fun_template< DIntGDL>( p0);
     else if( p0->Type() == ULONG64)
       return p0->Dup();
     else if( p0->Type() == ULONG)
@@ -1178,13 +1202,13 @@
 	DFloatGDL* res = static_cast<DFloatGDL*>
 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = abs( (*res)[ i]); 
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = abs( (*res)[ i]); 
+	    }
+	}
 	return res;
       }
   }
@@ -1200,24 +1224,24 @@
     if (isKWSetL64) {
       DLong64GDL* res = new DLong64GDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+      {
 #pragma omp for
-      for( SizeT i=0; i<nEl; ++i)
-	{
-	  (*res)[ i] = static_cast<DLong64>( round((*p0C)[ i])); 
-	}
-}
+	for( SizeT i=0; i<nEl; ++i)
+	  {
+	    (*res)[ i] = static_cast<DLong64>( round((*p0C)[ i])); 
+	  }
+      }
       return res;
     } else {
       DLongGDL* res = new DLongGDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+      {
 #pragma omp for
-      for( SizeT i=0; i<nEl; ++i)
-	{
-	  (*res)[ i] = static_cast<DLong>( round((*p0C)[ i])); 
-	}
-}
+	for( SizeT i=0; i<nEl; ++i)
+	  {
+	    (*res)[ i] = static_cast<DLong>( round((*p0C)[ i])); 
+	  }
+      }
       return res;
     }
   }
@@ -1231,7 +1255,7 @@
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
       e->Throw( 
-			  "ROUND: Variable is undefined: "+e->GetParString(0));
+	       "ROUND: Variable is undefined: "+e->GetParString(0));
 
     static SizeT l64Ix = e->KeywordIx( "L64");
     bool isKWSetL64 = e->KeywordSet( l64Ix);
@@ -1245,26 +1269,26 @@
 	if (isKWSetL64) {
 	  DLong64GDL* res = new DLong64GDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	  {
 #pragma omp for
-	  for( SizeT i=0; i<nEl; ++i)
-	    {
-	      DComplex& C = (*p0C)[ i];
-	      (*res)[ i] = (DLong64) round(C.real());
-	    }
-}
+	    for( SizeT i=0; i<nEl; ++i)
+	      {
+		DComplex& C = (*p0C)[ i];
+		(*res)[ i] = (DLong64) round(C.real());
+	      }
+	  }
 	  return res;
 	} else {
 	  DLongGDL* res = new DLongGDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	  {
 #pragma omp for
-	  for( SizeT i=0; i<nEl; ++i)
-	    {
-	      DComplex& C = (*p0C)[ i];
-	      (*res)[ i] = (int) round(C.real());
-	    }
-}
+	    for( SizeT i=0; i<nEl; ++i)
+	      {
+		DComplex& C = (*p0C)[ i];
+		(*res)[ i] = (int) round(C.real());
+	      }
+	  }
 	  return res;
 	}
       }
@@ -1277,26 +1301,26 @@
 	if (isKWSetL64) {
 	  DLong64GDL* res = new DLong64GDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	  {
 #pragma omp for
-	  for( SizeT i=0; i<nEl; ++i)
-	    {
-	      DComplexDbl& C = (*p0C)[ i];
-	      (*res)[ i] = (DLong64) round(C.real());
-	    }
-}
+	    for( SizeT i=0; i<nEl; ++i)
+	      {
+		DComplexDbl& C = (*p0C)[ i];
+		(*res)[ i] = (DLong64) round(C.real());
+	      }
+	  }
 	  return res;
 	} else {
 	  DLongGDL* res = new DLongGDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	  {
 #pragma omp for
-	  for( SizeT i=0; i<nEl; ++i)
-	    {
-	      DComplexDbl& C = (*p0C)[ i];
-	      (*res)[ i] = (int) round(C.real());
-	    }
-}
+	    for( SizeT i=0; i<nEl; ++i)
+	      {
+		DComplexDbl& C = (*p0C)[ i];
+		(*res)[ i] = (int) round(C.real());
+	      }
+	  }
 	  return res;
 	}
       }
@@ -1324,13 +1348,13 @@
 	DLongGDL* res = new DLongGDL(p0->Dim(), BaseGDL::NOZERO);
 	SizeT nEl = p0->N_Elements();
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = (int) round((double) (*p0F)[ i]); 
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = (int) round((double) (*p0F)[ i]); 
+	    }
+	}
 	return res;
       }
   }
@@ -1345,24 +1369,24 @@
     if (isKWSetL64) {
       DLong64GDL* res = new DLong64GDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+      {
 #pragma omp for
-      for( SizeT i=0; i<nEl; ++i)
-	{
-	  (*res)[ i] = (DLong64) ceil((*p0C)[ i]); 
-	}
-}
+	for( SizeT i=0; i<nEl; ++i)
+	  {
+	    (*res)[ i] = (DLong64) ceil((*p0C)[ i]); 
+	  }
+      }
       return res;
     } else {
       DLongGDL* res = new DLongGDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+      {
 #pragma omp for
-      for( SizeT i=0; i<nEl; ++i)
-	{
-	  (*res)[ i] = (int) ceil((*p0C)[ i]); 
-	}
-}
+	for( SizeT i=0; i<nEl; ++i)
+	  {
+	    (*res)[ i] = (int) ceil((*p0C)[ i]); 
+	  }
+      }
       return res;
     }
   }
@@ -1376,7 +1400,7 @@
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
       e->Throw( 
-			  "Variable is undefined: "+e->GetParString(0));
+	       "Variable is undefined: "+e->GetParString(0));
 
     bool isKWSetL64 = e->KeywordSet( "L64");
 
@@ -1389,26 +1413,26 @@
 	if (isKWSetL64) {
 	  DLong64GDL* res = new DLong64GDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	  {
 #pragma omp for
-	  for( SizeT i=0; i<nEl; ++i)
-	    {
-	      DComplex& C = (*p0C)[ i];
-	      (*res)[ i] = (DLong64) ceil(C.real());
-	    }
-}
+	    for( SizeT i=0; i<nEl; ++i)
+	      {
+		DComplex& C = (*p0C)[ i];
+		(*res)[ i] = (DLong64) ceil(C.real());
+	      }
+	  }
 	  return res;
 	} else {
 	  DLongGDL* res = new DLongGDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	  {
 #pragma omp for
-	  for( SizeT i=0; i<nEl; ++i)
-	    {
-	      DComplex& C = (*p0C)[ i];
-	      (*res)[ i] = (int) ceil(C.real());
-	    }
-}
+	    for( SizeT i=0; i<nEl; ++i)
+	      {
+		DComplex& C = (*p0C)[ i];
+		(*res)[ i] = (int) ceil(C.real());
+	      }
+	  }
 	  return res;
 	}
       }
@@ -1421,26 +1445,26 @@
 	if (isKWSetL64) {
 	  DLong64GDL* res = new DLong64GDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	  {
 #pragma omp for
-	  for( SizeT i=0; i<nEl; ++i)
-	    {
-	      DComplexDbl& C = (*p0C)[ i];
-	      (*res)[ i] = (DLong64) ceil(C.real());
-	    }
-}
+	    for( SizeT i=0; i<nEl; ++i)
+	      {
+		DComplexDbl& C = (*p0C)[ i];
+		(*res)[ i] = (DLong64) ceil(C.real());
+	      }
+	  }
 	  return res;
 	} else {
 	  DLongGDL* res = new DLongGDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	  {
 #pragma omp for
-	  for( SizeT i=0; i<nEl; ++i)
-	    {
-	      DComplexDbl& C = (*p0C)[ i];
-	      (*res)[ i] = (int) ceil(C.real());
-	    }
-}
+	    for( SizeT i=0; i<nEl; ++i)
+	      {
+		DComplexDbl& C = (*p0C)[ i];
+		(*res)[ i] = (int) ceil(C.real());
+	      }
+	  }
 	  return res;
 	}
       }
@@ -1468,13 +1492,13 @@
 	DLongGDL* res = new DLongGDL(p0->Dim(), BaseGDL::NOZERO);
 	SizeT nEl = p0->N_Elements();
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = (int) ceil((double) (*p0F)[ i]); 
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = (int) ceil((double) (*p0F)[ i]); 
+	    }
+	}
 	return res;
       }
   }
@@ -1489,24 +1513,24 @@
     if (isKWSetL64) {
       DLong64GDL* res = new DLong64GDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+      {
 #pragma omp for
-      for( SizeT i=0; i<nEl; ++i)
-	{
-	  (*res)[ i] = (DLong64) floor((*p0C)[ i]); 
-	}
-}
+	for( SizeT i=0; i<nEl; ++i)
+	  {
+	    (*res)[ i] = (DLong64) floor((*p0C)[ i]); 
+	  }
+      }
       return res;
     } else {
       DLongGDL* res = new DLongGDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+      {
 #pragma omp for
-      for( SizeT i=0; i<nEl; ++i)
-	{
-	  (*res)[ i] = (int) floor((*p0C)[ i]); 
-	}
-}
+	for( SizeT i=0; i<nEl; ++i)
+	  {
+	    (*res)[ i] = (int) floor((*p0C)[ i]); 
+	  }
+      }
       return res;
     }
   }
@@ -1520,7 +1544,7 @@
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
       e->Throw( 
-			  "Variable is undefined: "+e->GetParString(0));
+	       "Variable is undefined: "+e->GetParString(0));
 
     bool isKWSetL64 = e->KeywordSet( "L64");
 
@@ -1533,26 +1557,26 @@
 	if (isKWSetL64) {
 	  DLong64GDL* res = new DLong64GDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	  {
 #pragma omp for
-	  for( SizeT i=0; i<nEl; ++i)
-	    {
-	      DComplex& C = (*p0C)[ i];
-	      (*res)[ i] = (DLong64) floor(C.real());
-	    }
-}
+	    for( SizeT i=0; i<nEl; ++i)
+	      {
+		DComplex& C = (*p0C)[ i];
+		(*res)[ i] = (DLong64) floor(C.real());
+	      }
+	  }
 	  return res;
 	} else {
 	  DLongGDL* res = new DLongGDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	  {
 #pragma omp for
-	  for( SizeT i=0; i<nEl; ++i)
-	    {
-	      DComplex& C = (*p0C)[ i];
-	      (*res)[ i] = (int) floor(C.real());
-	    }
-}
+	    for( SizeT i=0; i<nEl; ++i)
+	      {
+		DComplex& C = (*p0C)[ i];
+		(*res)[ i] = (int) floor(C.real());
+	      }
+	  }
 	  return res;
 	}
       }
@@ -1565,26 +1589,26 @@
 	if (isKWSetL64) {
 	  DLong64GDL* res = new DLong64GDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	  {
 #pragma omp for
-	  for( SizeT i=0; i<nEl; ++i)
-	    {
-	      DComplexDbl& C = (*p0C)[ i];
-	      (*res)[ i] = (DLong64) floor(C.real());
-	    }
-}
+	    for( SizeT i=0; i<nEl; ++i)
+	      {
+		DComplexDbl& C = (*p0C)[ i];
+		(*res)[ i] = (DLong64) floor(C.real());
+	      }
+	  }
 	  return res;
 	} else {
 	  DLongGDL* res = new DLongGDL(p0C->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	  {
 #pragma omp for
-	  for( SizeT i=0; i<nEl; ++i)
-	    {
-	      DComplexDbl& C = (*p0C)[ i];
-	      (*res)[ i] = (int) floor(C.real());
-	    }
-}
+	    for( SizeT i=0; i<nEl; ++i)
+	      {
+		DComplexDbl& C = (*p0C)[ i];
+		(*res)[ i] = (int) floor(C.real());
+	      }
+	  }
 	  return res;
 	}
       }
@@ -1612,13 +1636,13 @@
 	DLongGDL* res = new DLongGDL(p0->Dim(), BaseGDL::NOZERO);
 	SizeT nEl = p0->N_Elements();
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[ i] = (int) floor((double) (*p0F)[ i]); 
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[ i] = (int) floor((double) (*p0F)[ i]); 
+	    }
+	}
 	return res;
       }
   }
@@ -1635,26 +1659,26 @@
       {
 	DComplexGDL* res = static_cast<DComplexGDL*>(p0->Dup());
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[i] = DComplex( (*res)[i].real(), -(*res)[i].imag());
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[i] = DComplex( (*res)[i].real(), -(*res)[i].imag());
+	    }
+	}
 	return res;
       }
     if( p0->Type() == COMPLEXDBL)
       {
 	DComplexDblGDL* res = static_cast<DComplexDblGDL*>(p0->Dup());
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[i] = DComplexDbl( (*res)[i].real(), -(*res)[i].imag());
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[i] = DComplexDbl( (*res)[i].real(), -(*res)[i].imag());
+	    }
+	}
 	return res;
       }
     if( p0->Type() == DOUBLE || 
@@ -1687,13 +1711,13 @@
 	DComplexGDL* c0 = static_cast<DComplexGDL*>(p0);
 	DFloatGDL* res = new DFloatGDL( c0->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[i] = (*c0)[i].imag();
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[i] = (*c0)[i].imag();
+	    }
+	}
 	return res;
       }
     if( p0->Type() == COMPLEXDBL)
@@ -1701,13 +1725,13 @@
 	DComplexDblGDL* c0 = static_cast<DComplexDblGDL*>(p0);
 	DDoubleGDL* res = new DDoubleGDL( c0->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    (*res)[i] = (*c0)[i].imag();
-	  }
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    {
+	      (*res)[i] = (*c0)[i].imag();
+	    }
+	}
 	return res;
       }
 
@@ -1750,11 +1774,11 @@
 	DComplexDblGDL *c0 = static_cast< DComplexDblGDL*>( p0);
 	DComplexDblGDL *res = c0->New( c0->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  (*res)[ i] = exp( (*c0)[ i]);
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    (*res)[ i] = exp( (*c0)[ i]);
+	}
 	return res;
       }
     else if( t == COMPLEX)
@@ -1762,11 +1786,11 @@
 	DComplexGDL *c0 = static_cast< DComplexGDL*>( p0);
 	DComplexGDL *res = c0->New( c0->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  (*res)[ i] = exp( (*c0)[ i]);
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    (*res)[ i] = exp( (*c0)[ i]);
+	}
 	return res;
       }
     else if( t == DOUBLE)
@@ -1774,11 +1798,11 @@
 	DDoubleGDL *c0 = static_cast< DDoubleGDL*>( p0);
 	DDoubleGDL *res = c0->New( c0->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  (*res)[ i] = exp( (*c0)[ i]);
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    (*res)[ i] = exp( (*c0)[ i]);
+	}
 	return res;
       }
     else if( t == FLOAT)
@@ -1786,11 +1810,11 @@
 	DFloatGDL *c0 = static_cast< DFloatGDL*>( p0);
 	DFloatGDL *res = c0->New( c0->Dim(), BaseGDL::NOZERO);
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  (*res)[ i] = exp( (*c0)[ i]);
-}
+	  for( SizeT i=0; i<nEl; ++i)
+	    (*res)[ i] = exp( (*c0)[ i]);
+	}
 	return res;
       }
     else
@@ -1799,17 +1823,17 @@
 	  static_cast< DFloatGDL*>( p0->Convert2( FLOAT, BaseGDL::COPY));
 	
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+	{
 #pragma omp for
-	for( SizeT i=0; i<nEl; ++i)
-	  (*res)[ i] = exp( (*res)[ i]);
-}	
+	  for( SizeT i=0; i<nEl; ++i)
+	    (*res)[ i] = exp( (*res)[ i]);
+	}	
 	return res;
       }
   }
 
   // by medericboquien@users.sourceforge.net
-   BaseGDL* gauss_pdf(EnvT* e)
+  BaseGDL* gauss_pdf(EnvT* e)
   {
     SizeT nParam = e->NParam(1);
     DDoubleGDL* v = static_cast<DDoubleGDL*>(e->GetParDefined(0)->
@@ -1827,7 +1851,7 @@
   }
 
   // by medericboquien@users.sourceforge.net
-   BaseGDL* gauss_cvf(EnvT* e)
+  BaseGDL* gauss_cvf(EnvT* e)
   {
     SizeT nParam = e->NParam(1);
     DDoubleGDL* p = static_cast<DDoubleGDL*>(e->GetParDefined(0)->
@@ -1864,8 +1888,8 @@
         e->Throw("Degrees of freedom must be positive.");
 
     if (nv == 1 && ndf == 1) {
-        res = new DDoubleGDL(dimension(1), BaseGDL::NOZERO);
-        (*res)[0] = gsl_cdf_tdist_P((*v)[0],(*df)[0]);
+      res = new DDoubleGDL(dimension(1), BaseGDL::NOZERO);
+      (*res)[0] = gsl_cdf_tdist_P((*v)[0],(*df)[0]);
     } else if (nv > 1 && ndf == 1) {
       res = new DDoubleGDL(dimension(nv), BaseGDL::NOZERO);
       for (SizeT count = 0; count < nv; ++count)
@@ -1889,7 +1913,7 @@
   }
 
   // by medericboquien@users.sourceforge.net
-   BaseGDL* laguerre(EnvT* e)
+  BaseGDL* laguerre(EnvT* e)
   {
     SizeT nParam = e->NParam(2);
 
@@ -1933,19 +1957,19 @@
       double gamma_kn1 = gsl_sf_gamma(k+n+1.);
       DDoubleGDL* coefKW = new DDoubleGDL(dimension(n+1) , BaseGDL::NOZERO);
 
-/*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
-#pragma omp for*/
+      /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+	{
+	#pragma omp for*/
       for(count = 0;count<=n;++count) {
         dcount = static_cast<double>(count);
         (*coefKW)[count] = ((count & 0x0001)?-1.0:1.0)*gamma_kn1/
           (gsl_sf_gamma(n-dcount+1.)*gsl_sf_gamma(k+dcount+1.)*
            gsl_sf_gamma(dcount+1.));
-        }
-// }        
+      }
+      // }        
       if(e->GetParDefined(0)->Type() != DOUBLE && !e->KeywordSet(doubleKWIx))
         coefKW = static_cast<DDoubleGDL*>(coefKW->
-                        Convert2(FLOAT,BaseGDL::CONVERT));
+					  Convert2(FLOAT,BaseGDL::CONVERT));
       e->SetKW(coefKWIx, coefKW);
     }
 
@@ -1960,7 +1984,7 @@
   // SA: based on equations 5-5 & 5-6 from Snyder (1987) USGS report no 1395 (page 31)
   //     available for download at: http://pubs.er.usgs.gov/djvu/PP/pp_1395.djvu
   template <typename T> inline void ll_arc_distance_helper(
-    T c, T Az, T phi1, T l0, T& phi, T& l, bool degrees) 
+							   T c, T Az, T phi1, T l0, T& phi, T& l, bool degrees) 
   {
     // temporary variables
     T pi = 4 * atan((T)1.), 
@@ -1973,8 +1997,8 @@
     // computing the results
     phi = asin(sin_phi1 * cos_c + cos_phi1 * sin_c * cos_Az) / dtor;
     l = l0 * dtor + atan2(
-      sin_c * sin(Az * dtor), (cos_phi1 * cos_c - sin_phi1 * sin_c * cos_Az)
-    ); 
+			  sin_c * sin(Az * dtor), (cos_phi1 * cos_c - sin_phi1 * sin_c * cos_Az)
+			  ); 
     // placing the result in (-pi, pi)
     while (l < -pi) l += 2 * pi;
     while (l > pi) l -= 2 * pi;
@@ -2005,8 +2029,8 @@
     bool args_complex = args_complexdbl ? false : 
       (p0->Type() == COMPLEX || p1->Type() == COMPLEX || p2->Type() == COMPLEX);
     DType type = (
-      p0->Type() == DOUBLE || p1->Type() == DOUBLE || p2->Type() == DOUBLE || args_complexdbl
-    ) ? DOUBLE : FLOAT;
+		  p0->Type() == DOUBLE || p1->Type() == DOUBLE || p2->Type() == DOUBLE || args_complexdbl
+		  ) ? DOUBLE : FLOAT;
 
     // converting datatypes if neccesarry
     if (p0->Type() != type) p0 = p0->Convert2(type, BaseGDL::COPY);
@@ -2016,35 +2040,35 @@
     // calculating (by calling a helper template function for float/double versions)
     BaseGDL* rt = p0->New(dimension(2, BaseGDL::NOZERO));
     if (type == FLOAT) 
-    {
-      ll_arc_distance_helper(
-        (*static_cast<DFloatGDL*>(p1))[0], 
-        (*static_cast<DFloatGDL*>(p2))[0], 
-        (*static_cast<DFloatGDL*>(p0))[1], 
-        (*static_cast<DFloatGDL*>(p0))[0], 
-        (*static_cast<DFloatGDL*>(rt))[1], 
-        (*static_cast<DFloatGDL*>(rt))[0],
-        e->KeywordSet("DEGREES")
-      );
-    }
+      {
+	ll_arc_distance_helper(
+			       (*static_cast<DFloatGDL*>(p1))[0], 
+			       (*static_cast<DFloatGDL*>(p2))[0], 
+			       (*static_cast<DFloatGDL*>(p0))[1], 
+			       (*static_cast<DFloatGDL*>(p0))[0], 
+			       (*static_cast<DFloatGDL*>(rt))[1], 
+			       (*static_cast<DFloatGDL*>(rt))[0],
+			       e->KeywordSet("DEGREES")
+			       );
+      }
     else
-    {
-      ll_arc_distance_helper(
-        (*static_cast<DDoubleGDL*>(p1))[0], 
-        (*static_cast<DDoubleGDL*>(p2))[0], 
-        (*static_cast<DDoubleGDL*>(p0))[1], 
-        (*static_cast<DDoubleGDL*>(p0))[0], 
-        (*static_cast<DDoubleGDL*>(rt))[1], 
-        (*static_cast<DDoubleGDL*>(rt))[0],
-        e->KeywordSet("DEGREES")
-      );
-    }
+      {
+	ll_arc_distance_helper(
+			       (*static_cast<DDoubleGDL*>(p1))[0], 
+			       (*static_cast<DDoubleGDL*>(p2))[0], 
+			       (*static_cast<DDoubleGDL*>(p0))[1], 
+			       (*static_cast<DDoubleGDL*>(p0))[0], 
+			       (*static_cast<DDoubleGDL*>(rt))[1], 
+			       (*static_cast<DDoubleGDL*>(rt))[0],
+			       e->KeywordSet("DEGREES")
+			       );
+      }
 
     // handling complex/dcomplex conversion
     return rt->Convert2(
-      args_complexdbl ? COMPLEXDBL : args_complex ? COMPLEX : type,
-      BaseGDL::CONVERT
-    );
+			args_complexdbl ? COMPLEXDBL : args_complex ? COMPLEX : type,
+			BaseGDL::CONVERT
+			);
   }
 
   BaseGDL* crossp(EnvT* e)
@@ -2057,22 +2081,22 @@
     BaseGDL *a, *b, *c;
 
     a = (DTypeOrder[p0->Type()] >= DTypeOrder[p1->Type()] ? p0 : p1)->New(dimension(3), BaseGDL::ZERO);
-                          // a = 0
-                          // .--mem: new a (with the type and shape of the result)
+    // a = 0
+    // .--mem: new a (with the type and shape of the result)
     b = p0->CShift(-1)->Convert2(a->Type(), BaseGDL::CONVERT);
-                          // | .--mem: new b
+    // | .--mem: new b
     a->Add(b);            // | | a = shift(p0, -1)
     delete b;             // | `--mem: del b
     b = p1->CShift(-2)->Convert2(a->Type(), BaseGDL::CONVERT);
-                          // | .--mem: new b
+    // | .--mem: new b
     a->Mult(b);           // | | a = shift(p0, -1) * shift(p1, -2)
     b->Sub(b);            // | | b = 0
     c = p0->CShift(1)->Convert2(a->Type(), BaseGDL::CONVERT);
-                          // | | .--mem: new c
+    // | | .--mem: new c
     b->Sub(c);            // | | | b = - shift(p0, 1)
     delete c;             // | | `--mem: del c
     c = p1->CShift(2)->Convert2(a->Type(), BaseGDL::CONVERT); 
-                          // | | .--mem: new c
+    // | | .--mem: new c
     b->Mult(c);           // | | | b = - shift(p0, 1) * shift(p1, 2)
     delete c;             // | | `--mem: del c
     a->Add(b);            // | | a = shift(p0, -1) * shift(p1, -2) - shift(p0, 1) * shift(p1, 2)
@@ -2080,4 +2104,109 @@
     return a;             // `--->
   }
 
+
+  // SA: adapted from the GPL-licensed GNU plotutils (plotutils-2.5/ode/specfun.c)
+  // -----------------------------------------------------------------------------
+  template <typename T> 
+  T inverf (T p)               /* Inverse Error Function */
+  {
+  /*
+   * Source: This routine was derived (using f2c) from the Fortran
+   * subroutine MERFI found in ACM Algorithm 602, obtained from netlib.
+   *
+   * MDNRIS code is copyright 1978 by IMSL, Inc.  Since MERFI has been
+   * submitted to netlib, it may be used with the restrictions that it may
+   * only be used for noncommercial purposes, and that IMSL be acknowledged
+   * as the copyright-holder of the code.
+   */
+
+  /* Initialized data */
+  static T a1 = -.5751703,   a2 = -1.896513,   a3 = -.05496261,
+           b0 = -.113773,    b1 = -3.293474,   b2 = -2.374996,  b3 = -1.187515,
+           c0 = -.1146666,   c1 = -.1314774,   c2 = -.2368201,  c3 = .05073975,
+           d0 = -44.27977,   d1 = 21.98546,    d2 = -7.586103, 
+           e0 = -.05668422,  e1 = .3937021,    e2 = -.3166501,  e3 = .06208963,
+           f0 = -6.266786,   f1 = 4.666263,    f2 = -2.962883,
+           g0 = 1.851159e-4, g1 = -.002028152, g2 = -.1498384,  g3 = .01078639,
+           h0 = .09952975,   h1 = .5211733,    h2 = -.06888301;
+
+    /* Local variables */
+    static T a, b, f, w, x, y, z, sigma, z2, sd, wi, sn;
+
+    x = p;
+
+    /* determine sign of x */
+    sigma = (x > 0 ? 1.0 : -1.0);
+
+    /* Note: -1.0 < x < 1.0 */
+
+    z = abs(x);
+
+    /* z between 0.0 and 0.85, approx. f by a
+       rational function in z  */
+
+    if (z <= 0.85)
+    {
+      z2 = z * z;
+      f = z + z * (b0 + a1 * z2 / (b1 + z2 + a2 / (b2 + z2 + a3 / (b3 + z2))));
+    }
+    else  /* z greater than 0.85 */
+    {
+      a = 1.0 - z;
+      b = z;
+
+      /* reduced argument is in (0.85,1.0), obtain the transformed variable */
+
+      w = sqrt(-(T)log(a + a * b));
+
+      if (w >= 4.0)
+      /* w greater than 4.0, approx. f by a rational function in 1.0 / w */
+      {
+        wi = 1.0 / w;
+        sn = ((g3 * wi + g2) * wi + g1) * wi;
+        sd = ((wi + h2) * wi + h1) * wi + h0;
+        f = w + w * (g0 + sn / sd);
+      }
+      else if (w < 4.0 && w > 2.5)
+      /* w between 2.5 and 4.0, approx.  f by a rational function in w */
+      {
+        sn = ((e3 * w + e2) * w + e1) * w;
+        sd = ((w + f2) * w + f1) * w + f0;
+        f = w + w * (e0 + sn / sd);
+
+        /* w between 1.13222 and 2.5, approx. f by
+           a rational function in w */
+      }
+      else if (w <= 2.5 && w > 1.13222)
+      {
+        sn = ((c3 * w + c2) * w + c1) * w;
+        sd = ((w + d2) * w + d1) * w + d0;
+        f = w + w * (c0 + sn / sd);
+      }
+    }
+    y = sigma * f;
+
+    return y;
+  } 
+  // -----------------------------------------------------------------------------
+
+  BaseGDL* gdl_erfinv_fun(EnvT* e)
+  {
+    BaseGDL* p0 = e->GetNumericParDefined(0);    
+    SizeT n = p0->N_Elements();
+    static int doubleIx = e->KeywordIx("DOUBLE");
+    if (e->KeywordSet(doubleIx) || p0->Type() == DOUBLE)
+    {
+      DDoubleGDL *ret = new DDoubleGDL(dimension(n)), *p0d = e->GetParAs<DDoubleGDL>(0);
+      while (n != 0) --n, (*ret)[n] = inverf((*p0d)[n]);
+      return ret;
+    }
+    else
+    {
+      DFloatGDL *ret = new DFloatGDL(dimension(n)), *p0f = e->GetParAs<DFloatGDL>(0);
+      while (n != 0) --n, (*ret)[n] = inverf((*p0f)[n]); 
+      return ret;
+    }
+  }
+
 } // namespace
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/math_fun.hpp cvs/gdl/src/math_fun.hpp
--- gdl-0.9rc4/src/math_fun.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/math_fun.hpp	2010-07-07 14:41:02.049004086 -0600
@@ -61,6 +61,7 @@
   // by Sylwester Arabas
   BaseGDL* ll_arc_distance(EnvT* e);
   BaseGDL* crossp(EnvT* e);
+  BaseGDL* gdl_erfinv_fun(EnvT* e);
 
 } // namespace
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/math_fun_jmg.cpp cvs/gdl/src/math_fun_jmg.cpp
--- gdl-0.9rc4/src/math_fun_jmg.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/math_fun_jmg.cpp	2010-04-22 09:50:41.000000000 -0600
@@ -1754,8 +1754,18 @@
     trAST = treeParser.getAST();
     ProgNodeP progAST = ProgNode::NewProgNode( trAST);
     auto_ptr< ProgNode> progAST_guard( progAST);
-    GDLInterpreter::RetCode retCode = caller->Interpreter()->execute( progAST);
-  }
+
+	// Marc: necessary for correct FOR loop handling
+	assert( dynamic_cast<EnvUDT*>(caller) != NULL);
+    EnvUDT* env = static_cast<EnvUDT*>(caller);
+    int nForLoopsIn = env->NForLoops();
+    int nForLoops = ProgNode::NumberForLoops( progAST, nForLoopsIn);
+	env->ResizeForLoops( nForLoops);
+
+    RetCode retCode = caller->Interpreter()->execute( progAST);
+  
+  	env->ResizeForLoops( nForLoopsIn);
+}
 
 
   BaseGDL* rk4jmg_fun(EnvT* e)
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/math_fun_jmg.hpp cvs/gdl/src/math_fun_jmg.hpp
--- gdl-0.9rc4/src/math_fun_jmg.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/math_fun_jmg.hpp	2010-07-07 14:41:02.057944625 -0600
@@ -18,15 +18,6 @@
 #ifndef MATH_FUN_HPP_
 #define MATH_FUN_HPP_
 
-#ifdef __cplusplus
-  extern "C" {
-#  include <fenv.h>
-    //#  if defined(__FreeBSD__)
-#    pragma STDC FENV_ACCESS ON
-    //#  endif
-}
-#endif
-
 #include "datatypes.hpp"
 #include "envt.hpp"
 #include "math_utl.hpp"
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/math_utl.hpp cvs/gdl/src/math_utl.hpp
--- gdl-0.9rc4/src/math_utl.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/math_utl.hpp	2010-04-16 11:22:53.000000000 -0600
@@ -22,11 +22,16 @@
 
 //#define ABS(xxx) (( xxx > -xxx)?(xxx):(-xxx))
 
-template< typename T>
-inline T abs( T a) { return (a>=T(0))?a:-a;}
-
+// This caused a compiler error on g++ 4.5, see:
+// http://sourceforge.net/tracker/index.php?func=detail&aid=2949808&group_id=97659&atid=618683
+// template< typename T>
+// inline T abs( T a) { return (a>=T(0))?a:-a;}
 namespace lib {
 
+  // SA: needs to be inside a namespace for GCC 4.5
+  template< typename T>
+  inline T abs( T a) { return (a>=T(0))?a:-a;}
+
 //   int trans513(char *, int, int, int, DType);
 //   int transpose(char *, SizeT, SizeT [], SizeT, DType);
 //   int transpose_perm(char *, SizeT, SizeT [], SizeT, DType, long []);
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/ncdf_cl.cpp cvs/gdl/src/ncdf_cl.cpp
--- gdl-0.9rc4/src/ncdf_cl.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/ncdf_cl.cpp	2010-07-07 14:41:02.064942063 -0600
@@ -67,17 +67,6 @@
     return DStringGDL("UNKNOWN");
   }
 
-  string _ncdf_itos(int i)
-  {
-    int mema=3;
-    char *n=new char(mema);
-    while (snprintf(n, sizeof n, "%d", i) >= sizeof n)
-      {			delete n;mema++; n=new char(mema);   }
-    string s=n;
-    delete n;
-    return s;
-  }
-  
   void ncdf_handle_error(EnvT *e, int status, const char *function)
   {
     if(status != NC_NOERR)
@@ -91,8 +80,8 @@
 	  {
             DLong id;
             e->AssureLongScalarPar( 0, id);
-	    error+=_ncdf_itos(id);
-	    error+=" is not a valid cdfid";
+	    error += i2s(id);
+	    error += " is not a valid cdfid";
 	    
 	    error+="(NC_ERROR=-33)";
 	  }
@@ -163,9 +152,9 @@
 	  {
             DLong id;
             e->AssureLongScalarPar( 0, id);
-	    error+="No Dimension with id = ";
-	    error+=_ncdf_itos(id);
-	    error+=" found. ";
+	    error += "No Dimension with id = ";
+	    error += i2s(id);
+	    error += " found. ";
 	    
 	    error+="(NC_ERROR=-46)";
 	  }
@@ -181,11 +170,11 @@
 	else if(status==NC_ENOTVAR) 	/* Variable not found */
 	  {
             DLong id;
-            e->AssureLongScalarPar( 0, id);
-	    error+="Variable enquiry failed, ";
-	    error+=_ncdf_itos(id);	    
-	    error+=" is not a valid variable id.";
-	    error+="(NC_ERROR=-49)";
+            e->AssureLongScalarPar( 1, id);
+	    error += "Variable enquiry failed, ";
+	    error += i2s(id);	    
+	    error += " is not a valid variable id.";
+	    error += "(NC_ERROR=-49)";
 	  }
       	else if(status==NC_EGLOBAL) 	/* Action prohibited on NC_GLOBAL varid */
 	  {
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/newprognode.cpp cvs/gdl/src/newprognode.cpp
--- gdl-0.9rc4/src/newprognode.cpp	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/newprognode.cpp	2010-05-04 11:32:32.000000000 -0600
@@ -0,0 +1,822 @@
+/***************************************************************************
+                          newprognode.cpp  -  translation from DNodes to ProgNode (our final 'code')
+                             -------------------
+    begin                : July 22 2002
+    copyright            : (C) 2002 by Marc Schellens
+    email                : m_schellens@users.sf.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "includefirst.hpp"
+
+#include <memory>
+
+#include <antlr/ASTFactory.hpp>
+
+#include "dinterpreter.hpp"
+#include "prognodeexpr.hpp"
+#include "basegdl.hpp"
+#include "arrayindexlistt.hpp"
+#include "envt.hpp"
+#include "gdlexception.hpp"
+
+using namespace std;
+
+// helper function for NewProgNode( const RefDNode& refNode)
+// checks if parameterlist is all constant
+// used for constant evaluation at compile time
+bool ConstantPar( ProgNodeP _t)
+{
+
+  while(_t != NULL) {
+    switch ( _t->getType()) {
+    case GDLTokenTypes::KEYDEF_REF:
+      {
+		return false;
+      }
+    case GDLTokenTypes::KEYDEF_REF_EXPR:
+      {
+		return false;
+      }
+    case GDLTokenTypes::KEYDEF:
+      {
+// 	ProgNodeP __t162 = _t;
+
+	// 			match(antlr::RefAST(_t),KEYDEF);
+// 	_t = _t->getFirstChild();
+	// 			match(antlr::RefAST(_t),IDENTIFIER);
+// 	_t = _t->getNextSibling();
+
+	if( !_t->getFirstChild()->getNextSibling()->ConstantNode())
+	  return false;
+			
+// 	_t = __t162;
+	_t = _t->getNextSibling();
+	break;
+      }
+    case GDLTokenTypes::REF:
+      {
+	return false;
+      }
+    case GDLTokenTypes::REF_EXPR:
+      {
+	return false;
+      }
+    case GDLTokenTypes::KEYDEF_REF_CHECK:
+      {
+	return false;
+      }
+    case GDLTokenTypes::REF_CHECK:
+      {
+	return false;
+      }
+    default:
+      {
+	// expr
+	if( !_t->ConstantNode())
+	  return false;
+
+	_t = _t->getNextSibling();
+	break;
+      }
+    } // switch
+  } // while
+
+  return true;
+}
+
+
+
+// here the transcription from DNode to ProgNode takes place
+// references are resolved
+ProgNodeP ProgNode::NewProgNode( const RefDNode& refNode)
+{
+  // this can happen in case of a subroutine with only common blocks
+  if( refNode == RefDNode(antlr::nullAST)) return NULL;
+
+  bool nonCopy = false;
+  if( refNode->GetFirstChild() != RefDNode(antlr::nullAST))
+    {
+      if( NonCopyNode( refNode->GetFirstChild()->getType()))
+	nonCopy = true;
+      if( refNode->GetFirstChild()->GetNextSibling() != RefDNode(antlr::nullAST))
+		if( NonCopyNode( refNode->GetFirstChild()->GetNextSibling()->getType()))
+			nonCopy = true;
+    }
+  
+  // note: constant expressions are always nonCopy
+  // but expressions of constant expressions are not
+  if( nonCopy) // VAR, VARPTR,...
+    {
+      UnaryExpr* newUnary = NULL;
+      BinaryExpr* newNode = NULL;
+      switch( refNode->getType())
+	{
+	case GDLTokenTypes::QUESTION:
+	  {
+	    return new QUESTIONNode( refNode);
+	  }
+
+	  // unary
+	case GDLTokenTypes::UMINUS:
+	  {
+	    // 	// optimize constant unary minus away
+	    // 	// CONSTANT is a non-copy node
+	    // 	if( refNode->GetFirstChild()->getType() == GDLTokenTypes::CONSTANT)
+	    // 	  {
+	    // 	    const RefDNode& child = refNode->GetFirstChild();
+	    // 	    child->ResetCData( child->CData()->UMinus());
+	    // 	    return NewProgNode( child);
+	    // 	  }
+	    // 	else
+	    newUnary = new UMINUSNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::LOG_NEG:
+	  {
+	    newUnary = new LOG_NEGNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::NOT_OP:
+	  {
+	    newUnary = new NOT_OPNode( refNode);
+	    break;
+	  }
+
+	  // binary
+	case GDLTokenTypes::AND_OP:
+	  {
+	    newNode = new AND_OPNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::OR_OP:
+	  {
+	    newNode = new OR_OPNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::XOR_OP:
+	  {
+	    newNode = new XOR_OPNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::LOG_AND:
+	  {
+	    newNode = new LOG_ANDNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::LOG_OR:
+	  {
+	    newNode = new LOG_ORNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::EQ_OP:
+	  {
+	    newNode = new EQ_OPNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::NE_OP:
+	  {
+	    newNode = new NE_OPNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::LE_OP:
+	  {
+	    newNode = new LE_OPNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::LT_OP:
+	  {
+	    newNode = new LT_OPNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::GE_OP:
+	  {
+	    newNode = new GE_OPNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::GT_OP:
+	  {
+	    newNode = new GT_OPNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::PLUS:
+	  {
+	    newNode = new PLUSNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::MINUS:
+	  {
+	    newNode = new MINUSNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::LTMARK:
+	  {
+	    newNode = new LTMARKNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::GTMARK:
+	  {
+	    newNode = new GTMARKNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::ASTERIX:
+	  {
+	    newNode = new ASTERIXNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::MATRIX_OP1:
+	  {
+	    newNode = new MATRIX_OP1NCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::MATRIX_OP2:
+	  {
+	    newNode = new MATRIX_OP2NCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::SLASH:
+	  {
+	    newNode = new SLASHNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::MOD_OP:
+	  {
+	    newNode = new MOD_OPNCNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::POW:
+	  {
+	    newNode = new POWNCNode( refNode);
+	    break;
+	  }
+	  //     case GDLTokenTypes::DEC:
+	  //       {
+	  // 	return new DECNCNode( refNode);
+	  //       }
+	  //     case GDLTokenTypes::INC:
+	  //       {
+	  // 	return new INCNCNode( refNode);
+	  //       }
+	  //     case GDLTokenTypes::POSTDEC:
+	  //       {
+	  // 	return new POSTDECNCNode( refNode);
+	  //       }
+	  //     case GDLTokenTypes::POSTINC:
+	  //       {
+	  // 	return new POSTINCNCNode( refNode);
+	  //       }
+	  //    default:
+	  //      return new DefaultNode( refNode);
+	}
+
+      if( newNode != NULL)
+	{
+	  if( !newNode->ConstantExpr()) return newNode;
+
+	  auto_ptr<ProgNode> guard( newNode);
+
+	  BaseGDL* cData = newNode->Eval();
+
+	  ProgNodeP cN = new CONSTANTNode( newNode->StealNextSibling(), cData);
+	  cN->lineNumber = refNode->getLine();
+	  cN->setText( "C" + refNode->getText());
+
+	  return cN;
+	}
+      else if( newUnary != NULL)
+	{
+	  if( !newUnary->ConstantExpr()) return newUnary;
+
+	  auto_ptr<ProgNode> guard( newUnary);
+
+	  BaseGDL* cData = newUnary->Eval();
+
+	  ProgNodeP cN = new CONSTANTNode( newUnary->StealNextSibling(), cData);
+	  cN->lineNumber = refNode->getLine();
+	  cN->setText( "C" + refNode->getText());
+
+	  return cN;
+	}
+    }
+  else // !nonCopy
+    {
+      UnaryExpr* newUnary = NULL;
+      BinaryExpr* newNode = NULL;
+      switch( refNode->getType())
+	{
+	case GDLTokenTypes::QUESTION:
+	  {
+	    return new QUESTIONNode( refNode);
+	  }
+
+	  // unary
+	case GDLTokenTypes::UMINUS:
+	  {
+	    newUnary = new UMINUSNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::LOG_NEG:
+	  {
+	    newUnary = new LOG_NEGNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::NOT_OP:
+	  {
+	    newUnary = new NOT_OPNode( refNode);
+	    break;
+	  }
+
+	  // binary
+	case GDLTokenTypes::AND_OP:
+	  {
+	    newNode = new AND_OPNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::OR_OP:
+	  {
+	    newNode = new OR_OPNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::XOR_OP:
+	  {
+	    newNode = new XOR_OPNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::LOG_AND:
+	  {
+	    newNode = new LOG_ANDNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::LOG_OR:
+	  {
+	    newNode = new LOG_ORNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::EQ_OP:
+	  {
+	    newNode = new EQ_OPNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::NE_OP:
+	  {
+	    newNode = new NE_OPNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::LE_OP:
+	  {
+	    newNode = new LE_OPNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::LT_OP:
+	  {
+	    newNode = new LT_OPNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::GE_OP:
+	  {
+	    newNode = new GE_OPNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::GT_OP:
+	  {
+	    newNode = new GT_OPNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::PLUS:
+	  {
+	    newNode = new PLUSNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::MINUS:
+	  {
+	    newNode = new MINUSNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::LTMARK:
+	  {
+	    newNode = new LTMARKNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::GTMARK:
+	  {
+	    newNode = new GTMARKNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::ASTERIX:
+	  {
+	    newNode = new ASTERIXNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::MATRIX_OP1:
+	  {
+	    newNode = new MATRIX_OP1Node( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::MATRIX_OP2:
+	  {
+	    newNode = new MATRIX_OP2Node( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::SLASH:
+	  {
+	    newNode = new SLASHNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::MOD_OP:
+	  {
+	    newNode = new MOD_OPNode( refNode);
+	    break;
+	  }
+	case GDLTokenTypes::POW:
+	  {
+	    newNode = new POWNode( refNode);
+	    break;
+	  }
+	  //     case GDLTokenTypes::DEC:
+	  //       {
+	  // 	return new DECNode( refNode);
+	  //       }
+	  //     case GDLTokenTypes::INC:
+	  //       {
+	  // 	return new INCNode( refNode);
+	  //       }
+	  //     case GDLTokenTypes::POSTDEC:
+	  //       {
+	  // 	return new POSTDECNode( refNode);
+	  //       }
+	  //     case GDLTokenTypes::POSTINC:
+	  //       {
+	  // 	return new POSTINCNode( refNode);
+	  //       }
+	  //      default:
+	}
+      if( newNode != NULL)
+	{
+	  if( !newNode->ConstantExpr()) return newNode;
+
+	  auto_ptr<ProgNode> guard( newNode);
+
+	  BaseGDL* cData = newNode->Eval();
+
+	  ProgNodeP cN = new CONSTANTNode( newNode->StealNextSibling(), cData);
+	  cN->lineNumber = refNode->getLine();
+	  cN->setText( "C" + refNode->getText());
+
+	  return cN;
+	}
+      else if( newUnary != NULL)
+	{
+	  if( !newUnary->ConstantExpr()) return newUnary;
+
+	  auto_ptr<ProgNode> guard( newUnary);
+
+	  BaseGDL* cData = newUnary->Eval();
+
+	  ProgNodeP cN = new CONSTANTNode( newUnary->StealNextSibling(), cData);
+	  cN->lineNumber = refNode->getLine();
+	  cN->setText( "C" + refNode->getText());
+
+	  return cN;
+	}
+    }
+
+  // independed of nonCopy:
+  switch( refNode->getType())
+    {
+    case GDLTokenTypes::FCALL_LIB_RETNEW:
+      {
+	ProgNodeP c = new DefaultNode( refNode);
+
+	if( !static_cast<DLibFunRetNew*>(c->libFun)->RetConstant()
+	    || !ConstantPar( c->getFirstChild())) return c;
+	
+	auto_ptr< ProgNode> guard( c);
+	
+	BaseGDL* cData = c->Eval();
+	
+	ProgNodeP cN = new CONSTANTNode( c->StealNextSibling(), cData);
+	cN->lineNumber = refNode->getLine();
+	cN->setText( "C()");
+	
+	return cN;
+      }
+
+    case GDLTokenTypes::FCALL_LIB:
+      {
+		return new FCALL_LIBNode( refNode);
+      }
+    case GDLTokenTypes::MFCALL:
+      {
+		return new MFCALLNode( refNode);
+      }
+    case GDLTokenTypes::MFCALL_PARENT:
+      {
+		return new MFCALL_PARENTNode( refNode);
+      }
+    case GDLTokenTypes::FCALL:
+      {
+		return new FCALLNode( refNode);
+      }
+    case GDLTokenTypes::ARRAYEXPR_MFCALL:
+      {
+		return new ARRAYEXPR_MFCALLNode( refNode);
+      }
+
+    case GDLTokenTypes::ARRAYEXPR:
+      {
+	return new ARRAYEXPRNode( refNode);
+      }
+    
+    case GDLTokenTypes::VAR:
+      {
+	return new VARNode( refNode);
+      }
+    case GDLTokenTypes::VARPTR:
+      {
+	return new VARPTRNode( refNode);
+      }
+    case GDLTokenTypes::SYSVAR:
+      {
+	return new SYSVARNode( refNode);
+      }
+    case GDLTokenTypes::DEREF:
+      {
+	return new DEREFNode( refNode);
+      }
+    case GDLTokenTypes::CONSTANT:
+      {
+	return new CONSTANTNode( refNode);
+      }
+    case GDLTokenTypes::ARRAYDEF:
+      {
+	ARRAYDEFNode* c = new ARRAYDEFNode( refNode);
+	if( !c->ConstantArray()) return c;
+
+	auto_ptr< ARRAYDEFNode> guard( c);
+
+	BaseGDL* cData = c->Eval();
+
+	ProgNodeP cN = new CONSTANTNode( c->StealNextSibling(), cData);
+	cN->lineNumber = refNode->getLine();
+        cN->setText( "[c]");
+
+	return cN;
+
+      }
+    case GDLTokenTypes::ARRAYDEF_CONST:
+      {
+
+	ProgNodeP c = new ARRAYDEFNode( refNode);
+	auto_ptr< ProgNode> guard( c);
+
+	BaseGDL* cData = c->Eval();
+
+	ProgNodeP cN = new CONSTANTNode( c->StealNextSibling(), cData);
+	cN->lineNumber = refNode->getLine();
+        cN->setText( "[C]");
+
+	return cN;
+
+// 	DNode* cN = new DNode();
+//         cN->setType(GDLTokenTypes::CONSTANT);
+// 	cN->setText("[CONSTANT]");
+// 	cN->setNextSibling( refNode->getNextSibling());
+
+// 	refNode->setNextSibling(antlr::nullAST);
+
+// 	ProgNodeP c = new ARRAYDEFNode( refNode);
+// 	auto_ptr< ProgNode> guard( c);
+// 	//c->setType(  GDLTokenTypes::ARRAYDEF);
+
+// 	// evaluate constant
+// 	BaseGDL* res = c->Eval();
+
+// 	cN->ResetCData( res);
+
+// 	return new CONSTANTNode( RefDNode( cN));
+      }
+    case GDLTokenTypes::STRUC:
+      {
+	return new STRUCNode( refNode);
+      }
+    case GDLTokenTypes::NSTRUC:
+      {
+	return new NSTRUCNode( refNode);
+      }
+    case GDLTokenTypes::NSTRUC_REF:
+      {
+ 	return new NSTRUC_REFNode( refNode);
+      }
+    case GDLTokenTypes::ASSIGN:         
+      {
+	return new ASSIGNNode( refNode);
+      }
+    case GDLTokenTypes::ASSIGN_ARRAYEXPR_MFCALL:
+      {
+	return new ASSIGN_ARRAYEXPR_MFCALLNode( refNode);
+      }
+    case GDLTokenTypes::ASSIGN_REPLACE:
+      {
+	return new ASSIGN_REPLACENode( refNode);
+      }
+    case GDLTokenTypes::GOTO:
+      {
+	return new  GOTONode( refNode);
+      }
+    case GDLTokenTypes::BREAK:
+      {
+	return new  BREAKNode( refNode);
+      }
+    case GDLTokenTypes::CONTINUE:
+      {
+	return new  CONTINUENode( refNode);
+      }
+    case GDLTokenTypes::LABEL:
+      {
+	return new  LABELNode( refNode);
+      }
+    case GDLTokenTypes::ON_IOERROR:
+      {
+	return new  ON_IOERRORNode( refNode);
+      }
+    case GDLTokenTypes::ON_IOERROR_NULL:
+      {
+	return new  ON_IOERROR_NULLNode( refNode);
+      }
+    case GDLTokenTypes::RETF:
+      {
+	return new  RETFNode( refNode);
+      }
+    case GDLTokenTypes::RETP:
+      {
+	return new  RETPNode( refNode);
+      }
+    case GDLTokenTypes::FOR:
+      {
+	return new  FORNode( refNode);
+      }
+    case GDLTokenTypes::FOR_STEP:
+      {
+	return new  FOR_STEPNode( refNode);
+      }
+    case GDLTokenTypes::FOREACH:
+      {
+	return new  FOREACHNode( refNode);
+      }
+    case GDLTokenTypes::WHILE:
+      {
+	return new  WHILENode( refNode);
+      }
+    case GDLTokenTypes::REPEAT:
+      {
+	return new  REPEATNode( refNode);
+      }
+    case GDLTokenTypes::CASE:
+      {
+	return new  CASENode( refNode);
+      }
+    case GDLTokenTypes::SWITCH:
+      {
+	return new  SWITCHNode( refNode);
+      }
+    case GDLTokenTypes::BLOCK:
+      {
+	return new  BLOCKNode( refNode);
+      }
+    case GDLTokenTypes::IF:
+      {
+	return new  IFNode( refNode);
+      }
+    case GDLTokenTypes::IF_ELSE:
+      {
+	return new  IF_ELSENode( refNode);
+      }
+    case GDLTokenTypes::PCALL_LIB:
+      {
+	return new  PCALL_LIBNode( refNode);
+      }
+    case GDLTokenTypes::MPCALL:
+      {
+	return new  MPCALLNode( refNode);
+      }
+    case GDLTokenTypes::MPCALL_PARENT:
+      {
+	return new  MPCALL_PARENTNode( refNode);
+      }
+    case GDLTokenTypes::PCALL:
+      {
+	return new  PCALLNode( refNode);
+      }
+    case GDLTokenTypes::DEC:
+      {
+	return new  DECNode( refNode);
+      }
+    case GDLTokenTypes::INC:
+      {
+	return new  INCNode( refNode);
+      }
+      // the following must change their type if precalculation strikes
+		case GDLTokenTypes::KEYDEF_REF:
+		{
+		  ProgNodeP nn = new KEYDEF_REFNode( refNode);
+
+		  if( !nn->getFirstChild()->getNextSibling()->ConstantNode())
+		    return nn;
+
+// 		  nn->setType( GDLTokenTypes::KEYDEF);
+		  delete nn;
+		  nn = new KEYDEFNode( refNode);
+		  return nn;
+		}
+		case GDLTokenTypes::KEYDEF_REF_EXPR:
+		{
+		  ProgNodeP nn = new KEYDEF_REF_EXPRNode( refNode);
+
+		  if( !nn->getFirstChild()->getNextSibling()->ConstantNode())
+		    return nn;
+
+		  delete nn;
+		  nn = new KEYDEFNode( refNode);
+// 		  nn->setType( GDLTokenTypes::KEYDEF);
+		  return nn;
+		}
+		case  GDLTokenTypes::PARAEXPR:
+		  {
+		  ProgNodeP firstChild = 
+		    new ParameterNode( refNode);
+		  return firstChild;
+		  }
+		case  GDLTokenTypes::KEYDEF:
+		  {
+		  ProgNodeP nn = new KEYDEFNode( refNode);
+		  return nn;  
+		  }
+		case GDLTokenTypes::REF:
+		{
+		  ProgNodeP nn = new REFNode( refNode);
+
+		  if( !nn->getFirstChild()->ConstantNode())
+		    return nn;
+		  
+		  delete nn;
+		  
+		  ProgNodeP firstChild = 
+		    new ParameterNode( refNode);//->GetFirstChild());
+		  return firstChild;
+		}
+		case GDLTokenTypes::REF_EXPR:
+		{
+		  ProgNodeP nn = new REF_EXPRNode( refNode);
+
+		  if( !nn->getFirstChild()->ConstantNode())
+		    return nn;
+		  
+		  delete nn;
+		  ProgNodeP firstChild = 
+		    new ParameterNode( refNode);//->GetFirstChild());
+		  return firstChild;
+
+// 		  auto_ptr<ProgNode> guard(nn);
+// 		  return nn->StealFirstChild();
+		}
+ 		case GDLTokenTypes::KEYDEF_REF_CHECK:
+		{
+		  ProgNodeP nn = new KEYDEF_REF_CHECKNode( refNode);
+
+		  if( nn->getFirstChild()->getNextSibling()->getType() != 
+		      GDLTokenTypes::CONSTANT) return nn;
+
+		  delete nn;
+		  nn = new KEYDEFNode( refNode);
+		  return nn;
+		}
+		case GDLTokenTypes::REF_CHECK:
+		{
+		  ProgNodeP nn = new REF_CHECKNode( refNode);
+
+		  if( !nn->getFirstChild()->ConstantNode())
+		    return nn;
+		  
+		  delete nn;
+		  ProgNodeP firstChild = 
+		    new ParameterNode( refNode);
+		  return firstChild;
+
+// 		  auto_ptr<ProgNode> guard(nn);
+// 		  ProgNodeP firstChild = nn->StealFirstChild();
+// 		  firstChild->SetNextSibling( nn->StealNextSibling());
+// 		  return firstChild;
+		}
+    }
+
+  // default
+  return new DefaultNode( refNode);
+}
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/objects.cpp cvs/gdl/src/objects.cpp
--- gdl-0.9rc4/src/objects.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/objects.cpp	2010-07-07 14:41:02.079940950 -0600
@@ -111,26 +111,39 @@
   // insert into structList
   structList.push_back(gdl_size);
 
-  DStructDesc* fstat = new DStructDesc( "FSTAT");
-  fstat->AddTag("UNIT", &aLong);
-  fstat->AddTag("NAME", &aString);
-  fstat->AddTag("OPEN", &aByte);
-  fstat->AddTag("ISATTY", &aByte);
-  fstat->AddTag("ISAGUI", &aByte);
-  fstat->AddTag("INTERACTIVE", &aByte);
-  fstat->AddTag("XDR", &aByte);
-  fstat->AddTag("COMPRESS", &aByte);
-  fstat->AddTag("READ", &aByte);
-  fstat->AddTag("WRITE", &aByte);
-  fstat->AddTag("ATIME", &aLong64);
-  fstat->AddTag("CTIME", &aLong64);
-  fstat->AddTag("MTIME", &aLong64);
-  fstat->AddTag("TRANSFER_COUNT", &aLong);
-  fstat->AddTag("CUR_PTR", &aLong);
-  fstat->AddTag("SIZE", &aLong);
-  fstat->AddTag("REC_LEN", &aLong);
-  // insert into structList
-  structList.push_back( fstat);
+  for (int big = 1; big >= 0; --big) 
+  {
+    DStructDesc* fstat = new DStructDesc( big ? "FSTAT64" : "FSTAT");
+    fstat->AddTag("UNIT", &aLong);
+    fstat->AddTag("NAME", &aString);
+    fstat->AddTag("OPEN", &aByte);
+    fstat->AddTag("ISATTY", &aByte);
+    fstat->AddTag("ISAGUI", &aByte);
+    fstat->AddTag("INTERACTIVE", &aByte);
+    fstat->AddTag("XDR", &aByte);
+    fstat->AddTag("COMPRESS", &aByte);
+    fstat->AddTag("READ", &aByte);
+    fstat->AddTag("WRITE", &aByte);
+    fstat->AddTag("ATIME", &aLong64);
+    fstat->AddTag("CTIME", &aLong64);
+    fstat->AddTag("MTIME", &aLong64);
+    if (big)
+    {
+      fstat->AddTag("TRANSFER_COUNT", &aLong64);
+      fstat->AddTag("CUR_PTR", &aLong64);
+      fstat->AddTag("SIZE", &aLong64);
+      fstat->AddTag("REC_LEN", &aLong64);
+    }
+    else
+    {
+      fstat->AddTag("TRANSFER_COUNT", &aLong);
+      fstat->AddTag("CUR_PTR", &aLong);
+      fstat->AddTag("SIZE", &aLong);
+      fstat->AddTag("REC_LEN", &aLong);
+    }
+    // insert into structList
+    structList.push_back( fstat);
+  }
 
   DStructDesc* finfo = new DStructDesc("FILE_INFO");
   finfo->AddTag("NAME", &aString);
@@ -215,6 +228,14 @@
   // insert into structList
   structList.push_back( widgbut);
 
+  DStructDesc* widgdlist = new DStructDesc( "WIDGET_DROPLIST");
+  widgdlist->AddTag("ID", &aLong);
+  widgdlist->AddTag("TOP", &aLong);
+  widgdlist->AddTag("HANDLER", &aLong);
+  widgdlist->AddTag("SELECT", &aLong);
+  // insert into structList
+  structList.push_back( widgdlist);
+
   DStructDesc* widgtxt = new DStructDesc( "WIDGET_TEXT");
   widgtxt->AddTag("ID", &aLong);
   widgtxt->AddTag("TOP", &aLong);
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/objects.hpp cvs/gdl/src/objects.hpp
--- gdl-0.9rc4/src/objects.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/objects.hpp	2010-04-22 09:50:41.000000000 -0600
@@ -65,9 +65,9 @@
 
 enum DebugCode {
   DEBUG_CLEAR=0,
-  DEBUG_STOP,
-  DEBUG_PROCESS_STOP
-};  
+  DEBUG_STOP = 1,
+  DEBUG_PROCESS_STOP = 2
+};
 
 template< class Container> void Purge( Container& s) 
 {
@@ -91,4 +91,50 @@
 
 bool BigEndian();
 
+template <typename T> class RefHeap {
+private:
+		T* ptr;
+		SizeT count;
+		
+	// prevent usage
+	RefHeap<T>& operator=(const RefHeap<T>& other) {	return *this;}
+	template<class newType> operator RefHeap<newType>() {return RefHeap<newType>(ptr);}
+
+		
+public:
+
+	SizeT Count() const { return count;}
+	
+	void Inc() {++count;}
+	void Add( SizeT add) {count += add;}
+	bool Dec() {return (--count==0);}
+
+	RefHeap(T* p = 0)
+	: ptr(p), count(1)
+	{}
+	
+	RefHeap( const RefHeap<T>& other)
+	: ptr( other.ptr), count( other.count) 
+	{}
+	
+	~RefHeap()
+	{}
+	
+	operator T* () const
+	{
+		return ptr;
+	}
+
+	T* operator->() const
+	{
+		return ptr;
+	}
+
+	 T*& get()
+	{
+		return ptr;
+	}
+};
+
+
 #endif
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/plotting.cpp cvs/gdl/src/plotting.cpp
--- gdl-0.9rc4/src/plotting.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/plotting.cpp	2010-07-07 14:41:02.140004721 -0600
@@ -27,6 +27,7 @@
 #include "graphics.hpp"
 #include "plotting.hpp"
 #include "math_utl.hpp"
+#include <gsl/gsl_const_mksa.h> // GSL_CONST_MKSA_INCH
 
 #define PLK_Escape            0x1B
 #define free_mem(a) \
@@ -62,8 +63,38 @@
     static int xSizeIx = e->KeywordIx( "XSIZE");
     static int ySizeIx = e->KeywordIx( "YSIZE");
     static int colorIx = e->KeywordIx( "COLOR");
+    static int inchesIx = e->KeywordIx( "INCHES");
  
+    static int get_screen_sizeIx = e->KeywordIx( "GET_SCREEN_SIZE");
+
     Graphics* actDevice = Graphics::GetDevice();
+    
+    if( e->KeywordPresent( get_screen_sizeIx))
+      {
+#ifndef HAVE_X
+        e->Throw("GDL was compiled without support for X-windows");
+#else
+	// see below in Function "get_scren_size()" explanations ...
+	Display* display = XOpenDisplay(NULL);
+	if (display == NULL)
+	  e->Throw("Cannot connect to X server");
+	
+	int screen_num;
+	int screen_width;
+	int screen_height;
+	screen_num = DefaultScreen(display);
+	screen_width = DisplayWidth(display, screen_num);
+	screen_height = DisplayHeight(display, screen_num);
+
+	DIntGDL* res;
+	res = new DIntGDL(2, BaseGDL::NOZERO);
+    
+	(*res)[0]= screen_width;
+	(*res)[1]= screen_height;
+	e->SetKW( get_screen_sizeIx, res);
+#endif
+      }
+
 
     if( e->KeywordSet( closeFileIx))
       {
@@ -130,12 +161,16 @@
         if ((*static_cast<DStringGDL*>( dStruct->GetTag( nameTag, 0)))[0] != "X")
           e->Throw("GET_VISUAL_DEPTH is not supported by current device");
       }
+#ifndef HAVE_X
+      e->Throw("GDL was compiled without support for X-windows");
+#else
       Display* display = XOpenDisplay(NULL);
       if (display == NULL) 
         e->Throw("Cannot connect to X server");
       int depth = DefaultDepth(display, DefaultScreen(display));
       XCloseDisplay(display);
       e->SetKW( get_visual_depthIx, new DLongGDL( depth));
+#endif
     }
 
     BaseGDL* fileName = e->GetKW( fileNameIx);
@@ -157,7 +192,9 @@
       {
 	DFloat xSizeValue;
 	e->AssureFloatScalarKW( xSizeIx, xSizeValue);
-	bool success = actDevice->SetXPageSize( xSizeValue);
+	bool success = actDevice->SetXPageSize( xSizeValue 
+          * (e->KeywordPresent(inchesIx) ? 100. * GSL_CONST_MKSA_INCH : 1.)
+        );
 	if( !success)
 	  e->Throw( "Current device does not support "
 		    "keyword XSIZE.");
@@ -168,7 +205,9 @@
       {
 	DFloat ySizeValue;
 	e->AssureFloatScalarKW( ySizeIx, ySizeValue);
-	bool success = actDevice->SetYPageSize( ySizeValue);
+	bool success = actDevice->SetYPageSize( ySizeValue
+          * (e->KeywordPresent(inchesIx) ? 100. * GSL_CONST_MKSA_INCH : 1.)
+        );
 	if( !success)
 	  e->Throw( "Current device does not support "
 		    "keyword YSIZE.");
@@ -203,8 +242,9 @@
 
     if (device == "PS" || device == "SVG") {
       static DStructGDL* pStruct = SysVar::P();
-      static unsigned noEraseTag = pStruct->Desc()->TagIndex( "NOERASE");
-      (*static_cast<DLongGDL*>( pStruct->GetTag( noEraseTag, 0)))[0] = 1;
+      // SA: this does not comply with IDL behaviour, see testsuite/test_pmulti.pro
+      //static unsigned noEraseTag = pStruct->Desc()->TagIndex( "NOERASE");
+      //(*static_cast<DLongGDL*>( pStruct->GetTag( noEraseTag, 0)))[0] = 1;
       if (device == "PS") {
 	static unsigned colorTag = pStruct->Desc()->TagIndex( "COLOR");
 	(*static_cast<DLongGDL*>( pStruct->GetTag( colorTag, 0)))[0] = 0;
@@ -687,6 +727,27 @@
       (*static_cast<DFloatGDL*>( xStruct->GetTag( ticklenTag, 0)))[0];
   }
 
+  void AdjustAxisOpts(string& xOpt, string& yOpt,
+    DLong xStyle, DLong yStyle, DLong xTicks, DLong yTicks,
+    string& xTickformat, string& yTickformat, DLong xLog, DLong yLog
+  ) // {{{
+  {
+    if ((xStyle & 8) == 8) xOpt = "b";
+    if ((yStyle & 8) == 8) yOpt = "b";
+
+    if (xTicks == 1) xOpt += "t"; else xOpt += "st";
+    if (yTicks == 1) yOpt += "tv"; else yOpt += "stv";
+
+    if (xTickformat != "(A1)") xOpt += "n";
+    if (yTickformat != "(A1)") yOpt += "n";
+
+    if( xLog) xOpt += "l";
+    if( yLog) yOpt += "l";
+
+    if ((xStyle & 4) == 4) xOpt = "";
+    if ((yStyle & 4) == 4) yOpt = "";
+  } // }}}
+
   GDLGStream* GetPlotStream( EnvT* e)
   {
     Graphics* actDevice=Graphics::GetDevice();
@@ -894,6 +955,9 @@
   BaseGDL* get_screen_size( EnvT* e)
   //void GetScreenSize( EnvT* e)
   {
+#ifndef HAVE_X
+    e->Throw("GDL was compiled without support for X-windows");
+#else
     SizeT nParam=e->NParam(); 
     
     if ( nParam > 1) e->Throw( "Incorrect number of arguments.");
@@ -963,6 +1027,7 @@
     (*res)[0]=screen_width;
     (*res)[1]=screen_height;
     return res->Convert2(FLOAT, BaseGDL::CONVERT);
+#endif
   }
 
 
@@ -1057,6 +1122,8 @@
       while (1) {
 	plg->GetCursor(&gin);
 	if (gin.button > 0) break;
+ 	if( sigControlC)
+ 		return;
       }
       mode=1;
     }    
@@ -1070,6 +1137,8 @@
 	  plg->GetCursor(&gin);
 	  if (abs(RefX-gin.dX) >0 || abs(RefY-gin.dY) >0) break;
 	  if (gin.button > 0) break;
+ 	if( sigControlC)
+ 		return;
 	}
       }
       mode=1;
@@ -1081,6 +1150,8 @@
 	// TODO: When no Mouse, should be extended later to any key of the keyboard 
 	if (gin.keysym == PLK_Escape) break;
 	if (gin.button > 0) break;
+ 	if( sigControlC)
+ 		return;
       }
     }
     
@@ -1417,6 +1488,8 @@
 
     // axis
     string xOpt="bc", yOpt="bc";
+    AdjustAxisOpts(xOpt, yOpt, xStyle, yStyle, xTicks, yTicks, xTickformat, yTickformat, xLog, yLog);
+    /* SA: moved into a common AdjustAxisOpts() function
     if ((xStyle & 8) == 8) xOpt = "b";
     if ((yStyle & 8) == 8) yOpt = "b";
 
@@ -1431,6 +1504,7 @@
 
     if ((xStyle & 4) == 4) xOpt = "";
     if ((yStyle & 4) == 4) yOpt = "";
+    */
 
     // axis titles
     actStream->schr( 0.0, actH/defH * xCharSize);
@@ -1650,6 +1724,36 @@
     actStream->flush();
   } // oplot
 
+
+  void GetSFromPlotStructs(DDouble **sx, DDouble **sy)
+  {
+    static DStructGDL* xStruct = SysVar::X();
+    static DStructGDL* yStruct = SysVar::Y();
+    unsigned sxTag = xStruct->Desc()->TagIndex( "S");
+    unsigned syTag = yStruct->Desc()->TagIndex( "S");
+    *sx = &(*static_cast<DDoubleGDL*>( xStruct->GetTag( sxTag, 0)))[0];
+    *sy = &(*static_cast<DDoubleGDL*>( yStruct->GetTag( syTag, 0)))[0];
+  }
+    
+  void GetWFromPlotStructs(DFloat **wx, DFloat **wy)
+  {
+    static DStructGDL* xStruct = SysVar::X();
+    static DStructGDL* yStruct = SysVar::Y();
+    unsigned xwindowTag = xStruct->Desc()->TagIndex( "WINDOW");
+    unsigned ywindowTag = yStruct->Desc()->TagIndex( "WINDOW");
+    *wx = &(*static_cast<DFloatGDL*>( xStruct->GetTag( xwindowTag, 0)))[0];
+    *wy = &(*static_cast<DFloatGDL*>( yStruct->GetTag( ywindowTag, 0)))[0];
+  }
+    
+  void DataCoordLimits(DDouble *sx, DDouble *sy, DFloat *wx, DFloat *wy, 
+    DDouble *xStart, DDouble *xEnd, DDouble *yStart, DDouble *yEnd)
+  {
+    *xStart = (wx[0] - sx[0]) / sx[1];
+    *xEnd   = (wx[1] - sx[0]) / sx[1];
+    *yStart = (wy[0] - sy[0]) / sy[1];
+    *yEnd   = (wy[1] - sy[0]) / sy[1];
+  }
+
   // PLOTS
   void plots( EnvT* e)
   {
@@ -1802,30 +1906,15 @@
     }
 #endif
 
+    DDouble *sx, *sy;
+    DFloat *wx, *wy;
+    GetSFromPlotStructs(&sx, &sy);
+    GetWFromPlotStructs(&wx, &wy);
+
     // Determine data coordinate limits (if mapSet is true)
     // These are computed from window and scaling axis system
     // variables because map routines change these directly.
-    DDouble *sx;
-    DDouble *sy;
-    DStructGDL* xStruct = SysVar::X();
-    DStructGDL* yStruct = SysVar::Y();
-    unsigned sxTag = xStruct->Desc()->TagIndex( "S");
-    unsigned syTag = yStruct->Desc()->TagIndex( "S");
-    sx = &(*static_cast<DDoubleGDL*>( xStruct->GetTag( sxTag, 0)))[0];
-    sy = &(*static_cast<DDoubleGDL*>( yStruct->GetTag( syTag, 0)))[0];
-    
-    DFloat *wx;
-    DFloat *wy;
-    unsigned xwindowTag = xStruct->Desc()->TagIndex( "WINDOW");
-    unsigned ywindowTag = yStruct->Desc()->TagIndex( "WINDOW");
-    wx = &(*static_cast<DFloatGDL*>( xStruct->GetTag( xwindowTag, 0)))[0];
-    wy = &(*static_cast<DFloatGDL*>( yStruct->GetTag( ywindowTag, 0)))[0];
-    
-    xStart = (wx[0] - sx[0]) / sx[1];
-    xEnd   = (wx[1] - sx[0]) / sx[1];
-    yStart = (wy[0] - sy[0]) / sy[1];
-    yEnd   = (wy[1] - sy[0]) / sy[1];
-
+    DataCoordLimits(sx, sy, wx, wy, &xStart, &xEnd, &yStart, &yEnd);
 
     if(e->KeywordSet("DEVICE")) {
       PLFLT xpix, ypix;
@@ -1989,31 +2078,15 @@
     }
 #endif
 
+    DDouble *sx, *sy;
+    DFloat *wx, *wy;
+    GetSFromPlotStructs(&sx, &sy);
+    GetWFromPlotStructs(&wx, &wy);
 
     // Determine data coordinate limits
     // These are computed from window and scaling axis system
     // variables because map routines change these directly.
-    DDouble *sx;
-    DDouble *sy;
-    DStructGDL* xStruct = SysVar::X();
-    DStructGDL* yStruct = SysVar::Y();
-    unsigned sxTag = xStruct->Desc()->TagIndex( "S");
-    unsigned syTag = yStruct->Desc()->TagIndex( "S");
-    sx = &(*static_cast<DDoubleGDL*>( xStruct->GetTag( sxTag, 0)))[0];
-    sy = &(*static_cast<DDoubleGDL*>( yStruct->GetTag( syTag, 0)))[0];
-    
-    DFloat *wx;
-    DFloat *wy;
-    unsigned xwindowTag = xStruct->Desc()->TagIndex( "WINDOW");
-    unsigned ywindowTag = yStruct->Desc()->TagIndex( "WINDOW");
-    wx = &(*static_cast<DFloatGDL*>( xStruct->GetTag( xwindowTag, 0)))[0];
-    wy = &(*static_cast<DFloatGDL*>( yStruct->GetTag( ywindowTag, 0)))[0];
-    
-    xStart = (wx[0] - sx[0]) / sx[1];
-    xEnd   = (wx[1] - sx[0]) / sx[1];
-    yStart = (wy[0] - sy[0]) / sy[1];
-    yEnd   = (wy[1] - sy[0]) / sy[1];
-
+    DataCoordLimits(sx, sy, wx, wy, &xStart, &xEnd, &yStart, &yEnd);
 
     if(e->KeywordSet("DEVICE")) {
       PLFLT xpix, ypix;
@@ -2169,6 +2242,150 @@
     actStream->flush();
   }
 
+  void polyfill( EnvT* e)
+  {
+    SizeT nParam = e->NParam(1);
+    DDoubleGDL* yVal, *xVal;
+    SizeT xEl, yEl;
+
+    bool mapSet=false;
+#ifdef USE_LIBPROJ4
+    LPTYPE idata;
+    XYTYPE odata;
+    get_mapset(mapSet);
+    if (mapSet) 
+    {
+      ref = map_init();
+      if (ref == NULL) e->Throw( "Projection initialization failed.");
+    }
+#endif
+
+    if(nParam == 1 || nParam == 3) 
+    {
+      e->Throw("1- and 3-argument case not implemented yet");
+    }
+    else
+    {
+      xVal = !mapSet
+        ? e->GetParAs< DDoubleGDL>(0)
+        : static_cast<DDoubleGDL*>(
+          e->GetNumericArrayParDefined(0)->Convert2(DOUBLE, BaseGDL::COPY)
+        );
+      yVal = !mapSet
+        ? e->GetParAs< DDoubleGDL>(1)
+        : static_cast<DDoubleGDL*>(
+          e->GetNumericArrayParDefined(1)->Convert2(DOUBLE, BaseGDL::COPY)
+        );
+
+      xEl = xVal->N_Elements();
+      yEl = yVal->N_Elements();
+    }
+
+    if (xEl != yEl)
+      e->Throw("xEl != yEl"); // TODO
+
+    if (xEl < 3)
+      e->Throw("Input arrays must define at least three points");
+
+    DFloat xMarginL, xMarginR,yMarginB, yMarginT; 
+    get_axis_margin("X", xMarginL, xMarginR);
+    get_axis_margin("Y", yMarginB, yMarginT);
+    
+    DDouble xStart, xEnd, yStart, yEnd;
+    bool xLog, yLog;
+
+    get_axis_crange("X", xStart, xEnd);
+    get_axis_crange("Y", yStart, yEnd);
+    get_axis_type("X", xLog);
+    get_axis_type("Y", yLog);
+
+    GDLGStream* actStream = GetPlotStream( e); 
+    
+    gkw_color(e, actStream);
+
+    PLFLT xMR, xML, yMB, yMT;
+    CheckMargin( e, actStream, xMarginL, xMarginR, yMarginB, yMarginT, xMR, xML, yMB, yMT);
+
+    DDouble *sx, *sy;
+    DFloat *wx, *wy;
+    GetSFromPlotStructs(&sx, &sy);
+    GetWFromPlotStructs(&wx, &wy);
+
+    // Determine data coordinate limits
+    // These are computed from window and scaling axis system
+    // variables because map routines change these directly.
+    DataCoordLimits(sx, sy, wx, wy, &xStart, &xEnd, &yStart, &yEnd);
+
+    if(e->KeywordSet("DEVICE")) {
+      PLFLT xpix, ypix;
+      PLINT xleng, yleng, xoff, yoff;
+      actStream->gpage(xpix, ypix,xleng, yleng, xoff, yoff);
+      xStart=0; xEnd=xleng;
+      yStart=0; yEnd=yleng;
+      xLog = false; yLog = false;
+      actStream->NoSub();
+    } else if(e->KeywordSet("NORMAL")) {
+      xStart = 0;
+      xEnd   = 1;
+      yStart = 0;
+      yEnd   = 1;
+      actStream->NoSub();
+      actStream->vpor(0, 1, 0, 1);
+      xLog = false; yLog = false;
+    } else {
+      actStream->NoSub();
+      actStream->vpor(wx[0], wx[1], wy[0], wy[1]);
+    }
+
+    //CLIPPING
+    DLong noclip = 1;
+    e->AssureLongScalarKWIfPresent( "NOCLIP", noclip);
+    if (noclip == 0)
+    {
+      static int clippingix = e->KeywordIx( "CLIP"); 
+      DDoubleGDL* clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
+      if (clippingD != NULL) Clipping( clippingD, xStart, xEnd, yStart, yEnd);
+    }
+
+    actStream->wind( xStart, xEnd, yStart, yEnd);
+
+/* SA: does not work at all (TODO, help welcome)
+    // LINE_FILL, SPACING, LINESTYLE, ORIENTATION, THICK
+    static int line_fillIx = e->KeywordIx("LINE_FILL");
+    if (e->KeywordSet(line_fillIx))
+    {
+      PLINT inc = 0, del = 1;
+
+      static int orientationIx = e->KeywordIx("ORIENTATION");
+      if (e->KeywordSet(orientationIx)) inc = PLINT(1e1 * (*e->GetKWAs<DFloatGDL>(orientationIx))[0]);
+
+      static int spacingIx = e->KeywordIx("SPACING");
+      if (e->KeywordSet(spacingIx)) del = PLINT(1e4 * (*e->GetKWAs<DFloatGDL>(spacingIx))[0]);
+      
+      gkw_thick(e, actStream);
+      gkw_linestyle(e, actStream);
+
+      actStream->pat(1, &inc, &del);
+    }
+*/
+
+#ifdef USE_LIBPROJ4
+    if (mapSet)
+    {
+      for (SizeT i = 0; i < xEl; ++i) 
+      {
+        idata.lam = (*xVal)[i] * DEG_TO_RAD;
+        idata.phi = (*yVal)[i] * DEG_TO_RAD;
+        odata = PJ_FWD(idata, ref);
+        (*xVal)[i] = odata.x;
+        (*yVal)[i] = odata.y;
+      }
+    }
+#endif
+
+    actStream->fill(xEl, static_cast<PLFLT*>(&(*xVal)[0]), static_cast<PLFLT*>(&(*yVal)[0]));
+    actStream->flush();
+  }
 
   void surface( EnvT* e)
   {
@@ -3078,14 +3295,8 @@
     
     DDouble *sx, *sy;
     DFloat *wx, *wy;
-    unsigned sxTag = xStruct->Desc()->TagIndex( "S");
-    unsigned syTag = yStruct->Desc()->TagIndex( "S");
-    unsigned xwindowTag = xStruct->Desc()->TagIndex( "WINDOW");
-    unsigned ywindowTag = yStruct->Desc()->TagIndex( "WINDOW");
-    sx = &(*static_cast<DDoubleGDL*>( xStruct->GetTag( sxTag, 0)))[0];
-    sy = &(*static_cast<DDoubleGDL*>( yStruct->GetTag( syTag, 0)))[0];
-    wx = &(*static_cast<DFloatGDL*>( xStruct->GetTag( xwindowTag, 0)))[0];
-    wy = &(*static_cast<DFloatGDL*>( yStruct->GetTag( ywindowTag, 0)))[0];
+    GetSFromPlotStructs(&sx, &sy);
+    GetWFromPlotStructs(&wx, &wy);
 
     // mapping only in OVERPLOT mode
     if (!overplot) set_mapset(0);
@@ -3100,10 +3311,7 @@
       } 
       else 
       {
-        xStart = (wx[0] - sx[0]) / sx[1];
-        xEnd   = (wx[1] - sx[0]) / sx[1];
-        yStart = (wy[0] - sy[0]) / sy[1];
-        yEnd   = (wy[1] - sy[0]) / sy[1];
+        DataCoordLimits(sx, sy, wx, wy, &xStart, &xEnd, &yStart, &yEnd);
       }
       get_axis_margin("X",xMarginL, xMarginR);
       get_axis_margin("Y",yMarginB, yMarginF);
@@ -3465,8 +3673,14 @@
       string xOpt = "bcnst";
       string yOpt = "bcnstv";
 
+      /* SA: moved into a common AdjustAxisOpts()
       if( xLog) xOpt += "l";
       if( yLog) yOpt += "l";
+      */
+      DString xTickformat, yTickformat;
+      e->AssureStringScalarKWIfPresent( "XTICKFORMAT", xTickformat);
+      e->AssureStringScalarKWIfPresent( "YTICKFORMAT", yTickformat);
+      AdjustAxisOpts(xOpt, yOpt, xStyle, yStyle, xTicks, yTicks, xTickformat, yTickformat, xLog, yLog);
 
       // axis titles
       actStream->schr( 0.0, actH/defH * xCharSize);
@@ -3550,10 +3764,6 @@
   {
     SizeT nParam=e->NParam( 0); 
     bool valid=true;
-    DDouble zVal, yVal, xVal;
-
-    if (nParam >= 1) e->AssureDoubleScalarPar( 0, xVal);
-
     // !X, !Y (also used below)
 
     DLong xStyle=0, yStyle=0; 
@@ -3565,10 +3775,24 @@
     bool xAxis=false, yAxis=false; 
     static int xaxisIx = e->KeywordIx( "XAXIS");
     static int yaxisIx = e->KeywordIx( "YAXIS");
-
-    if( e->GetKW( xaxisIx) != NULL) xAxis = true;
-    if( e->GetKW( yaxisIx) != NULL) yAxis = true;
-
+    
+    PLINT xaxis_value, yaxis_value; 
+    bool standardNumPos;
+    //IDL behaviour for XAXIS and YAXIS options
+    if( (e->GetKW( xaxisIx) != NULL) ) {
+      xAxis = true;
+      e->AssureLongScalarKWIfPresent( "XAXIS", xaxis_value);
+      if (xaxis_value == 0) {standardNumPos = true;} else {standardNumPos = false;}
+    }      
+    if( e->GetKW( yaxisIx) != NULL) {
+      yAxis = true; xAxis = false; // like in IDL, yaxis overrides xaxis
+      e->AssureLongScalarKWIfPresent( "YAXIS", yaxis_value);
+      if (yaxis_value == 0) {standardNumPos = true;} else {standardNumPos = false;}
+    }
+    if( (e->GetKW( xaxisIx) == NULL) & (e->GetKW( yaxisIx) == NULL ) )  {
+      xAxis = true; standardNumPos = true; 
+    }
+    
     // [XY]STYLE
     gkw_axis_style(e, "X", xStyle);
     gkw_axis_style(e, "Y", yStyle);
@@ -3583,13 +3807,22 @@
     gkw_axis_margin(e, "X",xMarginL, xMarginR);
     gkw_axis_margin(e, "Y",yMarginB, yMarginT);
 
-
     // x and y range
-    DDouble xStart;
-    DDouble xEnd;
-    DDouble yStart;
-    DDouble yEnd;
+    DDouble xStart, xEnd;
+    DDouble yStart, yEnd;
 
+    get_axis_crange("X", xStart, xEnd);
+    get_axis_crange("Y", yStart, yEnd);
+    
+    DLong xnozero=1, ynozero=0;
+	gkw_axis_range( e, "X", xStart, xEnd, xnozero);
+	gkw_axis_range( e, "Y", yStart, yEnd, ynozero);
+
+    if (xStart == xEnd && yStart == yEnd) {
+      e->Throw("Invalid plotting ranges.  Set up a plot window first.");
+    }
+
+    /*
     if ((xStyle & 1) != 1 && xAxis) {
       PLFLT intv;
       intv = AutoIntvAC(xStart, xEnd, false );
@@ -3600,17 +3833,35 @@
 
     if ((yStyle & 1) != 1 && yAxis) {
       PLFLT intv;
-      intv = AutoIntvAC(xStart, xEnd, false );
+      intv = AutoIntvAC(yStart, yEnd, false );
       //      intv = AutoIntv(yEnd-yStart);
       //yEnd = ceil(yEnd/intv) * intv;
       //yStart = floor(yStart/intv) * intv;
     }
+    */
 
+    DDouble zVal, yVal, xVal;
+    //read arguments 
+    if (nParam == 1) {
+      e->AssureDoubleScalarPar( 0, xVal);
+      yVal=0.; //IDL behaviour
+    }
+    if (nParam == 2) {
+      e->AssureDoubleScalarPar( 0, xVal);
+      e->AssureDoubleScalarPar( 1, yVal);
+    }
+    if (nParam == 3) {
+      e->Throw( "Sorry, we do not yet support the 3D case");
+    }
+    if (nParam == 0 && standardNumPos) { xVal = xStart; yVal = yStart; }
+    if (nParam == 0 && !standardNumPos) { xVal = xEnd; yVal = yEnd; }
 
+    /*
     DLong ynozero, xnozero;
     //[x|y]range keyword
     gkw_axis_range(e, "X", xStart, xEnd, ynozero);
     gkw_axis_range(e, "Y", yStart, yEnd, xnozero);
+    */
 
     // AC nomore useful
     // if(xEnd == xStart) xEnd=xStart+1;
@@ -3633,11 +3884,16 @@
     bool xLog, yLog;
     get_axis_type("X", xLog);
     get_axis_type("Y", yLog);
+    /*
+    //if log, x/y/Start/End are already logarithmic. 
     if( xLog && xStart <= 0.0)
       Warning( "AXIS: Infinite x plot range.");
     if( yLog && minVal <= 0.0)
       Warning( "AXIS: Infinite y plot range.");
-
+    */
+    // test for x/yVal
+    if (xLog) { if (xVal <= 0.) xVal=xStart; else xVal=log10(xVal);}
+    if (yLog) { if (yVal <= 0.) yVal=yStart; else yVal=log10(yVal);}
 
     DDouble ticklen = 0.02;
     e->AssureDoubleScalarKWIfPresent( "TICKLEN", ticklen);
@@ -3668,9 +3924,48 @@
     PLFLT defH, actH;
     actStream->gchr( defH, actH);
 
+    // get viewport coordinates in normalised units
+    PLFLT vpXL, vpXR, vpYB, vpYT;
+    actStream->gvpd(vpXL, vpXR, vpYB, vpYT);
+    PLFLT vpX = vpXR-vpXL;
+    PLFLT vpY = vpYT-vpYB;
+
+    // create new viewport and draw only the relevant side (viewport
+    // will be reset to its original values later)
+    PLFLT svpXL, svpXR, svpYB, svpYT; //new viewport coordinates
+    if (xAxis) {
+      //keep the X values the same
+      svpXL=vpXL; svpXR=vpXR;
+      if (standardNumPos) { //our axis is the bottom of viewport
+	svpYB=vpY*(yVal-yStart)/(yEnd-yStart)+vpYB;
+	svpYT=svpYB+0.2; //value doesn't matter, as long as svpYT>svpYB
+      } else { //our axis is the top of viewport
+	svpYT=vpYT-vpY*(yEnd-yVal)/(yEnd-yStart);
+	svpYB=svpYT-0.2; //value doesn't matter, as long as svpYT>svpYB
+      }
+    }
+    if (yAxis) {
+      //keep the top and bottom the same
+      svpYT=vpYT; svpYB=vpYB;
+      if (standardNumPos) { //our axis is the left of the viewport
+	svpXL=vpX*(xVal-xStart)/(xEnd-xStart)+vpXL;
+	svpXR=svpXL+0.2; //value doesn't matter, as long as svpXR>svpXL
+      } else { //our axis is the right of the viewport
+	svpXR=vpXR-vpX*(xEnd-xVal)/(xEnd-xStart);
+	svpXL=svpXR-0.2; //value doesn't matter, as long as svpXR>svpXL
+      }
+    }
+    actStream->vpor(svpXL, svpXR, svpYB, svpYT);
+    //The world coordinates for the relevant axis should be same as
+    //the originals, while the other axis doesn't matter.  
+    actStream->wind(xStart, xEnd, yStart,yEnd);
+
+    // POSITION
+    //DFloatGDL* pos = (DFloatGDL*) 0xF;
+
     /*
     // viewport and world coordinates
-    bool okVPWC = SetVP_WC( e, actStream, pos, clippingD, 
+    bool okVPWC = SetVP_WC( e, actStream, pos, NULL,
 			    xLog, yLog,
 			    xMarginL, xMarginR, yMarginB, yMarginT,
 			    xStart, xEnd, minVal, maxVal);
@@ -3681,15 +3976,16 @@
     actStream->wid( 0);
 
     // axis
-    string xOpt="bc", yOpt="bc";
-    if ((xStyle & 8) == 8) xOpt = "b";
-    if ((yStyle & 8) == 8) yOpt = "b";
+    string xOpt, yOpt;
+    if (standardNumPos) { xOpt = "b"; yOpt = "b";} else { xOpt = "c"; yOpt = "c"; }
 
     if (xTicks == 1) xOpt += "t"; else xOpt += "st";
     if (yTicks == 1) yOpt += "tv"; else yOpt += "stv";
 
-    if (xTickformat != "(A1)") xOpt += "n";
-    if (yTickformat != "(A1)") yOpt += "n";
+    if (xTickformat != "(A1)" && standardNumPos) xOpt += "nf";
+    if (xTickformat != "(A1)" && !standardNumPos) xOpt += "mf";
+    if (yTickformat != "(A1)" && standardNumPos) yOpt += "nf";
+    if (yTickformat != "(A1)" && !standardNumPos) yOpt += "mf";
 
     if( xLog) xOpt += "l";
     if( yLog) yOpt += "l";
@@ -3697,11 +3993,13 @@
     if ((xStyle & 4) == 4) xOpt = "";
     if ((yStyle & 4) == 4) yOpt = "";
 
+    string titleOpt;
     if (xAxis) {
 
       // axis titles
       actStream->schr( 0.0, actH/defH * xCharSize);
-      actStream->mtex("b",3.5,0.5,0.5,xTitle.c_str());
+      if (standardNumPos) { titleOpt = "b"; } else { titleOpt = "t"; }
+      actStream->mtex(titleOpt.c_str(),3.5,0.5,0.5,xTitle.c_str());
 
       // the axis (separate for x and y axis because of charsize)
       PLFLT xintv;
@@ -3711,11 +4009,38 @@
 	xintv = (xEnd - xStart) / xTicks;
       }
       actStream->box( xOpt.c_str(), xintv, xMinor, "", 0.0, 0);
+
+      if (e->KeywordSet("SAVE"))
+      {
+        // X.CRANGE
+        set_axis_crange("X", xStart, xEnd);
+
+        // X.TYPE
+        set_axis_type("X",xLog);
+
+        // X.S ... TODO: set_axis_s()
+        DStructGDL* Struct=NULL;
+        Struct = SysVar::X();
+        static unsigned sTag = Struct->Desc()->TagIndex( "S");
+        PLFLT p_xmin, p_xmax, p_ymin, p_ymax;
+        actStream->gvpd (p_xmin, p_xmax, p_ymin, p_ymax);
+        if(Struct != NULL)
+        {
+          (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[0] =
+            (p_xmin*xEnd - p_xmax*xStart) / (xEnd - xStart);
+          (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[1] =
+            (p_xmax - p_xmin) / (xEnd - xStart);
+        }
+      }
     }
 
     if (yAxis) {
+
+      // axis titles
       actStream->schr( 0.0, actH/defH * yCharSize);
-      actStream->mtex("l",5.0,0.5,0.5,yTitle.c_str());
+      if (standardNumPos) { titleOpt = "l"; } else { titleOpt = "r"; }
+      actStream->mtex(titleOpt.c_str(),5.0,0.5,0.5,yTitle.c_str());
+
       // the axis (separate for x and y axis because of charsize)
       PLFLT yintv;
       if (yTicks == 0) {
@@ -3724,8 +4049,35 @@
 	yintv = (yEnd - yStart) / yTicks;
       }
       actStream->box( "", 0.0, 0, yOpt.c_str(), yintv, yMinor);
+
+      if (e->KeywordSet("SAVE"))
+      {
+        // Y.CRANGE
+        set_axis_crange("Y", yStart, yEnd);
+
+        // Y.TYPE
+        set_axis_type("Y",yLog);
+
+        // Y.S ... TODO: set_axis_s()
+        DStructGDL* Struct=NULL;
+        Struct = SysVar::Y();
+        static unsigned sTag = Struct->Desc()->TagIndex( "S");
+        PLFLT p_xmin, p_xmax, p_ymin, p_ymax;
+        actStream->gvpd (p_xmin, p_xmax, p_ymin, p_ymax);
+        if(Struct != NULL)
+        {
+          (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[0] =
+            (p_ymin*yEnd - p_ymax*yStart) / (yEnd - yStart);
+          (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[1] =
+            (p_ymax - p_ymin) / (yEnd - yStart);
+        }
+      }
     }
 
+    // reset the viewport and world coordinates to the original values
+    actStream->vpor(vpXL, vpXR, vpYB, vpYT);
+    actStream->wind(xStart, xEnd, yStart,yEnd);
+
     // title and sub title
     // axis has subtitle but no title, gkw_title requires both
     //    gkw_title(e, actStream, actH/defH);
@@ -3791,14 +4143,8 @@
     if (yVal->N_Elements() == 1 && yVal->Rank() == 0) 
       minEl = xVal->N_Elements();
 
-    DDouble *sx;
-    DDouble *sy;
-    static DStructGDL* xStruct = SysVar::X();
-    static DStructGDL* yStruct = SysVar::Y();
-    static unsigned sxTag = xStruct->Desc()->TagIndex( "S");
-    static unsigned syTag = yStruct->Desc()->TagIndex( "S");
-    sx = &(*static_cast<DDoubleGDL*>( xStruct->GetTag( sxTag, 0)))[0];
-    sy = &(*static_cast<DDoubleGDL*>( yStruct->GetTag( syTag, 0)))[0];
+    DDouble *sx, *sy;
+    GetSFromPlotStructs(&sx, &sy);
 
     bool mapSet=false;
 #ifdef USE_LIBPROJ4
@@ -3950,14 +4296,8 @@
     if (yVal->N_Elements() == 1 && yVal->Rank() == 0) 
       minEl = xVal->N_Elements();
 
-    DDouble *sx;
-    DDouble *sy;
-    static DStructGDL* xStruct = SysVar::X();
-    static DStructGDL* yStruct = SysVar::Y();
-    static unsigned sxTag = xStruct->Desc()->TagIndex( "S");
-    static unsigned syTag = yStruct->Desc()->TagIndex( "S");
-    sx = &(*static_cast<DDoubleGDL*>( xStruct->GetTag( sxTag, 0)))[0];
-    sy = &(*static_cast<DDoubleGDL*>( yStruct->GetTag( syTag, 0)))[0];
+    DDouble *sx, *sy;
+    GetSFromPlotStructs(&sx, &sy);
 
     bool mapSet=false;
 #ifdef USE_LIBPROJ4
@@ -5010,15 +5350,15 @@
     if (nParam == 3)
       p2 = e->GetParDefined( 2);
 
-    static DStructGDL* xStruct = SysVar::X();
-    static DStructGDL* yStruct = SysVar::Y();
+    DDouble *sx, *sy;
+    GetSFromPlotStructs(&sx, &sy);
+
     static DStructGDL* zStruct = SysVar::Z();
-    static unsigned sxTag = xStruct->Desc()->TagIndex( "S");
-    static unsigned syTag = yStruct->Desc()->TagIndex( "S");
     static unsigned szTag = zStruct->Desc()->TagIndex( "S");
-    DDouble *sx = &(*static_cast<DDoubleGDL*>( xStruct->GetTag( sxTag, 0)))[0];
-    DDouble *sy = &(*static_cast<DDoubleGDL*>( yStruct->GetTag( syTag, 0)))[0];
     DDouble *sz = &(*static_cast<DDoubleGDL*>( zStruct->GetTag( szTag, 0)))[0];
+
+    static DStructGDL* xStruct = SysVar::X();
+    static DStructGDL* yStruct = SysVar::Y();
     static unsigned xtTag = xStruct->Desc()->TagIndex( "TYPE");
     static unsigned ytTag = yStruct->Desc()->TagIndex( "TYPE");
     static unsigned ztTag = zStruct->Desc()->TagIndex( "TYPE");
Only in gdl-0.9rc4/src: plotting.cpp.orig
Only in gdl-0.9rc4/src: plotting.cpp.rej
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/plotting.hpp cvs/gdl/src/plotting.hpp
--- gdl-0.9rc4/src/plotting.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/plotting.hpp	2010-04-22 09:50:41.000000000 -0600
@@ -42,6 +42,7 @@
   void axis( EnvT* e);
   void erase( EnvT* e);
   void cursor( EnvT* e);
+  void polyfill( EnvT* e);
 
 
   //helper functions
@@ -101,6 +102,12 @@
 
   BaseGDL* convert_coord( EnvT* e);
 
+  GDLGStream* GetPlotStream( EnvT* e);
+  void GetSFromPlotStructs(DDouble **sx, DDouble **sy);
+  void GetWFromPlotStructs(DFloat **wx, DFloat **wy);
+  void DataCoordLimits(DDouble *sx, DDouble *sy, DFloat *wx, DFloat *wy, 
+    DDouble *xStart, DDouble *xEnd, DDouble *yStart, DDouble *yEnd);
+
 } // namespace
 
 #endif
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/print.cpp cvs/gdl/src/print.cpp
--- gdl-0.9rc4/src/print.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/print.cpp	2010-07-07 14:41:02.144944688 -0600
@@ -94,7 +94,12 @@
 	sockNum = fileUnits[ lun-1].SockNum();
 
 	if (sockNum == -1) 
-	  os = &fileUnits[ lun-1].OStream();
+	{
+	  if( fileUnits[ lun-1].Compress())
+		os = &fileUnits[ lun-1].OgzStream();
+	  else
+		os = &fileUnits[ lun-1].OStream();
+	}
 	else
 	  os = &oss;
 
@@ -142,12 +147,16 @@
 	DString fmtString;
 	e->AssureScalarKW<DStringGDL>( 0, fmtString);
 
+	if( fmtString != "")
+	{
 	RefFMTNode fmtAST = GetFMTAST( fmtString);
 
 	// formatted output ignores WIDTH
 	FMTOut Formatter( fmtAST, os, e, parOffset); 
+	return;
+	}
       }
-    else // default-format output
+    //else // default-format output
       {
 	int nParam = e->NParam();
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/deriv.pro cvs/gdl/src/pro/deriv.pro
--- gdl-0.9rc4/src/pro/deriv.pro	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/pro/deriv.pro	2010-06-03 09:06:40.358740996 -0600
@@ -110,7 +110,7 @@
 ; When GDL behavior of {MESSAGE, .skip, .Continue} will be similar to
 ; IDL, the following flag can be switch to 1 !
 ;
-flag_message=0
+flag_message=1
 name_proc='% DERIV: '
 ;
 if ((N_PARAMS() EQ 0) OR (N_PARAMS() GT 2)) then begin
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/dialog_pickfile.pro cvs/gdl/src/pro/dialog_pickfile.pro
--- gdl-0.9rc4/src/pro/dialog_pickfile.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/pro/dialog_pickfile.pro	2010-06-23 01:51:46.000000000 -0600
@@ -0,0 +1,387 @@
+;+
+; NAME:   DIALOG_PICKFILE
+;
+; PURPOSE:
+;
+; This function try to reproduce the IDL's DIALOG_PICKFILE
+; behavior using "zenity".
+;
+; zenity, under GNU GPL, is available on most Linux distributions 
+; and also on OSX
+;
+; CATEGORY:
+;
+;
+; CALLING SEQUENCE:  resu_list=DIALOG_PICKFILE()
+;
+; INPUTS: none
+;
+; OPTIONAL INPUTS: none
+;
+; KEYWORD PARAMETERS:
+;	DEFAULT_EXTENSION: Set this keyword to a scalar string 
+; representing the default extension to be appended onto the returned file name
+; or names. If the returned file name already has an extension, 
+; then the value set for this keyword is not appended. The string value set
+; for this keyword should not include a period (.). 
+;	DIALOG_PARENT: This keywork isn't supported. 
+;	DIRECTORY: Set this keyword to display only the existing
+; directories in the directory specified by the PATH keyword. If a path is not
+; specified, setting this keyword shows directories in the current directory.
+; The Browse for Folder dialog is opened to the directory specified by the path
+; definition. Individual files are displayed but can't be selected.
+; The return value contains the path of the directory selected, or
+; directory created and selected by the user. 
+;	DISPLAY_NAME: This keyword isn't supported
+;	FILE: Set this keyword to a scalar string that contains the name
+; of the initial file selection. This keyword is useful for specifying a default 
+; filename.
+;	FILTER: Set this keyword to a string value or an array of strings
+; specifying the file types to be displayed in the file list. This keyword is
+; used to reduce the number of files displayed in the file list. The user can
+; modify the filter unless the FIX_FILTER keyword is set. If the value contains
+; a vector of strings, multiple filters are used to filter the files.
+; The filter *.* is automatically added to any filter you specify.
+; Needs Zenity  >= 2.23.1
+;	FIX_FILTER: This keyword isn't supported
+;	GET_PATH: Set this keyword to a named variable in which the path of
+; the selection is returned. 
+;	GROUP: Ths keyword isn't supported
+;	MULTIPLE_FILES: Set this keyword to allow for multiple file selection
+; in the file-selection dialog. When you set this keyword, the user can select
+; multiple files using the platform-specific selection method. The currently
+; selected files appear in the selection text field of the dialog. 
+; With this keyword set, DIALOG_PICKFILE can return a string array that contains
+; the full path name of the selected file or files. 
+;	MUST_EXIST: Set this keyword to allow only files that already exist
+; to be returned
+;	OVERWRITE_PROMPT: If this keyword is set along with the WRITE keyword
+; and the user selects a file that already exists, then a dialog will be displayed
+; asking if the user wants to replace the existing file or not.
+; For multiple selections, the user is prompted separately for each file.
+; If the user selects "No" the file won't be returned; if the user selects "Yes"
+; then the selection is allowed. This keyword has no effect unless the WRITE
+; keyword is also set. 
+;	PATH: Set this keyword to a string that contains the initial path from
+; which to select files. Relative paths are appended to current working directory.
+; If this keyword is not set, current working directory is used.
+;	READ: Set this keyword to make the title of the dialog "Please Select a File|Directory for Reading". 
+;	RESOURCE_NAME: This keyword isn't supported
+;	TITLE: Set this keyword to a scalar string to be used for the dialog title.
+; If it is not specified, the default title is "Please Select a File|Directory". 
+;	WRITE: Set this keyword to make the title of the dialog "Please Select a
+; File|Directory for Writing". This keyword must be set to allow OVERWRITE_PROMPT. 
+;
+;	NON IDL KEYWORDS
+;
+;	ZENITY_NAME: Set this keyword to a scalar string used to overwrite Zenity
+; executable name.
+;	ZENITY_PATH: If set, Zenith will be searched in this path. If it doesn't 
+; exist, then it will be searched in common unix paths. This can also be done
+; by exporting the shell variable $ZENITY_PATH.
+;	HELP: Display a help message and return
+;	DEBUG: Display bebug messages
+;	VERBOSE: Switch on verbose mode
+;	
+			
+;
+; OUTPUTS:
+;
+; OPTIONAL OUTPUTS:
+;
+;
+;
+; COMMON BLOCKS: none
+;
+; SIDE EFFECTS:
+;
+;
+;
+; RESTRICTIONS: 
+;               - need Zenity v2.23.1 or higher to use filters.
+;               - interface is not exactly the same ...
+;
+; PROCEDURE:  straithforward
+;
+; EXAMPLE:
+;		files=DIALOG_PICKFILE(FILTER=['*.c','*.cpp'],/MULTIPLE_FILES)
+;
+;
+; MODIFICATION HISTORY:
+;
+;  Idea by Alain Coulais on June 2010, implementation by Maxime Lenoir
+;  (first public version 16 June 2010).
+;
+;-
+;
+; This function try to reproduce the IDL's DIALOG_PICKFILE
+; behavior using "zenity".
+;
+; zenity, under GNU GPL, is available in package on most Linux
+; distributions (available and tested on CentOS 5.4, Mandriva 2010 and Ubuntu
+; 9.04)
+; Also on OSX: http://www.macports.org/ports.php?by=name&substr=zenity
+;
+; Since the implementation use Zenity as File Selector, 
+; some functionalities are different from the original one
+; but this function works well for general purpose.
+;
+; Make sure that you have Zenity in your PATH 
+; You need to have Zenity v2.23.1 or higher to use filters. 
+;
+; If you try to get existing files w/ /WRITE and /OVERWRITE_PROMPT, 
+; you'll be prompted when the main dialog get closed.
+; Each cancelation leads to the removal of the associated file 
+; from the returned file list.
+;
+; Default extension also applies to selected files 
+; (and not only to file names typed into the dialog)
+;
+;-
+; LICENCE:
+; Copyright (C) 2010, Maxime Lenoir (main author) and Alain Coulais
+; (idea, contact)
+; This program is free software; you can redistribute it and/or modify  
+; it under the terms of the GNU General Public License as published by  
+; the Free Software Foundation; either version 2 of the License, or     
+; (at your option) any later version.
+; 
+;-
+function DIALOG_PICKFILE, DEFAULT_EXTENSION=default_extension, $
+                          DIRECTORY=directory, DIALOG_PARENT=dialog_parent, $
+                          DISPLAY_NAME=display_name, FILE=file, FILTER=filter, $
+                          FIX_FILTER=fix_filter, GET_PATH=get_path, GROUP=group, $
+                          MULTIPLE_FILES=multiple_files, MUST_EXIST=must_exist, $
+                          OVERWRITE_PROMPT=overwrite_prompt, PATH=path, $
+                          READ=read, WRITE=write, RESOURCE_NAME=resource_name, $
+                          TITLE=title, $
+                          ZENITY_NAME=zenity_name, ZENITY_PATH=zenity_path, $
+                          HELP=help, test=test, debug=debug, verbose=verbose
+;
+if KEYWORD_SET(help) then begin
+    print, 'function DIALOG_PICKFILE, DEFAULT_EXTENSION=default_extension, $'
+    print, '           DIRECTORY=directory, DIALOG_PARENT=dialog_parent, $'
+    print, '           DISPLAY_NAME=display_name, FILE=file, FILTER=filter, $'
+    print, '           FIX_FILTER=fix_filter, GET_PATH=get_path, GROUP=group, $'
+    print, '           MULTIPLE_FILES=multiple_files, MUST_EXIST=must_exist, $'
+    print, '           OVERWRITE_PROMPT=overwrite_prompt, PATH=path, '
+    print, '           READ=read, WRITE=write, RESOURCE_NAME=resource_name, $'
+    print, '           TITLE=title, '
+    print, '           ZENITY_NAME=zenity_name, ZENITY_PATH=zenity_path, $'
+    print, '           HELP=help, test=test, debug=debug, verbose=verbose'
+    return, ''
+endif
+; name
+if (N_ELEMENTS(zenity_name) EQ 0) then ZenityName='zenity' else ZenityName=zenity_name
+; path
+ZenityPath=''
+alt_ZenityPath=GETENV('ZENITY_PATH')
+if (N_ELEMENTS(zenity_path) GT 0) and (alt_ZenityPath NE '') then begin
+    if ~STRCMP(zenity_path,alt_ZenityPath) then begin
+        MESSAGE, /continue, 'You setup 2 different PATH to Zenity, please fix it !'
+        return, ''
+    endif
+    ;; the two paths are the same ...
+    ZenityPath=zenity_path
+endif else begin
+    ;; zero or one is provided ... if zero, no change to ZenityPath=''
+    if (N_ELEMENTS(zenity_path) GT 0) then ZenityPath=zenity_path
+    if (alt_ZenityPath NE '') then ZenityPath=alt_ZenityPath
+endelse
+;
+if KEYWORD_SET(debug) then begin
+    MESSAGE, /continue, 'Name of <<zenity>> : '+ZenityName
+    MESSAGE, /continue, 'Path to <<zenity>> : '+ZenityPath
+endif
+;
+if (ZenityPath eq '') then begin
+    ;; No path provided, use shell variable PATH
+    ZenityFullName=ZenityName
+endif else begin
+    ZenityFullName=ZenityPath+PATH_SEP()+ZenityName
+endelse
+;
+; Check if zenity exists in current paths and which version we have
+;
+SPAWN, ZenityFullName+' --version', stdout, stderr, exit_status=exit_status
+;
+; Search with other PATHs; 
+if (exit_status EQ 0) then begin
+    zen=ZenityFullName
+endif else begin
+    if (ZenityPath EQ '') then begin ; No path provided (no ZENITY_PATH shell variable or GDL keyword)
+        MESSAGE,/continue, 'No Zenity found in PATH, looking in alternate places'
+    endif else begin
+        MESSAGE,/continue, 'No Zenity found in the ZENITY_PATH you provide'
+        MESSAGE,/continue, '($ZENITY_PATH) or keyword ZENITY_PATH=), looking in alternate places'
+    endelse
+    ;;
+    paths=['/bin', '/usr/bin', '/usr/local/bin', '/opt/local/bin']+'/'
+    list_zenity=FILE_SEARCH(paths+zenityName)
+    ;;
+    if N_ELEMENTS(list_zenity) GT 1 then begin
+        MESSAGE, /continue, 'Multiple zenity found !'
+        MESSAGE, /continue, 'Please select the good one using shell variables'
+        MESSAGE, /continue, '($PATH or $ZENITY_PATH) or keyword ZENITY_PATH='
+        return, ''
+    endif
+    if (list_zenity eq '') then begin
+        MESSAGE, /continue, 'Zenity not found ! Zenity must be installed or in your PATH.'
+        MESSAGE, /continue, 'Your current path is : '+GETENV('PATH')
+        MESSAGE, /continue, 'You can give a path to Zenity with keyword ZENITY_PATH='
+        MESSAGE, /continue, 'or using shell $ZENITY_PATH'
+        if (STRLOWCASE(!version.OS) EQ 'darwin') then begin
+            MESSAGE, /continue, ' '
+            MESSAGE, /continue, 'How to install "zenity" on OSX ? Please have a look here:'
+            MESSAGE, /continue, 'http://www.macports.org/ports.php?by=name&substr=zenity'
+        endif
+        return, ''
+    endif
+    ;; here we have one and only one no-null path-to-zenity !
+    zen=list_zenity
+endelse
+;
+; Check default_extension
+if KEYWORD_SET(default_extension) then default_extension=STRING(default_extension[0])
+;
+; Zenith file selection mode
+cmd=zen+' --file-selection '
+get_path=''
+;
+; Only display directories
+if KEYWORD_SET(directory) then begin
+    cmd+='--directory '
+    type='Directory'
+endif else type='File'
+
+; Dialog_parent can't be used w/ Zenity
+
+; Set the X Window display
+; if KEYWORD_SET(display_name) then cmd+='--display="'+STRING(display_name)+'" '
+
+; Set the initial file selection. Since zenity can't distinguish initial path from initial selected file, 
+; we have to concatenate path and file
+; if path is set and exist, initial path = path
+; if path and file are set, then initial = path/file if exists, path otherwise (or current working directory if invalid path)
+; if file is set, initial = file
+; Zenity can't initialy select a non-exising file/directory
+start=''
+if KEYWORD_SET(path) then begin
+    path=STRING(path[0])
+    start+=path+path_sep()
+endif
+
+if KEYWORD_SET(file) then file=STRING(file[0])
+
+if start ne '' then $
+  if KEYWORD_SET(file) && file_test(start+file) then cmd+='--filename="'+start+file+'" ' else $
+  if file_test(start) then cmd+='--filename="'+start+'" '
+
+; Set the filters (Zenity version >= 2.23.1)
+if KEYWORD_SET(filter) then begin
+    SPAWN, zen+' --version', ver ; Get current Zenith version
+    version=STRSPLIT(ver, '\.', /extract)
+    version=UINT(version[0])*10000+UINT(version[1])*100+UINT(version[2])
+    if version lt 22301 then MESSAGE, 'Zenith version need to be >= 2.23.1 to support filters', /cont else begin ; Check if zenity ver < 2.23.1
+        if SIZE(filter, /dimensions) eq 0 then filter=[filter] ; Filter is as scalar STRING
+        filters=''
+        fsize=SIZE(filter, /n_elements)
+        if fsize gt 0 then begin
+            ;; Transform filter in Zenity(GTK) syntax
+            for i=0, fsize-1 do filter[i]=STRJOIN(STRSPLIT(STRING(filter[i]), ';', /extract), ' ')
+            if fsize gt 1 then begin ; concatenate all filters
+                for i=0, fsize-2 do begin
+                    filters+=STRING(filter[i])+' '
+                endfor
+                filters+=STRING(filter[fsize-1])
+                cmd+='--file-filter="'+filters+'" ' ; Add gobal filter
+            endif
+            for i=0, fsize-1 do cmd+='--file-filter="'+filter[i]+'" ' ; Add individual filters
+            cmd+='--file-filter="*.*" ' ; Add no-filter
+        endif
+    endelse
+endif
+
+; Can't perform fix_filter w/ Zenity
+; Group (Dialog_parent) can't be used w/ Zenity
+
+; Set multiple files option
+if KEYWORD_SET(multiple_files) then $
+  if KEYWORD_SET(directory) then message,'Selecting multiple directories is not supported.',/cont else cmd+='--multiple --separator=":" '
+
+; Must exist can't be used w/ Zenity, but if the selected file doesn't exist, it won't be returned (see below)
+
+; Read KW
+if KEYWORD_SET(read) && ~KEYWORD_SET(title) && ~KEYWORD_SET(write) then cmd+='--title="Please Select a '+type+' for Reading" '
+
+; Resource_name can't be used w/ Zenity
+
+; Write KW
+if KEYWORD_SET(write) && ~KEYWORD_SET(title) && ~KEYWORD_SET(read) then begin
+    readtitle='"Please Select a '+type+' for Writing" '
+    cmd+='--title='+readtitle
+endif
+
+; R/W KW
+if KEYWORD_SET(read) && KEYWORD_SET(write) && ~KEYWORD_SET(title) then begin
+    readtitle='"Please Select a '+type+' for Reading for Writing" '
+    cmd+='--title='+readtitle
+endif
+
+; Set window title
+if KEYWORD_SET(title) then begin
+    title=STRING(title[0])
+    cmd+='--title="'+title+'" '
+endif else $
+  if ~KEYWORD_SET(read) && ~KEYWORD_SET(write) then cmd+='--title="Please Select a '+type+'" '
+
+; Call Zenity
+SPAWN, cmd, result, exit_status=ex
+if (ex ne 0) then return, ''
+
+results=STRSPLIT(result, ':', /extract)
+rsize=SIZE(results, /n_elements)
+if (rsize eq 0) then return, ''
+
+; Set the path
+; If directory, get_path = the directory
+; else get_path = result's directory
+if KEYWORD_SET(directory) then get_path=results[0]+PATH_SEP() else get_path=FILE_DIRNAME(results[0])+PATH_SEP()
+
+; Must exist filter
+if KEYWORD_SET(must_exist) then begin
+    ix=where(file_test(results), c)
+    if c eq 0 then return, ''   ; No file exist
+    results=results[ix]
+    rsize=SIZE(results, /n_elements)
+    if rsize eq 0 then return, ''
+endif
+
+; Overwrite prompt
+if KEYWORD_SET(overwrite_prompt) && KEYWORD_SET(write) then begin
+    ;; Zenity can't be in save and multiselection mode at the same time
+    ;; That's why save mode is disable and overwrite prompt is done when Zenity returns
+    MESSAGE, 'For each cancelation, associated file will be deleted from the file list at return', /cont 
+    over=BYTARR(rsize)
+    for i=0, rsize-1 do begin   ; for each selected files
+        if file_test(results[i]) then begin ; check if it already exists
+            SPAWN, 'zenity --question --title='+readtitle+'--text="'+results[i]+' already exists.\nDo you want to replace it ?"', exit_status=ex
+            over[i]=~ex ; As Zenity can't pop-up question dialog, if user don't want to overwrite the file, just pop it from the list
+        endif
+    endfor
+    ix=where(over, c)         ; indexes of files which must be deleted
+    if c eq 0 then return, '' ; if every files have to be deleted, return
+    results=results[ix]    ; Delete file that shouldn't be overwritten
+    rsize=SIZE(results, /n_elements)
+    if rsize eq 0 then return, ''
+endif
+
+; default extension (simple behaviour, unlike IDL [no filter taken into account])
+if KEYWORD_SET(default_extension) then $
+  for i=0, rsize-1 do if STRPOS(file_basename(results[i]), '.') eq -1 then $
+  results[i]+='.'+default_extension ; no extension, then append default extension
+;
+if KEYWORD_SET(debug) OR KEYWORD_SET(debug) then STOP
+;
+return, results
+end
Only in gdl-0.9rc4/src/pro/dicom: Makefile.am.off
Only in gdl-0.9rc4/src/pro/dicom: Makefile.in.off
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/escape_special_char.pro cvs/gdl/src/pro/escape_special_char.pro
--- gdl-0.9rc4/src/pro/escape_special_char.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/pro/escape_special_char.pro	2010-06-29 04:21:27.000000000 -0600
@@ -0,0 +1,87 @@
+;+
+; NAME: ESCAPE_SPECIAL_CHAR
+; 
+; ESCAPE_SPECIAL_CHAR function escape special characteres present
+; in input string argument and returns the result.
+; Special characteres can be given by Keyword : list_of_special_char
+; or default list is used.
+;
+; MODIFICATION HISTORY:
+;   - June 2010: created by Lea Noreskal
+;   - 28 June 2010: modified by Alain Coulais (N_PARAMS(), /help)
+;-
+; LICENCE:
+; Copyright (C) 2010, Lea Noreskal and Alain Coulais
+; This program is free software; you can redistribute it and/or modify  
+; it under the terms of the GNU General Public License as published by  
+; the Free Software Foundation; either version 2 of the License, or     
+; (at your option) any later version.
+;-
+;
+; ---------------------------------
+;
+function ESCAPE_SPECIAL_CHAR, str_in,  show_list=show_list, $
+                              list_of_special_char=list_of_special_char, $
+                              test=test, help=help, verbose=verbose
+;
+if N_PARAMS() NE 1 then begin
+    MESSAGE, /continue, 'You must provide a input string !'
+    help=1
+endif
+if KEYWORD_SET(help) then begin
+    print, 'function ESCAPE_SPECIAL_CHAR, str_in, show_list=show_list, $'
+    print, '           list_of_special_char=list_of_special_char, $'
+    print, '           test=test, help=help, verbose=verbose'
+    return, -1
+endif
+;
+if KEYWORD_SET(verbose) then begin
+    MESSAGE, /continue, '/verbose keyword not available, please contribute'
+endif
+;
+; list of special characteres can be modified if it is not complete
+;if( not KEYWORD_SET(list_of_special_char)) then list_of_special_char ='[*.^$,&\]'
+;tab=STRSPLIT(str_in, list_of_special_char, /REGEX, /preserve)
+;print, tab
+
+if ~KEYWORD_SET(list_of_special_char) then list_of_special_char ='*.^$,&\'
+;
+if KEYWORD_SET(show_list) then begin
+    print, 'List of Special Chars which will be escapaded :'
+    print, list_of_special_char
+endif
+;
+tab=STRSPLIT(str_in, list_of_special_char, /preserve_null)
+;
+str_out='';
+;
+for ii=0,N_ELEMENTS(tab)-1 do begin
+    if (ii+1 LT N_ELEMENTS(tab)) then begin
+        ;;print,ii,  ' : ', tab[ii] ,' > ', STRMID(str_in,tab[ii],tab[ii+1]-tab[ii]-1)
+        if (tab[ii] GT 0) then begin
+            ;;escape special char
+            str_out=str_out+'\'+STRMID(str_in,tab[ii]-1,1)+STRMID(str_in,tab[ii],tab[ii+1]-tab[ii]-1)
+        endif else begin
+            ;;beginning of the world
+            str_out=str_out+STRMID(str_in,tab[ii],tab[ii+1]-tab[ii]-1)
+        endelse
+    endif else begin
+        ;;print, ii,  ' : ', tab[ii] ,' > ', STRMID(str_in,tab[ii])
+        if(tab[ii] GT 0) then begin
+            ;;escape special char
+            str_out=str_out+'\'+STRMID(str_in,tab[ii]-1,1)+STRMID(str_in,tab[ii])
+        endif else begin
+            ;;end of  the word        
+            str_out=str_out+STRMID(str_in,tab[ii])
+        endelse
+    endelse
+endfor
+;
+;merger of each part and escape spaces
+str_out=STRJOIN(STRSPLIT(str_out, /EXTRACT), '\ ') 
+;
+if KEYWORD_SET(test) then STOP
+;
+return, str_out
+;
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/file_basename.pro cvs/gdl/src/pro/file_basename.pro
--- gdl-0.9rc4/src/pro/file_basename.pro	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/pro/file_basename.pro	2010-07-07 14:41:02.616941801 -0600
@@ -56,12 +56,13 @@
 ; EXAMPLE:   
 ;
 ; print, file_basename('/usr/local/rsi/idl/lib/dist.pro', '.pro')  
-; IDL prints: 
+; GDL prints: 
 ; dist  
 ;
 ; MODIFICATION HISTORY:
 ;   - Sept 2007: created by Sebastien Masson
 ;   - Sept 2007: managing insufficient numbers of parameters, /help
+;   - June 2010: escape special characters by Lea Noreskal
 ;
 ;-
 ; LICENCE:
@@ -73,29 +74,33 @@
 ;-
 ;
 FUNCTION FILE_BASENAME, Path, RemoveSuffix, FOLD_CASE = fold_case, help=help
-  on_error, 2
+;
+ON_ERROR, 2
 ;
 if KEYWORD_SET(help) then begin
    print, 'FUNCTION FILE_BASENAME, Path, [RemoveSuffix], [/FOLD_CASE], [/help]'
    return, -1
 endif
 ;
-IF ((N_PARAMS() LT 1) OR (N_PARAMS() GT 2)) THEN BEGIN
-   message, 'Incorrect number of arguments.'
-ENDIF
-;
-IF KEYWORD_SET(fold_case) THEN BEGIN
-    message, 'Sorry, Keyword fold_case is not available now.'
-ENDIF
-
-SFX = N_ELEMENTS(RemoveSuffix) NE 0 ? RemoveSuffix : ''
-RESULT = STRARR(N_ELEMENTS(Path))
-FOR I = 0, N_ELEMENTS(Path) - 1 DO BEGIN
-  IF STRTRIM(PATH[I], 2) NE '' THEN BEGIN
-    SPAWN, '\basename ' + PATH[I] + ' ' + SFX, RES
-    RESULT[I] = TEMPORARY(RES)
-  ENDIF ELSE RESULT[I] = PATH[I]
-ENDFOR
+if ((N_PARAMS() LT 1) OR (N_PARAMS() GT 2)) then begin
+   MESSAGE, 'Incorrect number of arguments.'
+endif
+;
+IF KEYWORD_SET(fold_case) then begin
+    MESSAGE, 'Sorry, Keyword FOLD_CASE is not available now.'
+endif
+;
+sfx = N_ELEMENTS(RemoveSuffix) NE 0 ? RemoveSuffix : ''
+result = STRARR(N_ELEMENTS(Path))
+;
+for i = 0, N_ELEMENTS(path) - 1 do begin
+  if STRTRIM(path[i], 2) ne '' then begin
+    SPAWN, '\basename ' + ESCAPE_SPECIAL_CHAR(path[i]) + ' ' + ESCAPE_SPECIAL_CHAR(sfx), res
+    result[i] = TEMPORARY(res)
+  endif else result[i] = path[i]
+endfor
+;
+return, SIZE(path, /n_dim) eq 0 ? result[0] : result
+;
+end
 
-return, size(path, /N_DIM) eq 0 ? result[0] : result
-END
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/file_copy.pro cvs/gdl/src/pro/file_copy.pro
--- gdl-0.9rc4/src/pro/file_copy.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/pro/file_copy.pro	2010-06-29 02:51:54.000000000 -0600
@@ -0,0 +1,193 @@
+;+
+; NAME: FILE_COPY
+; 
+; RESTRICTIONS:  only for Unix (Unix, Linux and Mac OS X) systems
+;
+;-
+; LICENCE:
+; Copyright (C) 2010, Lea Noreskal; contact: Alain Coulais
+; This program is free software; you can redistribute it and/or modify  
+; it under the terms of the GNU General Public License as published by  
+; the Free Software Foundation; either version 2 of the License, or     
+; (at your option) any later version.
+;-
+; ---------------------------------
+;
+pro FILE_COPY, source, dest, require_directory=require_directory, $
+               allow_same=allow_same, noexpand_path=noexpand_path, recursive=recursive, $
+               overwrite=overwrite, quiet=quiet, verbose=verbose, help=help, test=test ;, $
+;not ready : force=force, copy_named_pipe=copy_named_pipe, copy_symlink=copy_symlink
+;
+if (N_PARAMS() LT 2) then BEGIN
+    print, '% FILE_COPY: Incorrect number of arguments.'
+    return
+endif
+;
+
+if (Not KEYWORD_SET(noexpand_path)) then begin  
+    
+    flist=''
+    for ii=0,N_ELEMENTS(source)-1 do begin
+        
+        dir=FILE_SEARCH(FILE_DIRNAME(source[ii]),/fully)
+        res=FILE_SEARCH(dir, FILE_BASENAME(source[ii]), /fully)
+
+        for jj=0,N_ELEMENTS(res)-1 do begin
+            if(FILE_DIRNAME(res[jj], /MARK_DIRECTORY) eq dir) then flist=[flist, res[jj]] ;
+            ;print, 'dir ', dir, ' res ', FILE_DIRNAME(res[jj])
+        endfor
+
+    endfor
+
+    if(N_ELEMENTS(flist) gt 1) then source=flist[1:*]; print, flist ;;
+
+; ...
+    for ii=0,N_ELEMENTS(dest)-1 do begin
+      struct=FILE_INFO(dest[ii])
+      if(struct.exists) then dest[ii]=escape_special_char(struct.name)
+    endfor
+;... 
+
+
+endif
+
+
+
+; either dest has the same size as source or it is a directory
+destIsDir=0 ; 0 if dest is an array, 1 if it is a directory
+
+if ( N_ELEMENTS(source) ne N_ELEMENTS(dest)) then begin
+   if( (N_ELEMENTS(dest) gt 1) $
+ or (FILE_TEST(dest[0], /directory) eq 0) ) then begin    
+      print, '% FILE_COPY:  Arrays source and dest must have same size, or dest must be a directory'
+      return
+   endif
+   ; N_elements(dest) = 1 and dest is a directory
+   destIsDir=1
+endif 
+;
+
+;
+if KEYWORD_SET(help) then begin
+   print, 'FUNCTION FILE_DELETE, source, dest,'
+   print, '          allow_same=allow_same, noexpand_path=noexpand_path, recursive=recursive, $'
+   print, '          overwrite=overwrite, require_directory=require directory, quiet=quiet, verbose=verbose, help=help, test=test'
+   ;print, '          UNIX-Only Keywords: [/COPY_NAMED_PIPE] [, /COPY_SYMLINK] [, /FORCE] '
+   return
+endif
+;
+
+command='\cp '
+option='-'
+
+;if KEYWORD_SET(allow_same) then begin
+;   print, 'Sorry, Keyword allow_same is not available now.'
+;   return
+;endif
+;
+
+
+
+if KEYWORD_SET(require_directory) then begin
+
+   ; verify if dest contains only directories
+   for ii=0, N_ELEMENTS(dest)-1 do begin
+      if ( FILE_TEST(dest[ii], /directory) eq 0 ) then begin 
+         print, '% FILE_COPY: require_directory, ', dest[ii], ' is not a valid directory '
+         return
+      endif
+   endfor
+endif
+;
+if KEYWORD_SET(recursive) then begin
+   option=option+'r'
+endif
+;
+;if KEYWORD_SET(noexpand_path) then begin
+;   print, 'Sorry, Keyword NOEXPAND_PATH is not available now.'
+;   return
+;endif
+;
+;cp=0;
+;if KEYWORD_SET(overwrite) then begin
+;endif
+;
+if KEYWORD_SET(copy_named_pipe) then begin
+   print, 'Sorry, Keyword copy_named_pipe is not available now.'
+   return
+endif
+;
+if KEYWORD_SET(copy_symlink) then begin
+   option=option+'d'
+endif
+;
+if KEYWORD_SET(force) then begin
+   option=option+'f'
+endif
+;
+;if KEYWORD_SET(quiet) then begin
+;   print, 'Sorry, Keyword quiet is not available now.'
+;   return
+;endif
+;
+if KEYWORD_SET(verbose) then begin
+   option=option+'v'
+endif
+;
+
+
+;
+if (STRLEN(option) GT 1 ) then begin
+   command=command+option
+   ;print, 'opt >', option, ' Comm : ', command
+endif
+;
+
+for ii=0, N_ELEMENTS(source)-1 do begin
+ 
+   if not KEYWORD_SET(recursive) then begin
+      if (FILE_TEST(source[ii], /directory) eq 1 ) then begin
+         if (KEYWORD_SET(verbose) or not KEYWORD_SET(quiet)) then print, '% FILE_COPY: ', source[ii], ' is a directory, use option /recursive'
+         return
+      endif
+   endif 
+
+   ; escape special characters
+   snameesc=escape_special_char(source[ii])
+   destname=dest[0] ; dest is a directory
+    
+   ;
+   if(destIsDir eq 0) then destname=dest[ii] ; dest is an array with several destination
+   ;
+   dnameesc=escape_special_char(destname)
+
+   ;if(KEYWORD_SET(allow_same) and (snameesc eq dnameesc)) > ne rien faire
+
+
+    ;verify if it is possible to copy, without keyword overwrite
+    cp=1;
+    if ((Not KEYWORD_SET(overwrite)) and FILE_TEST(destname,/directory)) then begin  
+        ;sname=get_filename(source[ii]) ;
+        sname=FILE_BASENAME(source[ii]) 
+
+        res = FILE_SEARCH(destname, sname,  COUNT=nb)
+        ;print ,'RES : ' , res, ' sname : ', sname
+        if (nb ne 0) then cp=0 ; there is not same files in directory
+    endif
+
+   ;copy
+   if((cp eq 1) and (not KEYWORD_SET(allow_same) or (snameesc ne dnameesc))) then SPAWN, command+' '+snameesc+' '+dnameesc
+   if(cp eq 0 and (KEYWORD_SET(verbose) or not KEYWORD_SET(quiet))) then print, '% FILE_COPY: ', source[ii] ,' overwrite not allowed '
+
+endfor
+
+
+
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+
+
+
+
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/file_delete.pro cvs/gdl/src/pro/file_delete.pro
--- gdl-0.9rc4/src/pro/file_delete.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/pro/file_delete.pro	2010-06-29 02:51:54.000000000 -0600
@@ -0,0 +1,132 @@
+;+
+; NAME: FILE_DELETE
+;
+;  
+;
+; RESTRICTIONS:  only for Unix (Unix, Linux and Mac OS X) systems
+;
+; MODIFICATION HISTORY:
+;   - April 2009: created by Alain Coulais, request by Igor C.
+;   - June 2010: modified by Lea Noreskal
+;-
+; LICENCE:
+; Copyright (C) 2009, Alain Coulais
+; This program is free software; you can redistribute it and/or modify  
+; it under the terms of the GNU General Public License as published by  
+; the Free Software Foundation; either version 2 of the License, or     
+; (at your option) any later version.
+;-
+; ---------------------------------
+;
+pro FILE_DELETE_ONE, list_of_files, allow_nonexistent=allow_nonexistent, $
+                     quiet=quiet, verbose=verbose , recursive=recursive, $ 
+                     noexpand_path=noexpand_path
+;
+command='\rm '
+option=''
+;
+if KEYWORD_SET(allow_nonexistent) then begin
+   option=option+'f'
+endif
+;
+if KEYWORD_SET(recursive) then begin
+   option=option+'r'
+endif
+;
+if KEYWORD_SET(verbose) then begin
+   option=option+'v'
+endif
+;
+if (STRLEN(option) GT 0) then begin
+   option='-'+option
+endif
+
+
+for ii=0,N_ELEMENTS(list_of_files)-1 do begin
+
+    ; escape special char
+    nameescp=escape_special_char(list_of_files[ii])
+;
+    if (Not KEYWORD_SET(noexpand_path)) then begin  
+        struct=FILE_INFO(list_of_files[ii])
+        if(struct.exists) then nameescp=escape_special_char(struct.name)
+    endif
+; 
+
+    ; empty directory
+    emptdir=''
+    if (FILE_TEST(nameescp , /directory) and (Not KEYWORD_SET(recursive)) ) then begin  
+        res = FILE_SEARCH(list_of_files[ii] , '*' ,  COUNT=nb)
+        if ((nb eq 0)  and (Not KEYWORD_SET(recursive))) then begin
+            emptdir=' -r'
+        endif
+    endif
+
+    res = FILE_INFO(nameescp) 
+
+    ;if (FILE_TEST(nameescp) EQ 1) then begin
+    if ((res.EXISTS eq 1) and (res.WRITE ne 0)) then begin
+
+        SPAWN, command+option+emptdir+' '+nameescp, result, result_error
+
+        if KEYWORD_SET(verbose) or NOT(KEYWORD_SET(quiet)) then print,'% FILE_DELETE: Removed file: ', nameescp ;list_of_files[ii]
+        ;print, 'res:', result, result_error
+
+    endif else begin
+        if ((KEYWORD_SET(verbose)) or (NOT(KEYWORD_SET(allow_nonexistent) or KEYWORD_SET(quiet)))) then begin 
+            print, 'problem with =', list_of_files[ii] , ' , no existing file or forbidden deletion'
+        endif
+    endelse
+
+endfor
+
+
+end
+;
+; ---------------------------------
+;
+pro FILE_DELETE, files0,  files1,  files2,  files3,  files4,  files5,  files6,  files7,  files8,  files9, $
+                 files10, files11, files12, files13, files14, files15, files16, files17, files18, files19, $
+                 files20, files21, files22, files23, files24, files25, files26, files27, files28, files29, $
+                 allow_nonexistent=allow_nonexistent, noexpand_path=noexpand_path, recursive=recursive, $
+                 quiet=quiet, verbose=verbose, help=help, test=test
+
+;
+if (N_PARAMS() LT 1) then begin
+   print, '% FILE_DELETE: Incorrect number of arguments.'
+   return
+endif
+
+;
+if KEYWORD_SET(help) then begin
+   print, 'FUNCTION FILE_DELETE, file1, file2, ...'
+   print, '          allow_nonexistent=allow_nonexistent, noexpand_path=noexpand_path, recursive=recursive, $'
+   print, '          quiet=quiet, verbose=verbose, help=help, test=test'
+   return
+endif
+;
+
+;if KEYWORD_SET(noexpand_path) then begin
+;   print, 'Sorry, Keyword NOEXPAND_PATH is not available now.'
+;   return
+;endif
+;
+
+for __i__=0, N_PARAMS()-1 do begin
+   files = STRCOMPRESS('files' + string(__i__), /remove_all)
+   stat=EXECUTE('FILE_DELETE_ONE,'+files+',allow_nonexistent=allow_nonexistent, quiet=quiet, verbose=verbose, recursive=recursive, noexpand_path=noexpand_path')
+
+endfor
+
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+
+
+
+
+
+
+
+
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/file_dirname.pro cvs/gdl/src/pro/file_dirname.pro
--- gdl-0.9rc4/src/pro/file_dirname.pro	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/pro/file_dirname.pro	2010-07-07 14:41:02.657004380 -0600
@@ -67,6 +67,7 @@
 ; MODIFICATION HISTORY:
 ;   - Sept 2007: created by Sebastien Masson
 ;   - Setp 2007: mananing wrong numbers of parameters, /help
+;   - June 2010: escape special characters by Lea Noreskal
 ;
 ;-
 ; LICENCE:
@@ -81,17 +82,18 @@
   on_error, 2
 ;
 if KEYWORD_SET(help) then begin
-   print, 'FUNCTION FILE_DIRNAME, Path [, /mark_directory] [, /help]'
+   PRINT, 'FUNCTION FILE_DIRNAME, Path [, /mark_directory] [, /help]'
    return, -1
 endif
 ;
 IF (N_PARAMS() NE 1) THEN BEGIN
-   message, 'Incorrect number of arguments.'
+   MESSAGE, 'Incorrect number of arguments.'
 ENDIF
 ;
-command = '\dirname ' + Path
-spawn, command, result
-IF keyword_set(mark_directory) THEN result = result + path_sep()
+command = '\dirname ' + ESCAPE_SPECIAL_CHAR(Path)
+SPAWN, command, result
+;
+IF KEYWORD_SET(mark_directory) THEN result = result + PATH_SEP()
 ;
 return, result
 ;
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/file_expand_path.pro cvs/gdl/src/pro/file_expand_path.pro
--- gdl-0.9rc4/src/pro/file_expand_path.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/pro/file_expand_path.pro	2010-06-29 02:34:15.000000000 -0600
@@ -0,0 +1,16 @@
+;+
+; NAME: FILE_EXPAND_PATH
+; 
+;-
+; LICENCE:
+; Copyright (C) 2010, Lea Noreskal, contact Alain Coulais
+; This program is free software; you can redistribute it and/or modify
+; it under the terms of the GNU General Public License as published by
+; the Free Software Foundation; either version 2 of the License, or
+; (at your option) any later version.
+;-
+;
+function FILE_EXPAND_PATH , path
+return , FILE_SEARCH(path, /FULLY_QUALIFY_PATH)
+end
+;
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/findex.pro cvs/gdl/src/pro/findex.pro
--- gdl-0.9rc4/src/pro/findex.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/pro/findex.pro	2010-04-09 04:30:38.000000000 -0600
@@ -0,0 +1,97 @@
+ ;+
+   ; ROUTINE:  findex
+   ;
+   ; PURPOSE:  Compute "floating point index" into a table using binary
+   ;           search.  The resulting output may be used with INTERPOLATE.
+   ;
+   ; USEAGE:   result = findex(u,v)
+   ;
+   ; INPUT:    
+   ;   u       a monitically increasing or decreasing 1-D grid
+   ;   v       a scalor, or array of values
+   ;
+   ; OUTPUT:
+   ;   result  Floating point index. Integer part of RESULT(i) gives
+   ;           the index into to U such that V(i) is between
+   ;           U(RESULT(i)) and U(RESULT(i)+1).  The fractional part
+   ;           is the weighting factor
+   ;
+   ;                          V(i)-U(RESULT(i))
+   ;                          ---------------------
+   ;                     U(RESULT(i)+1)-U(RESULT(i))
+   ;
+   ;
+   ; DISCUSSION: 
+   ;           This routine is used to expedite one dimensional
+   ;           interpolation on irregular 1-d grids.  Using this routine
+   ;           with INTERPOLATE is much faster then IDL's INTERPOL
+   ;           procedure because it uses a binary instead of linear
+   ;           search algorithm.  The speedup is even more dramatic when
+   ;           the same independent variable (V) and grid (U) are used
+   ;           for several dependent variable interpolations.
+   ;
+   ;  
+   ; EXAMPLE:  
+   ;
+   ;; In this example I found the FINDEX + INTERPOLATE combination
+   ;; to be about 60 times faster then INTERPOL.
+   ;
+   ;  u=randomu(iseed,200000) & u=u(sort(u))
+   ;  v=randomu(iseed,10)     & v=v(sort(v))
+   ;  y=randomu(iseed,200000) & y=y(sort(y))
+   ;
+   ;  t=systime(1) & y1=interpolate(y,findex(u,v)) & print,systime(1)-t
+   ;  t=systime(1) & y2=interpol(y,u,v)            & print,systime(1)-t
+   ;  print,f='(3(a,10f7.4/))','findex:   ',y1,'interpol: ',y2,'diff:     ',y1-y2
+   ;
+   ; AUTHOR:   Paul Ricchiazzi                        21 Feb 97
+   ;           Institute for Computational Earth System Science
+   ;           University of California, Santa Barbara
+   ;           paul@icess.ucsb.edu
+   ;
+   ; REVISIONS:
+   ;
+   ; LICENCE: (note added by Sylwester Arabas)
+   ;  This code was posted by Paul Ricchiazzi at the comp.land.idl-pvwave 
+   ;  newsgroup on Feb 21 1997. The post mentions 'donating this procedure
+   ;  to the IDL community' - it is thus regarded as 'public domain' licence
+   ;  compatible with GNU GPL.
+   ;
+   ;-
+   ;
+   function findex,u,v
+   nu=n_elements(u)
+   nv=n_elements(v)
+
+   us=u-shift(u,+1)
+   us=us(1:*)
+   umx=max(us,min=umn)
+   if umx gt 0 and umn lt 0 then message,'u must be monotonic'
+   if umx gt 0 then inc=1 else inc=0
+
+   maxcomp=fix(alog(float(nu))/alog(2.)+.5) 
+
+   ; maxcomp = maximum number of binary search iteratios
+
+   jlim=lonarr(2,nv)
+   jlim(0,*)=0          ; array of lower limits
+   jlim(1,*)=nu-1       ; array of upper limits
+
+   iter=0
+   repeat begin
+     jj=(jlim(0,*)+jlim(1,*))/2
+     ii=where(v ge u(jj),n) & if n gt 0 then jlim(1-inc,ii)=jj(ii)
+     ii=where(v lt u(jj),n) & if n gt 0 then jlim(inc,ii)=jj(ii)
+     jdif=max(jlim(1,*)-jlim(0,*))
+     if iter gt maxcomp then begin
+       print,maxcomp,iter, jdif
+       message,'binary search failed'
+     endif
+     iter=iter+1
+   endrep until jdif eq 1 
+
+   w=v-v
+   w(*)=(v-u(jlim(0,*)))/(u(jlim(0,*)+1)-u(jlim(0,*)))+jlim(0,*)
+
+   return,w
+   end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/hist_2d.pro cvs/gdl/src/pro/hist_2d.pro
--- gdl-0.9rc4/src/pro/hist_2d.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/pro/hist_2d.pro	2010-02-20 13:46:27.000000000 -0700
@@ -0,0 +1,39 @@
+; by Sylwester Arabas <slayoo@igf.fuw.edu.pl>
+; uses hist_nd() released under GPL by J.D. Smith
+function hist_2d, v1, v2, bin1=bin1, bin2=bin2, max1=max1, max2=max2, min1=min1, min2=min2
+  on_error, 2
+
+  ; bin-widths default to 1
+  if n_elements(bin1) eq 0 then bin1 = 1
+  if n_elements(bin2) eq 0 then bin2 = 1
+
+  ; min and max default to minimum and maximum values ... with some exceptions
+  if n_elements(min1) eq 0 then begin
+    if n_elements(max1) ne 0 then min1 = 0 < min(v1, /nan) else min1 = 0 < min(v1, max=max1, /nan)
+  endif else if n_elements(max1) eq 0 then max1 = max(v1, /nan)
+  if n_elements(min2) eq 0 then begin
+    if n_elements(max2) ne 0 then min2 = 0 < min(v2, /nan) else min2 = 0 < min(v2, max=max2, /nan)
+  endif else if n_elements(max2) eq 0 then max2 = max(v2, /nan)
+
+  ; sanity checks for some undefined-behaviour conditions
+  if bin1 le 0 then message, "bin1 must be > 0"
+  if bin2 le 0 then message, "bin2 must be > 0"
+  if ~finite(min1) || ~finite(min2) || ~finite(max1) || ~finite(max2) then $
+    message, "min1, min2, max1 and max2 must all be finite"
+  if min1 eq max1 then message, "min1 must not be equal to max1"
+  if min2 eq max2 then message, "min2 must not be equal to max2"
+
+  ; the shorter array determines how many elements are taken into account
+  n = n_elements(v1) < n_elements(v2)
+  if n eq 1 then begin
+    ; emulating IDL behaviour with 1-element arrays and scalars
+    data = transpose([[v1[0], max1 + 1], [v2[0], max2 + 1]])
+  endif else begin
+    data = transpose([[v1[0 : n - 1]], [v2[0 : n - 1]]])
+  endelse
+
+  ret = hist_nd(temporary(data), [bin1, bin2], min=[min1, min2], max=[max1, max2])
+  if size(ret,/n_dimensions) eq 1 then return, reform(ret, n_elements(ret), 1)
+  return, ret
+
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/hist_nd.pro cvs/gdl/src/pro/hist_nd.pro
--- gdl-0.9rc4/src/pro/hist_nd.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/pro/hist_nd.pro	2010-02-20 13:46:27.000000000 -0700
@@ -0,0 +1,177 @@
+;+
+; NAME:
+;       HIST_ND
+;
+; PURPOSE:
+;
+;       Perform an N-dimensional histogram, also known as the joint
+;       density function of N variables, ala HIST_2D.
+;
+; CALLING SEQUENCE:
+;       hist=HIST_ND(V,[BINSIZE,MIN=,MAX=,NBINS=,REVERSE_INDICES=])
+;
+; INPUTS:
+;
+;       V: A NxP array representing P data points in N dimensions.  
+;
+;       BINSIZE: The size of the bin to use. Either an N point vector
+;         specifying a separate size for each dimension, or a scalar,
+;         which will be used for all dimensions.  If BINSIZE is not
+;         passed, NBINS must be.
+;
+; OPTIONAL INPUTS: 
+;
+;       MIN: The minimum value for the histogram.  Either a P point
+;         vector specifying a separate minimum for each dimension, or
+;         a scalar, which will be used for all dimensions.  If
+;         omitted, the natural minimum within the dataset will be
+;         used.
+;
+;       MAX: The maximum value for the histogram.  Either a P point
+;         vector specifying a separate maximmum for each dimension, or
+;         a scalar, which will be used for all dimensions. If omitted,
+;         the natural maximum within the dataset will be used.
+;
+;       NBINS: Rather than specifying the binsize, you can pass NBINS,
+;         the number of bins in each dimension, which can be a P point
+;         vector, or a scalar.  If BINSIZE it also passed, NBINS will
+;         be ignored, otherwise BINSIZE will then be calculated as
+;         binsize=(max-min)/nbins.  Note that *unlike* RSI's version
+;         of histogram as of IDL 5.4, this keyword actually works as
+;         advertised, giving you NBINS bins over the range min to max.
+;
+; KEYWORD PARAMETERS:
+;       
+;       MIN,MAX,NBINS: See above
+;       
+;       REVERSE_INDICES: Set to a named variable to receive the
+;         reverse indices, for mapping which points occurred in a
+;         given bin.  Note that this is a 1-dimensional reverse index
+;         vector (see HISTOGRAM).  E.g., to find the indices of points
+;         which fell in a histogram bin [i,j,k], look up:
+;
+;             ind=[i+nx*(j+ny*k)]
+;             ri[ri[ind]:ri[ind+1]-1]
+;
+;         See also ARRAY_INDICES for converting in the other
+;         direction.
+;
+; OUTPUTS:
+;
+;       hist: The N-Dimensional histogram, an array of size
+;         N1xN2xN3x...xND where the Ni's are the number of bins
+;         implied by the data, and/or the optional inputs min, max and
+;         binsize.
+;
+; OPTIONAL OUTPUTS:
+;
+;       The reverse indices.
+;
+; EXAMPLE:
+;       
+;       v=randomu(sd,3,100)
+;       h=hist_nd(v,.25,MIN=0,MAX=1,REVERSE_INDICES=ri)
+;
+; SEE ALSO:
+;
+;       HISTOGRAM, HIST_2D
+;
+; MODIFICATION HISTORY:
+;
+;       Mon Mar 5 09:45:53 2007, J.D. Smith <jdsmith@as.arizona.edu>
+;
+;               Correctly trim out of range elements from the
+;               histogram, when MIN/MAX are specified. Requires IDL
+;               v6.1 or later.
+;
+;       Tue Aug 19 09:13:43 2003, J.D. Smith <jdsmith@as.arizona.edu>
+;
+;               Slight update to BINSIZE logic to provide consistency
+;               with HIST_2D.
+;
+;       Fri Oct 11 10:10:01 2002, J.D. Smith <jdsmith@as.arizona.edu>
+;
+;               Updated to use new DIMENSION keyword to MAX/MIN.
+;
+;       Fri Apr 20 12:57:34 2001, JD Smith <jdsmith@astro.cornell.edu>
+;
+;               Slight update to NBINS logic.  More aggressive keyword
+;               checking.
+;
+;       Wed Mar 28 19:41:10 2001, JD Smith <jdsmith@astro.cornell.edu>
+;
+;               Written, based on HIST_2D, and suggestions of CM.
+;
+;-
+;##############################################################################
+;
+; LICENSE
+;
+;  Copyright (C) 2001-2003, 2004, 2007 J.D. Smith
+;
+;  This file is free software; you can redistribute it and/or modify
+;  it under the terms of the GNU General Public License as published
+;  by the Free Software Foundation; either version 2, or (at your
+;  option) any later version.
+;
+;  This file is distributed in the hope that it will be useful, but
+;  WITHOUT ANY WARRANTY; without even the implied warranty of
+;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+;  General Public License for more details.
+;
+;  You should have received a copy of the GNU General Public License
+;  along with this file; see the file COPYING.  If not, write to the
+;  Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+;  Boston, MA 02110-1301, USA.
+;
+;##############################################################################
+
+function hist_nd,V,bs,MIN=mn,MAX=mx,NBINS=nbins,REVERSE_INDICES=ri
+  s=size(V,/DIMENSIONS)
+  if n_elements(s) ne 2 then message,'Input must be N (dimensions) x P (points)'
+  if s[0] gt 8 then message, 'Only up to 8 dimensions allowed'
+  
+  imx=max(V,DIMENSION=2,MIN=imn)
+  
+  if n_elements(mx) eq 0 then mx=imx
+  if n_elements(mn) eq 0 then mn=imn
+  
+  if s[0] gt 1 then begin 
+     if n_elements(mn)    eq 1 then mn=replicate(mn,s[0])
+     if n_elements(mx)    eq 1 then mx=replicate(mx,s[0])
+     if n_elements(bs)    eq 1 then bs=replicate(bs,s[0])
+     if n_elements(nbins) eq 1 then nbins=replicate(nbins,s[0])
+  endif 
+  
+  if ~array_equal(mn le mx,1b) then $
+     message,'Min must be less than or equal to max.'
+  
+  if n_elements(bs) eq 0 then begin 
+     if n_elements(nbins) ne 0 then begin 
+        nbins=long(nbins)       ;No fractional bins, please
+        bs=float(mx-mn)/nbins   ;a correct formulation
+     endif else message,'Must pass either binsize or NBINS'
+  endif else nbins=long((mx-mn)/bs+1) 
+  
+  total_bins=product(nbins,/PRESERVE_TYPE) ;Total number of bins
+  h=long((V[s[0]-1,*]-mn[s[0]-1])/bs[s[0]-1])
+  ;; The scaled indices, s[n]+N[n-1]*(s[n-1]+N[n-2]*(s[n-2]+...
+  for i=s[0]-2,0,-1 do h=nbins[i]*temporary(h) + long((V[i,*]-mn[i])/bs[i])
+  
+  out_of_range=[~array_equal(mn le imn,1b),~array_equal(mx ge imx,1b)]
+  if ~array_equal(out_of_range,0b) then begin 
+     in_range=1
+     if out_of_range[0] then $  ;out of range low
+        in_range=total(V ge rebin(mn,s,/SAMP),1,/PRESERVE_TYPE) eq s[0]
+     if out_of_range[1] then $  ;out of range high
+        in_range AND= total(V le rebin(mx,s,/SAMP),1,/PRESERVE_TYPE) eq s[0]
+     h=(temporary(h) + 1L)*temporary(in_range) - 1L
+  endif 
+
+  ret=make_array(TYPE=3,DIMENSION=nbins,/NOZERO)
+  if arg_present(ri) then $
+     ret[0]=histogram(h,MIN=0L,MAX=total_bins-1L,REVERSE_INDICES=ri) $
+  else $
+     ret[0]=histogram(h,MIN=0L,MAX=total_bins-1L)
+  return,ret
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/imsl_erf.pro cvs/gdl/src/pro/imsl_erf.pro
--- gdl-0.9rc4/src/pro/imsl_erf.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/pro/imsl_erf.pro	2010-06-08 06:08:18.000000000 -0600
@@ -0,0 +1,8 @@
+; by Sylwester Arabas <slayoo@igf.fuw.edu.pl>
+function imsl_erf, x, double=dbl, inverse=inv
+  on_error, 2
+  if ~keyword_set(inv) then return, erf(x, double=dbl)
+  if total([x] ge 1 or [x] le -1) gt 0 then $
+    message, 'The inverse error function is defined only for -1 < x < 1'
+  return, gdl_erfinv(x, double=dbl)
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/interpol.pro cvs/gdl/src/pro/interpol.pro
--- gdl-0.9rc4/src/pro/interpol.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/pro/interpol.pro	2010-04-09 04:30:38.000000000 -0600
@@ -0,0 +1,43 @@
+; by Sylwester Arabas <slayoo@igf.fuw.edu.pl>
+; relies on findex.pro by Paul Ricchiazzi
+function interpol, p0, p1, p2, lsquadratic=lsquadratic, quadratic=quadratic, spline=spline
+  on_error, 2
+
+  ; sanity checks
+  if n_params() eq 1 then $
+    message, 'Two or three parameters required'
+  if keyword_set(lsquadratic) then $
+    message, 'LSQUADRATIC keyword not supported yet (FIXME!)'
+  if keyword_set(quadratic) then $
+    message, 'QUADRATIC keyword not supported yet (FIXME!)'
+
+  isint = size(p0, /ty) lt 4 || size(p0, /ty) gt 11
+
+  if n_params() eq 2 then begin
+    ; regular grid case
+    if size(p1, /dimensions) eq 0 then begin
+      ind = findgen(p1) / (p1 - (p1 eq 1 ? 0 : 1)) * (n_elements(p0) - 1)
+    endif else begin
+      message, 'In the two-parameter case the second parameter must be a scalar'
+      ; TODO: IDL does something else here...
+    endelse
+  endif else if ~keyword_set(spline) then begin
+    ; irregular grid case
+    ind = findex(p1, p2)
+  endif
+
+  if keyword_set(spline) then begin
+    ; spline case
+    if n_params() eq 2 then begin
+      x = findgen(n_elements(p0))
+      y = spl_interp(x, p0, spl_init(x, p0), ind)
+    endif else begin
+      y = spl_interp(p1, p0, spl_init(p1, p0), p2)
+    endelse
+    return, fix(temporary(y), type=size(p0, /type))
+  endif else begin
+    ; linear interpolation case
+    return, interpolate(isint ? float(p0) : p0, ind)
+  endelse
+
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/ludc.pro cvs/gdl/src/pro/ludc.pro
--- gdl-0.9rc4/src/pro/ludc.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/src/pro/ludc.pro	2010-04-21 15:48:07.000000000 -0600
@@ -0,0 +1,7 @@
+;
+; Alain Coulais, 21/04/2010, under GNU GPL 2 or later
+; fake LUDC to be able to run end-to-end IDL time_test3
+;
+pro LUDC, a,b,c
+MESSAGE, /Continue, 'Sorry, this procedure LUDC is not available'
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/Makefile.am cvs/gdl/src/pro/Makefile.am
--- gdl-0.9rc4/src/pro/Makefile.am	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/pro/Makefile.am	2010-07-07 14:41:02.549945052 -0600
@@ -5,21 +5,32 @@
   array_indices.pro \
   calendar.pro \
   deriv.pro \
+  dialog_pickfile.pro \
   dist.pro \
+  escape_special_char.pro \
   factorial.pro \
   file_basename.pro \
+  file_copy.pro \
+  file_delete.pro \
   file_dirname.pro \
+  file_expand_path.pro \
   file_lines.pro \
   filepath.pro \
+  findex.pro \
   findfile.pro \
   helpform.pro \
+  hist_2d.pro \
+  hist_nd.pro \
   identity.pro \
+  imsl_erf.pro \
   imsl_zerosys.pro \
+  interpol.pro \
   ishft.pro \
   kurtosis.pro \
   last_item.pro \
   lmgr.pro \
   loadct.pro \
+  ludc.pro \
   map_clip_set.pro \
   matrix_multiply.pro \
   mean.pro \
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/Makefile.in cvs/gdl/src/pro/Makefile.in
--- gdl-0.9rc4/src/pro/Makefile.in	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/pro/Makefile.in	2010-07-07 14:41:02.552940898 -0600
@@ -244,21 +244,32 @@
   array_indices.pro \
   calendar.pro \
   deriv.pro \
+  dialog_pickfile.pro \
   dist.pro \
+  escape_special_char.pro \
   factorial.pro \
   file_basename.pro \
+  file_copy.pro \
+  file_delete.pro \
   file_dirname.pro \
+  file_expand_path.pro \
   file_lines.pro \
   filepath.pro \
+  findex.pro \
   findfile.pro \
   helpform.pro \
+  hist_2d.pro \
+  hist_nd.pro \
   identity.pro \
+  imsl_erf.pro \
   imsl_zerosys.pro \
+  interpol.pro \
   ishft.pro \
   kurtosis.pro \
   last_item.pro \
   lmgr.pro \
   loadct.pro \
+  ludc.pro \
   map_clip_set.pro \
   matrix_multiply.pro \
   mean.pro \
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/README.txt cvs/gdl/src/pro/README.txt
--- gdl-0.9rc4/src/pro/README.txt	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/pro/README.txt	2010-04-16 11:22:54.000000000 -0600
@@ -4,14 +4,14 @@
 1/ procedures from the IDL library
 
 Most of the files here are re-implementation of the
-open source files avaiblable in the IDL lib directory.
-Since the original library is under Copyrigth, we cannot copy it
+open source files available in the IDL lib directory.
+Since the original library is under Copyright, we cannot copy it
 directly in GDL. Then we need to develop a clone for some of the 
 most useful procedures in this library.
 
-Some of these routines can be find and downloaded from
+Some of these routines can be found and downloaded from
 http://idlastro.gsfc.nasa.gov/idllibsrch.html
-but we cannot includ them now in GDL.
+but we cannot include them now in GDL.
 
 Please see STATUS for a list of the files,
 if they are needed, or not, written (in GDL or C++)
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/restore.pro cvs/gdl/src/pro/restore.pro
--- gdl-0.9rc4/src/pro/restore.pro	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/pro/restore.pro	2010-04-16 11:22:54.000000000 -0600
@@ -79,22 +79,12 @@
    print, "% RESTORE: default FILENAME is used : ", filename0
 endif
 ;
-CMRESTORE, filename0, filename=filename1, verbose=verbose, $
-           p0,  p1,  p2,  p3,  p4,  p5,  p6,  p7,  p8,  p9, $
-           p10, p11, p12, p13, p14, p15, p16, p17, p18, p19, $
-           p20, p21, p22, p23, p24, p25, p26, p27, p28, p29, $
-           names=_nme_
+CMRESTORE, filename0, filename=filename1, verbose=verbose, names=_nme_, $
+  data=data, pass_method='struct'
 
-for i=0,n_elements(_nme_)-1 do begin
-   p = strcompress('p' + string(i), /remove_all)
-   parm = 'dummy=routine_names(_nme_[i],' + p + ',store=-1)'
-   stat = execute(parm)
-   ;;
-   ;; at the end, I saw the /Verbose is OK in CMRESTORE (but 2 times !)
-   ;;if KEYWORD_SET(verbose) then begin
-   ;;   print, '% RESTORE: Restored variable: ' , _nme_[i]+'.'
-   ;;endif       
-endfor
+  for i = 0, n_elements(_nme_) - 1 do begin
+    dummy = routine_names(_nme_[i], data.(i), store=-1)
+  endfor
 
-return
+  return
 end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/STATUS cvs/gdl/src/pro/STATUS
--- gdl-0.9rc4/src/pro/STATUS	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/pro/STATUS	2010-04-16 11:22:54.000000000 -0600
@@ -123,7 +123,7 @@
 !h_eq_ct.pro
 !h_eq_int.pro
 !hilbert.pro
-!hist_2d.pro
+=hist_2d.pro
 !hist_equal.pro
  hls.pro
  hsv.pro
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/str_sep.pro cvs/gdl/src/pro/str_sep.pro
--- gdl-0.9rc4/src/pro/str_sep.pro	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/pro/str_sep.pro	2010-07-07 14:41:02.700941727 -0600
@@ -6,6 +6,8 @@
 ;
 ; MODIFICATION HISTORY:
 ;   01-Sep-2006 : written by Joel Gales
+;   14-Apr-2010 : Alain Coulais : complete re-writing
+;   18-Jun-2010 : Alain Coulais and Lea N.: mandatory usage of /preserve_null
 ;
 ; LICENCE:
 ; Copyright (C) 2006, J. Gales
@@ -15,8 +17,54 @@
 ; (at your option) any later version.
 ;
 ;-
+;
+function STR_SEP, str, sep, $
+                  trim=trim, remove_all=remove_all, esc=esc, $
+                  test=test, help=help
+;
+ON_ERROR, 2
+;
+if KEYWORD_SET(help) then begin
+    print, 'function STR_SEP, str, sep, $'
+    print, '                  trim=trim, remove_all=remove_all, esc=esc, $'
+    print, '                  test=test, help=help'
+    return, -1
+endif
+;
+if (N_PARAMS() NE 2) then MESSAGE, 'Wrong number of arguments. (Two Strings expected)'
+
+if N_ELEMENTS(str) NE 1 then MESSAGE, 'No array allowed for Input String'
+if N_ELEMENTS(sep) NE 1 then MESSAGE, 'No array allowed for Sep String'
+if (SIZE(str, /type) NE 7) then MESSAGE, 'Invalid Input String.'
+if (SIZE(sep, /type) NE 7) then MESSAGE, 'Invalid Sep String.'
+;
+if KEYWORD_SET(escape) then begin
+    MESSAGE, /continue, 'Sorry, this keyword ESCAPE is not implemented (no effect)'
+    MESSAGE, /continue, 'PLEASE CONTRIBUTE'
+endif
 
-function str_sep, str, sep
+if (STRLEN(sep) EQ 1) then res=STRSPLIT(str,sep, /extract, /preserve_null)
+if (STRLEN(sep) GT 1) then res=STRSPLIT(str,sep, /regex, /extract, /preserve_null)
+;
+nb_parts=N_ELEMENTS(res)
+;
+if KEYWORD_SET(trim) then begin
+    for i=0,nb_parts-1 do res[ii]=STRTRIM(res[ii], 2)
+endif
+if KEYWORD_SET(remove_all) then begin
+    for i=0,nb_parts-1 do res[ii]=STRCOMPRESS(res[ii], /Remove_All)
+endif
+;
+if KEYWORD_SET(test) then STOP
+;
+return, res
+;
+end
+;
+; --------- original code by Joel ------------
+; seems to be OK only when : SRTLEN(sep) == 1
+;
+function OLD_STR_SEP, str, sep
   on_error, 2
 
   if n_params() ne 2 then message, 'Two parameters required.'
@@ -33,3 +81,17 @@
 
   return, res
 end
+;
+; --------- please add tests here ------------
+;
+pro TEST_STR_SEP, test=test
+;
+resu1=STR_SEP('../foo.txt','.')
+if n_elements(resu1) NE 4 then MESSAGE, 'problem 1'
+if resu1[3] NE '/foo' then MESSAGE, 'problem 1bis'
+if resu1[4] NE 'txt' then MESSAGE, 'problem 1ter'
+MESSAGE, /continue, 'First test OK'
+;
+if KEYWORD_SET(test) then STOP
+;
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/strsplit.pro cvs/gdl/src/pro/strsplit.pro
--- gdl-0.9rc4/src/pro/strsplit.pro	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/pro/strsplit.pro	2010-07-07 14:41:02.702942918 -0600
@@ -16,54 +16,189 @@
 ; MODIFICATION HISTORY:
 ;   17-Jul-2005 : written by Pierre Chanial
 ;   30-Jun-2009 : Alain Coulais : will allow 1D string : 'string' and ['string']
+;   14-Apr-2010 : Alain Coulais : complete re-writing
+;      Jun-2010 : Lea Noreskal : /preserve_null and other improvments
 ;
 ; LICENCE:
-; Copyright (C) 2004, Pierre Chanial
+; Copyright (C) 2004, Pierre Chanial; 2010, Alain Coulais
 ; This program is free software; you can redistribute it and/or modify
 ; it under the terms of the GNU General Public License as published by
 ; the Free Software Foundation; either version 2 of the License, or
 ; (at your option) any later version.
 ;
-;
 ;-
+;
+function STRMULTIPOS, str, single_char, test=test
+ON_ERROR, 2
+if (SIZE(str, /type) NE 7) OR (SIZE(single_char, /type) NE 7) then begin
+    MESSAGE, 'Invalid input string.'
+    return, -1
+endif
+if (STRLEN(single_char) NE 1) then begin
+    MESSAGE, 'field2 must be a Single Char'
+    return, -1
+endif
+;
+resu=-1
+;
+for ii=0, STRLEN(str)-1 do begin
+    sub_str=STRMID(str,ii,1)
+    if (sub_str EQ single_char) then resu=[resu,ii]
+endfor
+;
+if N_ELEMENTS(resu) GT 1 then resu=resu[1:*]
+;
+if KEYWORD_SET(test) then STOP
+;
+return, resu
+;
+end
+;
+; ----------------------------------------
+;
+function STRSPLIT, input1, input2 , $
+                   count=count, length=length, extract=extract, regex=regex, $
+                   escape=escape, fold_case=fold_case, preserve_null=preserve_null, $
+                   test=test, help=help
+;
+ON_ERROR, 2
+;
 
-function STRSPLIT, input1, input2, _ref_extra = extra, REGEX=regex
-
-on_error, 2
- 
-;if keyword_set( regex) then begin
-;    message,'REGEX keyword not implemented yet.'
-;endif
-
-if (SIZE(input1, /type) NE 7) then begin
-   MESSAGE, 'Invalid input string.'
+if KEYWORD_SET(help) then begin
+    print, 'function STRSPLIT, input1, input2, $'
+    print, '                   count=count, length=length, extract=extract, regex=regex, $'
+    print, '                   escape=escape, fold_case=fold_case, preserve_null=preserve_null, $'
+    print, '                   test=test, help=help'
+    return, -1
 endif
 ;
-if (SIZE(input1, /n_dimensions) GT 1) then begin
-   MESSAGE, 'Invalid input string.'
+if KEYWORD_SET(escape) then begin
+    MESSAGE, /continue, 'Sorry, this keyword ESCAPE is not implemented (no effect)'
+    MESSAGE, /continue, 'PLEASE CONTRIBUTE'
 endif
 ;
-local_input1=input1
+default=0
+if (not KEYWORD_SET(input2)) then begin
+    input2=' '
+    default=1
+endif
 ;
-if (SIZE(input1, /n_dimensions) EQ 1) then begin
-   local_input1=local_input1[0]
+if KEYWORD_SET(fold_case) then begin
+    MESSAGE, /continue, 'Sorry, this keyword /FOLD_CASE is not implemented (no effect)'
+    MESSAGE, /continue, 'PLEASE CONTRIBUTE'
 endif
 ;
-if (N_PARAMS() EQ 2) then begin
-   if (N_ELEMENTS(input2) EQ 0) then begin
-      MESSAGE, 'Undefined pattern string.'
-   endif
-   if KEYWORD_SET(regex) then begin
-      return, STRTOK(local_input1, input2, _extra = extra, REGEX=regex)
-   endif else begin
-      return, STRTOK(local_input1, input2, _extra = extra)
-   endelse
+if KEYWORD_SET(regex) and KEYWORD_SET(preserve_null) then begin
+    MESSAGE, /continue, 'Keywords /REGEX and /PRESERVE_NULL are incompatible, /PRESERVE_NULL is ignored' 
 endif
 ;
-if KEYWORD_SET(regex) then begin
-   return, STRTOK(local_input1, _extra = extra, REGEX=regex)
+;if (SIZE(input1, /n_dimensions) GT 1) then begin
+;    MESSAGE, 'Invalid input string.'
+;endif
+;
+if (SIZE(input1, /n_elements) GT 1) then begin
+    MESSAGE, '% STRTOK: Expression must be a scalar or 1 element array in this context: STRINGIN.'
+endif
+;
+if (SIZE(input1, /type) NE 7) then begin
+    local_input1=STRING(input1)
+    ;;MESSAGE, 'Invalid input string.'
+endif else begin
+    local_input1=input1
+endelse
+;
+if KEYWORD_SET(regex) then regex_flag=1 else regex_flag=0
+;
+if (N_PARAMS() EQ 2 or default) then begin
+    if (N_ELEMENTS(input2) EQ 0) then begin
+        MESSAGE, 'Undefined pattern string.'
+    endif
+    ;;
+    if KEYWORD_SET(regex) then begin
+        resu=STRTOK(local_input1, input2, extract=extract, REGEX=regex_flag)
+    endif else begin
+        resu=0
+	beg=0
+        ;;
+        for ii=0, STRLEN(input2)-1 do resu=[resu, STRMULTIPOS(local_input1, STRMID(input2, ii, 1))]
+        ;;
+        resu=resu[WHERE(resu GE 0)]
+	tst=resu[WHERE(resu EQ 0)]
+        resu=resu[UNIQ(resu,SORT(resu))]
+        ;;
+        if N_ELEMENTS(tst) EQ 2 then beg=1
+        ;;
+        if KEYWORD_SET(extract) then begin
+            if (beg eq 1) then resu=[0,resu]
+            if N_ELEMENTS(resu) EQ 1 then begin
+
+                if (beg eq 0) then begin 
+                    resu=local_input1
+                endif else begin
+                    resu=STRMID(local_input1, resu[0]+1)
+                endelse
+
+            endif else begin
+                
+                sresu=STRARR(N_ELEMENTS(resu))
+
+                if (beg eq 0) then begin 
+                    sresu[0]=STRMID(local_input1, 0, resu[1])
+                endif else begin
+                    sresu[0]=STRMID(local_input1, resu[0]+1, resu[1]-resu[0]-1)
+                endelse
+
+                for ii=1, N_ELEMENTS(resu)-2 do begin
+                    ;;print, resu[ii]+1,resu[ii+1]-resu[ii]-1                    
+                    sresu[ii]=STRMID(local_input1, resu[ii]+1,resu[ii+1]-resu[ii]-1)
+                endfor
+                sresu[N_ELEMENTS(resu)-1]=STRMID(local_input1, resu[N_ELEMENTS(resu)-1]+1)
+                ;stop
+                resu=sresu
+            endelse
+
+            if NOT(KEYWORD_SET(preserve_null)) then begin
+                ok=WHERE(STRLEN(resu) GT 0, nb_ok)
+                if (nb_ok GT 0) then resu=resu[ok] else resu=''
+            endif
+
+        endif else begin
+            if N_ELEMENTS(resu) GT 1 then resu[1:*]=resu[1:*]+1 else resu=0
+            if (beg EQ 1) then resu[0]=resu[0]+1 
+
+            if (KEYWORD_SET(preserve_null) and (N_ELEMENTS(resu) GT 1) and (resu[0] ne 0)) then resu=[0,resu]
+
+            if NOT(KEYWORD_SET(preserve_null)) then begin
+                refresu=resu
+                resu=-1
+
+                for ii=0, N_ELEMENTS(refresu)-2 do begin
+                    if ((refresu[ii+1]-refresu[ii]) ne 1) then resu=[resu,refresu[ii]]
+                endfor
+
+
+                if (refresu[N_ELEMENTS(refresu)-1] lt STRLEN(local_input1)) then resu=[resu,refresu[N_ELEMENTS(refresu)-1]]
+                if (N_ELEMENTS(resu) eq 1 ) then resu=0 else resu=resu[WHERE(resu GE 0)]
+            
+            endif
+        endelse
+    endelse
 endif else begin
-   return, STRTOK(local_input1, _extra = extra)
+    resu=STRTOK(local_input1, extract = extract, REGEX=regex_flag)
 endelse
 ;
+if KEYWORD_SET(count) then begin
+    if ((STRLEN(input1) EQ 0) OR (STRLEN(input2) EQ 0)) then begin
+        count=0
+    endif else begin
+        count=N_ELEMENTS(resu)
+    endelse
+endif
+;
+if KEYWORD_SET(length) then length=STRLEN(resu)
+;
+if KEYWORD_SET(test) then STOP
+;
+return, resu
+;
 end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/tvscl.pro cvs/gdl/src/pro/tvscl.pro
--- gdl-0.9rc4/src/pro/tvscl.pro	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/pro/tvscl.pro	2010-04-16 11:22:54.000000000 -0600
@@ -38,29 +38,42 @@
 ;	not yet implemented in MIN, MAX and BYTSCL.
 ;
 ; MODIFICATION HISTORY:
-;	Original: 14/3/05; SJT
+;     Original: 14/03/2005; SJT
+;     Modification: 14/04/2010; Alain Coulais: 
+;        -- better managment of inputs
+;        -- no use of "locs" if no /NaN !
+;
 ;-
- 
-pro tvscl, image, x, y, nan = nan, _extra = _extra
-
-on_error, 2                     ; Return to caller on error.
-
-if keyword_set(nan) then begin
-    locs = where(finite(image), nf)
-    if nf eq 0 then message, "No finite values found in image"
-endif else locs = lindgen(n_elements(image))
-
-dmin = min(image[locs], max = dmax)
+pro TVSCL, image, x, y, nan = nan, _extra = _extra
+;
+ON_ERROR, 2                     ; Return to caller on error.
+;
+if N_PARAMS() EQ 0 then begin
+   MESSAGE, 'Incorrect number of arguments.'
+   return
+endif
+if (SIZE(image,/n_elements) EQ 0) then begin
+   MESSAGE, ' Expression must be an array in this context'
+   return
+endif
+;
+if KEYWORD_SET(nan) then begin
+    locs = WHERE(FINITE(image), nf)
+    if (nf EQ 0) then MESSAGE, "No finite values found in image"
+    dmin = MIN(image[locs], max = dmax)
+endif else begin
+   dmin = MIN(image, max = dmax)
+endelse
 
 if !d.table_size eq 0 then imax = !d.n_colors-1 $
 else imax = !d.table_size-1
 
-img = bytscl(image, min = dmin, max = dmax, top = imax)
+img = BYTSCL(image, min = dmin, max = dmax, top = imax)
 
-case n_params() of
-    1: tv, img, _extra = _extra
-    2: tv, img, x, _extra = _extra
-    3: tv, img, x, y, _extra = _extra
+case N_PARAMS() of
+    1: TV, img, _extra = _extra
+    2: TV, img, x, _extra = _extra
+    3: TV, img, x, y, _extra = _extra
 endcase
 
 end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pro/UrgentNeed.txt cvs/gdl/src/pro/UrgentNeed.txt
--- gdl-0.9rc4/src/pro/UrgentNeed.txt	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/pro/UrgentNeed.txt	2010-04-16 11:22:54.000000000 -0600
@@ -37,7 +37,6 @@
 !h_eq_ct.pro
 !h_eq_int.pro
 !hilbert.pro
-!hist_2d.pro
 !hist_equal.pro
 !ibeta.pro
 !int_2d.pro
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/prognode.cpp cvs/gdl/src/prognode.cpp
--- gdl-0.9rc4/src/prognode.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/prognode.cpp	2010-05-21 10:23:58.598904426 -0600
@@ -27,6 +27,70 @@
 
 using namespace std;
 
+/////////////////////////////////////////////////////////////////////////////
+// c-tor d-tor
+/////////////////////////////////////////////////////////////////////////////
+
+// tanslation RefDNode -> ProgNode
+ProgNode::ProgNode( const RefDNode& refNode):
+	keepRight( false),
+	keepDown( false),
+	breakTarget( NULL),
+  ttype( refNode->getType()),
+  text( refNode->getText()),
+  down( NULL), 
+  right( NULL),
+  lineNumber( refNode->getLine()),
+  cData( refNode->StealCData()),
+  libPro( refNode->libPro),
+  libFun( refNode->libFun),
+  var( refNode->var),
+  arrIxList( refNode->StealArrIxList()),
+//   arrIxList( refNode->CloneArrIxList()),
+  labelStart( refNode->labelStart),
+  labelEnd( refNode->labelEnd)
+{
+  initInt = refNode->initInt;
+}
+
+
+
+ProgNode::~ProgNode()
+{
+  // delete cData in case this node is a constant
+  if( (getType() == GDLTokenTypes::CONSTANT))
+     {
+      delete cData;
+     }
+  if( (getType() == GDLTokenTypes::ARRAYIX))
+    {
+      delete arrIxList;
+    }
+  if( !keepDown) delete down;
+  if( !keepRight) delete right;
+}
+
+
+
+ProgNodeP ProgNode::GetNULLProgNodeP()
+  {
+	return interpreter->GetNULLProgNodeP();
+  }
+
+
+void FORNode::KeepRight( ProgNodeP r)
+{
+	throw GDLException( "Internal error: FORNode::KeepRight() called. Please report.");
+}
+void FOR_STEPNode::KeepRight( ProgNodeP r)
+{
+	throw GDLException( "Internal error: FOR_STEPNode::KeepRight() called. Please report.");
+}
+void FOREACHNode::KeepRight( ProgNodeP r)
+{
+	throw GDLException( "Internal error: FOREACHNode::KeepRight() called. Please report.");
+}
+
 bool ProgNode::ConstantNode()
   {
     if( this->getType() == GDLTokenTypes::SYSVAR)
@@ -36,12 +100,15 @@
        SizeT rdOnlySize = sysVarRdOnlyList.size();
          for( SizeT i=0; i<rdOnlySize; ++i)
                   if( sysVarRdOnlyList[ i] == this->var)
-		    return true;
+					return true;
       }
 
     return this->getType() == GDLTokenTypes::CONSTANT;
   }
 
+/////////////////////////////////////////////////////////
+// Eval 
+/////////////////////////////////////////////////////////
 BaseGDL* ARRAYDEFNode::Eval()
 {
   // GDLInterpreter::
@@ -67,7 +134,7 @@
     if( ty == UNDEF)
       {
 	throw GDLException( _t, "Variable is undefined: "+
-			    ProgNode::interpreter->Name(e));
+			    ProgNode::interpreter->Name(e),true,false);
       }
     if( cType == UNDEF) 
       {
@@ -82,7 +149,7 @@
 	      {
 		throw 
 		  GDLException( _t, e->TypeStr()+
-				" is not allowed in this context.");
+				" is not allowed in this context.",true,false);
 	      }
 			
 	    // update order if larger type (or types are equal)
@@ -111,7 +178,7 @@
 		if( (*newS) != (*oldS))
 		  throw GDLException( _t, 
 				      "Conflicting data structures: "+
-				      ProgNode::interpreter->Name(cTypeData)+", "+ProgNode::interpreter->Name(e));
+				      ProgNode::interpreter->Name(cTypeData)+", "+ProgNode::interpreter->Name(e),true,false);
 	      }
 	  }
       }
@@ -128,6 +195,8 @@
   return res;
 }
 
+
+
 BaseGDL* STRUCNode::Eval()
 {
   // don't forget the struct in extrat.cpp if you change something here
@@ -162,6 +231,8 @@
   return res;
 }
 
+
+
 BaseGDL* NSTRUCNode::Eval()
 {
   ProgNodeP id = NULL;
@@ -410,7 +481,7 @@
   // 			match(antlr::RefAST(_t),IDENTIFIER);
 //   _t = _t->getNextSibling();
   BaseGDL* kval=ProgNode::interpreter->
-    check_expr(this->getFirstChild()->getNextSibling());
+    lib_function_call(this->getFirstChild()->getNextSibling());
 			
   BaseGDL** kvalRef = ProgNode::interpreter->callStack.back()->GetPtrTo( kval);
   if( kvalRef != NULL)
@@ -426,7 +497,7 @@
 }
 void REF_CHECKNode::Parameter( EnvBaseT* actEnv)
 {
-  BaseGDL* pval=ProgNode::interpreter->check_expr(this->getFirstChild());
+  BaseGDL* pval=ProgNode::interpreter->lib_function_call(this->getFirstChild());
 			
   BaseGDL** pvalRef = ProgNode::interpreter->callStack.back()->GetPtrTo( pval);
   if( pvalRef != NULL)
@@ -453,7 +524,7 @@
 
 
 
-void ASSIGNNode::Run()
+RetCode  ASSIGNNode::Run()
 {
   BaseGDL*  r;
   BaseGDL** l;
@@ -475,7 +546,7 @@
       }
     case GDLTokenTypes::FCALL_LIB:
       {
-	r=ProgNode::interpreter->check_expr(_t);
+	r=ProgNode::interpreter->lib_function_call(_t);
 	_t = ProgNode::interpreter->_retTree;
 			
 	if( !ProgNode::interpreter->callStack.back()->Contains( r)) 
@@ -495,9 +566,13 @@
   l=ProgNode::interpreter->l_expr(_t, r);
 
   ProgNode::interpreter->_retTree = this->getNextSibling();
+
+  return RC_OK;
 }
 
-void ASSIGN_REPLACENode::Run()
+
+
+RetCode  ASSIGN_ARRAYEXPR_MFCALLNode::Run()
 {
   BaseGDL*  r;
   BaseGDL** l;
@@ -506,27 +581,111 @@
   //match(antlr::RefAST(_t),ASSIGN_REPLACE);
   ProgNodeP _t = this->getFirstChild();
   {
+    // BOTH
     if( _t->getType() ==  GDLTokenTypes::FCALL_LIB)
       {
-	r=ProgNode::interpreter->check_expr(_t);
+		r=ProgNode::interpreter->lib_function_call(_t);
 
-	if( r == NULL) // ROUTINE_NAMES
-		ProgNode::interpreter->callStack.back()->Throw( "Undefined return value");
+		if( r == NULL) // ROUTINE_NAMES
+			ProgNode::interpreter->callStack.back()->Throw( "Undefined return value");
 	
-	_t = ProgNode::interpreter->_retTree;
-			
-			
-	if( !ProgNode::interpreter->callStack.back()->Contains( r)) 
-	  r_guard.reset( r);
+		_t = ProgNode::interpreter->_retTree;
+		
+		if( !ProgNode::interpreter->callStack.back()->Contains( r)) 
+			r_guard.reset( r);
 			
       }
     else
       {
-	r=ProgNode::interpreter->tmp_expr(_t);
-	_t = ProgNode::interpreter->_retTree;
-			
-	r_guard.reset( r);
-			
+			// ASSIGN
+			switch ( _t->getType()) {
+				case GDLTokenTypes::CONSTANT:
+				case GDLTokenTypes::DEREF:
+				case GDLTokenTypes::SYSVAR:
+				case GDLTokenTypes:: VAR:
+				case GDLTokenTypes::VARPTR:
+				{
+				r= ProgNode::interpreter->indexable_expr(_t);
+				_t = ProgNode::interpreter->_retTree;
+				break;
+				}
+				default:
+				{
+				r=ProgNode::interpreter->indexable_tmp_expr(_t);
+				_t = ProgNode::interpreter->_retTree;
+				r_guard.reset( r);
+				break;
+			}
+			}//switch
+		}
+  }
+
+	ProgNodeP lExpr = _t;
+    
+	// try MFCALL
+	try
+    {
+    l=ProgNode::interpreter->l_arrayexpr_mfcall_as_mfcall(_t);
+    
+	if( r != (*l))
+		{
+		delete *l;
+
+		if( r_guard.get() == r)
+		*l = r_guard.release();
+		else
+		*l = r->Dup();
+		}
+    }
+    catch( GDLException& e)
+    {
+		// try ARRAYEXPR
+		try
+		{
+			l=ProgNode::interpreter->l_arrayexpr_mfcall_as_arrayexpr(lExpr, r);
+		}
+		catch( GDLException& e2)
+		{
+			throw GDLException(e.toString() + " or "+e2.toString());
+		}
+    }
+
+  ProgNode::interpreter->_retTree = this->getNextSibling();
+  return RC_OK;
+}
+
+
+
+RetCode  ASSIGN_REPLACENode::Run()
+{
+  BaseGDL*  r;
+  BaseGDL** l;
+  auto_ptr<BaseGDL> r_guard;
+
+  //match(antlr::RefAST(_t),ASSIGN_REPLACE);
+  ProgNodeP _t = this->getFirstChild();
+  {
+    if( _t->getType() ==  GDLTokenTypes::FCALL_LIB)
+      {
+		r=_t->Eval();//ProgNode::interpreter->lib_function_call(_t);
+		r_guard.reset( r);
+
+		if( r == NULL) // ROUTINE_NAMES
+			throw GDLException( this, "Undefined return value", true, false);
+		
+		_t = ProgNode::interpreter->_retTree;
+		
+/*		if( !ProgNode::interpreter->callStack.back()->Contains( r))
+			r_guard.reset( r);
+		else
+			r_guard.reset( r->Dup());*/
+      }
+    else
+      {
+			r=ProgNode::interpreter->tmp_expr(_t);
+			_t = ProgNode::interpreter->_retTree;
+					
+			r_guard.reset( r);
       }
   }
 
@@ -555,21 +714,22 @@
       break;
     }
   }
-		
-  if( r != (*l))
-    {
-      delete *l;
-		
-      if( r_guard.get() == r)
+//  if( r != (*l))
+//     {
+    delete *l;
+//      if( r_guard.get() == r)
 	*l = r_guard.release();
-      else  
-	*l = r->Dup();
-    }
+//       else
+// 	*l = r->Dup();
+//     }
 
-  ProgNode::interpreter->_retTree = this->getNextSibling();
+  ProgNode::interpreter->SetRetTree( this->getNextSibling());
+  return RC_OK;
 }
 
-void PCALL_LIBNode::Run()
+
+
+RetCode  PCALL_LIBNode::Run()
 {
   // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
   StackGuard<EnvStackT> guard( ProgNode::interpreter->CallStack());
@@ -595,8 +755,12 @@
 
   ProgNode::interpreter->SetRetTree( this->getNextSibling());
   //  ProgNode::interpreter->_retTree = this->getNextSibling();
+  return RC_OK;
 }
-void MPCALLNode::Run()
+
+
+
+RetCode  MPCALLNode::Run()
 {
   // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
   StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
@@ -628,15 +792,17 @@
   ProgNode::interpreter->call_pro(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
 
   ProgNode::interpreter->SetRetTree( this->getNextSibling());
+  return RC_OK;
 }
 
-void MPCALL_PARENTNode::Run()
+
+
+RetCode  MPCALL_PARENTNode::Run()
 {
   // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
   StackGuard<EnvStackT> guard(ProgNode::interpreter->callStack);
   BaseGDL *self;
   EnvUDT*   newEnv;
-	
 
   // 			match(antlr::RefAST(_t),MPCALL_PARENT);
   ProgNodeP _t = this->getFirstChild();
@@ -667,8 +833,9 @@
 
   ProgNode::interpreter->SetRetTree( this->getNextSibling());
   //  ProgNode::interpreter->_retTree = this->getNextSibling();
+  return RC_OK;
 }
-void PCALLNode::Run()
+RetCode  PCALLNode::Run()
 {
   // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
   StackGuard<EnvStackT> guard(ProgNode::interpreter->callStack);
@@ -696,172 +863,606 @@
 
   ProgNode::interpreter->SetRetTree( this->getNextSibling());
   //  ProgNode::interpreter->_retTree = this->getNextSibling();
+  return RC_OK;
 }
-void DECNode::Run()
+
+
+
+RetCode  DECNode::Run()
 {
   //		match(antlr::RefAST(_t),DEC);
   ProgNodeP _t = this->getFirstChild();
   ProgNode::interpreter->l_decinc_expr(_t, GDLTokenTypes::DECSTATEMENT);
 
   ProgNode::interpreter->SetRetTree( this->getNextSibling());
+  return RC_OK;
 }
-void INCNode::Run()
+
+
+
+RetCode  INCNode::Run()
 {
   //		match(antlr::RefAST(_t),INC);
   ProgNodeP _t = this->getFirstChild();
   ProgNode::interpreter->l_decinc_expr(_t, GDLTokenTypes::INCSTATEMENT);
 
   ProgNode::interpreter->SetRetTree( this->getNextSibling());
+  return RC_OK;
 }
 
-
-// void FOR_INIT_Node::Run()
-// {
-//   BaseGDL* s;
-//   BaseGDL* e;
-//   BaseGDL* st;
-//   GDLInterpreter::RetCode retCode = RC_OK;
+RetCode   FORNode::Run()//for_statement(ProgNodeP _t) {
+{
+		EnvUDT* callStack_back = 	static_cast<EnvUDT*>(GDLInterpreter::CallStack().back());
+		
+		ForLoopInfoT& loopInfo = callStack_back->GetForLoopInfo( this->forLoopIx);
 	
-//   //match(antlr::RefAST(_t),FOR);
-//   ProgNodeP _t = this->getFirstChild();
+		ProgNodeP vP = this->GetNextSibling()->GetFirstChild();
 		
-//   ProgNodeP sv = _t;
+		BaseGDL** v=ProgNode::interpreter->l_simple_var(vP);
 		
-//   BaseGDL** v=l_simple_var(_t);
-//   _t = _retTree;
-//   s=expr(_t);
-//   _t = _retTree;
-//   e=expr(_t);
-//   _t = _retTree;
-		
-//   auto_ptr<BaseGDL> s_guard(s);
-//   auto_ptr<BaseGDL> e_guard(e);
-		
-//   s->ForCheck( &e);
-//   e_guard.release();
-//   e_guard.reset(e);
-		
-//   ProgNodeP b= _t;
-		
-//   // ASSIGNMENT used here also
-//   delete (*v);
-		
-//   // problem:
-//   // EXECUTE may call DataListT.loc.resize(), as v points to the
-//   // old sequence v might be invalidated -> segfault
-//   // note that the value (*v) is preserved by resize()
-//   s_guard.release(); // s held in *v after this
-
-
-//   (*v)=s;  
-//   SetReturnCode( RC_OK);
-// }
-
-// void ENDFORNode::Run()
-// {
-//   v=l_simple_var( sv);
-//   (*v)->ForAdd();
-//   ProgNode::interpreter->SetRetTree( target);
-// }
-// void ENDFOR_STEPNode::Run()
-// {
-//   v=l_simple_var( sv); 
-//   (*v)->ForAdd(st))
-//   ProgNode::interpreter->SetRetTree( target);
-// }
-
-// void FORNode::Run()
-// {
-//   if( ProgNode::interpreter->returnCode != RC_OK)
-//     {
-//     if( retCode == RC_CONTINUE) continue;  
-//     if( retCode == RC_BREAK) 
-//       {
-// 	retCode = RC_OK;
-// 	break;        
-//       }
-//     if( retCode >= RC_RETURN) break;
-//     }
-
-//  if( (*v)->ForCondUp( e))
-//     {
-//       ProgNode::interpreter->SetRetTree( b);
-//     }
-//  else
-//     {
-//       ProgNode::interpreter->SetRetTree( this->getNextSibling());
-//     }
-// }
-
-// void FOR_STEP_INITNode::Run()
-// {
-//   BaseGDL* s;
-//   BaseGDL* e;
-//   BaseGDL* st;
-// //   match(antlr::RefAST(_t),FOR_STEP);
-//   ProgNodeP _t = this->getFirstChild();
+		BaseGDL* s=ProgNode::interpreter->expr( this->GetFirstChild());
+		auto_ptr<BaseGDL> s_guard(s);
 		
-//   ProgNodeP sv = _t;
+		delete loopInfo.endLoopVar;
+		loopInfo.endLoopVar=ProgNode::interpreter->expr(this->GetFirstChild()->GetNextSibling());
 		
-//   v=l_simple_var(_t);
-//   _t = _retTree;
-//   s=expr(_t);
-//   _t = _retTree;
-//   e=expr(_t);
-//   _t = _retTree;
-//   st=expr(_t);
-//   _t = _retTree;
-		
-//   auto_ptr<BaseGDL> s_guard(s);
-//   auto_ptr<BaseGDL> e_guard(e);
-//   auto_ptr<BaseGDL> st_guard(st);
-		
-//   SizeT nJump = static_cast<EnvUDT*>(callStack.back())->NJump();
-		
-//   s->ForCheck( &e, &st);
-//   e_guard.release();
-//   e_guard.reset(e);
-//   st_guard.release();
-//   st_guard.reset(st);
-		
-//   ProgNodeP bs=_t;
-		
-//   // ASSIGNMENT used here also
-//   delete (*v);
-// }
-// void FOR_STEPNode::Run()
-// {
-//   if( ProgNode::interpreter->returnCode != RC_OK)
-//     {
-//     if( retCode == RC_CONTINUE) continue;  
-//     if( retCode == RC_BREAK) 
-//       {
-// 	retCode = RC_OK;
-// 	break;        
-//       }
-//     if( retCode >= RC_RETURN) break;
-//     }
+		s->ForCheck( &loopInfo.endLoopVar);
+		
+		// ASSIGNMENT used here also
+		delete (*v);
+		(*v)= s_guard.release(); // s held in *v after this
+		
+		if( (*v)->ForCondUp( loopInfo.endLoopVar))
+		{
+			ProgNode::interpreter->_retTree = vP->GetNextSibling();
+			return RC_OK;
+		}
+		else
+		{
+			// skip if initial test fails
+			ProgNode::interpreter->_retTree = this->GetNextSibling()->GetNextSibling();
+			return RC_OK;
+		}
+}
+
+
+	RetCode   FOR_LOOPNode::Run()
+	{
+		EnvUDT* callStack_back = 	static_cast<EnvUDT*>(GDLInterpreter::CallStack().back());
+ 		ForLoopInfoT& loopInfo = 	callStack_back->GetForLoopInfo( this->forLoopIx);
+		BaseGDL* endLoopVar = 	loopInfo.endLoopVar;
+		if( endLoopVar == NULL)
+		{
+			// non-initialized loop (GOTO)
+			ProgNode::interpreter->_retTree = this->GetNextSibling();
+			return RC_OK;
+
+		}
+
+		// // problem:
+		// // EXECUTE may call DataListT.loc.resize(), as v points to the
+		// // old sequence v might be invalidated -> segfault
+		// // note that the value (*v) is preserved by resize()
+		
+		BaseGDL** v=this->getFirstChild()->LEval();//ProgNode::interpreter->l_simple_var(this->getFirstChild());
+
+// shortCut:;
+		
+		//(*v)->ForAdd();
+		if( (*v)->ForAddCondUp( endLoopVar))
+		{
+			ProgNode::interpreter->_retTree = this->statementList; //GetFirstChild()->GetNextSibling();
+// 			if( ProgNode::interpreter->_retTree == this) goto shortCut;
+		}
+		else
+		{
+			delete loopInfo.endLoopVar;
+			loopInfo.endLoopVar = NULL;
+			ProgNode::interpreter->_retTree = this->GetNextSibling();
+		}
+		return RC_OK;
+	}
+
+	
+ RetCode   FOR_STEPNode::Run()//for_statement(ProgNodeP _t) {
+{
+	EnvUDT* callStack_back = 	static_cast<EnvUDT*>(GDLInterpreter::CallStack().back());
+
+	ForLoopInfoT& loopInfo = callStack_back->GetForLoopInfo( this->forLoopIx);
+
+	ProgNodeP vP = this->GetNextSibling()->GetFirstChild();
+
+	BaseGDL** v=ProgNode::interpreter->l_simple_var(vP);
+
+	BaseGDL* s=ProgNode::interpreter->expr( this->GetFirstChild());
+	auto_ptr<BaseGDL> s_guard(s);
+
+	delete loopInfo.endLoopVar;
+	loopInfo.endLoopVar=ProgNode::interpreter->expr(this->GetFirstChild()->GetNextSibling());
+
+	delete loopInfo.loopStepVar;
+	loopInfo.loopStepVar=ProgNode::interpreter->expr(this->GetFirstChild()->GetNextSibling()->GetNextSibling());
+
+	s->ForCheck( &loopInfo.endLoopVar, &loopInfo.loopStepVar);
+
+	// ASSIGNMENT used here also
+	delete (*v);
+	(*v)= s_guard.release(); // s held in *v after this
+
+	if( loopInfo.loopStepVar->Sgn() == -1)
+	{
+		if( (*v)->ForCondDown( loopInfo.endLoopVar))
+		{
+			ProgNode::interpreter->_retTree = vP->GetNextSibling();
+  return RC_OK;
+
+		}
+	}
+	else
+	{
+		if( (*v)->ForCondUp( loopInfo.endLoopVar))
+		{
+			ProgNode::interpreter->_retTree = vP->GetNextSibling();
+  return RC_OK;
+
+		}
+	}
+	// skip if initial test fails
+	ProgNode::interpreter->_retTree = this->GetNextSibling()->GetNextSibling();
+  return RC_OK;
+}
+	
+RetCode   FOR_STEP_LOOPNode::Run()
+{
+	EnvUDT* callStack_back = 	static_cast<EnvUDT*>(GDLInterpreter::CallStack().back());
+	
+	ForLoopInfoT& loopInfo = 	callStack_back->GetForLoopInfo( this->forLoopIx);
+	if( loopInfo.endLoopVar == NULL)
+	{
+		// non-initialized loop (GOTO)
+		ProgNode::interpreter->_retTree = this->GetNextSibling();
+        return RC_OK;
+	}
+
+	// // problem:
+	// // EXECUTE may call DataListT.loc.resize(), as v points to the
+	// // old sequence v might be invalidated -> segfault
+	// // note that the value (*v) is preserved by resize()
+
+	BaseGDL** v=ProgNode::interpreter->l_simple_var(this->GetFirstChild());
+
+	(*v)->ForAdd(loopInfo.loopStepVar);
+	if( loopInfo.loopStepVar->Sgn() == -1)
+	{
+		if( (*v)->ForCondDown( loopInfo.endLoopVar))
+		{
+			ProgNode::interpreter->_retTree = this->GetFirstChild()->GetNextSibling();
+  return RC_OK;
+		}
+	}
+	else
+	{
+		if( (*v)->ForCondUp( loopInfo.endLoopVar))
+		{
+			ProgNode::interpreter->_retTree = this->GetFirstChild()->GetNextSibling();
+  return RC_OK;
+		}
+	}
+	
+	delete loopInfo.endLoopVar;
+	loopInfo.endLoopVar = NULL;
+	delete loopInfo.loopStepVar;
+	loopInfo.loopStepVar = NULL;
+	ProgNode::interpreter->_retTree = this->GetNextSibling();
+	return RC_OK;
+}
+
+RetCode   FOREACHNode::Run()
+{
+	EnvUDT* callStack_back = 	static_cast<EnvUDT*>(GDLInterpreter::CallStack().back());
+	ForLoopInfoT& loopInfo = callStack_back->GetForLoopInfo( this->forLoopIx);
+
+	ProgNodeP vP = this->GetNextSibling()->GetFirstChild();
+
+	BaseGDL** v=ProgNode::interpreter->l_simple_var(vP);
+
+	delete loopInfo.endLoopVar;
+	loopInfo.endLoopVar=ProgNode::interpreter->expr(this->GetFirstChild());
+
+	loopInfo.foreachIx = 0;
+
+	// currently there are no empty arrays
+	//SizeT nEl = loopInfo.endLoopVar->N_Elements();
+
+	// ASSIGNMENT used here also
+	delete (*v);
+	(*v) = loopInfo.endLoopVar->NewIx( 0);
+
+	ProgNode::interpreter->_retTree = vP->GetNextSibling();
+	return RC_OK;
+}
+	
+RetCode   FOREACH_LOOPNode::Run()
+{
+	EnvUDT* callStack_back = 	static_cast<EnvUDT*>(GDLInterpreter::CallStack().back());
+	ForLoopInfoT& loopInfo = callStack_back->GetForLoopInfo( this->forLoopIx);
+
+	if( loopInfo.endLoopVar == NULL)
+	{
+	// non-initialized loop (GOTO)
+	ProgNode::interpreter->_retTree = this->GetNextSibling();
+  return RC_OK;
+	}
+
+	BaseGDL** v=ProgNode::interpreter->l_simple_var(this->GetFirstChild());
+	
+	++loopInfo.foreachIx;
+
+	SizeT nEl = loopInfo.endLoopVar->N_Elements();
+
+	if( loopInfo.foreachIx < nEl)
+	{
+		// ASSIGNMENT used here also
+		delete (*v);
+		(*v) = loopInfo.endLoopVar->NewIx( loopInfo.foreachIx);
+
+		ProgNode::interpreter->_retTree = this->GetFirstChild()->GetNextSibling();
+  return RC_OK;
+	}
+
+	delete loopInfo.endLoopVar;
+	loopInfo.endLoopVar = NULL;
+	// 	loopInfo.foreachIx = -1;
+	ProgNode::interpreter->SetRetTree( this->GetNextSibling());
+  return RC_OK;
+}
+
+
+
+RetCode   REPEATNode::Run()
+{
+	// _t is REPEAT_LOOP, GetFirstChild() is expr, GetNextSibling is first loop statement
+	if( this->GetFirstChild()->GetFirstChild()->GetNextSibling() == NULL)
+		ProgNode::interpreter->SetRetTree( this->GetFirstChild());
+	else	
+		ProgNode::interpreter->SetRetTree( this->GetFirstChild()->GetFirstChild()->GetNextSibling());     // statement
+  return RC_OK;
+}
+
+
+
+RetCode   REPEAT_LOOPNode::Run()
+{
+	auto_ptr<BaseGDL> eVal( ProgNode::interpreter->expr(this->GetFirstChild()));
+	if( eVal.get()->False())
+	{
+	ProgNode::interpreter->SetRetTree( this->GetFirstChild()->GetNextSibling());     // 1st loop statement
+	if(  this->GetFirstChild()->GetNextSibling() == NULL)
+		throw GDLException(this,	"Empty REPEAT loop entered (infinite loop).",true,false);
+  return RC_OK;
+	}
+	
+	ProgNode::interpreter->SetRetTree( this->GetNextSibling());     // statement
+  return RC_OK;
+}
+
+
+
+RetCode   WHILENode::Run()
+{
+  auto_ptr<BaseGDL> e1_guard;
+  BaseGDL* e1;
+  ProgNodeP evalExpr = this->getFirstChild();
+  if( NonCopyNode( evalExpr->getType()))
+  {
+	e1 = evalExpr->EvalNC();
+  }
+  else
+  {
+	e1 = evalExpr->Eval();
+    e1_guard.reset(e1);
+  }
+// 	auto_ptr<BaseGDL> eVal( ProgNode::interpreter->expr( this->GetFirstChild()));
+	if( e1->True()) 
+	{
+		ProgNode::interpreter->SetRetTree( this->GetFirstChild()->GetNextSibling());
+		if( this->GetFirstChild()->GetNextSibling() == NULL)
+			throw GDLException(this,"Empty WHILE loop entered (infinite loop).",true,false);
+	}
+	else
+	{
+		ProgNode::interpreter->SetRetTree( this->GetNextSibling());
+	}
+  return RC_OK;
+}
+
+
+
+RetCode   IFNode::Run()
+ {
+  auto_ptr<BaseGDL> e1_guard;
+  BaseGDL* e1;
+  ProgNodeP evalExpr = this->getFirstChild();
+  if( NonCopyNode( evalExpr->getType()))
+  {
+	e1 = evalExpr->EvalNC();
+  }
+  else
+  {
+	e1 = evalExpr->Eval();
+    e1_guard.reset(e1);
+  }
+//	auto_ptr<BaseGDL> eVal( ProgNode::interpreter->expr( this->GetFirstChild()));
+	if( e1->True()) 
+	{
+		ProgNode::interpreter->SetRetTree( this->GetFirstChild()->GetNextSibling());
+	}
+	else
+	{
+		ProgNode::interpreter->SetRetTree( this->GetNextSibling());
+	}
+  return RC_OK;
+}
+
+RetCode   IF_ELSENode::Run()
+{	
+  auto_ptr<BaseGDL> e1_guard;
+  BaseGDL* e1;
+  ProgNodeP evalExpr = this->getFirstChild();
+  if( NonCopyNode( evalExpr->getType()))
+  {
+	e1 = evalExpr->EvalNC();
+  }
+  else
+  {
+	e1 = evalExpr->Eval();
+    e1_guard.reset(e1);
+  }
+// 	auto_ptr<BaseGDL> eVal( ProgNode::interpreter->expr( this->GetFirstChild()));
+	if( e1->True()) 
+	{
+		ProgNode::interpreter->SetRetTree( this->GetFirstChild()->GetNextSibling()->GetFirstChild());
+	}
+	else
+	{
+		ProgNode::interpreter->SetRetTree( this->GetFirstChild()->GetNextSibling()->GetNextSibling());
+	}
+  return RC_OK;
+}
+
+
+
+RetCode   CASENode::Run()
+{
+  auto_ptr<BaseGDL> e1_guard;
+  BaseGDL* e1;
+  ProgNodeP evalExpr = this->getFirstChild();
+  if( NonCopyNode( evalExpr->getType()))
+  {
+	e1 = evalExpr->EvalNC();
+  }
+  else
+  {
+	e1 = evalExpr->Eval();
+    e1_guard.reset(e1);
+  }
+
+// 	auto_ptr<BaseGDL> eVal( ProgNode::interpreter->expr( this->GetFirstChild()));
+  	if( !e1->Scalar())
+		throw GDLException( this->GetFirstChild(), "Expression must be a"
+			" scalar in this context: "+ProgNode::interpreter->Name(e1),true,false);
+
+	ProgNodeP b=this->GetFirstChild()->GetNextSibling(); // remeber block begin
+ 
+	for( int i=0; i<this->numBranch; ++i)
+	{
+		if( b->getType() == GDLTokenTypes::ELSEBLK)
+		{
+			ProgNodeP sL = b->GetFirstChild(); // statement_list
+		
+			if(sL != NULL )
+			{
+				ProgNode::interpreter->SetRetTree( sL);
+			}
+			else
+			{
+				ProgNode::interpreter->SetRetTree( this->GetNextSibling());
+			}
+			return RC_OK;
+		}
+		else
+		{
+			ProgNodeP ex = b->GetFirstChild();  // EXPR
+							
+			auto_ptr<BaseGDL> ee_guard;
+			BaseGDL* ee;
+			if( NonCopyNode( ex->getType()))
+				{
+					ee = ex->EvalNC();
+				}
+			else
+				{
+					ee = ex->Eval();
+					ee_guard.reset(ee);
+				}
+// 			BaseGDL* ee=ProgNode::interpreter->expr(ex);
+			// auto_ptr<BaseGDL> ee_guard(ee);
+			bool equalexpr=e1->EqualNoDelete(ee); // Equal deletes ee
+		
+			if( equalexpr)
+			{
+				ProgNodeP bb = ex->GetNextSibling(); // statement_list
+				if(bb != NULL )
+				{
+					ProgNode::interpreter->SetRetTree( bb);
+					return RC_OK;
+				}
+				else
+				{
+					ProgNode::interpreter->SetRetTree( this->GetNextSibling());
+					return RC_OK;
+				}
+			}
+		}
+		b=b->GetNextSibling(); // next block
+	} // for
+	
+	throw GDLException( this, "CASE statement found no match.",true,false);
+	return RC_OK;
+}
+
+
+
+RetCode   SWITCHNode::Run()
+{
+  auto_ptr<BaseGDL> e1_guard;
+  BaseGDL* e1;
+  ProgNodeP evalExpr = this->getFirstChild();
+  if( NonCopyNode( evalExpr->getType()))
+  {
+	e1 = evalExpr->EvalNC();
+  }
+  else
+  {
+	e1 = evalExpr->Eval();
+    e1_guard.reset(e1);
+  }
+
+// 	auto_ptr<BaseGDL> eVal( ProgNode::interpreter->expr( this->GetFirstChild()));
+ 	if( !e1->Scalar())
+	throw GDLException( this->GetFirstChild(), "Expression must be a"
+	" scalar in this context: "+ProgNode::interpreter->Name(e1),true,false);
+
+	ProgNodeP b=this->GetFirstChild()->GetNextSibling(); // remeber block begin
+	
+	bool hook=false; // switch executes everything after 1st match
+	for( int i=0; i<this->numBranch; i++)
+	{
+		if( b->getType() == GDLTokenTypes::ELSEBLK)
+			{
+				hook=true;
+				
+				ProgNodeP sL = b->GetFirstChild(); // statement_list
+				
+				if(sL != NULL )
+				{
+					ProgNode::interpreter->SetRetTree( sL);
+					return RC_OK;
+				}
+			}
+		else
+			{
+				ProgNodeP ex = b->GetFirstChild();  // EXPR
+				
+				if( !hook)
+				{
+					auto_ptr<BaseGDL> ee_guard;
+					BaseGDL* ee;
+					if( NonCopyNode( ex->getType()))
+					{
+						ee = ex->EvalNC();
+					}
+					else
+					{
+						ee = ex->Eval();
+						ee_guard.reset(ee);
+					}
+// 					BaseGDL* ee=ProgNode::interpreter->expr(ex);
+					// auto_ptr<BaseGDL> ee_guard(ee);
+					hook=e1->EqualNoDelete(ee); // Equal deletes ee
+				}
+				
+				if( hook)
+				{
+					ProgNodeP bb = ex->GetNextSibling(); // statement_list
+					// statement there
+					if(bb != NULL )
+					{
+						ProgNode::interpreter->SetRetTree( bb);
+						return RC_OK;
+					}
+				}
+			}
+		b=b->GetNextSibling(); // next block
+	} // for
+	ProgNode::interpreter->SetRetTree( this->GetNextSibling());
+	return RC_OK;
+}
+
+RetCode   BLOCKNode::Run()
+{
+	ProgNode::interpreter->SetRetTree( this->getFirstChild());
+  return RC_OK;
+}
+
+RetCode      GOTONode::Run()
+	{
+		ProgNode::interpreter->SetRetTree( static_cast<EnvUDT*>(GDLInterpreter::CallStack().back())->
+			GotoTarget( targetIx)->GetNextSibling());
+  return RC_OK;
+	}
+RetCode      CONTINUENode::Run()
+{
+assert( this->breakTarget != NULL); ProgNode::interpreter->SetRetTree( this->breakTarget);
+  return RC_OK;
+}
+RetCode      BREAKNode::Run()
+{
+ProgNode::interpreter->SetRetTree( this->breakTarget);
+  return RC_OK;
+}
+RetCode      LABELNode::Run()
+{
+ ProgNode::interpreter->SetRetTree( this->GetNextSibling());
+   return RC_OK;
+}
+RetCode      ON_IOERROR_NULLNode::Run()
+{
+	static_cast<EnvUDT*>(GDLInterpreter::CallStack().back())->SetIOError( -1);
+	ProgNode::interpreter->SetRetTree( this->GetNextSibling());
+  return RC_OK;
+}
+RetCode      ON_IOERRORNode::Run()
+{
+	static_cast<EnvUDT*>(GDLInterpreter::CallStack().back())->SetIOError( this->targetIx);
+	ProgNode::interpreter->SetRetTree( this->GetNextSibling());
+  return RC_OK;
+}
+
+
+RetCode   RETFNode::Run()
+{
+	ProgNodeP _t = this->getFirstChild();
+	assert( _t != NULL);
+	if ( !static_cast<EnvUDT*>(GDLInterpreter::CallStack().back())->LFun())
+		{
+			BaseGDL* e=ProgNode::interpreter->expr(_t);
+
+			delete ProgNode::interpreter->returnValue;
+			ProgNode::interpreter->returnValue=e;
+
+			GDLInterpreter::CallStack().back()->RemoveLoc( e); // steal e from local list
+		}
+	else
+		{
+			BaseGDL** eL=ProgNode::interpreter->l_ret_expr(_t);
+
+			// returnValueL is otherwise owned
+			ProgNode::interpreter->returnValueL=eL;
+		}
+	//if( !(interruptEnable && sigControlC) && ( debugMode == DEBUG_CLEAR))
+	//return RC_RETURN;
+	return RC_RETURN;
+}
+
+RetCode   RETPNode::Run()
+{
+	return RC_RETURN;
+}
+
+
+
+
+
+
 
-//  if( st->Sgn() == -1) 
-//    {
-//  if( (*v)->ForCondDown( e))
-//     {
-//       ProgNode::interpreter->SetRetTree( bs);
-//     }
-//  else
-//     {
-//       ProgNode::interpreter->SetRetTree( this->getNextSibling());
-//     }
-//    }
-//  else
-//    {
-//  if( (*v)->ForCondUp( e))
-//     {
-//       ProgNode::interpreter->SetRetTree( bs);
-//     }
-//  else
-//     {
-//       ProgNode::interpreter->SetRetTree( this->getNextSibling());
-//     }
-//    }
-// }
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/prognodeexpr.cpp cvs/gdl/src/prognodeexpr.cpp
--- gdl-0.9rc4/src/prognodeexpr.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/prognodeexpr.cpp	2010-05-21 10:23:58.663905064 -0600
@@ -18,6 +18,7 @@
 #include "includefirst.hpp"
 
 #include <memory>
+#include <cassert>
 
 #include <antlr/ASTFactory.hpp>
 
@@ -30,18 +31,6 @@
 
 using namespace std;
 
-bool NonCopyNode( int type)
-{
-  return (type == GDLTokenTypes::DEREF) ||
-    (type == GDLTokenTypes::CONSTANT) ||
-    (type == GDLTokenTypes::VAR) ||
-    (type == GDLTokenTypes::VARPTR);
-}
-// are always copy nodes
-//     (type == GDLTokenTypes::ARRAYDEF) 
-//     (type == GDLTokenTypes::STRUC) 
-//     (type == GDLTokenTypes::NSTRUC) 
-//     (type == GDLTokenTypes::NSTRUC_REF) 
 
 BinaryExpr::BinaryExpr( const RefDNode& refNode): DefaultNode( refNode)
 {
@@ -57,6 +46,9 @@
 }
 
 ProgNode::ProgNode(): // for NULLProgNode
+	keepRight( false),
+	keepDown( false),
+	breakTarget( NULL),
   ttype( antlr::Token::NULL_TREE_LOOKAHEAD),
   text( "NULLProgNode"),
   down( NULL), 
@@ -70,64 +62,29 @@
   labelEnd( 0)
 {}
 
-// tanslation RefDNode -> ProgNode
-ProgNode::ProgNode( const RefDNode& refNode):
-  ttype( refNode->getType()),
-  text( refNode->getText()),
-  down( NULL), 
-  right( NULL),
-  lineNumber( refNode->getLine()),
-  cData( refNode->StealCData()),
-  libPro( refNode->libPro),
-  libFun( refNode->libFun),
-  var( refNode->var),
-  arrIxList( refNode->StealArrIxList()),
-//   arrIxList( refNode->CloneArrIxList()),
-  labelStart( refNode->labelStart),
-  labelEnd( refNode->labelEnd)
-{
-  initInt = refNode->initInt;
-  
-//   if( refNode->GetFirstChild() != RefDNode(antlr::nullAST))
-//     {
-//       down = NewProgNode( refNode->GetFirstChild());
-//     }
-//   if( refNode->GetNextSibling() != RefDNode(antlr::nullAST))
-//     {
-//       right = NewProgNode( refNode->GetNextSibling());
-//     }
-}
-
-ProgNode::~ProgNode()
+BaseGDL* ProgNode::EvalNC()
 {
-  // delete cData in case this node is a constant
-  if( (getType() == GDLTokenTypes::CONSTANT))
-     {
-      delete cData;
-     }
-  if( (getType() == GDLTokenTypes::ARRAYIX))
-    {
-      delete arrIxList;
-    }
-  delete down;
-  delete right;
+  throw GDLException( this,
+		      "Internal error. "
+		      "ProgNode::EvalNC() called.",true,false);
 }
 
-BaseGDL* ProgNode::EvalNC()
+BaseGDL** ProgNode::LEval()
 {
   throw GDLException( this,
 		      "Internal error. "
-		      "ProgNode::EvalNC() called.");
+		      "ProgNode::LEval() called.",true,false);
 }
 
-void  ProgNode::Run()
+RetCode   ProgNode::Run()
 { 
   throw GDLException( this,
 		      "Internal error. "
-		      "ProgNode::Run() called.");
+		      "ProgNode::Run() called.",true,false);
+  return RC_OK; // silence compiler
 }
 
-void ProgNode::SetNodes( const ProgNodeP r, const ProgNodeP d)
+void ProgNode::SetRightDown( const ProgNodeP r, const ProgNodeP d)
 {
   right = r;
   down  = d;
@@ -138,692 +95,7 @@
   return ProgNode::interpreter->expr( this);
 }
 
-// checks if parameterlist is constant
-bool ConstantPar( ProgNodeP _t)
-{
-
-  while(_t != NULL) {
-    switch ( _t->getType()) {
-    case GDLTokenTypes::KEYDEF_REF:
-      {
-	return false;
-      }
-    case GDLTokenTypes::KEYDEF_REF_EXPR:
-      {
-	return false;
-      }
-    case GDLTokenTypes::KEYDEF:
-      {
-// 	ProgNodeP __t162 = _t;
-
-	// 			match(antlr::RefAST(_t),KEYDEF);
-// 	_t = _t->getFirstChild();
-	// 			match(antlr::RefAST(_t),IDENTIFIER);
-// 	_t = _t->getNextSibling();
-
-	if( !_t->getFirstChild()->getNextSibling()->ConstantNode())
-	  return false;
-			
-// 	_t = __t162;
-	_t = _t->getNextSibling();
-	break;
-      }
-    case GDLTokenTypes::REF:
-      {
-	return false;
-      }
-    case GDLTokenTypes::REF_EXPR:
-      {
-	return false;
-      }
-    case GDLTokenTypes::KEYDEF_REF_CHECK:
-      {
-	return false;
-      }
-    case GDLTokenTypes::REF_CHECK:
-      {
-	return false;
-      }
-    default:
-      {
-	// expr
-	if( !_t->ConstantNode())
-	  return false;
-
-	_t = _t->getNextSibling();
-	break;
-      }
-    } // switch
-  } // while
-
-  return true;
-}
-
-
-
-
-
-ProgNodeP ProgNode::NewProgNode( const RefDNode& refNode)
-{
-  // this can happen in case of a subroutine with only common blocks
-  if( refNode == RefDNode(antlr::nullAST)) return NULL;
-
-  bool nonCopy = false;
-  if( refNode->GetFirstChild() != RefDNode(antlr::nullAST))
-    {
-      if( NonCopyNode( refNode->GetFirstChild()->getType()))
-	nonCopy = true;
-      if( refNode->GetFirstChild()->GetNextSibling() != 
-	  RefDNode(antlr::nullAST))
-	if( NonCopyNode( refNode->GetFirstChild()->GetNextSibling()->getType()))
-	  nonCopy = true;
-    }
-  
-  // note: constant expressions are always nonCopy
-  // but expressions of constant expressions are not
-  if( nonCopy) // VAR, VARPTR,...
-    {
-      UnaryExpr* newUnary = NULL;
-      BinaryExpr* newNode = NULL;
-      switch( refNode->getType())
-	{
-	case GDLTokenTypes::QUESTION:
-	  {
-	    return new QUESTIONNode( refNode);
-	  }
-
-	  // unary
-	case GDLTokenTypes::UMINUS:
-	  {
-	    // 	// optimize constant unary minus away
-	    // 	// CONSTANT is a non-copy node
-	    // 	if( refNode->GetFirstChild()->getType() == GDLTokenTypes::CONSTANT)
-	    // 	  {
-	    // 	    const RefDNode& child = refNode->GetFirstChild();
-	    // 	    child->ResetCData( child->CData()->UMinus());
-	    // 	    return NewProgNode( child);
-	    // 	  }
-	    // 	else
-	    newUnary = new UMINUSNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::LOG_NEG:
-	  {
-	    newUnary = new LOG_NEGNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::NOT_OP:
-	  {
-	    newUnary = new NOT_OPNode( refNode);
-	    break;
-	  }
-
-	  // binary
-	case GDLTokenTypes::AND_OP:
-	  {
-	    newNode = new AND_OPNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::OR_OP:
-	  {
-	    newNode = new OR_OPNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::XOR_OP:
-	  {
-	    newNode = new XOR_OPNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::LOG_AND:
-	  {
-	    newNode = new LOG_ANDNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::LOG_OR:
-	  {
-	    newNode = new LOG_ORNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::EQ_OP:
-	  {
-	    newNode = new EQ_OPNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::NE_OP:
-	  {
-	    newNode = new NE_OPNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::LE_OP:
-	  {
-	    newNode = new LE_OPNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::LT_OP:
-	  {
-	    newNode = new LT_OPNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::GE_OP:
-	  {
-	    newNode = new GE_OPNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::GT_OP:
-	  {
-	    newNode = new GT_OPNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::PLUS:
-	  {
-	    newNode = new PLUSNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::MINUS:
-	  {
-	    newNode = new MINUSNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::LTMARK:
-	  {
-	    newNode = new LTMARKNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::GTMARK:
-	  {
-	    newNode = new GTMARKNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::ASTERIX:
-	  {
-	    newNode = new ASTERIXNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::MATRIX_OP1:
-	  {
-	    newNode = new MATRIX_OP1NCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::MATRIX_OP2:
-	  {
-	    newNode = new MATRIX_OP2NCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::SLASH:
-	  {
-	    newNode = new SLASHNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::MOD_OP:
-	  {
-	    newNode = new MOD_OPNCNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::POW:
-	  {
-	    newNode = new POWNCNode( refNode);
-	    break;
-	  }
-	  //     case GDLTokenTypes::DEC:
-	  //       {
-	  // 	return new DECNCNode( refNode);
-	  //       }
-	  //     case GDLTokenTypes::INC:
-	  //       {
-	  // 	return new INCNCNode( refNode);
-	  //       }
-	  //     case GDLTokenTypes::POSTDEC:
-	  //       {
-	  // 	return new POSTDECNCNode( refNode);
-	  //       }
-	  //     case GDLTokenTypes::POSTINC:
-	  //       {
-	  // 	return new POSTINCNCNode( refNode);
-	  //       }
-	  //    default:
-	  //      return new DefaultNode( refNode);
-	}
-
-      if( newNode != NULL)
-	{
-	  if( !newNode->ConstantExpr()) return newNode;
-
-	  auto_ptr<ProgNode> guard( newNode);
-
-	  BaseGDL* cData = newNode->Eval();
-
-	  ProgNodeP cN = new CONSTANTNode( newNode->StealNextSibling(), cData);
-	  cN->lineNumber = refNode->getLine();
-	  cN->setText( "C" + refNode->getText());
-
-	  return cN;
-	}
-      else if( newUnary != NULL)
-	{
-	  if( !newUnary->ConstantExpr()) return newUnary;
-
-	  auto_ptr<ProgNode> guard( newUnary);
-
-	  BaseGDL* cData = newUnary->Eval();
-
-	  ProgNodeP cN = new CONSTANTNode( newUnary->StealNextSibling(), cData);
-	  cN->lineNumber = refNode->getLine();
-	  cN->setText( "C" + refNode->getText());
-
-	  return cN;
-	}
-    }
-  else // !nonCopy
-    {
-      UnaryExpr* newUnary = NULL;
-      BinaryExpr* newNode = NULL;
-      switch( refNode->getType())
-	{
-	case GDLTokenTypes::QUESTION:
-	  {
-	    return new QUESTIONNode( refNode);
-	  }
-
-	  // unary
-	case GDLTokenTypes::UMINUS:
-	  {
-	    newUnary = new UMINUSNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::LOG_NEG:
-	  {
-	    newUnary = new LOG_NEGNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::NOT_OP:
-	  {
-	    newUnary = new NOT_OPNode( refNode);
-	    break;
-	  }
-
-	  // binary
-	case GDLTokenTypes::AND_OP:
-	  {
-	    newNode = new AND_OPNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::OR_OP:
-	  {
-	    newNode = new OR_OPNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::XOR_OP:
-	  {
-	    newNode = new XOR_OPNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::LOG_AND:
-	  {
-	    newNode = new LOG_ANDNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::LOG_OR:
-	  {
-	    newNode = new LOG_ORNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::EQ_OP:
-	  {
-	    newNode = new EQ_OPNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::NE_OP:
-	  {
-	    newNode = new NE_OPNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::LE_OP:
-	  {
-	    newNode = new LE_OPNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::LT_OP:
-	  {
-	    newNode = new LT_OPNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::GE_OP:
-	  {
-	    newNode = new GE_OPNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::GT_OP:
-	  {
-	    newNode = new GT_OPNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::PLUS:
-	  {
-	    newNode = new PLUSNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::MINUS:
-	  {
-	    newNode = new MINUSNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::LTMARK:
-	  {
-	    newNode = new LTMARKNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::GTMARK:
-	  {
-	    newNode = new GTMARKNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::ASTERIX:
-	  {
-	    newNode = new ASTERIXNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::MATRIX_OP1:
-	  {
-	    newNode = new MATRIX_OP1Node( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::MATRIX_OP2:
-	  {
-	    newNode = new MATRIX_OP2Node( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::SLASH:
-	  {
-	    newNode = new SLASHNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::MOD_OP:
-	  {
-	    newNode = new MOD_OPNode( refNode);
-	    break;
-	  }
-	case GDLTokenTypes::POW:
-	  {
-	    newNode = new POWNode( refNode);
-	    break;
-	  }
-	  //     case GDLTokenTypes::DEC:
-	  //       {
-	  // 	return new DECNode( refNode);
-	  //       }
-	  //     case GDLTokenTypes::INC:
-	  //       {
-	  // 	return new INCNode( refNode);
-	  //       }
-	  //     case GDLTokenTypes::POSTDEC:
-	  //       {
-	  // 	return new POSTDECNode( refNode);
-	  //       }
-	  //     case GDLTokenTypes::POSTINC:
-	  //       {
-	  // 	return new POSTINCNode( refNode);
-	  //       }
-	  //      default:
-	}
-      if( newNode != NULL)
-	{
-	  if( !newNode->ConstantExpr()) return newNode;
-
-	  auto_ptr<ProgNode> guard( newNode);
-
-	  BaseGDL* cData = newNode->Eval();
-
-	  ProgNodeP cN = new CONSTANTNode( newNode->StealNextSibling(), cData);
-	  cN->lineNumber = refNode->getLine();
-	  cN->setText( "C" + refNode->getText());
-
-	  return cN;
-	}
-      else if( newUnary != NULL)
-	{
-	  if( !newUnary->ConstantExpr()) return newUnary;
-
-	  auto_ptr<ProgNode> guard( newUnary);
-
-	  BaseGDL* cData = newUnary->Eval();
-
-	  ProgNodeP cN = new CONSTANTNode( newUnary->StealNextSibling(), cData);
-	  cN->lineNumber = refNode->getLine();
-	  cN->setText( "C" + refNode->getText());
-
-	  return cN;
-	}
-    }
-
-  // independed of nonCopy:
-  switch( refNode->getType())
-    {
-    case GDLTokenTypes::FCALL_LIB_RETNEW:
-      {
-	ProgNodeP c = new DefaultNode( refNode);
-
-	if( !static_cast<DLibFunRetNew*>(c->libFun)->RetConstant()
-	    || !ConstantPar( c->getFirstChild())) return c;
-	
-	auto_ptr< ProgNode> guard( c);
-	
-	BaseGDL* cData = c->Eval();
-	
-	ProgNodeP cN = new CONSTANTNode( c->StealNextSibling(), cData);
-	cN->lineNumber = refNode->getLine();
-	cN->setText( "C()");
-	
-	return cN;
-      }
-    case GDLTokenTypes::VAR:
-      {
-	return new VARNode( refNode);
-      }
-    case GDLTokenTypes::VARPTR:
-      {
-	return new VARPTRNode( refNode);
-      }
-    case GDLTokenTypes::SYSVAR:
-      {
-	return new SYSVARNode( refNode);
-      }
-    case GDLTokenTypes::DEREF:
-      {
-	return new DEREFNode( refNode);
-      }
-    case GDLTokenTypes::CONSTANT:
-      {
-	return new CONSTANTNode( refNode);
-      }
-    case GDLTokenTypes::ARRAYDEF:
-      {
-	ARRAYDEFNode* c = new ARRAYDEFNode( refNode);
-	if( !c->ConstantArray()) return c;
-
-	auto_ptr< ARRAYDEFNode> guard( c);
-
-	BaseGDL* cData = c->Eval();
-
-	ProgNodeP cN = new CONSTANTNode( c->StealNextSibling(), cData);
-	cN->lineNumber = refNode->getLine();
-        cN->setText( "[c]");
-
-	return cN;
-
-      }
-    case GDLTokenTypes::ARRAYDEF_CONST:
-      {
-
-	ProgNodeP c = new ARRAYDEFNode( refNode);
-	auto_ptr< ProgNode> guard( c);
-
-	BaseGDL* cData = c->Eval();
-
-	ProgNodeP cN = new CONSTANTNode( c->StealNextSibling(), cData);
-	cN->lineNumber = refNode->getLine();
-        cN->setText( "[C]");
-
-	return cN;
-
-// 	DNode* cN = new DNode();
-//         cN->setType(GDLTokenTypes::CONSTANT);
-// 	cN->setText("[CONSTANT]");
-// 	cN->setNextSibling( refNode->getNextSibling());
-
-// 	refNode->setNextSibling(antlr::nullAST);
-
-// 	ProgNodeP c = new ARRAYDEFNode( refNode);
-// 	auto_ptr< ProgNode> guard( c);
-// 	//c->setType(  GDLTokenTypes::ARRAYDEF);
-
-// 	// evaluate constant
-// 	BaseGDL* res = c->Eval();
-
-// 	cN->ResetCData( res);
-
-// 	return new CONSTANTNode( RefDNode( cN));
-      }
-    case GDLTokenTypes::STRUC:
-      {
-	return new STRUCNode( refNode);
-      }
-    case GDLTokenTypes::NSTRUC:
-      {
-	return new NSTRUCNode( refNode);
-      }
-    case GDLTokenTypes::NSTRUC_REF:
-      {
- 	return new NSTRUC_REFNode( refNode);
-      }
-    case GDLTokenTypes::ASSIGN:         
-      {
-	return new ASSIGNNode( refNode);
-      }
-    case GDLTokenTypes::ASSIGN_REPLACE:
-      {
-	return new ASSIGN_REPLACENode( refNode);
-      }
-    case GDLTokenTypes::PCALL_LIB:
-      {
-	return new  PCALL_LIBNode( refNode);
-      }
-    case GDLTokenTypes::MPCALL:
-      {
-	return new  MPCALLNode( refNode);
-      }
-    case GDLTokenTypes::MPCALL_PARENT:
-      {
-	return new  MPCALL_PARENTNode( refNode);
-      }
-    case GDLTokenTypes::PCALL:
-      {
-	return new  PCALLNode( refNode);
-      }
-    case GDLTokenTypes::DEC:
-      {
-	return new  DECNode( refNode);
-      }
-    case GDLTokenTypes::INC:
-      {
-	return new  INCNode( refNode);
-      }
-      // the following must change their type if precalculation strikes
-		case GDLTokenTypes::KEYDEF_REF:
-		{
-		  ProgNodeP nn = new KEYDEF_REFNode( refNode);
-
-		  if( !nn->getFirstChild()->getNextSibling()->ConstantNode())
-		    return nn;
-
-// 		  nn->setType( GDLTokenTypes::KEYDEF);
-		  delete nn;
-		  nn = new KEYDEFNode( refNode);
-		  return nn;
-		}
-		case GDLTokenTypes::KEYDEF_REF_EXPR:
-		{
-		  ProgNodeP nn = new KEYDEF_REF_EXPRNode( refNode);
-
-		  if( !nn->getFirstChild()->getNextSibling()->ConstantNode())
-		    return nn;
 
-		  delete nn;
-		  nn = new KEYDEFNode( refNode);
-// 		  nn->setType( GDLTokenTypes::KEYDEF);
-		  return nn;
-		}
-		case  GDLTokenTypes::PARAEXPR:
-		  {
-		  ProgNodeP firstChild = 
-		    new ParameterNode( refNode);
-		  return firstChild;
-		  }
-		case  GDLTokenTypes::KEYDEF:
-		  {
-		  ProgNodeP nn = new KEYDEFNode( refNode);
-		  return nn;  
-		  }
-		case GDLTokenTypes::REF:
-		{
-		  ProgNodeP nn = new REFNode( refNode);
-
-		  if( !nn->getFirstChild()->ConstantNode())
-		    return nn;
-		  
-		  delete nn;
-		  
-		  ProgNodeP firstChild = 
-		    new ParameterNode( refNode);//->GetFirstChild());
-		  return firstChild;
-		}
-		case GDLTokenTypes::REF_EXPR:
-		{
-		  ProgNodeP nn = new REF_EXPRNode( refNode);
-
-		  if( !nn->getFirstChild()->ConstantNode())
-		    return nn;
-		  
-		  delete nn;
-		  ProgNodeP firstChild = 
-		    new ParameterNode( refNode);//->GetFirstChild());
-		  return firstChild;
-
-// 		  auto_ptr<ProgNode> guard(nn);
-// 		  return nn->StealFirstChild();
-		}
- 		case GDLTokenTypes::KEYDEF_REF_CHECK:
-		{
-		  ProgNodeP nn = new KEYDEF_REF_CHECKNode( refNode);
-
-		  if( nn->getFirstChild()->getNextSibling()->getType() != 
-		      GDLTokenTypes::CONSTANT) return nn;
-
-		  delete nn;
-		  nn = new KEYDEFNode( refNode);
-		  return nn;
-		}
-		case GDLTokenTypes::REF_CHECK:
-		{
-		  ProgNodeP nn = new REF_CHECKNode( refNode);
-
-		  if( !nn->getFirstChild()->ConstantNode())
-		    return nn;
-		  
-		  delete nn;
-		  ProgNodeP firstChild = 
-		    new ParameterNode( refNode);
-		  return firstChild;
-
-// 		  auto_ptr<ProgNode> guard(nn);
-// 		  ProgNodeP firstChild = nn->StealFirstChild();
-// 		  firstChild->SetNextSibling( nn->StealNextSibling());
-// 		  return firstChild;
-		}
-    }
-
-  // default
-  return new DefaultNode( refNode);
-}
 
 // converts inferior type to superior type
 void ProgNode::AdjustTypes(auto_ptr<BaseGDL>& a, auto_ptr<BaseGDL>& b)
@@ -925,7 +197,7 @@
       BaseGDL* res=static_cast<EnvUDT*>(callStack.back())->GetKW(this->varIx); 
       if( res == NULL)
 	throw GDLException( this, "Variable is undefined: "+
-			    callStack.back()->GetString(this->varIx));
+			    callStack.back()->GetString(this->varIx),true,false);
       return res;
 }
 
@@ -936,7 +208,7 @@
 	{
 	  EnvStackT& callStack=interpreter->CallStack();
 	  throw GDLException( this, "Variable is undefined: "+
-			      callStack.back()->GetString( res));
+			      callStack.back()->GetString( res),true,false);
 	}
       return res;
 }
@@ -952,43 +224,69 @@
     {
       this->var=FindInVarList(sysVarList,this->getText());
       if( this->var == NULL)		    
-	throw GDLException( this, "Not a legal system variable: !"+
-			    this->getText());
+		throw GDLException( this, "Not a legal system variable: !"+
+			    this->getText(),true,false);
     }
   // system variables are always defined
   return this->var->Data(); 
 }
 
+
+
+
 BaseGDL* DEREFNode::EvalNC()
 {
-  BaseGDL* e1 = this->getFirstChild()->Eval();
-  auto_ptr<BaseGDL> e1_guard(e1);
-  
-  DPtrGDL* ptr=dynamic_cast<DPtrGDL*>(e1);
-  if( ptr == NULL)
+  auto_ptr<BaseGDL> e1_guard;
+  BaseGDL* e1;
+  ProgNodeP evalExpr = this->getFirstChild();
+  if( NonCopyNode( evalExpr->getType()))
+  {
+	e1 = evalExpr->EvalNC();
+  }
+  else
+  {
+	e1 = evalExpr->Eval();
+    e1_guard.reset(e1);
+  }
+
+  if( e1 == NULL || e1->Type() != PTR)
     throw GDLException( this, "Pointer type required"
-			" in this context: "+interpreter->Name(e1));
-  DPtr sc; 
+			" in this context: "+interpreter->Name(e1),true,false);
+  DPtrGDL* ptr=static_cast<DPtrGDL*>(e1);
+  DPtr sc;
   if( !ptr->Scalar(sc))
     throw GDLException( this, "Expression must be a "
-			"scalar in this context: "+interpreter->Name(e1));
+			"scalar in this context: "+interpreter->Name(e1),true,false);
   if( sc == 0)
     throw GDLException( this, "Unable to dereference"
-			" NULL pointer: "+interpreter->Name(e1));
+			" NULL pointer: "+interpreter->Name(e1),true,false);
   
   try{
     return interpreter->GetHeap(sc);
   }
   catch( GDLInterpreter::HeapException)
     {
-      throw GDLException( this, "Invalid pointer: "+interpreter->Name(e1));
+      throw GDLException( this, "Invalid pointer: "+interpreter->Name(e1),true,false);
     }
 }
 
+
+
 // trinary operator
 BaseGDL* QUESTIONNode::Eval()
 {
-  auto_ptr<BaseGDL> e1( op1->Eval());
+  auto_ptr<BaseGDL> e1_guard;
+  BaseGDL* e1;
+  if( NonCopyNode( op1->getType()))
+  {
+	e1 = op1->EvalNC();
+  }
+  else
+  {
+	e1 = op1->Eval();
+    e1_guard.reset(e1);
+  }
+//  auto_ptr<BaseGDL> e1( op1->Eval());
   if( e1->True())
     {
       return op2->Eval(); // right->down
@@ -2511,3 +1809,501 @@
 // { BaseGDL* res;
 //   return new POSTINCNode( refNode);
 // }
+
+  BaseGDL** FCALL_LIB_RETNEWNode::LEval()
+  {
+      // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+    StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+	throw GDLException(this,"Internal error: FCALL_LIB_RETNEW as left expr.");
+  }
+  
+  BaseGDL* FCALL_LIB_RETNEWNode::Eval()
+  {
+      // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+    StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+
+// 	match(antlr::RefAST(_t),FCALL_LIB_RETNEW);
+//	_t = _t->getFirstChild();
+// 	match(antlr::RefAST(_t),IDENTIFIER);
+	EnvT* newEnv=new EnvT( this, this->libFun);//libFunList[fl->funIx]);
+// 	_t =_t->getFirstChild();
+// 	EnvT* newEnv=new EnvT( fl, fl->libFun);//libFunList[fl->funIx]);
+    static int n_elementsIx = LibFunIx("N_ELEMENTS");
+    static DLibFun* n_elementsFun = libFunList[n_elementsIx];
+
+    if( this->libFun == n_elementsFun)
+        {
+            ProgNode::interpreter->parameter_def_n_elements(this->getFirstChild(), newEnv);
+        }
+    else
+        {
+            ProgNode::interpreter->parameter_def(this->getFirstChild(), newEnv);
+        }
+
+//	parameter_def(_t->getFirstChild(), newEnv);
+	// push id.pro onto call stack
+	ProgNode::interpreter->CallStack().push_back(newEnv);
+	// make the call
+	BaseGDL*
+    res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
+	//*** MUST always return a defined expression
+	
+	ProgNode::interpreter->SetRetTree( this->getNextSibling());
+	return res;
+  }
+
+  BaseGDL** FCALL_LIBNode::LEval()
+  {
+      // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+    StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+// 	match(antlr::RefAST(_t),FCALL_LIB);
+	EnvT* newEnv=new EnvT( this, this->libFun);//libFunList[fl->funIx]);
+	
+    ProgNode::interpreter->parameter_def(this->getFirstChild(), newEnv);
+
+	EnvT* callerEnv = static_cast<EnvT*>(ProgNode::interpreter->CallStack().back());
+
+	// push id.pro onto call stack
+	ProgNode::interpreter->CallStack().push_back(newEnv);
+	// make the call
+	BaseGDL* libRes =	static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
+		
+	BaseGDL** res = callerEnv->GetPtrTo( libRes);
+	if( res == NULL)
+		throw GDLException( this, "Library function must return a "
+		"l-value in this context: "+this->getText());
+
+	ProgNode::interpreter->SetRetTree( this->getNextSibling());
+	return res;
+  }
+
+  BaseGDL* FCALL_LIBNode::Eval()
+  {
+      // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+    StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+// 	match(antlr::RefAST(_t),FCALL_LIB);
+	EnvT* newEnv=new EnvT( this, this->libFun);//libFunList[fl->funIx]);
+	
+    ProgNode::interpreter->parameter_def(this->getFirstChild(), newEnv);
+
+	assert( dynamic_cast<EnvUDT*>(ProgNode::interpreter->CallStack().back()) != NULL);
+	EnvUDT* callStackBack = static_cast<EnvUDT*>(ProgNode::interpreter->CallStack().back());
+		
+	// push id.pro onto call stack
+	ProgNode::interpreter->CallStack().push_back(newEnv);
+	// make the call
+	BaseGDL* res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
+	// *** MUST always return a defined expression
+//    if( res == NULL)
+//       throw GDLException( _t, "");
+	
+	if( callStackBack->Contains( res))
+		res = res->Dup();
+
+	ProgNode::interpreter->SetRetTree( this->getNextSibling());
+	return res;
+  }
+
+  BaseGDL** MFCALLNode::LEval()
+  {
+        // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+    StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+
+//			match(antlr::RefAST(_t),MFCALL);
+		ProgNodeP _t = this->getFirstChild();
+		BaseGDL* self=ProgNode::interpreter->expr(_t);
+		auto_ptr<BaseGDL> self_guard(self);
+
+		ProgNodeP mp = _t->getNextSibling();
+//			match(antlr::RefAST(_t),IDENTIFIER);
+		_t = mp->getNextSibling();
+
+		EnvUDT* newEnv=new EnvUDT( self, mp, "", true);
+
+		self_guard.release();
+
+		ProgNode::interpreter->parameter_def(_t, newEnv);
+		
+		// push environment onto call stack
+	ProgNode::interpreter->CallStack().push_back(newEnv);
+		
+		// make the call
+	BaseGDL**	res=ProgNode::interpreter->
+			call_lfun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
+
+	ProgNode::interpreter->SetRetTree( this->getNextSibling());
+	return res;
+  }
+
+  BaseGDL* MFCALLNode::Eval()
+  {
+      // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+    StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+		
+		ProgNodeP _t = this->getFirstChild();
+
+		BaseGDL* self=ProgNode::interpreter->expr(_t);
+		auto_ptr<BaseGDL> self_guard(self);
+		
+		_t = _t->getNextSibling();
+		//match(antlr::RefAST(_t),IDENTIFIER);
+
+		EnvUDT* newEnv=new EnvUDT( self, _t);
+		
+		self_guard.release();
+		
+		_t = _t->getNextSibling();
+		
+		ProgNode::interpreter->parameter_def(_t, newEnv);
+  	
+  	// push environment onto call stack
+	ProgNode::interpreter->CallStack().push_back(newEnv);
+	
+	// make the call
+	BaseGDL* res=ProgNode::interpreter->call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
+	
+	ProgNode::interpreter->SetRetTree( this->getNextSibling());
+	return res;
+  }
+
+  BaseGDL** MFCALL_PARENTNode::LEval()
+  {
+      // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+    StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+//			match(antlr::RefAST(_t),MFCALL_PARENT);
+	ProgNodeP _t = this->getFirstChild();
+	BaseGDL* self=ProgNode::interpreter->expr(_t);
+	auto_ptr<BaseGDL> self_guard(self);
+
+	_t = _t->getNextSibling();
+	ProgNodeP parent = _t;
+// 		match(antlr::RefAST(_t),IDENTIFIER);
+	_t = _t->getNextSibling();
+	ProgNodeP p = _t;
+// 		match(antlr::RefAST(_t),IDENTIFIER);
+	_t = _t->getNextSibling();
+
+	EnvUDT* newEnv=new EnvUDT( self, p,	parent->getText(), true);
+
+	self_guard.release();
+
+	ProgNode::interpreter->parameter_def(_t, newEnv);
+
+		// push environment onto call stack
+	ProgNode::interpreter->CallStack().push_back(newEnv);
+		
+		// make the call
+	BaseGDL**	res=ProgNode::interpreter->
+			call_lfun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
+
+	ProgNode::interpreter->SetRetTree( this->getNextSibling());
+	return res;
+  }
+
+  BaseGDL* MFCALL_PARENTNode::Eval()
+  {
+      // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+    StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+// 		match(antlr::RefAST(_t),MFCALL_PARENT);
+		ProgNodeP _t = this->getFirstChild();
+		BaseGDL* self=ProgNode::interpreter->expr(_t);
+		auto_ptr<BaseGDL> self_guard(self);
+		
+		_t = _t->getNextSibling();
+		ProgNodeP parent = _t;
+// 		match(antlr::RefAST(_t),IDENTIFIER);
+		_t = _t->getNextSibling();
+		ProgNodeP p = _t;
+// 		match(antlr::RefAST(_t),IDENTIFIER);
+		_t = _t->getNextSibling();
+
+		EnvUDT* newEnv=new EnvUDT( self, p,	parent->getText());
+		
+		self_guard.release();
+		
+		ProgNode::interpreter->parameter_def(_t, newEnv);
+  	
+  	// push environment onto call stack
+	ProgNode::interpreter->CallStack().push_back(newEnv);
+	
+	// make the call
+	BaseGDL* res=ProgNode::interpreter->call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
+	
+	ProgNode::interpreter->SetRetTree( this->getNextSibling());
+	return res;
+  }
+
+  BaseGDL** FCALLNode::LEval()
+  {
+      // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+    StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+	//	match(antlr::RefAST(_t),FCALL);
+	ProgNodeP	_t = this->getFirstChild();
+			
+	ProgNode::interpreter->SetFunIx( this);
+			
+	EnvUDT* newEnv=new EnvUDT( this, funList[this->funIx], true);
+			
+	ProgNode::interpreter->parameter_def(_t, newEnv);
+		
+		// push environment onto call stack
+	ProgNode::interpreter->CallStack().push_back(newEnv);
+		
+		// make the call
+	BaseGDL**	res=
+		ProgNode::interpreter->call_lfun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
+	
+	ProgNode::interpreter->SetRetTree( this->getNextSibling());
+	return res;
+  }
+
+  BaseGDL* FCALLNode::Eval()
+  {
+      // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+    StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+		ProgNode::interpreter->SetFunIx( this);
+		
+		EnvUDT* newEnv=new EnvUDT( this, funList[this->funIx]);
+		
+		ProgNode::interpreter->parameter_def(this->getFirstChild(), newEnv);
+
+	// push environment onto call stack
+	ProgNode::interpreter->CallStack().push_back(newEnv);
+	
+	// make the call
+	BaseGDL*
+	res=ProgNode::interpreter->call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
+	
+	ProgNode::interpreter->SetRetTree( this->getNextSibling());
+	return res;
+  }
+
+  BaseGDL* ARRAYEXPR_MFCALLNode::Eval()
+  {
+      // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+    StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+//		match(antlr::RefAST(_t),ARRAYEXPR_MFCALL);
+	ProgNodeP mark = this->getFirstChild();
+
+	ProgNodeP _t = mark->getNextSibling(); // skip DOT
+
+	BaseGDL* self=ProgNode::interpreter->expr(_t);
+	auto_ptr<BaseGDL> self_guard(self);
+
+	ProgNodeP mp2 = _t->getNextSibling();
+	//match(antlr::RefAST(_t),IDENTIFIER);
+
+	_t = mp2->getNextSibling();
+
+	BaseGDL* res;
+
+	EnvUDT* newEnv;
+	try {
+		newEnv=new EnvUDT( self, mp2);
+		self_guard.release();
+	}
+	catch( GDLException& ex)
+	{
+		goto tryARRAYEXPR;
+	}
+
+	ProgNode::interpreter->parameter_def(_t, newEnv);
+
+	// push environment onto call stack
+	ProgNode::interpreter->CallStack().push_back(newEnv);
+	
+	// make the call
+	res=
+		ProgNode::interpreter->
+			call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
+	
+	ProgNode::interpreter->SetRetTree( this->getNextSibling());
+	return res;
+	
+	tryARRAYEXPR:;
+	//_t = mark;
+	
+	ProgNodeP dot = mark;
+	// 	match(antlr::RefAST(_t),DOT);
+	_t = mark->getFirstChild();
+		
+	SizeT nDot=dot->nDot;
+	auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+		
+	ProgNode::interpreter->r_dot_array_expr(_t, aD.get());
+	_t = _t->getNextSibling();
+	for (; _t != NULL;) {
+	ProgNode::interpreter->tag_array_expr(_t, aD.get());
+	_t = _t->getNextSibling();
+	}
+	res= aD->Resolve();
+	
+	ProgNode::interpreter->SetRetTree( this->getNextSibling());
+	return res;
+  }
+
+  BaseGDL** ARRAYEXPR_MFCALLNode::LEval()
+  {
+      // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+    StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+  }
+
+  BaseGDL** VARNode::LEval()
+	{
+  	ProgNode::interpreter->SetRetTree( this->getNextSibling());
+	return &ProgNode::interpreter->CallStack().back()->GetKW(this->varIx);
+	}
+  BaseGDL** VARPTRNode::LEval()
+	{
+  	ProgNode::interpreter->SetRetTree( this->getNextSibling());
+	return &this->var->Data();
+	}
+
+
+  BaseGDL* ARRAYEXPRNode::Eval()
+  {
+	BaseGDL* res;
+	ProgNodeP ax;
+
+	ArrayIndexListT* aL;
+	BaseGDL* r;
+	ArrayIndexListGuard guard;
+	auto_ptr<BaseGDL> r_guard;
+
+	ExprListT        exprList; // for cleanup
+	IxExprListT      ixExprList;
+	SizeT nExpr;
+	BaseGDL* s;
+
+	//	match(antlr::RefAST(_t),ARRAYEXPR);
+	ProgNodeP	_t = this->getFirstChild();
+
+	switch ( _t->getType()) {
+		case GDLTokenTypes::VAR:
+		case GDLTokenTypes::CONSTANT:
+		case GDLTokenTypes::DEREF:
+		case GDLTokenTypes::SYSVAR:
+		case GDLTokenTypes::VARPTR:
+		{
+			r=_t->EvalNC();
+			//r=indexable_expr(_t);
+			break;
+		}
+		case GDLTokenTypes::FCALL_LIB:
+		{
+			// better than Eval(): no copying here if not necessary
+			r=ProgNode::interpreter->lib_function_call(_t);
+
+			if( !ProgNode::interpreter->CallStack().back()->Contains( r))
+			r_guard.reset( r); // guard if no global data
+
+			break;
+		}
+		// 	case ASSIGN:
+		// 	case ASSIGN_REPLACE:
+		// 	case ASSIGN_ARRAYEXPR_MFCALL:
+		// 	case ARRAYDEF:
+		// 	case ARRAYEXPR:
+		// 	case ARRAYEXPR_MFCALL:
+		// 	case EXPR:
+		// 	case FCALL:
+		// 	case FCALL_LIB_RETNEW:
+		// 	case MFCALL:
+		// 	case MFCALL_PARENT:
+		// 	case NSTRUC:
+		// 	case NSTRUC_REF:
+		// 	case POSTDEC:
+		// 	case POSTINC:
+		// 	case STRUC:
+		// 	case DEC:
+		// 	case INC:
+		// 	case DOT:
+		// 	case QUESTION:
+		default:
+		{
+			r=ProgNode::interpreter->indexable_tmp_expr(_t);
+			r_guard.reset( r);
+			break;
+		}
+	} // switch
+		
+		_t = _t->getNextSibling();
+	
+	aL = _t->arrIxList;
+	assert( aL != NULL);
+	guard.reset(aL);
+		
+	//    ax = _t
+	//	match(antlr::RefAST(_t),ARRAYIX);
+	_t = _t->getFirstChild();
+		
+	nExpr = aL->NParam();
+		
+	if( nExpr == 0)
+	{
+		goto empty;
+	}
+		
+	for (;;)
+	{
+		switch ( _t->getType()) {
+		case GDLTokenTypes::VAR:
+		case GDLTokenTypes::CONSTANT:
+		case GDLTokenTypes::DEREF:
+		case GDLTokenTypes::SYSVAR:
+		case GDLTokenTypes::VARPTR:
+		{
+			s=_t->EvalNC();//indexable_expr(_t);
+			_t = _t->getNextSibling();//_retTree;
+			break;
+		}
+		case GDLTokenTypes::FCALL_LIB:
+		{
+			s=ProgNode::interpreter->lib_function_call(_t);
+			_t = _t->getNextSibling();
+
+			if( !ProgNode::interpreter->CallStack().back()->Contains( s))
+			exprList.push_back( s);
+
+			break;
+		}
+		// 			case ASSIGN:
+		// 			case ASSIGN_REPLACE:
+		// 			case ASSIGN_ARRAYEXPR_MFCALL:
+		// 			case ARRAYDEF:
+		// 			case ARRAYEXPR:
+		// 			case ARRAYEXPR_MFCALL:
+		// 			case EXPR:
+		// 			case FCALL:
+		// 			case FCALL_LIB_RETNEW:
+		// 			case MFCALL:
+		// 			case MFCALL_PARENT:
+		// 			case NSTRUC:
+		// 			case NSTRUC_REF:
+		// 			case POSTDEC:
+		// 			case POSTINC:
+		// 			case STRUC:
+		// 			case DEC:
+		// 			case INC:
+		// 			case DOT:
+		// 			case QUESTION:
+		default:
+			{
+				s=ProgNode::interpreter->indexable_tmp_expr(_t);
+				_t = _t->getNextSibling();
+				exprList.push_back( s);
+				break;
+			}
+		} // switch
+
+		ixExprList.push_back( s);
+		if( ixExprList.size() == nExpr)
+				break; // for -> finish
+	} // for
+
+	empty:
+	res = aL->Index( r, ixExprList);
+
+	ProgNode::interpreter->SetRetTree( this->getNextSibling());
+	return res;
+}
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/prognodeexpr.hpp cvs/gdl/src/prognodeexpr.hpp
--- gdl-0.9rc4/src/prognodeexpr.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/prognodeexpr.hpp	2010-05-21 10:23:58.667906577 -0600
@@ -92,11 +92,80 @@
 
 
 
+
+
+class FCALL_LIB_RETNEWNode: public LeafNode
+{
+public:
+  FCALL_LIB_RETNEWNode( const RefDNode& refNode): LeafNode( refNode)
+  {}
+  BaseGDL** LEval();
+  BaseGDL* Eval();
+};
+
+
+
+class FCALL_LIBNode: public LeafNode
+{
+public:
+  FCALL_LIBNode( const RefDNode& refNode): LeafNode( refNode)
+  {}
+  BaseGDL** LEval();
+  BaseGDL* Eval();
+};
+
+
+
+class MFCALLNode: public LeafNode
+{
+public:
+  MFCALLNode( const RefDNode& refNode): LeafNode( refNode)
+  {}
+  BaseGDL** LEval();
+  BaseGDL* Eval();
+};
+
+
+
+class MFCALL_PARENTNode: public LeafNode
+{
+public:
+  MFCALL_PARENTNode( const RefDNode& refNode): LeafNode( refNode)
+  {}
+  BaseGDL** LEval();
+  BaseGDL* Eval();
+};
+
+
+
+class FCALLNode: public LeafNode
+{
+public:
+  FCALLNode( const RefDNode& refNode): LeafNode( refNode)
+  {}
+  BaseGDL** LEval();
+  BaseGDL* Eval();
+};
+
+
+
+class ARRAYEXPR_MFCALLNode: public LeafNode
+{
+public:
+  ARRAYEXPR_MFCALLNode( const RefDNode& refNode): LeafNode( refNode)
+  {}
+  BaseGDL** LEval();
+  BaseGDL* Eval();
+};
+
+
+
 class VARNode: public LeafNode
 {
 public:
   VARNode( const RefDNode& refNode): LeafNode( refNode)
   {}
+  BaseGDL** LEval();
   BaseGDL* EvalNC();
 };
 class VARPTRNode: public LeafNode
@@ -104,6 +173,7 @@
 public:
   VARPTRNode( const RefDNode& refNode): LeafNode( refNode)
   {}
+  BaseGDL** LEval();
   BaseGDL* EvalNC();
 };
 class SYSVARNode: public LeafNode
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/prognode.hpp cvs/gdl/src/prognode.hpp
--- gdl-0.9rc4/src/prognode.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/prognode.hpp	2010-05-21 10:23:58.601905794 -0600
@@ -33,6 +33,22 @@
 class ProgNode;
 typedef ProgNode* ProgNodeP;
 
+inline bool NonCopyNode( int type)
+{
+  return (type == GDLTokenTypes::DEREF) ||
+    (type == GDLTokenTypes::VAR) ||
+    (type == GDLTokenTypes::VARPTR) ||
+    (type == GDLTokenTypes::CONSTANT) ||
+    (type == GDLTokenTypes::SYSVAR) ;
+// are always copy nodes:
+//     (type == GDLTokenTypes::ARRAYDEF)
+//     (type == GDLTokenTypes::STRUC)
+//     (type == GDLTokenTypes::NSTRUC)
+//     (type == GDLTokenTypes::NSTRUC_REF)
+}
+
+class BreakableNode;
+
 // the nodes the programs are made of
 class ProgNode
 {
@@ -44,6 +60,11 @@
   std::string text;
 
 protected:
+  bool keepRight;
+  bool keepDown;
+
+  ProgNodeP breakTarget;
+  
   ProgNodeP down;
   ProgNodeP right;
 
@@ -67,8 +88,13 @@
     int        targetIx;   // Index into label list
     int        structDefined; // struct contains entry with no tag name
     int        compileOpt; // for PRO and FUNCTION nodes
+	int        forLoopIx; // acessing loop variables
   };
 
+	void SetType( int tt, const std::string& txt) { ttype = tt; text = txt;} 
+
+	static ProgNodeP GetNULLProgNodeP(); 
+
 private:
   // from DNode (see there)
   int lineNumber;
@@ -76,20 +102,46 @@
   int labelStart; // for loops to determine if to bail out
   int labelEnd; // for loops to determine if to bail out
 
+  // disable usage
+  ProgNode( const ProgNode& p) {}
+
 public:
   ProgNode();
 
   ProgNode( const RefDNode& refNode);
 
+	// tree translation takes place here
+	// see newprognode.cpp
   static ProgNodeP NewProgNode( const RefDNode& refNode);
+  static int NumberForLoops( ProgNodeP tree, int offset = 0)
+  {
+	return tree->NumberForLoops( offset);
+  }
 
+  virtual int NumberForLoops( int actNum)
+  {
+	if( down != NULL && !keepDown)
+		{
+			actNum = down->NumberForLoops( actNum);
+		}
+		
+	if( right != NULL && !keepRight)
+		{
+			actNum = right->NumberForLoops( actNum);
+		}
+	return actNum;
+ }
+  
   virtual ~ProgNode();
   
-  void SetNodes( const ProgNodeP right, const ProgNodeP down);
+  void SetRightDown( const ProgNodeP right, const ProgNodeP down);
+
+  virtual BaseGDL** LEval();
+  virtual BaseGDL* Eval(); // caller receives ownership
+  virtual BaseGDL* EvalNC(); // non-copy used by all operators (and in other places)
+  virtual RetCode    Run();
 
-  virtual BaseGDL* Eval();
-  virtual BaseGDL* EvalNC(); // non-copy
-  virtual void     Run();
+//   RetCode  (*RunP)();
 
   bool ConstantNode();
 
@@ -99,7 +151,7 @@
   }
   ProgNodeP GetFirstChild() const
   {
-    return getFirstChild();
+    return down;//getFirstChild();
   }
   void SetFirstChild( ProgNodeP d)
   {
@@ -109,9 +161,15 @@
   {
     return right;
   }
+  ProgNodeP GetLastSibling() const
+  {
+	ProgNodeP act = const_cast<ProgNodeP>(this);
+	while(!act->KeepRight() && act->GetNextSibling() != NULL) act = act->GetNextSibling();
+    return act;
+  }
   ProgNodeP GetNextSibling() const
   {
-    return getNextSibling();
+    return right;//getNextSibling();
   }
   void SetNextSibling( ProgNodeP r)
   {
@@ -130,7 +188,52 @@
     down = NULL;
     return n;
   }
+
+  bool KeepRight() const { return keepRight;}
+  bool KeepDown() const { return keepDown;}
   
+  void KeepDown( ProgNodeP d)
+  {
+	down = d;
+	keepDown = true;
+  }
+  virtual void KeepRight( ProgNodeP r)
+  {
+	right = r;
+	keepRight = true;
+  }
+
+   void SetRight( ProgNodeP r)
+   {
+ 	right = r;
+// 	keepRight = false;
+   }
+  
+	virtual void SetAllBreak( ProgNodeP target)
+	{
+		if( down != NULL && !keepDown)
+				{
+					down->SetAllBreak( target);
+				}
+		
+		if( right != NULL && !keepRight)
+		{
+			right->SetAllBreak( target);
+		}
+	}
+	virtual void SetAllContinue( ProgNodeP target)
+	{
+		if( down != NULL && !keepDown)
+				{
+					down->SetAllContinue( target);
+				}
+		
+		if( right != NULL && !keepRight)
+		{
+			right->SetAllContinue( target);
+		}
+	}
+
   int getType() { return ttype;}
   void setType( int t) { ttype=t;}
   std::string getText() { return text;}
@@ -138,32 +241,39 @@
   int getLine() const { return lineNumber;}
   void setLine( int l) { lineNumber = l;}
   void SetGotoIx( int ix) { targetIx=ix;}
+
+  ProgNodeP BreakTarget() const { return breakTarget;}
   
   bool LabelInRange( const int lIx)
-  { return (lIx >= labelStart) && (lIx < labelEnd);}
+  {
+// 	std::cout << "LabelInRange: " << ((lIx >= labelStart) && (lIx < labelEnd)) << "     " << lIx << "   [" << labelStart << "," << labelEnd << ")" << std::endl;
+	return (lIx >= labelStart) && (lIx < labelEnd);
+  }
   
-  friend class GDLInterpreter;
-  friend class DInterpreter;
-
-friend class NSTRUCNode;
-friend class ASSIGNNode;
-friend class ASSIGN_REPLACENode;
-friend class PCALL_LIBNode;//: public CommandNode
-friend class MPCALLNode;//: public CommandNode
-friend class MPCALL_PARENTNode;//: public CommandNode
-friend class PCALLNode;//: public CommandNode
-
-  friend class KEYDEF_Node;
-  friend class KEYDEF_REFNode;
-  friend class KEYDEF_REF_CHECKNode;
-  friend class KEYDEF_REF_EXPRNode;
-  friend class REFNode;
-  friend class REF_CHECKNode;
-  friend class REF_EXPRNode;
-  friend class ParameterNode;
+	friend class GDLInterpreter;
+	friend class DInterpreter;
 
+	friend class NSTRUCNode;
+	friend class ASSIGNNode;
+	friend class ASSIGN_REPLACENode;
+	friend class PCALL_LIBNode;//: public CommandNode
+	friend class MPCALLNode;//: public CommandNode
+	friend class MPCALL_PARENTNode;//: public CommandNode
+	friend class PCALLNode;//: public CommandNode
+	friend class ARRAYEXPR_MFCALLNode;
+	friend class KEYDEF_Node;
+	friend class KEYDEF_REFNode;
+	friend class KEYDEF_REF_CHECKNode;
+	friend class KEYDEF_REF_EXPRNode;
+	friend class REFNode;
+	friend class REF_CHECKNode;
+	friend class REF_EXPRNode;
+	friend class ParameterNode;
+	friend class ARRAYEXPRNode;
 };
 
+
+
 class DefaultNode: public ProgNode
 {
 public:
@@ -173,15 +283,926 @@
   {
     if( refNode->GetFirstChild() != RefDNode(antlr::nullAST))
       {
-	down = NewProgNode( refNode->GetFirstChild());
+		down = NewProgNode( refNode->GetFirstChild());
       }
     if( refNode->GetNextSibling() != RefDNode(antlr::nullAST))
       {
-	right = NewProgNode( refNode->GetNextSibling());
+		right = NewProgNode( refNode->GetNextSibling());
       }
   }
 };
 
+class RETPNode: public DefaultNode
+{
+public:
+	RetCode      Run();
+	
+public:
+    RETPNode(): DefaultNode()  {}
+	
+	RETPNode( const RefDNode& refNode): DefaultNode( refNode)
+	{}
+};
+class RETFNode: public DefaultNode
+{
+public:
+ RetCode      Run();
+	
+public:
+    RETFNode(): DefaultNode()  {}
+	
+	RETFNode( const RefDNode& refNode): DefaultNode( refNode)
+	{}
+};
+class GOTONode: public DefaultNode
+{
+public:
+ RetCode      Run();
+	
+	void SetAllBreak( ProgNodeP target)
+	{
+// 		breakTarget = target;
+		
+		if( right != NULL && !keepRight)
+		{
+			right->SetAllBreak( target);
+		}
+	}
+public:
+    GOTONode(): DefaultNode()  {}
+	
+	GOTONode( const RefDNode& refNode): DefaultNode( refNode)
+	{}
+};
+class CONTINUENode: public DefaultNode
+{
+public:
+ RetCode      Run();
+	
+
+	void SetAllContinue( ProgNodeP target)
+	{
+		assert( target != NULL);
+		breakTarget = target;
+		
+		if( right != NULL && !keepRight)
+		{
+			right->SetAllContinue( target);
+		}
+	}
+public:
+    CONTINUENode(): DefaultNode()  {}
+	
+	CONTINUENode( const RefDNode& refNode): DefaultNode( refNode)
+	{}
+};
+class BREAKNode: public DefaultNode
+{
+public:
+ RetCode      Run();
+	
+
+	void SetAllBreak( ProgNodeP target)
+	{
+		breakTarget = target;
+		
+		if( right != NULL && !keepRight)
+		{
+			right->SetAllBreak( target);
+		}
+	}
+public:
+    BREAKNode(): DefaultNode()  {}
+	
+	BREAKNode( const RefDNode& refNode): DefaultNode( refNode)
+	{}
+};
+class LABELNode: public DefaultNode
+{
+public:
+ RetCode      Run();
+	
+
+public:
+    LABELNode(): DefaultNode()  {}
+	
+	LABELNode( const RefDNode& refNode): DefaultNode( refNode)
+	{}
+};
+class ON_IOERROR_NULLNode: public DefaultNode
+{
+public:
+ RetCode      Run();
+	
+
+public:
+    ON_IOERROR_NULLNode(): DefaultNode()  {}
+	
+	ON_IOERROR_NULLNode( const RefDNode& refNode): DefaultNode( refNode)
+	{}
+};
+class ON_IOERRORNode: public DefaultNode
+{
+public:
+ RetCode      Run();
+	
+
+public:
+    ON_IOERRORNode(): DefaultNode()  {}
+	
+	ON_IOERRORNode( const RefDNode& refNode): DefaultNode( refNode)
+	{}
+};
+
+
+class BreakableNode: public ProgNode
+{
+public:
+	void SetAllBreak( ProgNodeP target)
+	{
+		// down: do NOT descent into own loop tree here
+		
+		if( right != NULL && !keepRight)
+		{
+			right->SetAllBreak( target);
+		}
+	}
+	void SetAllContinue( ProgNodeP target)
+	{
+		// down: do NOT descent into own loop tree here
+		
+		if( right != NULL && !keepRight)
+		{
+			right->SetAllContinue( target);
+		}
+	}
+
+public:
+  BreakableNode(): ProgNode()  {}
+
+  BreakableNode( const RefDNode& refNode): ProgNode( refNode)
+  {
+    if( refNode->GetFirstChild() != RefDNode(antlr::nullAST))
+      {
+		down = NewProgNode( refNode->GetFirstChild());
+      }
+    if( refNode->GetNextSibling() != RefDNode(antlr::nullAST))
+      {
+		right = NewProgNode( refNode->GetNextSibling());
+      }
+  }
+};
+
+
+
+
+class FOR_LOOPNode: public BreakableNode
+{
+  public:
+ RetCode      Run();
+
+	ProgNodeP statementList;
+	
+	ProgNodeP GetStatementList()
+	{
+		return down->GetNextSibling();//->GetNextSibling()->GetNextSibling();
+	}
+	
+  public:
+	void KeepRight( ProgNodeP r)
+	{
+		right = r;
+		keepRight = true;
+		assert( this->GetStatementList() != NULL);
+// 		if( this->GetStatementList() != NULL)
+			this->GetStatementList()->SetAllBreak( right);
+	}
+  
+  int NumberForLoops( int actNum)
+  {
+	this->forLoopIx = actNum;
+	actNum++;
+	ProgNodeP statementList = this->GetStatementList();
+	if( statementList != NULL && !down->KeepRight())
+		{
+			actNum = statementList->NumberForLoops( actNum);
+		}
+	if( right != NULL && !keepRight)
+		{
+			actNum = right->NumberForLoops( actNum);
+		}
+	return actNum;
+ }
+  
+  public:
+  FOR_LOOPNode( ProgNodeP r, ProgNodeP d): BreakableNode()
+  {
+    SetType( GDLTokenTypes::FOR_LOOP, "for_loop");
+	SetRightDown( r, d);
+
+	assert( down != NULL);
+	
+	statementList = this->GetStatementList();
+	if( statementList != NULL)
+		{
+			statementList->SetAllContinue( this);
+			statementList->GetLastSibling()->KeepRight( this);
+			if( right != NULL) statementList->SetAllBreak( right);
+		}
+	else
+		{
+			down->KeepRight( this);
+			statementList = this;
+		}
+  }
+
+};
+
+
+class FORNode: public BreakableNode
+{
+  public:
+ RetCode      Run();
+	
+  void KeepRight( ProgNodeP r);
+	
+  int NumberForLoops( int actNum)
+  {
+	this->forLoopIx = actNum;
+	
+// 	assert( down == NULL);
+		
+	assert( right != NULL && !keepRight);
+			
+	actNum = right->NumberForLoops( actNum);
+	
+	return actNum;
+ }
+  
+  public:
+  FORNode(): BreakableNode()  {}
+
+  FORNode( const RefDNode& refNode): BreakableNode( refNode)
+	{
+	ProgNodeP keep = down->GetNextSibling();
+	down->SetRight( down->GetNextSibling()->GetNextSibling()->GetNextSibling());
+
+	keep->GetNextSibling()->SetRight( NULL);
+	
+    FOR_LOOPNode* forLoop = new FOR_LOOPNode( right, down);
+	forLoop->setLine( getLine());
+
+	down = keep;
+	
+	right = forLoop;
+//   		if( this->GetStatementList() != NULL && right != NULL)
+// 			this->GetStatementList()->GetLastSibling()->KeepRight( right);
+	}
+};
+
+
+
+class FOR_STEP_LOOPNode: public BreakableNode
+{
+  public:
+ RetCode      Run();
+	
+	ProgNodeP GetStatementList()
+	{
+		return down->GetNextSibling();//->GetNextSibling()->GetNextSibling()->GetNextSibling();
+	}
+	
+  public:
+	void KeepRight( ProgNodeP r)
+	{
+		right = r;
+		keepRight = true;
+		if( this->GetStatementList() != NULL)
+			this->GetStatementList()->SetAllBreak( right);
+	}
+  
+  int NumberForLoops( int actNum)
+  {
+	this->forLoopIx = actNum;
+	actNum++;
+	ProgNodeP statementList = this->GetStatementList();
+	if( statementList != NULL && !down->KeepRight())
+		{
+			actNum = statementList->NumberForLoops( actNum);
+		}
+	if( right != NULL && !keepRight)
+		{
+			actNum = right->NumberForLoops( actNum);
+		}
+	return actNum;
+ }
+  
+  public:
+  FOR_STEP_LOOPNode( ProgNodeP r, ProgNodeP d): BreakableNode()
+  {
+    SetType( GDLTokenTypes::FOR_STEP_LOOP, "for_step_loop");
+	SetRightDown( r, d);
+
+	assert( down != NULL);
+	
+	ProgNodeP statementList = this->GetStatementList();
+	if( statementList != NULL)
+		{
+			statementList->SetAllContinue( this);
+			statementList->GetLastSibling()->KeepRight( this);
+			if( right != NULL) statementList->SetAllBreak( right);
+		}
+	else
+		{
+			down->KeepRight( this);
+		}
+  }
+
+};
+
+
+
+class FOR_STEPNode: public BreakableNode
+{
+  public:
+ RetCode      Run();
+	
+	void KeepRight( ProgNodeP r);
+	
+  int NumberForLoops( int actNum)
+  {
+	this->forLoopIx = actNum;
+	
+	//assert( down == NULL);
+		
+	assert( right != NULL && !keepRight);
+			
+	actNum = right->NumberForLoops( actNum);
+	
+	return actNum;
+ }
+  
+  public:
+  FOR_STEPNode(): BreakableNode()  {}
+
+  FOR_STEPNode( const RefDNode& refNode): BreakableNode( refNode)
+	{
+	ProgNodeP keep = down->GetNextSibling();
+	down->SetRight( down->GetNextSibling()->GetNextSibling()->GetNextSibling()->GetNextSibling());
+
+	keep->GetNextSibling()->GetNextSibling()->SetRight( NULL);
+	
+    FOR_STEP_LOOPNode* forLoop = new FOR_STEP_LOOPNode( right, down);
+	forLoop->setLine( getLine());
+
+	down = keep;
+	
+	right = forLoop;
+
+//   		if( this->GetStatementList() != NULL && right != NULL)
+// 			this->GetStatementList()->GetLastSibling()->KeepRight( right);
+	}
+};
+
+class FOREACH_LOOPNode: public BreakableNode
+{
+  public:
+ RetCode      Run();
+	
+	ProgNodeP GetStatementList()
+	{
+		return down->GetNextSibling();
+	}
+	
+  public:
+	void KeepRight( ProgNodeP r)
+	{
+		right = r;
+		keepRight = true;
+		if( this->GetStatementList() != NULL)
+			this->GetStatementList()->SetAllBreak( right);
+	}
+  
+  int NumberForLoops( int actNum)
+  {
+	this->forLoopIx = actNum;
+	actNum++;
+	ProgNodeP statementList = this->GetStatementList();
+	if( statementList != NULL && !down->KeepRight())
+		{
+			actNum = statementList->NumberForLoops( actNum);
+		}
+	if( right != NULL && !keepRight)
+		{
+			actNum = right->NumberForLoops( actNum);
+		}
+	return actNum;
+ }
+  
+  public:
+  FOREACH_LOOPNode( ProgNodeP r, ProgNodeP d): BreakableNode()
+  {
+    SetType( GDLTokenTypes::FOREACH_LOOP, "foreach_loop");
+	SetRightDown( r, d);
+
+	assert( down != NULL);
+	
+	ProgNodeP statementList = this->GetStatementList();
+	if( statementList != NULL)
+		{
+			statementList->SetAllContinue( this);
+			statementList->GetLastSibling()->KeepRight( this);
+			if( right != NULL) statementList->SetAllBreak( right);
+		}
+	else
+		{
+			down->KeepRight( this);
+		}
+  }
+
+};
+
+
+
+class FOREACHNode: public BreakableNode
+{
+  public:
+ RetCode      Run();
+	
+	void KeepRight( ProgNodeP r);
+	
+  int NumberForLoops( int actNum)
+  {
+	this->forLoopIx = actNum;
+	
+// 	assert( down == NULL);
+		
+	assert( right != NULL && !keepRight);
+			
+	actNum = right->NumberForLoops( actNum);
+	
+	return actNum;
+ }
+  
+  public:
+  FOREACHNode(): BreakableNode()  {}
+
+  FOREACHNode( const RefDNode& refNode): BreakableNode( refNode)
+  {
+	ProgNodeP keep = down->GetNextSibling();
+	down->SetRight( down->GetNextSibling()->GetNextSibling());
+
+	keep->SetRight( NULL);
+
+	FOREACH_LOOPNode* forLoop = new FOREACH_LOOPNode( right, down);
+	forLoop->setLine( getLine());
+
+	down = keep;
+
+	right = forLoop;
+ }
+};
+
+
+
+class WHILENode: public BreakableNode
+{
+  public:
+ RetCode      Run();
+	
+	ProgNodeP GetStatementList()
+	{
+		return down->GetNextSibling();
+	}
+	
+	void KeepRight( ProgNodeP r)
+	{
+		right = r;
+		keepRight = true;
+		if( this->GetStatementList() != NULL)
+			this->GetStatementList()->SetAllBreak( right);
+	}
+  
+  public:
+  WHILENode(): BreakableNode()  {}
+
+  WHILENode( const RefDNode& refNode): BreakableNode( refNode)
+  {
+	assert( down != NULL);
+  
+// 	down->GetLastSibling()->KeepRight( this); // for empty body
+	
+	ProgNodeP statementList = this->GetStatementList();
+	if( statementList != NULL)
+		{
+			statementList->SetAllContinue( this);
+			if( right != NULL) statementList->SetAllBreak( right);
+			statementList->GetLastSibling()->KeepRight( this); // for empty body
+		}
+  }
+};
+
+
+
+class REPEAT_LOOPNode: public BreakableNode
+{
+  public:
+ RetCode      Run();
+	
+	ProgNodeP GetStatementList()
+	{
+		return down->GetNextSibling();
+	}
+	
+  public:
+	void KeepRight( ProgNodeP r)
+	{
+		right = r;
+		keepRight = true;
+		if( this->GetStatementList() != NULL)
+			this->GetStatementList()->SetAllBreak( right);
+	}
+  
+  public:
+  REPEAT_LOOPNode( ProgNodeP r, ProgNodeP d): BreakableNode()
+  {
+    SetType( GDLTokenTypes::REPEAT_LOOP, "repeat_loop");
+	SetRightDown( r, d);
+
+	assert( down != NULL);
+	
+	ProgNodeP statementList = this->GetStatementList();
+	if( statementList != NULL)
+		{
+			statementList->SetAllContinue( this);
+			statementList->GetLastSibling()->KeepRight( this);
+			if( right != NULL) statementList->SetAllBreak( right);
+		}
+  }
+
+};
+
+
+
+class REPEATNode: public BreakableNode
+{
+  public:
+ RetCode      Run();
+	
+	void KeepRight( ProgNodeP r)
+	{
+		right = r;
+		keepRight = true;
+		down->KeepRight( right); // REPEAT_LOOP
+	}
+
+public:
+  REPEATNode(): BreakableNode()  {}
+
+  REPEATNode( const RefDNode& refNode): BreakableNode( refNode)
+  {
+    REPEAT_LOOPNode* repeatLoop = new REPEAT_LOOPNode( NULL, down);
+	repeatLoop->KeepRight( right);
+	repeatLoop->setLine( getLine());
+	
+	down = repeatLoop;
+  }
+};
+
+
+
+class CASENode: public BreakableNode
+{
+  public:
+ RetCode      Run();
+  
+	ProgNodeP GetStatementList()
+	{
+		return down->GetNextSibling();
+	}
+	
+	void KeepRight( ProgNodeP r)
+	{
+		assert( down != NULL);
+		right = r;
+		keepRight = true;
+		// down is expr
+		ProgNodeP csBlock = GetStatementList();
+		while( csBlock != NULL)
+		{
+			if( csBlock->getType() == GDLTokenTypes::ELSEBLK)
+				{
+					ProgNodeP statementList = csBlock->GetFirstChild();
+					if( statementList != NULL)
+					{
+							statementList->GetLastSibling()->KeepRight( right);
+					}
+				}
+			else
+				{
+					// keep expr in case of empty statement
+					ProgNodeP statementList = csBlock->GetFirstChild()->GetNextSibling();
+					if( statementList != NULL)
+					{
+							statementList->GetLastSibling()->KeepRight( right);
+					}
+				}
+			csBlock = csBlock->GetNextSibling();
+		}
+		GetStatementList()->SetAllBreak( right);
+	}
+
+public:
+  CASENode(): BreakableNode()  {}
+
+  CASENode( const RefDNode& refNode): BreakableNode( refNode)
+  {
+    assert( down != NULL);
+	
+	ProgNodeP statementList = this->GetStatementList();
+	statementList->SetAllBreak( right);
+
+    // down is expr
+    ProgNodeP csBlock = GetStatementList();
+
+	while( csBlock != NULL)
+	{
+		if( csBlock->getType() == GDLTokenTypes::ELSEBLK)
+			{
+				ProgNodeP statementList = csBlock->GetFirstChild();
+				if( statementList != NULL)
+				{
+						statementList->GetLastSibling()->KeepRight( right);
+				}
+			}
+		else
+			{
+				// keep expr in case of empty statement
+				ProgNodeP statementList = csBlock->GetFirstChild()->GetNextSibling();
+				if( statementList != NULL)
+				{
+						statementList->GetLastSibling()->KeepRight( right);
+				}
+			}
+		
+// 		if( csBlock->GetNextSibling() == NULL)
+// 		{
+// 				csBlock->KeepRight( right);
+// 				break;
+// 		}
+		
+		csBlock = csBlock->GetNextSibling();
+	}
+  }
+};
+
+
+
+class SWITCHNode: public BreakableNode
+{
+  public:
+ RetCode      Run();
+  
+	ProgNodeP GetStatementList()
+	{
+		return down->GetNextSibling();
+	}
+
+  void KeepRight( ProgNodeP r)
+  {
+	right = r;
+	keepRight = true;
+    ProgNodeP csBlock = GetStatementList();
+	ProgNodeP lastStatementList = NULL;
+	while( csBlock != NULL)
+	{
+		if( csBlock->getType() == GDLTokenTypes::ELSEBLK)
+			{
+				ProgNodeP statementList = csBlock->GetFirstChild();
+				if( statementList != NULL)
+				{
+					lastStatementList = statementList;
+				}
+			}
+		else
+			{
+				// keep expr in case of empty statement
+				ProgNodeP statementList = csBlock->GetFirstChild()->GetNextSibling();
+				if( statementList != NULL)
+				{
+					lastStatementList = statementList;
+				}
+			}
+		csBlock = csBlock->GetNextSibling();
+	}
+	if( lastStatementList != NULL)
+		lastStatementList->GetLastSibling()->KeepRight( right);
+	GetStatementList()->SetAllBreak( right);
+ } 
+	
+public:
+  SWITCHNode(): BreakableNode()  {}
+
+  SWITCHNode( const RefDNode& refNode): BreakableNode( refNode)
+  {
+    assert( down != NULL);
+
+	ProgNodeP statementList = this->GetStatementList();
+	statementList->SetAllBreak( right);
+ 
+    // down is expr
+    ProgNodeP csBlock = GetStatementList();
+
+	ProgNodeP lastStatementList = NULL;
+
+	while( csBlock != NULL)
+	{
+		if( csBlock->getType() == GDLTokenTypes::ELSEBLK)
+			{
+				ProgNodeP statementList = csBlock->GetFirstChild();
+				if( statementList != NULL)
+				{
+					if( lastStatementList != NULL)
+						lastStatementList->GetLastSibling()->KeepRight( statementList);
+						
+					lastStatementList = statementList;
+				}
+			}
+		else
+			{
+				// keep expr in case of empty statement
+				ProgNodeP statementList = csBlock->GetFirstChild()->GetNextSibling();
+				if( statementList != NULL)
+				{
+					if( lastStatementList != NULL)
+						lastStatementList->GetLastSibling()->KeepRight( statementList);
+						
+					lastStatementList = statementList;
+				}
+			}
+		if( csBlock->GetNextSibling() == NULL)
+		{
+				if( lastStatementList != NULL)
+					lastStatementList->GetLastSibling()->KeepRight( right);
+				break;
+		}
+		csBlock = csBlock->GetNextSibling();
+	}
+  }
+
+};
+
+
+
+class BLOCKNode: public ProgNode
+{
+  public:
+ RetCode      Run();
+	
+  void KeepRight( ProgNodeP r)
+  {
+	right = r;
+	keepRight = true;
+	// 	must recursively set dependents here
+     if( down != NULL && !KeepDown())
+		down->GetLastSibling()->KeepRight( right);
+	else
+		this->KeepDown( right);
+ }
+
+public:
+  BLOCKNode(): ProgNode()  {}
+
+  BLOCKNode( const RefDNode& refNode): ProgNode( refNode)
+  {
+    if( refNode->GetFirstChild() != RefDNode(antlr::nullAST))
+      {
+		down = NewProgNode( refNode->GetFirstChild());
+      }
+    if( refNode->GetNextSibling() != RefDNode(antlr::nullAST))
+      {
+		right = NewProgNode( refNode->GetNextSibling());
+     
+		// first statement
+		if( down != NULL)
+			down->GetLastSibling()->KeepRight( right);
+		else
+			this->KeepDown( right);
+      }
+  }
+
+};
+
+
+
+class IFNode: public ProgNode
+{
+  public:
+ RetCode      Run();
+  
+  void KeepRight( ProgNodeP r)
+  {
+    assert( down != NULL);
+	right = r;
+	keepRight = true;
+	down->GetLastSibling()->KeepRight( right);
+  }
+public:
+  IFNode(): ProgNode()  {}
+
+  IFNode( const RefDNode& refNode): ProgNode( refNode)
+  {
+		if( refNode->GetFirstChild() != RefDNode(antlr::nullAST))
+		{
+			down = NewProgNode( refNode->GetFirstChild());
+		}
+		if( refNode->GetNextSibling() != RefDNode(antlr::nullAST))
+		{
+			right = NewProgNode( refNode->GetNextSibling());
+		}
+
+		assert( down != NULL);
+
+        // first alternative
+        if( right != NULL)
+        {
+			ProgNodeP s1 = down->GetNextSibling(); // skip expr
+			s1->GetLastSibling()->KeepRight( right);
+        }
+  }
+};
+
+
+
+class IF_ELSENode: public ProgNode
+{
+  public:
+ RetCode      Run();
+  
+  void KeepRight( ProgNodeP r)
+  {
+    // 	must recursively set dependents here
+    assert( down != NULL);
+     
+	right = r;
+	keepRight = true;
+        
+	ProgNodeP s1 = down->GetNextSibling(); // skip expr
+	if( s1->GetFirstChild() == NULL || s1->KeepDown())
+			{
+				s1->KeepDown( right);
+			}
+	else
+			{
+				s1->GetFirstChild()->GetLastSibling()->KeepRight( right);
+			}
+		
+	// 2nd alternative
+	ProgNodeP s2 = s1->GetNextSibling();
+	s2->GetLastSibling()->KeepRight( right); 
+  }
+
+public:
+  IF_ELSENode(): ProgNode()  {}
+
+  IF_ELSENode( const RefDNode& refNode): ProgNode( refNode)
+  {
+// 	std::cout << "IF_ELSENode" << std::endl;
+    if( refNode->GetFirstChild() != RefDNode(antlr::nullAST))
+      {
+		down = NewProgNode( refNode->GetFirstChild());
+      }
+    if( refNode->GetNextSibling() != RefDNode(antlr::nullAST))
+      {
+		right = NewProgNode( refNode->GetNextSibling());
+      }
+
+    assert( down != NULL);
+
+		// IF expr s1 s2
+		// first alternative
+		// s1 is always a BLOCK (gdlc.tree.g, if_statement)
+	// right MUST be set here even if NULL as it IS set to 2nd alternative
+	ProgNodeP s1 = down->GetNextSibling(); // skip expr
+	if( s1->GetFirstChild() == NULL || s1->KeepDown())
+		{
+			s1->KeepDown( right);
+		}
+	else
+		{
+			s1->GetFirstChild()->GetLastSibling()->KeepRight( right);
+		}
+		
+    if( right != NULL)
+    {
+		// 2nd alternative
+		ProgNodeP s2 = s1->GetNextSibling();
+
+		s2->GetLastSibling()->KeepRight( right); // disconnect s2
+	}
+  }
+};
+
 //#undef UNDEF
 //#ifdef UNDEF
 class EnvBaseT;
@@ -253,71 +1274,60 @@
 {
 public:
   ASSIGNNode( const RefDNode& refNode): CommandNode( refNode) {}
-  void Run();
+  RetCode Run();
+};
+class ASSIGN_ARRAYEXPR_MFCALLNode: public CommandNode
+{
+public:
+  ASSIGN_ARRAYEXPR_MFCALLNode( const RefDNode& refNode): CommandNode( refNode) {}
+  RetCode Run();
 };
 class ASSIGN_REPLACENode: public CommandNode
 {
 public:
   ASSIGN_REPLACENode( const RefDNode& refNode): CommandNode( refNode) {}
-  void Run();
+  RetCode Run();
 };
 class PCALL_LIBNode: public CommandNode
 {
 public:
   PCALL_LIBNode( const RefDNode& refNode): CommandNode( refNode) {}
-  void Run();
+  RetCode Run();
 };
 class MPCALLNode: public CommandNode
 {
 public:
   MPCALLNode( const RefDNode& refNode): CommandNode( refNode) {}
-  void Run();
+  RetCode Run();
 };
 class MPCALL_PARENTNode: public CommandNode
 {
 public:
   MPCALL_PARENTNode( const RefDNode& refNode): CommandNode( refNode) {}
-  void Run();
+  RetCode Run();
 };
 class PCALLNode: public CommandNode
 {
 public:
   PCALLNode( const RefDNode& refNode): CommandNode( refNode) {}
-  void Run();
+  RetCode Run();
 };
 class DECNode: public CommandNode
 { public:
   DECNode( const RefDNode& refNode): CommandNode( refNode){}
-  void Run();
+  RetCode Run();
 };
 class INCNode: public CommandNode
 { public:
   INCNode( const RefDNode& refNode): CommandNode( refNode){}
-  void Run();
+  RetCode Run();
+};
+
+class ARRAYEXPRNode: public DefaultNode
+{
+public:
+ ARRAYEXPRNode( const RefDNode& refNode): DefaultNode( refNode) {}
+ BaseGDL* Eval(); // caller receives ownership
 };
-// class FOR_INITNode: public CommandNode
-// { public:
-//   FOR_INITNode( const RefDNode& refNode): CommandNode( refNode){}
-//   void Run();
-// };
-// class FORNode: public CommandNode
-// { public:
-//   FORNode( const RefDNode& refNode): CommandNode( refNode){}
-//   void Run();
-// };
-// class FOR_STEPNode: public CommandNode
-// { public:
-//   FOR_STEPNode( const RefDNode& refNode): CommandNode( refNode){}
-//   void Run();
-// };
-
-
-// class ARRAYDEFNode: public CommandNode
-// {
-// public:
-//   /*virtual*/ RetCode   Run();
-// 
-// };
-//#endif
 
 #endif
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/pythongdl.cpp cvs/gdl/src/pythongdl.cpp
--- gdl-0.9rc4/src/pythongdl.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/pythongdl.cpp	2010-04-16 11:22:54.000000000 -0600
@@ -43,6 +43,14 @@
 
 //#include <numarray/numarray.h>
 
+#include "gdleventhandler.hpp"
+
+// SA fix based on:
+// http://synopsis.fresco.org/viewsvn/Synopsis/branches/Synopsis_0_8/src/Synopsis/Python/Object.hh?r2=1792&rev=1792&r1=1657&sortdir=down
+#if PY_VERSION_HEX < 0x02050000
+  typedef int Py_ssize_t;
+#endif
+
 void LibInit(); // defined in libinit.cpp
 
 using namespace std;
@@ -176,7 +184,7 @@
   if( kwDict != NULL)
     {
       PyObject *key, *value;
-      int dictPos = 0;
+      Py_ssize_t dictPos = 0;
       
       int nKW = PyDict_Size( kwDict);
 
@@ -242,7 +250,7 @@
   if( kwDict != NULL)
     {
       PyObject *key, *value;
-      int dictPos = 0;
+      Py_ssize_t dictPos = 0;
 
       int nKW = PyDict_Size( kwDict);
       for( SizeT k=0; k<nKW; ++k)
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/read.cpp cvs/gdl/src/read.cpp
--- gdl-0.9rc4/src/read.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/read.cpp	2010-07-07 14:41:02.344005024 -0600
@@ -26,6 +26,7 @@
 #include "basic_pro.hpp"
 #include "objects.hpp"
 #include "FMTIn.hpp"
+#include "dinterpreter.hpp"
 
 namespace lib {
   
@@ -61,7 +62,10 @@
 
        	if (sockNum == -1) {
 	  // *** File Read *** //
-	  is = &fileUnits[ lun-1].IStream();
+	  if( fileUnits[ lun-1].Compress())
+		is = &fileUnits[ lun-1].IgzStream();
+	  else
+		is = &fileUnits[ lun-1].IStream();
 
 	} else {
 	  //  *** Socket Read *** //
@@ -140,6 +144,8 @@
 	int nParam = e->NParam();
 	if( nParam == parOffset) return; 
       
+	ostringstream oss;
+      
 	BaseGDL* parIn;
 	for( SizeT i=parOffset; i<nParam; i++)
 	  {
@@ -147,33 +153,38 @@
             if( (*par) != NULL)
 	      {
                 if( e->GlobalPar( i))
-		  { // defined global
+				{ // defined global
                     parIn = *par;
-		  }
+				}
                 else
-		  { // defined local
-                    if( prompt != NULL)
-		      { // prompt keyword there -> error
-                        throw GDLException( e->CallingNode(),
-					    "Expression must be named variable "
-					    "in this context: "+e->GetParString( i));
-		      }
-                    else
-		      { // prompt not there -> put out or ignore
-                        if( is == &cin) 
-			  {
-			    (*par)->ToStream( cout);
-			    cout << flush;
-			    noPrompt = false;
-			  }
-			continue;
-		      }
-		  }
+				{ // defined local
+					if( prompt != NULL)
+					{ // prompt keyword there -> error
+								throw GDLException( e->CallingNode(),
+								"Expression must be named variable "
+								"in this context: "+e->GetParString( i));
+					}
+					else
+					{ // prompt not there -> put out or ignore
+					if( is == &cin)
+						{
+							(*par)->ToStream( oss);
+							actualPrompt = oss.str();
+#ifdef HAVE_LIBREADLINE
+							cout << flush;
+#else
+							cout << oss.str() << flush;
+#endif
+							noPrompt = false;
+						}
+					continue;
+					}
+				}
 	      }
             else
 	      { // undefined
                 if( e->LocalPar( i))
-		  throw GDLException( e->CallingNode(),
+					throw GDLException( e->CallingNode(),
 				      "Internal error: Input: UNDEF is local.");
 
                 (*par) = new DFloatGDL( 0.0);
@@ -181,16 +192,71 @@
 	      }
 
 	    if( is == &cin && noPrompt)
-	      if( prompt != NULL) 
-		{
-		  prompt->ToStream( cout);
-		  cout << flush;
-		}
-	      else 
+			if( prompt != NULL)
+			{
+				prompt->ToStream( oss);
+			    actualPrompt = oss.str();
+#ifdef HAVE_LIBREADLINE
+				cout << flush;
+#else
+ 				cout << oss.str() << flush;
+#endif
+			}
+			else
+			{
+				actualPrompt = ": ";
+#ifdef HAVE_LIBREADLINE
+				cout << flush;
+#else
+ 				cout << ": " << flush;
+#endif
+			}
+		
+#ifdef HAVE_LIBREADLINE
+		if( is == &cin  && isatty(0))
 		{
-		  cout << ": " << flush;
+			string line;
+			string strTrimLine;
+
+			int edit_input = SysVar::Edit_Input();// && isatty(0);
+
+ 			do {
+				char *cline;
+
+				lineEdit = true;
+
+				if( edit_input != 0)
+					cline = readline(actualPrompt.c_str());
+				else
+					cline = e->Interpreter()->NoReadline(actualPrompt.c_str());
+
+				lineEdit = false;
+
+				if( !cline)
+					{
+// 						if (isatty(0))
+						cout << endl;
+						e->Throw("Error encountered reading from: Unit: 0, <stdin> (redirected).");
+					}
+				else
+					// make a string
+					line = cline;
+
+				free(cline);        // done here for compatibility with readline
+
+				strTrimLine = line;
+				StrTrim(strTrimLine); 
+ 			} while( strTrimLine == "" && parIn->Type() != STRING);
+			
+			istringstream iss( line + "\n");
+			parIn->FromStream( iss);
+				
+			if( sigControlC)
+				return;
 		}
-	    parIn->FromStream( *is);
+		else
+#endif
+			parIn->FromStream( *is);
 	  }
       }
   }
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/sigfpehandler.cpp cvs/gdl/src/sigfpehandler.cpp
--- gdl-0.9rc4/src/sigfpehandler.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/sigfpehandler.cpp	2010-04-16 11:22:54.000000000 -0600
@@ -18,6 +18,7 @@
 #include "includefirst.hpp"
 
 #include <csetjmp>
+#include <csignal>
 
 #include "gdlexception.hpp"
 
@@ -29,6 +30,7 @@
 // and intager modulo division by zero
 void SigFPEHandler( int signo) 
 {
+  signal(SIGFPE,SigFPEHandler);
   Warning( "Program caused arithmetic error: Integer divide by 0");
   siglongjmp( sigFPEJmpBuf,-1);
 } 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/specializations.hpp cvs/gdl/src/specializations.hpp
--- gdl-0.9rc4/src/specializations.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/specializations.hpp	2010-04-22 09:50:41.000000000 -0600
@@ -245,10 +245,10 @@
 Data_<SpDObj>* Data_<SpDObj>::Pow( BaseGDL* r);
 template<> 
 Data_<SpDObj>* Data_<SpDObj>::PowInv( BaseGDL* r);
-template<> 
-Data_<SpDString>* Data_<SpDString>::MatrixOp( BaseGDL* r);
-template<> 
-Data_<SpDPtr>* Data_<SpDPtr>::MatrixOp( BaseGDL* r);
+template<>
+Data_<SpDString>* Data_<SpDString>::MatrixOp( BaseGDL* r,bool t,bool tr, bool s);
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::MatrixOp( BaseGDL* ,bool t,bool tr,bool s);
 template<> 
 Data_<SpDByte>* Data_<SpDFloat>::LogNeg();
 template<> 
@@ -323,10 +323,16 @@
 template<> 
 bool Data_<SpDComplex>::ForCondUp( BaseGDL*);
 template<> 
+bool Data_<SpDComplex>::ForAddCondUp( BaseGDL* loopInfo);
+// bool Data_<SpDComplex>::ForAddCondUp( ForLoopInfoT& loopInfo);
+template<>
 bool Data_<SpDComplex>::ForCondDown( BaseGDL*);
 template<> 
+bool Data_<SpDComplexDbl>::ForAddCondUp( BaseGDL* loopInfo);
+// bool Data_<SpDComplexDbl>::ForAddCondUp( ForLoopInfoT& loopInfo);
+template<>
 bool Data_<SpDComplexDbl>::ForCondUp( BaseGDL*);
-template<> 
+template<>
 bool Data_<SpDComplexDbl>::ForCondDown( BaseGDL*);
 template<> 
 void Data_<SpDFloat>::DecAt( ArrayIndexListT* ixList); 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/strassenmatrix.hpp cvs/gdl/src/strassenmatrix.hpp
--- gdl-0.9rc4/src/strassenmatrix.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/strassenmatrix.hpp	2010-04-16 11:22:54.000000000 -0600
@@ -1,7 +1,7 @@
 #ifndef STRASSENMATRIX_HPP__
 #define STRASSENMATRIX_HPP__
 
-//#define USE_STRASSEN_MATRIXMULTIPLICATION
+#define USE_STRASSEN_MATRIXMULTIPLICATION
 
 #ifdef USE_STRASSEN_MATRIXMULTIPLICATION
 
@@ -2069,7 +2069,8 @@
 #pragma omp taskq
 {
   /* p1 = (a11 + a22) x (b11 + b22) */
-#pragma omp task private( subBuf, a_cum, b_cum) default(shared)
+// #pragma omp task private( subBuf, a_cum, b_cum) default(shared)
+#pragma omp task default(shared)
 {
   T* subBuf = new T[ 5 * n_22];
   T* a_cum = subBuf + 3 * n_22;
@@ -2093,7 +2094,8 @@
 }
 
   /* p4 = a22 x (b21 - b11) */
-#pragma omp task private( subBuf, a_cum, b_cum) default(shared)
+// #pragma omp task private( subBuf, a_cum, b_cum) default(shared)
+#pragma omp task default(shared)
 {
   T* subBuf = new T[ 5 * n_22];
   T* a_cum = subBuf + 3 * n_22;
@@ -2113,7 +2115,8 @@
 }
 
   /* p5 = (a11 + a12) x b22 */
-#pragma omp task private( subBuf, a_cum, b_cum) default(shared)
+// #pragma omp task private( subBuf, a_cum, b_cum) default(shared)
+#pragma omp task default(shared)
 {
   T* subBuf = new T[ 5 * n_22];
   T* a_cum = subBuf + 3 * n_22;
@@ -2133,7 +2136,8 @@
 }
 	    
   /* p7 = (a12 - a22) x (b21 + b22) */
-#pragma omp task private( subBuf, a_cum, b_cum) default(shared)
+// #pragma omp task private( subBuf, a_cum, b_cum) default(shared)
+#pragma omp task default(shared)
 {
   T* subBuf = new T[ 5 * n_22];
   T* a_cum = subBuf + 3 * n_22;
@@ -2156,7 +2160,8 @@
 }
 
   /* p2 = (a21 + a22) x b11 */
-#pragma omp task private( subBuf, a_cum, b_cum) default(shared)
+// #pragma omp task private( subBuf, a_cum, b_cum) default(shared)
+#pragma omp task default(shared)
 {
   T* subBuf = new T[ 5 * n_22];
   T* a_cum = subBuf + 3 * n_22;
@@ -2176,7 +2181,8 @@
 }
 	    
   /* p3 = a11 x (b12 - b22) */
-#pragma omp task private( subBuf, a_cum, b_cum) default(shared)
+// #pragma omp task private( subBuf, a_cum, b_cum) default(shared)
+#pragma omp task default(shared)
 {
   T* subBuf = new T[ 5 * n_22];
   T* a_cum = subBuf + 3 * n_22;
@@ -2196,7 +2202,8 @@
 }
 
   /* p6 = (a21 - a11) x (b11 + b12) */
-#pragma omp task private( subBuf, a_cum, b_cum) default(shared)
+// #pragma omp task private( subBuf, a_cum, b_cum) default(shared)
+#pragma omp task default(shared)
 {
   T* subBuf = new T[ 5 * n_22];
   T* a_cum = subBuf + 3 * n_22;
Only in gdl-0.9rc4/src: strassenmatrix.no_c_check.hpp
Only in gdl-0.9rc4/src: strassenmatrix.ok.hpp
Only in gdl-0.9rc4/src: strassenmatrix.rc1.hpp
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/str.cpp cvs/gdl/src/str.cpp
--- gdl-0.9rc4/src/str.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/str.cpp	2010-07-07 14:41:02.348004615 -0600
@@ -24,7 +24,12 @@
 extern "C" {
 #endif
 
-#include <wordexp.h>
+// quoting http://permalink.gmane.org/gmane.os.openbsd.tech/19860 :
+// 'wordexp() will never be in OpenBSD's libc' :)
+// (TODO: perhaps better to implement it using HAVE_WORDEXP_H? + once more below in WordExp())
+#if !defined(__OpenBSD__)
+#  include <wordexp.h>
+#endif
 
 #ifdef __CYGWIN__
 }
@@ -88,12 +93,21 @@
 
   return res;
 }
-
+//#define STRMID_DEBUG 
 string StrMid(const string& s, long first, long len, bool reverse)
 {
-  // (long)string::npos == -1
-  if( len != string::npos && len <= 0) return string("");
+#ifdef STRMID_DEBUG
+cout << "DebugInfo: StrMid(\"" << s << "\"," << first <<","<<len<<","<<reverse<<") = ";//<<endl
+#endif
 
+  // (long)string::npos == -1
+  if( len != string::npos && len <= 0)
+  {
+#ifdef STRMID_DEBUG
+	cout << "." << endl;
+#endif
+	return string("");
+  }
   long strLen = s.length();
   if( reverse)
     {
@@ -104,6 +118,9 @@
   if( first >= strLen) return string("");
   if( first < 0) first = 0; 
 
+#ifdef STRMID_DEBUG
+	cout << s.substr( first, len)<<"." << endl;
+#endif
   return s.substr( first, len);
 }
 
@@ -227,17 +244,19 @@
 
 void WordExp( string& s)
 {
+#if !defined(__OpenBSD__)
   wordexp_t p;
   int ok0 = wordexp( s.c_str(), &p, 0);
   if( ok0 == 0) 
     {
       if( p.we_wordc > 0)
 	s = p.we_wordv[0];
-#if defined(__APPLE__)
+#  if defined(__APPLE__)
       p.we_offs = 0;
-#endif
+#  endif
       wordfree( &p);
     }
+#endif
 }
 
 // Tries to find file "fn" along GDLPATH.
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/typedefs.hpp cvs/gdl/src/typedefs.hpp
--- gdl-0.9rc4/src/typedefs.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/typedefs.hpp	2010-05-21 10:23:58.975905747 -0600
@@ -58,8 +58,11 @@
 
 #if defined(HAVE_64BIT_OS)
 typedef unsigned long long int      SizeT;
+typedef long long int RangeT;
+
 #else
 typedef unsigned int        	    SizeT;
+typedef int                            RangeT;
 #endif
 //typedef size_t              SizeT;
 typedef unsigned int        UInt;
@@ -273,42 +276,46 @@
   GDLArray() throw() : buf( NULL), sz( 0) {}
   GDLArray( const GDLArray& cp) : sz( cp.size())
   {
-    try { buf = (cp.size() > smallArraySize) ? new T[ cp.size()] : scalar; }
-    catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than GDL can address"); }
-#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
+    try {
+		buf = (cp.size() > smallArraySize) ? new T[ cp.size()] : scalar;
+    } catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than GDL can address"); }
+/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
 {
-#pragma omp for
+#pragma omp for*/
     for( SizeT i=0; i<sz; ++i)
       buf[ i] = cp.buf[ i];
-}
+// }
   }
 
   GDLArray( SizeT s, bool b) : sz( s)
   {
-    try { buf = (s > smallArraySize) ? new T[ s] : scalar; }
-    catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than GDL can address"); }
+    try {
+    buf = (s > smallArraySize) ? new T[ s] : scalar;
+    } catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than GDL can address"); }
   }
   GDLArray( T val, SizeT s) : sz( s)
   {
-    try { buf = (s > smallArraySize) ? new T[ s] : scalar; }
-    catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than GDL can address"); }
-#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
+    try {
+    buf = (s > smallArraySize) ? new T[ s] : scalar;
+    } catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than GDL can address"); }
+/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
 {
-#pragma omp for
+#pragma omp for*/
     for( SizeT i=0; i<sz; ++i)
       buf[ i] = val;
-}
+// }
   }
   GDLArray( const T* arr, SizeT s) : sz( s)
   {
-    try { buf = (s > smallArraySize) ? new T[ s]: scalar; }
-    catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than GDL can address"); }
-#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
+    try {
+    buf = (s > smallArraySize) ? new T[ s]: scalar;
+    } catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than GDL can address"); }
+/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
 {
-#pragma omp for
+#pragma omp for*/
     for( SizeT i=0; i<sz; ++i)
       buf[ i] = arr[ i];
-}
+// }
   }
 
   explicit GDLArray( const T& s) throw() : /*scalar( s),*/ buf( scalar), sz( 1)
@@ -339,12 +346,12 @@
     //       {
     if( sz == right.size())
       {
-#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
+/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
 {
-#pragma omp for
+#pragma omp for*/
 	for( SizeT i=0; i<sz; ++i)
 	  buf[ i] = right.buf[ i];
-}
+// }
       }
     else
       {
@@ -352,35 +359,35 @@
 	  delete[] buf;
 	sz = right.size();
 	buf = (sz>smallArraySize) ? new T[ sz] : scalar; 
-#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
+/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
 {
-#pragma omp for
+#pragma omp for*/
 	for( SizeT i=0; i<sz; ++i)
 	  buf[ i] = right.buf[ i];
-}
+// }
      }
     //       }
     return *this;
   }
 
-  GDLArray&operator+=( const GDLArray& right) throw()
+  GDLArray& operator+=( const GDLArray& right) throw()
   {
-#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
+/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
 {
-#pragma omp for
+#pragma omp for*/
     for( SizeT i=0; i<sz; ++i)
       buf[ i] += right.buf[ i];
-}
+// }
     return *this;
   }
-  GDLArray&operator-=( const GDLArray& right) throw()
+  GDLArray& operator-=( const GDLArray& right) throw()
   {
-#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
+/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
 {
-#pragma omp for
+#pragma omp for*/
     for( SizeT i=0; i<sz; ++i)
       buf[ i] -= right.buf[ i];
-}
+// }
     return *this;
   }
 //   GDLArray&operator*=( const GDLArray& right) throw()
@@ -395,24 +402,24 @@
 //       buf[ i] /= right.buf[ i]; // can be 0
 //     return *this;
 //   }
-  GDLArray&operator+=( const T& right) throw()
+  GDLArray& operator+=( const T& right) throw()
   {
-#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
+/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
 {
-#pragma omp for
+#pragma omp for*/
     for( SizeT i=0; i<sz; ++i)
       buf[ i] += right;
-}
+// }
     return *this;
   }
-  GDLArray&operator-=( const T& right) throw()
+  GDLArray& operator-=( const T& right) throw()
   {
-#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
+/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
 {
-#pragma omp for
+#pragma omp for*/
     for( SizeT i=0; i<sz; ++i)
       buf[ i] -= right;
-}
+// }
     return *this;
   }
 //   GDLArray&operator*=( const T& right) throw()
@@ -454,12 +461,12 @@
 	try 
         { 
           T* newBuf = new T[ newSz]; 
-#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
+/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
 {
-#pragma omp for
+#pragma omp for*/
 	  for( SizeT i=0; i<sz; ++i)
 	    newBuf[ i] = buf[ i];
-}
+// }
  	  if( buf != scalar)
 	    delete[] buf;
 	  buf = newBuf;
@@ -494,6 +501,8 @@
 //   }
 };
 
+
+
 // friend  GDLArray pow(const GDLArray& left, const GDLArray& right);
 
 // friend  GDLArray pow(const GDLArray& left, const T& right);
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/widget.cpp cvs/gdl/src/widget.cpp
--- gdl-0.9rc4/src/widget.cpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/widget.cpp	2010-06-03 09:06:39.994800801 -0600
@@ -33,6 +33,33 @@
 namespace lib {
   using namespace std;
 
+  void executeString2( EnvBaseT* caller, istringstream *istr)
+  {
+    RefDNode theAST;
+
+    GDLLexer lexer(*istr, "", GDLParser::NONE);
+    GDLParser& parser = lexer.Parser();
+    parser.interactive();
+    theAST = parser.getAST();
+    RefDNode trAST;
+    GDLTreeParser treeParser( caller);
+    treeParser.interactive(theAST);
+    trAST = treeParser.getAST();
+    ProgNodeP progAST = ProgNode::NewProgNode( trAST);
+    auto_ptr< ProgNode> progAST_guard( progAST);
+
+    // necessary for correct FOR loop handling
+    assert( dynamic_cast<EnvUDT*>(caller) != NULL);
+    EnvUDT* env = static_cast<EnvUDT*>(caller);
+    int nForLoopsIn = env->NForLoops();
+    int nForLoops = ProgNode::NumberForLoops( progAST, nForLoopsIn);
+    env->ResizeForLoops( nForLoops);
+    env->ResizeForLoops( nForLoopsIn);
+
+    RetCode retCode = caller->Interpreter()->execute( progAST);
+  }
+
+
   BaseGDL* widget_base( EnvT* e)
   {
     SizeT nParam = e->NParam();
@@ -131,7 +158,7 @@
     if ( e->KeywordPresent( mapIx))
       if ( !e->KeywordSet( mapIx))
 	mapWid = false;
-    std::cout << "Map in widget_base: " << mapWid << std::endl;
+    //    std::cout << "Map in widget_base: " << mapWid << std::endl;
 
     bool no_copy = e->KeywordSet( no_copyIx);
     bool scroll = e->KeywordSet( scrollIx);
@@ -316,10 +343,50 @@
 
     button->SetWidgetType( "BUTTON");
 
+    button->SetButtonOff();
+
     return new DLongGDL( button->WidgetID());
   }
 
 
+  // WIDGET_DROPLIST
+  BaseGDL* widget_droplist( EnvT* e)
+  {
+    DLongGDL* p0L = e->GetParAs<DLongGDL>( 0);
+    WidgetIDT parentID = (*p0L)[0];
+    GDLWidget *widget = GDLWidget::GetWidget( parentID);
+
+    DLong xsize = -1;
+    static int xsizeIx = e->KeywordIx( "XSIZE");
+    e->AssureLongScalarKWIfPresent( xsizeIx, xsize);
+
+    static int titleIx = e->KeywordIx( "TITLE");
+    DString title = "";
+    e->AssureStringScalarKWIfPresent( titleIx, title);
+
+    static int valueIx = e->KeywordIx( "VALUE");
+    //    DStringGDL* value = e->IfDefGetKWAs<DStringGDL>( valueIx);
+    BaseGDL* value = e->GetKW( valueIx);
+    if( value != NULL)
+      value = value->Dup();
+
+    static int uvalueIx = e->KeywordIx( "UVALUE");
+    BaseGDL* uvalue = e->GetKW( uvalueIx);
+    if( uvalue != NULL)
+      uvalue = uvalue->Dup();
+
+    GDLWidgetLabel* label = 
+      new GDLWidgetLabel( parentID, uvalue, title, xsize);
+
+    DLong style = wxCB_READONLY;
+    GDLWidgetDropList* droplist = new GDLWidgetDropList( parentID, uvalue, value,
+							 title, xsize, style);
+    droplist->SetWidgetType( "DROPLIST");
+
+    return new DLongGDL( droplist->WidgetID());
+  }
+
+
   // WIDGET_TEXT
   BaseGDL* widget_text( EnvT* e)
   {
@@ -551,8 +618,8 @@
     DLong select;
     //    int i; cin >> i;
 
-    while ( 1) {
-      std::cout << "In PollEvents loop" << std::endl;
+    while ( 1) { // outer while loop
+      std::cout << "In PollEvents loop (widget_event)" << std::endl;
       while ( 1) {
 	// Sleep a bit to prevent CPU overuse
 	wxMilliSleep( 50);
@@ -560,7 +627,7 @@
 	  break;
       }
 
-      std::cout << "break from PollEvents" << std::endl;
+      std::cout << "break from PollEvents (widget_event)" << std::endl;
       std::cout << "top: " << top << std::endl;
       std::cout << "id:  " << id << std::endl;
 
@@ -587,9 +654,12 @@
 	delete e;
       }
 
+      executeString2( caller, &istr);
+
+      /*
       RefDNode theAST;
 
-      GDLLexer lexer(istr, "");
+      GDLLexer lexer(istr, "", GDLParser::NONE);
       GDLParser& parser = lexer.Parser();
       parser.interactive();
 
@@ -602,11 +672,22 @@
       ProgNodeP progAST = ProgNode::NewProgNode( trAST);
       auto_ptr< ProgNode> progAST_guard( progAST);
 
-      GDLInterpreter::RetCode retCode = 
+      // necessary for correct FOR loop handling
+      assert( dynamic_cast<EnvUDT*>(caller) != NULL);
+      EnvUDT* env = static_cast<EnvUDT*>(caller);
+      int nForLoopsIn = env->NForLoops();
+      int nForLoops = ProgNode::NumberForLoops( progAST, nForLoopsIn);
+      env->ResizeForLoops( nForLoops);
+
+      RetCode retCode =
 	caller->Interpreter()->execute( progAST);
 
+	env->ResizeForLoops( nForLoopsIn);
+      */
+
       // Return from GDL/IDL event handler procedure
-      std::cout << "return from event handler" << std::endl << std::endl;
+      std::cout << "return from event handler (widget_event)" << 
+	std::endl << std::endl;
 
       if ( GDLWidget::GetWidget( top) == NULL) {
 	std::cout << "widget NULLed" << std::endl;
@@ -619,7 +700,8 @@
       buttonWidget->SetManaged( false);
 
       lasttop = top;
-    }
+    } // outer while loop
+
     return new DLongGDL( 0);
   }
 
@@ -663,6 +745,27 @@
     static int setvalueIx = e->KeywordIx( "SET_VALUE");
     bool setvalue = e->KeywordPresent( setvalueIx);
 
+    static int getvalueIx = e->KeywordIx( "GET_VALUE");
+    bool getvalue = e->KeywordPresent( getvalueIx);
+
+    static int setunameIx = e->KeywordIx( "SET_UNAME");
+    bool setuname = e->KeywordPresent( setunameIx);
+    DString uname = "";
+    e->AssureStringScalarKWIfPresent( setunameIx, uname);
+
+    static int prosetvalueIx = e->KeywordIx( "PRO_SET_VALUE");
+    bool prosetvalue = e->KeywordPresent( prosetvalueIx);
+    DString setvaluepro = "";
+    e->AssureStringScalarKWIfPresent( prosetvalueIx, setvaluepro);
+
+    static int funcgetvalueIx = e->KeywordIx( "FUNC_GET_VALUE");
+    bool funcgetvalue = e->KeywordPresent( funcgetvalueIx);
+    DString setvaluefunc = "";
+    e->AssureStringScalarKWIfPresent( funcgetvalueIx, setvaluefunc);
+
+    static int setbuttonIx = e->KeywordIx( "SET_BUTTON");
+    bool setbutton = e->KeywordPresent( setbuttonIx);
+
     if ( realize) {
       widget->Realize( map);
     }
@@ -672,6 +775,7 @@
     }
 
     if ( xmanActCom) {
+      cout << "Set xmanager active command: " << widgetID << endl;
       widget->SetXmanagerActiveCommand();
     }
 
@@ -685,56 +789,160 @@
       widget->SetEventPro( eventPro);
     }
 
+
     if ( getuvalue) {
       BaseGDL** uvalueKW = &e->GetKW( getuvalueIx);
       delete (*uvalueKW);
 
-      *uvalueKW = widget->GetUvalue();
+      BaseGDL *widval = widget->GetUvalue();
+      //      *uvalueKW = widget->GetUvalue();
+      *uvalueKW = widval->Dup();
+
+      /*
       if ( *uvalueKW != NULL) {
 	if( (*uvalueKW)->Type() == STRING)
 	  *uvalueKW = new DStringGDL( (*( DStringGDL*) (*uvalueKW))[0]);
 	if( (*uvalueKW)->Type() == LONG)
 	  *uvalueKW = new DLongGDL( (*( DLongGDL*) (*uvalueKW))[0]);
+	if( (*uvalueKW)->Type() == STRUCT) {
+	  DStructGDL* s = static_cast<DStructGDL*>( *uvalueKW);
+	  //	  DStructGDL* parStruct = dynamic_cast<DStructGDL*>( *uvalueKW);
+	  cout << s->Desc()->Name() << endl;
+	}
       }
+      */
+
     }
 
     if ( setuvalue) {
       BaseGDL* uvalue = e->GetKW( setuvalueIx);
+      if( uvalue->Type() == STRUCT) {
+	//	cout << "Structure uvalue" << endl;
+	//DStructGDL* s1 = static_cast<DStructGDL*>( uvalue);
+	//cout << s1->Desc()->Name() << endl;
+      }
       if( uvalue != NULL) uvalue = uvalue->Dup();
       widget->SetUvalue( uvalue);
     }
 
+    if ( setuname) {
+      widget->SetUname( uname);
+    }
 
-    if ( setvalue) {
-      DString value = "";
-      e->AssureStringScalarKWIfPresent( setvalueIx, value);
+    if ( prosetvalue) {
+      widget->SetProValue( setvaluepro);
+    }
 
+    if ( funcgetvalue) {
+      widget->SetFuncValue( setvaluefunc);
+    }
+
+    if ( setbutton) {
+      DLong buttonVal;
+      e->AssureLongScalarKWIfPresent( setbuttonIx, buttonVal);
+      if ( buttonVal == 0)
+	widget->SetButtonOff();
+      else
+	widget->SetButtonOn();
+    }
+
+    if ( setvalue) {
       DString wType = widget->GetWidgetType();
+
+      if ( wType == "") {
+	BaseGDL* value = e->GetKW( setvalueIx);
+	if( value != NULL) value = value->Dup();
+
+	DString setProName = widget->GetProValue();
+	if ( setProName != "") {
+
+	  // Build call to SETV procedure
+	  ostringstream ostr;
+	  ostr << setProName.c_str() << ", " << widgetID << ", [";
+
+	  DLongGDL* values = e->IfDefGetKWAs<DLongGDL>( setvalueIx);
+	  DLong nEl = values->N_Elements();
+	  for( SizeT i=0; i<nEl; i++) {
+	    ostr << (*values)[i];
+	    if ( i != (nEl-1)) ostr << ", ";
+	  }
+	  ostr << "]";
+
+	  DString line = ostr.rdbuf()->str();
+	  istringstream istr(line+"\n");
+
+	  // Call SETV procedure
+	  EnvBaseT* caller = e->Caller();
+	  e->Interpreter()->CallStack().pop_back();
+	  executeString2( caller, &istr);
+	}
+
+
+	widget->SetVvalue( value);
+      }
+
       if ( wType == "TEXT") {
-	std::cout << "settextvalue: " << value.c_str() << std::endl;
+	DString value = "";
+	e->AssureStringScalarKWIfPresent( setvalueIx, value);
+	//	std::cout << "settextvalue: " << value.c_str() << std::endl;
 	GDLWidgetText *textWidget = ( GDLWidgetText *) widget;
 	textWidget->SetTextValue( value);
       }
 
       if ( wType == "LABEL") {
-	std::cout << "setlabelvalue: " << value.c_str() << std::endl;
+	DString value = "";
+	e->AssureStringScalarKWIfPresent( setvalueIx, value);
+	//	std::cout << "setlabelvalue: " << value.c_str() << std::endl;
 	GDLWidgetLabel *labelWidget = ( GDLWidgetLabel *) widget;
 	labelWidget->SetLabelValue( value);
       }
     }
-  }
 
+    if ( getvalue) {
+      BaseGDL** valueKW = &e->GetKW( getvalueIx);
+      delete (*valueKW);
+
+      DString getFuncName = widget->GetFuncValue();
+      if ( getFuncName != "") {
+	StackGuard<EnvStackT> guard( e->Interpreter()->CallStack());
+
+	DString callF;
+	// this is a function name -> convert to UPPERCASE
+	callF = getFuncName.c_str();
+	callF = StrUpCase( callF);
+
+	SizeT funIx = GDLInterpreter::GetFunIx( callF);
+	EnvUDT* newEnv= new EnvUDT( e, funList[ funIx], NULL);
+
+	// add parameter
+	newEnv->SetNextPar( new DLongGDL(widgetID)); // pass as local
+	e->Interpreter()->CallStack().push_back( newEnv);
+
+	// make the call
+	BaseGDL* res = e->Interpreter()->
+	  call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
+
+	// set the keyword to the function's return value
+	*valueKW = new DIntGDL( (*( DIntGDL*) (res))[0]);
+      } else {
+	// "Regular" getvalue
+	BaseGDL** valueKW = &e->GetKW( getvalueIx);
+	delete (*valueKW);
+
+	*valueKW = widget->GetVvalue();
+	if ( *valueKW != NULL) {
+	  if( (*valueKW)->Type() == STRING)
+	    *valueKW = new DStringGDL( (*( DStringGDL*) (*valueKW))[0]);
+	  if( (*valueKW)->Type() == LONG)
+	    *valueKW = new DLongGDL( (*( DLongGDL*) (*valueKW))[0]);
+	} else {
+	  DLongGDL* res = new DLongGDL( 0);
+	  *valueKW = res;
+	}
+      }
+    }
+  }
 
 } // namespace
 
 #endif
-
-
-/*
-	// Get Parent Widget
-	GDLWidget *parent = GDLWidget::GetParent( widgetID);
-	DLong nChildren = parent->GetChild( -1);
-	if ( nChildren != 0) {
-	for( SizeT j=0; j<nChildren; j++) {
-	  if (widget->GetChild( j) == widgetID) return new DLongGDL( 1);
-*/
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/src/widget.hpp cvs/gdl/src/widget.hpp
--- gdl-0.9rc4/src/widget.hpp	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/src/widget.hpp	2010-04-16 11:22:54.000000000 -0600
@@ -28,6 +28,7 @@
 
   BaseGDL* widget_base( EnvT* e);
   BaseGDL* widget_button( EnvT* e);
+  BaseGDL* widget_droplist( EnvT* e);
   BaseGDL* widget_text( EnvT* e);
   BaseGDL* widget_label( EnvT* e);
   BaseGDL* widget_info( EnvT* e);
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/checks cvs/gdl/testsuite/checks
--- gdl-0.9rc4/testsuite/checks	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/checks	2010-04-07 10:29:37.000000000 -0600
@@ -0,0 +1,15 @@
+#!/bin/bash
+
+# SA: checking if every .pro file is listed in the Makefile.am
+test \
+  "`fgrep '.pro' Makefile.am | tr '\\' ' ' | tr "\n" ' ' | tr -s ' '`" \
+  = \
+  " `LC_COLLATE=C ls *.pro | tr "\n" ' ' | tr -s ' '`" && exit
+echo "----------------------------------------------------------------"
+echo "REASON: list of .pro files vs. entries in testsuite/Makefile.am:" 
+LC_COLLATE=C ls -1 *.pro \
+  | awk '{ print "  " $0 " \\" }' \
+  | diff /dev/stdin Makefile.am \
+  | fgrep .pro | tr '<' '-' | tr '\\' ' ' | tr -s ' ' 
+echo "----------------------------------------------------------------"
+exit 1
Only in gdl-0.9rc4/testsuite: Makefile
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/Makefile.am cvs/gdl/testsuite/Makefile.am
--- gdl-0.9rc4/testsuite/Makefile.am	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/testsuite/Makefile.am	2010-07-07 14:41:02.729944039 -0600
@@ -1,10 +1,37 @@
 TESTS_ENVIRONMENT = $(top_srcdir)/testsuite/try $(top_srcdir)
 TESTS = \
-  test_zeropoly.pro \
-  test_url.pro \
-  test_multiroots.pro \
   test_angles.pro \
-  test_wavelet.pro \
   test_base64.pro \
   test_constants.pro \
-  test_nestedloop.pro 
+  test_device.pro \
+  test_erfinv.pro \
+  test_fft.pro \
+  test_fft_leak.pro \
+  test_file_basename.pro \
+  test_file_copy.pro \
+  test_file_delete.pro \
+  test_file_dirname.pro \
+  test_file_search.pro \
+  test_fix.pro \
+  test_gc.pro \
+  test_get_screen_size.pro \
+  test_hist_2d.pro \
+  test_idl8.pro \
+  test_interpol.pro \
+  test_memory.pro \
+  test_multiroots.pro \
+  test_nans_in_sort_and_median.pro \
+  test_nestedloop.pro \
+  test_pmulti.pro \
+  test_product.pro \
+  test_readf.pro \
+  test_rebin.pro \
+  test_spher_harm.pro \
+  test_spl_init.pro \
+  test_str_functions.pro \
+  test_suite.pro \
+  test_url.pro \
+  test_wavelet.pro \
+  test_zeropoly.pro \
+  test_zzz.pro \
+  checks
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/Makefile.in cvs/gdl/testsuite/Makefile.in
--- gdl-0.9rc4/testsuite/Makefile.in	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/testsuite/Makefile.in	2010-07-07 14:41:02.743004106 -0600
@@ -34,7 +34,7 @@
 build_triplet = @build@
 host_triplet = @host@
 subdir = testsuite
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+DIST_COMMON = README $(srcdir)/Makefile.am $(srcdir)/Makefile.in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.in
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
@@ -175,14 +175,42 @@
 wxConfig = @wxConfig@
 TESTS_ENVIRONMENT = $(top_srcdir)/testsuite/try $(top_srcdir)
 TESTS = \
-  test_zeropoly.pro \
-  test_url.pro \
-  test_multiroots.pro \
   test_angles.pro \
-  test_wavelet.pro \
   test_base64.pro \
   test_constants.pro \
-  test_nestedloop.pro 
+  test_device.pro \
+  test_erfinv.pro \
+  test_fft.pro \
+  test_fft_leak.pro \
+  test_file_basename.pro \
+  test_file_copy.pro \
+  test_file_delete.pro \
+  test_file_dirname.pro \
+  test_file_search.pro \
+  test_fix.pro \
+  test_gc.pro \
+  test_get_screen_size.pro \
+  test_hist_2d.pro \
+  test_idl8.pro \
+  test_interpol.pro \
+  test_memory.pro \
+  test_multiroots.pro \
+  test_nans_in_sort_and_median.pro \
+  test_nestedloop.pro \
+  test_pmulti.pro \
+  test_product.pro \
+  test_readf.pro \
+  test_rebin.pro \
+  test_spher_harm.pro \
+  test_spl_init.pro \
+  test_str_functions.pro \
+  test_strsplit.pro \
+  test_suite.pro \
+  test_url.pro \
+  test_wavelet.pro \
+  test_zeropoly.pro \
+  test_zzz.pro \
+  checks
 
 all: all-am
 
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/README cvs/gdl/testsuite/README
--- gdl-0.9rc4/testsuite/README	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/README	2010-02-17 04:15:12.000000000 -0700
@@ -0,0 +1,48 @@
+How to add a new test-routine to the automatic "make check" rule:
+--------------------------------------------------------------------
+
+The list of GDL routines to be executed during the make-check run
+is defined (implicitly, through a list of .pro files) in the 
+Makefile.am file. After adding a new item (filename) to the list,
+please rerun "automake" being in the root folder of the source tree.
+
+Each test routine is invoked using the GDL "-e" command-line option 
+by the "try" shell script in the testsuite directory. "make" decides
+on the status of a test basing on the exit code of this script:
+- "success" for exit code 0 
+- "ignorable failure" for code 77
+- "failure" for any other exit code, e.g. 1
+The "try" script should, in principle, exit with the GDL exit code.
+Therefore, a failure of a GDL test should be indicated by e.g.:
+
+  if ( ...true if test failed... ) begin
+    message, 'reason for the failure', /continue
+    exit, status=1
+  endif
+
+An ignorable failure can be indicated by e.g.:
+
+  if (!XXX_exists()) then begin
+    message, 'GDL was built w/o support for XXX - skipping', /conti
+    exit, status=77
+  endif
+
+Any GDL error (e.g. parser error or library-routine-triggered error)
+causing GDL to return to the $MAIN$ level will cause make to assume 
+_success_! (GDL exits normally in this case). Any GDL error causing
+GDL to stop execution on an other-than-$MAIN$ level will bring the
+GDL interpreter prompt.
+
+The name of the file must match the name of the test routine, e.g. for
+the example above: testsuite/test_dummy.pro
+
+GDL segfaults, assertion-exits, std::terminate() exits, etc. are handled
+as failures by make.
+
+The "try" script always uses the gdl binary in the build tree - not the
+one installed in the system. The "try" script also sets appropriate env. 
+variables so that the GDL-written library routines are taken from the 
+source tree as well (e.g. src/pro/mean.pro).
+
+Sylwester Arabas
+February 2010
Binary files gdl-0.9rc4/testsuite/Saturn.jpg and cvs/gdl/testsuite/Saturn.jpg differ
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_constants.pro cvs/gdl/testsuite/test_constants.pro
--- gdl-0.9rc4/testsuite/test_constants.pro	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/testsuite/test_constants.pro	2010-04-16 11:22:54.000000000 -0600
@@ -1,445 +1,485 @@
-; by Sylwester Arabas
-pro test_constants
-
-  cnsts = strarr(28)
-  units = strarr(28)
-
-  cnsts[0:5] = ['amu','atm', 'AU', 'Avogadro', 'Boltzman', 'C'  ]
-  units[0:5] = ['kg', 'N/m2','m',  '1/mole',   'J/K',      'm/s']
-
-  ;cnsts[6] = ['Catalan']
-  ;units[6] = ['1']
-
-  cnsts[7:10] = ['E', 'ElectronCharge', 'ElectronMass', 'ElectronVolt']
-  units[7:10] = ['1', 'C',              'kg',           'J']
-
-  cnsts[11:15] = ['Euler', 'Faraday', 'FineStructure', 'Gamma', 'Gas']
-  units[11:15] = ['1',     'C/mole',  '1',             '1',     'J/mole/K']
-
-  cnsts[16:20] = ['Gravity',  'Hbar', 'PerfectGasVolume', 'Pi', 'Planck']
-  units[16:20] = ['N*m2/kg2', 'J*s',  'm3 / mole',        '1',  'J*s']
-
-  cnsts[21:24] = ['ProtonMass', 'Rydberg', 'Speedlight', 'StandardGravity']
-  units[21:24] = ['kg',         'm-1',     'm/s',        'm/s2']
-
-  cnsts[25:27] = ['StandardPressure', 'StefanBoltzman', 'WaterTriple'] 
-  units[25:27] = ['N/m2',             'W/K4 /m2',       'K']
-
-  ; testing all possible calling sequences with the default units
-  for i = 0, n_elements(cnsts) - 1 do if strlen(cnsts[i]) ne 0 then begin
-    a = imsl_constant(cnsts[i])
-    b = imsl_constant(cnsts[i], units[i])
-    a = imsl_constant(cnsts[i], /double)
-    b = imsl_constant(cnsts[i], units[i], /double)
-    if a ne b then begin
-      message, 'FAILED: ' + cnsts[i] + ' [' + units[i] + ']', /conti
-      exit, status=1
+;
+; Created by Sylwester Arabas
+; Modifications by AC on 30 March 2010
+;
+pro TEST_CONSTANTS, test=test
+;
+has_udunits = ~ (EXECUTE("a=IMSL_CONSTANT('c','m/s')") eq 0)
+;
+cnsts = STRARR(28)
+units = STRARR(28)
+;
+cnsts[0:5] = ['amu','atm', 'AU', 'Avogadro', 'Boltzman', 'C'  ]
+units[0:5] = ['kg', 'N/m2','m',  '1/mole',   'J/K',      'm/s']
+;;
+;;cnsts[6] = ['Catalan']
+;;units[6] = ['1']
+;;
+cnsts[7:10] = ['E', 'ElectronCharge', 'ElectronMass', 'ElectronVolt']
+units[7:10] = ['1', 'C',              'kg',           'J']
+;
+cnsts[11:15] = ['Euler', 'Faraday', 'FineStructure', 'Gamma', 'Gas']
+units[11:15] = ['1',     'C/mole',  '1',             '1',     'J/mole/K']
+;
+cnsts[16:20] = ['Gravity',  'Hbar', 'PerfectGasVolume', 'Pi', 'Planck']
+units[16:20] = ['N*m2/kg2', 'J*s',  'm3 / mole',        '1',  'J*s']
+;
+cnsts[21:24] = ['ProtonMass', 'Rydberg', 'Speedlight', 'StandardGravity']
+units[21:24] = ['kg',         'm-1',     'm/s',        'm/s2']
+;
+cnsts[25:27] = ['StandardPressure', 'StefanBoltzman', 'WaterTriple'] 
+units[25:27] = ['N/m2',             'W/K4 /m2',       'K']
+;;
+;; testing all possible calling sequences with the default units
+;;
+for i = 0, n_elements(cnsts) - 1 do if strlen(cnsts[i]) NE 0 then begin
+    a = IMSL_CONSTANT(cnsts[i])
+    a = IMSL_CONSTANT(cnsts[i], /double)
+    if has_udunits then begin
+        b = IMSL_CONSTANT(cnsts[i], units[i])
+        b = IMSL_CONSTANT(cnsts[i], units[i], /double)
+        if a NE b then begin
+            MESSAGE, 'FAILED: ' + cnsts[i] + ' [' + units[i] + ']', /conti
+            EXIT, status=1
+        endif
     endif
-  endif
-
-  ; testing unit conversion
-  ; - time
-  u = 'm/day'    & if ~finite(imsl_constant('c', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'm/hour'   & if ~finite(imsl_constant('c', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'm/hr'     & if ~finite(imsl_constant('c', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'm/min'    & if ~finite(imsl_constant('c', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'm/minute' & if ~finite(imsl_constant('c', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'm/s'      & if ~finite(imsl_constant('c', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'm/sec'    & if ~finite(imsl_constant('c', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'm/second' & if ~finite(imsl_constant('c', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'm/year'   & if ~finite(imsl_constant('c', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-
-  ; - frequency
-  u = 'm*Hz'     & if ~finite(imsl_constant('c', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-
-  ; - mass
-  u = 'AMU'      & if ~finite(imsl_constant('electronmass', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'g'        & if ~finite(imsl_constant('electronmass', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'gram'     & if ~finite(imsl_constant('electronmass', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'lb'       & if ~finite(imsl_constant('electronmass', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'pound'    & if ~finite(imsl_constant('electronmass', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-;  u = 'ounce'    & if ~finite(imsl_constant('electronmass', u)) then begin
-;    message, 'FAILED! ' + u, /conti
-;    exit, status=1
+endif
+;;
+;; testing unit conversion
+;;
+if has_udunits then begin
+  ;;
+  ;; - time
+  ;;
+  u = 'm/day'    & if ~FINITE(IMSL_CONSTANT('c', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'm/hour'   & if ~FINITE(IMSL_CONSTANT('c', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'm/hr'     & if ~FINITE(IMSL_CONSTANT('c', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'm/min'    & if ~FINITE(IMSL_CONSTANT('c', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'm/minute' & if ~FINITE(IMSL_CONSTANT('c', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'm/s'      & if ~FINITE(IMSL_CONSTANT('c', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'm/sec'    & if ~FINITE(IMSL_CONSTANT('c', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'm/second' & if ~FINITE(IMSL_CONSTANT('c', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'm/year'   & if ~FINITE(IMSL_CONSTANT('c', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; - frequency
+  ;;
+  u = 'm*Hz'     & if ~FINITE(IMSL_CONSTANT('c', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; - mass
+  ;;
+  u = 'AMU'      & if ~FINITE(IMSL_CONSTANT('electronmass', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'g'        & if ~FINITE(IMSL_CONSTANT('electronmass', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'gram'     & if ~FINITE(IMSL_CONSTANT('electronmass', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'lb'       & if ~FINITE(IMSL_CONSTANT('electronmass', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'pound'    & if ~FINITE(IMSL_CONSTANT('electronmass', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+;  u = 'ounce'    & if ~FINITE(IMSL_CONSTANT('electronmass', u)) then begin
+;    MESSAGE, 'FAILED! ' + u, /conti
+;    EXIT, status=1
 ;  endif
-;  u = 'oz'       & if ~finite(imsl_constant('electronmass', u)) then begin
-;    message, 'FAILED! ' + u, /conti
-;    exit, status=1
+;  u = 'oz'       & if ~FINITE(IMSL_CONSTANT('electronmass', u)) then begin
+;    MESSAGE, 'FAILED! ' + u, /conti
+;    EXIT, status=1
 ;  endif
-  u = 'slug'     & if ~finite(imsl_constant('electronmass', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
- 
-  ; - distance
-  u = 'Angstrom' & if ~finite(imsl_constant('AU', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-;  u = 'AU'       & if ~finite(imsl_constant('AU', u)) then begin
-;    message, 'FAILED! ' + u, /conti
-;    exit, status=1
+  u = 'slug'     & if ~FINITE(IMSL_CONSTANT('electronmass', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; - distance
+  ;;
+  u = 'Angstrom' & if ~FINITE(IMSL_CONSTANT('AU', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+;  u = 'AU'       & if ~FINITE(IMSL_CONSTANT('AU', u)) then begin
+;    MESSAGE, 'FAILED! ' + u, /conti
+;    EXIT, status=1
 ;  endif
-  u = 'feet'     & if ~finite(imsl_constant('AU', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'foot'     & if ~finite(imsl_constant('AU', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'in'       & if ~finite(imsl_constant('AU', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'inch'     & if ~finite(imsl_constant('AU', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'm'        & if ~finite(imsl_constant('AU', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'meter'    & if ~finite(imsl_constant('AU', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'metre'    & if ~finite(imsl_constant('AU', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'micron'   & if ~finite(imsl_constant('AU', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'mile'     & if ~finite(imsl_constant('AU', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-;  u = 'mill'     & if ~finite(imsl_constant('AU', u)) then begin 
-;    message, 'FAILED! ' + u, /conti
-;    exit, status=1
+  u = 'feet'     & if ~FINITE(IMSL_CONSTANT('AU', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'foot'     & if ~FINITE(IMSL_CONSTANT('AU', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'in'       & if ~FINITE(IMSL_CONSTANT('AU', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'inch'     & if ~FINITE(IMSL_CONSTANT('AU', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'm'        & if ~FINITE(IMSL_CONSTANT('AU', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'meter'    & if ~FINITE(IMSL_CONSTANT('AU', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'metre'    & if ~FINITE(IMSL_CONSTANT('AU', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'micron'   & if ~FINITE(IMSL_CONSTANT('AU', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'mile'     & if ~FINITE(IMSL_CONSTANT('AU', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+;  u = 'mill'     & if ~FINITE(IMSL_CONSTANT('AU', u)) then begin 
+;    MESSAGE, 'FAILED! ' + u, /conti
+;    EXIT, status=1
 ;  endif
-  u = 'parsec'   & if ~finite(imsl_constant('AU', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'yard'     & if ~finite(imsl_constant('AU', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-
-  ; - area
-  u = 'N/acre'   & if ~finite(imsl_constant('ATM', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-
-  ; - volume
-  u = 'l/mole'    & if ~finite(imsl_constant('PerfectGasVolume', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'liter/mole'& if ~finite(imsl_constant('PerfectGasVolume', u)) then begin 
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'litre/mole'& if ~finite(imsl_constant('PerfectGasVolume', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-
-  ; - force
-  u = 'dyne/m^2'  & if ~finite(imsl_constant('ATM', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'N/m^2'     & if ~finite(imsl_constant('ATM', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'Newton/m^2'& if ~finite(imsl_constant('ATM', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-
-  ; - energy
-  u = 'BTU'   & if ~finite(imsl_constant('ElectronVolt', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'Erg'   & if ~finite(imsl_constant('ElectronVolt', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'J'     & if ~finite(imsl_constant('ElectronVolt', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'Joule' & if ~finite(imsl_constant('ElectronVolt', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-
-  ; - work
-  u = 'W*s^2'    & if ~finite(imsl_constant('Hbar', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'watt*s^2' & if ~finite(imsl_constant('Hbar', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-
-  ; - pressure
-;  u = 'ATM'        & if ~finite(imsl_constant('ATM', u)) then begin
-;    message, 'FAILED! ' + u, /conti
-;    exit, status=1
+  u = 'parsec'   & if ~FINITE(IMSL_CONSTANT('AU', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'yard'     & if ~FINITE(IMSL_CONSTANT('AU', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; - area
+  ;;
+  u = 'N/acre'   & if ~FINITE(IMSL_CONSTANT('ATM', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; - volume
+  ;;
+  u = 'l/mole'    & if ~FINITE(IMSL_CONSTANT('PerfectGasVolume', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'liter/mole'& if ~FINITE(IMSL_CONSTANT('PerfectGasVolume', u)) then begin 
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'litre/mole'& if ~FINITE(IMSL_CONSTANT('PerfectGasVolume', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; - force
+  ;;
+  u = 'dyne/m^2'  & if ~FINITE(IMSL_CONSTANT('ATM', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'N/m^2'     & if ~FINITE(IMSL_CONSTANT('ATM', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'Newton/m^2'& if ~FINITE(IMSL_CONSTANT('ATM', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; - energy
+  ;;
+  u = 'BTU'   & if ~FINITE(IMSL_CONSTANT('ElectronVolt', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'Erg'   & if ~FINITE(IMSL_CONSTANT('ElectronVolt', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'J'     & if ~FINITE(IMSL_CONSTANT('ElectronVolt', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'Joule' & if ~FINITE(IMSL_CONSTANT('ElectronVolt', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; - work
+  ;;
+  u = 'W*s^2'    & if ~FINITE(IMSL_CONSTANT('Hbar', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'watt*s^2' & if ~FINITE(IMSL_CONSTANT('Hbar', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; - pressure
+  ;;
+;  u = 'ATM'        & if ~FINITE(IMSL_CONSTANT('ATM', u)) then begin
+;    MESSAGE, 'FAILED! ' + u, /conti
+;    EXIT, status=1
 ;  endif
-  u = 'atmosphere' & if ~finite(imsl_constant('ATM', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'bar'        & if ~finite(imsl_constant('ATM', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-
-  ; - temperature
-  u = 'degC'       & if ~finite(imsl_constant('WaterTriple', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'Celsius'    & if ~finite(imsl_constant('WaterTriple', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'degF'       & if ~finite(imsl_constant('WaterTriple', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-;  u = 'Fahrenheit' & if ~finite(imsl_constant('WaterTriple', u)) then begin
-;    message, 'FAILED! ' + u, /conti
-;    exit, status=1
+  u = 'atmosphere' & if ~FINITE(IMSL_CONSTANT('ATM', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'bar'        & if ~FINITE(IMSL_CONSTANT('ATM', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; - temperature
+  ;;
+  u = 'degC'       & if ~FINITE(IMSL_CONSTANT('WaterTriple', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'Celsius'    & if ~FINITE(IMSL_CONSTANT('WaterTriple', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'degF'       & if ~FINITE(IMSL_CONSTANT('WaterTriple', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+;  u = 'Fahrenheit' & if ~FINITE(IMSL_CONSTANT('WaterTriple', u)) then begin
+;    MESSAGE, 'FAILED! ' + u, /conti
+;    EXIT, status=1
 ;  endif
-  u = 'degK'       & if ~finite(imsl_constant('WaterTriple', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'Kelvin'     & if ~finite(imsl_constant('WaterTriple', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-
-  ; - viscosity
-;  u = 'stoke/m'    & if ~finite(imsl_constant('Speedlight', u)) then begin
-;    message, 'FAILED! ' + u, /conti
-;    exit, status=1
+  u = 'degK'       & if ~FINITE(IMSL_CONSTANT('WaterTriple', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'Kelvin'     & if ~FINITE(IMSL_CONSTANT('WaterTriple', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; - viscosity
+  ;;
+;  u = 'stoke/m'    & if ~FINITE(IMSL_CONSTANT('Speedlight', u)) then begin
+;    MESSAGE, 'FAILED! ' + u, /conti
+;    EXIT, status=1
 ;  endif
-  u = 'poise/s'    & if ~finite(imsl_constant('ATM', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-
-  ; - charge
-;  u = 'Abcoulomb'   & if ~finite(imsl_constant('electroncharge', u)) then begin 
-;    message, 'FAILED! ' + u, /conti
-;    exit, status=1
+  u = 'poise/s'    & if ~FINITE(IMSL_CONSTANT('ATM', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; - charge
+  ;;
+;  u = 'Abcoulomb'   & if ~FINITE(IMSL_CONSTANT('electroncharge', u)) then begin 
+;    MESSAGE, 'FAILED! ' + u, /conti
+;    EXIT, status=1
 ;  endif
-  u = 'C'           & if ~finite(imsl_constant('electroncharge', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'Coulomb'     & if ~finite(imsl_constant('electroncharge', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'statcoulomb' & if ~finite(imsl_constant('electroncharge', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-
-  ; - current
-  u = 'A*s'          & if ~finite(imsl_constant('electroncharge', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'ampere*s'     & if ~finite(imsl_constant('electroncharge', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'abampere*s'   & if ~finite(imsl_constant('electroncharge', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'statampere*s' & if ~finite(imsl_constant('electroncharge', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-
-  ; - voltage
-  u = 'J/Abvolt' & if ~finite(imsl_constant('electroncharge', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'J/V'      & if ~finite(imsl_constant('electroncharge', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'J/volt'   & if ~finite(imsl_constant('electroncharge', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-
-  ; - magnetic induction
-  u = 'T*C*s'     & if ~finite(imsl_constant('electronmass', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'Tesla*C*s' & if ~finite(imsl_constant('electronmass', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'Weber*A'   & if ~finite(imsl_constant('electronvolt', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'Wb*A'      & if ~finite(imsl_constant('electronvolt', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-
-  ; - other units
-  u = '1/mole'     & if ~finite(imsl_constant('avogadro', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'farad*V'    & if ~finite(imsl_constant('electroncharge', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'Gauss*C*s'  & if ~finite(imsl_constant('electronmass', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'Henry*C2/s' & if ~finite(imsl_constant('planck', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'Maxwell*A'  & if ~finite(imsl_constant('electronvolt', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-  u = 'Ohm*s*A^2'  & if ~finite(imsl_constant('electronvolt', u)) then begin
-    message, 'FAILED! ' + u, /conti
-    exit, status=1
-  endif
-
-  ; testing prefixes
+  u = 'C'           & if ~FINITE(IMSL_CONSTANT('electroncharge', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'Coulomb'     & if ~FINITE(IMSL_CONSTANT('electroncharge', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'statcoulomb' & if ~FINITE(IMSL_CONSTANT('electroncharge', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; - current
+  ;;
+  u = 'A*s'          & if ~FINITE(IMSL_CONSTANT('electroncharge', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'ampere*s'     & if ~FINITE(IMSL_CONSTANT('electroncharge', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'abampere*s'   & if ~FINITE(IMSL_CONSTANT('electroncharge', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'statampere*s' & if ~FINITE(IMSL_CONSTANT('electroncharge', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; - voltage
+  ;;
+  u = 'J/Abvolt' & if ~FINITE(IMSL_CONSTANT('electroncharge', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'J/V'      & if ~FINITE(IMSL_CONSTANT('electroncharge', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'J/volt'   & if ~FINITE(IMSL_CONSTANT('electroncharge', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; - magnetic induction
+  ;;
+  u = 'T*C*s'     & if ~FINITE(IMSL_CONSTANT('electronmass', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'Tesla*C*s' & if ~FINITE(IMSL_CONSTANT('electronmass', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'Weber*A'   & if ~FINITE(IMSL_CONSTANT('electronvolt', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'Wb*A'      & if ~FINITE(IMSL_CONSTANT('electronvolt', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; - other units
+  ;;
+  u = '1/mole'     & if ~FINITE(IMSL_CONSTANT('avogadro', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'farad*V'    & if ~FINITE(IMSL_CONSTANT('electroncharge', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'Gauss*C*s'  & if ~FINITE(IMSL_CONSTANT('electronmass', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'Henry*C2/s' & if ~FINITE(IMSL_CONSTANT('planck', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'Maxwell*A'  & if ~FINITE(IMSL_CONSTANT('electronvolt', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  u = 'Ohm*s*A^2'  & if ~FINITE(IMSL_CONSTANT('electronvolt', u)) then begin
+    MESSAGE, 'FAILED! ' + u, /conti
+    EXIT, status=1
+  endif
+  ;;
+  ;; testing prefixes
+  ;;
   eps = 1d-6
-  au = imsl_constant('AU', /d)
-  if imsl_constant('AU', 'parsec', /d) - au * 1d18 gt eps then begin
-    message, 'FAILED! a', /conti
-    exit, status=1
-  endif
-  if imsl_constant('AU', 'parsec', /d) - au * 1d15 gt eps then begin
-    message, 'FAILED! f', /conti
-    exit, status=1
-  endif
-  if imsl_constant('AU', 'pm', /d) ne au * 1d12 then begin
-    message, 'FAILED! p', /conti
-    exit, status=1
-  endif
-  if imsl_constant('AU', 'nm', /d) ne au * 1d9 then begin
-    message, 'FAILED! n', /conti
-    exit, status=1
-  endif
-;  if imsl_constant('AU', 'um', /d) ne au * 1d6 then begin
-;    message, 'FAILED! u', /conti
-;    exit, status=1
+  au = IMSL_CONSTANT('AU', /d)
+  if IMSL_CONSTANT('AU', 'parsec', /d) - au * 1d18 GT eps then begin
+    MESSAGE, 'FAILED! a', /conti
+    EXIT, status=1
+  endif
+  if IMSL_CONSTANT('AU', 'parsec', /d) - au * 1d15 GT eps then begin
+    MESSAGE, 'FAILED! f', /conti
+    EXIT, status=1
+  endif
+  if IMSL_CONSTANT('AU', 'pm', /d) NE au * 1d12 then begin
+    MESSAGE, 'FAILED! p', /conti
+    EXIT, status=1
+  endif
+  if IMSL_CONSTANT('AU', 'nm', /d) NE au * 1d9 then begin
+    MESSAGE, 'FAILED! n', /conti
+    EXIT, status=1
+  endif
+;  if IMSL_CONSTANT('AU', 'um', /d) NE au * 1d6 then begin
+;    MESSAGE, 'FAILED! u', /conti
+;    EXIT, status=1
 ;  endif
-  if imsl_constant('AU', 'mm', /d) ne au * 1d3 then begin
-    message, 'FAILED! m', /conti
-    exit, status=1
-  endif
-  if imsl_constant('AU', 'cm', /d) ne au * 1d2 then begin
-    message, 'FAILED! c', /conti
-    exit, status=1
-  endif
-  if imsl_constant('AU', 'dm', /d) ne au * 1d1 then begin
-    message, 'FAILED! d', /conti
-    exit, status=1
-  endif
-  if imsl_constant('AU', 'dam', /d) ne au * 1d-1 then begin
-    message, 'FAILED! da', /conti
-    exit, status=1
-  endif
-  if imsl_constant('AU', 'km', /d) ne au * 1d-3 then begin
-    message, 'FAILED! k', /conti
-    exit, status=1
-  endif
-  if imsl_constant('AU', 'Gm', /d) ne au * 1d-9 then begin
-    message, 'FAILED! g', /conti
-    exit, status=1
-  endif
-  if imsl_constant('AU', 'Tm', /d) ne au * 1d-12 then begin
-    message, 'FAILED! t', /conti
-    exit, status=1
-  endif
- 
-  ; testing if PI = PI
-  if imsl_constant('pi') ne !PI then begin
-    message, 'FAILED! (PI != PI)', /conti
-    exit, status=1
-  endif
-  if imsl_constant('pi', /double) ne !DPI then begin
-    message, 'FAILED! (DPI != DPI)', /conti
-    exit, status=1
-  endif
-
+  if IMSL_CONSTANT('AU', 'mm', /d) NE au * 1d3 then begin
+    MESSAGE, 'FAILED! m', /conti
+    EXIT, status=1
+  endif
+  if IMSL_CONSTANT('AU', 'cm', /d) NE au * 1d2 then begin
+    MESSAGE, 'FAILED! c', /conti
+    EXIT, status=1
+  endif
+  if IMSL_CONSTANT('AU', 'dm', /d) NE au * 1d1 then begin
+    MESSAGE, 'FAILED! d', /conti
+    EXIT, status=1
+  endif
+  if IMSL_CONSTANT('AU', 'dam', /d) NE au * 1d-1 then begin
+    MESSAGE, 'FAILED! da', /conti
+    EXIT, status=1
+  endif
+  if IMSL_CONSTANT('AU', 'km', /d) NE au * 1d-3 then begin
+    MESSAGE, 'FAILED! k', /conti
+    EXIT, status=1
+  endif
+  if IMSL_CONSTANT('AU', 'Gm', /d) NE au * 1d-9 then begin
+    MESSAGE, 'FAILED! g', /conti
+    EXIT, status=1
+  endif
+  if IMSL_CONSTANT('AU', 'Tm', /d) NE au * 1d-12 then begin
+    MESSAGE, 'FAILED! t', /conti
+    EXIT, status=1
+  endif
+
+endif
+
+;;
+;; testing if PI = PI
+;;
+if IMSL_CONSTANT('pi') NE !PI then begin
+    MESSAGE, 'FAILED! (PI != PI)', /conti
+    EXIT, status=1
+endif
+if IMSL_CONSTANT('pi', /double) NE !DPI then begin
+    MESSAGE, 'FAILED! (DPI != DPI)', /conti
+    EXIT, status=1
+endif
+;
+if KEYWORD_SET(test) then STOP
+;
+if (~has_udunits) then begin
+    MESSAGE, 'Some checks skipped (GDL was compiled without support for UDUNITS)', /conti
+    EXIT, status=77
+endif
+;
 end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_device.pro cvs/gdl/testsuite/test_device.pro
--- gdl-0.9rc4/testsuite/test_device.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_device.pro	2010-04-20 02:14:07.000000000 -0600
@@ -0,0 +1,29 @@
+pro test_device
+
+  set_plot, 'ps'
+
+  device, xsize=10
+  if !D.X_SIZE ne 10000 then begin
+    message, '!D.X_SIZE ne 10000', /conti
+    exit, status=1
+  endif
+
+  device, ysize=20
+  if !D.Y_SIZE ne 20000 then begin
+    message, '!D.Y_SIZE ne 20000', /conti
+    exit, status=1
+  endif
+  
+  device, xsize=10, /inches
+  if !D.X_SIZE ne 25400 then begin
+    message, '!D.X_SIZE ne 25400', /conti
+    exit, status=1
+  endif
+
+  device, ysize=20, /inches
+  if !D.Y_SIZE ne 50800 then begin
+    message, '!D.Y_SIZE ne 50800', /conti
+    exit, status=1
+  endif
+
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_erfinv.pro cvs/gdl/testsuite/test_erfinv.pro
--- gdl-0.9rc4/testsuite/test_erfinv.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_erfinv.pro	2010-06-08 06:08:17.000000000 -0600
@@ -0,0 +1,24 @@
+; by Sylwester Arabas <slayoo@igf.fuw.edu.pl>
+pro test_erfinv
+
+  x = (2 * findgen(100) / 99 - 1)[1 : 98]
+  for i=0, n_elements(x) - 1 do begin
+    if abs(imsl_erf(erf(x[i]), /inv) - x[i]) gt 1e-6 then begin
+      message, 'erf-1(erf(float x)) != x', /conti
+      exit, status=1
+    endif
+    if abs(imsl_erf(erf(x[i], /double), /inv, /double) - x[i]) gt 1e-7 then begin
+      message, 'erf-1(erf(float x, /double), /double) != x', /conti
+      exit, status=1
+    endif
+  endfor
+
+  x = (2 * dindgen(100) / 99 - 1)[1 : 98]
+  for i=0, n_elements(x) - 1 do begin
+    if abs(imsl_erf(erf(x[i]), /inv) - x[i]) gt 1e-7 then begin
+      message, 'erf-1(erf(double x)) != x', /conti
+      exit, status=1
+    endif
+  endfor
+
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_fft_leak.pro cvs/gdl/testsuite/test_fft_leak.pro
--- gdl-0.9rc4/testsuite/test_fft_leak.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_fft_leak.pro	2010-06-15 07:32:00.000000000 -0600
@@ -0,0 +1,93 @@
+;
+; do the call to FFTw give Memory leaks ?
+; (maybe we can generalyse such tests on other pro/func ?)
+;
+; Lea Noreskal and Alain Coulais
+; Mai 2010
+; under GNU GPL 2 or later
+;
+; testing possible memory leak in FFT 
+; http://sourceforge.net/tracker/?func=detail&aid=3009319&group_id=97659&atid=618683
+;
+; Known problems: MEMORY() is not working on Linux OS as is on June 7, 2010
+;
+pro TEST_FFT_LEAK_ONE_TYPE, type=type, lenght=lenght, nb_iter_max=nb_iter_max, $
+                            help=help, test=test, verbose=verbose, max_leak=max_leak
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro TEST_FFT_LEAK_ONE_TYPE, type=type, lenght=lenght, nb_iter_max=nb_iter_max, $'
+   print, '                            help=help, test=test, verbose=verbose, max_leak=max_leak'
+endif
+;
+if N_ELEMENTS(lenght) EQ 0 then lenght=1024
+;
+; types: 4: real, 5 double, 6 complex ...
+;
+if N_ELEMENTS(type) EQ 0 then type=4
+;
+x=MAKE_ARRAY(lenght, type=type)
+y=x
+;
+if N_ELEMENTS(nb_iter_max) EQ 0 then nb_iter_max=1000
+;
+Resu_mem=FLTARR(nb_iter_max)
+;
+for i=0L, nb_iter_max-1 do begin
+    x += FFT(y)
+    resu_mem[i]=(MEMORY())[0]
+endfor
+;
+max_leak=MAX(resu_mem-resu_mem[0])
+;
+if KEYWORD_SET(verbose) then begin
+    print, 'type: ', type, ' , max leak size: ', max_leak
+endif
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+
+pro TEST_FFT_LEAK, force=force, no_exit=no_exit, $
+                   verbose=verbose, test=test, help=help
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro TEST_FFT_LEAK, force=force, no_exit=no_exit, $'
+   print, '                   help=help, test=test, verbose=verbose'
+endif
+;
+; /FORCE will allow to skip the test on OS type ...
+if NOT(KEYWORD_SET(force)) then begin
+   if (STRLOWCASE(!version.OS) NE 'darwin') then begin
+      txt='AC and LN 2010/06/07: '
+        MESSAGE, /continue, txt+'because MEMORY() not working now on Linux'
+        MESSAGE, /continue, txt+'we cannot do these tests ...'
+        MESSAGE, /continue, txt+'you can overpass this by using /FORCE'
+        ;;
+        if KEYWORD_SET(no_exit) then return else EXIT, status=77
+    endif
+endif
+;
+nb_pb=0
+;
+for ii=0, 15 do begin
+   if ii EQ 8 then CONTINUE   ;; Struc
+   if ii EQ 10 then CONTINUE  ;; Pointer
+   if ii EQ 11 then CONTINUE  ;; Objref
+   ;;
+   TEST_FFT_LEAK_ONE_TYPE, type=ii, max_leak=max_leak, verbose=verbose
+   ;;
+   ;; empirical value working for OSX
+   if (max_leak GT 10000) then nb_pb=nb_pb+1
+   ;;
+endfor
+;
+if nb_pb GT 0 then begin
+    MESSAGE, /continue, STRING(nb_pb)+' case of memory leak when calling FFT have been found'
+    if NOT(KEYWORD_SET(no_exit)) then EXIT, status=1
+endif else begin
+    MESSAGE, /continue, 'NO case of memory leak when calling FFT have been found'
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_fft.pro cvs/gdl/testsuite/test_fft.pro
--- gdl-0.9rc4/testsuite/test_fft.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_fft.pro	2010-03-30 06:48:16.000000000 -0600
@@ -0,0 +1,149 @@
+;
+; Under GPL 2 or later
+; Thibaut Mermet and Alain Coulais
+; June 2009 and February 2010.
+;
+; Testing the FFT function : 
+; do the FFT computes :
+; -- (1) somethings
+; -- (2) at the expected place
+; We need such a function because one version of GDL rc2
+; does suffer from a bug for few types (double ?) where
+; computations always return "0". It was hard to check
+; because most was OK and also we can used 2 libraries for FFT: GSL or FFTw.
+;
+; -------------------------------------------
+;
+; This is a preliminary but important version of TEST_FFT 
+;
+; -------------------------------------------
+;
+; expected types for outputs from FFT are "6" (complex) or "9" (Dcomplex)
+;
+pro TEST_FFT_ALL_TYPES, test=test, help=help, $
+                        verbose=verbose, quiet=quiet
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro TEST_FFT_ALL_TYPES, test=test, help=help, $'
+   print, '                        verbose=verbose, quiet=quiet'
+endif
+;
+print, 'Running TEST_FFT_ALL_TYPES (for 13 input types)'
+;
+nb_pb=0
+for ii=0, 15 do begin
+   if ii EQ 8 then CONTINUE   ;; Struc
+   if ii EQ 10 then CONTINUE  ;; Pointer
+   if ii EQ 11 then CONTINUE  ;; Objref
+   ;;
+   input=MAKE_ARRAY(1024,type=ii)
+   result=FFT(input)
+   type=SIZE(result,/type)
+   if ((type EQ 6) or (type EQ 9)) then begin
+      message=', OK'
+   endif else begin
+      message=', Problem'
+      nb_pb=nb_pb+1
+   endelse
+   if NOT(KEYWORD_SET(quiet)) OR KEYWORD_SET(verbose) then begin
+      print, 'Input type :', ii, ', Output type :', type, message
+   endif
+endfor
+;
+if (nb_pb GT 0) then begin
+   MESSAGE, STRING(nb_pb)+' problem(s) found in TEST_FFT_ALL_TYPES',/continue
+   EXIT, status=1
+endif else begin
+   MESSAGE, 'No problem found in TEST_FFT_ALL_TYPES',/continue
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; -------------------------------------------
+;
+pro TEST_FFT_GO_AND_BACK, dimension=dimension, nbp=nbp, $
+                          verbose=verbose, quiet=quiet, $
+                          test=test, help=help, debug=debug
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro TEST_FFT_GO_AND_BACK, dimension=dimension, nbp=nbp, $'
+   print, '                          verbose=verbose, quiet=quiet, $'
+   print, '                          test=test, help=help, debug=debug'
+   return
+end
+;
+print, '' &
+mess='Running TEST_FFT_GO_AND_BACK (for 13 input types)'
+;;if N_ELEMENTS(dimension) GT 3 then begin
+;;   MESSAGE, 'Sorry, we are not ready for high Dimensions cases'
+;;   EXIT, status=1
+;;end
+if N_ELEMENTS(dimension) EQ 0 then begin
+   if N_ELEMENTS(nbp) EQ 0 then nbp=1024
+   if nbp LE 0 then begin
+      MESSAGE, 'Nbp= must be positive (>0)'
+      EXIT, status=1
+   endif
+   dimension=[nbp]
+endif
+mess=mess+' in '+STRING(N_ELEMENTS(dimension))+'D case, with size:'
+print, STRCOMPRESS(mess), dimension
+;
+nb_pb=0
+;
+; We will point a Dirac somewhere in the array ...
+glitch=[5,7,12]
+glitch_index=glitch[0]
+for ii=1, N_ELEMENTS(dimension)-1 do begin
+   glitch_index=glitch_index+glitch[ii mod 3]*dimension[ii-1]
+endfor
+if KEYWORD_SET(debug) then print, glitch_index
+;
+for ii=0, 15 do begin
+   if ii EQ 8 then CONTINUE   ;; Struc
+   if ii EQ 10 then CONTINUE  ;; Pointer
+   if ii EQ 11 then CONTINUE  ;; Objref
+   ;;
+   input=MAKE_ARRAY(dimension,type=ii)
+   input[glitch_index]=1
+   ;;
+   result1=FFT(input,1)
+   result2=FFT(result1,-1)
+   error=TOTAL(ABS(input-result2))
+   message=', OK'
+   if (error GT 1e-3) then begin
+      message=', Problems'
+      nb_pb=nb_pb+1
+   endif
+   if NOT(KEYWORD_SET(quiet)) OR KEYWORD_SET(verbose) then begin
+      print, format='(A,i4,A,i4,A,G10.4,A)', 'Input type :', ii, $
+             ', Output type :', SIZE(result2,/type), ', error: ', error, message
+   endif
+endfor
+;
+if (nb_pb GT 0) then begin
+   MESSAGE, STRING(nb_pb)+' problem(s) found in TEST_FFT_GO_AND_BACK', /continue
+   EXIT, status=1
+endif else begin
+   MESSAGE, 'No problem found in TEST_FFT_GO_AND_BACK', /continue
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; -------------------------------------------
+;
+pro TEST_FFT, quiet=quiet, verbose=verbose
+;
+if NOT(KEYWORD_SET(quiet)) AND NOT(KEYWORD_SET(verbose)) then quiet=1
+;
+TEST_FFT_ALL_TYPES, quiet=quiet, verbose=verbose
+TEST_FFT_GO_AND_BACK, quiet=quiet, verbose=verbose
+TEST_FFT_GO_AND_BACK, dim=[1024,1024], quiet=quiet, verbose=verbose
+TEST_FFT_GO_AND_BACK, dim=[512,2048], quiet=quiet, verbose=verbose
+TEST_FFT_GO_AND_BACK, dim=[128,64,128], quiet=quiet, verbose=verbose
+;
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_file_basename.pro cvs/gdl/testsuite/test_file_basename.pro
--- gdl-0.9rc4/testsuite/test_file_basename.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_file_basename.pro	2010-06-29 02:47:39.000000000 -0600
@@ -0,0 +1,60 @@
+;
+; Doing a serie of tests for FILE_BASENAME(),
+; including mandatory escape of special chars
+;
+; Lea Noreskal and Alain Coulais
+; June 2010
+; under GNU GPL 2 or later
+;
+pro TEST_FILE_BASENAME , test=test
+;
+;print, FILE_BASENAME('GDLTokenTy*') ; GDLTokenTy*
+if (FILE_BASENAME('GDLTokenTy*') NE 'GDLTokenTy*') then begin
+    MESSAGE, /continue, 'FILE_BASENAME(GDLTokenTy*) NE GDLTokenTy*'
+    EXIT, status=1
+endif
+;
+
+;print, FILE_BASENAME('GDLTokenTy\*') ; GDLTokenTy\*
+if (FILE_BASENAME('GDLTokenTy\*') NE 'GDLTokenTy\*') then begin
+    MESSAGE, /continue, 'FILE_BASENAME(GDLTokenTy\*) NE GDLTokenTy\* '
+    EXIT, status=1
+endif
+;
+my_file='/usr/share/gnudatalanguage/lib/dist.pro'
+;
+;print, FILE_BASENAME(my_file, '.pro') ;  dist
+my_test='.pro'
+if (FILE_BASENAME(my_file, my_test) NE 'dist') then begin
+    MESSAGE, /continue, 'FILE_BASENAME('''+my_file+''', '''+my_test+''' ) NE dist.pro'
+    EXIT, status=1
+endif
+;
+;print, FILE_BASENAME(my_file, '.pr*') ; dist.pro
+my_test='.pr*'
+if (FILE_BASENAME(my_file, '.pr*') NE 'dist.pro') then begin
+    MESSAGE, /continue, 'FILE_BASENAME('''+my_file+''', '''+my_test+''' ) NE dist.pro'
+    EXIT, status=1
+endif
+;
+;print, FILE_BASENAME(my_file, '*') ; dist.pro
+my_test='*'
+if (FILE_BASENAME(my_file, '*') NE 'dist.pro') then begin
+    MESSAGE, /continue, 'FILE_BASENAME('''+my_file+''', '''+my_test+''' ) NE dist.pro'
+    EXIT, status=1
+endif
+;
+;print, FILE_BASENAME(my_file, '.') ; dist.pro
+my_test='.'
+if (FILE_BASENAME(my_file, my_test) NE 'dist.pro') then begin
+    MESSAGE, /continue, 'FILE_BASENAME('''+my_file+''', '''+my_test+''' ) NE dist.pro'
+    EXIT, status=1
+endif
+;
+MESSAGE, /continue, 'All tests done with success'
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_file_copy.pro cvs/gdl/testsuite/test_file_copy.pro
--- gdl-0.9rc4/testsuite/test_file_copy.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_file_copy.pro	2010-06-29 02:47:39.000000000 -0600
@@ -0,0 +1,236 @@
+;
+; Testing FILE_COPY function
+;
+; Lea Noreskal, June 2010
+; under GNU GPL 2 or later
+; 
+pro del_test_files , to_delete 
+
+; Delete files and directories
+for ii=0, N_ELEMENTS(to_delete)-1 do begin
+   if(FILE_TEST(to_delete[ii]) eq 1) then SPAWN , 'rm -rf '+escape_special_char(to_delete[ii])
+endfor
+
+end
+
+
+pro TEST_FILE_COPY , test=test
+
+; Create test directory
+tdir='tdir_test_f_copy_gdl'
+if FILE_TEST(tdir) EQ 0 then SPAWN, 'mkdir '+tdir
+;if (FILE_TEST(tdir,/directory) EQ 1 and FILE_TEST(rep) EQ 0) then SPAWN, 'mkdir '+rep
+
+all_files_and_directories=tdir 
+
+;Files
+files1=['gdlfd_test1a','gdlfd_test1b']
+files2=['gdlfd_test1aCP','gdlfd_test1bCP']
+
+file2='$chops &up str*ings_gdltest.'
+
+all_files_and_directories=[all_files_and_directories,files1]
+all_files_and_directories=[all_files_and_directories,files2]
+all_files_and_directories=[all_files_and_directories,file2]
+
+more='more text , more more '
+
+f1=[tdir+'/gdlfd_test1a',tdir+'/gdlfd_test1b']
+
+if FILE_TEST(files1[0]) EQ 0 then SPAWN, 'touch '+files1[0]
+if FILE_TEST(files1[1]) EQ 0 then SPAWN, 'touch '+files1[1]
+if FILE_TEST(file2) EQ 0 then SPAWN, 'touch '+escape_special_char(file2)
+
+
+sce=MAKE_ARRAY(N_ELEMENTS(files1))
+dest=MAKE_ARRAY(N_ELEMENTS(files1))
+
+
+; Add elements to files
+for ii=0, N_ELEMENTS(files1)-1 do begin
+	SPAWN , 'echo '+more+' >> '+files1[ii]
+endfor
+
+print , 'COPY N1'
+; Copy files1 into tdir
+FILE_COPY, files1 , tdir
+
+sce=FILE_INFO(files1)
+dest=FILE_INFO(f1) 
+
+;print, 'Size sce',  sce[0].size
+;print, 'Size dest', dest[0].size
+
+; if files1 et f1 have same size , cp ok
+
+for ii=0, N_ELEMENTS(sce)-1 do begin
+   if(sce[ii].size ne dest[ii].size ) then begin
+      MESSAGE, 'error cp', /continue
+      del_test_files , all_files_and_directories
+      EXIT, status=1
+   endif
+endfor
+
+; add elements to files
+for ii=0, N_ELEMENTS(files1)-1 do begin
+	SPAWN , 'echo '+more+' >> '+files1[ii]
+endfor
+
+print , 'COPY N2'
+; Copy files1 into tdir again
+FILE_COPY, files1 , tdir
+
+sce=FILE_INFO(files1)
+dest=FILE_INFO(f1) 
+
+;print , 'Size sce',  sce[0].size
+;print , 'Size dest', dest[0].size
+
+; if files1 et f1 don't have same size , because overwrite is not allowed
+
+for ii=0, N_ELEMENTS(sce)-1 do begin
+   if(sce[ii].size eq dest[ii].size ) then begin
+      MESSAGE, 'error cp', /continue
+      del_test_files , all_files_and_directories
+      EXIT, status=1
+   endif
+endfor
+
+
+
+for ii=0, N_ELEMENTS(files1)-1 do begin
+	SPAWN , 'echo '+more+' >> '+files1[ii]
+endfor
+
+; Overwrite -  maj :::: t0 < t1
+print , 'OVERWRITE' 
+FILE_COPY, files1 , tdir , /overwrite 
+dest=FILE_INFO(f1) 
+sce=FILE_INFO(files1)
+;print, 'Size sce',  sce[0].size
+;print, 'Size dest', dest[0].size
+
+; if files1 et f1 have same size , cp ok
+for ii=0, N_ELEMENTS(sce)-1 do begin
+   if(sce[ii].size ne dest[ii].size ) then begin
+      MESSAGE, 'error cp', /continue
+      del_test_files , all_files_and_directories
+      EXIT, status=1
+   endif
+endfor
+
+
+for ii=0, N_ELEMENTS(files1)-1 do begin
+	SPAWN , 'echo '+more+' >> '+files1[ii]
+endfor
+
+; CP files > files
+
+print , 'Require_dir ' 
+FILE_COPY, files1 , files2 , /require_dir
+; if files2 exist : error
+
+for ii=0, N_ELEMENTS(files2)-1 do begin
+   if(FILE_TEST(files2[ii]) eq 1 ) then begin
+      MESSAGE, 'error require_dir', /continue
+      del_test_files , all_files_and_directories                
+      EXIT, status=1
+   endif
+endfor
+
+;print , 'Sce=tab of files Dest=file ' 
+FILE_COPY, files1 , file2 , /require_dir
+
+
+print , 'files to files' 
+FILE_COPY, files1 , files2
+
+sce=FILE_INFO(files2)
+dest=FILE_INFO(files1) 
+
+;print, 'Size sce', sce[0].size
+;print, 'Size dest',  dest[0].size
+; if files1 et files2 have same size , cp ok
+
+for ii=0, N_ELEMENTS(sce)-1 do begin
+   if(sce[ii].size ne dest[ii].size ) then begin
+      MESSAGE, 'error cp', /continue
+      del_test_files , all_files_and_directories
+      EXIT, status=1
+   endif
+endfor
+
+;;;;;;;;;;;;;;;;;;;;;
+; How to verify with allow_same?
+
+; Without allow_same
+print , 'WITHOUT ALLOW_SAME' 
+FILE_COPY, files1 , files1
+
+
+; With Allow_same
+print , 'WITH ALLOW_SAME' 
+FILE_COPY, files1 , files1 , /allow_same
+
+;;;;;;;;;;;;;;;;;;;;;
+
+;recursive
+
+; Test with directories
+tdir3=['test_dir1' , '$&dir2_&-spec$'] ; 
+tdir2=['td2_1' , 'td2_2'] ; 
+td2cp=[tdir+'/td2_1' , tdir+'/td2_2'] ; 
+
+all_files_and_directories=[all_files_and_directories,tdir2]
+
+
+if FILE_TEST(tdir2[0], /directory) EQ 0 then SPAWN, 'mkdir '+tdir2[0]
+if FILE_TEST(tdir2[1], /directory) EQ 0 then SPAWN, 'mkdir '+tdir2[1]
+
+for ii=0,N_ELEMENTS(tdir2)-1 do begin
+   for jj=0, 5 do begin
+      fname = tdir2[ii]+'/'+STRCOMPRESS('fi' + string(jj), /remove_all)
+      SPAWN , 'touch '+fname
+   endfor
+endfor
+
+
+print , 'WITHOUT RECURSIVE'
+FILE_COPY, tdir2 , tdir
+;tdir/tdir2 : copy not allowed
+
+for ii=0, N_ELEMENTS(td2cp)-1 do begin
+   if(FILE_TEST(td2cp[ii]) eq 1 ) then begin
+      MESSAGE, 'error whtout rec', /continue
+      del_test_files , all_files_and_directories
+      EXIT, status=1
+   endif
+endfor
+
+
+print , 'WITH RECURSIVE'
+FILE_COPY, tdir2 , tdir , /recursive
+;copy ok
+sce=FILE_INFO(tdir2)
+dest=FILE_INFO(td2cp) 
+
+for ii=0, N_ELEMENTS(td2cp)-1 do begin
+   if(FILE_TEST(td2cp[ii]) eq 0 ) then begin
+      MESSAGE, 'error recursive', /continue
+      del_test_files , all_files_and_directories
+      EXIT, status=1
+   endif
+endfor
+
+
+;delete all
+del_test_files , all_files_and_directories
+
+
+
+print, 'All tests done'
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_file_delete.pro cvs/gdl/testsuite/test_file_delete.pro
--- gdl-0.9rc4/testsuite/test_file_delete.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_file_delete.pro	2010-06-29 02:47:39.000000000 -0600
@@ -0,0 +1,159 @@
+;
+; Lea Noreskal, June 2010
+; under GNU GPL 2 or later
+;
+; initial version by AC, 28 Avril 2009
+; very basic tests for FILE_DELETE
+;
+pro TEST_FILE_DELETE, full_test=full_test, test=test
+
+; Files
+files1=['fd_test1a','fd_test1b', '$chops &up str*ings.' ]
+file2='fd_test2'
+files3=['/etc/passwd', '/etc/passwd1']
+specfile='$f_tst*.mq' ; filename with special characters
+
+;
+; creation des fichiers temporaires de test
+;
+if FILE_TEST(files1[0]) EQ 0 then SPAWN, 'touch '+files1[0]
+if FILE_TEST(files1[1]) EQ 0 then SPAWN, 'touch '+files1[1]
+if FILE_TEST(files1[2]) EQ 0 then SPAWN, 'touch '+escape_special_char(files1[2])
+if FILE_TEST(file2) EQ 0 then SPAWN, 'touch '+file2
+;
+
+all_files_and_directories=files1 
+all_files_and_directories=[all_files_and_directories,file2]
+
+FILE_DELETE, files1, file2, /quiet
+
+for ii=0,N_ELEMENTS(files1)-1 do begin
+   if (FILE_TEST(files1[ii]) EQ 1 ) then begin
+      MESSAGE, 'files1 has not been deleted', /continue
+      del_test_files , all_files_and_directories
+      EXIT, status=1
+   endif
+endfor
+
+if (FILE_TEST(file2) EQ 1) then begin
+   MESSAGE, 'file2 has not been deleted', /continue
+   del_test_files , all_files_and_directories
+   EXIT, status=1
+endif
+
+; test with no existing file
+FILE_DELETE, specfile
+FILE_DELETE, specfile , /quiet
+FILE_DELETE, specfile , /allow_nonexistent
+FILE_DELETE, specfile , /quiet , /verbose
+
+; Test with directories 
+tdir=['test_dir1' , '$&dir2_&-spec$'] ; empty directories 
+tdir2=['td2_1' , 'td2_2'] ; Not empty directories
+
+
+print , 'Empty directories'
+if FILE_TEST(tdir[0], /directory) EQ 0 then SPAWN, 'mkdir '+tdir[0]
+if FILE_TEST(escape_special_char(tdir[1]), /directory) EQ 0 then SPAWN, 'mkdir '+escape_special_char(tdir[1])
+
+all_files_and_directories=[all_files_and_directories,tdir]
+
+FILE_DELETE, tdir 
+
+for ii=0,N_ELEMENTS(tdir)-1 do begin
+   if (FILE_TEST(tdir[ii]) EQ 1 ) then begin
+      MESSAGE, 'Empty directory has not been deleted', /continue
+      del_test_files , all_files_and_directories
+      ;FILE_DELETE, tdir , /recursive , /quiet
+     ; EXIT, status=1
+   endif
+endfor
+
+
+print , 'Not empty directories'
+if FILE_TEST(tdir2[0], /directory) EQ 0 then SPAWN, 'mkdir '+tdir2[0]
+if FILE_TEST(tdir2[1], /directory) EQ 0 then SPAWN, 'mkdir '+tdir2[1]
+all_files_and_directories=[all_files_and_directories,tdir2]
+
+for ii=0,N_ELEMENTS(tdir2)-1 do begin
+   for jj=0, 5 do begin
+      fname = tdir2[ii]+'/'+STRCOMPRESS('fi' + string(jj), /remove_all)
+      ;fname = tdir2[ii]+'/fi01'
+      SPAWN , 'touch '+fname
+   endfor
+endfor
+
+
+FILE_DELETE, tdir2[1] 
+
+if (FILE_TEST(tdir2[1]) EQ 0) then begin
+   MESSAGE, 'Not empty directory have been deleted..', /continue
+   del_test_files , all_files_and_directories
+   EXIT, status=1
+endif
+
+
+FILE_DELETE, tdir2 , /recursive
+
+if (FILE_TEST(tdir2[0]) EQ 1) then begin
+   MESSAGE, 'Directory has not been deleted with key word recursive', /continue
+   del_test_files , all_files_and_directories
+   EXIT, status=1
+endif
+
+;
+if KEYWORD_SET(full_test) then begin
+   print, 'Files we cannot remove'
+   FILE_DELETE, files3, /quiet
+   FILE_DELETE, files3, /allow
+   FILE_DELETE, files3, /verbose
+end
+;
+; Noexpand_path test
+; titi titit 
+
+
+file_exp=['titi', 'tititt' , 'ti*']
+
+for ii=0,N_ELEMENTS(file_exp)-1 do begin
+   if FILE_TEST(file_exp[ii],/noexpand) EQ 0 then SPAWN, 'touch '+escape_special_char(file_exp[ii])
+endfor
+
+
+
+SPAWN , 'ls'
+
+all_files_and_directories=[all_files_and_directories,file_exp]
+
+;file_to_supp=FILE_INFO('ti*' , /noexpand)
+FILE_DELETE , file_exp[2] , /noexpand
+
+if (FILE_TEST(file_exp[2], /noexpand) EQ 1) then begin
+   MESSAGE, 'file_exp[2] has not been deleted', /continue
+   del_test_files , all_files_and_directories
+   EXIT, status=1
+endif
+
+file_to_supp=FILE_INFO('ti*')
+FILE_DELETE , 'ti*'
+if (FILE_TEST(file_to_supp.name) EQ 1) then begin
+   MESSAGE, 'file has not been deleted , error expand', /continue
+   del_test_files , all_files_and_directories
+   EXIT, status=1
+endif
+;
+file_to_supp=FILE_INFO('ti*')
+FILE_DELETE , 'ti*'
+if (FILE_TEST(file_to_supp.name) EQ 1) then begin
+   MESSAGE, 'file has not been deleted , error expand', /continue
+   del_test_files , all_files_and_directories
+   EXIT, status=1
+endif
+
+
+print, 'All tests done'
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_file_dirname.pro cvs/gdl/testsuite/test_file_dirname.pro
--- gdl-0.9rc4/testsuite/test_file_dirname.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_file_dirname.pro	2010-06-29 02:47:39.000000000 -0600
@@ -0,0 +1,49 @@
+;
+; Doing a serie of tests for FILE_DIRNAME(),
+; including mandatory escape of special chars
+;
+; Lea Noreskal and Alain Coulais
+; June 2010
+; under GNU GPL 2 or later
+;
+pro TEST_FILE_DIRNAME, test=test
+
+;print, FILE_DIRNAME('GDLTokenTy\*') ; .
+if (FILE_DIRNAME('GDLTokenTy\*') NE '.') then begin
+   MESSAGE, /continue, ' FILE_DIRNAME(GDLTokenTy\*) NE .'
+   EXIT, status=1
+endif
+;
+;print, FILE_DIRNAME('GDLTokenTy*') ; .
+if (FILE_DIRNAME('GDLTokenTy*') NE '.') then begin
+   MESSAGE, /continue, 'FILE_DIRNAME : FILE_DIRNAME(GDLTokenTy\*) NE .'
+   EXIT, status=1
+endif
+;
+;print, FILE_DIRNAME('GDLTokenTy*/*') ; GDLTokenTy*
+if (FILE_DIRNAME('GDLTokenTy*/*') NE 'GDLTokenTy*') then begin
+   MESSAGE, /continue, 'FILE_DIRNAME(GDLTokenTy*/*) NE GDLTokenTy*'
+   EXIT, status=1
+endif
+;
+;print, FILE_DIRNAME('GDLTokenTy/*') ; GDLTokenTy*
+if (FILE_DIRNAME('GDLTokenTy/*') NE 'GDLTokenTy') then begin
+   MESSAGE, /continue, 'FILE_DIRNAME(GDLTokenTy/*) NE GDLTokenTy'
+   EXIT, status=1
+endif
+;
+;print, FILE_DIRNAME('/home/GDL/test/of/dir/name/*/*') ;
+;/home/GDL/test/of/dir/name/*
+; 
+my_path='/home/GDL/test/of/dir/name/*/*'
+if (FILE_DIRNAME(my_path) NE '/home/GDL/test/of/dir/name/*') then begin
+   MESSAGE, /continue, 'FILE_DIRNAME(/home/GDL/test/of/dir/name/*/*) NE /home/GDL/test/of/dir/name/*'
+   EXIT, status=1
+endif
+;
+MESSAGE, /continue, 'All tests done with success'
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_file_search.pro cvs/gdl/testsuite/test_file_search.pro
--- gdl-0.9rc4/testsuite/test_file_search.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_file_search.pro	2010-06-22 07:55:15.000000000 -0600
@@ -0,0 +1,84 @@
+;
+; Maxime Lenoir (contact also: Alain Coulais)
+; Distributed version 2010/06/21
+; Under GNU GPL V2 or later
+;
+; Purpose: Check FILE_SEARCH procedure with different glob patterns
+; Tests *,  [] patterns and /fold_case keyword
+;
+pro TEST_FILE_SEARCH_FREE,  fd
+for i=0, N_ELEMENTS(fd)-1 do begin
+    CLOSE, fd[i]
+    FREE_LUN, fd[i]
+endfor
+end
+;
+; --------------------------------------
+;
+pro TEST_FILE_SEARCH
+;
+OPENW, fd1, /delete, /get_lun, ']foo.txt'
+OPENW, fd2, /delete, /get_lun, 'foo\*.txt'
+OPENW, fd3, /delete, /get_lun, 'foobar.txt'
+OPENW, fd4, /delete, /get_lun, 'afoo.txt'
+OPENW, fd5, /delete, /get_lun, 'Afoo.txt'
+OPENW, fd6, /delete, /get_lun, 'AfoO.txt'
+OPENW, fd7, /delete, /get_lun, '[Foo'
+
+fd=[fd1, fd2, fd3, fd4, fd5, fd6, fd7]
+
+if FILE_SEARCH(']foo.txt') ne ']foo.txt' then begin 
+    MESSAGE, /continue, 'Fail with ]foo.txt'
+    TEST_FILE_SEARCH_free, fd
+    EXIT, status=1 
+endif
+
+if FILE_SEARCH('[]]foo.txt') ne ']foo.txt' then begin 
+    MESSAGE, /continue, 'Fail with []]foo.txt'
+    TEST_FILE_SEARCH_free, fd
+    EXIT, status=1
+endif
+
+f=FILE_SEARCH('foo*.txt')
+if WHERE(f eq 'foo*.txt') eq -1 or WHERE(f eq 'foobar.txt') eq -1 then begin 
+    MESSAGE, /continue, 'Fail with foo*.txt'
+    TEST_FILE_SEARCH_free, fd
+    EXIT, status=1
+endif
+
+if FILE_SEARCH('foo[*].txt') ne 'foo*.txt' then begin 
+    MESSAGE, /continue, 'Fail with foo[*].txt'
+    TEST_FILE_SEARCH_free, fd
+    EXIT, status=1
+endif
+
+f=FILE_SEARCH('[]a]foo*')
+if WHERE(f eq ']foo.txt') eq -1 or WHERE(f eq 'afoo.txt') eq -1 then begin 
+    MESSAGE, /continue, 'Fail with []a]foo*'
+    TEST_FILE_SEARCH_free, fd
+    EXIT, status=1
+endif
+
+f=FILE_SEARCH('afoo.txt', /fold_case)
+if WHERE(f eq 'AfoO.txt') eq -1 or WHERE(f eq 'Afoo.txt') eq -1 then begin
+    MESSAGE, /continue, 'Fail with afoo.txt,  /fold_case'
+    TEST_FILE_SEARCH_free, fd
+    EXIT, status=1
+endif
+
+f=FILE_SEARCH('[]a]foo*', /fold_case)
+if WHERE(f eq 'Afoo.txt') eq -1 or WHERE(f eq ']foo.txt') eq -1 or WHERE(f eq 'afoo.txt') eq -1 or WHERE(f eq 'AfoO.txt') then begin 
+    MESSAGE, /continue, 'Fail with []a]foo*,  /fold_case'
+    TEST_FILE_SEARCH_free, fd
+    EXIT, status=1
+endif
+
+if FILE_SEARCH('[foo', /fold_case) ne '[Foo' then begin
+    MESSAGE, /continue, 'Fail with [foo,  /fold_case'
+    TEST_FILE_SEARCH_free, fd
+    EXIT, status=1
+endif
+
+TEST_FILE_SEARCH_FREE, fd
+
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_fix.pro cvs/gdl/testsuite/test_fix.pro
--- gdl-0.9rc4/testsuite/test_fix.pro	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/testsuite/test_fix.pro	2010-04-16 11:22:54.000000000 -0600
@@ -28,7 +28,7 @@
 endif
 end
 ;
-pro TEST_FIX_ONE_VALUE, value=value, verbose=verbose, all_types=all_types
+function TEST_FIX_ONE_VALUE, value=value, verbose=verbose, all_types=all_types
 ;
 if KEYWORD_SET(verbose) then quiet=0 else quiet=1
 
@@ -48,7 +48,7 @@
 
 if (x LT 0.) then begin
    print, 'Positive input mandatory !'
-   return
+   return, 0
 endif
 ;
 separateur= '---------------------------'
@@ -95,14 +95,19 @@
    print, separateur
    print, 'Bad news ! At least one problem encoutered !'
    print, 'Please rerun this test with keyword /verbose !'
+   return, 0
 endif
 
+return, 1
+
 end
 
 
 pro TEST_FIX, verbose=verbose, all_types=all_types
-TEST_FIX_ONE_VALUE, value=1.001, verbose=verbose, all_types=all_types
-TEST_FIX_ONE_VALUE, value=10.1, verbose=verbose, all_types=all_types
-TEST_FIX_ONE_VALUE, value=1000.1, verbose=verbose, all_types=all_types
-TEST_FIX_ONE_VALUE, value=1000.1e5, verbose=verbose, all_types=all_types
+  ok = 1
+  ok and= TEST_FIX_ONE_VALUE(value=1.001, verbose=verbose, all_types=all_types) 
+  ok and= TEST_FIX_ONE_VALUE(value=10.1, verbose=verbose, all_types=all_types) 
+  ok and= TEST_FIX_ONE_VALUE(value=1000.1, verbose=verbose, all_types=all_types) 
+  ok and= TEST_FIX_ONE_VALUE(value=1000.1e5, verbose=verbose, all_types=all_types)
+  if ~ok then exit, status=1
 end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_float2string.pro cvs/gdl/testsuite/test_float2string.pro
--- gdl-0.9rc4/testsuite/test_float2string.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_float2string.pro	2010-06-29 08:10:15.000000000 -0600
@@ -0,0 +1,37 @@
+;
+; Alain Coulais, June 2010
+; under GNU GPL 2 or later
+;
+; few cases where STRING() conversion output
+; differ between IDL and GDL
+;
+pro TEST_FLOAT2STRING
+
+print, 'various Float conversion into strings:'
+
+print, STRING(123123.)
+print, STRING(123.)
+print, STRING(123.e)
+print, STRING(123.e0)
+print, STRING(123.e1)
+;
+print, STRING(123.e, format='(f13.2)')
+print, STRING(123.e, format='(e13.3)')
+print, STRING(123.e1)
+print, STRING(123.e1, format='(e13.3)')
+print, STRING(123.e1, format='(e13.4)')
+;print, STRING(123.e1, format='()')
+
+print, STRING(123.123e4)
+print, STRING(123.123e4, format='(e13.4)')
+;
+; bug id 2555865
+;
+print, 'conversion into strings in C style:'
+;
+resu=string(format='(%"test32T_%dinp.dat")',42)
+print, 'Expected: >>test32T_42dinp.dat<<'
+print, 'Result:   >>'+resu+'<<'
+if (STRLEN(resu) NE 17) then print, 'difference between Exp. and Res.'
+
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_gc.pro cvs/gdl/testsuite/test_gc.pro
--- gdl-0.9rc4/testsuite/test_gc.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_gc.pro	2010-03-22 14:44:23.000000000 -0600
@@ -0,0 +1,28 @@
+pro test_gc
+
+  a = total(memory() * [0,1,-1])                            ; n_alloc - n_free
+  if total(memory() * [0,1,-1]) - a ne 1 then begin         ; 1 for storing the 1 (? - hope I'm right ;))  
+    message, 'A (problem with memory() ?)', /conti
+    exit, status=1
+  endif
+
+  b = ptr_new(a)
+  if total(memory() * [0,1,-1]) - a ne 3 then begin         ; 3 for storing the 3, the copy of a, and the b
+    message, 'B (problem with memory() ?)', /conti
+    exit, status=1
+  endif
+
+  b = ptr_new(a, /no_copy)
+  if total(memory() * [0,1,-1]) - *b ne 2 then begin        ; 2 for storing the 2, and the b
+    message, 'C (problem with GC)', /conti
+    exit, status=1
+  endif
+
+  c = ptr_new(ptr_new(1))
+  c = 0.
+  if total(memory() * [0,1,-1]) - *b ne 3 then begin        ; 3 for storing the 3, the b, and the c
+    message, 'D (problem with GC)', /conti
+    exit, status=1
+  endif
+
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_get_screen_size.pro cvs/gdl/testsuite/test_get_screen_size.pro
--- gdl-0.9rc4/testsuite/test_get_screen_size.pro	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/testsuite/test_get_screen_size.pro	2010-07-07 14:41:02.823942151 -0600
@@ -1,18 +1,86 @@
 ;
-; AC 18/10/2009
-; under GNU/GPL 2 or later
+; AC 18/10/2009 under GNU/GPL 2 or later
+;
+; resived 03/05/2010 for integration in the "make check" testsuite
+;
+; purpose: quickly testing the GET_SCREEN_SIZE() function  
+;
+; ---------------------------------------------------
+;
+pro DEMO_GET_SCREEN_SIZE
 ;
-pro TEST_GET_SCREEN_SIZE
-
 print, 'basic test (call without Display name)'
 taille=GET_SCREEN_SIZE(resolution=resolution)
 print, 'Screen Size (in pixels) :', taille
 print, 'Pixel Size (in mm) :', resolution
-
+;
 print, 'On current Display, using ":0" as name'
 display=':0'
 taille=GET_SCREEN_SIZE(display, resolution=resolution)
 print, 'Screen Size (in pixels) :', taille
 print, 'Pixel Size (in mm) :', resolution
-
+;
+end
+;
+; ---------------------------------------------------
+;
+pro TESTING_GET_SCREEN_SIZE, test=test, exit_on_error=exit_on_error
+;
+print, 'basic test (call without Display name)'
+taille=GET_SCREEN_SIZE(resolution=resolution)
+print, 'Screen Size (in pixels) :', taille
+print, 'Pixel Size (in mm) :', resolution
+;
+; are the values "reasonnables" ?
+; 1/ positives values
+; 2/ (non blocking) quasi square pixels
+; 3/ (non blocking) non excessive aspect ratio for the whole screen
+;
+nb_doubts=0
+nb_pbs=0
+if (taille[0] LE 0) then nb_pbs=nb_pbs+1
+if (taille[1] LE 0) then nb_pbs=nb_pbs+1
+if (resolution[0] LE 0) then nb_pbs=nb_pbs+1
+if (resolution[1] LE 0) then nb_pbs=nb_pbs+1
+;
+pixel_aspect_ratio=resolution[1]/resolution[0]
+if ((pixel_aspect_ratio LT 0.95) OR (pixel_aspect_ratio GT 1.05)) then begin
+   nb_doubts=nb_doubts+1
+   MESSAGE, /continue, 'the pixels of this screen are not square !'
+endif
+;
+screen_aspect_ratio=taille[1]/taille[0]
+if ((screen_aspect_ratio LT 0.5) OR (screen_aspect_ratio GT 2.)) then begin
+   nb_doubts=nb_doubts+1
+   MESSAGE, /continue, 'this screen has strange aspect ration !! (> 2)'
+endif
+;
+if (nb_pbs GT 0) then begin
+   MESSAGE, STRING(nb_pbs)+' problem(s) found (size(s) <= 0 !!)', /continue
+   if KEYWORD_SET(exit_on_error) then EXIT, status=1
+endif else begin
+   MESSAGE, 'No problem found', /continue
+endelse
+;
+if (nb_doubts GT 0) then begin
+   MESSAGE, STRING(nb_doubts)+' doubt(s) found (see the values)', /continue
+endif else begin
+   MESSAGE, 'No doubt found', /continue
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; ---------------------------------------------------
+;
+pro TEST_GET_SCREEN_SIZE
+  ;
+  if getenv('DISPLAY') eq '' then begin
+    message, 'apparently no X connection is available (DISPLAY env. var. not set)', /conti
+    exit, status=77
+  endif 
+  ;
+  TESTING_GET_SCREEN_SIZE, /exit_on_error
+  ;
 end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_hist_2d.pro cvs/gdl/testsuite/test_hist_2d.pro
--- gdl-0.9rc4/testsuite/test_hist_2d.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_hist_2d.pro	2010-04-07 09:04:28.000000000 -0600
@@ -0,0 +1,67 @@
+; by Sylwester Arabas <slayoo@igf.fuw.edu.pl>
+
+pro ensure_equal, checkno, a, b
+  if ~array_equal(size(a), size(b)) || ~array_equal(a, b, /no_typeconv) then begin
+    message, "check " + checkno + " failed", /conti
+    exit, status=1
+  endif
+end
+
+pro test_hist_2d
+  
+  message, 'basic tests...', /conti
+  ensure_equal, '01', hist_2d([1],[1]), [[0,0],[0,1l]]                     ; \
+  ensure_equal, '02', hist_2d([0],[1],max1=.1), [[0],[1l]]                 ;  |- dimensions check
+  ensure_equal, '03', hist_2d([1],[0],max2=.1), reform([0,1l],2,1)         ; /
+  ensure_equal, '04', hist_2d([1,1],[1,1,1]), [[0,0],[0,2l]]               ; - non-equal array length
+  ensure_equal, '05', hist_2d(dist(2),dist(2),max2=1), [[1,0],[0,2l]]      ; - max2 kw check
+  ensure_equal, '06', hist_2d(dist(2),dist(2),max2=2), [[1,0],[0,3],[0,0l]]; - max2 kw check
+  ensure_equal, '07', hist_2d(dist(2),dist(2),max1=1), [[1,0],[0,2l]]      ; - max1 kw check
+  ensure_equal, '08', hist_2d(dist(2),dist(2),max1=2), [[1,0,0],[0,3,0l]]  ; - max1 kw check
+  ensure_equal, '09', hist_2d(dist(2),dist(2),bin1=2), [[1],[3l]]          ; - bin1 kw check
+  ensure_equal, '10', hist_2d(dist(2),dist(2),bin2=2), reform([1,3l],2,1)  ; - bin2 kw check
+
+  ; result should always be a 2D long array
+  data = [ $
+    ptr_new(1b), $
+    ptr_new([-3,4]), $
+    ptr_new(-10 + dindgen(20)), $
+    ptr_new(findgen(2,3,1,1,3)), $
+    ptr_new(randomn(seed, 3, 3)), $
+    ptr_new(1000*randomu(seed, 2,1,1,1,2)), $
+    ptr_new([1, !VALUES.D_NAN, !VALUES.D_NAN]), $
+    ptr_new([-10,-9]) $
+  ]
+  bins = [ptr_new(1b), ptr_new(.1)]
+  mins = [ptr_new(10b), ptr_new(-.1)]
+  maxs = [ptr_new(12b), ptr_new(13.)]
+  for i = 0, n_elements(data) - 1 do begin; first data array
+    message, 'case ' + strtrim(string(i + 1), 2) + ' / ' + strtrim(string(n_elements(data)), 2), /conti
+    for j = 0, n_elements(data) - 1 do begin; second data array
+      for mi1=0,1 do for mi2=0,1 do for ma1=0,1 do for ma2=0,1 do for bi1=0,1 do for bi2=0,1 do begin
+        for bare = 0, 1 do begin; with optional arguments or not
+          a = bare $
+            ? hist_2d(*(data[i]), *(data[j])) $
+            : hist_2d(*(data[i]), *(data[j]), $
+              min1=*(mins[mi1]), $
+              min2=*(mins[mi2]), $
+              max1=*(maxs[ma1]), $
+              max2=*(maxs[ma2]), $
+              bin1=*(bins[bi1]), $ 
+              bin2=*(bins[bi2]) $
+            )
+          if (size(a))[0] ne 2 || size(a,/type) ne 3 then begin
+            message, "ERROR", /conti
+            exit, status=1
+          endif
+        endfor
+      endfor
+    endfor
+  endfor
+
+  for i = 0, n_elements(data) - 1 do ptr_free, data[i]
+  for i = 0, n_elements(mins) - 1 do ptr_free, mins[i]
+  for i = 0, n_elements(maxs) - 1 do ptr_free, maxs[i]
+  for i = 0, n_elements(bins) - 1 do ptr_free, bins[i]
+
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_idl8.pro cvs/gdl/testsuite/test_idl8.pro
--- gdl-0.9rc4/testsuite/test_idl8.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_idl8.pro	2010-04-08 01:21:15.000000000 -0600
@@ -0,0 +1,45 @@
+pro o__define
+  struct = {o, a:0}
+end
+
+function o::aFun, v
+  return, v
+end
+
+pro o::aPro, v
+  v = 2
+end
+
+pro test_idl8
+
+  a = [1, 2, 3]
+
+  message, 'testing FOREACH statement', /conti
+  foreach i of a do i = 0 ; should do nothing
+  sum = 0
+  foreach i of a do begin
+    sum += i
+  end
+  if sum ne total(a) then begin
+    message, '1+2+3 != 6', /conti
+    exit, status=1
+  endif
+
+  message, 'testing negative array indices (for ranges)', /conti
+  if total(a[-2: -1]) ne total(a[n_elements(a) - 2 : n_elements(a) - 1]) then begin
+    message, '2+3 != 5', /conti
+    exit, status=1
+  endif
+  
+  message, 'testing the dot operator for member routine access', /conti
+  o = obj_new('o')
+  if o.aFun(1) ne 1 then begin
+    exit, status=1
+  endif
+  o.aPro, v
+  if v ne 2 then begin
+    exit, status=1
+  endif
+  obj_destroy, o
+
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_interpol.pro cvs/gdl/testsuite/test_interpol.pro
--- gdl-0.9rc4/testsuite/test_interpol.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_interpol.pro	2010-04-09 04:30:38.000000000 -0600
@@ -0,0 +1,39 @@
+; by Sylwester Arabas <slayoo@igf.fuw.edu.pl>
+pro test_interpol
+
+  ; test data - a parabola probed at four points
+  x = [0.,1.,2.,3.]
+  y = x*x
+
+  ; 2-parameter case, linear interpolation, sanity check
+  if ~array_equal(y, interpol(y, 4)) then begin
+    message, '2p, linear', /conti
+    exit, status=1
+  endif 
+
+  ; 2-parameter case, linear vs. spline interpolation
+  wh = where(interpol(y, 7, /spline) gt interpol(y, 7), cnt)
+  if cnt ne 0 then begin
+    message, '2p, spline', /conti
+    exit, status=1
+  endif
+
+  ; 3-parameter case, linear vs. spline interpolation
+  mid = [.5,1.5,2.5]
+  wh = where(interpol(y, x, mid, /spline) gt interpol(y, x, mid), cnt)
+  if cnt ne 0 then begin
+    message, '3p, spline', /conti
+    exit, status=1
+  endif
+
+  ; ensuring interpol(/spline) returns the same as spl_interp() 
+  ; (intentionally swapping x,y with y,x)
+  if ~array_equal( $
+    interpol(x, y, mid, /spline), $
+    spl_interp(y, x, spl_init(y, x), mid) $
+  ) then begin
+    message, 'interpol(/spline) != spl_interp', /conti
+    exit, status=1
+  endif
+
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_known_bugs.pro cvs/gdl/testsuite/test_known_bugs.pro
--- gdl-0.9rc4/testsuite/test_known_bugs.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_known_bugs.pro	2010-04-02 08:50:58.000000000 -0600
@@ -0,0 +1,101 @@
+;
+; AC 02 April 2010
+;
+; We put here some well known problems in order to help
+; beginners to setup well installed/compiled GDL 
+;
+; this program can be used in any versions of GDL
+; It should help you to found important bugs and
+; solution to avoid them.
+;
+; -----------------------------------------------
+;
+pro TEST_BUG_LENNY, verbose=verbose
+;
+if KEYWORD_SET(verbose) then begin
+    print, 'A bug related to ImageMagick and Plplot exists in'
+    print, 'Debian Lenny and (maybe) in recent Ubuntu (9.10, 10.4).'
+    print, 'If GDL crashs here, please re-compiled PLPlot library'
+    print, 'using option -DENABLE_DYNDRIVERS=OFF in cmake'
+endif
+;
+WINDOW
+WDELETE
+;
+if KEYWORD_SET(verbose) then begin
+    print, 'will crash here if plplot not well compiled (on some plateforms !)'
+endif
+;
+WINDOW
+WDELETE
+;
+print, 'test TEST_BUG_LENNY passed'
+;
+end
+;
+; -----------------------------------------------
+;
+pro TEST_BUG_FFT, verbose=verbose
+;
+if KEYWORD_SET(verbose) then begin
+    print, 'Old version of GDL do have, in the important FFT procedure,'
+    print, 'some bugs and bad managment of some type (Integer, Complex) in input'
+    print, 'This call helps you to quickly know if you must upgrade to version >= gdl-0.9rc4'
+endif
+;
+a=L64INDGEN(16)
+b=FFT(a)
+if TOTAL(ABS(a-b)) EQ 0 then begin
+    print, 'You are using an old version of GDL, please upgrade to gdl >= gdl-0.9rc4'
+    print, '(using FFTw library is better)'
+    print, 'test TEST_BUG_FFT *NOT* passed'
+    exit, 1
+endif
+;
+print, 'test TEST_BUG_FFT passed'
+;
+end
+;
+; -----------------------------------------------
+;
+pro TEST_BUG_SAVE_RESTORE, verbose=verbose
+;
+if KEYWORD_SET(verbose) then begin
+    print, 'A change in the CMSR library in May 2009 affects the behavior of SAVE/RESTORE in GDL'
+    print, 'If this test failed, please use an old version of the library'
+    print, 'or change line 286c279 in CMRESTORE '
+    print, 'bad    if nnames EQ 0 AND n_par EQ 0 then kall = 1'
+    print, 'good   if nnames EQ 0 then kall = 1'
+endif
+;
+a=1
+b=1.
+SAVE, file='DemoGDL.xdr', a, b
+RESTORE, file='DemoGDL.xdr', /verbose
+;
+print, 'test TEST_BUG_SAVE_RESTORE passed'
+;
+end
+;
+; -----------------------------------------------
+;
+pro TEST_KNOWN_BUGS, verbose=verbose, quiet=quiet
+;
+if NOT(KEYWORD_SET(quiet)) then begin
+    print, 'Despite strong efforts, GDL cannot take into account'
+    print, 'all tricks and problems in dependances and related softwares (libraries).'
+    print, 'In some cases, on some distributions, we know we have'
+    print, 'reproducible crashs and, with those programs, we try to help you to know' 
+    print, 'wether you will suffer from some problems'
+    print, ''
+    print, 'If GDL crashes when running first time this procedure, please re-run GDL and call:'
+    print, 'TEST_KNOWN_BUGS, /verbose'
+    print, 'in order to receive detailed informations about your problem'
+endif
+;
+TEST_BUG_LENNY, verbose=verbose
+TEST_BUG_FFT, verbose=verbose
+TEST_BUG_SAVE_RESTORE, verbose=verbose
+;
+end
+
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_memory.pro cvs/gdl/testsuite/test_memory.pro
--- gdl-0.9rc4/testsuite/test_memory.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_memory.pro	2010-06-04 15:01:32.000000000 -0600
@@ -0,0 +1,8 @@
+pro test_memory
+  mem = memory(/curr)
+  a = dblarr(99999)
+  if mem ge memory(/curr) then begin
+    message, 'reported memory consumption should increase after allocating a big array!', /conti
+    exit, status=1
+  endif
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_nans_in_sort_and_median.pro cvs/gdl/testsuite/test_nans_in_sort_and_median.pro
--- gdl-0.9rc4/testsuite/test_nans_in_sort_and_median.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_nans_in_sort_and_median.pro	2010-06-05 03:51:58.000000000 -0600
@@ -0,0 +1,81 @@
+; by Sylwester Arabas <slayoo@igf.fuw.edu.pl>
+; a follow-up to the bug-report by Boud Roukema (tracker item no. 2985552)
+pro test_nans_in_sort_and_median
+
+  ; testing behaviour of SORT() with NaN, inf, -inf
+
+  a = [1, !VALUES.F_NAN, -1]
+  if ~array_equal(sort(a), [2,0,1]) then begin
+    message, 'sort() failed to sort an array containing a float NaN', /conti
+    exit, status=1
+  endif
+
+  a = double(a)
+  if ~array_equal(sort(a), [2,0,1]) then begin
+    message, 'sort() failed to sort an array containing a double NaN', /conti
+    exit, status=1
+  endif
+
+  a = [1, !VALUES.F_INFINITY, -!VALUES.F_INFINITY, -1]
+  if ~array_equal(sort(a), [2,3,0,1]) then begin
+    message, 'sort() failed to sort an array containing float Infs', /conti
+    exit, status=1
+  endif
+
+  a = double(a)
+  if ~array_equal(sort(a), [2,3,0,1]) then begin
+    message, 'sort() failed to sort an array containing double Infs', /conti
+    exit, status=1
+  endif
+
+  ; testing behaviour of MEDIAN() with NaN, inf, -inf
+
+  a = [-500, !VALUES.F_NAN, !VALUES.F_INFINITY, -!VALUES.F_INFINITY, 500, 600.0]
+  if median(a) ne median(a[where(finite(a))]) then begin
+    message, 'median() failed to compute the median for a 1D array cotaining float NaN/Infs', /conti
+    exit, status=1
+  endif
+
+  a = double(a)
+  if median(a) ne median(a[where(finite(a))]) then begin
+    message, 'median() failed to compute the median for a 1D array cotaining double NaN/Infs', /conti
+    exit, status=1
+  endif
+
+  a = [[-500, !VALUES.F_INFINITY], [-!VALUES.F_INFINITY, 600.0]]
+  if ~array_equal(median(a, dim=1), [!VALUES.F_INFINITY, 600]) then begin
+    message, 'median() failed to compute the median for a 2D array cotaining float Infs', /conti
+    exit, status=1
+  endif
+
+  a = double(a)
+  if ~array_equal(median(a, dim=1), [!VALUES.F_INFINITY, 600]) then begin
+    message, 'median() failed to compute the median for a 2D array cotaining double Infs', /conti
+    exit, status=1
+  endif
+
+  a = [[-500, !VALUES.F_NAN], [-!VALUES.F_NAN, 600.0]]
+  if ~array_equal(median(a, dim=1), [-500, 600]) then begin
+    message, 'median() failed to compute the median for a 2D array cotaining float NaNs', /conti
+    exit, status=1
+  endif
+
+  a = double(a)
+  if ~array_equal(median(a, dim=1), [-500, 600]) then begin
+    message, 'median() failed to compute the median for a 2D array cotaining double NaNs', /conti
+    exit, status=1
+  endif
+
+  a = [[-500, !VALUES.F_NAN, !VALUES.F_INFINITY], [-!VALUES.F_INFINITY, 500, 600.0]]
+  if ~array_equal(median(a, dim=1), [!VALUES.F_INFINITY, 500]) then begin
+    message, 'median() failed to compute the median for a 2D array cotaining float NaNs and Infs', /conti
+    exit, status=1
+  endif
+
+  a = double(a)
+  if ~array_equal(median(a, dim=1), [!VALUES.F_INFINITY, 500]) then begin
+    message, 'median() failed to compute the median for a 2D array cotaining double NaNs and Infs', /conti
+    exit, status=1
+  endif
+
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_pmulti.pro cvs/gdl/testsuite/test_pmulti.pro
--- gdl-0.9rc4/testsuite/test_pmulti.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_pmulti.pro	2010-06-05 04:43:03.000000000 -0600
@@ -0,0 +1,23 @@
+; by Sylwester Arabas <slayoo@igf.fuw.edu.pl>
+pro test_pmulti
+
+  foreach dev of ['z', 'ps', 'svg'] do begin
+
+    set_plot, dev
+    if dev ne 'z' then device, filename='/dev/null'
+
+    !P.MULTI=[1,3,1] & plot, [0] 
+    if !P.MULTI[0] ne 0 then begin
+      message, '!P.MULTI[1,3,1] check failed for device >>' + dev + '<<', /conti
+      exit, status=1
+    endif
+
+    !P.MULTI=[2,3,1] & plot, [0] 
+    if !P.MULTI[0] ne 1 then begin
+      message, '!P.MULTI[2,3,1] check failed for device >>' + dev + '<<', /conti
+      exit, status=1
+    endif
+ 
+  endforeach
+
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_point_lun.pro cvs/gdl/testsuite/test_point_lun.pro
--- gdl-0.9rc4/testsuite/test_point_lun.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_point_lun.pro	2010-06-29 08:10:15.000000000 -0600
@@ -0,0 +1,51 @@
+;
+; Eriv Hivon, April 2010
+; under GNU GPL 2 or later
+;
+; Related to contribution of Maxime Lenoir in June 2010,
+; see also "test_zip.pro" in testsuite/
+;
+; Simple tests on POINT_LUN
+;
+; Works in IDL and in GDL (CVS version since 29 june 2010)
+;
+pro READ_4B_FILE, file, compress=compress
+
+x = BYTARR(1)
+
+print,'reading 4 times the 1st character of '+file
+print,'compress ',compress
+openr, lun, file, /get_lun, compress=compress
+for i=0,3 do begin 
+    point_lun, lun, 0L  ; <<< rewind
+    readu,lun,x & print,string(x)
+endfor
+free_lun, lun
+
+return
+end
+
+pro TEST_POINT_LUN
+
+; file creation
+file = '/tmp/file.txt'
+filegz = file+'.gz'
+openw,lun,file,/get_lun
+printf,lun,'abcd'
+free_lun,lun
+
+; read raw file
+read_4b_file, file, compress=0
+
+; read raw file
+read_4b_file, file, compress=1
+
+; compress file
+spawn,'gzip -f '+file,/sh
+
+; read compressed file
+read_4b_file, filegz, compress=1
+
+return
+end
+
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_product.pro cvs/gdl/testsuite/test_product.pro
--- gdl-0.9rc4/testsuite/test_product.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_product.pro	2010-05-21 10:24:01.329908063 -0600
@@ -0,0 +1,198 @@
+;
+; AC 04/02/2010 under GNU GPL v2/3
+;
+; Test of PRODUCT, some options are mandatory
+; for READFITS routine in Astron package
+;
+pro TEST_PRODUCT_BASIC
+
+a=[1,2,3,4,5]
+
+print, 'input :', a
+print, PRODUCT(a)
+print, PRODUCT(a,/cumul)
+print, PRODUCT(a,/int)
+print, PRODUCT(a,/cumul,/int)
+;
+print, 'Same data but with NaN ...'
+;
+a=FINDGEN(5)+1     
+a[2]=!values.f_nan
+print, 'input :', a
+print, PRODUCT(a,/nan)
+print, PRODUCT(a,/cumul,/nan)
+print, PRODUCT(a,/int,/nan)
+print, PRODUCT(a,/cumul,/int,/nan)
+;
+end
+;
+; ---------------------------
+;
+pro TEST_PRODUCT_1D, help=help, nan=nan, no_format=no_format
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro TEST_PRODUCT_1D, help=help, nan=nan, no_format=no_format'
+   return
+endif
+
+if NOT(KEYWORD_SET(no_format)) then begin
+   f4='(A,4G12)' & i4='(A,4I12)'
+   fi='(A,G12)'  & i1='(A,I12)'
+endif else begin
+   ;; not ready in GDL (AC 11/02/2010) 
+   f4='' & f1=''
+   i4='' & i1=''
+endelse
+;
+txt0='input   '
+txt1='cumul   '
+txt2='product '
+txtNaN='(with /Nan) :'
+txtNon='(NONE /Nan) :'
+  vide='            :'
+txt0=txt0+vide
+;
+print, 'Reference WITHOUT Infinity nor NaN'
+;
+a=FINDGEN(4)+1
+;
+print, format=f1, txt0, a
+print, format=i4, txt1+txtNon, PRODUCT(a,/int,/cum)
+print, format=i4, txt1+txtNaN, PRODUCT(a,/int,/cum,/nan)
+print, format=i1, txt2+txtNon, PRODUCT(a,/int)
+print, format=i1, txt2+txtNaN, PRODUCT(a,/int,/nan)
+;
+print, 'Running WITH Infinity OR NaN (/nan)'
+;
+b=a
+b[1]=!values.f_infinity
+if KEYWORD_SET(nan) then b[1]=!values.f_nan
+;
+print, format=f1, txt0, b
+print, format=i4, txt1+txtNon, PRODUCT(b,/int,/cum)
+print, format=i4, txt1+txtNaN, PRODUCT(b,/int,/cum,/nan)
+print, format=i1, txt2+txtNon, PRODUCT(b,/int)
+print, format=i1, txt2+txtNaN, PRODUCT(b,/int,/nan)
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; ---------------------------------
+;
+pro TEST_PRODUCT_2D, dim=dim, test=test
+
+print, 'Reference WITHOUT dim and WITHOUT Infinity nor NaN'
+
+a=FINDGEN(2,3)+1
+
+print, PRODUCT(a,/int)
+print, PRODUCT(a,/int,/nan)
+print, PRODUCT(a,/int,/cum)
+print, PRODUCT(a,/int,/cum,/nan)
+
+print, 'data WITHOUT dim and WITH Infinity nor NaN'
+
+b=a
+b[1]=!values.f_infinity
+
+print, PRODUCT(b,/int)
+print, PRODUCT(b,/int,/nan)
+print, PRODUCT(b,/int,/cum)
+print, PRODUCT(b,/int,/cum,/nan)
+
+dim=1
+
+print, 'Reference WITHOUT dim and WITHOUT Infinity nor NaN'
+
+a=FINDGEN(2,3)+1
+
+print, PRODUCT(a,dim,/int)
+print, PRODUCT(a,dim,/int,/nan)
+print, PRODUCT(a,dim,/int,/cum)
+print, PRODUCT(a,dim,/int,/cum,/nan)
+
+print, 'data WITHOUT dim and WITH Infinity nor NaN'
+
+b=a
+b[1]=!values.f_infinity
+
+print, PRODUCT(b,dim,/int)
+print, PRODUCT(b,dim,/int,/nan)
+print, PRODUCT(b,dim,/int,/cum)
+print, PRODUCT(b,dim,/int,/cum,/nan)
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; ---------------------------------------------------
+;
+pro TEST_PRODUCT_ALL_TYPE, test=test, nan=nan, $
+                           verbose=verbose, very_verbose=very_verbose, $
+                           exit_on_error=exit_on_error
+; list of TYPE
+; http://idlastro.gsfc.nasa.gov/idl_html_help/SIZE.html
+;
+a=INDGEN(5)+1
+;
+; not ready now, pb with INT types ...
+if KEYWORD_SET(nan) then begin
+   print, 'Sorry, this option is not ready now'
+                                ;a[2]=!value.f_nan
+endif
+;
+ref1=PRODUCT(a)
+ref2=PRODUCT(a,/int)
+ref3=PRODUCT(a,/cumul)
+ref4=PRODUCT(a,/cumul,/int)
+tref3=TOTAL(ref3)
+tref4=TOTAL(ref4)
+;
+for ii=1, 15 do begin
+   if ii EQ 7 then CONTINUE   ;; String
+   if ii EQ 8 then CONTINUE   ;; Struc
+   if ii EQ 10 then CONTINUE  ;; Pointer
+   if ii EQ 11 then CONTINUE  ;; Objref
+   ;;
+   a=1b+INDGEN(5, type=ii)
+   ;;
+   err=''
+   if (ABS(ref1- PRODUCT(a)) GT 1e-6) then err=err+'Erreur 1, '
+   if (ABS(tref3-TOTAL(PRODUCT(a,/cumul))) GT 1e-6) then err=err+'Erreur 2, '
+   if (ABS(ref2- PRODUCT(a,/int)) GT 1e-6) then err=err+'Erreur 3, '
+   if (ABS(tref4-TOTAL(PRODUCT(a,/int, /cumul))) GT 1e-6) then err=err+'Erreur 4, '
+   ;;
+   if STRLEN(err) EQ 0 then begin
+      err='None'
+   endif else begin
+      if KEYWORD_SET(exit_on_error) then begin
+         MESSAGE, err + '(type: ' + SIZE(A,/type) + ')', /conti
+         EXIT, status=1
+      endif
+   endelse
+   ;;
+   if KEYWORD_SET(verbose) then begin
+      print, 'current TYPE : ', SIZE(A,/type), ', Type of Errors: ', err
+   endif
+   if KEYWORD_SET(very_verbose) then begin
+      print, 'raw :', PRODUCT(a)
+      print, '/cumul :', PRODUCT(a,/cumul)
+      print, '/int :', PRODUCT(a,/int)
+      print, '/int, /cumul :', PRODUCT(a,/cumul,/int)
+   endif
+endfor
+;
+if KEYWORD_SET(exit_on_error) then MESSAGE, /continue, 'All tests OK'
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; ---------------------------------------------------
+;
+; SA: for inclusion in the "make check" rule
+pro TEST_PRODUCT
+  TEST_PRODUCT_BASIC
+  TEST_PRODUCT_ALL_TYPE, /exit_on_error
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_readf.pro cvs/gdl/testsuite/test_readf.pro
--- gdl-0.9rc4/testsuite/test_readf.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_readf.pro	2010-06-15 08:21:58.000000000 -0600
@@ -0,0 +1,138 @@
+;
+; Maxime Lenoir (contact also: Alain Coulais)
+; Distributed version 2010/06/14
+; Under GNU GPL V2 or later
+;
+; Purpose: Check READF procedure with different end-of-line characters (CR, LF, CRLF)
+; @2010/06/14 : issue with lines ended with CR character
+;
+; --------------------------------------------
+;
+; due to changes by Alain, no more useful
+;
+; pro TESTREADF_ERR, type
+; ;
+; MESSAGE, /continue, '% TEST_READF: failed with '+type+' char'
+; SPAWN, 'rm -f testreadf.txt'
+; EXIT, status=1
+; ;
+; end
+;
+pro MINIREREADF, filename
+;
+if N_PARAMS() EQ 0 then begin
+    MESSAGE, /continue, 'You mus provide a Filename !'
+    return
+endif
+;
+resu=FILE_INFO(filename)
+if (resu.exists NE 1) then begin
+    MESSAGE, /continue, 'File : '+filename+' not available'
+    return
+endif
+;
+line=''
+;
+OPENR, lun, /get_lun, filename
+WHILE ~EOF(lun) do begin
+    READF, lun, line
+    print, line
+endwhile
+;
+end
+;
+; --------------------------------------------
+;
+pro TESTREADF, verbose=verbose, type=type, no_erase=no_erase, errors=errors
+;
+if KEYWORD_SET(verbose) then begin
+    print, '====='
+    print, 'test'+type+':'
+endif
+case type of
+    'CR': begin
+        char='\r'
+        suffixe='CR.txt'
+    end
+    'LF': begin
+        char='\n'
+        suffixe='LF.txt'
+    end
+    'CRLF': begin
+        char='\r\n'
+        suffixe='CRLF.txt'
+    end
+    else: begin
+        MESSAGE, /continue, 'type={CR, LF, CRLF}'
+        EXIT, status=1
+    end
+endcase
+;
+DEFSYSV, '!gdl', exists=is_it_gdl
+if (is_it_gdl EQ 1) then soft='GDL' else soft='IDL'
+;
+filename='TestReadF_'+soft+'_'+suffixe
+;
+; generating the ASCII file
+;
+SPAWN, 'echo -e "testl1'+char+'testl2" > '+filename
+;
+; reading back the generated ASCII file
+;
+OPENR, fd, filename, /get_lun
+str=''
+;
+; reading first line
+;
+READF, fd, str
+if (str NE 'testl1') then begin
+    MESSAGE, /continue, '% TEST_READF: failed with '+type+' char'
+    errors=errors+1
+endif
+if KEYWORD_SET(verbose) then print, str
+if EOF(fd) then begin
+    MESSAGE, /continue, '% TEST_READF: failed with '+type+' char'
+    errors=errors+1
+endif else begin
+    ;;
+    ;; reading second line
+    ;;
+    READF, fd, str
+    if (str NE 'testl2') then begin
+        MESSAGE, /continue, '% TEST_READF: failed with '+type+' char'
+        errors=errors+1
+    endif
+    if KEYWORD_SET(verbose) then print, str
+endelse
+;
+CLOSE, fd
+FREE_LUN, fd
+;
+if NOT(KEYWORD_SET(no_erase)) then SPAWN, 'rm -f '+filename
+;
+end
+;
+; --------------------------------------------
+;
+pro TEST_READF, verbose=verbose, no_erase=no_erase, help=help
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro TEST_READF, verbose=verbose, no_erase=no_erase, help=help'
+    return
+endif
+;
+if KEYWORD_SET(verbose) then begin
+    print, 'Should print (for each pro):'
+    print, 'testl1'
+    print, 'testl2'
+endif
+;
+errors=0
+;
+TESTREADF, verbose=verbose, no_erase=no_erase, errors=errors, type='LF'
+TESTREADF, verbose=verbose, no_erase=no_erase, errors=errors, type='CRLF'
+TESTREADF, verbose=verbose, no_erase=no_erase, errors=errors, type='CR'
+;
+if (errors GT 0) then EXIT, status=1
+;
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_read_jpeg.pro cvs/gdl/testsuite/test_read_jpeg.pro
--- gdl-0.9rc4/testsuite/test_read_jpeg.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_read_jpeg.pro	2010-04-14 09:07:58.000000000 -0600
@@ -0,0 +1,109 @@
+;
+; AC 28/01/2010
+;
+; quick test reading back and displaying a JPEG
+;
+; What is tested ?
+; -- reading back a small (600x259) JPEG image
+; -- using well positions index in TVSCL
+;
+pro TEST_READ_JPEG, filename=filename, path=path, $
+                    help=help, test=test, debug=debug, verbose=verbose
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro TEST_READ_JPEG, filename=filename, path=path, factor=factor, $'
+   print, '                 help=help, test=test, debug=debug, verbose=verbose'
+   print, ''
+   print, 'You can provide any JPEG image using FILENAME='
+   print, 'We look in !Path. You can provide alternate paths with PATH='
+   return
+endif
+;
+if N_ELEMENTS(path) EQ 0 then path=!path
+if N_ELEMENTS(filename) EQ 0 then filename='Saturn.jpg'
+;
+title0='the 3 channels in greyscale'
+title1='<<'+filename+'>> in Colors'
+;
+liste_of_files=FILE_SEARCH(STRSPLIT(path,':',/ex),filename)
+;
+if (N_ELEMENTS(liste_of_files) EQ 1) then begin
+   if (STRLEN(liste_of_files) EQ 0) then begin
+      MESSAGE, /continue, 'No file founded ...'
+      MESSAGE, /continue, 'File : '+filename
+      MESSAGE, /continue, 'Path : '+path
+      return
+   endif
+   one_file_and_path=liste_of_files
+endif
+if N_ELEMENTS(liste_of_files) GT 1 then begin
+   MESSAGE, /continue, $
+            'Warning: more than one file found, we used the first one !'
+   one_file_and_path=liste_of_files[0]
+endif
+;
+if KEYWORD_SET(verbose) then begin
+   MESSAGE, 'reading : '+one_file_and_path, /continue
+endif
+;
+READ_JPEG, one_file_and_path, image
+;
+xy_img=(SIZE(image,/dim))[1:2]
+xy_screen=GET_SCREEN_SIZE()
+loose=50 ; perte (surtout en vertical: la/les barre(s) de menu KDE/Gnome
+xy_screen=xy_screen-loose
+;
+vertical=-1
+; rentre-t-on dans de l'horizontal ?
+if (xy_screen[0] GT 3*xy_img[0]) AND (xy_screen[1] GT xy_img[1]) then begin
+   vertical=0
+   xy_win0=xy_img
+   xy_win0[0]=xy_win0[0]*3
+   xy_win1=xy_img
+endif
+; rentre-t-on dans du vertical ? (on prefere ce mode-ci)
+if (xy_screen[0] GT xy_img[0]) AND (xy_screen[1] GT 3*xy_img[1]) then begin
+   vertical=1
+   xy_win0=xy_img
+   xy_win0[1]=xy_win0[1]*3
+   xy_win1=xy_img
+endif
+;
+if (vertical EQ -1) then begin
+   MESSAGE, /continue, 'Soo small screen/too big image ! automatic rescaling !!'
+   MESSAGE, /continue, 'Some part of the image may be cut (top and right sides)'
+   ;;
+   factor_h_x=ROUND(1+xy_img[0]*3/xy_screen[0])
+   factor_h_y=ROUND(1+xy_img[1]/xy_screen[1])
+   factor_v_x=ROUND(1+xy_img[0]/xy_screen[0])
+   factor_v_y=ROUND(1+xy_img[1]*3/xy_screen[1])
+   factor_h=MAX([factor_h_x,factor_h_y])
+   factor_v=MAX([factor_v_x,factor_v_y])
+   factor=MIN([factor_h,factor_v],vertical)
+   ;;
+   xy_win1=xy_img/factor
+   image=REBIN(image[*,0:xy_win1[0]*factor-1,0:xy_win1[1]*factor-1],3,xy_win1[0],xy_win1[1])
+   ;;
+   xy_win0=xy_img/factor
+   if (vertical EQ 1) then begin
+      xy_win0[1]=xy_win0[1]*3
+   endif else begin
+      xy_win0[0]=xy_win0[0]*3
+   endelse
+endif
+;
+; just a trick to be able to test for small screens
+if KEYWORD_SET(debug) then half=debug
+;
+WINDOW, 0, xsize=xy_win0[0], ysize=xy_win0[1], title=title0
+TVSCL, image[0,*,*], 0
+TVSCL, image[1,*,*], 1
+TVSCL, image[2,*,*], 2
+;
+WINDOW, 1, xsize=xy_win1[0], ysize=xy_win1[1], title=title1
+TVSCL, image, /true
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_rebin.pro cvs/gdl/testsuite/test_rebin.pro
--- gdl-0.9rc4/testsuite/test_rebin.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_rebin.pro	2010-02-20 13:46:27.000000000 -0700
@@ -0,0 +1,11 @@
+; by Sylwester Arabas <slayoo@igf.fuw.edu.pl>
+pro test_rebin
+  ; testing the two ways of specifying new dimensions:
+  a = randomn(seed,2,3,4,5)
+  if $
+    ~array_equal(size(a), size(rebin(a,2,3,4,5))) || $
+    ~array_equal(size(a), size(rebin(a,[2,3,4,5]))) || $
+    ~array_equal([4,6,8,10], size(rebin(a,4,6,8,10), /dim)) || $
+    ~array_equal([4,6,8,10], size(rebin(a,[4,6,8,10]), /dim)) $
+  then exit, status=1
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_spher_harm.pro cvs/gdl/testsuite/test_spher_harm.pro
--- gdl-0.9rc4/testsuite/test_spher_harm.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_spher_harm.pro	2010-05-31 04:59:21.000000000 -0600
@@ -0,0 +1,105 @@
+; by Sylwester Arabas <slayoo@igf.fuw.edu.pl>
+
+; this one does not perform any sanity checks, and is intedned
+; only for testing the C++ implementation as done below
+function spher_harm_gdl, theta, phi, l, m
+  return, sqrt( $
+    (2. * l + 1) / 4. / !PI * factorial(l - abs(m)) / factorial(l + abs(m)) $
+  ) * legendre(cos(theta), l, abs(m)) * exp(complex(0, m * phi)) * (m lt 0 ? -1. : 1.)^m
+end
+
+; tests SPHER_HARM (and btw FACTORIAL and LEGENDRE)
+pro test_spher_harm
+
+  ; testing output shape
+  if size(spher_harm(0.,0.,0,0), /dimensions) ne 0 then begin
+    message, 'spher_harm(scalar, ...) should be scalar', /conti
+    exit, status=1
+  endif
+  if size(spher_harm([0.],[0.],0,0), /dimensions) ne 1 then begin
+    message, 'spher_harm([scalar], ...) should be vector', /conti
+    exit, status=1
+  endif
+  if n_elements(spher_harm([0.,0.,0.],0.,0,0)) ne 3 then begin
+    message, 'spher_harm(vector, scalar, ...) should be vector', /conti
+    exit, status=1
+  endif
+  if n_elements(spher_harm(0.,[0.,0.,0.],0,0)) ne 3 then begin
+    message, 'spher_harm(scalar, vector, ...) should be vector', /conti
+    exit, status=1
+  endif
+
+  ; testing output type
+  in = [ $
+    ptr_new(1b), $
+    ptr_new(1), $
+    ptr_new(1l), $
+    ptr_new(1.), $
+    ptr_new(1d), $
+    ptr_new(complex(1,1)), $
+    ptr_new(dcomplex(1,1)), $
+    ptr_new([1b]), $
+    ptr_new([1]), $
+    ptr_new([1l]), $
+    ptr_new([1.]), $
+    ptr_new([1d]), $
+    ptr_new([complex(1,1)]), $
+    ptr_new([dcomplex(1,1)]) $
+  ]
+  foreach i of in do begin
+    if (size(spher_harm(*i, 0d, 0, 0), /type) ne 9) then begin
+      message, 'spher_harm(*, double, ...) should be dcomplex'
+      exit, status=1
+    endif
+    if (size(spher_harm(*i, 0., 0, 0, /double), /type) ne 9) then begin
+      message, 'spher_harm(*, *, ..., /double) should be dcomplex'
+      exit, status=1
+    endif
+    if size(*i, /type) ne 9 && size(*i, /type) ne 5 then begin
+      if (size(spher_harm(*i, 0., 0, 0), /type) ne 6) then begin
+        message, 'spher_harm(not double, not double, ...) should be complex'
+        exit, status=1
+      endif
+    endif
+  endforeach
+  foreach i of in do ptr_free, i
+
+  ; testing output values against GDL-computed harmonics
+  thetas = findgen(10.)
+  phis = dindgen(5.)
+  ls = indgen(2)
+  eps = 1e-7
+  foreach theta of thetas do foreach phi of phis do foreach l of ls do begin
+    foreach m of indgen(2*l+1) - l do begin
+      ; scalar computations
+      if abs(spher_harm(theta, phi, l, m) - spher_harm_gdl(theta, phi, l, m)) gt eps then begin
+        message, 'spher_harm() != spher_harm_gdl()', /conti
+        exit, status=1
+      endif
+
+      ; vector computations
+      if total(abs(spher_harm(thetas, phi, l, m) - spher_harm_gdl(thetas, phi, l, m))) gt eps then begin
+        message, 'spher_harm(vector, scalar, ...) != spher_harm_gdl(vector, scalar, ...)', /conti
+        exit, status=1
+      endif
+      if total(abs(spher_harm(theta, phis, l, m) - spher_harm_gdl(theta, phis, l, m))) gt eps then begin
+        message, 'spher_harm(scalar, vector, ...) != spher_harm_gdl(scalar, vector, ...)', /conti
+        exit, status=1
+      endif
+      if total(abs(spher_harm(theta, phis, l, m) - spher_harm_gdl(theta, phis, l, m))) gt eps then begin
+        message, 'spher_harm(vector, vector, ...) != spher_harm_gdl(vector, vector, ...)', /conti
+        exit, status=1
+      endif
+
+      ; one more check for negative-m case
+      if m lt 0 then begin
+        if spher_harm(theta, phi, l, m) ne (-1)^(-m) * conj(spher_harm(theta, phi, l, -m)) then begin 
+          message, 'spher_harm(..., -m) != -1^m * conj(spher_harm(..., m))', /conti
+          exit, status=1
+        endif
+      endif
+
+    endforeach
+  endforeach
+
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_spl_init.pro cvs/gdl/testsuite/test_spl_init.pro
--- gdl-0.9rc4/testsuite/test_spl_init.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_spl_init.pro	2010-05-31 07:20:34.000000000 -0600
@@ -0,0 +1,163 @@
+;
+; testsuite for the SPL_INIT function
+; Lea Noreskal and Alain Coulais
+; Mai 2010
+; under GNU GPL 2 or later
+;
+pro TEST_SPL_INIT, test=test, help=help
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro TEST_SPL_INIT, test=test, help=help'
+   return
+endif
+;
+; generating well known input
+x=(FINDGEN(21)/20.)*2.0*!PI  
+y=SIN(X)  
+a=FINDGEN(5)
+b=MAKE_ARRAY(7,/DOUBLE, VALUE = 1)
+c=[1,2,!values.f_nan,4,5]
+;
+status=0
+;
+; -------------------------------
+; Result equal to NaN
+;
+;  YP0=NaN
+result=SPL_INIT(X, Y, YP0 = !values.f_nan, YPN_1 = 0.0)
+
+if (TOTAL(FINITE(result, /NaN)) NE N_ELEMENTS(result) ) then begin
+   MESSAGE, 'result ne NaN', /continue
+   EXIT, status=1
+endif
+;
+; YPN_1=NaN
+;
+result=SPL_INIT(X, Y, YP0 = 0.0, YPN_1 = !values.f_nan)
+;
+if (TOTAL(FINITE(result, /NaN)) NE N_ELEMENTS(result) ) then begin
+   MESSAGE, 'result ne NaN', /continue
+   EXIT, status=1
+endif
+
+
+; YP0=YPN_1=NaN
+result=SPL_INIT(X, Y, YP0 = !values.f_nan, YPN_1 = !values.f_nan)
+
+if (TOTAL(FINITE(result, /NaN)) NE N_ELEMENTS(result) ) then begin
+   MESSAGE, 'result ne NaN', /continue
+   EXIT, status=1
+endif
+;
+; X contains a Nan value
+;
+result=SPL_INIT(c, a) 
+if (TOTAL(FINITE(result, /NaN)) NE N_ELEMENTS(result) ) then begin
+   MESSAGE, 'result ne NaN', /continue
+   EXIT, status=1
+endif
+
+; Y contains a Nan value
+result=SPL_INIT(A, C) 
+if (TOTAL(FINITE(result, /NaN)) NE N_ELEMENTS(result) ) then begin
+   MESSAGE, 'result ne NaN', /continue
+   EXIT, status=1
+endif
+
+; At least two consecutive X values are identical
+result=SPL_INIT(B, B) 
+if (TOTAL(FINITE(result, /NaN)) NE N_ELEMENTS(result) ) then begin
+   MESSAGE, 'result ne NaN', /continue
+   EXIT, status=1
+endif
+;
+; -------------------------------
+; When giving 0 value as keyword, sould return same results
+; than without keywords
+;
+yy=MAKE_ARRAY(N_ELEMENTS(X),/DOUBLE, VALUE = 1)
+;
+kwyp0=0.0
+kwyn1=0.0
+;
+;without key words (reference)
+XY=SPL_INIT(X, yy)
+if (ARRAY_EQUAL(XY,0) EQ 0 ) then begin
+   MESSAGE, 'SPL_INIT error : SPL_INIT(X,Y) wrong result', /continue
+   EXIT, status=1
+endif
+
+;with key word YP0
+XYP=SPL_INIT(X, yy, YP0 = kwyp0)
+if (ARRAY_EQUAL(XYP,0) EQ 0 ) then begin
+   MESSAGE, 'SPL_INIT error : SPL_INIT(X,Y,YP0) wrong result', /continue
+   EXIT, status=1
+endif
+
+;with YPN_1
+XYPN=SPL_INIT(X, yy, YPN_1 = kwyn1)
+if (ARRAY_EQUAL(XYPN,0) EQ 0 ) then begin
+   MESSAGE, 'SPL_INIT error : SPL_INIT(X,Y,YPN_1) wrong result', /continue
+   EXIT, status=1
+endif
+
+;with key words YP0 and YPN_1
+result=SPL_INIT(X, yy, YP0 = kwyp0, YPN_1 = kwyn1)
+if (ARRAY_EQUAL(result,0) EQ 0 ) then begin
+   MESSAGE, 'SPL_INIT error : SPL_INIT(X,Y,YP0,YPN_1) wrong result', /continue
+   EXIT, status=1
+endif
+;
+; -------------------------------
+; When input X and Y do not have the same number of elements ... 
+;
+; n_element(X) lt n_element(Y)
+result=SPL_INIT(A,B) 
+if (ARRAY_EQUAL(result,0) EQ 0 ) then begin
+   MESSAGE, 'SPL_INIT error : n_element(X) lt n_element(Y)', /continue
+   EXIT, status=1
+endif
+;
+; n_element(X) gt n_element(Y)
+; result undefined
+result=SPL_INIT(Y,B)
+; if (ARRAY_EQUAL(result,0) EQ 0 ) then begin
+;MESSAGE, 'SPL_INIT error :  n_element(X) gt n_element(Y)', /continue
+;EXIT, status=1
+;endif
+;
+; -------------------------------
+; Cases with YP0 or YPN_1 equal infinity... 
+;
+;with key words YP0=infinity and YPN_1 != infinity
+result=SPL_INIT(X, yy, YP0 = !values.F_INFINITY, YPN_1 = kwyn1)
+;result=SPL_INIT(X,yy,YPN_1=0.0)=XYPN?
+;
+if (ARRAY_EQUAL(XYPN,result) EQ 0 ) then begin
+   MESSAGE, 'SPL_INIT error : YP0==inf and YPN_1 != inf', /continue
+   EXIT, status=1
+endif
+;
+;with key words YP0=infinity and YPN_1 != infinity
+result=SPL_INIT(X, yy, YP0 = kwyp0 , YPN_1 = !values.F_INFINITY)
+;result=SPL_INIT(X,yy,YP0=-1.1) =XYP?
+;
+if (ARRAY_EQUAL(XYP,result) EQ 0 ) then begin
+   MESSAGE, 'SPL_INIT error : YP0!=inf and YPN_1 == inf', /continue
+   EXIT, status=1
+endif
+;
+; with keywords YP0=YPN_1=INFINITY
+result=SPL_INIT(X, yy, YP0 = !values.f_infinity, YPN_1 = !values.f_infinity)
+;result=SPL_INIT(X,yy) =XY?
+;
+if (ARRAY_EQUAL(XY,result) EQ 0 ) then begin
+   MESSAGE, 'SPL_INIT error : YP0==YPN_1 == inf', /continue
+   EXIT, status=1
+endif
+;
+MESSAGE, 'No (real) problem found in TEST_SPL_INIT', /continue
+;
+if KEYWORD_SET(test) then STOP
+;
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_str_functions.pro cvs/gdl/testsuite/test_str_functions.pro
--- gdl-0.9rc4/testsuite/test_str_functions.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_str_functions.pro	2010-04-16 08:41:32.000000000 -0600
@@ -0,0 +1,80 @@
+;
+; Alain Coulais, 16 Avril 2010
+;
+; Few basic tests on functions working on Strings
+;
+pro TEST_STRMID, exit_on_error=exit_on_error, test=test
+;
+a='azerty'
+flag_pb=0
+;
+if NOT(STRCMP(a,STRMID(a,0))) then flag_pb=1
+if NOT(STRCMP(a,STRMID(a,0,100))) then flag_pb=flag_pb+1
+;
+res=STRMID(a,3)
+if NOT(STRCMP(res,'rty')) then flag_pb=flag_pb+1
+;
+if flag_pb GT 0 then begin
+    MESSAGE, /continue, STRING(flag_pb)+' ERROR(s) found in STRMID'
+    if KEYWORD_SET(exit_on_error) then  EXIT, status=1
+endif else begin
+    MESSAGE, /continue, 'No  ERROR found in STRMID'
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; ---------------
+;
+; return "0" when the arrays of substrings are different, else return "1"
+function STRCMP_MULTI, str1, str2, debug=debug
+;
+if N_ELEMENTS(str1) NE N_ELEMENTS(str2) then return, 0
+;
+for ii=0, N_ELEMENTS(str1)-1 do begin
+    if KEYWORD_SET(debug) then print, ii, str1[ii],str2[ii]
+    if NOT(STRCMP(str1[ii],str2[ii])) then return, 0
+endfor
+return, 1
+end
+;
+; -----------------------
+;
+pro TEST_STRSPLIT, exit_on_error=exit_on_error, test=test, debug=debug
+;
+str = 'rouge&&bleu&&jaune&&pair&impair'
+expected_res1=['rouge','bleu','jaune','pair','impair']
+expected_res2=['rouge','bleu','jaune','pair&impair']
+;
+flag_pb=0
+res1=STRSPLIT(str,'&&',/EXTRACT)
+if NOT(STRCMP_MULTI(res1,expected_res1,debug=debug)) then flag_pb=flag_pb+1
+;
+res2=STRSPLIT(str,'&&',/EXTRACT,/REGEX)
+if NOT(STRCMP_MULTI(res2,expected_res2,debug=debug)) then flag_pb=flag_pb+1
+;
+str2 = '<4>What<1>a<7>tangled<3>web<2>we<6>weave.'
+expected_res=['What','a','tangled','web','we','weave.']
+res = STRSPLIT(str2,'<[0-9]+>',/EXTRACT,/REGEX)
+if NOT(STRCMP_MULTI(res,expected_res,debug=debug)) then flag_pb=flag_pb+1
+;
+if flag_pb GT 0 then begin
+    MESSAGE, /continue, STRING(flag_pb)+' ERROR(s) found in STRSPLIT'
+    if KEYWORD_SET(exit_on_error) then  EXIT, status=1
+endif else begin
+    MESSAGE, /continue, 'No  ERROR found in STRSPLIT'
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; ---------------
+;
+pro TEST_STR_FUNCTIONS
+;
+TEST_STRMID, /exit_on_error
+TEST_STRSPLIT, /exit_on_error
+;
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_strsplit.pro cvs/gdl/testsuite/test_strsplit.pro
--- gdl-0.9rc4/testsuite/test_strsplit.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_strsplit.pro	2010-06-29 02:47:39.000000000 -0600
@@ -0,0 +1,168 @@
+;
+; some tests for STRPLIT
+;
+; Lea Noreskal, June 2010, under GNU GPL V2 or later
+;
+pro TEST_STRSPLIT
+
+str='$$$$$$$$$$' ; LONG 0
+str1='$chops &up str*ings.' ; [1]
+str2='ch$ops &up str*ings.' ; [0,3]
+str3='$ch$ops &up str*ings.' ; [1,4]
+str4='../foo.txt' ; [2,7]
+str5=' t e s t '
+
+;strsplit(str,'$',/ext)
+
+
+tab=strsplit(str,'$')
+if(tab ne 0) then begin
+   MESSAGE, 'error str', /continue
+   EXIT, status=1
+endif
+
+ext=strsplit(str,'$',/ext)
+;print , str , ' Fext> ' , strjoin(ext,'-') , N_ELEMENTS(ext)
+
+if(N_ELEMENTS(ext) ne 1) then begin
+   MESSAGE, 'error str extract', /continue
+   EXIT, status=1
+endif
+
+tab=strsplit(str,'$',/preserve)
+res=indgen(11)
+if(ARRAY_EQUAL(tab,res) eq 0) then begin
+   MESSAGE, 'error str preserve_null', /continue
+   EXIT, status=1
+endif
+
+ext=strsplit(str,'$',/ext,/preserve)
+;print , str , ' Fext> ' , strjoin(ext,'-') , N_ELEMENTS(ext)
+if(N_ELEMENTS(ext) ne 11) then begin
+   MESSAGE, 'error str extract', /continue
+   EXIT, status=1
+endif
+
+
+tab=strsplit(str1,'$')
+res=[1]
+if(ARRAY_EQUAL(tab,res) eq 0) then begin
+   MESSAGE, 'error str1', /continue
+   EXIT, status=1
+endif
+
+ext=strsplit(str1,'$',/ext)
+;print , str1 , ' Fext> ' , strjoin(ext,'-') , N_ELEMENTS(ext)
+
+res=['chops &up str*ings.']
+if( (N_ELEMENTS(ext) ne 1) AND (ARRAY_EQUAL(tab,res, /NO_TYPECONV) eq 0 )) then begin
+   MESSAGE, 'error str extract', /continue
+   EXIT, status=1
+endif
+
+ext=strsplit(str1,'$',/ext,/preserve)
+;print , str1 , ' Fext> ' , strjoin(ext,'-') , N_ELEMENTS(ext)
+if((N_ELEMENTS(ext) ne 2)) then begin
+   MESSAGE, 'error str1 extract preserves', /continue
+   EXIT, status=1
+endif
+
+
+
+tab=strsplit(str2,'$')
+res=[0,3]
+if(ARRAY_EQUAL(tab,res) eq 0) then begin
+   MESSAGE, 'error str2', /continue
+   EXIT, status=1
+endif
+
+ext=strsplit(str2,'$',/ext)
+;print , str2 , ' Fext> ' , strjoin(ext,'-') , N_ELEMENTS(ext)
+
+res=['ch' , 'ops &up str*ings.' ]
+if( (N_ELEMENTS(ext) ne 2) AND (ARRAY_EQUAL(tab,res, /NO_TYPECONV) eq 0 )) then begin
+   MESSAGE, 'error str extract', /continue
+   EXIT, status=1
+endif
+
+ext=strsplit(str2,'$',/ext,/preserve)
+;print , str2 , ' Fext> ' , strjoin(ext,'-') , N_ELEMENTS(ext)
+if((N_ELEMENTS(ext) ne 2)) then begin
+   MESSAGE, 'error str2 extract preserve', /continue
+   EXIT, status=1
+endif
+
+
+
+tab=strsplit(str2,'$',/preserve)
+res=[0,3]
+if(ARRAY_EQUAL(tab,res) eq 0) then begin
+   MESSAGE, 'error str2 preserve_null', /continue
+   EXIT, status=1
+endif
+
+tab=strsplit(str3,'$')
+res=[1,4]
+if(ARRAY_EQUAL(tab,res) eq 0) then begin
+   MESSAGE, 'error str3', /continue
+   EXIT, status=1
+endif
+
+ext=strsplit(str3,'$',/ext)
+;print , str3 , ' Fext> ' , strjoin(ext,'-') , N_ELEMENTS(ext)
+
+res=['ch' , 'ops &up str*ings.' ]
+if( (N_ELEMENTS(ext) ne 2) AND (ARRAY_EQUAL(tab,res, /NO_TYPECONV) eq 0 )) then begin
+   MESSAGE, 'error str extract', /continue
+   EXIT, status=1
+endif
+;
+
+ext=strsplit(str3,'$',/ext,/preserve)
+;print , str3 , ' Fext> ' , strjoin(ext,'-') , N_ELEMENTS(ext)
+if((N_ELEMENTS(ext) ne 3)) then begin
+   MESSAGE, 'error str3 extract preserve', /continue
+   EXIT, status=1
+endif
+
+;
+
+tab=strsplit(str4,'.')
+res=[2,7]
+if(ARRAY_EQUAL(tab,res) eq 0) then begin
+   MESSAGE, 'error str3', /continue
+   EXIT, status=1
+endif
+
+tab=strsplit(str4,'.',/preserve)
+res=[0,1,2,7]
+if(ARRAY_EQUAL(tab,res) eq 0) then begin
+   MESSAGE, 'error str4 preserve_null', /continue
+   EXIT, status=1
+endif
+
+ext=strsplit(str4,'.',/ext,/preserve)
+;print , str4 , ' Fext> ' , strjoin(ext,'-') , N_ELEMENTS(ext)
+if((N_ELEMENTS(ext) ne 4)) then begin
+   MESSAGE, 'error str4 extract , preserve', /continue
+   EXIT, status=1
+endif
+
+tab= STRSPLIT(str5,/preserve)
+res=[0,1,3,5,7,9]
+if(ARRAY_EQUAL(tab,res) eq 0) then begin
+   MESSAGE, 'error str5 preserve_null', /continue
+   EXIT, status=1
+endif
+
+ext= STRSPLIT(str5,/preserve,/extract)
+if((N_ELEMENTS(ext) ne 6)) then begin
+   MESSAGE, 'error str5 extract , preserve', /continue
+   EXIT, status=1
+endif
+
+print, 'All tests done'
+;
+end
+
+
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_suite.pro cvs/gdl/testsuite/test_suite.pro
--- gdl-0.9rc4/testsuite/test_suite.pro	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/testsuite/test_suite.pro	2010-05-21 10:24:01.372906136 -0600
@@ -2,24 +2,27 @@
 
 pro if_test
 
-if 1 then $
-  if 0 then begin & end $
-else if 1 then $ 
-  if 0 then begin & end $
-else a=1e
+  if 1 then $
+    if 0 then begin & end $
+  else if 1 then $ 
+    if 0 then begin & end $
+  else a=1e
+
+  if a ne 1e then begin
+    message, '***IF: ERROR', /conti
+    exit, status=1
+  endif
 
-if a ne 1e then print,'***IF: ERROR'
-
-print,'IF: OK'
+  print, 'IF: OK'
 end
 
 
 pro switch_test
 
-a='abc'
+  a='abc'
 
-;; empty
-switch a of
+  ;; empty
+  switch a of
 
     1:
     complex(1): begin & end
@@ -27,897 +30,1364 @@
     'abc':
     1.0: begin & end
     else:
-endswitch
+  endswitch
 
-switch a of
+  switch a of
 
-    1: print,'***SWITCH: ERROR'
-    complex(1): print,'***SWITCH: ERROR'
-    'def': print,'***SWITCH: ERROR'
+    1: begin
+      message, '***SWITCH: ERROR', /conti
+      exit, status=1
+    end
+    complex(1): begin
+      message, '***SWITCH: ERROR', /conti
+      exit, status=1
+    end
+    'def': begin
+      message, '***SWITCH: ERROR', /conti
+      exit, status=1
+    end
     'abc': begin
         abc = 1
     end
     1.0: fall = abc+1
     else: e=1
-endswitch
+  endswitch
 
-if abc ne 1 then print,'***SWITCH: ERROR'
-if fall ne abc+1 then print,'***SWITCH: ERROR'
-if e ne 1 then print,'***SWITCH: ERROR'
-
-switch 1 of
-   0: print,"***SWITCH: ERROR"
-   0: print,"***SWITCH: ERROR"
-   1:       
-endswitch
+  if abc ne 1 then begin
+    message, '***SWITCH: ERROR', /conti
+    exit, status=1
+  endif
+  if fall ne abc+1 then begin
+    message, '***SWITCH: ERROR', /conti
+    exit, status=1
+  endif
+  if e ne 1 then begin
+    message, '***SWITCH: ERROR', /conti
+    exit, status=1
+  endif
+
+  switch 1 of
+    0: begin
+      message, "***SWITCH: ERROR", /conti
+      exit, status=1
+    end
+    0: begin
+      message, "***SWITCH: ERROR", /conti
+      exit, status=1
+    end
+    1:       
+  endswitch
 
-print,'SWITCH: OK'
+  print,'SWITCH: OK'
 end
 
 pro case_test
 
-a='abc'
+  a='abc'
 
-case a of
+  case a of
 
-    1: print,'***CASE: ERROR'
-    complex(1): print,'***CASE: ERROR'
-    'def': print,'***CASE: ERROR'
+    1: begin
+      message, '***CASE: ERROR', /conti
+      exit, status=1
+    end
+    complex(1): begin
+      message, '***CASE: ERROR', /conti
+      exit, status=1
+    end
+    'def': begin
+      message, '***CASE: ERROR', /conti
+      exit, status=1
+    end
     'abc': begin
         c=1
     end
-    1.0: print,'***CASE: ERROR'
-    else: print,'***CASE: ERROR'
-endcase
-
-if c ne 1 then print,'***CASE: ERROR'
-
-case a of
+    1.0: begin
+      message, '***CASE: ERROR', /conti
+      exit, status=1
+    end
+    else: begin
+      message, '***CASE: ERROR', /conti
+      exit, status=1
+    end
+  endcase
 
-    1: print,'***CASE: ERROR'
-    complex(1): print,'***CASE: ERROR'
-    'def': print,'***CASE: ERROR'
+  if c ne 1 then begin
+    message, '***CASE: ERROR', /conti
+    exit, status=1
+  endif
+
+  case a of
+
+    1: begin
+      message, '***CASE: ERROR', /conti
+      exit, status=1
+    end
+    complex(1): begin
+      message, '***CASE: ERROR', /conti
+      exit, status=1
+    end
+    'def': begin
+      message, '***CASE: ERROR', /conti
+      exit, status=1
+    end
     'a': begin
-        print,'***CASE: ERROR'
+      message, '***CASE: ERROR', /conti
+      exit, status=1
+    end
+    1.0d: begin
+      message, '***CASE: ERROR', /conti
+      exit, status=1
     end
-    1.0d: print,'***CASE: ERROR'
     else: e=1
-end
+  end
 
-if e ne 1 then print,'***CASE: ERROR'
+  if e ne 1 then begin
+    message, '***CASE: ERROR', /conti
+    exit, status=1
+  endif
+
+  case 1 of
+    0: begin
+      message, "***CASE: ERROR", /conti
+      exit, status=1
+    end
+    0: begin
+      message, "***CASE: ERROR", /conti
+      exit, status=1
+    end
+    1:       
+  endcase
 
-case 1 of
-   0: print,"***CASE: ERROR"
-   0: print,"***CASE: ERROR"
-   1:       
-endcase
+  print, 'CASE: OK'
 
-print,'CASE: OK'
 end
 
 pro while_test
 
-i=0
-while i lt 100 do begin
-i=i+1
-endwhile
+  i=0
+  while i lt 100 do begin
+    i=i+1
+  endwhile
+
+  if i eq 100 then print,'WHILE: OK' else begin
+    message, '***WHILE: ERROR', /conti
+    exit, status=1
+  endelse
 
-if i eq 100 then print,'WHILE: OK' else print,'***WHILE: ERROR'
 end
 
 pro for_test
 
-c=0
-for i=0,99 do c=c+1 
-
-if c ne 100 then print,'***FOR: ERROR'
+  c=0
+  for i=0,99 do c=c+1 
 
-c=0
-for i=0,990,10 do c=c+1 
+  if c ne 100 then begin
+    message, '***FOR: ERROR', /conti
+    exit, status=1
+  endif
+
+  c=0
+  for i=0,990,10 do c=c+1 
+
+  if c ne 100 then begin
+    message, '***FOR: Step: ERROR', /conti
+    exit, status=1
+  endif
+
+  a=0
+  for i=0, 0 do begin
+    for j=0, 1 do begin
+      if i eq 0 then continue
+    endfor
+    a = 1
+  endfor
+  if a eq 0 then begin
+    message, '***FOR: CONTINUE: ERROR', /conti
+    exit, status=1
+  endif
 
-if c ne 100 then print,'***FOR: Step: ERROR'
+  print, 'FOR: OK'
 
-a=0
-for i=0, 0 do begin
-   for j=0, 1 do begin
-      if i eq 0 then continue
-   endfor
-   a = 1
-endfor
-if a eq 0 then print,'***FOR: CONTINUE: ERROR'
-print,'FOR: OK'
 end
 
 pro repeat_test
 
-i=0
-repeat begin 
-i=i+1
-endrep until (i eq 100)
-
-repeat begin 
-endrep until (i eq 100)
-
-repeat begin 
-endrep until 1
+  i=0
+  repeat begin 
+    i=i+1
+  endrep until (i eq 100)
+
+  repeat begin 
+  endrep until (i eq 100)
+
+  repeat begin 
+  endrep until 1
+
+  if i eq 100 then print,'REPEAT: OK' else begin
+    message, '***REPEAT: ERROR', /conti
+    exit, status=1
+  endelse
 
-if i eq 100 then print,'REPEAT: OK' else print,'***REPEAT: ERROR'
 end
 
 pro goto_test
 
-;; simple
-goto,jump11
-print,'***GOTO: Error'
-jump21:
-goto,jump31
-print,'***GOTO: Error'
-jump11:
-goto,jump21
-print,'***GOTO: Error'
-jump31:
-
-
-count=0
-;; within loop
-for i=0,10 do begin
-
-goto,jump1
-print,'***GOTO: Error1'
-jump2:
-goto,jump3
-print,'***GOTO: Error2'
-jump1:
-goto,jump2
-print,'***GOTO: Error3'
-jump3:
-goto,jump4 ; even to jump out of the block and in again is ok
-jump5:
+  ;; simple
+  goto,jump11
+  message, '***GOTO: Error', /conti
+  exit, status=1
+  jump21:
+  goto,jump31
+  message, '***GOTO: Error', /conti
+  exit, status=1
+  jump11:
+  goto,jump21
+  message, '***GOTO: Error', /conti
+  exit, status=1
+  jump31:
+
+
+  count=0
+  ;; within loop
+  for i=0,10 do begin
+
+  goto,jump1
+  message, '***GOTO: Error1', /conti
+  exit, status=1
+  jump2:
+  goto,jump3
+  message, '***GOTO: Error2', /conti
+  exit, status=1
+  jump1:
+  goto,jump2
+  message, '***GOTO: Error3', /conti
+  exit, status=1
+  jump3:
+  goto,jump4 ; even to jump out of the block and in again is ok
+  jump5:
+
+  if 0 then goto,jump5 else goto,jump7
+  message, '***GOTO: Error4', /conti
+  exit, status=1
 
-if 0 then goto,jump5 else goto,jump7
-print,'***GOTO: Error4'
+  jump7:
 
-jump7:
-
-if 1 then begin
+  if 1 then begin
 
     goto,jump8
-    print,'***GOTO: Error5'
-jump8:
-
-endif else begin
-
-    print,'***GOTO: Error6'
-endelse
+    message, '***GOTO: Error5', /conti
+    exit, status=1
+    jump8:
+
+  endif else begin
+
+    message, '***GOTO: Error6', /conti
+    exit, status=1
+  endelse
+
+
+  count=count+1
+  endfor
+
+  goto,jump6
+  jump4:
+  goto,jump5
+  jump6:
+  
+  if count ne 11 then begin
+    message, '***GOTO: ERROR7', /conti
+    exit, status=1
+  endif
 
-
-count=count+1
-endfor
-
-goto,jump6
-jump4:
-goto,jump5
-jump6:
-
-if count ne 11 then print,'***GOTO: ERROR7'
-
-IF (1)then begin
+  IF (1)then begin
    
-   IF (1)then begin
+    IF (1)then begin
       ;print,"Going to Label1"
       goto, Label1
-   end else begin
-      print,'***GOTO: ERROR8'
-   end
+    end else begin
+      message, '***GOTO: ERROR8', /conti
+      exit, status=1
+    end
       
-   Label1:
-end
+    Label1:
+  end
 
-
-print,'GOTO: OK'
+  print,'GOTO: OK'
 
 end
 
 function ret99
-return,99b
+  return,99b
 end
 
 function ret,a
-return,a
+  return,a
 end
 
 function retEq,a
-return,(a=3)
+  return,(a=3)
 end
 
 function retTag,a
-return,(a.t=3)
+  return,(a.t=3)
 end
 
 function ret2,b
-return,ret(b)
+  return,ret(b)
 end
 
 function ret3,b
-return,ret2(b)
+  return,ret2(b)
 end
 
 function retOverwriteLocal
-a=[['m','a'],['r','c']]
-return,reform(a,4,/OVERWRITE)
+  a=[['m','a'],['r','c']]
+  return,reform(a,4,/OVERWRITE)
 end
 function retOverwriteGlobal,a
-return,reform(a,4,/OVERWRITE)
+  return,reform(a,4,/OVERWRITE)
 end
 function retOverwriteExpression
-a=[['m','a'],['r','c']]
-return,reform(a[*],4,/OVERWRITE)
+  a=[['m','a'],['r','c']]
+  return,reform(a[*],4,/OVERWRITE)
 end
 
 pro ret_test
 
-if ret99() ne 99.0 then print,'***RET: ERROR1'
-if retEq(u) ne 3 then print,'***RET: ERROR2'
-(retEq(u2)) = 4
-if u2 ne 4 then print,'***RET: ERROR4'
-
-
-(ret3(u3))=7
-if u3 ne 7 then print,'***RET: ERROR5'
-
-s={t:0}
-if retTag(s) ne 3 then print,'***RET: ERROR6'
-;(ret(s))=2
-
-n = retOverwriteLocal()
-if n[2] ne "r" then print,'***RET: ERROR7'
-
-a=[[1,2],[3,4]]
-(retOverwriteGlobal(a))--
-if a[1] ne 1 then print,'***RET: ERROR8'
+  if ret99() ne 99.0 then begin
+    message, '***RET: ERROR1', /conti
+    exit, status=1
+  endif
+  if retEq(u) ne 3 then begin
+    message, '***RET: ERROR2', /conti
+    exit, status=1
+  endif
+  (retEq(u2)) = 4
+  if u2 ne 4 then begin
+    message, '***RET: ERROR4', /conti
+    exit, status=1
+  endif
+
+
+  (ret3(u3))=7
+  if u3 ne 7 then begin
+    message, '***RET: ERROR5', /conti
+    exit, status=1
+  endif
+
+  s={t:0}
+  if retTag(s) ne 3 then begin
+    message, '***RET: ERROR6', /conti
+    exit, status=1
+  endif
+  ;(ret(s))=2
+
+  n = retOverwriteLocal()
+  if n[2] ne "r" then begin
+    message, '***RET: ERROR7', /conti
+    exit, status=1
+  endif
+
+  a=[[1,2],[3,4]]
+  (retOverwriteGlobal(a))--
+  if a[1] ne 1 then begin
+    message, '***RET: ERROR8', /conti
+    exit, status=1
+  endif
+
+  n = retOverwriteExpression()
+  if n[2] ne "r" then begin
+    message, '***RET: ERROR9', /conti
+    exit, status=1
+  endif
+
+  a=1
+  c=ret(4*(3+reform(a,1,/OVERWRITE)+1)*2)
+  if a ne 1 then begin
+    message, '***RET: ERROR10', /conti
+    exit, status=1
+  endif
+  if c ne 40 then begin
+    message, '***RET: ERROR11', /conti
+    exit, status=1
+  endif
+
+  common ret_common,aa
+
+  aa=1
+  c=ret(4*(3+reform(aa,1,/OVERWRITE)+1)*2)
+  if aa ne 1 then begin
+    message, '***RET: ERROR12', /conti
+    exit, status=1
+  endif
+  if c ne 40 then begin
+    message, '***RET: ERROR13', /conti
+    exit, status=1
+  endif
 
-n = retOverwriteExpression()
-if n[2] ne "r" then print,'***RET: ERROR9'
+  print,'RET: OK';
 
-a=1
-c=ret(4*(3+reform(a,1,/OVERWRITE)+1)*2)
-if a ne 1 then print,'***RET: ERROR10'
-if c ne 40 then print,'***RET: ERROR11'
-
-common ret_common,aa
-
-aa=1
-c=ret(4*(3+reform(aa,1,/OVERWRITE)+1)*2)
-if aa ne 1 then print,'***RET: ERROR12'
-if c ne 40 then print,'***RET: ERROR13'
-
-print,'RET: OK';
 end
 
 
 pro struct_test
 
-s={s:"a string",tag: indgen(5),c:complex(1,2)}
-
-if s.tag[ 3] ne 3 then print,'***STRUCT: ERROR1'
-
-s={s1,tag: indgen(5),s:s}
+  s={s:"a string",tag: indgen(5),c:complex(1,2)}
 
-if s.tag[ 3] ne 3 then print,'***STRUCT: ERROR1b'
+  if s.tag[ 3] ne 3 then begin
+    message, '***STRUCT: ERROR1', /conti
+    exit, status=1
+  endif
+
+  s={s1,tag: indgen(5),s:s}
+
+  if s.tag[ 3] ne 3 then begin
+    message, '***STRUCT: ERROR1b', /conti
+    exit, status=1
+  endif
+
+  s.tag++
+
+  if s.tag[ 3] ne 4 then begin
+    message, '***STRUCT: ERROR2', /conti
+    exit, status=1
+  endif
+
+  s.tag = 9
+
+  if s.tag[ 3] ne 9 then begin
+    message, '***STRUCT: ERROR3', /conti
+    exit, status=1
+  endif
+
+  s.tag = [10,11,12]
+
+  if s.tag[ 2] ne 12 then begin
+    message, '***STRUCT: ERROR4', /conti
+    exit, status=1
+  endif
+
+  ss=[s,s]
+
+  ss[*].tag=indgen(5,2)
+
+  if ss[1].tag[2] ne 7 then begin
+    message, '***STRUCT: ERROR5', /conti
+    exit, status=1
+  endif
+
+  s={s:indgen(5),$
+    t:"string",$
+    u:complexarr(3,5),$
+    v:dcomplexarr(99,2),$
+    x:sindgen(100)$
+  }
+  ss={ss:s,s2:s}
+  sss={sss:ss,ss:[s,s]}
+
+  sa = s
+  for i=0,2 do begin
+    sa={s1:sa,s2:[sa,sa]}
+  endfor
+  sa = {named,t:s}
+  for i=0,3 do begin
+    sa={s1:sa,s2:[sa,sa]}
+  endfor
+  sa=0
+
+  ;p=ptr_new( sss)
+  ;((*p).sss.ss)[2] = 5
+  ;print,((*p).ss)[2]
+
+  sss.sss.ss.s[2] = 10
+  if sss.sss.ss.s[2] ne 10 then begin
+    message, '***STRUCT: ERROR6', /conti
+    exit, status=1
+  endif
+
+  (ret(sss)).sss.ss.s[1] = 11
+  if sss.sss.ss.s[1] ne 11 then begin
+    message, '***STRUCT: ERROR7', /conti
+    exit, status=1
+  endif
+  if (ret(sss)).sss.ss.s[3] ne 3 then begin
+    message, '***STRUCT: ERROR8', /conti
+    exit, status=1
+  endif
+
+  (ret(sss)).sss.(0).s[1] = 11
+  if sss.(0).ss.s[1] ne 11 then begin
+    message, '***STRUCT: ERROR9', /conti
+    exit, status=1
+  endif
+
+  if ({a:3}).a ne 3 then begin
+    print, '***STRUCT: ERROR10', /conti
+    exit, status=1
+  endif
+
+  ;; array and struct
+  s4=[sss,sss]
+  s5=[[s4],[s4]]
+  if s5[1,1].sss.ss.s[3] ne 3 then begin
+    print, '***STRUCT: ERROR11', /conti
+    exit, status=1
+  endif
 
-s.tag++
+  a = {a0, var1: 0, var2: 0.0d0}
+  b = {a0, '0L', ' 1.0'}
 
-if s.tag[ 3] ne 4 then print,'***STRUCT: ERROR2'
+  print,'STRUCT: OK'
 
-s.tag = 9
-
-if s.tag[ 3] ne 9 then print,'***STRUCT: ERROR3'
-
-s.tag = [10,11,12]
-
-if s.tag[ 2] ne 12 then print,'***STRUCT: ERROR4'
-
-ss=[s,s]
-
-ss[*].tag=indgen(5,2)
-
-if ss[1].tag[2] ne 7 then print,'***STRUCT: ERROR5'
-
-s={s:indgen(5),$
-t:"string",$
-u:complexarr(3,5),$
-v:dcomplexarr(99,2),$
-x:sindgen(100)$
-}
-ss={ss:s,s2:s}
-sss={sss:ss,ss:[s,s]}
-
-sa = s
-for i=0,2 do begin
-sa={s1:sa,s2:[sa,sa]}
-endfor
-sa = {named,t:s}
-for i=0,3 do begin
-sa={s1:sa,s2:[sa,sa]}
-endfor
-sa=0
-
-;p=ptr_new( sss)
-;((*p).sss.ss)[2] = 5
-;print,((*p).ss)[2]
-
-sss.sss.ss.s[2] = 10
-if sss.sss.ss.s[2] ne 10 then print,'***STRUCT: ERROR6'
-
-(ret(sss)).sss.ss.s[1] = 11
-if sss.sss.ss.s[1] ne 11 then print,'***STRUCT: ERROR7'
-if (ret(sss)).sss.ss.s[3] ne 3 then print,'***STRUCT: ERROR8'
-
-(ret(sss)).sss.(0).s[1] = 11
-if sss.(0).ss.s[1] ne 11 then print,'***STRUCT: ERROR9'
-
-if ({a:3}).a ne 3 then  print,'***STRUCT: ERROR10'
-
-;; array and struct
-s4=[sss,sss]
-s5=[[s4],[s4]]
-if s5[1,1].sss.ss.s[3] ne 3 then print,'***STRUCT: ERROR11'
-
-a = {a0, var1: 0, var2: 0.0d0}
-b = {a0, '0L', ' 1.0'}
-
-print,'STRUCT: OK'
 end
 
 pro multi,a,b,c
-b=9
-if a ne 9 then print,'***MULTI: ERROR1'
-if c ne 9 then print,'***MULTI: ERROR2'
+  b=9
+  if a ne 9 then begin
+    message, '***MULTI: ERROR1', /conti
+    exit, status=1
+  endif
+  if c ne 9 then begin
+    message, '***MULTI: ERROR2', /conti
+    exit, status=1
+  endif
 end
 
 pro multi_test
-multi,a,a,a
-if a ne 9 then print,'***MULTI: ERROR3'
-print,'MULTI: OK'
+  multi,a,a,a
+  if a ne 9 then begin
+    message, '***MULTI: ERROR3', /conti
+    exit, status=1
+  endif
+  print,'MULTI: OK'
 end
 
 function o::init
-self.a=9
-return,1
+  self.a=9
+  return,1
 end
 
 function o::get
-return,self.a
+  return,self.a
 end
 
 pro o::test
-self.a=1
-if self.a ne 1 then print,'***OBJECT: ERROR1'
-self[0].a=2
-if self[0].a ne 2 then print,'***OBJECT: ERROR2'
-(self).a[0]=3
-if (self[0]).a[[-2]] ne 3 then print,'***OBJECT: ERROR3'
-if self[[0]].a ne 3 then print,'***OBJECT: ERROR4'
-;; would be legal in GDL (but IDL complains)
-;if (self[[0]]).a ne 3 then print,'***OBJECT: ERROR5'
+  self.a=1
+  if self.a ne 1 then begin
+    message, '***OBJECT: ERROR1', /conti
+    exit, status=1
+  endif
+  self[0].a=2
+  if self[0].a ne 2 then begin
+    message, '***OBJECT: ERROR2', /conti
+    exit, status=1
+  endif
+  (self).a[0]=3
+  if (self[0]).a[[-2]] ne 3 then begin
+    message, '***OBJECT: ERROR3', /conti
+    exit, status=1
+  endif
+  if self[[0]].a ne 3 then begin
+    message, '***OBJECT: ERROR4', /conti
+    exit, status=1
+  endif
+  ;; would be legal in GDL (but IDL complains)
+  ;if (self[[0]]).a ne 3 then begin
+  ;  message, '***OBJECT: ERROR5', /conti
+  ;  exit, status=1
+  ;endif
 end
 
 pro o::cleanup
-common object_test,o_cleanup
-o_cleanup=-1
+  common object_test,o_cleanup
+  o_cleanup=-1
 end
 
 pro object_test
 
-common object_test
-
-;; object
-s={o,a:0}
-obj=obj_new('o')
-
-if obj->get() ne 9 then print,'***OBJECT: ERROR6'
+  common object_test
 
-obj->test
-(obj)->test
-obj[0]->test
-(obj[0])->test
+  ;; object
+  s={o,a:0}
+  obj=obj_new('o')
+
+  if obj->get() ne 9 then begin
+    message, '***OBJECT: ERROR6', /conti
+    exit, status=1
+  endif
+
+  obj->test
+  (obj)->test
+  obj[0]->test
+  (obj[0])->test
+
+  if not obj_valid( obj) then begin
+    message, '***OBJECT: ERROR7', /conti
+    exit, status=1
+  endif
+
+  obj_destroy,obj
+
+  if obj_valid( obj) then begin
+    message, '***OBJECT: ERROR8', /conti
+    exit, status=1
+  endif
+  if o_cleanup ne -1 then begin
+    message, '***OBJECT: ERROR9', /conti
+    exit, status=1
+  endif
 
-if not obj_valid( obj) then print,'***OBJECT: ERROR7'
-
-obj_destroy,obj
-
-if obj_valid( obj) then print,'***OBJECT: ERROR8'
-if o_cleanup ne -1 then print,'***OBJECT: ERROR9'
-
-print,'OBJECT: OK'
+  print,'OBJECT: OK'
 end
 
 pro ct1
-common tc,x,y,z
-if x ne 3 then print,'***COMMON: ERROR1'
-y=7
+  common tc,x,y,z
+  if x ne 3 then begin
+    message, '***COMMON: ERROR1', /conti
+    exit, status=1
+  endif
+  y=7
 end
 
 pro ct2
-common tc
-if x ne 3 then print,'***COMMON: ERROR2'
-if y ne 7 then print,'***COMMON: ERROR3'
-z=9
+  common tc
+  if x ne 3 then begin
+    message, '***COMMON: ERROR2', /conti
+    exit, status=1
+  endif
+  if y ne 7 then begin
+    message, '***COMMON: ERROR3', /conti
+    exit, status=1
+  endif
+  z=9
 end
 
 function ct3
-common tc3,a
-return,a
+  common tc3,a
+  return,a
 end
 
 pro common_test
-common tc,a,b,c
-common tc,d,e,f
-common tc
-
-a=3
-ct1
-ct2
-
-if a ne 3 then print,'***COMMON: ERROR4'
-if b ne 7 then print,'***COMMON: ERROR5'
-if c ne 9 then print,'***COMMON: ERROR6'
-if d ne 3 then print,'***COMMON: ERROR7'
-if e ne 7 then print,'***COMMON: ERROR8'
-if f ne 9 then print,'***COMMON: ERROR9'
-if x ne 3 then print,'***COMMON: ERROR10'
-if y ne 7 then print,'***COMMON: ERROR11'
-if z ne 9 then print,'***COMMON: ERROR12'
+  common tc,a,b,c
+  common tc,d,e,f
+  common tc
+
+  a=3
+  ct1
+  ct2
+
+  if a ne 3 then begin
+    message, '***COMMON: ERROR4', /conti
+    exit, status=1
+  endif
+  if b ne 7 then begin
+    message, '***COMMON: ERROR5', /conti
+    exit, status=1
+  endif
+  if c ne 9 then begin
+    message, '***COMMON: ERROR6', /conti
+    exit, status=1
+  endif
+  if d ne 3 then begin
+    message, '***COMMON: ERROR7', /conti
+    exit, status=1
+  endif
+  if e ne 7 then begin
+    message, '***COMMON: ERROR8', /conti
+    exit, status=1
+  endif
+  if f ne 9 then begin
+    message, '***COMMON: ERROR9', /conti
+    exit, status=1
+  endif
+  if x ne 3 then begin
+    message, '***COMMON: ERROR10', /conti
+    exit, status=1
+  endif
+  if y ne 7 then begin
+    message, '***COMMON: ERROR11', /conti
+    exit, status=1
+  endif
+  if z ne 9 then begin
+    message, '***COMMON: ERROR12', /conti
+    exit, status=1
+  endif
+
+  (ct3()) = 2
+  if ct3() ne 2 then begin
+    message, '***COMMON: ERROR13', /conti
+    exit, status=1
+  endif
 
-(ct3()) = 2
-if ct3() ne 2 then print,'***COMMON: ERROR13'
+  print,'COMMON: OK'
 
-print,'COMMON: OK'
 end
 
 pro set22,a,X=x
-a=2
-x=2
+  a=2
+  x=2
 end
 
 pro ref_test,MEMCHECK=mCheck
 
-set22,b
-if b ne 2 then print,"***REF: ERROR1"
+  set22,b
+  if b ne 2 then begin
+    message, "***REF: ERROR1", /conti
+    exit, status=1
+  endif
 
-if not keyword_set( mCheck) then begin
+  if not keyword_set( mCheck) then begin
 
     p=ptr_new(/alloc)
     set22,*p
-    if *p ne 2 then print,"***REF: ERROR2"
+    if *p ne 2 then begin
+      message, "***REF: ERROR2", /conti
+      exit, status=1
+    endif
     ptr_free,p
 
     p=ptr_new(/alloc)
     pp=ptr_new(p)
     set22,**pp
-    if **pp ne 2 then print,"***REF: ERROR3"
+    if **pp ne 2 then begin
+      message, "***REF: ERROR3", /conti
+      exit, status=1
+    endif
     ptr_free,p,pp
 
-endif
-
-a=indgen(3)
-set22,reform(a,1,3,/OVERWRITE)
-if a ne 2 then print,"***REF: ERROR4"
-
-a=4 & x=4
-set22,a++,X=x++
-if a ne 5 or x ne 5 then print,"***REF: ERROR5"
+  endif
 
-a=1 & x=1
-set22,++a,X=++x
-if a ne 2 or x ne 2 then print,"***REF: ERROR6"
+  a=indgen(3)
+  set22,reform(a,1,3,/OVERWRITE)
+  if a ne 2 then begin
+    message, "***REF: ERROR4", /conti
+    exit, statis=1
+  endif
+
+  a=4 & x=4
+  set22,a++,X=x++
+  if a ne 5 or x ne 5 then begin
+    message, "***REF: ERROR5", /conti
+    exit, status=1
+  endif
+
+  a=1 & x=1
+  set22,++a,X=++x
+  if a ne 2 or x ne 2 then begin
+    message, "***REF: ERROR6", /conti
+    exit, status=1
+  endif
+
+  a=1 & x=1
+  set22,(a=4),X=(x=4)
+  if a ne 2 or x ne 2 then begin
+    message, "***REF: ERROR7", /conti
+    exit, status=1
+  endif
+
+  a=4 & x=4
+  set22,++(a=1),X=++(x=1)
+  if a ne 2 or x ne 2 then begin
+    message, "***REF: ERROR8", /conti
+    exit, status=1
+  endif
+
+  set22,++(a[0]=4),X=++(x[0]=4)
+  if a ne 5 or x ne 5 then begin
+    message, "***REF: ERROR9", /conti
+    exit, status=1
+  endif
 
-a=1 & x=1
-set22,(a=4),X=(x=4)
-if a ne 2 or x ne 2 then print,"***REF: ERROR7"
+  print,'REF: OK'
 
-a=4 & x=4
-set22,++(a=1),X=++(x=1)
-if a ne 2 or x ne 2 then print,"***REF: ERROR8"
-
-set22,++(a[0]=4),X=++(x[0]=4)
-if a ne 5 or x ne 5 then print,"***REF: ERROR9"
-
-print,'REF: OK'
 end
 
 function base::init
-common inheritance,baseInit,baseCleanup,derivInit,derivCleanup
-baseInit=1
-return,1
+  common inheritance,baseInit,baseCleanup,derivInit,derivCleanup
+  baseInit=1
+  return,1
 end
 pro base::cleanup
-common inheritance,baseInit,baseCleanup,derivInit,derivCleanup
-baseCleanup=1
+  common inheritance,baseInit,baseCleanup,derivInit,derivCleanup
+  baseCleanup=1
 end
 pro base::set
-self.b='base'
+  self.b='base'
 end
 pro base::setbase
-self.b='base'
+  self.b='base'
 end
 function base::get
-return,self.b
+  return,self.b
 end
 
 function deriv::init
-common inheritance,baseInit,baseCleanup,derivInit,derivCleanup
-r=self->base::init()
-derivInit=1
-return,1
+  common inheritance,baseInit,baseCleanup,derivInit,derivCleanup
+  r=self->base::init()
+  derivInit=1
+  return,1
 end
 pro deriv::cleanup
-common inheritance,baseInit,baseCleanup,derivInit,derivCleanup
-self->base::cleanup
-derivCleanup=1
+  common inheritance,baseInit,baseCleanup,derivInit,derivCleanup
+  self->base::cleanup
+  derivCleanup=1
 end
 pro deriv::set
-self.b='deriv'
+  self.b='deriv'
 end
 
 pro inheritance_test
 
-base={ base, b: ''}
-deriv={ deriv, INHERITS base, d: ''}
+  base={ base, b: ''}
+  deriv={ deriv, INHERITS base, d: ''}
 
-common inheritance
+  common inheritance
 
-o=obj_new( 'deriv')
-if baseInit ne 1 then print,'***INHERITANCE: ERROR1'
-if derivInit ne 1 then print,'***INHERITANCE: ERROR2'
-
-o->setbase
-if o->get() ne 'base' then print,'***INHERITANCE: ERROR3'
-o->set
-if o->get() ne 'deriv' then print,'***INHERITANCE: ERROR4'
-o->base::set
-if o->get() ne 'base' then print,'***INHERITANCE: ERROR5'
-
-obj_destroy, o
-if baseInit ne 1 then print,'***INHERITANCE: ERROR6'
-if derivInit ne 1 then print,'***INHERITANCE: ERROR7'
+  o=obj_new( 'deriv')
+  if baseInit ne 1 then begin
+    message, '***INHERITANCE: ERROR1', /conti
+    exit, status=1
+  endif
+  if derivInit ne 1 then begin
+    message, '***INHERITANCE: ERROR2', /conti
+    exit, status=1
+  endif
+
+  o->setbase
+  if o->get() ne 'base' then begin
+    message, '***INHERITANCE: ERROR3', /conti
+    exit, status=1
+  endif
+  o->set
+  if o->get() ne 'deriv' then begin
+    message, '***INHERITANCE: ERROR4', /conti
+    exit, status=1
+  endif
+  o->base::set
+  if o->get() ne 'base' then begin
+    message, '***INHERITANCE: ERROR5', /conti
+    exit, status=1
+  endif
+
+  obj_destroy, o
+  if baseInit ne 1 then begin
+    message, '***INHERITANCE: ERROR6', /conti
+    exit, status=1
+  endif
+  if derivInit ne 1 then begin
+    message, '***INHERITANCE: ERROR7', /conti
+    exit, status=1
+  endif
 
-print,'INHERITANCE: OK'
+  print,'INHERITANCE: OK'
 end
 
 function syntax_test,a,b,c
-return,byte(a,b,c)
+  return,byte(a,b,c)
 end
 
 pro syntax_test
 
-s={a:0}
-
-t=s[0].a
-t=s[[0]].a
-t=(s[0]).a
-t=(s[[0]]).a
+  s={a:0}
 
-b=(a=2)
-if b ne 2 then print,'***SYNTAX_TEST: ERROR1'
+  t=s[0].a
+  t=s[[0]].a
+  t=(s[0]).a
+  t=(s[[0]]).a
+
+  b=(a=2)
+  if b ne 2 then begin
+    message, '***SYNTAX_TEST: ERROR1', /conti
+    exit, status=1
+  endif
 
-a=(byte(1,0,1))[0]
-a=(syntax_test(1,0,1))[0]
+  a=(byte(1,0,1))[0]
+  a=(syntax_test(1,0,1))[0]
 
-;((a=4)) syntax error
-;(a=2)=3  forbidden in GDL (as it hardly makes sense)
+  ;((a=4)) syntax error
+  ;(a=2)=3  forbidden in GDL (as it hardly makes sense)
 
 end
 
 pro inc_test
 
-a=1
-
-(ret(a))++
-++(ret(a))
-
-if a ne 3 then print,"***INC: ERROR1"
-
-b = intarr(3)
+  a=1
 
-b[1]++
-++b[1]
-(b[1])++
-++(b[1])
+  (ret(a))++
+  ++(ret(a))
 
-if b[1] ne 4 then print,"***INC: ERROR2"
+  if a ne 3 then begin
+    message, "***INC: ERROR1", /conti
+    exit, status=1
+  endif
+
+  b = intarr(3)
+
+  b[1]++
+  ++b[1]
+  (b[1])++
+  ++(b[1])
+
+  if b[1] ne 4 then begin
+    message, "***INC: ERROR2", /conti
+    exit, status=1
+  endif
+
+  b[[1,2]]+=1
+  if b[1] ne 5 then begin
+    message, "***INC: ERROR3", /conti
+    exit, status=1
+  endif
+
+  (a=2)++
+  if a ne 3 then begin
+    message, '***INC_TEST: ERROR4', /conti
+    exit, status=1
+  endif
+
+  ((a=2))++
+  if a ne 3 then begin
+    message, '***INC_TEST: ERROR5', /conti
+    exit, status=1
+  endif
+
+  ++(a=2)
+  if a ne 3 then begin
+    message, '***INC_TEST: ERROR6', /conti
+    exit, status=1
+  endif
+
+  ++((a=2))
+  if a ne 3 then begin
+    message, '***INC_TEST: ERROR7', /conti
+    exit, status=1
+  endif
 
-b[[1,2]]+=1
-if b[1] ne 5 then print,"***INC: ERROR3"
+  print,'INC: OK'
 
-(a=2)++
-if a ne 3 then print,'***INC_TEST: ERROR4'
-
-((a=2))++
-if a ne 3 then print,'***INC_TEST: ERROR5'
-
-++(a=2)
-if a ne 3 then print,'***INC_TEST: ERROR6'
-
-++((a=2))
-if a ne 3 then print,'***INC_TEST: ERROR7'
-
-print,'INC: OK'
 end
 
 
-
 pro continuebreak_test
 
-repeat begin
+  repeat begin
 
     goto,start
 
-    print,'***CONTINUE/BREAK: ERROR2'
+    message, '***CONTINUE/BREAK: ERROR2', /conti
+    exit, status=1
 
-start:
+    start:
 
     for i=0,40,2 do begin
 
-        if i lt 6 then continue
-
-        if i lt 6 then print,'***CONTINUE/BREAK: ERROR1'
+      if i lt 6 then continue
 
-        if i gt 10 then break
-
-        if i gt 10 then print,'***CONTINUE/BREAK: ERROR2'
-
-        goto,in1
-        print,'***CONTINUE/BREAK: ERROR2'
-        goto,out1
-in1:
+      if i lt 6 then begin
+        message, '***CONTINUE/BREAK: ERROR1', /conti
+        exit, status=1
+      endif
+
+      if i gt 10 then break
+
+      if i gt 10 then begin
+        message, '***CONTINUE/BREAK: ERROR2', /conti
+        exit, status=1
+      endif
+
+      goto,in1
+      message, '***CONTINUE/BREAK: ERROR2', /conti
+      exit, status=1
+      goto,out1
+      in1:
 
     endfor
 
-goto,out2
-out1:
-out2:
+    goto,out2
+    out1:
+    out2:
+
+  endrep until 1
 
-endrep until 1
+  print,'CONTINUE/BREAK: OK'
 
-print,'CONTINUE/BREAK: OK'
 end
 
 
 pro e2,A=a,B=b
-if a ne 'a' then print,'EXTRA: ERROR1'
-if b ne 'b' then print,'EXTRA: ERROR2'
+  if a ne 'a' then begin
+    message, 'EXTRA: ERROR1', /conti
+    exit, status=1
+  endif
+  if b ne 'b' then begin
+    message, 'EXTRA: ERROR2', /conti
+    exit, status=1
+  endif
 end
 
 pro eref,_REF_EXTRA=ex
-e2,_EXTRA=ex
+  e2,_EXTRA=ex
 end
 
 pro eval,_EXTRA=ex
-e2,_EXTRA=ex
+  e2,_EXTRA=ex
 end
 
 pro e1,R2=a,R1=b
-a=1
-b=2
+  a=1
+  b=2
 end
 
 pro eret,_REF_EXTRA=ex
-e1,_EXTRA=ex
+  e1,_EXTRA=ex
 end
 
 
 pro extra_test,_REF_EXTRA=ex
 
-eval,b='b',a='a',c=u ;;
-eref,b='b',a='a',c=u
+  eval,b='b',a='a',c=u ;;
+  eref,b='b',a='a',c=u
 
-eret,r1=r1,r2=r2
+  eret,r1=r1,r2=r2
 
-if r1 ne 2 then print,'***EXTRA: ERROR3'
-if r2 ne 1 then print,'***EXTRA: ERROR4'
+  if r1 ne 2 then begin
+    message, '***EXTRA: ERROR3', /conti
+    exit, status=1
+  endif
+  if r2 ne 1 then begin
+    message, '***EXTRA: ERROR4', /conti
+    exit, status=1
+  endif
+
+  print,'EXTRA: OK'
 
-print,'EXTRA: OK'
 end
 
 pro expr_test
 
-a=0
-a++
-a *= 2
-a ^= 2
-b = a+2*3-(9*2)+9
-if b ne 1 then print,'***EXPR: ERROR1'
-
-a=indgen(6,6,6)
-a[3,3,3]=-1
-if a[3,3,3] ne -1 then print,'***EXPR: ERROR2'
-
-a=a+100
-if a[3,3,3] ne 99 then print,'***EXPR: ERROR2a'
-
-a[*]=a[*]-100
-if a[3,3,3] ne -1 then print,'***EXPR: ERROR2b'
-
-
-sdef={s,a:intarr(3),s:strarr(3)}
-s1={s,indgen(3),s:sindgen(3)}
-if s1.a[1] ne 1 then print,'***EXPR: ERROR3'
-s2={s}
-sArr=[s2,s2]
-sArr[1].s[1]='test'
-if sArr[1].s[1] ne 'test' then print,'***EXPR: ERROR4'
-
-a=1
-c=4*(3+reform(a,1,/OVERWRITE)+1)*2
-if c ne 40 then print,'***EXPR: ERROR5'
-if a ne 1 then print,'***EXPR: ERROR6'
+  a=0
+  a++
+  a *= 2
+  a ^= 2
+  b = a+2*3-(9*2)+9
+  if b ne 1 then begin
+    message, '***EXPR: ERROR1', /conti
+    exit, status=1
+  endif
+
+  a=indgen(6,6,6)
+  a[3,3,3]=-1
+  if a[3,3,3] ne -1 then begin
+    message, '***EXPR: ERROR2', /conti
+    exit, status=1
+  endif
+
+  a=a+100
+  if a[3,3,3] ne 99 then begin
+    message, '***EXPR: ERROR2a', /conti
+    exit, status=1
+  endif
+
+  a[*]=a[*]-100
+  if a[3,3,3] ne -1 then begin
+    message, '***EXPR: ERROR2b', /conti
+    exit, status=1
+  endif
+
+  sdef={s,a:intarr(3),s:strarr(3)}
+  s1={s,indgen(3),s:sindgen(3)}
+  if s1.a[1] ne 1 then begin
+    message, '***EXPR: ERROR3', /conti
+    exit, status=1
+  endif
+  s2={s}
+  sArr=[s2,s2]
+  sArr[1].s[1]='test'
+  if sArr[1].s[1] ne 'test' then begin
+    message, '***EXPR: ERROR4', /conti
+    exit, status=1
+  endif
+
+  a=1
+  c=4*(3+reform(a,1,/OVERWRITE)+1)*2
+  if c ne 40 then begin
+    message, '***EXPR: ERROR5', /conti
+    exit, status=1
+  endif
+  if a ne 1 then begin
+    message, '***EXPR: ERROR6', /conti
+    exit, status=1
+  endif
+
+  if ~1 and ~2 && ~3 and 4 || ~ 5 ne 0 then begin
+    message, '***EXPR: ERROR7', /conti
+    exit, status=1
+  endif
 
-if ~1 and ~2 && ~3 and 4 || ~ 5 ne 0 then print,'***EXPR: ERROR7'
+  print,'EXPR: OK'
 
-print,'EXPR: OK'
 end
 
 function fac,n
 
-if n le 1 then return,1
+  if n le 1 then return,1
 
-return,fac(n-1)*n
+  return,fac(n-1)*n
 
 end
 
 pro recursion_test
 
-if fac( 5) ne 120 then print,"***RECURSION: ERROR"
+  if fac( 5) ne 120 then begin
+    message, "***RECURSION: ERROR", /conti
+    exit, status=1
+  endif
 
-print,'RECURSION: OK'
+  print,'RECURSION: OK'
 end
 
 pro index_test
 
-b=byte( "abcdefg")
-d=bytarr(20)
-d[10]=b
-
-if string( d[10:16]) ne "abcdefg" then  print,"***INDEX: ERROR1"
-
-i=indgen(3,3)
-s=[[-1],[-2]]
+  b=byte( "abcdefg")
+  d=bytarr(20)
+  d[10]=b
+
+  if string( d[10:16]) ne "abcdefg" then begin
+    message, "***INDEX: ERROR1", /conti
+    exit, status=1
+  endif
+
+  i=indgen(3,3)
+  s=[[-1],[-2]]
+
+  i[1,1]=s
+
+  if i[1,2] ne -2 then begin
+    message, "***INDEX: ERROR2", /conti
+    exit, status=1
+  endif
+
+  c=intarr(3)
+  (((c[1])))=1
+  if c[1] ne 1 then begin
+    message, '***INDEX: ERROR3', /conti
+    exit, status=1
+  endif
 
-i[1,1]=s
+  print,'ARRAY INDEXING: OK'
 
-if i[1,2] ne -2 then  print,"***INDEX: ERROR2"
-
-c=intarr(3)
-(((c[1])))=1
-if c[1] ne 1 then print,'***INDEX: ERROR3'
-
-print,'ARRAY INDEXING: OK'
 end
 
 pro operator_test
 
-a=indgen(4)
-b=indgen(4)
+  a=indgen(4)
+  b=indgen(4)
 
-c=a#b
+  c=a#b
 
-if c[2,3] ne 6 then print,"***OPERATOR: ERROR1"
+  if c[2,3] ne 6 then begin
+    message, "***OPERATOR: ERROR1", /conti
+    exit, status=1
+  endif
 
-b=indgen(4,2)
+  b=indgen(4,2)
 
-c=a#b
+  c=a#b
 
-if c[0,1] ne 38 then print,"***OPERATOR: ERROR2"
+  if c[0,1] ne 38 then begin
+    message, "***OPERATOR: ERROR2", /conti
+    exit, status=1
+  endif
 
-a=indgen(2,4)
-b=indgen(4)
+  a=indgen(2,4)
+  b=indgen(4)
 
-c=a#b
+  c=a#b
 
-if c[1] ne 34 then print,"***OPERATOR: ERROR3"
+  if c[1] ne 34 then begin
+    message, "***OPERATOR: ERROR3", /conti
+    exit, status=1
+  endif
 
-b=indgen(4,2)
+  b=indgen(4,2)
 
-c=a#b
+  c=a#b
 
-if c[0,1] ne 76 then print,"***OPERATOR: ERROR4"
+  if c[0,1] ne 76 then begin
+    message, "***OPERATOR: ERROR4", /conti
+    exit, status=1
+  endif
 
-x=indgen(10) # transpose(intarr(10)+1)
+  x=indgen(10) # transpose(intarr(10)+1)
 
-if x[9,9] ne 9 then print,"***OPERATOR: ERROR5"
+  if x[9,9] ne 9 then begin
+    message, "***OPERATOR: ERROR5", /conti
+    exit, status=1
+  endif
 
-;; with scalar
-r= 4 # indgen(1,4)
-if r[0,2] ne 8 then print,"***OPERATOR: ERROR6"
+  ;; with scalar
+  r= 4 # indgen(1,4)
+  if r[0,2] ne 8 then begin
+    message, "***OPERATOR: ERROR6", /conti
+    exit, status=1
+  endif
 
-r= indgen(4) # 4
-if r[1] ne 4 then print,"***OPERATOR: ERROR7"
+  r= indgen(4) # 4
+  if r[1] ne 4 then begin
+    message, "***OPERATOR: ERROR7", /conti
+    exit, status=1
+  endif
 
+  print,'OPERATORS: OK'
 
-print,'OPERATORS: OK'
 end
 
 pro assignment_test
 
-c = indgen( 4, 4)
+  c = indgen( 4, 4)
+
+  t = intarr( 5, 5)
+  t[0,0] = c
+  if t[3,3] ne 15 then begin
+    message, "***ASSIGNMENT: ERROR1", /conti
+    exit, status=1
+  endif
+
+  t = intarr( 5, 5)
+  t[0,1] = c
+  if t[3,3] ne 11 then begin
+    message, "***ASSIGNMENT: ERROR2", /conti
+    exit, status=1
+  endif
+
+  t = intarr( 5, 5)
+  t[1,0] = c
+  if t[3,3] ne 14 then begin
+    message, "***ASSIGNMENT: ERROR3", /conti
+    exit, status=1
+  endif
+
+  t = intarr( 5, 5)
+  t[1,1] = c
+  if t[3,3] ne 10 then begin
+    message, "***ASSIGNMENT: ERROR4", /conti
+    exit, status=1
+  endif
+
+  t = intarr( 5, 5)
+  a=indgen(3,3)
+  t[1,1]=a
+  if t[2,2] ne 4 then begin
+    message, "***ASSIGNMENT: ERROR5", /conti
+    exit, status=1
+  endif
+
+  t = intarr( 5, 5)
+  a=indgen(3,3)
+  t[1]=a
+  if t[3,0] ne 2 then begin
+    message, "***ASSIGNMENT: ERROR6", /conti
+    exit, status=1
+  endif
+ 
+  a=(1?0:9)
+  b=0
+  (1?a:b) = 2
+  if a ne 2 then begin
+    message, "***ASSIGNMENT: ERROR7", /conti
+    exit, status=1
+  endif
+
+
+  ((a=3))=2
+  if a ne 2 then begin
+    message, "***ASSIGNMENT: ERROR8", /conti
+    exit, status=1
+  endif
+
+  A=create_struct("boo",dblarr(10),"foo",dblarr(10))
+  B=replicate(A,30)
+  data=findgen(30)
+  B[0:29].boo[3] = data[0:29]
+  if B[29].boo[3] ne 29.0 then begin
+    message, "***ASSIGNMENT: ERROR9", /conti
+    exit, status=1
+  endif
 
-t = intarr( 5, 5)
-t[0,0] = c
-if t[3,3] ne 15 then print,"***ASSIGNMENT: ERROR1"
-
-t = intarr( 5, 5)
-t[0,1] = c
-if t[3,3] ne 11 then print,"***ASSIGNMENT: ERROR2"
-
-t = intarr( 5, 5)
-t[1,0] = c
-if t[3,3] ne 14 then print,"***ASSIGNMENT: ERROR3"
-
-t = intarr( 5, 5)
-t[1,1] = c
-if t[3,3] ne 10 then print,"***ASSIGNMENT: ERROR4"
-
-t = intarr( 5, 5)
-a=indgen(3,3)
-t[1,1]=a
-if t[2,2] ne 4 then print,"***ASSIGNMENT: ERROR5"
-
-t = intarr( 5, 5)
-a=indgen(3,3)
-t[1]=a
-if t[3,0] ne 2 then print,"***ASSIGNMENT: ERROR6"
-
-a=(1?0:9)
-b=0
-(1?a:b) = 2
-if a ne 2 then print,"***ASSIGNMENT: ERROR7"
-
-
-((a=3))=2
-if a ne 2 then print,"***ASSIGNMENT: ERROR8"
-
-A=create_struct("boo",dblarr(10),"foo",dblarr(10))
-B=replicate(A,30)
-data=findgen(30)
-B[0:29].boo[3] = data[0:29]
-if B[29].boo[3] ne 29.0 then print,"***ASSIGNMENT: ERROR9"
+  print,"ASSIGNMENT: OK"
 
-print,"ASSIGNMENT: OK"
 end
 
 pro left_libfunction_test
 
-u=indgen(4)
+  u=indgen(4)
 
-(reform(u,4,/OVERWRITE))++
+  (reform(u,4,/OVERWRITE))++
 
-if u[2] ne 3 then print,"***LEFT_LIBFUNCTION: ERROR1"
+  if u[2] ne 3 then begin
+    message, "***LEFT_LIBFUNCTION: ERROR1", /conti
+    exit, status=1
+  endif
 
-print,"LEFT_LIBFUNCTION: OK"
+  print,"LEFT_LIBFUNCTION: OK"
 end
 
 pro stride_index_test
 
-a=lindgen( 11, 20, 31)
+  a=lindgen( 11, 20, 31)
 
-;print,total( a[1:*:3])
+  ;print,total( a[1:*:3])
 
-if total( a[1:10:4, 2:16:2, 5:29:5]) ne 408480. then print,"***STRIDE_INDEX: ERROR 1"
-if total( a[*, 2:14:2, 20:29:5]) ne 776622. then print,"***STRIDE_INDEX: ERROR 2"
-if total( a[1:6:2, *, 17:29:5]) ne 890550. then print,"***STRIDE_INDEX: ERROR 3"
-if total( a[[7,1], 2:16:2, 5:29:5]) ne 272240. then print,"***STRIDE_INDEX: ERROR 4"
-if total( a[3:9:2, [7,1], 2:*:4]) ne 228480. then print,"***STRIDE_INDEX: ERROR "
-if total( a[*, 5:*:5, [7,1]]) ne 65670. then print,"***STRIDE_INDEX: ERROR 5"
-if total( a[5:7, 2:16:2, 5:29:5]) ne 408600. then print,"***STRIDE_INDEX: ERROR 6"
-if total( a[3:9:2, 5:7, 2:*:4]) ne 344832. then print,"***STRIDE_INDEX: ERROR 7"
-if total( a[*, 5:*:5, 5:7]) ne 142065. then print,"***STRIDE_INDEX: ERROR 8"
-
-b=lindgen(50)
-if total( b[1:32:7]) ne 75. then print,"***STRIDE_INDEX: ERROR 9"
-if total( b[1:*:3]) ne 425. then print,"***STRIDE_INDEX: ERROR 10"
+  if total( a[1:10:4, 2:16:2, 5:29:5]) ne 408480. then begin
+    message, "***STRIDE_INDEX: ERROR 1", /conti
+    exit, status=1
+  endif
+  if total( a[*, 2:14:2, 20:29:5]) ne 776622. then begin
+    message, "***STRIDE_INDEX: ERROR 2", /conti
+    exit, status=1
+  endif
+  if total( a[1:6:2, *, 17:29:5]) ne 890550. then begin
+    message, "***STRIDE_INDEX: ERROR 3", /conti
+    exit, status=1
+  endif
+  if total( a[[7,1], 2:16:2, 5:29:5]) ne 272240. then begin
+    message, "***STRIDE_INDEX: ERROR 4", /conti
+    exit, status=1
+  endif
+  if total( a[3:9:2, [7,1], 2:*:4]) ne 228480. then begin
+    message, "***STRIDE_INDEX: ERROR ", /conti
+    exit, status=1
+  endif
+  if total( a[*, 5:*:5, [7,1]]) ne 65670. then begin
+    message, "***STRIDE_INDEX: ERROR 5", /conti
+    exit, status=1
+  endif
+  if total( a[5:7, 2:16:2, 5:29:5]) ne 408600. then begin
+    message, "***STRIDE_INDEX: ERROR 6", /conti
+    exit, status=1
+  endif
+  if total( a[3:9:2, 5:7, 2:*:4]) ne 344832. then begin
+    message, "***STRIDE_INDEX: ERROR 7", /conti
+    exit, status=1
+  endif
+  if total( a[*, 5:*:5, 5:7]) ne 142065. then begin
+    message, "***STRIDE_INDEX: ERROR 8", /conti
+    exit, status=1
+  endif
+
+  b=lindgen(50)
+  if total( b[1:32:7]) ne 75. then begin
+    message, "***STRIDE_INDEX: ERROR 9", /conti
+    exit, status=1
+  endif
+  if total( b[1:*:3]) ne 425. then begin
+    message, "***STRIDE_INDEX: ERROR 10", /conti
+    exit, status=1
+  endif
+
+  print,"STRIDE_INDEX: OK"
 
-print,"STRIDE_INDEX: OK"
 end
 
 ;; set MEMCHECK to perform a memory leak check
@@ -926,37 +1396,37 @@
 ;; with MEMCHECK set, no ptr and object allocations are made
 pro test_suite,MEMCHECK=mCheck
 
-s=systime(1)
+  s=systime(1)
 
-switch_test
-case_test
-while_test
-for_test
-repeat_test
-goto_test
-ret_test
-struct_test
-multi_test
-if not keyword_set( mCheck) then object_test
-common_test
-ref_test,MEMCHECK=mCheck
-syntax_test
-inc_test
-if not keyword_set( mCheck) then inheritance_test
-continuebreak_test
-extra_test
-expr_test
-recursion_test
-index_test
-operator_test
-assignment_test
-left_libfunction_test
-stride_index_test
+  if_test
+  switch_test
+  case_test
+  while_test
+  for_test
+  repeat_test
+  goto_test
+  ret_test
+  struct_test
+  multi_test
+  if not keyword_set( mCheck) then object_test
+  common_test
+  ref_test,MEMCHECK=mCheck
+  syntax_test
+  inc_test
+  if not keyword_set( mCheck) then inheritance_test
+  continuebreak_test
+  extra_test
+  expr_test
+  recursion_test
+  index_test
+  operator_test
+  assignment_test
+  left_libfunction_test
+  stride_index_test
 
-print,"TEST_SUITE finished. Time: ",systime(1)-s
+  print,"TEST_SUITE finished. Time: ",systime(1)-s
 end
 
-
 ;; main program
 print,'TEST_SUITE main program called.'
 test_suite
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_tv.pro cvs/gdl/testsuite/test_tv.pro
--- gdl-0.9rc4/testsuite/test_tv.pro	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/testsuite/test_tv.pro	2010-04-16 11:22:54.000000000 -0600
@@ -40,6 +40,77 @@
 end
 ; -------------------------------------
 ;
+pro TEST_TV_DAMIER_COLOR, numwin, noclose=noclose, test=test, debug=debug, help=help
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro TEST_TV_DAMIER_COLOR, noclose=noclose, test=test, debug=debug, help=help'
+    return
+end
+;
+if N_PARAMS() EQ 0 then numwin=0
+;
+units=64
+nbx=10
+nby=8
+WINDOW, numwin, xsi=units*nbx, ysi=units*nby
+;
+vignette=DIST(units)
+;
+offset_line=0
+nb_cells=nbx*nby
+for ii=0, (nb_cells/2-1)  do begin
+    offset_line=(ii / (nbx/2)) mod 2
+    if KEYWORD_SET(debug) then print, ii, offset_line, 2*ii+offset_line
+    LOADCT, ii
+    TVSCL, vignette, 2*ii+offset_line
+endfor
+;
+if NOT(KEYWORD_SET(noclose)) then begin
+   rep=''
+   READ, 'press any key to finish (and closing all windows)', rep
+   WDELETE, numwin
+endif
+;
+if KEYWORD_SET(test) then STOP
+;;
+end 
+; -------------------------------------
+;
+pro TEST_TV_DAMIER, numwin, noclose=noclose, test=test, debug=debug
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro TEST_TV_DAMIER, numwin, noclose=noclose, test=test, debug=debug, help=help'
+    return
+end
+;
+if N_PARAMS() EQ 0 then numwin=0
+;
+units=64
+nbx=8
+nby=8
+WINDOW, numwin, xsi=units*nbx, ysi=units*nby
+;
+vignette=DIST(units)
+;
+offset_line=0
+nb_cells=nbx*nby
+for ii=0, (nb_cells/2-1)  do begin
+    offset_line=(ii / (nbx/2)) mod 2
+    if KEYWORD_SET(debug) then print, ii, offset_line, 2*ii+offset_line
+    TVSCL, vignette, 2*ii+offset_line
+endfor
+;
+if NOT(KEYWORD_SET(noclose)) then begin
+   rep=''
+   READ, 'press any key to finish (and closing all windows)', rep
+   WDELETE, numwin
+endif
+;
+if KEYWORD_SET(test) then STOP
+;;
+end 
+; -------------------------------------
+;
 pro TEST_TV, noclose=noclose, test=test
 ;
 xdim=350
@@ -61,11 +132,14 @@
 MY_WINDOW, 5, b3
 MY_WINDOW, 6, REFORM(b3)
 ;
+TEST_TV_DAMIER, 8, /noclose
+TEST_TV_DAMIER_COLOR, 9, /noclose
+;
 if NOT(KEYWORD_SET(noclose)) then begin
    rep=''
    READ, 'press any key to finish (and closing all windows)', rep
    ;;
-   WDELETE, 0, 1, 2, 3, 4, 5, 6
+   WDELETE, 0, 1, 2, 3, 4, 5, 6, 8, 9
 endif
 ;
 if KEYWORD_SET(test) then STOP
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_url.pro cvs/gdl/testsuite/test_url.pro
--- gdl-0.9rc4/testsuite/test_url.pro	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/testsuite/test_url.pro	2010-04-16 11:22:54.000000000 -0600
@@ -8,17 +8,18 @@
 ;   PHP is free software available at http://www.php.net/software/
 ; - examples of IPv6 addresses from the RFC2732 (Format for Literal IPv6 Addresses in URL's)
 ;   (http://www.faqs.org/rfcs/rfc2732.html)
-pro test_url
-
-  ; TODO: testing of parse-errors:
-  ; GDL> print, parse_url('a://:000000')
-  ; % PARSE_URL: port cannot be longer then 5 characters
-  ; GDL> print, parse_url('a://:00000')
-  ; % PARSE_URL: invalid host
-
-  sample_urls = [ $
-    ; examples from PHP test script
-    '', $                                 ; IDL 6.4 fails (syntax error)
+;
+pro TEST_URL, debug=debug
+;
+; TODO: testing of parse-errors:
+; GDL> print, parse_url('a://:000000')
+; % PARSE_URL: port cannot be longer then 5 characters
+; GDL> print, parse_url('a://:00000')
+; % PARSE_URL: invalid host
+;
+sample_urls = [ $
+    ;; examples from PHP test script
+    '', $             ; IDL 6.4 fails (syntax error)
     '64.246.30.37', $
     'http://64.246.30.37', $
     'http://64.246.30.37/', $
@@ -177,15 +178,36 @@
     '{ http   [2010:836B:4179::836B:4179]   }', $
     '{ http   www.google.com  /	 }' $
   ]
+;
+if KEYWORD_SET(test) OR KEYWORD_SET(debug) then STOP
+;
+nb_errors=0
+for i = 0, N_ELEMENTS(sample_urls) - 1 do begin
+   s = STRING(PARSE_URL(sample_urls[i]), /print)
+
+   ; STRING(/PRINT) returns an array if the string length exceedes the number of columns in a terminal 
+   if N_ELEMENTS(s) NE 1 then begin
+     ss = ''
+     for ii = 0, n_elements(s) - 1 do ss += s[ii]
+     s = ss
+   endif
 
-  for i = 0, n_elements(sample_urls) - 1 do begin
-    s = string(parse_url(sample_urls[i]), /print) 
-    if s ne expected[i] then begin
-      message, 'test failed for URL: ' + sample_urls[i], /continue
-      message, '  expected: ' + expected[i], /continue
-      message, '       got: ' + s, /continue
-      ;help, parse_url(sample_urls[i]), /stru
-      exit, status=1
-    endif
-  endfor
+   if (s NE expected[i]) then begin
+      MESSAGE, 'test failed for URL: ' + sample_urls[i], /continue
+      MESSAGE, '  expected: ' + expected[i], /continue
+      MESSAGE, '       got: ' + s, /continue
+      ;;help, parse_url(sample_urls[i]), /stru
+      ;;EXIT, status=1
+      nb_errors=nb_errors+1
+      CONTINUE
+   endif
+endfor
+;
+if (nb_errors GT 0) then begin
+   print, 'Number of errors founded :', nb_errors
+   EXIT, status=1
+endif
+;
+if KEYWORD_SET(test) then STOP
+;
 end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_zeropoly.pro cvs/gdl/testsuite/test_zeropoly.pro
--- gdl-0.9rc4/testsuite/test_zeropoly.pro	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/testsuite/test_zeropoly.pro	2010-04-16 11:22:54.000000000 -0600
@@ -44,4 +44,8 @@
     endif
   endfor
 
+  ; freeing heap vars
+  foreach i of c do ptr_free, i
+  foreach i of c do ptr_free, i
+
 end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_zip.pro cvs/gdl/testsuite/test_zip.pro
--- gdl-0.9rc4/testsuite/test_zip.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_zip.pro	2010-06-29 03:20:57.000000000 -0600
@@ -0,0 +1,126 @@
+;
+; Testing the /compress keyword !
+;
+; Maxime Lenoir, June 2010
+; under GNU GPL 2 or later
+; 
+pro TEST_ZIP
+
+file='test_zip.gz'
+spawn,'echo -e "GDL - GNU Data Language\nA free IDL (Interactive Data Language) compatible incremental\ncompiler (i. e. runs IDL programs)." | gzip > '+file
+
+openr,fd,file,/get,/compress,/delete
+
+;; Size test (FSTAT)
+if strlowcase(!version.os_name) eq 'linux' then spawn,'stat --printf=%s '+file,s else spawn,'stat -f%z '+file,s
+if (fstat(fd)).size ne s then begin
+	message,/continue,'Bad size returned for zipped file'
+	exit,status=1
+endif
+
+;; READ TESTS
+
+; Readf test
+str=''
+readf,fd,str
+spawn,'cat '+file+' | gunzip - | head -1',head1
+if str ne head1 then begin
+	message,/continue,'Readf doesn''t work on zipped file'
+	exit,status=1
+endif
+
+readf,fd,str
+spawn,'cat '+file+' | gunzip - | head -2 | tail -1',head2
+if str ne head2 then begin
+	message,/continue,'Readf doesn''t work twice on zipped file'
+	exit,status=1
+endif
+
+point_lun,fd,0
+readf,fd,str ; At this point, readf works well, so we can test point_lun
+if str ne head1 then begin
+	message,/continue,'Point_lun doesn''t work on zipped file (read mode)'
+	exit,status=1
+endif
+
+; Assoc test
+point_lun,fd,0
+a=assoc(fd,bytarr(5))
+spawn,'cat '+file+' | gunzip - | head -1 | cut -b 1-5',cut15
+if string(a[0]) ne cut15 then begin
+	message,/continue,'Assoc doesn''t work on zipped file'
+	exit,status=1
+endif
+
+point_lun,fd,5
+
+if string(a[0]) ne cut15 then begin
+	message,/continue,'Assoc doesn''t work twice on zipped file'
+	exit,status=1
+endif
+
+spawn,'cat '+file+' | gunzip - | head -1 | cut -b 6-10',cut15
+if string(a[1]) ne ' GNU ' then begin
+	message,/continue,'Assoc doesn''t work with differents indexes on zipped file'
+	exit,status=1
+endif
+
+; Readu test
+point_lun,fd,0
+str='123'
+readu,fd,str
+if str ne 'GDL' then begin
+	message,/continue,'Readu doesn''t work on zipped file'
+	exit,status=1
+endif
+
+readu,fd,str
+if str ne ' - ' then begin
+	message,/continue,'Readu doesn''t work twice on zipped file'
+	exit,status=1
+endif
+
+close,fd
+free_lun,fd
+
+;; WRITE TESTS
+
+file='test_zipw.gz'
+openw,fd,file,/get,/compress
+printf,fd,'GNU Data Language'
+close,fd
+free_lun,fd
+
+openr,fd,file,/get,/compress
+readf,fd,str
+if str ne 'GNU Data Language' then begin
+	message,/continue,'Printf doesn''t work on zipped file'
+	exit,status=1
+endif
+close,fd
+free_lun,fd
+
+openw,fd,file,/get,/compress
+printf,fd,'GNU Data Language'
+point_lun,fd,10
+; point_lun used in write mode is pretty useless cause you can only move forward and it cause premature EOF.
+; Also, you can't open a file in write mode, with compress and append keywords.
+; So, if you don't specify append, you truncate the file, and point_lun become useless.
+; To summarize, you can't write data and go backward to overwrite it. (Just don't use it)
+
+printf,fd,'rocks' ; GNU Data Language\nrocks\n
+close,fd
+free_lun,fd
+
+openr,fd,file,/get,/compress,/delete
+a=assoc(fd,bytarr(10))
+
+if string(a[0]) ne 'GNU Data L' or strmid(string(a[1]),0,7) ne 'anguage' then begin
+	message,/continue,'Point_lun doesn''t work on zipped file (write mode)'
+	exit,status=1
+endif
+
+close,fd
+free_lun,fd
+
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/test_zzz.pro cvs/gdl/testsuite/test_zzz.pro
--- gdl-0.9rc4/testsuite/test_zzz.pro	1969-12-31 17:00:00.000000000 -0700
+++ cvs/gdl/testsuite/test_zzz.pro	2010-04-07 10:29:37.000000000 -0600
@@ -0,0 +1,5 @@
+; the name 'zzz' is chosen to place this test at the end of the list
+pro test_zzz
+  spawn, './checks', exit_status=status
+  exit, status=status
+end
diff -ru --unidirectional-new-file --exclude=CVS gdl-0.9rc4/testsuite/try cvs/gdl/testsuite/try
--- gdl-0.9rc4/testsuite/try	2010-02-02 11:13:51.000000000 -0700
+++ cvs/gdl/testsuite/try	2010-04-16 11:22:54.000000000 -0600
@@ -8,9 +8,12 @@
 # expected contents/behaviour of the GDL file:
 # - the script to be tried shoud exit with a non-zero status if failed
 #   (if the scripts exits with status 77, automake will ignore the failure)
-# - the file should containg a procedure with a named in accordance with the
+# - the file should contain a procedure named in accordance with the
 #   file name, e.g. test_wavelet in test_wavelet.pro
 # - the procedure should not need any arguments/keywords
 
+# a quick & dirty way of making the "checks" script work
+test "x$2" = "x./checks" && exit
+
 IDL_PATH="" IDL_STARTUP="" GDL_STARTUP="" GDL_PATH=$1/src/pro:$1/testsuite \
   $1/src/gdl -quiet -e `echo $2 | cut -d/ -f2 | cut -d. -f1`
