diff -ruN --exclude CVS gdl-0.9.2/CMakeLists.txt gdl/CMakeLists.txt
--- gdl-0.9.2/CMakeLists.txt	2011-11-06 15:39:45.000000000 -0700
+++ gdl/CMakeLists.txt	2012-02-19 04:21:43.000000000 -0700
@@ -8,13 +8,13 @@
 #
 
 # tested with 2.4 and doesn't seem to run.
+# SA: 2.6 supports simplified if constructs, e.g. endif()
 cmake_minimum_required(VERSION 2.6 FATAL_ERROR)
 
 project(GDL)
 
-# we hope a 0.9.2 very soon !
-# set(VERSION "0.9.2 CVS")
-set(VERSION "0.9.2")
+# X.X.X CVS becomes release X.X.X
+set(VERSION "0.9.2 CVS")
 enable_testing()
 
 include(CheckIncludeFile)
@@ -43,7 +43,7 @@
 
 set(ZLIBDIR "" CACHE PATH "specify the Zlib directory tree")
 
-set(WXWIDGETS OFF CACHE BOOL "Enable WxWidgets ?")
+set(WXWIDGETS ON CACHE BOOL "Enable WxWidgets ?")
 set(WXWIDGETSDIR "" CACHE PATH "Specify WxWidgets directory tree")
 
 set(UDUNITS OFF CACHE BOOL "Enable UDUNITS-2 ?")
@@ -192,7 +192,9 @@
 		set(CMAKE_REQUIRED_LIBRARIES)
 	else(READLINE_FOUND)
 		message(FATAL_ERROR "GNU readline was not found.\n"
-		"Use -DREADLINEDIR=no to explicitely disable it.")
+		  "Use -DREADLINEDIR=no to explicitely disable it.\n"
+                  "(suitable Debian/Ubuntu package: libreadline5-dev)\n"
+                  "(suitable Fedora package: readline-devel)")
 	endif(READLINE_FOUND)
 endif(READLINE)
 
@@ -206,7 +208,9 @@
 	include_directories(${ZLIB_INCLUDE_DIR})
 else(ZLIB_FOUND)
 	message(FATAL_ERROR "ZLib library is required but was not found.\n"
-	"Use -DZLIBDIR=DIR to specify the zlib directory tree.")
+	"Use -DZLIBDIR=DIR to specify the zlib directory tree.\n"
+        "(suitable Debian/Ubuntu package: zlib1g-dev)\n"
+        "(suitable Fedora package: zlib-devel)")
 endif(ZLIB_FOUND)
 
 # openmp
@@ -230,7 +234,9 @@
 	include_directories(${GSL_INCLUDE_DIR})
 else(GSL_FOUND)
 	message(FATAL_ERROR "Gnu Scientific library (1.7 or higher) and libgslcblas are mandatory.\n"
-	"Use -DGSLDIR=DIR to specify the gsl directory tree.")
+	"Use -DGSLDIR=DIR to specify the gsl directory tree.\n"
+        "(suitable Debian/Ubuntu package: libgsl0-dev)\n"
+        "(suitable Fedora package: gsl-devel)")
 endif(GSL_FOUND)
 
 # PLplot MANDATORY
@@ -245,7 +251,9 @@
 	include_directories(${PLPLOT_INCLUDE_DIR})
 else(PLPLOT_FOUND)
 	message(FATAL_ERROR "plplot library is required but was not found.\n"
-	"Use -DPLPLOTDIR=DIR to specify the plplot directory tree.")
+	"Use -DPLPLOTDIR=DIR to specify the plplot directory tree.\n"
+        "(suitable Debian/Ubuntu packages: libplplot-dev, [plplot9-driver-xwin])"
+        "(suitable Fedora package: plplot-devel)")
 endif(PLPLOT_FOUND)
 if(MAGICK) # support Magick
 	check_library_exists("${PLPLOT_LIBRARIES}" plGetDrvDir "" HAVE_PLGETDRVDIR)
@@ -274,7 +282,9 @@
 	else(wxWidgets_FOUND)
 		message(FATAL_ERROR "wxWidgets are required but were not found.\n"
 		"Use -DWXWIDGETSDIR=DIR to specify the wxWidgets directory tree.\n"
-		"Use -DWXWIDGETS=OFF to not use it.")
+		"Use -DWXWIDGETS=OFF to not use it.\n"
+                "(suitable Debian/Ubuntu package: libwxgtk2.8-dev)\n"
+                "(suitable Fedora package: wxGTK-devel)")
 	endif(wxWidgets_FOUND)
 endif(WXWIDGETS)
 
@@ -295,7 +305,9 @@
 		else(MAGICKXXCONFIG)
 			message(FATAL_ERROR "ImageMagick is required but was not found (Magick++-config).\n"
 			"Use -DMAGICKDIR=DIR to specify the ImageMagick directory.\n"
-			"Use -DMAGICK=OFF to not use it.")
+			"Use -DMAGICK=OFF to not use it.\n"
+                        "(suitable Debian/Ubuntu package: libmagick++-dev)\n"
+                        "(suitable Fedora package: ImageMagick-c++-devel)")
 		endif(MAGICKXXCONFIG)
 		set(LIBRARIES ${LIBRARIES} ${ImageMagick_LIBRARIES})
 		include_directories(${ImageMagick_INCLUDE_DIRS})
@@ -303,7 +315,9 @@
 	else(ImageMagick_FOUND)
 		message(FATAL_ERROR "ImageMagick is required but was not found.\n"
 		"Use -DMAGICKDIR=DIR to specify the ImageMagick directory.\n"
-		"Use -DMAGICK=OFF to not use it.")
+		"Use -DMAGICK=OFF to not use it.\n"
+                "(suitable Debian/Ubuntu package: libmagick++-dev)\n"
+                "(suitable Fedora package: ImageMagick-c++-devel)")
 	endif(ImageMagick_FOUND)
 endif(MAGICK)
 
@@ -331,7 +345,9 @@
 	else(NETCDF_FOUND)
 		message(FATAL_ERROR "NetCDF version 3.5.1 or later is required but was not found.\n"
 		"Use -DNETCDFDIR=DIR to specify the netcdf directory tree.\n"
-		"Use -DNETCDF=OFF to not use it.")	
+		"Use -DNETCDF=OFF to not use it.\n"
+                "(suitable Debian/Ubuntu package: libnetcdf-dev)\n"
+                "(suitable Fedora package: netcdf-devel)")
 	endif(NETCDF_FOUND)
 endif(NETCDF)
 
@@ -358,7 +374,8 @@
 	else(HDF_FOUND)
 		message(FATAL_ERROR "HDF4 libraries were not found.\n"
 		"Use -DHDFDIR=DIR to specify the HDF directory tree.\n"
-		"Use -DHDF=OFF to not use it. "
+		"Use -DHDF=OFF to not use it.\n"
+                "(suitable Debian/Ubuntu package: libhdf4-alt-dev)\n"
 		"You can use -DJPEGDIR=DIR to specify the JPEG directory tree. "
 		"You can also use -DSZIPDIR=DIR to specify SZip directory tree if "
 		"HDF was compiled with SZip support.")
@@ -383,7 +400,9 @@
 	else(HDF5_FOUND)
 		message(FATAL_ERROR "HDF version 5 is required but was not found.\n"
 		"Use -DHDF5DIR=DIR to specify the HDF5 directory tree.\n"
-		"Use -DHDF5=OFF to not use it.")
+		"Use -DHDF5=OFF to not use it.\n"
+                "(suitable Debian/Ubuntu package: libhdf5-serial-dev)\n"
+                "(suitable Fedora package: hdf-devel)")
 	endif(HDF5_FOUND)
 endif(HDF5)
 
@@ -400,7 +419,9 @@
 	else(FFTW_FOUND)
 		message(FATAL_ERROR "FFTW3 is required but was not found.\n"
 		"Use -DFFTWDIR=DIR to specify the FFTW directory tree.\n"
-		"Use -DFFTW=OFF to not use it.")
+		"Use -DFFTW=OFF to not use it.\n"
+                "(suitable Debian/Ubuntu package: libfftw3-dev)\n
+                "(suitable Fedora package: fftw-devel)"")
 	endif(FFTW_FOUND)
 endif(FFTW)
 
@@ -462,12 +483,44 @@
 	if(PYTHON_MODULE)
 		set(PYTHON_MODULEMSG "Use -DPYTHON_MODULE=OFF to disable Python module.\n")
 	endif(PYTHON_MODULE)
-	set(CMAKE_PREFIX_PATH ${PYTHONDIR})
-	if(PYTHONVERSION)
-		find_package(PythonLibs ${PYTHONVERSION} EXACT QUIET)
-	else(PYTHONVERSION)
-		find_package(PythonLibs QUIET)
-	endif(PYTHONVERSION)
+	if(PYTHONDIR)
+		find_library(PYTHONLIBS 
+                  NAMES python${PYTHONVERSION}
+                  PATHS ${PYTHONDIR} 
+                  PATH_SUFFIXES lib lib/python${PYTHONVERSION}/config 
+                  NO_DEFAULT_PATH NO_CMAKE_PATH
+                )
+                string(COMPARE NOTEQUAL "${PYTHONLIBS}" "PYTHONLIBS-NOTFOUND" PYTHONLIBS_FOUND) 
+                if (NOT PYTHONLIBS_FOUND)
+                  message(FATAL_ERROR "Python libraries not found in ${PYTHONDIR}.")
+                else()
+                  set(PYTHON_LIBRARIES "${PYTHONLIBS}")
+                  message("-- Found Python libs: ${PYTHONLIBS}")
+                endif()
+                find_path(PYTHON_INCLUDE_DIRS 
+                  NAMES Python.h 
+                  PATHS ${PYTHONDIR}
+                  PATH_SUFFIXES include include/python${PYTHONVERSION}
+                  NO_DEFAULT_PATH NO_CMAKE_PATH
+                )
+                string(COMPARE NOTEQUAL "${PYTHONLIBS}" "PYTHON_INCLUDE_DIRS-NOTFOUND" PYTHONHEADERS_FOUND) 
+                if (PYTHONHEADERS_FOUND)
+                  message("-- Found Python headers: ${PYTHON_INCLUDE_DIRS}")
+                  set(PYTHON_INCLUDES "${PYTHON_INCLUDE_DIRS}")
+                else()
+                  message(FATAL_ERROR "Python headers not found in ${PYTHONDIR}.")
+                endif()
+                find_program(PYTHON_EXECUTABLE NAMES python${PYTHONVERSION} PATHS ${PYTHONDIR} PATH_SUFFIXES bin NO_DEFAULT_PATH NO_CMAKE_PATH)
+                string(COMPARE NOTEQUAL "${PYTHON_EXECUTABLE}" "PYTHON_EXECUTABLE-NOTFOUND" PYTHON_EXECUTABLE_FOUND) 
+                if(NOT PYTHON_EXECUTABLE_FOUND)
+                  message(FATAL_ERROR "Python executable not found in ${PYTHONDIR}.")
+                else()
+                  message("-- Found Python executable: ${PYTHON_EXECUTABLE}")
+                endif()
+	else()
+		find_package(PythonLibs)
+                include(FindPythonInterp)
+	endif()
 	set(USE_PYTHON ${PYTHONLIBS_FOUND})
 	if(PYTHONLIBS_FOUND)
 		find_package(Numpy QUIET)
@@ -476,12 +529,14 @@
 			"${PYTHONMSG} ${PYTHON_MODULEMSG}")
 		endif(NOT PYTHON_NUMPY_FOUND)
 		set(LIBRARIES ${LIBRARIES} ${PYTHON_LIBRARIES})
-		include_directories(${PYTHON_INCLUDE_DIRS})	
+		include_directories(${PYTHON_INCLUDE_DIRS} ${PYTHON_NUMPY_INCLUDE_DIR})	
 	else(PYTHONLIBS_FOUND)
 		message(FATAL_ERROR "Python is required but was not found.\n"
 		"Use -DPYTHONDIR=DIR to specify the Python directory tree.\n"
-		"${PYTHONMSG} ${PYTHON_MODULEMSG}"
-		"Use -DPYTHONVERSION=VERSION to help searching for the right version.")
+                "Use -DPYTHONVERSION=VERSION to help searching for the right version.\n"
+                "(suitable Debian/Ubuntu package: python-dev)\n"
+                "(suitable Fedora package: python-devel)\n"
+		"${PYTHONMSG} ${PYTHON_MODULEMSG}")
 	endif(PYTHONLIBS_FOUND)
 endif(PYTHON OR PYTHON_MODULE)
 
@@ -498,7 +553,9 @@
 	else(UDUNITS_FOUND)
 		message(FATAL_ERROR "UDUNITS-2 is required but was not found.\n"
 		"Use -DUDUNITSDIR=DIR to specify the Udunits directory tree.\n"
-		"Use -DUDUNITS=OFF to not use it.")
+		"Use -DUDUNITS=OFF to not use it.\n"
+                "(suitable Debian/Ubuntu package: libudunits2-dev)\n"
+                "(suitable Fedora package: udunits2-devel)")
 	endif(UDUNITS_FOUND)
 endif(UDUNITS)
 
@@ -515,7 +572,9 @@
 	else(LIBPS_FOUND)
 		message(FATAL_ERROR "pslib is required but was not found.\n"
 		"Use -DPSLIBDIR=DIR to specify the pslib directory tree.\n"
-		"Use -DPSLIB=OFF to not use it.")
+		"Use -DPSLIB=OFF to not use it.\n"
+                "(suitable Debian/Ubuntu package: pslib-dev)\n"
+                "(suitable Fedora package: pslib-devel)")
 	endif(LIBPS_FOUND)
 endif(PSLIB)
 
@@ -534,7 +593,9 @@
 		"Use -DGRIBDIR=DIR to specify the GRIB directory tree.\n"
 		"Use -DGRIB=OFF to not use it.\n"
 		"Use -DJASPERDIR=DIR and|or -DJPEGDIR=DIR to specify "
-		"the directory trees of JasPer and openJPEG libraries.")
+		"the directory trees of JasPer and openJPEG libraries.\n"
+                "(suitable Debian/Ubuntu package: libgrib-api-dev)\n"
+                "(suitable Fedora package: grib_api-devel)")
 	endif(GRIB_FOUND)
 endif(GRIB)
 
diff -ruN --exclude CVS gdl-0.9.2/CMakeModules/FindNumpy.cmake gdl/CMakeModules/FindNumpy.cmake
--- gdl-0.9.2/CMakeModules/FindNumpy.cmake	2011-08-19 04:18:51.000000000 -0600
+++ gdl/CMakeModules/FindNumpy.cmake	2012-01-02 14:28:12.000000000 -0700
@@ -19,7 +19,7 @@
   set (PYTHON_NUMPY_FIND_QUIETLY TRUE)
 endif (PYTHON_NUMPY_INCLUDE_DIR)
 
-INCLUDE(FindPythonInterp)
+#INCLUDE(FindPythonInterp) #SA: this is now done in CMakeLists.txt
 
 IF(PYTHON_EXECUTABLE)
     EXEC_PROGRAM ("${PYTHON_EXECUTABLE}"
@@ -27,12 +27,14 @@
       OUTPUT_VARIABLE PYTHON_NUMPY_INCLUDE_DIR
       RETURN_VALUE PYTHON_NUMPY_NOT_FOUND)
 
-    if (PYTHON_NUMPY_INCLUDE_DIR)
+    if (PYTHON_NUMPY_NOT_FOUND)
+      set(PYTHON_NUMPY_FOUND FALSE)
+    else()
       set (PYTHON_NUMPY_FOUND TRUE)
       set (PYTHON_NUMPY_INCLUDE_DIR ${PYTHON_NUMPY_INCLUDE_DIR} CACHE STRING "Numpy include path")
-    else (PYTHON_NUMPY_INCLUDE_DIR)
-      set(PYTHON_NUMPY_FOUND FALSE)
-    endif (PYTHON_NUMPY_INCLUDE_DIR)
+    endif()
+else()
+  message(FATAL_ERROR "PYTHON_EXECUTABLE not defined!")
 ENDIF(PYTHON_EXECUTABLE)
 
 if (PYTHON_NUMPY_FOUND)
diff -ruN --exclude CVS gdl-0.9.2/config.h.cmake gdl/config.h.cmake
--- gdl-0.9.2/config.h.cmake	2010-09-02 13:43:21.000000000 -0600
+++ gdl/config.h.cmake	2011-12-31 02:08:24.000000000 -0700
@@ -64,5 +64,6 @@
 #cmakedefine USE_NETCDF 1
 #cmakedefine USE_PYTHON 1
 #cmakedefine USE_UDUNITS 1
+#cmakedefine USE_PSLIB 1
 
 #endif
diff -ruN --exclude CVS gdl-0.9.2/config.log gdl/config.log
--- gdl-0.9.2/config.log	2011-11-08 17:32:45.000000000 -0700
+++ gdl/config.log	1969-12-31 17:00:00.000000000 -0700
@@ -1,1110 +0,0 @@
-This file contains any messages produced by compilers while
-running configure, to aid debugging if configure makes a mistake.
-
-It was created by gdl configure 0.9.2, which was
-generated by GNU Autoconf 2.68.  Invocation command line was
-
-  $ ./configure 
-
-## --------- ##
-## Platform. ##
-## --------- ##
-
-hostname = kubuntu1110VM
-uname -m = i686
-uname -r = 3.0.0-12-generic
-uname -s = Linux
-uname -v = #20-Ubuntu SMP Fri Oct 7 14:50:42 UTC 2011
-
-/usr/bin/uname -p = unknown
-/bin/uname -X     = unknown
-
-/bin/arch              = unknown
-/usr/bin/arch -k       = unknown
-/usr/convex/getsysinfo = unknown
-/usr/bin/hostinfo      = unknown
-/bin/machine           = unknown
-/usr/bin/oslevel       = unknown
-/bin/universe          = unknown
-
-PATH: /usr/local/sbin
-PATH: /usr/local/bin
-PATH: /usr/sbin
-PATH: /usr/bin
-PATH: /sbin
-PATH: /bin
-PATH: /usr/games
-
-
-## ----------- ##
-## Core tests. ##
-## ----------- ##
-
-configure:2502: checking autoconf version
-configure:2505: result: >=2.62
-configure:2552: checking for a BSD-compatible install
-configure:2620: result: /usr/bin/install -c
-configure:2631: checking whether build environment is sane
-configure:2681: result: yes
-configure:2822: checking for a thread-safe mkdir -p
-configure:2861: result: /bin/mkdir -p
-configure:2874: checking for gawk
-configure:2904: result: no
-configure:2874: checking for mawk
-configure:2890: found /usr/bin/mawk
-configure:2901: result: mawk
-configure:2912: checking whether make sets $(MAKE)
-configure:2934: result: yes
-configure:3080: checking for g++
-configure:3096: found /usr/bin/g++
-configure:3107: result: g++
-configure:3134: checking for C++ compiler version
-configure:3143: g++ --version >&5
-g++ (Ubuntu/Linaro 4.6.1-9ubuntu3) 4.6.1
-Copyright (C) 2011 Free Software Foundation, Inc.
-This is free software; see the source for copying conditions.  There is NO
-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-
-configure:3154: $? = 0
-configure:3143: g++ -v >&5
-Using built-in specs.
-COLLECT_GCC=g++
-COLLECT_LTO_WRAPPER=/usr/lib/gcc/i686-linux-gnu/4.6.1/lto-wrapper
-Target: i686-linux-gnu
-Configured with: ../src/configure -v --with-pkgversion='Ubuntu/Linaro 4.6.1-9ubuntu3' --with-bugurl=file:///usr/share/doc/gcc-4.6/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++,go --prefix=/usr --program-suffix=-4.6 --enable-shared --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.6 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-plugin --enable-objc-gc --enable-targets=all --disable-werror --with-arch-32=i686 --with-tune=generic --enable-checking=release --build=i686-linux-gnu --host=i686-linux-gnu --target=i686-linux-gnu
-Thread model: posix
-gcc version 4.6.1 (Ubuntu/Linaro 4.6.1-9ubuntu3) 
-configure:3154: $? = 0
-configure:3143: g++ -V >&5
-g++: error: unrecognized option '-V'
-g++: fatal error: no input files
-compilation terminated.
-configure:3154: $? = 4
-configure:3143: g++ -qversion >&5
-g++: error: unrecognized option '-qversion'
-g++: fatal error: no input files
-compilation terminated.
-configure:3154: $? = 4
-configure:3174: checking whether the C++ compiler works
-configure:3196: g++    conftest.cpp  >&5
-configure:3200: $? = 0
-configure:3248: result: yes
-configure:3251: checking for C++ compiler default output file name
-configure:3253: result: a.out
-configure:3259: checking for suffix of executables
-configure:3266: g++ -o conftest    conftest.cpp  >&5
-configure:3270: $? = 0
-configure:3292: result: 
-configure:3314: checking whether we are cross compiling
-configure:3322: g++ -o conftest    conftest.cpp  >&5
-configure:3326: $? = 0
-configure:3333: ./conftest
-configure:3337: $? = 0
-configure:3352: result: no
-configure:3357: checking for suffix of object files
-configure:3379: g++ -c   conftest.cpp >&5
-configure:3383: $? = 0
-configure:3404: result: o
-configure:3408: checking whether we are using the GNU C++ compiler
-configure:3427: g++ -c   conftest.cpp >&5
-configure:3427: $? = 0
-configure:3436: result: yes
-configure:3445: checking whether g++ accepts -g
-configure:3465: g++ -c -g  conftest.cpp >&5
-configure:3465: $? = 0
-configure:3506: result: yes
-configure:3540: checking for style of include used by make
-configure:3568: result: GNU
-configure:3593: checking dependency style of g++
-configure:3703: result: gcc3
-configure:3761: checking for ranlib
-configure:3777: found /usr/bin/ranlib
-configure:3788: result: ranlib
-configure:3839: checking build system type
-configure:3853: result: i686-pc-linux-gnu
-configure:3873: checking host system type
-configure:3886: result: i686-pc-linux-gnu
-configure:3927: checking how to print strings
-configure:3954: result: printf
-configure:4023: checking for gcc
-configure:4039: found /usr/bin/gcc
-configure:4050: result: gcc
-configure:4279: checking for C compiler version
-configure:4288: gcc --version >&5
-gcc (Ubuntu/Linaro 4.6.1-9ubuntu3) 4.6.1
-Copyright (C) 2011 Free Software Foundation, Inc.
-This is free software; see the source for copying conditions.  There is NO
-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-
-configure:4299: $? = 0
-configure:4288: gcc -v >&5
-Using built-in specs.
-COLLECT_GCC=gcc
-COLLECT_LTO_WRAPPER=/usr/lib/gcc/i686-linux-gnu/4.6.1/lto-wrapper
-Target: i686-linux-gnu
-Configured with: ../src/configure -v --with-pkgversion='Ubuntu/Linaro 4.6.1-9ubuntu3' --with-bugurl=file:///usr/share/doc/gcc-4.6/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++,go --prefix=/usr --program-suffix=-4.6 --enable-shared --enable-linker-build-id --with-system-zlib --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.6 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --enable-plugin --enable-objc-gc --enable-targets=all --disable-werror --with-arch-32=i686 --with-tune=generic --enable-checking=release --build=i686-linux-gnu --host=i686-linux-gnu --target=i686-linux-gnu
-Thread model: posix
-gcc version 4.6.1 (Ubuntu/Linaro 4.6.1-9ubuntu3) 
-configure:4299: $? = 0
-configure:4288: gcc -V >&5
-gcc: error: unrecognized option '-V'
-gcc: fatal error: no input files
-compilation terminated.
-configure:4299: $? = 4
-configure:4288: gcc -qversion >&5
-gcc: error: unrecognized option '-qversion'
-gcc: fatal error: no input files
-compilation terminated.
-configure:4299: $? = 4
-configure:4303: checking whether we are using the GNU C compiler
-configure:4322: gcc -c   conftest.c >&5
-configure:4322: $? = 0
-configure:4331: result: yes
-configure:4340: checking whether gcc accepts -g
-configure:4360: gcc -c -g  conftest.c >&5
-configure:4360: $? = 0
-configure:4401: result: yes
-configure:4418: checking for gcc option to accept ISO C89
-configure:4482: gcc  -c -g -O3  conftest.c >&5
-configure:4482: $? = 0
-configure:4495: result: none needed
-configure:4517: checking dependency style of gcc
-configure:4627: result: gcc3
-configure:4642: checking for a sed that does not truncate output
-configure:4706: result: /bin/sed
-configure:4724: checking for grep that handles long lines and -e
-configure:4782: result: /bin/grep
-configure:4787: checking for egrep
-configure:4849: result: /bin/grep -E
-configure:4854: checking for fgrep
-configure:4916: result: /bin/grep -F
-configure:4951: checking for ld used by gcc
-configure:5018: result: /usr/bin/ld
-configure:5025: checking if the linker (/usr/bin/ld) is GNU ld
-configure:5040: result: yes
-configure:5052: checking for BSD- or MS-compatible name lister (nm)
-configure:5101: result: /usr/bin/nm -B
-configure:5231: checking the name lister (/usr/bin/nm -B) interface
-configure:5238: g++ -c -g -O3  conftest.cpp >&5
-configure:5241: /usr/bin/nm -B "conftest.o"
-configure:5244: output
-00000000 B some_variable
-configure:5251: result: BSD nm
-configure:5254: checking whether ln -s works
-configure:5258: result: yes
-configure:5266: checking the maximum length of command line arguments
-configure:5391: result: 1572864
-configure:5408: checking whether the shell understands some XSI constructs
-configure:5418: result: yes
-configure:5422: checking whether the shell understands "+="
-configure:5428: result: yes
-configure:5463: checking how to convert i686-pc-linux-gnu file names to i686-pc-linux-gnu format
-configure:5503: result: func_convert_file_noop
-configure:5510: checking how to convert i686-pc-linux-gnu file names to toolchain format
-configure:5530: result: func_convert_file_noop
-configure:5537: checking for /usr/bin/ld option to reload object files
-configure:5544: result: -r
-configure:5618: checking for objdump
-configure:5634: found /usr/bin/objdump
-configure:5645: result: objdump
-configure:5677: checking how to recognize dependent libraries
-configure:5879: result: pass_all
-configure:5964: checking for dlltool
-configure:5994: result: no
-configure:6024: checking how to associate runtime and link libraries
-configure:6051: result: printf %s\n
-configure:6112: checking for ar
-configure:6128: found /usr/bin/ar
-configure:6139: result: ar
-configure:6176: checking for archiver @FILE support
-configure:6193: g++ -c -g -O3  conftest.cpp >&5
-configure:6193: $? = 0
-configure:6196: ar cru libconftest.a @conftest.lst >&5
-configure:6199: $? = 0
-configure:6204: ar cru libconftest.a @conftest.lst >&5
-ar: conftest.o: No such file or directory
-configure:6207: $? = 1
-configure:6219: result: @
-configure:6277: checking for strip
-configure:6293: found /usr/bin/strip
-configure:6304: result: strip
-configure:6376: checking for ranlib
-configure:6403: result: ranlib
-configure:6505: checking command to parse /usr/bin/nm -B output from gcc object
-configure:6624: g++ -c -g -O3  conftest.cpp >&5
-configure:6627: $? = 0
-configure:6631: /usr/bin/nm -B conftest.o \| sed -n -e 's/^.*[ ]\([ABCDGIRSTW][ABCDGIRSTW]*\)[ ][ ]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p' | sed '/ __gnu_lto/d' \> conftest.nm
-configure:6634: $? = 0
-configure:6700: g++ -o conftest -g -O3   conftest.cpp conftstm.o >&5
-configure:6703: $? = 0
-configure:6741: result: ok
-configure:6778: checking for sysroot
-configure:6808: result: no
-configure:7052: checking for mt
-configure:7068: found /bin/mt
-configure:7079: result: mt
-configure:7102: checking if mt is a manifest tool
-configure:7108: mt '-?'
-configure:7116: result: no
-configure:7748: checking how to run the C preprocessor
-configure:7779: gcc -E  conftest.c
-configure:7779: $? = 0
-configure:7793: gcc -E  conftest.c
-conftest.c:11:28: fatal error: ac_nonexistent.h: No such file or directory
-compilation terminated.
-configure:7793: $? = 1
-configure: failed program was:
-| /* confdefs.h */
-| #define PACKAGE_NAME "gdl"
-| #define PACKAGE_TARNAME "gdl"
-| #define PACKAGE_VERSION "0.9.2"
-| #define PACKAGE_STRING "gdl 0.9.2"
-| #define PACKAGE_BUGREPORT ""
-| #define PACKAGE_URL ""
-| #define PACKAGE "gdl"
-| #define VERSION "0.9.2"
-| /* end confdefs.h.  */
-| #include <ac_nonexistent.h>
-configure:7818: result: gcc -E
-configure:7838: gcc -E  conftest.c
-configure:7838: $? = 0
-configure:7852: gcc -E  conftest.c
-conftest.c:11:28: fatal error: ac_nonexistent.h: No such file or directory
-compilation terminated.
-configure:7852: $? = 1
-configure: failed program was:
-| /* confdefs.h */
-| #define PACKAGE_NAME "gdl"
-| #define PACKAGE_TARNAME "gdl"
-| #define PACKAGE_VERSION "0.9.2"
-| #define PACKAGE_STRING "gdl 0.9.2"
-| #define PACKAGE_BUGREPORT ""
-| #define PACKAGE_URL ""
-| #define PACKAGE "gdl"
-| #define VERSION "0.9.2"
-| /* end confdefs.h.  */
-| #include <ac_nonexistent.h>
-configure:7881: checking for ANSI C header files
-configure:7901: gcc -c -g -O3  conftest.c >&5
-configure:7901: $? = 0
-configure:7974: gcc -o conftest -g -O3   conftest.c  >&5
-configure:7974: $? = 0
-configure:7974: ./conftest
-configure:7974: $? = 0
-configure:7985: result: yes
-configure:7998: checking for sys/types.h
-configure:7998: gcc -c -g -O3  conftest.c >&5
-configure:7998: $? = 0
-configure:7998: result: yes
-configure:7998: checking for sys/stat.h
-configure:7998: gcc -c -g -O3  conftest.c >&5
-configure:7998: $? = 0
-configure:7998: result: yes
-configure:7998: checking for stdlib.h
-configure:7998: gcc -c -g -O3  conftest.c >&5
-configure:7998: $? = 0
-configure:7998: result: yes
-configure:7998: checking for string.h
-configure:7998: gcc -c -g -O3  conftest.c >&5
-configure:7998: $? = 0
-configure:7998: result: yes
-configure:7998: checking for memory.h
-configure:7998: gcc -c -g -O3  conftest.c >&5
-configure:7998: $? = 0
-configure:7998: result: yes
-configure:7998: checking for strings.h
-configure:7998: gcc -c -g -O3  conftest.c >&5
-configure:7998: $? = 0
-configure:7998: result: yes
-configure:7998: checking for inttypes.h
-configure:7998: gcc -c -g -O3  conftest.c >&5
-configure:7998: $? = 0
-configure:7998: result: yes
-configure:7998: checking for stdint.h
-configure:7998: gcc -c -g -O3  conftest.c >&5
-configure:7998: $? = 0
-configure:7998: result: yes
-configure:7998: checking for unistd.h
-configure:7998: gcc -c -g -O3  conftest.c >&5
-configure:7998: $? = 0
-configure:7998: result: yes
-configure:8012: checking for dlfcn.h
-configure:8012: gcc -c -g -O3  conftest.c >&5
-configure:8012: $? = 0
-configure:8012: result: yes
-configure:8209: checking for objdir
-configure:8224: result: .libs
-configure:8491: checking if gcc supports -fno-rtti -fno-exceptions
-configure:8509: gcc -c -g -O3  -fno-rtti -fno-exceptions conftest.c >&5
-cc1: warning: command line option '-fno-rtti' is valid for C++/ObjC++ but not for C [enabled by default]
-configure:8513: $? = 0
-configure:8526: result: no
-configure:8836: checking for gcc option to produce PIC
-configure:8843: result: -fPIC -DPIC
-configure:8851: checking if gcc PIC flag -fPIC -DPIC works
-configure:8869: gcc -c -g -O3  -fPIC -DPIC -DPIC conftest.c >&5
-configure:8873: $? = 0
-configure:8886: result: yes
-configure:8915: checking if gcc static flag -static works
-configure:8943: result: yes
-configure:8958: checking if gcc supports -c -o file.o
-configure:8979: gcc -c -g -O3  -o out/conftest2.o conftest.c >&5
-configure:8983: $? = 0
-configure:9005: result: yes
-configure:9013: checking if gcc supports -c -o file.o
-configure:9060: result: yes
-configure:9093: checking whether the gcc linker (/usr/bin/ld) supports shared libraries
-configure:10255: result: yes
-configure:10292: checking whether -lc should be explicitly linked in
-configure:10300: gcc -c -g -O3  conftest.c >&5
-configure:10303: $? = 0
-configure:10318: gcc -shared  -fPIC -DPIC conftest.o  -v -Wl,-soname -Wl,conftest -o conftest 2\>\&1 \| /bin/grep  -lc  \>/dev/null 2\>\&1
-configure:10321: $? = 0
-configure:10335: result: no
-configure:10500: checking dynamic linker characteristics
-configure:11015: gcc -o conftest -g -O3   -Wl,-rpath -Wl,/foo conftest.c  >&5
-configure:11015: $? = 0
-configure:11249: result: GNU/Linux ld.so
-configure:11356: checking how to hardcode library paths into programs
-configure:11381: result: immediate
-configure:11921: checking whether stripping libraries is possible
-configure:11926: result: yes
-configure:11961: checking if libtool supports shared libraries
-configure:11963: result: yes
-configure:11966: checking whether to build shared libraries
-configure:11987: result: yes
-configure:11990: checking whether to build static libraries
-configure:11994: result: yes
-configure:12017: checking how to run the C++ preprocessor
-configure:12044: g++ -E  conftest.cpp
-configure:12044: $? = 0
-configure:12058: g++ -E  conftest.cpp
-conftest.cpp:23:28: fatal error: ac_nonexistent.h: No such file or directory
-compilation terminated.
-configure:12058: $? = 1
-configure: failed program was:
-| /* confdefs.h */
-| #define PACKAGE_NAME "gdl"
-| #define PACKAGE_TARNAME "gdl"
-| #define PACKAGE_VERSION "0.9.2"
-| #define PACKAGE_STRING "gdl 0.9.2"
-| #define PACKAGE_BUGREPORT ""
-| #define PACKAGE_URL ""
-| #define PACKAGE "gdl"
-| #define VERSION "0.9.2"
-| #define STDC_HEADERS 1
-| #define HAVE_SYS_TYPES_H 1
-| #define HAVE_SYS_STAT_H 1
-| #define HAVE_STDLIB_H 1
-| #define HAVE_STRING_H 1
-| #define HAVE_MEMORY_H 1
-| #define HAVE_STRINGS_H 1
-| #define HAVE_INTTYPES_H 1
-| #define HAVE_STDINT_H 1
-| #define HAVE_UNISTD_H 1
-| #define HAVE_DLFCN_H 1
-| #define LT_OBJDIR ".libs/"
-| /* end confdefs.h.  */
-| #include <ac_nonexistent.h>
-configure:12083: result: g++ -E
-configure:12103: g++ -E  conftest.cpp
-configure:12103: $? = 0
-configure:12117: g++ -E  conftest.cpp
-conftest.cpp:23:28: fatal error: ac_nonexistent.h: No such file or directory
-compilation terminated.
-configure:12117: $? = 1
-configure: failed program was:
-| /* confdefs.h */
-| #define PACKAGE_NAME "gdl"
-| #define PACKAGE_TARNAME "gdl"
-| #define PACKAGE_VERSION "0.9.2"
-| #define PACKAGE_STRING "gdl 0.9.2"
-| #define PACKAGE_BUGREPORT ""
-| #define PACKAGE_URL ""
-| #define PACKAGE "gdl"
-| #define VERSION "0.9.2"
-| #define STDC_HEADERS 1
-| #define HAVE_SYS_TYPES_H 1
-| #define HAVE_SYS_STAT_H 1
-| #define HAVE_STDLIB_H 1
-| #define HAVE_STRING_H 1
-| #define HAVE_MEMORY_H 1
-| #define HAVE_STRINGS_H 1
-| #define HAVE_INTTYPES_H 1
-| #define HAVE_STDINT_H 1
-| #define HAVE_UNISTD_H 1
-| #define HAVE_DLFCN_H 1
-| #define LT_OBJDIR ".libs/"
-| /* end confdefs.h.  */
-| #include <ac_nonexistent.h>
-configure:12287: checking for ld used by g++
-configure:12354: result: /usr/bin/ld
-configure:12361: checking if the linker (/usr/bin/ld) is GNU ld
-configure:12376: result: yes
-configure:12431: checking whether the g++ linker (/usr/bin/ld) supports shared libraries
-configure:13435: result: yes
-configure:13470: g++ -c -g -O3  conftest.cpp >&5
-configure:13473: $? = 0
-configure:13993: checking for g++ option to produce PIC
-configure:14000: result: -fPIC -DPIC
-configure:14008: checking if g++ PIC flag -fPIC -DPIC works
-configure:14026: g++ -c -g -O3  -fPIC -DPIC -DPIC conftest.cpp >&5
-configure:14030: $? = 0
-configure:14043: result: yes
-configure:14066: checking if g++ static flag -static works
-configure:14094: result: yes
-configure:14106: checking if g++ supports -c -o file.o
-configure:14127: g++ -c -g -O3  -o out/conftest2.o conftest.cpp >&5
-configure:14131: $? = 0
-configure:14153: result: yes
-configure:14158: checking if g++ supports -c -o file.o
-configure:14205: result: yes
-configure:14235: checking whether the g++ linker (/usr/bin/ld) supports shared libraries
-configure:14272: result: yes
-configure:14415: checking dynamic linker characteristics
-configure:15098: result: GNU/Linux ld.so
-configure:15151: checking how to hardcode library paths into programs
-configure:15176: result: immediate
-configure:15244: checking for 64-bit OS
-configure:15254: gcc -o conftest -g -O3   conftest.c  >&5
-configure:15254: $? = 0
-configure:15254: ./conftest
-configure:15254: $? = 1
-configure: program exited with status 1
-configure: failed program was:
-| /* confdefs.h */
-| #define PACKAGE_NAME "gdl"
-| #define PACKAGE_TARNAME "gdl"
-| #define PACKAGE_VERSION "0.9.2"
-| #define PACKAGE_STRING "gdl 0.9.2"
-| #define PACKAGE_BUGREPORT ""
-| #define PACKAGE_URL ""
-| #define PACKAGE "gdl"
-| #define VERSION "0.9.2"
-| #define STDC_HEADERS 1
-| #define HAVE_SYS_TYPES_H 1
-| #define HAVE_SYS_STAT_H 1
-| #define HAVE_STDLIB_H 1
-| #define HAVE_STRING_H 1
-| #define HAVE_MEMORY_H 1
-| #define HAVE_STRINGS_H 1
-| #define HAVE_INTTYPES_H 1
-| #define HAVE_STDINT_H 1
-| #define HAVE_UNISTD_H 1
-| #define HAVE_DLFCN_H 1
-| #define LT_OBJDIR ".libs/"
-| /* end confdefs.h.  */
-|  int main () {
-|     if (sizeof(long) == 8) { return 0; } return 1; }
-configure:15263: result: no
-configure:15278: checking for library containing dlopen
-configure:15309: g++ -o conftest -g -O3   conftest.cpp  >&5
-/tmp/ccLUK4pA.o: In function `main':
-/home/marc/release/gdl-0.9.2/conftest.cpp:34: undefined reference to `dlopen'
-collect2: ld returned 1 exit status
-configure:15309: $? = 1
-configure: failed program was:
-| /* confdefs.h */
-| #define PACKAGE_NAME "gdl"
-| #define PACKAGE_TARNAME "gdl"
-| #define PACKAGE_VERSION "0.9.2"
-| #define PACKAGE_STRING "gdl 0.9.2"
-| #define PACKAGE_BUGREPORT ""
-| #define PACKAGE_URL ""
-| #define PACKAGE "gdl"
-| #define VERSION "0.9.2"
-| #define STDC_HEADERS 1
-| #define HAVE_SYS_TYPES_H 1
-| #define HAVE_SYS_STAT_H 1
-| #define HAVE_STDLIB_H 1
-| #define HAVE_STRING_H 1
-| #define HAVE_MEMORY_H 1
-| #define HAVE_STRINGS_H 1
-| #define HAVE_INTTYPES_H 1
-| #define HAVE_STDINT_H 1
-| #define HAVE_UNISTD_H 1
-| #define HAVE_DLFCN_H 1
-| #define LT_OBJDIR ".libs/"
-| /* end confdefs.h.  */
-| 
-| /* Override any GCC internal prototype to avoid an error.
-|    Use char because int might match the return type of a GCC
-|    builtin and then its argument prototype would still apply.  */
-| #ifdef __cplusplus
-| extern "C"
-| #endif
-| char dlopen ();
-| int
-| main ()
-| {
-| return dlopen ();
-|   ;
-|   return 0;
-| }
-configure:15309: g++ -o conftest -g -O3   conftest.cpp -ldl   >&5
-configure:15309: $? = 0
-configure:15326: result: -ldl
-configure:15364: checking for malloc_zone_statistics
-configure:15364: g++ -o conftest -g -O3   conftest.cpp -ldl  -ldl >&5
-/tmp/ccYDUFFY.o: In function `main':
-/home/marc/release/gdl-0.9.2/conftest.cpp:57: undefined reference to `malloc_zone_statistics'
-collect2: ld returned 1 exit status
-configure:15364: $? = 1
-configure: failed program was:
-| /* confdefs.h */
-| #define PACKAGE_NAME "gdl"
-| #define PACKAGE_TARNAME "gdl"
-| #define PACKAGE_VERSION "0.9.2"
-| #define PACKAGE_STRING "gdl 0.9.2"
-| #define PACKAGE_BUGREPORT ""
-| #define PACKAGE_URL ""
-| #define PACKAGE "gdl"
-| #define VERSION "0.9.2"
-| #define STDC_HEADERS 1
-| #define HAVE_SYS_TYPES_H 1
-| #define HAVE_SYS_STAT_H 1
-| #define HAVE_STDLIB_H 1
-| #define HAVE_STRING_H 1
-| #define HAVE_MEMORY_H 1
-| #define HAVE_STRINGS_H 1
-| #define HAVE_INTTYPES_H 1
-| #define HAVE_STDINT_H 1
-| #define HAVE_UNISTD_H 1
-| #define HAVE_DLFCN_H 1
-| #define LT_OBJDIR ".libs/"
-| /* end confdefs.h.  */
-| /* Define malloc_zone_statistics to an innocuous variant, in case <limits.h> declares malloc_zone_statistics.
-|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-| #define malloc_zone_statistics innocuous_malloc_zone_statistics
-| 
-| /* System header to define __stub macros and hopefully few prototypes,
-|     which can conflict with char malloc_zone_statistics (); below.
-|     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-|     <limits.h> exists even on freestanding compilers.  */
-| 
-| #ifdef __STDC__
-| # include <limits.h>
-| #else
-| # include <assert.h>
-| #endif
-| 
-| #undef malloc_zone_statistics
-| 
-| /* Override any GCC internal prototype to avoid an error.
-|    Use char because int might match the return type of a GCC
-|    builtin and then its argument prototype would still apply.  */
-| #ifdef __cplusplus
-| extern "C"
-| #endif
-| char malloc_zone_statistics ();
-| /* The GNU C library defines this for functions which it implements
-|     to always fail with ENOSYS.  Some functions are actually named
-|     something starting with __ and the normal name is an alias.  */
-| #if defined __stub_malloc_zone_statistics || defined __stub___malloc_zone_statistics
-| choke me
-| #endif
-| 
-| int
-| main ()
-| {
-| return malloc_zone_statistics ();
-|   ;
-|   return 0;
-| }
-configure:15364: result: no
-configure:15364: checking for sbrk
-configure:15364: g++ -o conftest -g -O3   conftest.cpp -ldl  -ldl >&5
-configure:15364: $? = 0
-configure:15364: result: yes
-configure:15364: checking for mallinfo
-configure:15364: g++ -o conftest -g -O3   conftest.cpp -ldl  -ldl >&5
-configure:15364: $? = 0
-configure:15364: result: yes
-configure:15377: checking malloc.h usability
-configure:15377: g++ -c -g -O3  conftest.cpp >&5
-configure:15377: $? = 0
-configure:15377: result: yes
-configure:15377: checking malloc.h presence
-configure:15377: g++ -E  conftest.cpp
-configure:15377: $? = 0
-configure:15377: result: yes
-configure:15377: checking for malloc.h
-configure:15377: result: yes
-configure:15377: checking malloc/malloc.h usability
-configure:15377: g++ -c -g -O3  conftest.cpp >&5
-conftest.cpp:59:27: fatal error: malloc/malloc.h: No such file or directory
-compilation terminated.
-configure:15377: $? = 1
-configure: failed program was:
-| /* confdefs.h */
-| #define PACKAGE_NAME "gdl"
-| #define PACKAGE_TARNAME "gdl"
-| #define PACKAGE_VERSION "0.9.2"
-| #define PACKAGE_STRING "gdl 0.9.2"
-| #define PACKAGE_BUGREPORT ""
-| #define PACKAGE_URL ""
-| #define PACKAGE "gdl"
-| #define VERSION "0.9.2"
-| #define STDC_HEADERS 1
-| #define HAVE_SYS_TYPES_H 1
-| #define HAVE_SYS_STAT_H 1
-| #define HAVE_STDLIB_H 1
-| #define HAVE_STRING_H 1
-| #define HAVE_MEMORY_H 1
-| #define HAVE_STRINGS_H 1
-| #define HAVE_INTTYPES_H 1
-| #define HAVE_STDINT_H 1
-| #define HAVE_UNISTD_H 1
-| #define HAVE_DLFCN_H 1
-| #define LT_OBJDIR ".libs/"
-| #define HAVE_SBRK 1
-| #define HAVE_MALLINFO 1
-| #define HAVE_MALLOC_H 1
-| /* end confdefs.h.  */
-| #include <stdio.h>
-| #ifdef HAVE_SYS_TYPES_H
-| # include <sys/types.h>
-| #endif
-| #ifdef HAVE_SYS_STAT_H
-| # include <sys/stat.h>
-| #endif
-| #ifdef STDC_HEADERS
-| # include <stdlib.h>
-| # include <stddef.h>
-| #else
-| # ifdef HAVE_STDLIB_H
-| #  include <stdlib.h>
-| # endif
-| #endif
-| #ifdef HAVE_STRING_H
-| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
-| #  include <memory.h>
-| # endif
-| # include <string.h>
-| #endif
-| #ifdef HAVE_STRINGS_H
-| # include <strings.h>
-| #endif
-| #ifdef HAVE_INTTYPES_H
-| # include <inttypes.h>
-| #endif
-| #ifdef HAVE_STDINT_H
-| # include <stdint.h>
-| #endif
-| #ifdef HAVE_UNISTD_H
-| # include <unistd.h>
-| #endif
-| #include <malloc/malloc.h>
-configure:15377: result: no
-configure:15377: checking malloc/malloc.h presence
-configure:15377: g++ -E  conftest.cpp
-conftest.cpp:26:27: fatal error: malloc/malloc.h: No such file or directory
-compilation terminated.
-configure:15377: $? = 1
-configure: failed program was:
-| /* confdefs.h */
-| #define PACKAGE_NAME "gdl"
-| #define PACKAGE_TARNAME "gdl"
-| #define PACKAGE_VERSION "0.9.2"
-| #define PACKAGE_STRING "gdl 0.9.2"
-| #define PACKAGE_BUGREPORT ""
-| #define PACKAGE_URL ""
-| #define PACKAGE "gdl"
-| #define VERSION "0.9.2"
-| #define STDC_HEADERS 1
-| #define HAVE_SYS_TYPES_H 1
-| #define HAVE_SYS_STAT_H 1
-| #define HAVE_STDLIB_H 1
-| #define HAVE_STRING_H 1
-| #define HAVE_MEMORY_H 1
-| #define HAVE_STRINGS_H 1
-| #define HAVE_INTTYPES_H 1
-| #define HAVE_STDINT_H 1
-| #define HAVE_UNISTD_H 1
-| #define HAVE_DLFCN_H 1
-| #define LT_OBJDIR ".libs/"
-| #define HAVE_SBRK 1
-| #define HAVE_MALLINFO 1
-| #define HAVE_MALLOC_H 1
-| /* end confdefs.h.  */
-| #include <malloc/malloc.h>
-configure:15377: result: no
-configure:15377: checking for malloc/malloc.h
-configure:15377: result: no
-configure:15390: checking locale.h usability
-configure:15390: g++ -c -g -O3  conftest.cpp >&5
-configure:15390: $? = 0
-configure:15390: result: yes
-configure:15390: checking locale.h presence
-configure:15390: g++ -E  conftest.cpp
-configure:15390: $? = 0
-configure:15390: result: yes
-configure:15390: checking for locale.h
-configure:15390: result: yes
-configure:15403: checking for nexttoward
-configure:15403: g++ -o conftest -g -O3   conftest.cpp -ldl  -ldl >&5
-configure:15403: $? = 0
-configure:15403: result: yes
-configure:15415: checking ext/stdio_filebuf.h usability
-configure:15415: g++ -c -g -O3  conftest.cpp >&5
-configure:15415: $? = 0
-configure:15415: result: yes
-configure:15415: checking ext/stdio_filebuf.h presence
-configure:15415: g++ -E  conftest.cpp
-configure:15415: $? = 0
-configure:15415: result: yes
-configure:15415: checking for ext/stdio_filebuf.h
-configure:15415: result: yes
-configure:15436: checking for initscr in -lncurses
-configure:15461: g++ -o conftest -g -O3   conftest.cpp -lncurses  -ldl  -ldl >&5
-configure:15461: $? = 0
-configure:15470: result: yes
-configure:15543: checking for stifle_history in -lreadline
-configure:15568: g++ -o conftest -g -O3   conftest.cpp -lreadline  -lncurses -ldl  -ldl -lreadline >&5
-configure:15568: $? = 0
-configure:15577: result: yes
-configure:15596: checking for rl_get_screen_size in -lreadline
-configure:15621: g++ -o conftest -g -O3   conftest.cpp -lreadline  -lncurses -ldl  -ldl -lreadline >&5
-configure:15621: $? = 0
-configure:15630: result: yes
-configure:15673: checking for gzopen in -lz
-configure:15698: g++ -o conftest -g -O3   conftest.cpp -lz  -lncurses -ldl  -ldl -lreadline -lz >&5
-configure:15698: $? = 0
-configure:15707: result: yes
-configure:15739: checking omp.h usability
-configure:15739: g++ -c -g -O3  conftest.cpp >&5
-configure:15739: $? = 0
-configure:15739: result: yes
-configure:15739: checking omp.h presence
-configure:15739: g++ -E  conftest.cpp
-configure:15739: $? = 0
-configure:15739: result: yes
-configure:15739: checking for omp.h
-configure:15739: result: yes
-configure:15797: checking for gsl_ran_binomial_knuth in -lgsl
-configure:15822: g++ -o conftest -g -O3  -fopenmp  -fopenmp conftest.cpp -lgsl  -lncurses -ldl  -ldl -lreadline -lz -lgsl -lgslcblas >&5
-configure:15822: $? = 0
-configure:15831: result: yes
-configure:15850: checking for cblas_drot in -lgslcblas
-configure:15875: g++ -o conftest -g -O3  -fopenmp  -fopenmp conftest.cpp -lgslcblas  -lgsl -lncurses -ldl  -ldl -lreadline -lz -lgsl -lgslcblas >&5
-configure:15875: $? = 0
-configure:15884: result: yes
-configure:15942: checking for plsexit in -lplplotcxxd
-configure:15967: g++ -o conftest -g -O3  -fopenmp  -fopenmp conftest.cpp -lplplotcxxd  -lgslcblas -lgsl -lncurses -ldl  -ldl -lreadline -lz -lgsl -lgslcblas -lplplotd -lplplotcxxd >&5
-configure:15967: $? = 0
-configure:15976: result: yes
-configure:15996: checking for plGetDrvDir in -lplplotd
-configure:16021: g++ -o conftest -g -O3  -fopenmp  -fopenmp conftest.cpp -lplplotd  -lgslcblas -lgsl -lncurses -ldl  -ldl -lreadline -lz -lgsl -lgslcblas -lplplotd -lplplotcxxd >&5
-configure:16021: $? = 0
-configure:16030: result: yes
-configure:16060: checking for wx-config
-configure:16091: result: no
-
-## ---------------- ##
-## Cache variables. ##
-## ---------------- ##
-
-ac_cv_build=i686-pc-linux-gnu
-ac_cv_c_compiler_gnu=yes
-ac_cv_cxx_compiler_gnu=yes
-ac_cv_env_CCC_set=
-ac_cv_env_CCC_value=
-ac_cv_env_CC_set=
-ac_cv_env_CC_value=
-ac_cv_env_CFLAGS_set=
-ac_cv_env_CFLAGS_value=
-ac_cv_env_CPPFLAGS_set=
-ac_cv_env_CPPFLAGS_value=
-ac_cv_env_CPP_set=
-ac_cv_env_CPP_value=
-ac_cv_env_CXXCPP_set=
-ac_cv_env_CXXCPP_value=
-ac_cv_env_CXXFLAGS_set=
-ac_cv_env_CXXFLAGS_value=
-ac_cv_env_CXX_set=
-ac_cv_env_CXX_value=
-ac_cv_env_LDFLAGS_set=
-ac_cv_env_LDFLAGS_value=
-ac_cv_env_LIBS_set=
-ac_cv_env_LIBS_value=
-ac_cv_env_XMKMF_set=
-ac_cv_env_XMKMF_value=
-ac_cv_env_build_alias_set=
-ac_cv_env_build_alias_value=
-ac_cv_env_host_alias_set=
-ac_cv_env_host_alias_value=
-ac_cv_env_target_alias_set=
-ac_cv_env_target_alias_value=
-ac_cv_func_mallinfo=yes
-ac_cv_func_malloc_zone_statistics=no
-ac_cv_func_nexttoward=yes
-ac_cv_func_sbrk=yes
-ac_cv_header_dlfcn_h=yes
-ac_cv_header_ext_stdio_filebuf_h=yes
-ac_cv_header_inttypes_h=yes
-ac_cv_header_locale_h=yes
-ac_cv_header_malloc_h=yes
-ac_cv_header_malloc_malloc_h=no
-ac_cv_header_memory_h=yes
-ac_cv_header_omp_h=yes
-ac_cv_header_stdc=yes
-ac_cv_header_stdint_h=yes
-ac_cv_header_stdlib_h=yes
-ac_cv_header_string_h=yes
-ac_cv_header_strings_h=yes
-ac_cv_header_sys_stat_h=yes
-ac_cv_header_sys_types_h=yes
-ac_cv_header_unistd_h=yes
-ac_cv_host=i686-pc-linux-gnu
-ac_cv_lib_gsl_gsl_ran_binomial_knuth=yes
-ac_cv_lib_gslcblas_cblas_drot=yes
-ac_cv_lib_ncurses_initscr=yes
-ac_cv_lib_plplotcxxd_plsexit=yes
-ac_cv_lib_plplotd_plGetDrvDir=yes
-ac_cv_lib_readline_rl_get_screen_size=yes
-ac_cv_lib_readline_stifle_history=yes
-ac_cv_lib_z_gzopen=yes
-ac_cv_objext=o
-ac_cv_path_EGREP='/bin/grep -E'
-ac_cv_path_FGREP='/bin/grep -F'
-ac_cv_path_GREP=/bin/grep
-ac_cv_path_SED=/bin/sed
-ac_cv_path_install='/usr/bin/install -c'
-ac_cv_path_mkdir=/bin/mkdir
-ac_cv_path_wxConfig=no
-ac_cv_prog_AWK=mawk
-ac_cv_prog_CPP='gcc -E'
-ac_cv_prog_CXXCPP='g++ -E'
-ac_cv_prog_ac_ct_AR=ar
-ac_cv_prog_ac_ct_CC=gcc
-ac_cv_prog_ac_ct_CXX=g++
-ac_cv_prog_ac_ct_MANIFEST_TOOL=mt
-ac_cv_prog_ac_ct_OBJDUMP=objdump
-ac_cv_prog_ac_ct_RANLIB=ranlib
-ac_cv_prog_ac_ct_STRIP=strip
-ac_cv_prog_cc_c89=
-ac_cv_prog_cc_g=yes
-ac_cv_prog_cxx_g=yes
-ac_cv_prog_make_make_set=yes
-ac_cv_search_dlopen=-ldl
-am_cv_CC_dependencies_compiler_type=gcc3
-am_cv_CXX_dependencies_compiler_type=gcc3
-lt_cv_ar_at_file=@
-lt_cv_archive_cmds_need_lc=no
-lt_cv_deplibs_check_method=pass_all
-lt_cv_file_magic_cmd='$MAGIC_CMD'
-lt_cv_file_magic_test_file=
-lt_cv_ld_reload_flag=-r
-lt_cv_nm_interface='BSD nm'
-lt_cv_objdir=.libs
-lt_cv_path_LD=/usr/bin/ld
-lt_cv_path_LDCXX=/usr/bin/ld
-lt_cv_path_NM='/usr/bin/nm -B'
-lt_cv_path_mainfest_tool=no
-lt_cv_prog_compiler_c_o=yes
-lt_cv_prog_compiler_c_o_CXX=yes
-lt_cv_prog_compiler_pic='-fPIC -DPIC'
-lt_cv_prog_compiler_pic_CXX='-fPIC -DPIC'
-lt_cv_prog_compiler_pic_works=yes
-lt_cv_prog_compiler_pic_works_CXX=yes
-lt_cv_prog_compiler_rtti_exceptions=no
-lt_cv_prog_compiler_static_works=yes
-lt_cv_prog_compiler_static_works_CXX=yes
-lt_cv_prog_gnu_ld=yes
-lt_cv_prog_gnu_ldcxx=yes
-lt_cv_sharedlib_from_linklib_cmd='printf %s\n'
-lt_cv_shlibpath_overrides_runpath=no
-lt_cv_sys_global_symbol_pipe='sed -n -e '\''s/^.*[	 ]\([ABCDGIRSTW][ABCDGIRSTW]*\)[	 ][	 ]*\([_A-Za-z][_A-Za-z0-9]*\)$/\1 \2 \2/p'\'' | sed '\''/ __gnu_lto/d'\'''
-lt_cv_sys_global_symbol_to_c_name_address='sed -n -e '\''s/^: \([^ ]*\)[ ]*$/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \([^ ]*\)$/  {"\2", (void *) \&\2},/p'\'''
-lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='sed -n -e '\''s/^: \([^ ]*\)[ ]*$/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \(lib[^ ]*\)$/  {"\2", (void *) \&\2},/p'\'' -e '\''s/^[ABCDGIRSTW]* \([^ ]*\) \([^ ]*\)$/  {"lib\2", (void *) \&\2},/p'\'''
-lt_cv_sys_global_symbol_to_cdecl='sed -n -e '\''s/^T .* \(.*\)$/extern int \1();/p'\'' -e '\''s/^[ABCDGIRSTW]* .* \(.*\)$/extern char \1;/p'\'''
-lt_cv_sys_max_cmd_len=1572864
-lt_cv_to_host_file_cmd=func_convert_file_noop
-lt_cv_to_tool_file_cmd=func_convert_file_noop
-
-## ----------------- ##
-## Output variables. ##
-## ----------------- ##
-
-ACLOCAL='${SHELL} /home/marc/release/gdl-0.9.2/missing --run aclocal-1.11'
-AMDEPBACKSLASH='\'
-AMDEP_FALSE='#'
-AMDEP_TRUE=''
-AMTAR='${SHELL} /home/marc/release/gdl-0.9.2/missing --run tar'
-AR='ar'
-AUTOCONF='${SHELL} /home/marc/release/gdl-0.9.2/missing --run autoconf'
-AUTOHEADER='${SHELL} /home/marc/release/gdl-0.9.2/missing --run autoheader'
-AUTOMAKE='${SHELL} /home/marc/release/gdl-0.9.2/missing --run automake-1.11'
-AWK='mawk'
-BUILDASLIBRARY_FALSE=''
-BUILDASLIBRARY_TRUE='#'
-CC='gcc'
-CCDEPMODE='depmode=gcc3'
-CFLAGS='-g -O3'
-CPP='gcc -E'
-CPPFLAGS=' -fopenmp'
-CXX='g++'
-CXXCPP='g++ -E'
-CXXDEPMODE='depmode=gcc3'
-CXXFLAGS='-g -O3'
-CYGPATH_W='echo'
-DARWIN_FALSE=''
-DARWIN_TRUE=''
-DEFS=''
-DEPDIR='.deps'
-DLLTOOL='false'
-DSYMUTIL=''
-DUMPBIN=''
-ECHO_C=''
-ECHO_N='-n'
-ECHO_T=''
-EGREP='/bin/grep -E'
-EXEC_PREFIX=''
-EXEEXT=''
-EXT_INCLUDES=''
-EXT_LIBS=''
-FGREP='/bin/grep -F'
-GDLDATADIR=''
-GREP='/bin/grep'
-HAVE_64BIT_OS=''
-INSTALL_DATA='${INSTALL} -m 644'
-INSTALL_PROGRAM='${INSTALL}'
-INSTALL_SCRIPT='${INSTALL}'
-INSTALL_STRIP_PROGRAM='$(install_sh) -c -s'
-LD='/usr/bin/ld'
-LDFLAGS=' -fopenmp'
-LIBOBJS=''
-LIBS='-lgslcblas -lgsl -lncurses -ldl  -ldl -lreadline -lz -lgsl -lgslcblas -lplplotd -lplplotcxxd'
-LIBTOOL='$(SHELL) $(top_builddir)/libtool'
-LIPO=''
-LN_S='ln -s'
-LTLIBOBJS=''
-MAKEINFO='${SHELL} /home/marc/release/gdl-0.9.2/missing --run makeinfo'
-MANIFEST_TOOL=':'
-MKDIR_P='/bin/mkdir -p'
-MagickConfig=''
-NM='/usr/bin/nm -B'
-NMEDIT=''
-OBJDUMP='objdump'
-OBJEXT='o'
-OTOOL64=''
-OTOOL=''
-PACKAGE='gdl'
-PACKAGE_BUGREPORT=''
-PACKAGE_NAME='gdl'
-PACKAGE_STRING='gdl 0.9.2'
-PACKAGE_TARNAME='gdl'
-PACKAGE_URL=''
-PACKAGE_VERSION='0.9.2'
-PATH_SEPARATOR=':'
-PYTHON=''
-PYTHON_EXEC_PREFIX=''
-PYTHON_PLATFORM=''
-PYTHON_PREFIX=''
-PYTHON_VERSION=''
-RANLIB='ranlib'
-SED='/bin/sed'
-SET_MAKE=''
-SHELL='/bin/bash'
-STRIP='strip'
-VERSION='0.9.2'
-XMKMF=''
-ac_ct_AR='ar'
-ac_ct_CC='gcc'
-ac_ct_CXX='g++'
-ac_ct_DUMPBIN=''
-am__EXEEXT_FALSE=''
-am__EXEEXT_TRUE=''
-am__fastdepCC_FALSE='#'
-am__fastdepCC_TRUE=''
-am__fastdepCXX_FALSE='#'
-am__fastdepCXX_TRUE=''
-am__include='include'
-am__isrc=''
-am__leading_dot='.'
-am__quote=''
-am__tar='${AMTAR} chof - "$$tardir"'
-am__untar='${AMTAR} xf -'
-bindir='${exec_prefix}/bin'
-build='i686-pc-linux-gnu'
-build_alias=''
-build_cpu='i686'
-build_os='linux-gnu'
-build_vendor='pc'
-datadir='${datarootdir}'
-datarootdir='${prefix}/share'
-docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
-dvidir='${docdir}'
-exec_prefix='NONE'
-host='i686-pc-linux-gnu'
-host_alias=''
-host_cpu='i686'
-host_os='linux-gnu'
-host_vendor='pc'
-htmldir='${docdir}'
-includedir='${prefix}/include'
-infodir='${datarootdir}/info'
-install_sh='${SHELL} /home/marc/release/gdl-0.9.2/install-sh'
-libdir='${exec_prefix}/lib'
-libexecdir='${exec_prefix}/libexec'
-localedir='${datarootdir}/locale'
-localstatedir='${prefix}/var'
-mandir='${datarootdir}/man'
-mkdir_p='/bin/mkdir -p'
-nc_config=''
-oldincludedir='/usr/include'
-pdfdir='${docdir}'
-pkgpyexecdir=''
-pkgpythondir=''
-prefix='NONE'
-program_transform_name='s,x,x,'
-psdir='${docdir}'
-pyexecdir=''
-pythondir=''
-sbindir='${exec_prefix}/sbin'
-sharedstatedir='${prefix}/com'
-sysconfdir='${prefix}/etc'
-target_alias=''
-wxConfig='no'
-
-## ----------- ##
-## confdefs.h. ##
-## ----------- ##
-
-/* confdefs.h */
-#define PACKAGE_NAME "gdl"
-#define PACKAGE_TARNAME "gdl"
-#define PACKAGE_VERSION "0.9.2"
-#define PACKAGE_STRING "gdl 0.9.2"
-#define PACKAGE_BUGREPORT ""
-#define PACKAGE_URL ""
-#define PACKAGE "gdl"
-#define VERSION "0.9.2"
-#define STDC_HEADERS 1
-#define HAVE_SYS_TYPES_H 1
-#define HAVE_SYS_STAT_H 1
-#define HAVE_STDLIB_H 1
-#define HAVE_STRING_H 1
-#define HAVE_MEMORY_H 1
-#define HAVE_STRINGS_H 1
-#define HAVE_INTTYPES_H 1
-#define HAVE_STDINT_H 1
-#define HAVE_UNISTD_H 1
-#define HAVE_DLFCN_H 1
-#define LT_OBJDIR ".libs/"
-#define HAVE_SBRK 1
-#define HAVE_MALLINFO 1
-#define HAVE_MALLOC_H 1
-#define HAVE_LOCALE_H 1
-#define HAVE_NEXTTOWARD 1
-#define HAVE_EXT_STDIO_FILEBUF_H 1
-#define HAVE_LIBNCURSES 1
-#define HAVE_LIBREADLINE 1
-#define RL_GET_SCREEN_SIZE 1
-#define HAVE_LIBZ 1
-#define HAVE_OMP_H 1
-#define HAVE_LIBGSL 1
-#define HAVE_LIBGSLCBLAS 1
-#define HAVE_LIBPLPLOTCXXD 1
-
-configure: exit 255
diff -ruN --exclude CVS gdl-0.9.2/configure gdl/configure
--- gdl-0.9.2/configure	2011-11-08 17:27:35.000000000 -0700
+++ gdl/configure	2012-06-28 03:54:53.000000000 -0600
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.68 for gdl 0.9.2.
+# Generated by GNU Autoconf 2.68 for gdl 0.9.2 CVS.
 #
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
@@ -567,8 +567,8 @@
 # Identity of this package.
 PACKAGE_NAME='gdl'
 PACKAGE_TARNAME='gdl'
-PACKAGE_VERSION='0.9.2'
-PACKAGE_STRING='gdl 0.9.2'
+PACKAGE_VERSION='0.9.2 CVS'
+PACKAGE_STRING='gdl 0.9.2 CVS'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
@@ -628,6 +628,7 @@
 PYTHON_VERSION
 PYTHON
 nc_config
+GraphicsMagickConfig
 XMKMF
 MagickConfig
 wxConfig
@@ -770,6 +771,7 @@
 with_wxWidgets
 with_Magick
 with_x
+with_GraphicsMagick
 with_netcdf
 with_hdf
 with_hdf5
@@ -1339,7 +1341,7 @@
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures gdl 0.9.2 to adapt to many kinds of systems.
+\`configure' configures gdl 0.9.2 CVS to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1413,7 +1415,7 @@
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of gdl 0.9.2:";;
+     short | recursive ) echo "Configuration of gdl 0.9.2 CVS:";;
    esac
   cat <<\_ACEOF
 
@@ -1449,6 +1451,7 @@
   --with-wxWidgets=DIR    use wxWidgets (with optional path DIR)
   --with-Magick=DIR       use ImageMagick package (with optional path DIR)
   --with-x                use the X Window System
+  --with-GraphicsMagick=DIR  use GraphicsMagick package (with optional path DIR)
   --with-netcdf=DIR       use netCDF package (with optional path DIR)
   --with-hdf=DIR          use HDF package (with optional path DIR)
   --with-hdf5=DIR         use HDF5 package (with optional path DIR)
@@ -1541,7 +1544,7 @@
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-gdl configure 0.9.2
+gdl configure 0.9.2 CVS
 generated by GNU Autoconf 2.68
 
 Copyright (C) 2010 Free Software Foundation, Inc.
@@ -2125,7 +2128,7 @@
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by gdl $as_me 0.9.2, which was
+It was created by gdl $as_me 0.9.2 CVS, which was
 generated by GNU Autoconf 2.68.  Invocation command line was
 
   $ $0 $@
@@ -2483,6 +2486,7 @@
 if test "x$with_udunits"     = "x"; then with_udunits=no;      fi
 if test "x$with_grib"        = "x"; then with_grib=no;         fi
 if test "x$with_Magick"      = "x"; then with_Magick=yes;      fi
+if test "x$with_GraphicsMagick" = "x"; then with_GraphicsMagick=no;      fi
 if test "x$with_netcdf"      = "x"; then with_netcdf=yes;      fi
 if test "x$with_hdf"         = "x"; then with_hdf=yes;         fi
 if test "x$with_hdf5"        = "x"; then with_hdf5=yes;        fi
@@ -2971,7 +2975,7 @@
 
 # Define the identity of the package.
  PACKAGE='gdl'
- VERSION='0.9.2'
+ VERSION='0.9.2 CVS'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -3509,13 +3513,13 @@
   CXXFLAGS=$ac_save_CXXFLAGS
 elif test $ac_cv_prog_cxx_g = yes; then
   if test "$GXX" = yes; then
-    CXXFLAGS="-g -O3"
+    CXXFLAGS="-g -O2"
   else
     CXXFLAGS="-g"
   fi
 else
   if test "$GXX" = yes; then
-    CXXFLAGS="-O3"
+    CXXFLAGS="-O2"
   else
     CXXFLAGS=
   fi
@@ -4404,13 +4408,13 @@
   CFLAGS=$ac_save_CFLAGS
 elif test $ac_cv_prog_cc_g = yes; then
   if test "$GCC" = yes; then
-    CFLAGS="-g -O3"
+    CFLAGS="-g -O2"
   else
     CFLAGS="-g"
   fi
 else
   if test "$GCC" = yes; then
-    CFLAGS="-O3"
+    CFLAGS="-O2"
   else
     CFLAGS=
   fi
@@ -15588,6 +15592,7 @@
 	echo "       Check the README or use configure --help for other libraries needed"
         echo ""
         echo "       (suitable Debian/Ubuntu package: libreadline5-dev)"
+        echo "       (suitable Fedora package: readline-devel)"
 	exit -1
 
 fi
@@ -15717,6 +15722,7 @@
  	echo "       Use --with-zlibdir=DIR to specify the zlib directory tree"
         echo ""
         echo "       (suitable Debian/Ubuntu package: zlib1g-dev)"
+        echo "       (suitable Fedora package: zlib-devel)"
  	exit -1
 
 fi
@@ -15843,6 +15849,7 @@
 	echo "Error! Gnu Scientific Library (1.7 or higher) is mandatory"
         echo ""
         echo "       (suitable Debian/Ubuntu package: libgsl0-dev)"
+        echo "       (suitable Fedora package: gsl-dev)"
         exit -1
 
 fi
@@ -15986,6 +15993,7 @@
 	echo "       Use --with-plplot=DIR to specify the plplot directory tree"
         echo ""
         echo "       (suitable Debian/Ubuntu packages: libplplot-dev, plplot9-driver-xwin)"
+        echo "       (suitable Fedora package: plplot-devel)"
 	exit -1
 
 fi
@@ -16149,6 +16157,7 @@
     echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
     echo ""
     echo "       (suitable Debian/Ubuntu package: libwxgtk2.8-dev)"
+    echo "       (suitable Fedora package: wxGTK-devel)"
     exit -1
   else
     LIBS="$LIBS `wx-config --libs`"
@@ -16279,6 +16288,7 @@
       Use --with-Magick=no  to not use it
 
       (suitable Debian/Ubuntu package: libmagick++-dev)
+      (suitable Fedora package: ImageMagick-c++-devel)
     " "$LINENO" 5
   else
     LIBS="$LIBS `$MagickConfig --libs`"
@@ -16574,7 +16584,416 @@
         echo "       Check the README or use configure --help for other libraries needed"
         echo "       (--with-xxxdir = mandatory, --with-xxx = optional (--with-xxx=no to disable))"
         echo ""
-        echo "       (suitable Debian/Ubuntu package: libmagick-dev)"
+        echo "       (suitable Debian/Ubuntu package: libmagick++-dev)"
+        echo "       (suitable Fedora package: ImageMagick-c++-devel)"
+        exit -1
+
+fi
+
+
+
+fi
+
+fi
+
+
+# Check whether --with-GraphicsMagick was given.
+if test "${with_GraphicsMagick+set}" = set; then :
+  withval=$with_GraphicsMagick; with_GraphicsMagick="$withval"
+fi
+
+
+if test "x$with_GraphicsMagick" != "xno"; then
+  if test "x$with_GraphicsMagick" = "xyes"; then
+    # Extract the first word of "GraphicsMagick++-config", so it can be a program name with args.
+set dummy GraphicsMagick++-config; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_GraphicsMagickConfig+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $GraphicsMagickConfig in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_GraphicsMagickConfig="$GraphicsMagickConfig" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_GraphicsMagickConfig="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_GraphicsMagickConfig" && ac_cv_path_GraphicsMagickConfig="no"
+  ;;
+esac
+fi
+GraphicsMagickConfig=$ac_cv_path_GraphicsMagickConfig
+if test -n "$GraphicsMagickConfig"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $GraphicsMagickConfig" >&5
+$as_echo "$GraphicsMagickConfig" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  else
+    # Extract the first word of "GraphicsMagick++-config", so it can be a program name with args.
+set dummy GraphicsMagick++-config; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_path_GraphicsMagickConfig+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $GraphicsMagickConfig in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_GraphicsMagickConfig="$GraphicsMagickConfig" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in "$with_GraphicsMagick/bin"
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_path_GraphicsMagickConfig="$as_dir/$ac_word$ac_exec_ext"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_path_GraphicsMagickConfig" && ac_cv_path_GraphicsMagickConfig="no"
+  ;;
+esac
+fi
+GraphicsMagickConfig=$ac_cv_path_GraphicsMagickConfig
+if test -n "$GraphicsMagickConfig"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $GraphicsMagickConfig" >&5
+$as_echo "$GraphicsMagickConfig" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+
+  if test "x$GraphicsMagickConfig" = "xno"; then
+    as_fn_error $? "GraphicsMagick is required but was not found (GraphicsMagick++-config program not found)
+      Use --with-GraphicsMagick=DIR to specify the GraphicsMagick directory tree
+      Use --with-GraphicsMagick=no  to not use it
+
+      (suitable Debian/Ubuntu package: libmagick++-dev)
+      (suitable Fedora package: GraphicsMagick-c++-devel)
+    " "$LINENO" 5
+  else
+    LIBS="$LIBS `$GraphicsMagickConfig --libs`"
+    INCLUDES="$INCLUDES `$GraphicsMagickConfig --cppflags`"
+    LDFLAGS="$LDFLAGS `$GraphicsMagickConfig --ldflags`"
+  fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GetMagickVersion in -lGraphicsMagick++" >&5
+$as_echo_n "checking for GetMagickVersion in -lGraphicsMagick++... " >&6; }
+if ${ac_cv_lib_GraphicsMagickpp_GetMagickVersion+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lGraphicsMagick++  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char GetMagickVersion ();
+int
+main ()
+{
+return GetMagickVersion ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_GraphicsMagickpp_GetMagickVersion=yes
+else
+  ac_cv_lib_GraphicsMagickpp_GetMagickVersion=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_GraphicsMagickpp_GetMagickVersion" >&5
+$as_echo "$ac_cv_lib_GraphicsMagickpp_GetMagickVersion" >&6; }
+if test "x$ac_cv_lib_GraphicsMagickpp_GetMagickVersion" = xyes; then :
+
+$as_echo "#define USE_MAGICK 1" >>confdefs.h
+
+else
+
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking if adding X library path helps" >&5
+$as_echo_n "checking if adding X library path helps... " >&6; }
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: ?" >&5
+$as_echo "?" >&6; }
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for X" >&5
+$as_echo_n "checking for X... " >&6; }
+
+
+# Check whether --with-x was given.
+if test "${with_x+set}" = set; then :
+  withval=$with_x;
+fi
+
+# $have_x is `yes', `no', `disabled', or empty when we do not yet know.
+if test "x$with_x" = xno; then
+  # The user explicitly disabled X.
+  have_x=disabled
+else
+  case $x_includes,$x_libraries in #(
+    *\'*) as_fn_error $? "cannot use X directory names containing '" "$LINENO" 5;; #(
+    *,NONE | NONE,*) if ${ac_cv_have_x+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  # One or both of the vars are not set, and there is no cached value.
+ac_x_includes=no ac_x_libraries=no
+rm -f -r conftest.dir
+if mkdir conftest.dir; then
+  cd conftest.dir
+  cat >Imakefile <<'_ACEOF'
+incroot:
+	@echo incroot='${INCROOT}'
+usrlibdir:
+	@echo usrlibdir='${USRLIBDIR}'
+libdir:
+	@echo libdir='${LIBDIR}'
+_ACEOF
+  if (export CC; ${XMKMF-xmkmf}) >/dev/null 2>/dev/null && test -f Makefile; then
+    # GNU make sometimes prints "make[1]: Entering ...", which would confuse us.
+    for ac_var in incroot usrlibdir libdir; do
+      eval "ac_im_$ac_var=\`\${MAKE-make} $ac_var 2>/dev/null | sed -n 's/^$ac_var=//p'\`"
+    done
+    # Open Windows xmkmf reportedly sets LIBDIR instead of USRLIBDIR.
+    for ac_extension in a so sl dylib la dll; do
+      if test ! -f "$ac_im_usrlibdir/libX11.$ac_extension" &&
+	 test -f "$ac_im_libdir/libX11.$ac_extension"; then
+	ac_im_usrlibdir=$ac_im_libdir; break
+      fi
+    done
+    # Screen out bogus values from the imake configuration.  They are
+    # bogus both because they are the default anyway, and because
+    # using them would break gcc on systems where it needs fixed includes.
+    case $ac_im_incroot in
+	/usr/include) ac_x_includes= ;;
+	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes=$ac_im_incroot;;
+    esac
+    case $ac_im_usrlibdir in
+	/usr/lib | /usr/lib64 | /lib | /lib64) ;;
+	*) test -d "$ac_im_usrlibdir" && ac_x_libraries=$ac_im_usrlibdir ;;
+    esac
+  fi
+  cd ..
+  rm -f -r conftest.dir
+fi
+
+# Standard set of common directories for X headers.
+# Check X11 before X11Rn because it is often a symlink to the current release.
+ac_x_header_dirs='
+/usr/X11/include
+/usr/X11R7/include
+/usr/X11R6/include
+/usr/X11R5/include
+/usr/X11R4/include
+
+/usr/include/X11
+/usr/include/X11R7
+/usr/include/X11R6
+/usr/include/X11R5
+/usr/include/X11R4
+
+/usr/local/X11/include
+/usr/local/X11R7/include
+/usr/local/X11R6/include
+/usr/local/X11R5/include
+/usr/local/X11R4/include
+
+/usr/local/include/X11
+/usr/local/include/X11R7
+/usr/local/include/X11R6
+/usr/local/include/X11R5
+/usr/local/include/X11R4
+
+/usr/X386/include
+/usr/x386/include
+/usr/XFree86/include/X11
+
+/usr/include
+/usr/local/include
+/usr/unsupported/include
+/usr/athena/include
+/usr/local/x11r5/include
+/usr/lpp/Xamples/include
+
+/usr/openwin/include
+/usr/openwin/share/include'
+
+if test "$ac_x_includes" = no; then
+  # Guess where to find include files, by looking for Xlib.h.
+  # First, try using that file with no special directory specified.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+_ACEOF
+if ac_fn_cxx_try_cpp "$LINENO"; then :
+  # We can compile using X headers with no special include directory.
+ac_x_includes=
+else
+  for ac_dir in $ac_x_header_dirs; do
+  if test -r "$ac_dir/X11/Xlib.h"; then
+    ac_x_includes=$ac_dir
+    break
+  fi
+done
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+fi # $ac_x_includes = no
+
+if test "$ac_x_libraries" = no; then
+  # Check for the libraries.
+  # See if we find them without any special options.
+  # Don't add to $LIBS permanently.
+  ac_save_LIBS=$LIBS
+  LIBS="-lX11 $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <X11/Xlib.h>
+int
+main ()
+{
+XrmInitialize ()
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  LIBS=$ac_save_LIBS
+# We can link X programs with no special library path.
+ac_x_libraries=
+else
+  LIBS=$ac_save_LIBS
+for ac_dir in `$as_echo "$ac_x_includes $ac_x_header_dirs" | sed s/include/lib/g`
+do
+  # Don't even attempt the hair of trying to link an X program!
+  for ac_extension in a so sl dylib la dll; do
+    if test -r "$ac_dir/libX11.$ac_extension"; then
+      ac_x_libraries=$ac_dir
+      break 2
+    fi
+  done
+done
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi # $ac_x_libraries = no
+
+case $ac_x_includes,$ac_x_libraries in #(
+  no,* | *,no | *\'*)
+    # Didn't find X, or a directory has "'" in its name.
+    ac_cv_have_x="have_x=no";; #(
+  *)
+    # Record where we found X for the cache.
+    ac_cv_have_x="have_x=yes\
+	ac_x_includes='$ac_x_includes'\
+	ac_x_libraries='$ac_x_libraries'"
+esac
+fi
+;; #(
+    *) have_x=yes;;
+  esac
+  eval "$ac_cv_have_x"
+fi # $with_x != no
+
+if test "$have_x" != yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $have_x" >&5
+$as_echo "$have_x" >&6; }
+  no_x=yes
+else
+  # If each of the values was on the command line, it overrides each guess.
+  test "x$x_includes" = xNONE && x_includes=$ac_x_includes
+  test "x$x_libraries" = xNONE && x_libraries=$ac_x_libraries
+  # Update the cache value to reflect the command line values.
+  ac_cv_have_x="have_x=yes\
+	ac_x_includes='$x_includes'\
+	ac_x_libraries='$x_libraries'"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: libraries $x_libraries, headers $x_includes" >&5
+$as_echo "libraries $x_libraries, headers $x_includes" >&6; }
+fi
+
+      LDFLAGS="$LDFLAGS -L$x_libraries"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GetMagickReleaseDate in -lGraphicsMagick++" >&5
+$as_echo_n "checking for GetMagickReleaseDate in -lGraphicsMagick++... " >&6; }
+if ${ac_cv_lib_GraphicsMagickpp_GetMagickReleaseDate+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lGraphicsMagick++  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char GetMagickReleaseDate ();
+int
+main ()
+{
+return GetMagickReleaseDate ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_cxx_try_link "$LINENO"; then :
+  ac_cv_lib_GraphicsMagickpp_GetMagickReleaseDate=yes
+else
+  ac_cv_lib_GraphicsMagickpp_GetMagickReleaseDate=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_GraphicsMagickpp_GetMagickReleaseDate" >&5
+$as_echo "$ac_cv_lib_GraphicsMagickpp_GetMagickReleaseDate" >&6; }
+if test "x$ac_cv_lib_GraphicsMagickpp_GetMagickReleaseDate" = xyes; then :
+  $as_echo "#define USE_MAGICK 1" >>confdefs.h
+
+else
+
+        echo ""
+        echo "Error! GraphicsMagick version 1.3 or later is required but was not found"
+        echo "       Use --with-GraphicsMagick=DIR to specify the GraphicsMagick directory tree"
+        echo "       Use --with-GraphicsMagick=no  to not use it"
+        echo "       Check the README or use configure --help for other libraries needed"
+        echo "       (--with-xxxdir = mandatory, --with-xxx = optional (--with-xxx=no to disable))"
+        echo ""
+        echo "       (suitable Debian/Ubuntu package: libgraphicsmagick++-dev)"
+        echo "       (suitable Fedora package: graphicsMagick-c++-devel)"
         exit -1
 
 fi
@@ -16746,6 +17165,7 @@
     echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
     echo ""
     echo "       (suitable Debian/Ubuntu package: libnetcdf-dev)"
+    echo "       (suitable Fedora package: netcdf-devel)"
     exit -1
 
 fi
@@ -17168,6 +17588,7 @@
     echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
     echo ""
     echo "       (suitable Debian/Ubuntu package: libhdf5-serial-dev)"
+    echo "       (suitable Fedora package: hdf-devel)"
     exit -1
 
 fi
@@ -17331,6 +17752,7 @@
     echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
     echo ""
     echo "       (suitable Debian/Ubuntu package: libfftw3-dev)"
+    echo "       (suitable Fedora package: fftw-devel)"
     exit -1
 
 fi
@@ -17893,6 +18315,7 @@
     echo "       Use --with-python=no  to not use it"
     echo ""
     echo "       (suitable Debian/Ubuntu package: python$PYTHON_VERSION-dev)"
+    echo "       (suitable Fedora package: python-devel)"
     exit -1
 
 fi
@@ -18009,6 +18432,7 @@
     echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
     echo ""
     echo "       (suitable Debian/Ubuntu package: libudunits2-dev)"
+    echo "       (suitable Fedora package: udunits2-devel)"
     exit -1
 
 fi
@@ -18240,6 +18664,7 @@
             echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
             echo ""
             echo "       (suitable Debian/Ubuntu package: libgrib-api-dev)"
+            echo "       (suitable Fedora package: grib_api-devel)"
             exit -1
 
 fi
@@ -18571,6 +18996,7 @@
     echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
     echo ""
     echo "       (suitable Debian/Ubuntu package: pslib-dev)"
+    echo "       (suitable Fedora package: pslib-devel)"
     exit -1
 
 fi
@@ -19275,7 +19701,7 @@
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by gdl $as_me 0.9.2, which was
+This file was extended by gdl $as_me 0.9.2 CVS, which was
 generated by GNU Autoconf 2.68.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -19341,7 +19767,7 @@
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-gdl config.status 0.9.2
+gdl config.status 0.9.2 CVS
 configured by $0, generated by GNU Autoconf 2.68,
   with options \\"\$ac_cs_config\\"
 
@@ -21404,6 +21830,8 @@
     then echo 'no'; else echo yes; fi`
   Magick:              `if test no = $with_Magick;
     then echo 'no'; else echo yes; fi`
+  GraphicsMagick:      `if test no = $with_GraphicsMagick;
+    then echo 'no'; else echo yes; fi`
   NetCDF:              `if test no = $with_netcdf;
     then echo 'no'; else echo yes; fi`
   HDF4:                `if test no = $with_hdf;
@@ -21442,4 +21870,13 @@
   use 'make' to build and 'make install' to install GDL
   (optional 'make check' tests the build - experimental)
 "
+echo "
+*********************** WARNING ******************************
+We plan to drop support for Autotools-based configuration
+(i.e. the configure script) and switch to CMake. If possible,
+please try to compile GDL with CMake (e.g. by typing \"cmake .\"
+instead of \"./configure\") and please do report any problems.
+Consult INSTALL.CMake for help on passing options to CMake.
+**************************************************************
+"
 
diff -ruN --exclude CVS gdl-0.9.2/configure~ gdl/configure~
--- gdl-0.9.2/configure~	2011-11-08 17:26:43.000000000 -0700
+++ gdl/configure~	1969-12-31 17:00:00.000000000 -0700
@@ -1,21445 +0,0 @@
-#! /bin/sh
-# Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.68 for gdl 0.9.2.
-#
-#
-# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
-# Foundation, Inc.
-#
-#
-# This configure script is free software; the Free Software Foundation
-# gives unlimited permission to copy, distribute and modify it.
-## -------------------- ##
-## M4sh Initialization. ##
-## -------------------- ##
-
-# Be more Bourne compatible
-DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in #(
-  *posix*) :
-    set -o posix ;; #(
-  *) :
-     ;;
-esac
-fi
-
-
-as_nl='
-'
-export as_nl
-# Printing a long string crashes Solaris 7 /usr/bin/printf.
-as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-# Prefer a ksh shell builtin over an external printf program on Solaris,
-# but without wasting forks for bash or zsh.
-if test -z "$BASH_VERSION$ZSH_VERSION" \
-    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='print -r --'
-  as_echo_n='print -rn --'
-elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='printf %s\n'
-  as_echo_n='printf %s'
-else
-  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
-    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
-    as_echo_n='/usr/ucb/echo -n'
-  else
-    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
-    as_echo_n_body='eval
-      arg=$1;
-      case $arg in #(
-      *"$as_nl"*)
-	expr "X$arg" : "X\\(.*\\)$as_nl";
-	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
-      esac;
-      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
-    '
-    export as_echo_n_body
-    as_echo_n='sh -c $as_echo_n_body as_echo'
-  fi
-  export as_echo_body
-  as_echo='sh -c $as_echo_body as_echo'
-fi
-
-# The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
-  PATH_SEPARATOR=:
-  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
-    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
-      PATH_SEPARATOR=';'
-  }
-fi
-
-
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-IFS=" ""	$as_nl"
-
-# Find who we are.  Look in the path if we contain no directory separator.
-as_myself=
-case $0 in #((
-  *[\\/]* ) as_myself=$0 ;;
-  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-  done
-IFS=$as_save_IFS
-
-     ;;
-esac
-# We did not find ourselves, most probably we were run as `sh COMMAND'
-# in which case we are not to be found in the path.
-if test "x$as_myself" = x; then
-  as_myself=$0
-fi
-if test ! -f "$as_myself"; then
-  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  exit 1
-fi
-
-# Unset variables that we do not need and which cause bugs (e.g. in
-# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
-# suppresses any "Segmentation fault" message there.  '((' could
-# trigger a bug in pdksh 5.2.14.
-for as_var in BASH_ENV ENV MAIL MAILPATH
-do eval test x\${$as_var+set} = xset \
-  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
-done
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-LC_ALL=C
-export LC_ALL
-LANGUAGE=C
-export LANGUAGE
-
-# CDPATH.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
-
-if test "x$CONFIG_SHELL" = x; then
-  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '\${1+\"\$@\"}'='\"\$@\"'
-  setopt NO_GLOB_SUBST
-else
-  case \`(set -o) 2>/dev/null\` in #(
-  *posix*) :
-    set -o posix ;; #(
-  *) :
-     ;;
-esac
-fi
-"
-  as_required="as_fn_return () { (exit \$1); }
-as_fn_success () { as_fn_return 0; }
-as_fn_failure () { as_fn_return 1; }
-as_fn_ret_success () { return 0; }
-as_fn_ret_failure () { return 1; }
-
-exitcode=0
-as_fn_success || { exitcode=1; echo as_fn_success failed.; }
-as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
-as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
-as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
-if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
-
-else
-  exitcode=1; echo positional parameters were not saved.
-fi
-test x\$exitcode = x0 || exit 1"
-  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
-  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
-  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
-  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
-
-  test -n \"\${ZSH_VERSION+set}\${BASH_VERSION+set}\" || (
-    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-    ECHO=\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO
-    ECHO=\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO
-    PATH=/empty FPATH=/empty; export PATH FPATH
-    test \"X\`printf %s \$ECHO\`\" = \"X\$ECHO\" \\
-      || test \"X\`print -r -- \$ECHO\`\" = \"X\$ECHO\" ) || exit 1
-test \$(( 1 + 1 )) = 2 || exit 1"
-  if (eval "$as_required") 2>/dev/null; then :
-  as_have_required=yes
-else
-  as_have_required=no
-fi
-  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
-
-else
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-as_found=false
-for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  as_found=:
-  case $as_dir in #(
-	 /*)
-	   for as_base in sh bash ksh sh5; do
-	     # Try only shells that exist, to save several forks.
-	     as_shell=$as_dir/$as_base
-	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
-		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
-  CONFIG_SHELL=$as_shell as_have_required=yes
-		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
-  break 2
-fi
-fi
-	   done;;
-       esac
-  as_found=false
-done
-$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
-	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
-  CONFIG_SHELL=$SHELL as_have_required=yes
-fi; }
-IFS=$as_save_IFS
-
-
-      if test "x$CONFIG_SHELL" != x; then :
-  # We cannot yet assume a decent shell, so we have to provide a
-	# neutralization value for shells without unset; and this also
-	# works around shells that cannot unset nonexistent variables.
-	# Preserve -v and -x to the replacement shell.
-	BASH_ENV=/dev/null
-	ENV=/dev/null
-	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
-	export CONFIG_SHELL
-	case $- in # ((((
-	  *v*x* | *x*v* ) as_opts=-vx ;;
-	  *v* ) as_opts=-v ;;
-	  *x* ) as_opts=-x ;;
-	  * ) as_opts= ;;
-	esac
-	exec "$CONFIG_SHELL" $as_opts "$as_myself" ${1+"$@"}
-fi
-
-    if test x$as_have_required = xno; then :
-  $as_echo "$0: This script requires a shell more modern than all"
-  $as_echo "$0: the shells that I found on your system."
-  if test x${ZSH_VERSION+set} = xset ; then
-    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
-    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
-  else
-    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
-$0: including any error possibly output before this
-$0: message. Then install a modern shell, or manually run
-$0: the script under such a shell if you do have one."
-  fi
-  exit 1
-fi
-fi
-fi
-SHELL=${CONFIG_SHELL-/bin/sh}
-export SHELL
-# Unset more variables known to interfere with behavior of common tools.
-CLICOLOR_FORCE= GREP_OPTIONS=
-unset CLICOLOR_FORCE GREP_OPTIONS
-
-## --------------------- ##
-## M4sh Shell Functions. ##
-## --------------------- ##
-# as_fn_unset VAR
-# ---------------
-# Portably unset VAR.
-as_fn_unset ()
-{
-  { eval $1=; unset $1;}
-}
-as_unset=as_fn_unset
-
-# as_fn_set_status STATUS
-# -----------------------
-# Set $? to STATUS, without forking.
-as_fn_set_status ()
-{
-  return $1
-} # as_fn_set_status
-
-# as_fn_exit STATUS
-# -----------------
-# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
-as_fn_exit ()
-{
-  set +e
-  as_fn_set_status $1
-  exit $1
-} # as_fn_exit
-
-# as_fn_mkdir_p
-# -------------
-# Create "$as_dir" as a directory, including parents if necessary.
-as_fn_mkdir_p ()
-{
-
-  case $as_dir in #(
-  -*) as_dir=./$as_dir;;
-  esac
-  test -d "$as_dir" || eval $as_mkdir_p || {
-    as_dirs=
-    while :; do
-      case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
-      *) as_qdir=$as_dir;;
-      esac
-      as_dirs="'$as_qdir' $as_dirs"
-      as_dir=`$as_dirname -- "$as_dir" ||
-$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_dir" : 'X\(//\)[^/]' \| \
-	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      test -d "$as_dir" && break
-    done
-    test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
-
-
-} # as_fn_mkdir_p
-# as_fn_append VAR VALUE
-# ----------------------
-# Append the text in VALUE to the end of the definition contained in VAR. Take
-# advantage of any shell optimizations that allow amortized linear growth over
-# repeated appends, instead of the typical quadratic growth present in naive
-# implementations.
-if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
-  eval 'as_fn_append ()
-  {
-    eval $1+=\$2
-  }'
-else
-  as_fn_append ()
-  {
-    eval $1=\$$1\$2
-  }
-fi # as_fn_append
-
-# as_fn_arith ARG...
-# ------------------
-# Perform arithmetic evaluation on the ARGs, and store the result in the
-# global $as_val. Take advantage of shells that can avoid forks. The arguments
-# must be portable across $(()) and expr.
-if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
-  eval 'as_fn_arith ()
-  {
-    as_val=$(( $* ))
-  }'
-else
-  as_fn_arith ()
-  {
-    as_val=`expr "$@" || test $? -eq 1`
-  }
-fi # as_fn_arith
-
-
-# as_fn_error STATUS ERROR [LINENO LOG_FD]
-# ----------------------------------------
-# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
-# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with STATUS, using 1 if that was 0.
-as_fn_error ()
-{
-  as_status=$1; test $as_status -eq 0 && as_status=1
-  if test "$4"; then
-    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
-  fi
-  $as_echo "$as_me: error: $2" >&2
-  as_fn_exit $as_status
-} # as_fn_error
-
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
-  as_basename=basename
-else
-  as_basename=false
-fi
-
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
-fi
-
-as_me=`$as_basename -- "$0" ||
-$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X/"$0" |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
-
-  as_lineno_1=$LINENO as_lineno_1a=$LINENO
-  as_lineno_2=$LINENO as_lineno_2a=$LINENO
-  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
-  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
-  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
-  sed -n '
-    p
-    /[$]LINENO/=
-  ' <$as_myself |
-    sed '
-      s/[$]LINENO.*/&-/
-      t lineno
-      b
-      :lineno
-      N
-      :loop
-      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
-      t loop
-      s/-\n.*//
-    ' >$as_me.lineno &&
-  chmod +x "$as_me.lineno" ||
-    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
-
-  # Don't try to exec as it changes $[0], causing all sort of problems
-  # (the dirname of $[0] is not the place where we might find the
-  # original and so on.  Autoconf is especially sensitive to this).
-  . "./$as_me.lineno"
-  # Exit status is that of the last command.
-  exit
-}
-
-ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in #(((((
--n*)
-  case `echo 'xy\c'` in
-  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  xy)  ECHO_C='\c';;
-  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
-       ECHO_T='	';;
-  esac;;
-*)
-  ECHO_N='-n';;
-esac
-
-rm -f conf$$ conf$$.exe conf$$.file
-if test -d conf$$.dir; then
-  rm -f conf$$.dir/conf$$.file
-else
-  rm -f conf$$.dir
-  mkdir conf$$.dir 2>/dev/null
-fi
-if (echo >conf$$.file) 2>/dev/null; then
-  if ln -s conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s='ln -s'
-    # ... but there are two gotchas:
-    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
-    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
-    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
-  elif ln conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s=ln
-  else
-    as_ln_s='cp -p'
-  fi
-else
-  as_ln_s='cp -p'
-fi
-rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
-rmdir conf$$.dir 2>/dev/null
-
-if mkdir -p . 2>/dev/null; then
-  as_mkdir_p='mkdir -p "$as_dir"'
-else
-  test -d ./-p && rmdir ./-p
-  as_mkdir_p=false
-fi
-
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
-
-# Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
-
-# Sed expression to map a string onto a valid variable name.
-as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
-
-SHELL=${CONFIG_SHELL-/bin/sh}
-
-
-test -n "$DJDIR" || exec 7<&0 </dev/null
-exec 6>&1
-
-# Name of the host.
-# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
-# so uname gets run too.
-ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
-
-#
-# Initializations.
-#
-ac_default_prefix=/usr/local
-ac_clean_files=
-ac_config_libobj_dir=.
-LIBOBJS=
-cross_compiling=no
-subdirs=
-MFLAGS=
-MAKEFLAGS=
-
-# Identity of this package.
-PACKAGE_NAME='gdl'
-PACKAGE_TARNAME='gdl'
-PACKAGE_VERSION='0.9.2'
-PACKAGE_STRING='gdl 0.9.2'
-PACKAGE_BUGREPORT=''
-PACKAGE_URL=''
-
-# Factoring default headers for most tests.
-ac_includes_default="\
-#include <stdio.h>
-#ifdef HAVE_SYS_TYPES_H
-# include <sys/types.h>
-#endif
-#ifdef HAVE_SYS_STAT_H
-# include <sys/stat.h>
-#endif
-#ifdef STDC_HEADERS
-# include <stdlib.h>
-# include <stddef.h>
-#else
-# ifdef HAVE_STDLIB_H
-#  include <stdlib.h>
-# endif
-#endif
-#ifdef HAVE_STRING_H
-# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
-#  include <memory.h>
-# endif
-# include <string.h>
-#endif
-#ifdef HAVE_STRINGS_H
-# include <strings.h>
-#endif
-#ifdef HAVE_INTTYPES_H
-# include <inttypes.h>
-#endif
-#ifdef HAVE_STDINT_H
-# include <stdint.h>
-#endif
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif"
-
-ac_subst_vars='am__EXEEXT_FALSE
-am__EXEEXT_TRUE
-LTLIBOBJS
-LIBOBJS
-EXT_INCLUDES
-EXT_LIBS
-DARWIN_FALSE
-DARWIN_TRUE
-GDLDATADIR
-EXEC_PREFIX
-pkgpyexecdir
-pyexecdir
-pkgpythondir
-pythondir
-PYTHON_PLATFORM
-PYTHON_EXEC_PREFIX
-PYTHON_PREFIX
-PYTHON_VERSION
-PYTHON
-nc_config
-XMKMF
-MagickConfig
-wxConfig
-BUILDASLIBRARY_FALSE
-BUILDASLIBRARY_TRUE
-HAVE_64BIT_OS
-CXXCPP
-CPP
-OTOOL64
-OTOOL
-LIPO
-NMEDIT
-DSYMUTIL
-MANIFEST_TOOL
-ac_ct_AR
-AR
-DLLTOOL
-OBJDUMP
-LN_S
-NM
-ac_ct_DUMPBIN
-DUMPBIN
-LD
-FGREP
-EGREP
-GREP
-SED
-am__fastdepCC_FALSE
-am__fastdepCC_TRUE
-CCDEPMODE
-ac_ct_CC
-CFLAGS
-CC
-host_os
-host_vendor
-host_cpu
-host
-build_os
-build_vendor
-build_cpu
-build
-LIBTOOL
-RANLIB
-am__fastdepCXX_FALSE
-am__fastdepCXX_TRUE
-CXXDEPMODE
-AMDEPBACKSLASH
-AMDEP_FALSE
-AMDEP_TRUE
-am__quote
-am__include
-DEPDIR
-OBJEXT
-EXEEXT
-ac_ct_CXX
-CPPFLAGS
-LDFLAGS
-CXXFLAGS
-CXX
-am__untar
-am__tar
-AMTAR
-am__leading_dot
-SET_MAKE
-AWK
-mkdir_p
-MKDIR_P
-INSTALL_STRIP_PROGRAM
-STRIP
-install_sh
-MAKEINFO
-AUTOHEADER
-AUTOMAKE
-AUTOCONF
-ACLOCAL
-VERSION
-PACKAGE
-CYGPATH_W
-am__isrc
-INSTALL_DATA
-INSTALL_SCRIPT
-INSTALL_PROGRAM
-target_alias
-host_alias
-build_alias
-LIBS
-ECHO_T
-ECHO_N
-ECHO_C
-DEFS
-mandir
-localedir
-libdir
-psdir
-pdfdir
-dvidir
-htmldir
-infodir
-docdir
-oldincludedir
-includedir
-localstatedir
-sharedstatedir
-sysconfdir
-datadir
-datarootdir
-libexecdir
-sbindir
-bindir
-program_transform_name
-prefix
-exec_prefix
-PACKAGE_URL
-PACKAGE_BUGREPORT
-PACKAGE_STRING
-PACKAGE_VERSION
-PACKAGE_TARNAME
-PACKAGE_NAME
-PATH_SEPARATOR
-SHELL'
-ac_subst_files=''
-ac_user_opts='
-enable_option_checking
-enable_dependency_tracking
-enable_shared
-enable_static
-with_pic
-enable_fast_install
-with_gnu_ld
-with_sysroot
-enable_libtool_lock
-enable_python_module
-with_ncursesdir
-with_readlinedir
-with_zlibdir
-with_openmp
-with_gsldir
-with_plplotdir
-enable_oldplplot
-with_wxWidgets
-with_Magick
-with_x
-with_netcdf
-with_hdf
-with_hdf5
-with_fftw
-with_libproj4
-with_mpich
-with_python
-enable_python_version
-with_udunits
-with_grib
-with_gshhs
-with_pslib
-'
-      ac_precious_vars='build_alias
-host_alias
-target_alias
-CXX
-CXXFLAGS
-LDFLAGS
-LIBS
-CPPFLAGS
-CCC
-CC
-CFLAGS
-CPP
-CXXCPP
-XMKMF'
-
-
-# Initialize some variables set by options.
-ac_init_help=
-ac_init_version=false
-ac_unrecognized_opts=
-ac_unrecognized_sep=
-# The variables have the same names as the options, with
-# dashes changed to underlines.
-cache_file=/dev/null
-exec_prefix=NONE
-no_create=
-no_recursion=
-prefix=NONE
-program_prefix=NONE
-program_suffix=NONE
-program_transform_name=s,x,x,
-silent=
-site=
-srcdir=
-verbose=
-x_includes=NONE
-x_libraries=NONE
-
-# Installation directory options.
-# These are left unexpanded so users can "make install exec_prefix=/foo"
-# and all the variables that are supposed to be based on exec_prefix
-# by default will actually change.
-# Use braces instead of parens because sh, perl, etc. also accept them.
-# (The list follows the same order as the GNU Coding Standards.)
-bindir='${exec_prefix}/bin'
-sbindir='${exec_prefix}/sbin'
-libexecdir='${exec_prefix}/libexec'
-datarootdir='${prefix}/share'
-datadir='${datarootdir}'
-sysconfdir='${prefix}/etc'
-sharedstatedir='${prefix}/com'
-localstatedir='${prefix}/var'
-includedir='${prefix}/include'
-oldincludedir='/usr/include'
-docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
-infodir='${datarootdir}/info'
-htmldir='${docdir}'
-dvidir='${docdir}'
-pdfdir='${docdir}'
-psdir='${docdir}'
-libdir='${exec_prefix}/lib'
-localedir='${datarootdir}/locale'
-mandir='${datarootdir}/man'
-
-ac_prev=
-ac_dashdash=
-for ac_option
-do
-  # If the previous option needs an argument, assign it.
-  if test -n "$ac_prev"; then
-    eval $ac_prev=\$ac_option
-    ac_prev=
-    continue
-  fi
-
-  case $ac_option in
-  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
-  *=)   ac_optarg= ;;
-  *)    ac_optarg=yes ;;
-  esac
-
-  # Accept the important Cygnus configure options, so we can diagnose typos.
-
-  case $ac_dashdash$ac_option in
-  --)
-    ac_dashdash=yes ;;
-
-  -bindir | --bindir | --bindi | --bind | --bin | --bi)
-    ac_prev=bindir ;;
-  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
-    bindir=$ac_optarg ;;
-
-  -build | --build | --buil | --bui | --bu)
-    ac_prev=build_alias ;;
-  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
-    build_alias=$ac_optarg ;;
-
-  -cache-file | --cache-file | --cache-fil | --cache-fi \
-  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
-    ac_prev=cache_file ;;
-  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
-  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
-    cache_file=$ac_optarg ;;
-
-  --config-cache | -C)
-    cache_file=config.cache ;;
-
-  -datadir | --datadir | --datadi | --datad)
-    ac_prev=datadir ;;
-  -datadir=* | --datadir=* | --datadi=* | --datad=*)
-    datadir=$ac_optarg ;;
-
-  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
-  | --dataroo | --dataro | --datar)
-    ac_prev=datarootdir ;;
-  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
-  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
-    datarootdir=$ac_optarg ;;
-
-  -disable-* | --disable-*)
-    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid feature name: $ac_useropt"
-    ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
-    case $ac_user_opts in
-      *"
-"enable_$ac_useropt"
-"*) ;;
-      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
-	 ac_unrecognized_sep=', ';;
-    esac
-    eval enable_$ac_useropt=no ;;
-
-  -docdir | --docdir | --docdi | --doc | --do)
-    ac_prev=docdir ;;
-  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
-    docdir=$ac_optarg ;;
-
-  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
-    ac_prev=dvidir ;;
-  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
-    dvidir=$ac_optarg ;;
-
-  -enable-* | --enable-*)
-    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid feature name: $ac_useropt"
-    ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
-    case $ac_user_opts in
-      *"
-"enable_$ac_useropt"
-"*) ;;
-      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
-	 ac_unrecognized_sep=', ';;
-    esac
-    eval enable_$ac_useropt=\$ac_optarg ;;
-
-  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
-  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
-  | --exec | --exe | --ex)
-    ac_prev=exec_prefix ;;
-  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
-  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
-  | --exec=* | --exe=* | --ex=*)
-    exec_prefix=$ac_optarg ;;
-
-  -gas | --gas | --ga | --g)
-    # Obsolete; use --with-gas.
-    with_gas=yes ;;
-
-  -help | --help | --hel | --he | -h)
-    ac_init_help=long ;;
-  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
-    ac_init_help=recursive ;;
-  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
-    ac_init_help=short ;;
-
-  -host | --host | --hos | --ho)
-    ac_prev=host_alias ;;
-  -host=* | --host=* | --hos=* | --ho=*)
-    host_alias=$ac_optarg ;;
-
-  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
-    ac_prev=htmldir ;;
-  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
-  | --ht=*)
-    htmldir=$ac_optarg ;;
-
-  -includedir | --includedir | --includedi | --included | --include \
-  | --includ | --inclu | --incl | --inc)
-    ac_prev=includedir ;;
-  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
-  | --includ=* | --inclu=* | --incl=* | --inc=*)
-    includedir=$ac_optarg ;;
-
-  -infodir | --infodir | --infodi | --infod | --info | --inf)
-    ac_prev=infodir ;;
-  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
-    infodir=$ac_optarg ;;
-
-  -libdir | --libdir | --libdi | --libd)
-    ac_prev=libdir ;;
-  -libdir=* | --libdir=* | --libdi=* | --libd=*)
-    libdir=$ac_optarg ;;
-
-  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
-  | --libexe | --libex | --libe)
-    ac_prev=libexecdir ;;
-  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
-  | --libexe=* | --libex=* | --libe=*)
-    libexecdir=$ac_optarg ;;
-
-  -localedir | --localedir | --localedi | --localed | --locale)
-    ac_prev=localedir ;;
-  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
-    localedir=$ac_optarg ;;
-
-  -localstatedir | --localstatedir | --localstatedi | --localstated \
-  | --localstate | --localstat | --localsta | --localst | --locals)
-    ac_prev=localstatedir ;;
-  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
-  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
-    localstatedir=$ac_optarg ;;
-
-  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
-    ac_prev=mandir ;;
-  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
-    mandir=$ac_optarg ;;
-
-  -nfp | --nfp | --nf)
-    # Obsolete; use --without-fp.
-    with_fp=no ;;
-
-  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-  | --no-cr | --no-c | -n)
-    no_create=yes ;;
-
-  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
-    no_recursion=yes ;;
-
-  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
-  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
-  | --oldin | --oldi | --old | --ol | --o)
-    ac_prev=oldincludedir ;;
-  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
-  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
-  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
-    oldincludedir=$ac_optarg ;;
-
-  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
-    ac_prev=prefix ;;
-  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
-    prefix=$ac_optarg ;;
-
-  -program-prefix | --program-prefix | --program-prefi | --program-pref \
-  | --program-pre | --program-pr | --program-p)
-    ac_prev=program_prefix ;;
-  -program-prefix=* | --program-prefix=* | --program-prefi=* \
-  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
-    program_prefix=$ac_optarg ;;
-
-  -program-suffix | --program-suffix | --program-suffi | --program-suff \
-  | --program-suf | --program-su | --program-s)
-    ac_prev=program_suffix ;;
-  -program-suffix=* | --program-suffix=* | --program-suffi=* \
-  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
-    program_suffix=$ac_optarg ;;
-
-  -program-transform-name | --program-transform-name \
-  | --program-transform-nam | --program-transform-na \
-  | --program-transform-n | --program-transform- \
-  | --program-transform | --program-transfor \
-  | --program-transfo | --program-transf \
-  | --program-trans | --program-tran \
-  | --progr-tra | --program-tr | --program-t)
-    ac_prev=program_transform_name ;;
-  -program-transform-name=* | --program-transform-name=* \
-  | --program-transform-nam=* | --program-transform-na=* \
-  | --program-transform-n=* | --program-transform-=* \
-  | --program-transform=* | --program-transfor=* \
-  | --program-transfo=* | --program-transf=* \
-  | --program-trans=* | --program-tran=* \
-  | --progr-tra=* | --program-tr=* | --program-t=*)
-    program_transform_name=$ac_optarg ;;
-
-  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
-    ac_prev=pdfdir ;;
-  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
-    pdfdir=$ac_optarg ;;
-
-  -psdir | --psdir | --psdi | --psd | --ps)
-    ac_prev=psdir ;;
-  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
-    psdir=$ac_optarg ;;
-
-  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-  | -silent | --silent | --silen | --sile | --sil)
-    silent=yes ;;
-
-  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
-    ac_prev=sbindir ;;
-  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
-  | --sbi=* | --sb=*)
-    sbindir=$ac_optarg ;;
-
-  -sharedstatedir | --sharedstatedir | --sharedstatedi \
-  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
-  | --sharedst | --shareds | --shared | --share | --shar \
-  | --sha | --sh)
-    ac_prev=sharedstatedir ;;
-  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
-  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
-  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
-  | --sha=* | --sh=*)
-    sharedstatedir=$ac_optarg ;;
-
-  -site | --site | --sit)
-    ac_prev=site ;;
-  -site=* | --site=* | --sit=*)
-    site=$ac_optarg ;;
-
-  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
-    ac_prev=srcdir ;;
-  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
-    srcdir=$ac_optarg ;;
-
-  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
-  | --syscon | --sysco | --sysc | --sys | --sy)
-    ac_prev=sysconfdir ;;
-  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
-  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
-    sysconfdir=$ac_optarg ;;
-
-  -target | --target | --targe | --targ | --tar | --ta | --t)
-    ac_prev=target_alias ;;
-  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
-    target_alias=$ac_optarg ;;
-
-  -v | -verbose | --verbose | --verbos | --verbo | --verb)
-    verbose=yes ;;
-
-  -version | --version | --versio | --versi | --vers | -V)
-    ac_init_version=: ;;
-
-  -with-* | --with-*)
-    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid package name: $ac_useropt"
-    ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
-    case $ac_user_opts in
-      *"
-"with_$ac_useropt"
-"*) ;;
-      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
-	 ac_unrecognized_sep=', ';;
-    esac
-    eval with_$ac_useropt=\$ac_optarg ;;
-
-  -without-* | --without-*)
-    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid package name: $ac_useropt"
-    ac_useropt_orig=$ac_useropt
-    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
-    case $ac_user_opts in
-      *"
-"with_$ac_useropt"
-"*) ;;
-      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
-	 ac_unrecognized_sep=', ';;
-    esac
-    eval with_$ac_useropt=no ;;
-
-  --x)
-    # Obsolete; use --with-x.
-    with_x=yes ;;
-
-  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
-  | --x-incl | --x-inc | --x-in | --x-i)
-    ac_prev=x_includes ;;
-  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
-  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
-    x_includes=$ac_optarg ;;
-
-  -x-libraries | --x-libraries | --x-librarie | --x-librari \
-  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
-    ac_prev=x_libraries ;;
-  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
-  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
-    x_libraries=$ac_optarg ;;
-
-  -*) as_fn_error $? "unrecognized option: \`$ac_option'
-Try \`$0 --help' for more information"
-    ;;
-
-  *=*)
-    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
-    # Reject names that are not valid shell variable names.
-    case $ac_envvar in #(
-      '' | [0-9]* | *[!_$as_cr_alnum]* )
-      as_fn_error $? "invalid variable name: \`$ac_envvar'" ;;
-    esac
-    eval $ac_envvar=\$ac_optarg
-    export $ac_envvar ;;
-
-  *)
-    # FIXME: should be removed in autoconf 3.0.
-    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
-    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
-      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
-    : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
-    ;;
-
-  esac
-done
-
-if test -n "$ac_prev"; then
-  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
-  as_fn_error $? "missing argument to $ac_option"
-fi
-
-if test -n "$ac_unrecognized_opts"; then
-  case $enable_option_checking in
-    no) ;;
-    fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
-    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
-  esac
-fi
-
-# Check all directory arguments for consistency.
-for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
-		datadir sysconfdir sharedstatedir localstatedir includedir \
-		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
-		libdir localedir mandir
-do
-  eval ac_val=\$$ac_var
-  # Remove trailing slashes.
-  case $ac_val in
-    */ )
-      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
-      eval $ac_var=\$ac_val;;
-  esac
-  # Be sure to have absolute directory names.
-  case $ac_val in
-    [\\/$]* | ?:[\\/]* )  continue;;
-    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
-  esac
-  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
-done
-
-# There might be people who depend on the old broken behavior: `$host'
-# used to hold the argument of --host etc.
-# FIXME: To remove some day.
-build=$build_alias
-host=$host_alias
-target=$target_alias
-
-# FIXME: To remove some day.
-if test "x$host_alias" != x; then
-  if test "x$build_alias" = x; then
-    cross_compiling=maybe
-    $as_echo "$as_me: WARNING: if you wanted to set the --build type, don't use --host.
-    If a cross compiler is detected then cross compile mode will be used" >&2
-  elif test "x$build_alias" != "x$host_alias"; then
-    cross_compiling=yes
-  fi
-fi
-
-ac_tool_prefix=
-test -n "$host_alias" && ac_tool_prefix=$host_alias-
-
-test "$silent" = yes && exec 6>/dev/null
-
-
-ac_pwd=`pwd` && test -n "$ac_pwd" &&
-ac_ls_di=`ls -di .` &&
-ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  as_fn_error $? "working directory cannot be determined"
-test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
-  as_fn_error $? "pwd does not report name of working directory"
-
-
-# Find the source files, if location was not specified.
-if test -z "$srcdir"; then
-  ac_srcdir_defaulted=yes
-  # Try the directory containing this script, then the parent directory.
-  ac_confdir=`$as_dirname -- "$as_myself" ||
-$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_myself" : 'X\(//\)[^/]' \| \
-	 X"$as_myself" : 'X\(//\)$' \| \
-	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_myself" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-  srcdir=$ac_confdir
-  if test ! -r "$srcdir/$ac_unique_file"; then
-    srcdir=..
-  fi
-else
-  ac_srcdir_defaulted=no
-fi
-if test ! -r "$srcdir/$ac_unique_file"; then
-  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
-  as_fn_error $? "cannot find sources ($ac_unique_file) in $srcdir"
-fi
-ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
-ac_abs_confdir=`(
-	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error $? "$ac_msg"
-	pwd)`
-# When building in place, set srcdir=.
-if test "$ac_abs_confdir" = "$ac_pwd"; then
-  srcdir=.
-fi
-# Remove unnecessary trailing slashes from srcdir.
-# Double slashes in file names in object file debugging info
-# mess up M-x gdb in Emacs.
-case $srcdir in
-*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
-esac
-for ac_var in $ac_precious_vars; do
-  eval ac_env_${ac_var}_set=\${${ac_var}+set}
-  eval ac_env_${ac_var}_value=\$${ac_var}
-  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
-  eval ac_cv_env_${ac_var}_value=\$${ac_var}
-done
-
-#
-# Report the --help message.
-#
-if test "$ac_init_help" = "long"; then
-  # Omit some internal or obsolete options to make the list less imposing.
-  # This message is too long to be a string in the A/UX 3.1 sh.
-  cat <<_ACEOF
-\`configure' configures gdl 0.9.2 to adapt to many kinds of systems.
-
-Usage: $0 [OPTION]... [VAR=VALUE]...
-
-To assign environment variables (e.g., CC, CFLAGS...), specify them as
-VAR=VALUE.  See below for descriptions of some of the useful variables.
-
-Defaults for the options are specified in brackets.
-
-Configuration:
-  -h, --help              display this help and exit
-      --help=short        display options specific to this package
-      --help=recursive    display the short help of all the included packages
-  -V, --version           display version information and exit
-  -q, --quiet, --silent   do not print \`checking ...' messages
-      --cache-file=FILE   cache test results in FILE [disabled]
-  -C, --config-cache      alias for \`--cache-file=config.cache'
-  -n, --no-create         do not create output files
-      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
-
-Installation directories:
-  --prefix=PREFIX         install architecture-independent files in PREFIX
-                          [$ac_default_prefix]
-  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
-                          [PREFIX]
-
-By default, \`make install' will install all the files in
-\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
-an installation prefix other than \`$ac_default_prefix' using \`--prefix',
-for instance \`--prefix=\$HOME'.
-
-For better control, use the options below.
-
-Fine tuning of the installation directories:
-  --bindir=DIR            user executables [EPREFIX/bin]
-  --sbindir=DIR           system admin executables [EPREFIX/sbin]
-  --libexecdir=DIR        program executables [EPREFIX/libexec]
-  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
-  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
-  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
-  --libdir=DIR            object code libraries [EPREFIX/lib]
-  --includedir=DIR        C header files [PREFIX/include]
-  --oldincludedir=DIR     C header files for non-gcc [/usr/include]
-  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
-  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
-  --infodir=DIR           info documentation [DATAROOTDIR/info]
-  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
-  --mandir=DIR            man documentation [DATAROOTDIR/man]
-  --docdir=DIR            documentation root [DATAROOTDIR/doc/gdl]
-  --htmldir=DIR           html documentation [DOCDIR]
-  --dvidir=DIR            dvi documentation [DOCDIR]
-  --pdfdir=DIR            pdf documentation [DOCDIR]
-  --psdir=DIR             ps documentation [DOCDIR]
-_ACEOF
-
-  cat <<\_ACEOF
-
-Program names:
-  --program-prefix=PREFIX            prepend PREFIX to installed program names
-  --program-suffix=SUFFIX            append SUFFIX to installed program names
-  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
-
-X features:
-  --x-includes=DIR    X include files are in DIR
-  --x-libraries=DIR   X library files are in DIR
-
-System types:
-  --build=BUILD     configure for building on BUILD [guessed]
-  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
-_ACEOF
-fi
-
-if test -n "$ac_init_help"; then
-  case $ac_init_help in
-     short | recursive ) echo "Configuration of gdl 0.9.2:";;
-   esac
-  cat <<\_ACEOF
-
-Optional Features:
-  --disable-option-checking  ignore unrecognized --enable/--with options
-  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
-  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
-  --disable-dependency-tracking  speeds up one-time build
-  --enable-dependency-tracking   do not reject slow dependency extractors
-  --enable-shared[=PKGS]  build shared libraries [default=yes]
-  --enable-static[=PKGS]  build static libraries [default=yes]
-  --enable-fast-install[=PKGS]
-                          optimize for fast installation [default=yes]
-  --disable-libtool-lock  avoid locking (might break parallel builds)
-  --enable-python_module  make GDL python module (default: standalone version)
-  --enable-oldplplot      use plplot version prior to 5.9.0
-  --enable-python_version set explicit python version to use (eg. 2.6)
-
-Optional Packages:
-  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
-  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
-  --with-pic              try to use only PIC/non-PIC objects [default=use
-                          both]
-  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
-  --with-sysroot=DIR Search for dependent libraries within DIR
-                        (or the compiler's sysroot if not specified).
-  --with-ncursesdir=DIR   specify the ncurses (or curses) directory tree
-  --with-readlinedir=DIR  specify the GNU readline directory tree
-  --with-zlibdir=DIR      specify the Zlib directory tree
-  --with-openmp=no        disable OpenMP utilization
-  --with-gsldir=DIR       specify the GSL directory tree
-  --with-plplotdir=DIR    specify the plplot directory tree
-  --with-wxWidgets=DIR    use wxWidgets (with optional path DIR)
-  --with-Magick=DIR       use ImageMagick package (with optional path DIR)
-  --with-x                use the X Window System
-  --with-netcdf=DIR       use netCDF package (with optional path DIR)
-  --with-hdf=DIR          use HDF package (with optional path DIR)
-  --with-hdf5=DIR         use HDF5 package (with optional path DIR)
-  --with-fftw=DIR         use FFTW package (with optional path DIR)
-  --with-libproj4=DIR     use LIBPROJ4 package (with optional path DIR)
-  --with-mpich=DIR        use MPICH (experimental) (with optional path DIR)
-  --with-python=DIR       use Python package (with optional path DIR)
-  --with-udunits=DIR      use UDUNITS-2 package (with optional path DIR)
-  --with-grib=DIR         use GRIB package (with optional path DIR)
-  --with-gshhs=DIR        use GSHHS package (with optional path DIR)
-  --with-pslib=DIR        use pslib package (with optional path DIR)
-
-Some influential environment variables:
-  CXX         C++ compiler command
-  CXXFLAGS    C++ compiler flags
-  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
-              nonstandard directory <lib dir>
-  LIBS        libraries to pass to the linker, e.g. -l<library>
-  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if
-              you have headers in a nonstandard directory <include dir>
-  CC          C compiler command
-  CFLAGS      C compiler flags
-  CPP         C preprocessor
-  CXXCPP      C++ preprocessor
-  XMKMF       Path to xmkmf, Makefile generator for X Window System
-
-Use these variables to override the choices made by `configure' or to help
-it to find libraries and programs with nonstandard names/locations.
-
-Report bugs to the package provider.
-_ACEOF
-ac_status=$?
-fi
-
-if test "$ac_init_help" = "recursive"; then
-  # If there are subdirs, report their specific --help.
-  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
-    test -d "$ac_dir" ||
-      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
-      continue
-    ac_builddir=.
-
-case "$ac_dir" in
-.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
-*)
-  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
-  # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
-  case $ac_top_builddir_sub in
-  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
-  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
-  esac ;;
-esac
-ac_abs_top_builddir=$ac_pwd
-ac_abs_builddir=$ac_pwd$ac_dir_suffix
-# for backward compatibility:
-ac_top_builddir=$ac_top_build_prefix
-
-case $srcdir in
-  .)  # We are building in place.
-    ac_srcdir=.
-    ac_top_srcdir=$ac_top_builddir_sub
-    ac_abs_top_srcdir=$ac_pwd ;;
-  [\\/]* | ?:[\\/]* )  # Absolute name.
-    ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir
-    ac_abs_top_srcdir=$srcdir ;;
-  *) # Relative name.
-    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_build_prefix$srcdir
-    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
-esac
-ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
-
-    cd "$ac_dir" || { ac_status=$?; continue; }
-    # Check for guested configure.
-    if test -f "$ac_srcdir/configure.gnu"; then
-      echo &&
-      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
-    elif test -f "$ac_srcdir/configure"; then
-      echo &&
-      $SHELL "$ac_srcdir/configure" --help=recursive
-    else
-      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
-    fi || ac_status=$?
-    cd "$ac_pwd" || { ac_status=$?; break; }
-  done
-fi
-
-test -n "$ac_init_help" && exit $ac_status
-if $ac_init_version; then
-  cat <<\_ACEOF
-gdl configure 0.9.2
-generated by GNU Autoconf 2.68
-
-Copyright (C) 2010 Free Software Foundation, Inc.
-This configure script is free software; the Free Software Foundation
-gives unlimited permission to copy, distribute and modify it.
-_ACEOF
-  exit
-fi
-
-## ------------------------ ##
-## Autoconf initialization. ##
-## ------------------------ ##
-
-# ac_fn_cxx_try_compile LINENO
-# ----------------------------
-# Try to compile conftest.$ac_ext, and return whether this succeeded.
-ac_fn_cxx_try_compile ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext
-  if { { ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compile") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && {
-	 test -z "$ac_cxx_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_retval=1
-fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_cxx_try_compile
-
-# ac_fn_c_try_compile LINENO
-# --------------------------
-# Try to compile conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_compile ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext
-  if { { ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compile") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_retval=1
-fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_c_try_compile
-
-# ac_fn_c_try_link LINENO
-# -----------------------
-# Try to link conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_link ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext conftest$ac_exeext
-  if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_retval=1
-fi
-  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
-  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
-  # interfere with the next link command; also delete a directory that is
-  # left behind by Apple's compiler.  We do this before executing the actions.
-  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_c_try_link
-
-# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
-# -------------------------------------------------------
-# Tests whether HEADER exists and can be compiled using the include files in
-# INCLUDES, setting the cache variable VAR accordingly.
-ac_fn_c_check_header_compile ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-#include <$2>
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  eval "$3=yes"
-else
-  eval "$3=no"
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-
-} # ac_fn_c_check_header_compile
-
-# ac_fn_c_try_cpp LINENO
-# ----------------------
-# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
-ac_fn_c_try_cpp ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { { ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } > conftest.i && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-    ac_retval=1
-fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_c_try_cpp
-
-# ac_fn_c_try_run LINENO
-# ----------------------
-# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
-# that executables *can* be run.
-ac_fn_c_try_run ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
-  { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: program exited with status $ac_status" >&5
-       $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-       ac_retval=$ac_status
-fi
-  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_c_try_run
-
-# ac_fn_c_check_func LINENO FUNC VAR
-# ----------------------------------
-# Tests whether FUNC exists, setting the cache variable VAR accordingly
-ac_fn_c_check_func ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $2 innocuous_$2
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $2 (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $2
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $2 ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$2 || defined __stub___$2
-choke me
-#endif
-
-int
-main ()
-{
-return $2 ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  eval "$3=yes"
-else
-  eval "$3=no"
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-
-} # ac_fn_c_check_func
-
-# ac_fn_cxx_try_cpp LINENO
-# ------------------------
-# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
-ac_fn_cxx_try_cpp ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if { { ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } > conftest.i && {
-	 test -z "$ac_cxx_preproc_warn_flag$ac_cxx_werror_flag" ||
-	 test ! -s conftest.err
-       }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-    ac_retval=1
-fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_cxx_try_cpp
-
-# ac_fn_cxx_try_link LINENO
-# -------------------------
-# Try to link conftest.$ac_ext, and return whether this succeeded.
-ac_fn_cxx_try_link ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  rm -f conftest.$ac_objext conftest$ac_exeext
-  if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    grep -v '^ *+' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-    mv -f conftest.er1 conftest.err
-  fi
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && {
-	 test -z "$ac_cxx_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext && {
-	 test "$cross_compiling" = yes ||
-	 $as_test_x conftest$ac_exeext
-       }; then :
-  ac_retval=0
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_retval=1
-fi
-  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
-  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
-  # interfere with the next link command; also delete a directory that is
-  # left behind by Apple's compiler.  We do this before executing the actions.
-  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
-
-} # ac_fn_cxx_try_link
-
-# ac_fn_cxx_check_func LINENO FUNC VAR
-# ------------------------------------
-# Tests whether FUNC exists, setting the cache variable VAR accordingly
-ac_fn_cxx_check_func ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $2 innocuous_$2
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $2 (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $2
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $2 ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$2 || defined __stub___$2
-choke me
-#endif
-
-int
-main ()
-{
-return $2 ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  eval "$3=yes"
-else
-  eval "$3=no"
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-
-} # ac_fn_cxx_check_func
-
-# ac_fn_cxx_check_header_mongrel LINENO HEADER VAR INCLUDES
-# ---------------------------------------------------------
-# Tests whether HEADER exists, giving a warning if it cannot be compiled using
-# the include files in INCLUDES and setting the cache variable VAR
-# accordingly.
-ac_fn_cxx_check_header_mongrel ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  if eval \${$3+:} false; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 usability" >&5
-$as_echo_n "checking $2 usability... " >&6; }
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-#include <$2>
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  ac_header_compiler=yes
-else
-  ac_header_compiler=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler" >&5
-$as_echo "$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 presence" >&5
-$as_echo_n "checking $2 presence... " >&6; }
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <$2>
-_ACEOF
-if ac_fn_cxx_try_cpp "$LINENO"; then :
-  ac_header_preproc=yes
-else
-  ac_header_preproc=no
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
-$as_echo "$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_cxx_preproc_warn_flag in #((
-  yes:no: )
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&5
-$as_echo "$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
-    ;;
-  no:yes:* )
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled" >&5
-$as_echo "$as_me: WARNING: $2: present but cannot be compiled" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?" >&5
-$as_echo "$as_me: WARNING: $2:     check for missing prerequisite headers?" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation" >&5
-$as_echo "$as_me: WARNING: $2: see the Autoconf documentation" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&5
-$as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
-$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
-    ;;
-esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  eval "$3=\$ac_header_compiler"
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-
-} # ac_fn_cxx_check_header_mongrel
-
-# ac_fn_cxx_check_header_compile LINENO HEADER VAR INCLUDES
-# ---------------------------------------------------------
-# Tests whether HEADER exists and can be compiled using the include files in
-# INCLUDES, setting the cache variable VAR accordingly.
-ac_fn_cxx_check_header_compile ()
-{
-  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
-$as_echo_n "checking for $2... " >&6; }
-if eval \${$3+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-$4
-#include <$2>
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  eval "$3=yes"
-else
-  eval "$3=no"
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-eval ac_res=\$$3
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-
-} # ac_fn_cxx_check_header_compile
-cat >config.log <<_ACEOF
-This file contains any messages produced by compilers while
-running configure, to aid debugging if configure makes a mistake.
-
-It was created by gdl $as_me 0.9.2, which was
-generated by GNU Autoconf 2.68.  Invocation command line was
-
-  $ $0 $@
-
-_ACEOF
-exec 5>>config.log
-{
-cat <<_ASUNAME
-## --------- ##
-## Platform. ##
-## --------- ##
-
-hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
-uname -m = `(uname -m) 2>/dev/null || echo unknown`
-uname -r = `(uname -r) 2>/dev/null || echo unknown`
-uname -s = `(uname -s) 2>/dev/null || echo unknown`
-uname -v = `(uname -v) 2>/dev/null || echo unknown`
-
-/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
-/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
-
-/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
-/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
-/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
-/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
-/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
-/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
-/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
-
-_ASUNAME
-
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    $as_echo "PATH: $as_dir"
-  done
-IFS=$as_save_IFS
-
-} >&5
-
-cat >&5 <<_ACEOF
-
-
-## ----------- ##
-## Core tests. ##
-## ----------- ##
-
-_ACEOF
-
-
-# Keep a trace of the command line.
-# Strip out --no-create and --no-recursion so they do not pile up.
-# Strip out --silent because we don't want to record it for future runs.
-# Also quote any args containing shell meta-characters.
-# Make two passes to allow for proper duplicate-argument suppression.
-ac_configure_args=
-ac_configure_args0=
-ac_configure_args1=
-ac_must_keep_next=false
-for ac_pass in 1 2
-do
-  for ac_arg
-  do
-    case $ac_arg in
-    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
-    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-    | -silent | --silent | --silen | --sile | --sil)
-      continue ;;
-    *\'*)
-      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    esac
-    case $ac_pass in
-    1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
-    2)
-      as_fn_append ac_configure_args1 " '$ac_arg'"
-      if test $ac_must_keep_next = true; then
-	ac_must_keep_next=false # Got value, back to normal.
-      else
-	case $ac_arg in
-	  *=* | --config-cache | -C | -disable-* | --disable-* \
-	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
-	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
-	  | -with-* | --with-* | -without-* | --without-* | --x)
-	    case "$ac_configure_args0 " in
-	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
-	    esac
-	    ;;
-	  -* ) ac_must_keep_next=true ;;
-	esac
-      fi
-      as_fn_append ac_configure_args " '$ac_arg'"
-      ;;
-    esac
-  done
-done
-{ ac_configure_args0=; unset ac_configure_args0;}
-{ ac_configure_args1=; unset ac_configure_args1;}
-
-# When interrupted or exit'd, cleanup temporary files, and complete
-# config.log.  We remove comments because anyway the quotes in there
-# would cause problems or look ugly.
-# WARNING: Use '\'' to represent an apostrophe within the trap.
-# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
-trap 'exit_status=$?
-  # Save into config.log some information that might help in debugging.
-  {
-    echo
-
-    $as_echo "## ---------------- ##
-## Cache variables. ##
-## ---------------- ##"
-    echo
-    # The following way of writing the cache mishandles newlines in values,
-(
-  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
-    eval ac_val=\$$ac_var
-    case $ac_val in #(
-    *${as_nl}*)
-      case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
-$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
-      esac
-      case $ac_var in #(
-      _ | IFS | as_nl) ;; #(
-      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
-      *) { eval $ac_var=; unset $ac_var;} ;;
-      esac ;;
-    esac
-  done
-  (set) 2>&1 |
-    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
-    *${as_nl}ac_space=\ *)
-      sed -n \
-	"s/'\''/'\''\\\\'\'''\''/g;
-	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
-      ;; #(
-    *)
-      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
-      ;;
-    esac |
-    sort
-)
-    echo
-
-    $as_echo "## ----------------- ##
-## Output variables. ##
-## ----------------- ##"
-    echo
-    for ac_var in $ac_subst_vars
-    do
-      eval ac_val=\$$ac_var
-      case $ac_val in
-      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
-      esac
-      $as_echo "$ac_var='\''$ac_val'\''"
-    done | sort
-    echo
-
-    if test -n "$ac_subst_files"; then
-      $as_echo "## ------------------- ##
-## File substitutions. ##
-## ------------------- ##"
-      echo
-      for ac_var in $ac_subst_files
-      do
-	eval ac_val=\$$ac_var
-	case $ac_val in
-	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
-	esac
-	$as_echo "$ac_var='\''$ac_val'\''"
-      done | sort
-      echo
-    fi
-
-    if test -s confdefs.h; then
-      $as_echo "## ----------- ##
-## confdefs.h. ##
-## ----------- ##"
-      echo
-      cat confdefs.h
-      echo
-    fi
-    test "$ac_signal" != 0 &&
-      $as_echo "$as_me: caught signal $ac_signal"
-    $as_echo "$as_me: exit $exit_status"
-  } >&5
-  rm -f core *.core core.conftest.* &&
-    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
-    exit $exit_status
-' 0
-for ac_signal in 1 2 13 15; do
-  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
-done
-ac_signal=0
-
-# confdefs.h avoids OS command line length limits that DEFS can exceed.
-rm -f -r conftest* confdefs.h
-
-$as_echo "/* confdefs.h */" > confdefs.h
-
-# Predefined preprocessor variables.
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_NAME "$PACKAGE_NAME"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_VERSION "$PACKAGE_VERSION"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_STRING "$PACKAGE_STRING"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
-_ACEOF
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_URL "$PACKAGE_URL"
-_ACEOF
-
-
-# Let the site file select an alternate cache file if it wants to.
-# Prefer an explicitly selected file to automatically selected ones.
-ac_site_file1=NONE
-ac_site_file2=NONE
-if test -n "$CONFIG_SITE"; then
-  # We do not want a PATH search for config.site.
-  case $CONFIG_SITE in #((
-    -*)  ac_site_file1=./$CONFIG_SITE;;
-    */*) ac_site_file1=$CONFIG_SITE;;
-    *)   ac_site_file1=./$CONFIG_SITE;;
-  esac
-elif test "x$prefix" != xNONE; then
-  ac_site_file1=$prefix/share/config.site
-  ac_site_file2=$prefix/etc/config.site
-else
-  ac_site_file1=$ac_default_prefix/share/config.site
-  ac_site_file2=$ac_default_prefix/etc/config.site
-fi
-for ac_site_file in "$ac_site_file1" "$ac_site_file2"
-do
-  test "x$ac_site_file" = xNONE && continue
-  if test /dev/null != "$ac_site_file" && test -r "$ac_site_file"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
-$as_echo "$as_me: loading site script $ac_site_file" >&6;}
-    sed 's/^/| /' "$ac_site_file" >&5
-    . "$ac_site_file" \
-      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "failed to load site script $ac_site_file
-See \`config.log' for more details" "$LINENO" 5; }
-  fi
-done
-
-if test -r "$cache_file"; then
-  # Some versions of bash will fail to source /dev/null (special files
-  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.
-  if test /dev/null != "$cache_file" && test -f "$cache_file"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
-$as_echo "$as_me: loading cache $cache_file" >&6;}
-    case $cache_file in
-      [\\/]* | ?:[\\/]* ) . "$cache_file";;
-      *)                      . "./$cache_file";;
-    esac
-  fi
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
-$as_echo "$as_me: creating cache $cache_file" >&6;}
-  >$cache_file
-fi
-
-# Check that the precious variables saved in the cache have kept the same
-# value.
-ac_cache_corrupted=false
-for ac_var in $ac_precious_vars; do
-  eval ac_old_set=\$ac_cv_env_${ac_var}_set
-  eval ac_new_set=\$ac_env_${ac_var}_set
-  eval ac_old_val=\$ac_cv_env_${ac_var}_value
-  eval ac_new_val=\$ac_env_${ac_var}_value
-  case $ac_old_set,$ac_new_set in
-    set,)
-      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
-$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
-      ac_cache_corrupted=: ;;
-    ,set)
-      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
-$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
-      ac_cache_corrupted=: ;;
-    ,);;
-    *)
-      if test "x$ac_old_val" != "x$ac_new_val"; then
-	# differences in whitespace do not lead to failure.
-	ac_old_val_w=`echo x $ac_old_val`
-	ac_new_val_w=`echo x $ac_new_val`
-	if test "$ac_old_val_w" != "$ac_new_val_w"; then
-	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
-$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
-	  ac_cache_corrupted=:
-	else
-	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
-$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
-	  eval $ac_var=\$ac_old_val
-	fi
-	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
-$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
-	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
-$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
-      fi;;
-  esac
-  # Pass precious variables to config.status.
-  if test "$ac_new_set" = set; then
-    case $ac_new_val in
-    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
-    *) ac_arg=$ac_var=$ac_new_val ;;
-    esac
-    case " $ac_configure_args " in
-      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
-      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
-    esac
-  fi
-done
-if $ac_cache_corrupted; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
-$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
-fi
-## -------------------- ##
-## Main body of script. ##
-## -------------------- ##
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-
-
-
-PYTHON_MODULE="no"
-
-if test "x$with_readlinedir" = "x"; then with_readlinedir=yes; fi
-if test "x$with_wxWidgets"   = "x"; then with_wxWidgets=yes;   fi
-if test "x$with_udunits"     = "x"; then with_udunits=no;      fi
-if test "x$with_grib"        = "x"; then with_grib=no;         fi
-if test "x$with_Magick"      = "x"; then with_Magick=yes;      fi
-if test "x$with_netcdf"      = "x"; then with_netcdf=yes;      fi
-if test "x$with_hdf"         = "x"; then with_hdf=yes;         fi
-if test "x$with_hdf5"        = "x"; then with_hdf5=yes;        fi
-if test "x$with_fftw"        = "x"; then with_fftw=auto;       fi
-if test "x$with_libproj4"    = "x"; then with_libproj4=no;     fi
-if test "x$with_mpich"       = "x"; then with_mpich=no;        fi
-if test "x$with_python"      = "x"; then with_python=yes;      fi
-if test "x$with_gshhs"       = "x"; then with_gshhs=no;        fi
-if test "x$with_pslib"       = "x"; then with_pslib=yes;       fi
-
-datasubdir="gnudatalanguage"
-
-
-ac_config_headers="$ac_config_headers config.h"
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking autoconf version" >&5
-$as_echo_n "checking autoconf version... " >&6; }
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: >=2.62" >&5
-$as_echo ">=2.62" >&6; }
-  am__api_version='1.11'
-
-ac_aux_dir=
-for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
-  if test -f "$ac_dir/install-sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install-sh -c"
-    break
-  elif test -f "$ac_dir/install.sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install.sh -c"
-    break
-  elif test -f "$ac_dir/shtool"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/shtool install -c"
-    break
-  fi
-done
-if test -z "$ac_aux_dir"; then
-  as_fn_error $? "cannot find install-sh, install.sh, or shtool in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" "$LINENO" 5
-fi
-
-# These three variables are undocumented and unsupported,
-# and are intended to be withdrawn in a future Autoconf release.
-# They can cause serious problems if a builder's source tree is in a directory
-# whose full name contains unusual characters.
-ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
-ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
-ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
-
-
-# Find a good install program.  We prefer a C program (faster),
-# so one script is as good as another.  But avoid the broken or
-# incompatible versions:
-# SysV /etc/install, /usr/sbin/install
-# SunOS /usr/etc/install
-# IRIX /sbin/install
-# AIX /bin/install
-# AmigaOS /C/install, which installs bootblocks on floppy discs
-# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
-# AFS /usr/afsws/bin/install, which mishandles nonexistent args
-# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
-# OS/2's system install, which has a completely different semantic
-# ./install, which can be erroneously created by make from ./install.sh.
-# Reject install programs that cannot install multiple files.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install" >&5
-$as_echo_n "checking for a BSD-compatible install... " >&6; }
-if test -z "$INSTALL"; then
-if ${ac_cv_path_install+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    # Account for people who put trailing slashes in PATH elements.
-case $as_dir/ in #((
-  ./ | .// | /[cC]/* | \
-  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
-  ?:[\\/]os2[\\/]install[\\/]* | ?:[\\/]OS2[\\/]INSTALL[\\/]* | \
-  /usr/ucb/* ) ;;
-  *)
-    # OSF1 and SCO ODT 3.0 have their own names for install.
-    # Don't use installbsd from OSF since it installs stuff as root
-    # by default.
-    for ac_prog in ginstall scoinst install; do
-      for ac_exec_ext in '' $ac_executable_extensions; do
-	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
-	  if test $ac_prog = install &&
-	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-	    # AIX install.  It has an incompatible calling convention.
-	    :
-	  elif test $ac_prog = install &&
-	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-	    # program-specific install script used by HP pwplus--don't use.
-	    :
-	  else
-	    rm -rf conftest.one conftest.two conftest.dir
-	    echo one > conftest.one
-	    echo two > conftest.two
-	    mkdir conftest.dir
-	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
-	      test -s conftest.one && test -s conftest.two &&
-	      test -s conftest.dir/conftest.one &&
-	      test -s conftest.dir/conftest.two
-	    then
-	      ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
-	      break 3
-	    fi
-	  fi
-	fi
-      done
-    done
-    ;;
-esac
-
-  done
-IFS=$as_save_IFS
-
-rm -rf conftest.one conftest.two conftest.dir
-
-fi
-  if test "${ac_cv_path_install+set}" = set; then
-    INSTALL=$ac_cv_path_install
-  else
-    # As a last resort, use the slow shell script.  Don't cache a
-    # value for INSTALL within a source directory, because that will
-    # break other packages using the cache if that directory is
-    # removed, or if the value is a relative name.
-    INSTALL=$ac_install_sh
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $INSTALL" >&5
-$as_echo "$INSTALL" >&6; }
-
-# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
-# It thinks the first close brace ends the variable substitution.
-test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
-
-test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
-
-test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether build environment is sane" >&5
-$as_echo_n "checking whether build environment is sane... " >&6; }
-# Just in case
-sleep 1
-echo timestamp > conftest.file
-# Reject unsafe characters in $srcdir or the absolute working directory
-# name.  Accept space and tab only in the latter.
-am_lf='
-'
-case `pwd` in
-  *[\\\"\#\$\&\'\`$am_lf]*)
-    as_fn_error $? "unsafe absolute working directory name" "$LINENO" 5;;
-esac
-case $srcdir in
-  *[\\\"\#\$\&\'\`$am_lf\ \	]*)
-    as_fn_error $? "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
-esac
-
-# Do `set' in a subshell so we don't clobber the current shell's
-# arguments.  Must try -L first in case configure is actually a
-# symlink; some systems play weird games with the mod time of symlinks
-# (eg FreeBSD returns the mod time of the symlink's containing
-# directory).
-if (
-   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
-   if test "$*" = "X"; then
-      # -L didn't work.
-      set X `ls -t "$srcdir/configure" conftest.file`
-   fi
-   rm -f conftest.file
-   if test "$*" != "X $srcdir/configure conftest.file" \
-      && test "$*" != "X conftest.file $srcdir/configure"; then
-
-      # If neither matched, then we have a broken ls.  This can happen
-      # if, for instance, CONFIG_SHELL is bash and it inherits a
-      # broken ls alias from the environment.  This has actually
-      # happened.  Such a system could not be considered "sane".
-      as_fn_error $? "ls -t appears to fail.  Make sure there is not a broken
-alias in your environment" "$LINENO" 5
-   fi
-
-   test "$2" = conftest.file
-   )
-then
-   # Ok.
-   :
-else
-   as_fn_error $? "newly created file is older than distributed files!
-Check your system clock" "$LINENO" 5
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-test "$program_prefix" != NONE &&
-  program_transform_name="s&^&$program_prefix&;$program_transform_name"
-# Use a double $ so make ignores it.
-test "$program_suffix" != NONE &&
-  program_transform_name="s&\$&$program_suffix&;$program_transform_name"
-# Double any \ or $.
-# By default was `s,x,x', remove it if useless.
-ac_script='s/[\\$]/&&/g;s/;s,x,x,$//'
-program_transform_name=`$as_echo "$program_transform_name" | sed "$ac_script"`
-
-# expand $ac_aux_dir to an absolute path
-am_aux_dir=`cd $ac_aux_dir && pwd`
-
-if test x"${MISSING+set}" != xset; then
-  case $am_aux_dir in
-  *\ * | *\	*)
-    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
-  *)
-    MISSING="\${SHELL} $am_aux_dir/missing" ;;
-  esac
-fi
-# Use eval to expand $SHELL
-if eval "$MISSING --run true"; then
-  am_missing_run="$MISSING --run "
-else
-  am_missing_run=
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`missing' script is too old or missing" >&5
-$as_echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
-fi
-
-if test x"${install_sh}" != xset; then
-  case $am_aux_dir in
-  *\ * | *\	*)
-    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
-  *)
-    install_sh="\${SHELL} $am_aux_dir/install-sh"
-  esac
-fi
-
-# Installed binaries are usually stripped using `strip' when the user
-# run `make install-strip'.  However `strip' might not be the right
-# tool to use in cross-compilation environments, therefore Automake
-# will honor the `STRIP' environment variable to overrule this program.
-if test "$cross_compiling" != no; then
-  if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
-set dummy ${ac_tool_prefix}strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_STRIP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$STRIP"; then
-  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-STRIP=$ac_cv_prog_STRIP
-if test -n "$STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
-$as_echo "$STRIP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_STRIP"; then
-  ac_ct_STRIP=$STRIP
-  # Extract the first word of "strip", so it can be a program name with args.
-set dummy strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_STRIP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_STRIP"; then
-  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_STRIP="strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
-if test -n "$ac_ct_STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
-$as_echo "$ac_ct_STRIP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_STRIP" = x; then
-    STRIP=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    STRIP=$ac_ct_STRIP
-  fi
-else
-  STRIP="$ac_cv_prog_STRIP"
-fi
-
-fi
-INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a thread-safe mkdir -p" >&5
-$as_echo_n "checking for a thread-safe mkdir -p... " >&6; }
-if test -z "$MKDIR_P"; then
-  if ${ac_cv_path_mkdir+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/opt/sfw/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in mkdir gmkdir; do
-	 for ac_exec_ext in '' $ac_executable_extensions; do
-	   { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; } || continue
-	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
-	     'mkdir (GNU coreutils) '* | \
-	     'mkdir (coreutils) '* | \
-	     'mkdir (fileutils) '4.1*)
-	       ac_cv_path_mkdir=$as_dir/$ac_prog$ac_exec_ext
-	       break 3;;
-	   esac
-	 done
-       done
-  done
-IFS=$as_save_IFS
-
-fi
-
-  test -d ./--version && rmdir ./--version
-  if test "${ac_cv_path_mkdir+set}" = set; then
-    MKDIR_P="$ac_cv_path_mkdir -p"
-  else
-    # As a last resort, use the slow shell script.  Don't cache a
-    # value for MKDIR_P within a source directory, because that will
-    # break other packages using the cache if that directory is
-    # removed, or if the value is a relative name.
-    MKDIR_P="$ac_install_sh -d"
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $MKDIR_P" >&5
-$as_echo "$MKDIR_P" >&6; }
-
-mkdir_p="$MKDIR_P"
-case $mkdir_p in
-  [\\/$]* | ?:[\\/]*) ;;
-  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
-esac
-
-for ac_prog in gawk mawk nawk awk
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_AWK+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$AWK"; then
-  ac_cv_prog_AWK="$AWK" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_AWK="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-AWK=$ac_cv_prog_AWK
-if test -n "$AWK"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AWK" >&5
-$as_echo "$AWK" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$AWK" && break
-done
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} sets \$(MAKE)" >&5
-$as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
-set x ${MAKE-make}
-ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
-if eval \${ac_cv_prog_make_${ac_make}_set+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat >conftest.make <<\_ACEOF
-SHELL = /bin/sh
-all:
-	@echo '@@@%%%=$(MAKE)=@@@%%%'
-_ACEOF
-# GNU make sometimes prints "make[1]: Entering ...", which would confuse us.
-case `${MAKE-make} -f conftest.make 2>/dev/null` in
-  *@@@%%%=?*=@@@%%%*)
-    eval ac_cv_prog_make_${ac_make}_set=yes;;
-  *)
-    eval ac_cv_prog_make_${ac_make}_set=no;;
-esac
-rm -f conftest.make
-fi
-if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-  SET_MAKE=
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-  SET_MAKE="MAKE=${MAKE-make}"
-fi
-
-rm -rf .tst 2>/dev/null
-mkdir .tst 2>/dev/null
-if test -d .tst; then
-  am__leading_dot=.
-else
-  am__leading_dot=_
-fi
-rmdir .tst 2>/dev/null
-
-if test "`cd $srcdir && pwd`" != "`pwd`"; then
-  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
-  # is not polluted with repeated "-I."
-  am__isrc=' -I$(srcdir)'
-  # test to see if srcdir already configured
-  if test -f $srcdir/config.status; then
-    as_fn_error $? "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
-  fi
-fi
-
-# test whether we have cygpath
-if test -z "$CYGPATH_W"; then
-  if (cygpath --version) >/dev/null 2>/dev/null; then
-    CYGPATH_W='cygpath -w'
-  else
-    CYGPATH_W=echo
-  fi
-fi
-
-
-# Define the identity of the package.
- PACKAGE='gdl'
- VERSION='0.9.2'
-
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE "$PACKAGE"
-_ACEOF
-
-
-cat >>confdefs.h <<_ACEOF
-#define VERSION "$VERSION"
-_ACEOF
-
-# Some tools Automake needs.
-
-ACLOCAL=${ACLOCAL-"${am_missing_run}aclocal-${am__api_version}"}
-
-
-AUTOCONF=${AUTOCONF-"${am_missing_run}autoconf"}
-
-
-AUTOMAKE=${AUTOMAKE-"${am_missing_run}automake-${am__api_version}"}
-
-
-AUTOHEADER=${AUTOHEADER-"${am_missing_run}autoheader"}
-
-
-MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
-
-# We need awk for the "check" target.  The system "awk" is bad on
-# some platforms.
-# Always define AMTAR for backward compatibility.
-
-AMTAR=${AMTAR-"${am_missing_run}tar"}
-
-am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'
-
-
-
-
-
-
-
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-if test -z "$CXX"; then
-  if test -n "$CCC"; then
-    CXX=$CCC
-  else
-    if test -n "$ac_tool_prefix"; then
-  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CXX+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CXX"; then
-  ac_cv_prog_CXX="$CXX" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CXX=$ac_cv_prog_CXX
-if test -n "$CXX"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CXX" >&5
-$as_echo "$CXX" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-    test -n "$CXX" && break
-  done
-fi
-if test -z "$CXX"; then
-  ac_ct_CXX=$CXX
-  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CXX+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_CXX"; then
-  ac_cv_prog_ac_ct_CXX="$ac_ct_CXX" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_CXX="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
-if test -n "$ac_ct_CXX"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CXX" >&5
-$as_echo "$ac_ct_CXX" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$ac_ct_CXX" && break
-done
-
-  if test "x$ac_ct_CXX" = x; then
-    CXX="g++"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    CXX=$ac_ct_CXX
-  fi
-fi
-
-  fi
-fi
-# Provide some information about the compiler.
-$as_echo "$as_me:${as_lineno-$LINENO}: checking for C++ compiler version" >&5
-set X $ac_compile
-ac_compiler=$2
-for ac_option in --version -v -V -qversion; do
-  { { ac_try="$ac_compiler $ac_option >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    sed '10a\
-... rest of stderr output deleted ...
-         10q' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-  fi
-  rm -f conftest.er1 conftest.err
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-done
-
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
-# Try to create an executable without -o first, disregard a.out.
-# It will help us diagnose broken compilers, and finding out an intuition
-# of exeext.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C++ compiler works" >&5
-$as_echo_n "checking whether the C++ compiler works... " >&6; }
-ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
-
-# The possible output files:
-ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
-
-ac_rmfiles=
-for ac_file in $ac_files
-do
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
-    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
-  esac
-done
-rm -f $ac_rmfiles
-
-if { { ac_try="$ac_link_default"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link_default") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
-  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
-# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
-# in a Makefile.  We should not override ac_cv_exeext if it was cached,
-# so that the user can short-circuit this test for compilers unknown to
-# Autoconf.
-for ac_file in $ac_files ''
-do
-  test -f "$ac_file" || continue
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
-	;;
-    [ab].out )
-	# We found the default executable, but exeext='' is most
-	# certainly right.
-	break;;
-    *.* )
-	if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
-	then :; else
-	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-	fi
-	# We set ac_cv_exeext here because the later test for it is not
-	# safe: cross compilers may not add the suffix if given an `-o'
-	# argument, so we may need to know it at that point already.
-	# Even if this section looks crufty: it has the advantage of
-	# actually working.
-	break;;
-    * )
-	break;;
-  esac
-done
-test "$ac_cv_exeext" = no && ac_cv_exeext=
-
-else
-  ac_file=''
-fi
-if test -z "$ac_file"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-$as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error 77 "C++ compiler cannot create executables
-See \`config.log' for more details" "$LINENO" 5; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for C++ compiler default output file name" >&5
-$as_echo_n "checking for C++ compiler default output file name... " >&6; }
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
-$as_echo "$ac_file" >&6; }
-ac_exeext=$ac_cv_exeext
-
-rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
-ac_clean_files=$ac_clean_files_save
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
-$as_echo_n "checking for suffix of executables... " >&6; }
-if { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
-  # If both `conftest.exe' and `conftest' are `present' (well, observable)
-# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
-# work properly (i.e., refer to `conftest.exe'), while it won't with
-# `rm'.
-for ac_file in conftest.exe conftest conftest.*; do
-  test -f "$ac_file" || continue
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
-    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-	  break;;
-    * ) break;;
-  esac
-done
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details" "$LINENO" 5; }
-fi
-rm -f conftest conftest$ac_cv_exeext
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
-$as_echo "$ac_cv_exeext" >&6; }
-
-rm -f conftest.$ac_ext
-EXEEXT=$ac_cv_exeext
-ac_exeext=$EXEEXT
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdio.h>
-int
-main ()
-{
-FILE *f = fopen ("conftest.out", "w");
- return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-ac_clean_files="$ac_clean_files conftest.out"
-# Check that the compiler produces executables we can run.  If not, either
-# the compiler is broken, or we cross compile.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
-$as_echo_n "checking whether we are cross compiling... " >&6; }
-if test "$cross_compiling" != yes; then
-  { { ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-  if { ac_try='./conftest$ac_cv_exeext'
-  { { case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; }; then
-    cross_compiling=no
-  else
-    if test "$cross_compiling" = maybe; then
-	cross_compiling=yes
-    else
-	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "cannot run C++ compiled programs.
-If you meant to cross compile, use \`--host'.
-See \`config.log' for more details" "$LINENO" 5; }
-    fi
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
-$as_echo "$cross_compiling" >&6; }
-
-rm -f conftest.$ac_ext conftest$ac_cv_exeext conftest.out
-ac_clean_files=$ac_clean_files_save
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
-$as_echo_n "checking for suffix of object files... " >&6; }
-if ${ac_cv_objext+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.o conftest.obj
-if { { ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compile") 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then :
-  for ac_file in conftest.o conftest.obj conftest.*; do
-  test -f "$ac_file" || continue;
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
-    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
-       break;;
-  esac
-done
-else
-  $as_echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "cannot compute suffix of object files: cannot compile
-See \`config.log' for more details" "$LINENO" 5; }
-fi
-rm -f conftest.$ac_cv_objext conftest.$ac_ext
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
-$as_echo "$ac_cv_objext" >&6; }
-OBJEXT=$ac_cv_objext
-ac_objext=$OBJEXT
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C++ compiler" >&5
-$as_echo_n "checking whether we are using the GNU C++ compiler... " >&6; }
-if ${ac_cv_cxx_compiler_gnu+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-#ifndef __GNUC__
-       choke me
-#endif
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  ac_compiler_gnu=yes
-else
-  ac_compiler_gnu=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_cxx_compiler_gnu" >&5
-$as_echo "$ac_cv_cxx_compiler_gnu" >&6; }
-if test $ac_compiler_gnu = yes; then
-  GXX=yes
-else
-  GXX=
-fi
-ac_test_CXXFLAGS=${CXXFLAGS+set}
-ac_save_CXXFLAGS=$CXXFLAGS
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CXX accepts -g" >&5
-$as_echo_n "checking whether $CXX accepts -g... " >&6; }
-if ${ac_cv_prog_cxx_g+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_save_cxx_werror_flag=$ac_cxx_werror_flag
-   ac_cxx_werror_flag=yes
-   ac_cv_prog_cxx_g=no
-   CXXFLAGS="-g"
-   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  ac_cv_prog_cxx_g=yes
-else
-  CXXFLAGS=""
-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-
-else
-  ac_cxx_werror_flag=$ac_save_cxx_werror_flag
-	 CXXFLAGS="-g"
-	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  ac_cv_prog_cxx_g=yes
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-   ac_cxx_werror_flag=$ac_save_cxx_werror_flag
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cxx_g" >&5
-$as_echo "$ac_cv_prog_cxx_g" >&6; }
-if test "$ac_test_CXXFLAGS" = set; then
-  CXXFLAGS=$ac_save_CXXFLAGS
-elif test $ac_cv_prog_cxx_g = yes; then
-  if test "$GXX" = yes; then
-    CXXFLAGS="-g -O2"
-  else
-    CXXFLAGS="-g"
-  fi
-else
-  if test "$GXX" = yes; then
-    CXXFLAGS="-O2"
-  else
-    CXXFLAGS=
-  fi
-fi
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-DEPDIR="${am__leading_dot}deps"
-
-ac_config_commands="$ac_config_commands depfiles"
-
-
-am_make=${MAKE-make}
-cat > confinc << 'END'
-am__doit:
-	@echo this is the am__doit target
-.PHONY: am__doit
-END
-# If we don't find an include directive, just comment out the code.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for style of include used by $am_make" >&5
-$as_echo_n "checking for style of include used by $am_make... " >&6; }
-am__include="#"
-am__quote=
-_am_result=none
-# First try GNU make style include.
-echo "include confinc" > confmf
-# Ignore all kinds of additional output from `make'.
-case `$am_make -s -f confmf 2> /dev/null` in #(
-*the\ am__doit\ target*)
-  am__include=include
-  am__quote=
-  _am_result=GNU
-  ;;
-esac
-# Now try BSD make style include.
-if test "$am__include" = "#"; then
-   echo '.include "confinc"' > confmf
-   case `$am_make -s -f confmf 2> /dev/null` in #(
-   *the\ am__doit\ target*)
-     am__include=.include
-     am__quote="\""
-     _am_result=BSD
-     ;;
-   esac
-fi
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $_am_result" >&5
-$as_echo "$_am_result" >&6; }
-rm -f confinc confmf
-
-# Check whether --enable-dependency-tracking was given.
-if test "${enable_dependency_tracking+set}" = set; then :
-  enableval=$enable_dependency_tracking;
-fi
-
-if test "x$enable_dependency_tracking" != xno; then
-  am_depcomp="$ac_aux_dir/depcomp"
-  AMDEPBACKSLASH='\'
-fi
- if test "x$enable_dependency_tracking" != xno; then
-  AMDEP_TRUE=
-  AMDEP_FALSE='#'
-else
-  AMDEP_TRUE='#'
-  AMDEP_FALSE=
-fi
-
-
-
-depcc="$CXX"  am_compiler_list=
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
-$as_echo_n "checking dependency style of $depcc... " >&6; }
-if ${am_cv_CXX_dependencies_compiler_type+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
-  # We make a subdir and do the tests there.  Otherwise we can end up
-  # making bogus files that we don't know about and never remove.  For
-  # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
-  mkdir conftest.dir
-  # Copy depcomp to subdir because otherwise we won't find it if we're
-  # using a relative directory.
-  cp "$am_depcomp" conftest.dir
-  cd conftest.dir
-  # We will build objects and dependencies in a subdirectory because
-  # it helps to detect inapplicable dependency modes.  For instance
-  # both Tru64's cc and ICC support -MD to output dependencies as a
-  # side effect of compilation, but ICC will put the dependencies in
-  # the current directory while Tru64 will put them in the object
-  # directory.
-  mkdir sub
-
-  am_cv_CXX_dependencies_compiler_type=none
-  if test "$am_compiler_list" = ""; then
-     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
-  fi
-  am__universal=false
-  case " $depcc " in #(
-     *\ -arch\ *\ -arch\ *) am__universal=true ;;
-     esac
-
-  for depmode in $am_compiler_list; do
-    # Setup a source with many dependencies, because some compilers
-    # like to wrap large dependency lists on column 80 (with \), and
-    # we should not choose a depcomp mode which is confused by this.
-    #
-    # We need to recreate these files for each test, as the compiler may
-    # overwrite some of them when testing with obscure command lines.
-    # This happens at least with the AIX C compiler.
-    : > sub/conftest.c
-    for i in 1 2 3 4 5 6; do
-      echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
-    done
-    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
-
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
-    # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
-    am__obj=sub/conftest.${OBJEXT-o}
-    am__minus_obj="-o $am__obj"
-    case $depmode in
-    gcc)
-      # This depmode causes a compiler race in universal mode.
-      test "$am__universal" = false || continue
-      ;;
-    nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
-      if test "x$enable_dependency_tracking" = xyes; then
-	continue
-      else
-	break
-      fi
-      ;;
-    msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
-      # not run yet.  These depmodes are late enough in the game, and
-      # so weak that their functioning should not be impacted.
-      am__obj=conftest.${OBJEXT-o}
-      am__minus_obj=
-      ;;
-    none) break ;;
-    esac
-    if depmode=$depmode \
-       source=sub/conftest.c object=$am__obj \
-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
-       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
-         >/dev/null 2>conftest.err &&
-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
-       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
-      # icc doesn't choke on unknown options, it will just issue warnings
-      # or remarks (even with -Werror).  So we grep stderr for any message
-      # that says an option was ignored or not supported.
-      # When given -MP, icc 7.0 and 7.1 complain thusly:
-      #   icc: Command line warning: ignoring option '-M'; no argument required
-      # The diagnosis changed in icc 8.0:
-      #   icc: Command line remark: option '-MP' not supported
-      if (grep 'ignoring option' conftest.err ||
-          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
-        am_cv_CXX_dependencies_compiler_type=$depmode
-        break
-      fi
-    fi
-  done
-
-  cd ..
-  rm -rf conftest.dir
-else
-  am_cv_CXX_dependencies_compiler_type=none
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_CXX_dependencies_compiler_type" >&5
-$as_echo "$am_cv_CXX_dependencies_compiler_type" >&6; }
-CXXDEPMODE=depmode=$am_cv_CXX_dependencies_compiler_type
-
- if
-  test "x$enable_dependency_tracking" != xno \
-  && test "$am_cv_CXX_dependencies_compiler_type" = gcc3; then
-  am__fastdepCXX_TRUE=
-  am__fastdepCXX_FALSE='#'
-else
-  am__fastdepCXX_TRUE='#'
-  am__fastdepCXX_FALSE=
-fi
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
-set dummy ${ac_tool_prefix}ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_RANLIB+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$RANLIB"; then
-  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-RANLIB=$ac_cv_prog_RANLIB
-if test -n "$RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
-$as_echo "$RANLIB" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_RANLIB"; then
-  ac_ct_RANLIB=$RANLIB
-  # Extract the first word of "ranlib", so it can be a program name with args.
-set dummy ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_RANLIB+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_RANLIB"; then
-  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_RANLIB="ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
-if test -n "$ac_ct_RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
-$as_echo "$ac_ct_RANLIB" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_RANLIB" = x; then
-    RANLIB=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    RANLIB=$ac_ct_RANLIB
-  fi
-else
-  RANLIB="$ac_cv_prog_RANLIB"
-fi
-
-case `pwd` in
-  *\ * | *\	*)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
-$as_echo "$as_me: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&2;} ;;
-esac
-
-
-
-macro_version='2.4'
-macro_revision='1.3293'
-
-
-
-
-
-
-
-
-
-
-
-
-
-ltmain="$ac_aux_dir/ltmain.sh"
-
-# Make sure we can run config.sub.
-$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
-  as_fn_error $? "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
-$as_echo_n "checking build system type... " >&6; }
-if ${ac_cv_build+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_build_alias=$build_alias
-test "x$ac_build_alias" = x &&
-  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
-test "x$ac_build_alias" = x &&
-  as_fn_error $? "cannot guess build type; you must specify one" "$LINENO" 5
-ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
-  as_fn_error $? "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
-$as_echo "$ac_cv_build" >&6; }
-case $ac_cv_build in
-*-*-*) ;;
-*) as_fn_error $? "invalid value of canonical build" "$LINENO" 5;;
-esac
-build=$ac_cv_build
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_build
-shift
-build_cpu=$1
-build_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-build_os=$*
-IFS=$ac_save_IFS
-case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
-$as_echo_n "checking host system type... " >&6; }
-if ${ac_cv_host+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test "x$host_alias" = x; then
-  ac_cv_host=$ac_cv_build
-else
-  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
-    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
-$as_echo "$ac_cv_host" >&6; }
-case $ac_cv_host in
-*-*-*) ;;
-*) as_fn_error $? "invalid value of canonical host" "$LINENO" 5;;
-esac
-host=$ac_cv_host
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_host
-shift
-host_cpu=$1
-host_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-host_os=$*
-IFS=$ac_save_IFS
-case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
-
-
-# Backslashify metacharacters that are still active within
-# double-quoted strings.
-sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
-
-# Same as above, but do not quote variable references.
-double_quote_subst='s/\(["`\\]\)/\\\1/g'
-
-# Sed substitution to delay expansion of an escaped shell variable in a
-# double_quote_subst'ed string.
-delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
-
-# Sed substitution to delay expansion of an escaped single quote.
-delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
-
-# Sed substitution to avoid accidental globbing in evaled expressions
-no_glob_subst='s/\*/\\\*/g'
-
-ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
-ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to print strings" >&5
-$as_echo_n "checking how to print strings... " >&6; }
-# Test print first, because it will be a builtin if present.
-if test "X`( print -r -- -n ) 2>/dev/null`" = X-n && \
-   test "X`print -r -- $ECHO 2>/dev/null`" = "X$ECHO"; then
-  ECHO='print -r --'
-elif test "X`printf %s $ECHO 2>/dev/null`" = "X$ECHO"; then
-  ECHO='printf %s\n'
-else
-  # Use this function as a fallback that always works.
-  func_fallback_echo ()
-  {
-    eval 'cat <<_LTECHO_EOF
-$1
-_LTECHO_EOF'
-  }
-  ECHO='func_fallback_echo'
-fi
-
-# func_echo_all arg...
-# Invoke $ECHO with all args, space-separated.
-func_echo_all ()
-{
-    $ECHO ""
-}
-
-case "$ECHO" in
-  printf*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: printf" >&5
-$as_echo "printf" >&6; } ;;
-  print*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: print -r" >&5
-$as_echo "print -r" >&6; } ;;
-  *) { $as_echo "$as_me:${as_lineno-$LINENO}: result: cat" >&5
-$as_echo "cat" >&6; } ;;
-esac
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CC="${ac_tool_prefix}gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_CC"; then
-  ac_ct_CC=$CC
-  # Extract the first word of "gcc", so it can be a program name with args.
-set dummy gcc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_CC="gcc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_CC" = x; then
-    CC=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    CC=$ac_ct_CC
-  fi
-else
-  CC="$ac_cv_prog_CC"
-fi
-
-if test -z "$CC"; then
-          if test -n "$ac_tool_prefix"; then
-    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}cc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CC="${ac_tool_prefix}cc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  fi
-fi
-if test -z "$CC"; then
-  # Extract the first word of "cc", so it can be a program name with args.
-set dummy cc; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-  ac_prog_rejected=no
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
-       ac_prog_rejected=yes
-       continue
-     fi
-    ac_cv_prog_CC="cc"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-if test $ac_prog_rejected = yes; then
-  # We found a bogon in the path, so make sure we never use it.
-  set dummy $ac_cv_prog_CC
-  shift
-  if test $# != 0; then
-    # We chose a different compiler from the bogus one.
-    # However, it has the same basename, so the bogon will be chosen
-    # first if we set CC to just the basename; use the full file name.
-    shift
-    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
-  fi
-fi
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$CC"; then
-  if test -n "$ac_tool_prefix"; then
-  for ac_prog in cl.exe
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
-$as_echo "$CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-    test -n "$CC" && break
-  done
-fi
-if test -z "$CC"; then
-  ac_ct_CC=$CC
-  for ac_prog in cl.exe
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_CC+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_CC="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
-$as_echo "$ac_ct_CC" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$ac_ct_CC" && break
-done
-
-  if test "x$ac_ct_CC" = x; then
-    CC=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    CC=$ac_ct_CC
-  fi
-fi
-
-fi
-
-
-test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "no acceptable C compiler found in \$PATH
-See \`config.log' for more details" "$LINENO" 5; }
-
-# Provide some information about the compiler.
-$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
-set X $ac_compile
-ac_compiler=$2
-for ac_option in --version -v -V -qversion; do
-  { { ac_try="$ac_compiler $ac_option >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
-$as_echo "$ac_try_echo"; } >&5
-  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
-  ac_status=$?
-  if test -s conftest.err; then
-    sed '10a\
-... rest of stderr output deleted ...
-         10q' conftest.err >conftest.er1
-    cat conftest.er1 >&5
-  fi
-  rm -f conftest.er1 conftest.err
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-done
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
-$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
-if ${ac_cv_c_compiler_gnu+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-#ifndef __GNUC__
-       choke me
-#endif
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_compiler_gnu=yes
-else
-  ac_compiler_gnu=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-ac_cv_c_compiler_gnu=$ac_compiler_gnu
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
-$as_echo "$ac_cv_c_compiler_gnu" >&6; }
-if test $ac_compiler_gnu = yes; then
-  GCC=yes
-else
-  GCC=
-fi
-ac_test_CFLAGS=${CFLAGS+set}
-ac_save_CFLAGS=$CFLAGS
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
-$as_echo_n "checking whether $CC accepts -g... " >&6; }
-if ${ac_cv_prog_cc_g+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_save_c_werror_flag=$ac_c_werror_flag
-   ac_c_werror_flag=yes
-   ac_cv_prog_cc_g=no
-   CFLAGS="-g"
-   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_g=yes
-else
-  CFLAGS=""
-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-
-else
-  ac_c_werror_flag=$ac_save_c_werror_flag
-	 CFLAGS="-g"
-	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_g=yes
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-   ac_c_werror_flag=$ac_save_c_werror_flag
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
-$as_echo "$ac_cv_prog_cc_g" >&6; }
-if test "$ac_test_CFLAGS" = set; then
-  CFLAGS=$ac_save_CFLAGS
-elif test $ac_cv_prog_cc_g = yes; then
-  if test "$GCC" = yes; then
-    CFLAGS="-g -O2"
-  else
-    CFLAGS="-g"
-  fi
-else
-  if test "$GCC" = yes; then
-    CFLAGS="-O2"
-  else
-    CFLAGS=
-  fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
-$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
-if ${ac_cv_prog_cc_c89+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_cv_prog_cc_c89=no
-ac_save_CC=$CC
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdarg.h>
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
-struct buf { int x; };
-FILE * (*rcsopen) (struct buf *, struct stat *, int);
-static char *e (p, i)
-     char **p;
-     int i;
-{
-  return p[i];
-}
-static char *f (char * (*g) (char **, int), char **p, ...)
-{
-  char *s;
-  va_list v;
-  va_start (v,p);
-  s = g (p, va_arg (v,int));
-  va_end (v);
-  return s;
-}
-
-/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
-   function prototypes and stuff, but not '\xHH' hex character constants.
-   These don't provoke an error unfortunately, instead are silently treated
-   as 'x'.  The following induces an error, until -std is added to get
-   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
-   array size at least.  It's necessary to write '\x00'==0 to get something
-   that's true only with -std.  */
-int osf4_cc_array ['\x00' == 0 ? 1 : -1];
-
-/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
-   inside strings and character constants.  */
-#define FOO(x) 'x'
-int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
-
-int test (int i, double x);
-struct s1 {int (*f) (int a);};
-struct s2 {int (*f) (double a);};
-int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
-int argc;
-char **argv;
-int
-main ()
-{
-return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
-  ;
-  return 0;
-}
-_ACEOF
-for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
-	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
-do
-  CC="$ac_save_CC $ac_arg"
-  if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_prog_cc_c89=$ac_arg
-fi
-rm -f core conftest.err conftest.$ac_objext
-  test "x$ac_cv_prog_cc_c89" != "xno" && break
-done
-rm -f conftest.$ac_ext
-CC=$ac_save_CC
-
-fi
-# AC_CACHE_VAL
-case "x$ac_cv_prog_cc_c89" in
-  x)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
-$as_echo "none needed" >&6; } ;;
-  xno)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
-$as_echo "unsupported" >&6; } ;;
-  *)
-    CC="$CC $ac_cv_prog_cc_c89"
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
-$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
-esac
-if test "x$ac_cv_prog_cc_c89" != xno; then :
-
-fi
-
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-
-depcc="$CC"   am_compiler_list=
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
-$as_echo_n "checking dependency style of $depcc... " >&6; }
-if ${am_cv_CC_dependencies_compiler_type+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
-  # We make a subdir and do the tests there.  Otherwise we can end up
-  # making bogus files that we don't know about and never remove.  For
-  # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
-  mkdir conftest.dir
-  # Copy depcomp to subdir because otherwise we won't find it if we're
-  # using a relative directory.
-  cp "$am_depcomp" conftest.dir
-  cd conftest.dir
-  # We will build objects and dependencies in a subdirectory because
-  # it helps to detect inapplicable dependency modes.  For instance
-  # both Tru64's cc and ICC support -MD to output dependencies as a
-  # side effect of compilation, but ICC will put the dependencies in
-  # the current directory while Tru64 will put them in the object
-  # directory.
-  mkdir sub
-
-  am_cv_CC_dependencies_compiler_type=none
-  if test "$am_compiler_list" = ""; then
-     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
-  fi
-  am__universal=false
-  case " $depcc " in #(
-     *\ -arch\ *\ -arch\ *) am__universal=true ;;
-     esac
-
-  for depmode in $am_compiler_list; do
-    # Setup a source with many dependencies, because some compilers
-    # like to wrap large dependency lists on column 80 (with \), and
-    # we should not choose a depcomp mode which is confused by this.
-    #
-    # We need to recreate these files for each test, as the compiler may
-    # overwrite some of them when testing with obscure command lines.
-    # This happens at least with the AIX C compiler.
-    : > sub/conftest.c
-    for i in 1 2 3 4 5 6; do
-      echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
-    done
-    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
-
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
-    # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
-    am__obj=sub/conftest.${OBJEXT-o}
-    am__minus_obj="-o $am__obj"
-    case $depmode in
-    gcc)
-      # This depmode causes a compiler race in universal mode.
-      test "$am__universal" = false || continue
-      ;;
-    nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
-      if test "x$enable_dependency_tracking" = xyes; then
-	continue
-      else
-	break
-      fi
-      ;;
-    msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
-      # not run yet.  These depmodes are late enough in the game, and
-      # so weak that their functioning should not be impacted.
-      am__obj=conftest.${OBJEXT-o}
-      am__minus_obj=
-      ;;
-    none) break ;;
-    esac
-    if depmode=$depmode \
-       source=sub/conftest.c object=$am__obj \
-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
-       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
-         >/dev/null 2>conftest.err &&
-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
-       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
-      # icc doesn't choke on unknown options, it will just issue warnings
-      # or remarks (even with -Werror).  So we grep stderr for any message
-      # that says an option was ignored or not supported.
-      # When given -MP, icc 7.0 and 7.1 complain thusly:
-      #   icc: Command line warning: ignoring option '-M'; no argument required
-      # The diagnosis changed in icc 8.0:
-      #   icc: Command line remark: option '-MP' not supported
-      if (grep 'ignoring option' conftest.err ||
-          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
-        am_cv_CC_dependencies_compiler_type=$depmode
-        break
-      fi
-    fi
-  done
-
-  cd ..
-  rm -rf conftest.dir
-else
-  am_cv_CC_dependencies_compiler_type=none
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_CC_dependencies_compiler_type" >&5
-$as_echo "$am_cv_CC_dependencies_compiler_type" >&6; }
-CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
-
- if
-  test "x$enable_dependency_tracking" != xno \
-  && test "$am_cv_CC_dependencies_compiler_type" = gcc3; then
-  am__fastdepCC_TRUE=
-  am__fastdepCC_FALSE='#'
-else
-  am__fastdepCC_TRUE='#'
-  am__fastdepCC_FALSE=
-fi
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
-$as_echo_n "checking for a sed that does not truncate output... " >&6; }
-if ${ac_cv_path_SED+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-            ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
-     for ac_i in 1 2 3 4 5 6 7; do
-       ac_script="$ac_script$as_nl$ac_script"
-     done
-     echo "$ac_script" 2>/dev/null | sed 99q >conftest.sed
-     { ac_script=; unset ac_script;}
-     if test -z "$SED"; then
-  ac_path_SED_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in sed gsed; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_SED" && $as_test_x "$ac_path_SED"; } || continue
-# Check for GNU ac_path_SED and select it if it is found.
-  # Check for GNU $ac_path_SED
-case `"$ac_path_SED" --version 2>&1` in
-*GNU*)
-  ac_cv_path_SED="$ac_path_SED" ac_path_SED_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo '' >> "conftest.nl"
-    "$ac_path_SED" -f conftest.sed < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_SED_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_SED="$ac_path_SED"
-      ac_path_SED_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_SED_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_SED"; then
-    as_fn_error $? "no acceptable sed could be found in \$PATH" "$LINENO" 5
-  fi
-else
-  ac_cv_path_SED=$SED
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_SED" >&5
-$as_echo "$ac_cv_path_SED" >&6; }
- SED="$ac_cv_path_SED"
-  rm -f conftest.sed
-
-test -z "$SED" && SED=sed
-Xsed="$SED -e 1s/^X//"
-
-
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
-$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
-if ${ac_cv_path_GREP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$GREP"; then
-  ac_path_GREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in grep ggrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
-# Check for GNU ac_path_GREP and select it if it is found.
-  # Check for GNU $ac_path_GREP
-case `"$ac_path_GREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'GREP' >> "conftest.nl"
-    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_GREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_GREP="$ac_path_GREP"
-      ac_path_GREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_GREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_GREP"; then
-    as_fn_error $? "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
-  fi
-else
-  ac_cv_path_GREP=$GREP
-fi
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
-$as_echo "$ac_cv_path_GREP" >&6; }
- GREP="$ac_cv_path_GREP"
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
-$as_echo_n "checking for egrep... " >&6; }
-if ${ac_cv_path_EGREP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
-   then ac_cv_path_EGREP="$GREP -E"
-   else
-     if test -z "$EGREP"; then
-  ac_path_EGREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in egrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
-# Check for GNU ac_path_EGREP and select it if it is found.
-  # Check for GNU $ac_path_EGREP
-case `"$ac_path_EGREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'EGREP' >> "conftest.nl"
-    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_EGREP="$ac_path_EGREP"
-      ac_path_EGREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_EGREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_EGREP"; then
-    as_fn_error $? "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
-  fi
-else
-  ac_cv_path_EGREP=$EGREP
-fi
-
-   fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
-$as_echo "$ac_cv_path_EGREP" >&6; }
- EGREP="$ac_cv_path_EGREP"
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for fgrep" >&5
-$as_echo_n "checking for fgrep... " >&6; }
-if ${ac_cv_path_FGREP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if echo 'ab*c' | $GREP -F 'ab*c' >/dev/null 2>&1
-   then ac_cv_path_FGREP="$GREP -F"
-   else
-     if test -z "$FGREP"; then
-  ac_path_FGREP_found=false
-  # Loop through the user's path and test for each of PROGNAME-LIST
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_prog in fgrep; do
-    for ac_exec_ext in '' $ac_executable_extensions; do
-      ac_path_FGREP="$as_dir/$ac_prog$ac_exec_ext"
-      { test -f "$ac_path_FGREP" && $as_test_x "$ac_path_FGREP"; } || continue
-# Check for GNU ac_path_FGREP and select it if it is found.
-  # Check for GNU $ac_path_FGREP
-case `"$ac_path_FGREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_FGREP="$ac_path_FGREP" ac_path_FGREP_found=:;;
-*)
-  ac_count=0
-  $as_echo_n 0123456789 >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    $as_echo 'FGREP' >> "conftest.nl"
-    "$ac_path_FGREP" FGREP < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    as_fn_arith $ac_count + 1 && ac_count=$as_val
-    if test $ac_count -gt ${ac_path_FGREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_FGREP="$ac_path_FGREP"
-      ac_path_FGREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-      $ac_path_FGREP_found && break 3
-    done
-  done
-  done
-IFS=$as_save_IFS
-  if test -z "$ac_cv_path_FGREP"; then
-    as_fn_error $? "no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
-  fi
-else
-  ac_cv_path_FGREP=$FGREP
-fi
-
-   fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_FGREP" >&5
-$as_echo "$ac_cv_path_FGREP" >&6; }
- FGREP="$ac_cv_path_FGREP"
-
-
-test -z "$GREP" && GREP=grep
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-# Check whether --with-gnu-ld was given.
-if test "${with_gnu_ld+set}" = set; then :
-  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
-else
-  with_gnu_ld=no
-fi
-
-ac_prog=ld
-if test "$GCC" = yes; then
-  # Check if gcc -print-prog-name=ld gives a path.
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
-$as_echo_n "checking for ld used by $CC... " >&6; }
-  case $host in
-  *-*-mingw*)
-    # gcc leaves a trailing carriage return which upsets mingw
-    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
-  *)
-    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
-  esac
-  case $ac_prog in
-    # Accept absolute paths.
-    [\\/]* | ?:[\\/]*)
-      re_direlt='/[^/][^/]*/\.\./'
-      # Canonicalize the pathname of ld
-      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
-      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
-	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
-      done
-      test -z "$LD" && LD="$ac_prog"
-      ;;
-  "")
-    # If it fails, then pretend we aren't using GCC.
-    ac_prog=ld
-    ;;
-  *)
-    # If it is relative, then search for the first ld in PATH.
-    with_gnu_ld=unknown
-    ;;
-  esac
-elif test "$with_gnu_ld" = yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
-$as_echo_n "checking for GNU ld... " >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for non-GNU ld" >&5
-$as_echo_n "checking for non-GNU ld... " >&6; }
-fi
-if ${lt_cv_path_LD+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$LD"; then
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-  for ac_dir in $PATH; do
-    IFS="$lt_save_ifs"
-    test -z "$ac_dir" && ac_dir=.
-    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
-      lt_cv_path_LD="$ac_dir/$ac_prog"
-      # Check to see if the program is GNU ld.  I'd rather use --version,
-      # but apparently some variants of GNU ld only accept -v.
-      # Break only if it was the GNU/non-GNU ld that we prefer.
-      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
-      *GNU* | *'with BFD'*)
-	test "$with_gnu_ld" != no && break
-	;;
-      *)
-	test "$with_gnu_ld" != yes && break
-	;;
-      esac
-    fi
-  done
-  IFS="$lt_save_ifs"
-else
-  lt_cv_path_LD="$LD" # Let the user override the test with a path.
-fi
-fi
-
-LD="$lt_cv_path_LD"
-if test -n "$LD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
-$as_echo "$LD" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-test -z "$LD" && as_fn_error $? "no acceptable ld found in \$PATH" "$LINENO" 5
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
-$as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
-if ${lt_cv_prog_gnu_ld+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  # I'd rather use --version here, but apparently some GNU lds only accept -v.
-case `$LD -v 2>&1 </dev/null` in
-*GNU* | *'with BFD'*)
-  lt_cv_prog_gnu_ld=yes
-  ;;
-*)
-  lt_cv_prog_gnu_ld=no
-  ;;
-esac
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_gnu_ld" >&5
-$as_echo "$lt_cv_prog_gnu_ld" >&6; }
-with_gnu_ld=$lt_cv_prog_gnu_ld
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for BSD- or MS-compatible name lister (nm)" >&5
-$as_echo_n "checking for BSD- or MS-compatible name lister (nm)... " >&6; }
-if ${lt_cv_path_NM+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$NM"; then
-  # Let the user override the test.
-  lt_cv_path_NM="$NM"
-else
-  lt_nm_to_check="${ac_tool_prefix}nm"
-  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
-    lt_nm_to_check="$lt_nm_to_check nm"
-  fi
-  for lt_tmp_nm in $lt_nm_to_check; do
-    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
-      IFS="$lt_save_ifs"
-      test -z "$ac_dir" && ac_dir=.
-      tmp_nm="$ac_dir/$lt_tmp_nm"
-      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
-	# Check to see if the nm accepts a BSD-compat flag.
-	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
-	#   nm: unknown option "B" ignored
-	# Tru64's nm complains that /dev/null is an invalid object file
-	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
-	*/dev/null* | *'Invalid file or object type'*)
-	  lt_cv_path_NM="$tmp_nm -B"
-	  break
-	  ;;
-	*)
-	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
-	  */dev/null*)
-	    lt_cv_path_NM="$tmp_nm -p"
-	    break
-	    ;;
-	  *)
-	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
-	    continue # so that we can try to find one that supports BSD flags
-	    ;;
-	  esac
-	  ;;
-	esac
-      fi
-    done
-    IFS="$lt_save_ifs"
-  done
-  : ${lt_cv_path_NM=no}
-fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_path_NM" >&5
-$as_echo "$lt_cv_path_NM" >&6; }
-if test "$lt_cv_path_NM" != "no"; then
-  NM="$lt_cv_path_NM"
-else
-  # Didn't find any BSD compatible name lister, look for dumpbin.
-  if test -n "$DUMPBIN"; then :
-    # Let the user override the test.
-  else
-    if test -n "$ac_tool_prefix"; then
-  for ac_prog in dumpbin "link -dump"
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_DUMPBIN+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$DUMPBIN"; then
-  ac_cv_prog_DUMPBIN="$DUMPBIN" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_DUMPBIN="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-DUMPBIN=$ac_cv_prog_DUMPBIN
-if test -n "$DUMPBIN"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DUMPBIN" >&5
-$as_echo "$DUMPBIN" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-    test -n "$DUMPBIN" && break
-  done
-fi
-if test -z "$DUMPBIN"; then
-  ac_ct_DUMPBIN=$DUMPBIN
-  for ac_prog in dumpbin "link -dump"
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_DUMPBIN+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_DUMPBIN"; then
-  ac_cv_prog_ac_ct_DUMPBIN="$ac_ct_DUMPBIN" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_DUMPBIN="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_DUMPBIN=$ac_cv_prog_ac_ct_DUMPBIN
-if test -n "$ac_ct_DUMPBIN"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DUMPBIN" >&5
-$as_echo "$ac_ct_DUMPBIN" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$ac_ct_DUMPBIN" && break
-done
-
-  if test "x$ac_ct_DUMPBIN" = x; then
-    DUMPBIN=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    DUMPBIN=$ac_ct_DUMPBIN
-  fi
-fi
-
-    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in
-    *COFF*)
-      DUMPBIN="$DUMPBIN -symbols"
-      ;;
-    *)
-      DUMPBIN=:
-      ;;
-    esac
-  fi
-
-  if test "$DUMPBIN" != ":"; then
-    NM="$DUMPBIN"
-  fi
-fi
-test -z "$NM" && NM=nm
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the name lister ($NM) interface" >&5
-$as_echo_n "checking the name lister ($NM) interface... " >&6; }
-if ${lt_cv_nm_interface+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_nm_interface="BSD nm"
-  echo "int some_variable = 0;" > conftest.$ac_ext
-  (eval echo "\"\$as_me:$LINENO: $ac_compile\"" >&5)
-  (eval "$ac_compile" 2>conftest.err)
-  cat conftest.err >&5
-  (eval echo "\"\$as_me:$LINENO: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
-  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
-  cat conftest.err >&5
-  (eval echo "\"\$as_me:$LINENO: output\"" >&5)
-  cat conftest.out >&5
-  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
-    lt_cv_nm_interface="MS dumpbin"
-  fi
-  rm -f conftest*
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_nm_interface" >&5
-$as_echo "$lt_cv_nm_interface" >&6; }
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ln -s works" >&5
-$as_echo_n "checking whether ln -s works... " >&6; }
-LN_S=$as_ln_s
-if test "$LN_S" = "ln -s"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no, using $LN_S" >&5
-$as_echo "no, using $LN_S" >&6; }
-fi
-
-# find the maximum length of command line arguments
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the maximum length of command line arguments" >&5
-$as_echo_n "checking the maximum length of command line arguments... " >&6; }
-if ${lt_cv_sys_max_cmd_len+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-    i=0
-  teststring="ABCD"
-
-  case $build_os in
-  msdosdjgpp*)
-    # On DJGPP, this test can blow up pretty badly due to problems in libc
-    # (any single argument exceeding 2000 bytes causes a buffer overrun
-    # during glob expansion).  Even if it were fixed, the result of this
-    # check would be larger than it should be.
-    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
-    ;;
-
-  gnu*)
-    # Under GNU Hurd, this test is not required because there is
-    # no limit to the length of command line arguments.
-    # Libtool will interpret -1 as no limit whatsoever
-    lt_cv_sys_max_cmd_len=-1;
-    ;;
-
-  cygwin* | mingw* | cegcc*)
-    # On Win9x/ME, this test blows up -- it succeeds, but takes
-    # about 5 minutes as the teststring grows exponentially.
-    # Worse, since 9x/ME are not pre-emptively multitasking,
-    # you end up with a "frozen" computer, even though with patience
-    # the test eventually succeeds (with a max line length of 256k).
-    # Instead, let's just punt: use the minimum linelength reported by
-    # all of the supported platforms: 8192 (on NT/2K/XP).
-    lt_cv_sys_max_cmd_len=8192;
-    ;;
-
-  mint*)
-    # On MiNT this can take a long time and run out of memory.
-    lt_cv_sys_max_cmd_len=8192;
-    ;;
-
-  amigaos*)
-    # On AmigaOS with pdksh, this test takes hours, literally.
-    # So we just punt and use a minimum line length of 8192.
-    lt_cv_sys_max_cmd_len=8192;
-    ;;
-
-  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
-    # This has been around since 386BSD, at least.  Likely further.
-    if test -x /sbin/sysctl; then
-      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
-    elif test -x /usr/sbin/sysctl; then
-      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
-    else
-      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
-    fi
-    # And add a safety zone
-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
-    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
-    ;;
-
-  interix*)
-    # We know the value 262144 and hardcode it with a safety zone (like BSD)
-    lt_cv_sys_max_cmd_len=196608
-    ;;
-
-  osf*)
-    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
-    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
-    # nice to cause kernel panics so lets avoid the loop below.
-    # First set a reasonable default.
-    lt_cv_sys_max_cmd_len=16384
-    #
-    if test -x /sbin/sysconfig; then
-      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
-        *1*) lt_cv_sys_max_cmd_len=-1 ;;
-      esac
-    fi
-    ;;
-  sco3.2v5*)
-    lt_cv_sys_max_cmd_len=102400
-    ;;
-  sysv5* | sco5v6* | sysv4.2uw2*)
-    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
-    if test -n "$kargmax"; then
-      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[	 ]//'`
-    else
-      lt_cv_sys_max_cmd_len=32768
-    fi
-    ;;
-  *)
-    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
-    if test -n "$lt_cv_sys_max_cmd_len"; then
-      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
-      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
-    else
-      # Make teststring a little bigger before we do anything with it.
-      # a 1K string should be a reasonable start.
-      for i in 1 2 3 4 5 6 7 8 ; do
-        teststring=$teststring$teststring
-      done
-      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
-      # If test is not a shell built-in, we'll probably end up computing a
-      # maximum length that is only half of the actual maximum length, but
-      # we can't tell.
-      while { test "X"`func_fallback_echo "$teststring$teststring" 2>/dev/null` \
-	         = "X$teststring$teststring"; } >/dev/null 2>&1 &&
-	      test $i != 17 # 1/2 MB should be enough
-      do
-        i=`expr $i + 1`
-        teststring=$teststring$teststring
-      done
-      # Only check the string length outside the loop.
-      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
-      teststring=
-      # Add a significant safety factor because C++ compilers can tack on
-      # massive amounts of additional arguments before passing them to the
-      # linker.  It appears as though 1/2 is a usable value.
-      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
-    fi
-    ;;
-  esac
-
-fi
-
-if test -n $lt_cv_sys_max_cmd_len ; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_sys_max_cmd_len" >&5
-$as_echo "$lt_cv_sys_max_cmd_len" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: none" >&5
-$as_echo "none" >&6; }
-fi
-max_cmd_len=$lt_cv_sys_max_cmd_len
-
-
-
-
-
-
-: ${CP="cp -f"}
-: ${MV="mv -f"}
-: ${RM="rm -f"}
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands some XSI constructs" >&5
-$as_echo_n "checking whether the shell understands some XSI constructs... " >&6; }
-# Try some XSI features
-xsi_shell=no
-( _lt_dummy="a/b/c"
-  test "${_lt_dummy##*/},${_lt_dummy%/*},${_lt_dummy#??}"${_lt_dummy%"$_lt_dummy"}, \
-      = c,a/b,b/c, \
-    && eval 'test $(( 1 + 1 )) -eq 2 \
-    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
-  && xsi_shell=yes
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $xsi_shell" >&5
-$as_echo "$xsi_shell" >&6; }
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands \"+=\"" >&5
-$as_echo_n "checking whether the shell understands \"+=\"... " >&6; }
-lt_shell_append=no
-( foo=bar; set foo baz; eval "$1+=\$2" && test "$foo" = barbaz ) \
-    >/dev/null 2>&1 \
-  && lt_shell_append=yes
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_shell_append" >&5
-$as_echo "$lt_shell_append" >&6; }
-
-
-if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
-  lt_unset=unset
-else
-  lt_unset=false
-fi
-
-
-
-
-
-# test EBCDIC or ASCII
-case `echo X|tr X '\101'` in
- A) # ASCII based system
-    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
-  lt_SP2NL='tr \040 \012'
-  lt_NL2SP='tr \015\012 \040\040'
-  ;;
- *) # EBCDIC based system
-  lt_SP2NL='tr \100 \n'
-  lt_NL2SP='tr \r\n \100\100'
-  ;;
-esac
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to convert $build file names to $host format" >&5
-$as_echo_n "checking how to convert $build file names to $host format... " >&6; }
-if ${lt_cv_to_host_file_cmd+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $host in
-  *-*-mingw* )
-    case $build in
-      *-*-mingw* ) # actually msys
-        lt_cv_to_host_file_cmd=func_convert_file_msys_to_w32
-        ;;
-      *-*-cygwin* )
-        lt_cv_to_host_file_cmd=func_convert_file_cygwin_to_w32
-        ;;
-      * ) # otherwise, assume *nix
-        lt_cv_to_host_file_cmd=func_convert_file_nix_to_w32
-        ;;
-    esac
-    ;;
-  *-*-cygwin* )
-    case $build in
-      *-*-mingw* ) # actually msys
-        lt_cv_to_host_file_cmd=func_convert_file_msys_to_cygwin
-        ;;
-      *-*-cygwin* )
-        lt_cv_to_host_file_cmd=func_convert_file_noop
-        ;;
-      * ) # otherwise, assume *nix
-        lt_cv_to_host_file_cmd=func_convert_file_nix_to_cygwin
-        ;;
-    esac
-    ;;
-  * ) # unhandled hosts (and "normal" native builds)
-    lt_cv_to_host_file_cmd=func_convert_file_noop
-    ;;
-esac
-
-fi
-
-to_host_file_cmd=$lt_cv_to_host_file_cmd
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_to_host_file_cmd" >&5
-$as_echo "$lt_cv_to_host_file_cmd" >&6; }
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to convert $build file names to toolchain format" >&5
-$as_echo_n "checking how to convert $build file names to toolchain format... " >&6; }
-if ${lt_cv_to_tool_file_cmd+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  #assume ordinary cross tools, or native build.
-lt_cv_to_tool_file_cmd=func_convert_file_noop
-case $host in
-  *-*-mingw* )
-    case $build in
-      *-*-mingw* ) # actually msys
-        lt_cv_to_tool_file_cmd=func_convert_file_msys_to_w32
-        ;;
-    esac
-    ;;
-esac
-
-fi
-
-to_tool_file_cmd=$lt_cv_to_tool_file_cmd
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_to_tool_file_cmd" >&5
-$as_echo "$lt_cv_to_tool_file_cmd" >&6; }
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $LD option to reload object files" >&5
-$as_echo_n "checking for $LD option to reload object files... " >&6; }
-if ${lt_cv_ld_reload_flag+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_ld_reload_flag='-r'
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_reload_flag" >&5
-$as_echo "$lt_cv_ld_reload_flag" >&6; }
-reload_flag=$lt_cv_ld_reload_flag
-case $reload_flag in
-"" | " "*) ;;
-*) reload_flag=" $reload_flag" ;;
-esac
-reload_cmds='$LD$reload_flag -o $output$reload_objs'
-case $host_os in
-  cygwin* | mingw* | pw32* | cegcc*)
-    if test "$GCC" != yes; then
-      reload_cmds=false
-    fi
-    ;;
-  darwin*)
-    if test "$GCC" = yes; then
-      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
-    else
-      reload_cmds='$LD$reload_flag -o $output$reload_objs'
-    fi
-    ;;
-esac
-
-
-
-
-
-
-
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}objdump", so it can be a program name with args.
-set dummy ${ac_tool_prefix}objdump; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_OBJDUMP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$OBJDUMP"; then
-  ac_cv_prog_OBJDUMP="$OBJDUMP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_OBJDUMP="${ac_tool_prefix}objdump"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-OBJDUMP=$ac_cv_prog_OBJDUMP
-if test -n "$OBJDUMP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OBJDUMP" >&5
-$as_echo "$OBJDUMP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_OBJDUMP"; then
-  ac_ct_OBJDUMP=$OBJDUMP
-  # Extract the first word of "objdump", so it can be a program name with args.
-set dummy objdump; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_OBJDUMP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_OBJDUMP"; then
-  ac_cv_prog_ac_ct_OBJDUMP="$ac_ct_OBJDUMP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_OBJDUMP="objdump"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_OBJDUMP=$ac_cv_prog_ac_ct_OBJDUMP
-if test -n "$ac_ct_OBJDUMP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OBJDUMP" >&5
-$as_echo "$ac_ct_OBJDUMP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_OBJDUMP" = x; then
-    OBJDUMP="false"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    OBJDUMP=$ac_ct_OBJDUMP
-  fi
-else
-  OBJDUMP="$ac_cv_prog_OBJDUMP"
-fi
-
-test -z "$OBJDUMP" && OBJDUMP=objdump
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to recognize dependent libraries" >&5
-$as_echo_n "checking how to recognize dependent libraries... " >&6; }
-if ${lt_cv_deplibs_check_method+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_file_magic_cmd='$MAGIC_CMD'
-lt_cv_file_magic_test_file=
-lt_cv_deplibs_check_method='unknown'
-# Need to set the preceding variable on all platforms that support
-# interlibrary dependencies.
-# 'none' -- dependencies not supported.
-# `unknown' -- same as none, but documents that we really don't know.
-# 'pass_all' -- all dependencies passed with no checks.
-# 'test_compile' -- check by making test program.
-# 'file_magic [[regex]]' -- check by looking for files in library path
-# which responds to the $file_magic_cmd with a given extended regex.
-# If you have `file' or equivalent on your system and you're not sure
-# whether `pass_all' will *always* work, you probably want this one.
-
-case $host_os in
-aix[4-9]*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-beos*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-bsdi[45]*)
-  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib)'
-  lt_cv_file_magic_cmd='/usr/bin/file -L'
-  lt_cv_file_magic_test_file=/shlib/libc.so
-  ;;
-
-cygwin*)
-  # func_win32_libid is a shell function defined in ltmain.sh
-  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
-  lt_cv_file_magic_cmd='func_win32_libid'
-  ;;
-
-mingw* | pw32*)
-  # Base MSYS/MinGW do not provide the 'file' command needed by
-  # func_win32_libid shell function, so use a weaker test based on 'objdump',
-  # unless we find 'file', for example because we are cross-compiling.
-  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.
-  if ( test "$lt_cv_nm_interface" = "BSD nm" && file / ) >/dev/null 2>&1; then
-    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
-    lt_cv_file_magic_cmd='func_win32_libid'
-  else
-    # Keep this pattern in sync with the one in func_win32_libid.
-    lt_cv_deplibs_check_method='file_magic file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)'
-    lt_cv_file_magic_cmd='$OBJDUMP -f'
-  fi
-  ;;
-
-cegcc*)
-  # use the weaker test based on 'objdump'. See mingw*.
-  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'
-  lt_cv_file_magic_cmd='$OBJDUMP -f'
-  ;;
-
-darwin* | rhapsody*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-freebsd* | dragonfly*)
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
-    case $host_cpu in
-    i*86 )
-      # Not sure whether the presence of OpenBSD here was a mistake.
-      # Let's accept both of them until this is cleared up.
-      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[3-9]86 (compact )?demand paged shared library'
-      lt_cv_file_magic_cmd=/usr/bin/file
-      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
-      ;;
-    esac
-  else
-    lt_cv_deplibs_check_method=pass_all
-  fi
-  ;;
-
-gnu*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-haiku*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-hpux10.20* | hpux11*)
-  lt_cv_file_magic_cmd=/usr/bin/file
-  case $host_cpu in
-  ia64*)
-    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - IA64'
-    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
-    ;;
-  hppa*64*)
-    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\.[0-9]'
-    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl
-    ;;
-  *)
-    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|PA-RISC[0-9]\.[0-9]) shared library'
-    lt_cv_file_magic_test_file=/usr/lib/libc.sl
-    ;;
-  esac
-  ;;
-
-interix[3-9]*)
-  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
-  lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|\.a)$'
-  ;;
-
-irix5* | irix6* | nonstopux*)
-  case $LD in
-  *-32|*"-32 ") libmagic=32-bit;;
-  *-n32|*"-n32 ") libmagic=N32;;
-  *-64|*"-64 ") libmagic=64-bit;;
-  *) libmagic=never-match;;
-  esac
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-# This must be Linux ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-netbsd* | netbsdelf*-gnu)
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
-    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
-  else
-    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|_pic\.a)$'
-  fi
-  ;;
-
-newos6*)
-  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (executable|dynamic lib)'
-  lt_cv_file_magic_cmd=/usr/bin/file
-  lt_cv_file_magic_test_file=/usr/lib/libnls.so
-  ;;
-
-*nto* | *qnx*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-openbsd*)
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|\.so|_pic\.a)$'
-  else
-    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
-  fi
-  ;;
-
-osf3* | osf4* | osf5*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-rdos*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-solaris*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-
-sysv4 | sysv4.3*)
-  case $host_vendor in
-  motorola)
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib) M[0-9][0-9]* Version [0-9]'
-    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
-    ;;
-  ncr)
-    lt_cv_deplibs_check_method=pass_all
-    ;;
-  sequent)
-    lt_cv_file_magic_cmd='/bin/file'
-    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'
-    ;;
-  sni)
-    lt_cv_file_magic_cmd='/bin/file'
-    lt_cv_deplibs_check_method="file_magic ELF [0-9][0-9]*-bit [LM]SB dynamic lib"
-    lt_cv_file_magic_test_file=/lib/libc.so
-    ;;
-  siemens)
-    lt_cv_deplibs_check_method=pass_all
-    ;;
-  pc)
-    lt_cv_deplibs_check_method=pass_all
-    ;;
-  esac
-  ;;
-
-tpf*)
-  lt_cv_deplibs_check_method=pass_all
-  ;;
-esac
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_deplibs_check_method" >&5
-$as_echo "$lt_cv_deplibs_check_method" >&6; }
-
-file_magic_glob=
-want_nocaseglob=no
-if test "$build" = "$host"; then
-  case $host_os in
-  mingw* | pw32*)
-    if ( shopt | grep nocaseglob ) >/dev/null 2>&1; then
-      want_nocaseglob=yes
-    else
-      file_magic_glob=`echo aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ | $SED -e "s/\(..\)/s\/[\1]\/[\1]\/g;/g"`
-    fi
-    ;;
-  esac
-fi
-
-file_magic_cmd=$lt_cv_file_magic_cmd
-deplibs_check_method=$lt_cv_deplibs_check_method
-test -z "$deplibs_check_method" && deplibs_check_method=unknown
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}dlltool", so it can be a program name with args.
-set dummy ${ac_tool_prefix}dlltool; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_DLLTOOL+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$DLLTOOL"; then
-  ac_cv_prog_DLLTOOL="$DLLTOOL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_DLLTOOL="${ac_tool_prefix}dlltool"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-DLLTOOL=$ac_cv_prog_DLLTOOL
-if test -n "$DLLTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DLLTOOL" >&5
-$as_echo "$DLLTOOL" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_DLLTOOL"; then
-  ac_ct_DLLTOOL=$DLLTOOL
-  # Extract the first word of "dlltool", so it can be a program name with args.
-set dummy dlltool; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_DLLTOOL+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_DLLTOOL"; then
-  ac_cv_prog_ac_ct_DLLTOOL="$ac_ct_DLLTOOL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_DLLTOOL="dlltool"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_DLLTOOL=$ac_cv_prog_ac_ct_DLLTOOL
-if test -n "$ac_ct_DLLTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DLLTOOL" >&5
-$as_echo "$ac_ct_DLLTOOL" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_DLLTOOL" = x; then
-    DLLTOOL="false"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    DLLTOOL=$ac_ct_DLLTOOL
-  fi
-else
-  DLLTOOL="$ac_cv_prog_DLLTOOL"
-fi
-
-test -z "$DLLTOOL" && DLLTOOL=dlltool
-
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to associate runtime and link libraries" >&5
-$as_echo_n "checking how to associate runtime and link libraries... " >&6; }
-if ${lt_cv_sharedlib_from_linklib_cmd+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_sharedlib_from_linklib_cmd='unknown'
-
-case $host_os in
-cygwin* | mingw* | pw32* | cegcc*)
-  # two different shell functions defined in ltmain.sh
-  # decide which to use based on capabilities of $DLLTOOL
-  case `$DLLTOOL --help 2>&1` in
-  *--identify-strict*)
-    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib
-    ;;
-  *)
-    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib_fallback
-    ;;
-  esac
-  ;;
-*)
-  # fallback: assume linklib IS sharedlib
-  lt_cv_sharedlib_from_linklib_cmd="$ECHO"
-  ;;
-esac
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_sharedlib_from_linklib_cmd" >&5
-$as_echo "$lt_cv_sharedlib_from_linklib_cmd" >&6; }
-sharedlib_from_linklib_cmd=$lt_cv_sharedlib_from_linklib_cmd
-test -z "$sharedlib_from_linklib_cmd" && sharedlib_from_linklib_cmd=$ECHO
-
-
-
-
-
-
-
-
-if test -n "$ac_tool_prefix"; then
-  for ac_prog in ar
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_AR+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$AR"; then
-  ac_cv_prog_AR="$AR" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_AR="$ac_tool_prefix$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-AR=$ac_cv_prog_AR
-if test -n "$AR"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
-$as_echo "$AR" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-    test -n "$AR" && break
-  done
-fi
-if test -z "$AR"; then
-  ac_ct_AR=$AR
-  for ac_prog in ar
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_AR+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_AR"; then
-  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_AR="$ac_prog"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_AR=$ac_cv_prog_ac_ct_AR
-if test -n "$ac_ct_AR"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
-$as_echo "$ac_ct_AR" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$ac_ct_AR" && break
-done
-
-  if test "x$ac_ct_AR" = x; then
-    AR="false"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    AR=$ac_ct_AR
-  fi
-fi
-
-: ${AR=ar}
-: ${AR_FLAGS=cru}
-
-
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for archiver @FILE support" >&5
-$as_echo_n "checking for archiver @FILE support... " >&6; }
-if ${lt_cv_ar_at_file+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_ar_at_file=no
-   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_compile "$LINENO"; then :
-  echo conftest.$ac_objext > conftest.lst
-      lt_ar_try='$AR $AR_FLAGS libconftest.a @conftest.lst >&5'
-      { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$lt_ar_try\""; } >&5
-  (eval $lt_ar_try) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-      if test "$ac_status" -eq 0; then
-	# Ensure the archiver fails upon bogus file names.
-	rm -f conftest.$ac_objext libconftest.a
-	{ { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$lt_ar_try\""; } >&5
-  (eval $lt_ar_try) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-	if test "$ac_status" -ne 0; then
-          lt_cv_ar_at_file=@
-        fi
-      fi
-      rm -f conftest.* libconftest.a
-
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ar_at_file" >&5
-$as_echo "$lt_cv_ar_at_file" >&6; }
-
-if test "x$lt_cv_ar_at_file" = xno; then
-  archiver_list_spec=
-else
-  archiver_list_spec=$lt_cv_ar_at_file
-fi
-
-
-
-
-
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
-set dummy ${ac_tool_prefix}strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_STRIP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$STRIP"; then
-  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-STRIP=$ac_cv_prog_STRIP
-if test -n "$STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
-$as_echo "$STRIP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_STRIP"; then
-  ac_ct_STRIP=$STRIP
-  # Extract the first word of "strip", so it can be a program name with args.
-set dummy strip; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_STRIP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_STRIP"; then
-  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_STRIP="strip"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
-if test -n "$ac_ct_STRIP"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
-$as_echo "$ac_ct_STRIP" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_STRIP" = x; then
-    STRIP=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    STRIP=$ac_ct_STRIP
-  fi
-else
-  STRIP="$ac_cv_prog_STRIP"
-fi
-
-test -z "$STRIP" && STRIP=:
-
-
-
-
-
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
-set dummy ${ac_tool_prefix}ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_RANLIB+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$RANLIB"; then
-  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-RANLIB=$ac_cv_prog_RANLIB
-if test -n "$RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
-$as_echo "$RANLIB" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_RANLIB"; then
-  ac_ct_RANLIB=$RANLIB
-  # Extract the first word of "ranlib", so it can be a program name with args.
-set dummy ranlib; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_RANLIB+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_RANLIB"; then
-  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_RANLIB="ranlib"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
-if test -n "$ac_ct_RANLIB"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
-$as_echo "$ac_ct_RANLIB" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_RANLIB" = x; then
-    RANLIB=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    RANLIB=$ac_ct_RANLIB
-  fi
-else
-  RANLIB="$ac_cv_prog_RANLIB"
-fi
-
-test -z "$RANLIB" && RANLIB=:
-
-
-
-
-
-
-# Determine commands to create old-style static archives.
-old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'
-old_postinstall_cmds='chmod 644 $oldlib'
-old_postuninstall_cmds=
-
-if test -n "$RANLIB"; then
-  case $host_os in
-  openbsd*)
-    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$oldlib"
-    ;;
-  *)
-    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$oldlib"
-    ;;
-  esac
-  old_archive_cmds="$old_archive_cmds~\$RANLIB \$oldlib"
-fi
-
-case $host_os in
-  darwin*)
-    lock_old_archive_extraction=yes ;;
-  *)
-    lock_old_archive_extraction=no ;;
-esac
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-# If no C compiler was specified, use CC.
-LTCC=${LTCC-"$CC"}
-
-# If no C compiler flags were specified, use CFLAGS.
-LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
-
-# Allow CC to be a program name with arguments.
-compiler=$CC
-
-
-# Check for command to grab the raw symbol name followed by C symbol from nm.
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking command to parse $NM output from $compiler object" >&5
-$as_echo_n "checking command to parse $NM output from $compiler object... " >&6; }
-if ${lt_cv_sys_global_symbol_pipe+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-
-# These are sane defaults that work on at least a few old systems.
-# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
-
-# Character class describing NM global symbol codes.
-symcode='[BCDEGRST]'
-
-# Regexp to match symbols that can be accessed directly from C.
-sympat='\([_A-Za-z][_A-Za-z0-9]*\)'
-
-# Define system-specific variables.
-case $host_os in
-aix*)
-  symcode='[BCDT]'
-  ;;
-cygwin* | mingw* | pw32* | cegcc*)
-  symcode='[ABCDGISTW]'
-  ;;
-hpux*)
-  if test "$host_cpu" = ia64; then
-    symcode='[ABCDEGRST]'
-  fi
-  ;;
-irix* | nonstopux*)
-  symcode='[BCDEGRST]'
-  ;;
-osf*)
-  symcode='[BCDEGQRST]'
-  ;;
-solaris*)
-  symcode='[BDRT]'
-  ;;
-sco3.2v5*)
-  symcode='[DT]'
-  ;;
-sysv4.2uw2*)
-  symcode='[DT]'
-  ;;
-sysv5* | sco5v6* | unixware* | OpenUNIX*)
-  symcode='[ABDT]'
-  ;;
-sysv4)
-  symcode='[DFNSTU]'
-  ;;
-esac
-
-# If we're using GNU nm, then use its standard symbol codes.
-case `$NM -V 2>&1` in
-*GNU* | *'with BFD'*)
-  symcode='[ABCDGIRSTW]' ;;
-esac
-
-# Transform an extracted symbol line into a proper C declaration.
-# Some systems (esp. on ia64) link data and code symbols differently,
-# so use this general approach.
-lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
-
-# Transform an extracted symbol line into symbol name and symbol address
-lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\)[ ]*$/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"\2\", (void *) \&\2},/p'"
-lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([^ ]*\)[ ]*$/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \(lib[^ ]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
-
-# Handle CRLF in mingw tool chain
-opt_cr=
-case $build_os in
-mingw*)
-  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
-  ;;
-esac
-
-# Try without a prefix underscore, then with it.
-for ac_symprfx in "" "_"; do
-
-  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
-  symxfrm="\\1 $ac_symprfx\\2 \\2"
-
-  # Write the raw and C identifiers.
-  if test "$lt_cv_nm_interface" = "MS dumpbin"; then
-    # Fake it for dumpbin and say T for any non-static function
-    # and D for any global variable.
-    # Also find C++ and __fastcall symbols from MSVC++,
-    # which start with @ or ?.
-    lt_cv_sys_global_symbol_pipe="$AWK '"\
-"     {last_section=section; section=\$ 3};"\
-"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
-"     \$ 0!~/External *\|/{next};"\
-"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
-"     {if(hide[section]) next};"\
-"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
-"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
-"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
-"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
-"     ' prfx=^$ac_symprfx"
-  else
-    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[	 ]\($symcode$symcode*\)[	 ][	 ]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
-  fi
-  lt_cv_sys_global_symbol_pipe="$lt_cv_sys_global_symbol_pipe | sed '/ __gnu_lto/d'"
-
-  # Check to see that the pipe works correctly.
-  pipe_works=no
-
-  rm -f conftest*
-  cat > conftest.$ac_ext <<_LT_EOF
-#ifdef __cplusplus
-extern "C" {
-#endif
-char nm_test_var;
-void nm_test_func(void);
-void nm_test_func(void){}
-#ifdef __cplusplus
-}
-#endif
-int main(){nm_test_var='a';nm_test_func();return(0);}
-_LT_EOF
-
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    # Now try to grab the symbols.
-    nlist=conftest.nm
-    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist\""; } >&5
-  (eval $NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s "$nlist"; then
-      # Try sorting and uniquifying the output.
-      if sort "$nlist" | uniq > "$nlist"T; then
-	mv -f "$nlist"T "$nlist"
-      else
-	rm -f "$nlist"T
-      fi
-
-      # Make sure that we snagged all the symbols we need.
-      if $GREP ' nm_test_var$' "$nlist" >/dev/null; then
-	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
-	  cat <<_LT_EOF > conftest.$ac_ext
-/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */
-#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
-/* DATA imports from DLLs on WIN32 con't be const, because runtime
-   relocations are performed -- see ld's documentation on pseudo-relocs.  */
-# define LT_DLSYM_CONST
-#elif defined(__osf__)
-/* This system does not cope well with relocations in const data.  */
-# define LT_DLSYM_CONST
-#else
-# define LT_DLSYM_CONST const
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-_LT_EOF
-	  # Now generate the symbol file.
-	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
-
-	  cat <<_LT_EOF >> conftest.$ac_ext
-
-/* The mapping between symbol names and symbols.  */
-LT_DLSYM_CONST struct {
-  const char *name;
-  void       *address;
-}
-lt__PROGRAM__LTX_preloaded_symbols[] =
-{
-  { "@PROGRAM@", (void *) 0 },
-_LT_EOF
-	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
-	  cat <<\_LT_EOF >> conftest.$ac_ext
-  {0, (void *) 0}
-};
-
-/* This works around a problem in FreeBSD linker */
-#ifdef FREEBSD_WORKAROUND
-static const void *lt_preloaded_setup() {
-  return lt__PROGRAM__LTX_preloaded_symbols;
-}
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-_LT_EOF
-	  # Now try linking the two files.
-	  mv conftest.$ac_objext conftstm.$ac_objext
-	  lt_globsym_save_LIBS=$LIBS
-	  lt_globsym_save_CFLAGS=$CFLAGS
-	  LIBS="conftstm.$ac_objext"
-	  CFLAGS="$CFLAGS$lt_prog_compiler_no_builtin_flag"
-	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext}; then
-	    pipe_works=yes
-	  fi
-	  LIBS=$lt_globsym_save_LIBS
-	  CFLAGS=$lt_globsym_save_CFLAGS
-	else
-	  echo "cannot find nm_test_func in $nlist" >&5
-	fi
-      else
-	echo "cannot find nm_test_var in $nlist" >&5
-      fi
-    else
-      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&5
-    fi
-  else
-    echo "$progname: failed program was:" >&5
-    cat conftest.$ac_ext >&5
-  fi
-  rm -rf conftest* conftst*
-
-  # Do not use the global_symbol_pipe unless it works.
-  if test "$pipe_works" = yes; then
-    break
-  else
-    lt_cv_sys_global_symbol_pipe=
-  fi
-done
-
-fi
-
-if test -z "$lt_cv_sys_global_symbol_pipe"; then
-  lt_cv_sys_global_symbol_to_cdecl=
-fi
-if test -z "$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: failed" >&5
-$as_echo "failed" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: ok" >&5
-$as_echo "ok" >&6; }
-fi
-
-# Response file support.
-if test "$lt_cv_nm_interface" = "MS dumpbin"; then
-  nm_file_list_spec='@'
-elif $NM --help 2>/dev/null | grep '[@]FILE' >/dev/null; then
-  nm_file_list_spec='@'
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sysroot" >&5
-$as_echo_n "checking for sysroot... " >&6; }
-
-# Check whether --with-sysroot was given.
-if test "${with_sysroot+set}" = set; then :
-  withval=$with_sysroot;
-else
-  with_sysroot=no
-fi
-
-
-lt_sysroot=
-case ${with_sysroot} in #(
- yes)
-   if test "$GCC" = yes; then
-     lt_sysroot=`$CC --print-sysroot 2>/dev/null`
-   fi
-   ;; #(
- /*)
-   lt_sysroot=`echo "$with_sysroot" | sed -e "$sed_quote_subst"`
-   ;; #(
- no|'')
-   ;; #(
- *)
-   { $as_echo "$as_me:${as_lineno-$LINENO}: result: ${with_sysroot}" >&5
-$as_echo "${with_sysroot}" >&6; }
-   as_fn_error $? "The sysroot must be an absolute path." "$LINENO" 5
-   ;;
-esac
-
- { $as_echo "$as_me:${as_lineno-$LINENO}: result: ${lt_sysroot:-no}" >&5
-$as_echo "${lt_sysroot:-no}" >&6; }
-
-
-
-
-
-
-# Check whether --enable-libtool-lock was given.
-if test "${enable_libtool_lock+set}" = set; then :
-  enableval=$enable_libtool_lock;
-fi
-
-test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
-
-# Some flags need to be propagated to the compiler or linker for good
-# libtool support.
-case $host in
-ia64-*-hpux*)
-  # Find out which ABI we are using.
-  echo 'int i;' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    case `/usr/bin/file conftest.$ac_objext` in
-      *ELF-32*)
-	HPUX_IA64_MODE="32"
-	;;
-      *ELF-64*)
-	HPUX_IA64_MODE="64"
-	;;
-    esac
-  fi
-  rm -rf conftest*
-  ;;
-*-*-irix6*)
-  # Find out which ABI we are using.
-  echo '#line '$LINENO' "configure"' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    if test "$lt_cv_prog_gnu_ld" = yes; then
-      case `/usr/bin/file conftest.$ac_objext` in
-	*32-bit*)
-	  LD="${LD-ld} -melf32bsmip"
-	  ;;
-	*N32*)
-	  LD="${LD-ld} -melf32bmipn32"
-	  ;;
-	*64-bit*)
-	  LD="${LD-ld} -melf64bmip"
-	;;
-      esac
-    else
-      case `/usr/bin/file conftest.$ac_objext` in
-	*32-bit*)
-	  LD="${LD-ld} -32"
-	  ;;
-	*N32*)
-	  LD="${LD-ld} -n32"
-	  ;;
-	*64-bit*)
-	  LD="${LD-ld} -64"
-	  ;;
-      esac
-    fi
-  fi
-  rm -rf conftest*
-  ;;
-
-x86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \
-s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
-  # Find out which ABI we are using.
-  echo 'int i;' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    case `/usr/bin/file conftest.o` in
-      *32-bit*)
-	case $host in
-	  x86_64-*kfreebsd*-gnu)
-	    LD="${LD-ld} -m elf_i386_fbsd"
-	    ;;
-	  x86_64-*linux*)
-	    LD="${LD-ld} -m elf_i386"
-	    ;;
-	  ppc64-*linux*|powerpc64-*linux*)
-	    LD="${LD-ld} -m elf32ppclinux"
-	    ;;
-	  s390x-*linux*)
-	    LD="${LD-ld} -m elf_s390"
-	    ;;
-	  sparc64-*linux*)
-	    LD="${LD-ld} -m elf32_sparc"
-	    ;;
-	esac
-	;;
-      *64-bit*)
-	case $host in
-	  x86_64-*kfreebsd*-gnu)
-	    LD="${LD-ld} -m elf_x86_64_fbsd"
-	    ;;
-	  x86_64-*linux*)
-	    LD="${LD-ld} -m elf_x86_64"
-	    ;;
-	  ppc*-*linux*|powerpc*-*linux*)
-	    LD="${LD-ld} -m elf64ppc"
-	    ;;
-	  s390*-*linux*|s390*-*tpf*)
-	    LD="${LD-ld} -m elf64_s390"
-	    ;;
-	  sparc*-*linux*)
-	    LD="${LD-ld} -m elf64_sparc"
-	    ;;
-	esac
-	;;
-    esac
-  fi
-  rm -rf conftest*
-  ;;
-
-*-*-sco3.2v5*)
-  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
-  SAVE_CFLAGS="$CFLAGS"
-  CFLAGS="$CFLAGS -belf"
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler needs -belf" >&5
-$as_echo_n "checking whether the C compiler needs -belf... " >&6; }
-if ${lt_cv_cc_needs_belf+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  lt_cv_cc_needs_belf=yes
-else
-  lt_cv_cc_needs_belf=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-     ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_cc_needs_belf" >&5
-$as_echo "$lt_cv_cc_needs_belf" >&6; }
-  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
-    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
-    CFLAGS="$SAVE_CFLAGS"
-  fi
-  ;;
-sparc*-*solaris*)
-  # Find out which ABI we are using.
-  echo 'int i;' > conftest.$ac_ext
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-    case `/usr/bin/file conftest.o` in
-    *64-bit*)
-      case $lt_cv_prog_gnu_ld in
-      yes*) LD="${LD-ld} -m elf64_sparc" ;;
-      *)
-	if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
-	  LD="${LD-ld} -64"
-	fi
-	;;
-      esac
-      ;;
-    esac
-  fi
-  rm -rf conftest*
-  ;;
-esac
-
-need_locks="$enable_libtool_lock"
-
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}mt", so it can be a program name with args.
-set dummy ${ac_tool_prefix}mt; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_MANIFEST_TOOL+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$MANIFEST_TOOL"; then
-  ac_cv_prog_MANIFEST_TOOL="$MANIFEST_TOOL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_MANIFEST_TOOL="${ac_tool_prefix}mt"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-MANIFEST_TOOL=$ac_cv_prog_MANIFEST_TOOL
-if test -n "$MANIFEST_TOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MANIFEST_TOOL" >&5
-$as_echo "$MANIFEST_TOOL" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_MANIFEST_TOOL"; then
-  ac_ct_MANIFEST_TOOL=$MANIFEST_TOOL
-  # Extract the first word of "mt", so it can be a program name with args.
-set dummy mt; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_MANIFEST_TOOL+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_MANIFEST_TOOL"; then
-  ac_cv_prog_ac_ct_MANIFEST_TOOL="$ac_ct_MANIFEST_TOOL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_MANIFEST_TOOL="mt"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_MANIFEST_TOOL=$ac_cv_prog_ac_ct_MANIFEST_TOOL
-if test -n "$ac_ct_MANIFEST_TOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_MANIFEST_TOOL" >&5
-$as_echo "$ac_ct_MANIFEST_TOOL" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_MANIFEST_TOOL" = x; then
-    MANIFEST_TOOL=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    MANIFEST_TOOL=$ac_ct_MANIFEST_TOOL
-  fi
-else
-  MANIFEST_TOOL="$ac_cv_prog_MANIFEST_TOOL"
-fi
-
-test -z "$MANIFEST_TOOL" && MANIFEST_TOOL=mt
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $MANIFEST_TOOL is a manifest tool" >&5
-$as_echo_n "checking if $MANIFEST_TOOL is a manifest tool... " >&6; }
-if ${lt_cv_path_mainfest_tool+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_path_mainfest_tool=no
-  echo "$as_me:$LINENO: $MANIFEST_TOOL '-?'" >&5
-  $MANIFEST_TOOL '-?' 2>conftest.err > conftest.out
-  cat conftest.err >&5
-  if $GREP 'Manifest Tool' conftest.out > /dev/null; then
-    lt_cv_path_mainfest_tool=yes
-  fi
-  rm -f conftest*
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_path_mainfest_tool" >&5
-$as_echo "$lt_cv_path_mainfest_tool" >&6; }
-if test "x$lt_cv_path_mainfest_tool" != xyes; then
-  MANIFEST_TOOL=:
-fi
-
-
-
-
-
-
-  case $host_os in
-    rhapsody* | darwin*)
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}dsymutil", so it can be a program name with args.
-set dummy ${ac_tool_prefix}dsymutil; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_DSYMUTIL+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$DSYMUTIL"; then
-  ac_cv_prog_DSYMUTIL="$DSYMUTIL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_DSYMUTIL="${ac_tool_prefix}dsymutil"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-DSYMUTIL=$ac_cv_prog_DSYMUTIL
-if test -n "$DSYMUTIL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DSYMUTIL" >&5
-$as_echo "$DSYMUTIL" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_DSYMUTIL"; then
-  ac_ct_DSYMUTIL=$DSYMUTIL
-  # Extract the first word of "dsymutil", so it can be a program name with args.
-set dummy dsymutil; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_DSYMUTIL+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_DSYMUTIL"; then
-  ac_cv_prog_ac_ct_DSYMUTIL="$ac_ct_DSYMUTIL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_DSYMUTIL="dsymutil"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_DSYMUTIL=$ac_cv_prog_ac_ct_DSYMUTIL
-if test -n "$ac_ct_DSYMUTIL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DSYMUTIL" >&5
-$as_echo "$ac_ct_DSYMUTIL" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_DSYMUTIL" = x; then
-    DSYMUTIL=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    DSYMUTIL=$ac_ct_DSYMUTIL
-  fi
-else
-  DSYMUTIL="$ac_cv_prog_DSYMUTIL"
-fi
-
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}nmedit", so it can be a program name with args.
-set dummy ${ac_tool_prefix}nmedit; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_NMEDIT+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$NMEDIT"; then
-  ac_cv_prog_NMEDIT="$NMEDIT" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_NMEDIT="${ac_tool_prefix}nmedit"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-NMEDIT=$ac_cv_prog_NMEDIT
-if test -n "$NMEDIT"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $NMEDIT" >&5
-$as_echo "$NMEDIT" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_NMEDIT"; then
-  ac_ct_NMEDIT=$NMEDIT
-  # Extract the first word of "nmedit", so it can be a program name with args.
-set dummy nmedit; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_NMEDIT+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_NMEDIT"; then
-  ac_cv_prog_ac_ct_NMEDIT="$ac_ct_NMEDIT" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_NMEDIT="nmedit"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_NMEDIT=$ac_cv_prog_ac_ct_NMEDIT
-if test -n "$ac_ct_NMEDIT"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_NMEDIT" >&5
-$as_echo "$ac_ct_NMEDIT" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_NMEDIT" = x; then
-    NMEDIT=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    NMEDIT=$ac_ct_NMEDIT
-  fi
-else
-  NMEDIT="$ac_cv_prog_NMEDIT"
-fi
-
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}lipo", so it can be a program name with args.
-set dummy ${ac_tool_prefix}lipo; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_LIPO+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$LIPO"; then
-  ac_cv_prog_LIPO="$LIPO" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_LIPO="${ac_tool_prefix}lipo"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-LIPO=$ac_cv_prog_LIPO
-if test -n "$LIPO"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LIPO" >&5
-$as_echo "$LIPO" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_LIPO"; then
-  ac_ct_LIPO=$LIPO
-  # Extract the first word of "lipo", so it can be a program name with args.
-set dummy lipo; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_LIPO+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_LIPO"; then
-  ac_cv_prog_ac_ct_LIPO="$ac_ct_LIPO" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_LIPO="lipo"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_LIPO=$ac_cv_prog_ac_ct_LIPO
-if test -n "$ac_ct_LIPO"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_LIPO" >&5
-$as_echo "$ac_ct_LIPO" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_LIPO" = x; then
-    LIPO=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    LIPO=$ac_ct_LIPO
-  fi
-else
-  LIPO="$ac_cv_prog_LIPO"
-fi
-
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}otool", so it can be a program name with args.
-set dummy ${ac_tool_prefix}otool; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_OTOOL+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$OTOOL"; then
-  ac_cv_prog_OTOOL="$OTOOL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_OTOOL="${ac_tool_prefix}otool"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-OTOOL=$ac_cv_prog_OTOOL
-if test -n "$OTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL" >&5
-$as_echo "$OTOOL" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_OTOOL"; then
-  ac_ct_OTOOL=$OTOOL
-  # Extract the first word of "otool", so it can be a program name with args.
-set dummy otool; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_OTOOL+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_OTOOL"; then
-  ac_cv_prog_ac_ct_OTOOL="$ac_ct_OTOOL" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_OTOOL="otool"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_OTOOL=$ac_cv_prog_ac_ct_OTOOL
-if test -n "$ac_ct_OTOOL"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL" >&5
-$as_echo "$ac_ct_OTOOL" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_OTOOL" = x; then
-    OTOOL=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    OTOOL=$ac_ct_OTOOL
-  fi
-else
-  OTOOL="$ac_cv_prog_OTOOL"
-fi
-
-    if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}otool64", so it can be a program name with args.
-set dummy ${ac_tool_prefix}otool64; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_OTOOL64+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$OTOOL64"; then
-  ac_cv_prog_OTOOL64="$OTOOL64" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_OTOOL64="${ac_tool_prefix}otool64"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-OTOOL64=$ac_cv_prog_OTOOL64
-if test -n "$OTOOL64"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL64" >&5
-$as_echo "$OTOOL64" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_OTOOL64"; then
-  ac_ct_OTOOL64=$OTOOL64
-  # Extract the first word of "otool64", so it can be a program name with args.
-set dummy otool64; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_OTOOL64+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -n "$ac_ct_OTOOL64"; then
-  ac_cv_prog_ac_ct_OTOOL64="$ac_ct_OTOOL64" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_OTOOL64="otool64"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_OTOOL64=$ac_cv_prog_ac_ct_OTOOL64
-if test -n "$ac_ct_OTOOL64"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL64" >&5
-$as_echo "$ac_ct_OTOOL64" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-  if test "x$ac_ct_OTOOL64" = x; then
-    OTOOL64=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
-$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
-ac_tool_warned=yes ;;
-esac
-    OTOOL64=$ac_ct_OTOOL64
-  fi
-else
-  OTOOL64="$ac_cv_prog_OTOOL64"
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -single_module linker flag" >&5
-$as_echo_n "checking for -single_module linker flag... " >&6; }
-if ${lt_cv_apple_cc_single_mod+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_apple_cc_single_mod=no
-      if test -z "${LT_MULTI_MODULE}"; then
-	# By default we will add the -single_module flag. You can override
-	# by either setting the environment variable LT_MULTI_MODULE
-	# non-empty at configure time, or by adding -multi_module to the
-	# link flags.
-	rm -rf libconftest.dylib*
-	echo "int foo(void){return 1;}" > conftest.c
-	echo "$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
--dynamiclib -Wl,-single_module conftest.c" >&5
-	$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
-	  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err
-        _lt_result=$?
-	if test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then
-	  lt_cv_apple_cc_single_mod=yes
-	else
-	  cat conftest.err >&5
-	fi
-	rm -rf libconftest.dylib*
-	rm -f conftest.*
-      fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_apple_cc_single_mod" >&5
-$as_echo "$lt_cv_apple_cc_single_mod" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -exported_symbols_list linker flag" >&5
-$as_echo_n "checking for -exported_symbols_list linker flag... " >&6; }
-if ${lt_cv_ld_exported_symbols_list+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_ld_exported_symbols_list=no
-      save_LDFLAGS=$LDFLAGS
-      echo "_main" > conftest.sym
-      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  lt_cv_ld_exported_symbols_list=yes
-else
-  lt_cv_ld_exported_symbols_list=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-	LDFLAGS="$save_LDFLAGS"
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_exported_symbols_list" >&5
-$as_echo "$lt_cv_ld_exported_symbols_list" >&6; }
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -force_load linker flag" >&5
-$as_echo_n "checking for -force_load linker flag... " >&6; }
-if ${lt_cv_ld_force_load+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_ld_force_load=no
-      cat > conftest.c << _LT_EOF
-int forced_loaded() { return 2;}
-_LT_EOF
-      echo "$LTCC $LTCFLAGS -c -o conftest.o conftest.c" >&5
-      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&5
-      echo "$AR cru libconftest.a conftest.o" >&5
-      $AR cru libconftest.a conftest.o 2>&5
-      echo "$RANLIB libconftest.a" >&5
-      $RANLIB libconftest.a 2>&5
-      cat > conftest.c << _LT_EOF
-int main() { return 0;}
-_LT_EOF
-      echo "$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a" >&5
-      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err
-      _lt_result=$?
-      if test -f conftest && test ! -s conftest.err && test $_lt_result = 0 && $GREP forced_load conftest 2>&1 >/dev/null; then
-	lt_cv_ld_force_load=yes
-      else
-	cat conftest.err >&5
-      fi
-        rm -f conftest.err libconftest.a conftest conftest.c
-        rm -rf conftest.dSYM
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_force_load" >&5
-$as_echo "$lt_cv_ld_force_load" >&6; }
-    case $host_os in
-    rhapsody* | darwin1.[012])
-      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
-    darwin1.*)
-      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
-    darwin*) # darwin 5.x on
-      # if running on 10.5 or later, the deployment target defaults
-      # to the OS version, if on x86, and 10.4, the deployment
-      # target defaults to 10.4. Don't you love it?
-      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
-	10.0,*86*-darwin8*|10.0,*-darwin[91]*)
-	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
-	10.[012]*)
-	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
-	10.*)
-	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
-      esac
-    ;;
-  esac
-    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
-      _lt_dar_single_mod='$single_module'
-    fi
-    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
-      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
-    else
-      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
-    fi
-    if test "$DSYMUTIL" != ":" && test "$lt_cv_ld_force_load" = "no"; then
-      _lt_dsymutil='~$DSYMUTIL $lib || :'
-    else
-      _lt_dsymutil=
-    fi
-    ;;
-  esac
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
-$as_echo_n "checking how to run the C preprocessor... " >&6; }
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
-fi
-if test -z "$CPP"; then
-  if ${ac_cv_prog_CPP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-      # Double quotes because CPP needs to be expanded
-    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.i conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-  break
-fi
-
-    done
-    ac_cv_prog_CPP=$CPP
-
-fi
-  CPP=$ac_cv_prog_CPP
-else
-  ac_cv_prog_CPP=$CPP
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
-$as_echo "$CPP" >&6; }
-ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_c_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.i conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details" "$LINENO" 5; }
-fi
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
-$as_echo_n "checking for ANSI C header files... " >&6; }
-if ${ac_cv_header_stdc+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <float.h>
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  ac_cv_header_stdc=yes
-else
-  ac_cv_header_stdc=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-if test $ac_cv_header_stdc = yes; then
-  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <string.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "memchr" >/dev/null 2>&1; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <stdlib.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "free" >/dev/null 2>&1; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
-  if test "$cross_compiling" = yes; then :
-  :
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ctype.h>
-#include <stdlib.h>
-#if ((' ' & 0x0FF) == 0x020)
-# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
-# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
-#else
-# define ISLOWER(c) \
-		   (('a' <= (c) && (c) <= 'i') \
-		     || ('j' <= (c) && (c) <= 'r') \
-		     || ('s' <= (c) && (c) <= 'z'))
-# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
-#endif
-
-#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
-int
-main ()
-{
-  int i;
-  for (i = 0; i < 256; i++)
-    if (XOR (islower (i), ISLOWER (i))
-	|| toupper (i) != TOUPPER (i))
-      return 2;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-
-else
-  ac_cv_header_stdc=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
-
-fi
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
-$as_echo "$ac_cv_header_stdc" >&6; }
-if test $ac_cv_header_stdc = yes; then
-
-$as_echo "#define STDC_HEADERS 1" >>confdefs.h
-
-fi
-
-# On IRIX 5.3, sys/types and inttypes.h are conflicting.
-for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-		  inttypes.h stdint.h unistd.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
-"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-for ac_header in dlfcn.h
-do :
-  ac_fn_c_check_header_compile "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default
-"
-if test "x$ac_cv_header_dlfcn_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_DLFCN_H 1
-_ACEOF
-
-fi
-
-done
-
-
-
-func_stripname_cnf ()
-{
-  case ${2} in
-  .*) func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%\\\\${2}\$%%"`;;
-  *)  func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%${2}\$%%"`;;
-  esac
-} # func_stripname_cnf
-
-
-
-
-
-# Set options
-
-
-
-        enable_dlopen=no
-
-
-  enable_win32_dll=no
-
-
-            # Check whether --enable-shared was given.
-if test "${enable_shared+set}" = set; then :
-  enableval=$enable_shared; p=${PACKAGE-default}
-    case $enableval in
-    yes) enable_shared=yes ;;
-    no) enable_shared=no ;;
-    *)
-      enable_shared=no
-      # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
-      for pkg in $enableval; do
-	IFS="$lt_save_ifs"
-	if test "X$pkg" = "X$p"; then
-	  enable_shared=yes
-	fi
-      done
-      IFS="$lt_save_ifs"
-      ;;
-    esac
-else
-  enable_shared=yes
-fi
-
-
-
-
-
-
-
-
-
-  # Check whether --enable-static was given.
-if test "${enable_static+set}" = set; then :
-  enableval=$enable_static; p=${PACKAGE-default}
-    case $enableval in
-    yes) enable_static=yes ;;
-    no) enable_static=no ;;
-    *)
-     enable_static=no
-      # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
-      for pkg in $enableval; do
-	IFS="$lt_save_ifs"
-	if test "X$pkg" = "X$p"; then
-	  enable_static=yes
-	fi
-      done
-      IFS="$lt_save_ifs"
-      ;;
-    esac
-else
-  enable_static=yes
-fi
-
-
-
-
-
-
-
-
-
-
-# Check whether --with-pic was given.
-if test "${with_pic+set}" = set; then :
-  withval=$with_pic; pic_mode="$withval"
-else
-  pic_mode=default
-fi
-
-
-test -z "$pic_mode" && pic_mode=default
-
-
-
-
-
-
-
-  # Check whether --enable-fast-install was given.
-if test "${enable_fast_install+set}" = set; then :
-  enableval=$enable_fast_install; p=${PACKAGE-default}
-    case $enableval in
-    yes) enable_fast_install=yes ;;
-    no) enable_fast_install=no ;;
-    *)
-      enable_fast_install=no
-      # Look at the argument we got.  We use all the common list separators.
-      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
-      for pkg in $enableval; do
-	IFS="$lt_save_ifs"
-	if test "X$pkg" = "X$p"; then
-	  enable_fast_install=yes
-	fi
-      done
-      IFS="$lt_save_ifs"
-      ;;
-    esac
-else
-  enable_fast_install=yes
-fi
-
-
-
-
-
-
-
-
-
-
-
-# This can be used to rebuild libtool when needed
-LIBTOOL_DEPS="$ltmain"
-
-# Always use our own libtool.
-LIBTOOL='$(SHELL) $(top_builddir)/libtool'
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-test -z "$LN_S" && LN_S="ln -s"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-if test -n "${ZSH_VERSION+set}" ; then
-   setopt NO_GLOB_SUBST
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for objdir" >&5
-$as_echo_n "checking for objdir... " >&6; }
-if ${lt_cv_objdir+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  rm -f .libs 2>/dev/null
-mkdir .libs 2>/dev/null
-if test -d .libs; then
-  lt_cv_objdir=.libs
-else
-  # MS-DOS does not allow filenames that begin with a dot.
-  lt_cv_objdir=_libs
-fi
-rmdir .libs 2>/dev/null
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_objdir" >&5
-$as_echo "$lt_cv_objdir" >&6; }
-objdir=$lt_cv_objdir
-
-
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define LT_OBJDIR "$lt_cv_objdir/"
-_ACEOF
-
-
-
-
-case $host_os in
-aix3*)
-  # AIX sometimes has problems with the GCC collect2 program.  For some
-  # reason, if we set the COLLECT_NAMES environment variable, the problems
-  # vanish in a puff of smoke.
-  if test "X${COLLECT_NAMES+set}" != Xset; then
-    COLLECT_NAMES=
-    export COLLECT_NAMES
-  fi
-  ;;
-esac
-
-# Global variables:
-ofile=libtool
-can_build_shared=yes
-
-# All known linkers require a `.a' archive for static linking (except MSVC,
-# which needs '.lib').
-libext=a
-
-with_gnu_ld="$lt_cv_prog_gnu_ld"
-
-old_CC="$CC"
-old_CFLAGS="$CFLAGS"
-
-# Set sane defaults for various variables
-test -z "$CC" && CC=cc
-test -z "$LTCC" && LTCC=$CC
-test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
-test -z "$LD" && LD=ld
-test -z "$ac_objext" && ac_objext=o
-
-for cc_temp in $compiler""; do
-  case $cc_temp in
-    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
-    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
-    \-*) ;;
-    *) break;;
-  esac
-done
-cc_basename=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
-
-
-# Only perform the check for file, if the check method requires it
-test -z "$MAGIC_CMD" && MAGIC_CMD=file
-case $deplibs_check_method in
-file_magic*)
-  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${ac_tool_prefix}file" >&5
-$as_echo_n "checking for ${ac_tool_prefix}file... " >&6; }
-if ${lt_cv_path_MAGIC_CMD+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $MAGIC_CMD in
-[\\/*] |  ?:[\\/]*)
-  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
-  ;;
-*)
-  lt_save_MAGIC_CMD="$MAGIC_CMD"
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
-  for ac_dir in $ac_dummy; do
-    IFS="$lt_save_ifs"
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/${ac_tool_prefix}file; then
-      lt_cv_path_MAGIC_CMD="$ac_dir/${ac_tool_prefix}file"
-      if test -n "$file_magic_test_file"; then
-	case $deplibs_check_method in
-	"file_magic "*)
-	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
-	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
-	    $EGREP "$file_magic_regex" > /dev/null; then
-	    :
-	  else
-	    cat <<_LT_EOF 1>&2
-
-*** Warning: the command libtool uses to detect shared libraries,
-*** $file_magic_cmd, produces output that libtool cannot recognize.
-*** The result is that libtool may fail to recognize shared libraries
-*** as such.  This will affect the creation of libtool libraries that
-*** depend on shared libraries, but programs linked with such libtool
-*** libraries will work regardless of this problem.  Nevertheless, you
-*** may want to report the problem to your system manager and/or to
-*** bug-libtool@gnu.org
-
-_LT_EOF
-	  fi ;;
-	esac
-      fi
-      break
-    fi
-  done
-  IFS="$lt_save_ifs"
-  MAGIC_CMD="$lt_save_MAGIC_CMD"
-  ;;
-esac
-fi
-
-MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-if test -n "$MAGIC_CMD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
-$as_echo "$MAGIC_CMD" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-
-
-
-if test -z "$lt_cv_path_MAGIC_CMD"; then
-  if test -n "$ac_tool_prefix"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for file" >&5
-$as_echo_n "checking for file... " >&6; }
-if ${lt_cv_path_MAGIC_CMD+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $MAGIC_CMD in
-[\\/*] |  ?:[\\/]*)
-  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
-  ;;
-*)
-  lt_save_MAGIC_CMD="$MAGIC_CMD"
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
-  for ac_dir in $ac_dummy; do
-    IFS="$lt_save_ifs"
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/file; then
-      lt_cv_path_MAGIC_CMD="$ac_dir/file"
-      if test -n "$file_magic_test_file"; then
-	case $deplibs_check_method in
-	"file_magic "*)
-	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
-	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
-	    $EGREP "$file_magic_regex" > /dev/null; then
-	    :
-	  else
-	    cat <<_LT_EOF 1>&2
-
-*** Warning: the command libtool uses to detect shared libraries,
-*** $file_magic_cmd, produces output that libtool cannot recognize.
-*** The result is that libtool may fail to recognize shared libraries
-*** as such.  This will affect the creation of libtool libraries that
-*** depend on shared libraries, but programs linked with such libtool
-*** libraries will work regardless of this problem.  Nevertheless, you
-*** may want to report the problem to your system manager and/or to
-*** bug-libtool@gnu.org
-
-_LT_EOF
-	  fi ;;
-	esac
-      fi
-      break
-    fi
-  done
-  IFS="$lt_save_ifs"
-  MAGIC_CMD="$lt_save_MAGIC_CMD"
-  ;;
-esac
-fi
-
-MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
-if test -n "$MAGIC_CMD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
-$as_echo "$MAGIC_CMD" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  else
-    MAGIC_CMD=:
-  fi
-fi
-
-  fi
-  ;;
-esac
-
-# Use C for the default configuration in the libtool script
-
-lt_save_CC="$CC"
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-# Source file extension for C test sources.
-ac_ext=c
-
-# Object file extension for compiled C test sources.
-objext=o
-objext=$objext
-
-# Code to be used in simple compile tests
-lt_simple_compile_test_code="int some_variable = 0;"
-
-# Code to be used in simple link tests
-lt_simple_link_test_code='int main(){return(0);}'
-
-
-
-
-
-
-
-# If no C compiler was specified, use CC.
-LTCC=${LTCC-"$CC"}
-
-# If no C compiler flags were specified, use CFLAGS.
-LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
-
-# Allow CC to be a program name with arguments.
-compiler=$CC
-
-# Save the default compiler, since it gets overwritten when the other
-# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.
-compiler_DEFAULT=$CC
-
-# save warnings/boilerplate of simple test code
-ac_outfile=conftest.$ac_objext
-echo "$lt_simple_compile_test_code" >conftest.$ac_ext
-eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
-_lt_compiler_boilerplate=`cat conftest.err`
-$RM conftest*
-
-ac_outfile=conftest.$ac_objext
-echo "$lt_simple_link_test_code" >conftest.$ac_ext
-eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
-_lt_linker_boilerplate=`cat conftest.err`
-$RM -r conftest*
-
-
-if test -n "$compiler"; then
-
-lt_prog_compiler_no_builtin_flag=
-
-if test "$GCC" = yes; then
-  case $cc_basename in
-  nvcc*)
-    lt_prog_compiler_no_builtin_flag=' -Xcompiler -fno-builtin' ;;
-  *)
-    lt_prog_compiler_no_builtin_flag=' -fno-builtin' ;;
-  esac
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
-$as_echo_n "checking if $compiler supports -fno-rtti -fno-exceptions... " >&6; }
-if ${lt_cv_prog_compiler_rtti_exceptions+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_rtti_exceptions=no
-   ac_outfile=conftest.$ac_objext
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-   lt_compiler_flag="-fno-rtti -fno-exceptions"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   # The option is referenced via a variable to avoid confusing sed.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>conftest.err)
-   ac_status=$?
-   cat conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s "$ac_outfile"; then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings other than the usual output.
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
-     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_rtti_exceptions=yes
-     fi
-   fi
-   $RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
-$as_echo "$lt_cv_prog_compiler_rtti_exceptions" >&6; }
-
-if test x"$lt_cv_prog_compiler_rtti_exceptions" = xyes; then
-    lt_prog_compiler_no_builtin_flag="$lt_prog_compiler_no_builtin_flag -fno-rtti -fno-exceptions"
-else
-    :
-fi
-
-fi
-
-
-
-
-
-
-  lt_prog_compiler_wl=
-lt_prog_compiler_pic=
-lt_prog_compiler_static=
-
-
-  if test "$GCC" = yes; then
-    lt_prog_compiler_wl='-Wl,'
-    lt_prog_compiler_static='-static'
-
-    case $host_os in
-      aix*)
-      # All AIX code is PIC.
-      if test "$host_cpu" = ia64; then
-	# AIX 5 now supports IA64 processor
-	lt_prog_compiler_static='-Bstatic'
-      fi
-      ;;
-
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            lt_prog_compiler_pic='-fPIC'
-        ;;
-      m68k)
-            # FIXME: we need at least 68020 code to build shared libraries, but
-            # adding the `-m68020' flag to GCC prevents building anything better,
-            # like `-m68040'.
-            lt_prog_compiler_pic='-m68020 -resident32 -malways-restore-a4'
-        ;;
-      esac
-      ;;
-
-    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
-      # PIC is the default for these OSes.
-      ;;
-
-    mingw* | cygwin* | pw32* | os2* | cegcc*)
-      # This hack is so that the source file can tell whether it is being
-      # built for inclusion in a dll (and should export symbols for example).
-      # Although the cygwin gcc ignores -fPIC, still need this for old-style
-      # (--disable-auto-import) libraries
-      lt_prog_compiler_pic='-DDLL_EXPORT'
-      ;;
-
-    darwin* | rhapsody*)
-      # PIC is the default on this platform
-      # Common symbols not allowed in MH_DYLIB files
-      lt_prog_compiler_pic='-fno-common'
-      ;;
-
-    haiku*)
-      # PIC is the default for Haiku.
-      # The "-static" flag exists, but is broken.
-      lt_prog_compiler_static=
-      ;;
-
-    hpux*)
-      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
-      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
-      # sets the default TLS model and affects inlining.
-      case $host_cpu in
-      hppa*64*)
-	# +Z the default
-	;;
-      *)
-	lt_prog_compiler_pic='-fPIC'
-	;;
-      esac
-      ;;
-
-    interix[3-9]*)
-      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
-      # Instead, we relocate shared libraries at runtime.
-      ;;
-
-    msdosdjgpp*)
-      # Just because we use GCC doesn't mean we suddenly get shared libraries
-      # on systems that don't support them.
-      lt_prog_compiler_can_build_shared=no
-      enable_shared=no
-      ;;
-
-    *nto* | *qnx*)
-      # QNX uses GNU C++, but need to define -shared option too, otherwise
-      # it will coredump.
-      lt_prog_compiler_pic='-fPIC -shared'
-      ;;
-
-    sysv4*MP*)
-      if test -d /usr/nec; then
-	lt_prog_compiler_pic=-Kconform_pic
-      fi
-      ;;
-
-    *)
-      lt_prog_compiler_pic='-fPIC'
-      ;;
-    esac
-
-    case $cc_basename in
-    nvcc*) # Cuda Compiler Driver 2.2
-      lt_prog_compiler_wl='-Xlinker '
-      lt_prog_compiler_pic='-Xcompiler -fPIC'
-      ;;
-    esac
-  else
-    # PORTME Check for flag to pass linker flags through the system compiler.
-    case $host_os in
-    aix*)
-      lt_prog_compiler_wl='-Wl,'
-      if test "$host_cpu" = ia64; then
-	# AIX 5 now supports IA64 processor
-	lt_prog_compiler_static='-Bstatic'
-      else
-	lt_prog_compiler_static='-bnso -bI:/lib/syscalls.exp'
-      fi
-      ;;
-
-    mingw* | cygwin* | pw32* | os2* | cegcc*)
-      # This hack is so that the source file can tell whether it is being
-      # built for inclusion in a dll (and should export symbols for example).
-      lt_prog_compiler_pic='-DDLL_EXPORT'
-      ;;
-
-    hpux9* | hpux10* | hpux11*)
-      lt_prog_compiler_wl='-Wl,'
-      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
-      # not for PA HP-UX.
-      case $host_cpu in
-      hppa*64*|ia64*)
-	# +Z the default
-	;;
-      *)
-	lt_prog_compiler_pic='+Z'
-	;;
-      esac
-      # Is there a better lt_prog_compiler_static that works with the bundled CC?
-      lt_prog_compiler_static='${wl}-a ${wl}archive'
-      ;;
-
-    irix5* | irix6* | nonstopux*)
-      lt_prog_compiler_wl='-Wl,'
-      # PIC (with -KPIC) is the default.
-      lt_prog_compiler_static='-non_shared'
-      ;;
-
-    linux* | k*bsd*-gnu | kopensolaris*-gnu)
-      case $cc_basename in
-      # old Intel for x86_64 which still supported -KPIC.
-      ecc*)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-KPIC'
-	lt_prog_compiler_static='-static'
-        ;;
-      # icc used to be incompatible with GCC.
-      # ICC 10 doesn't accept -KPIC any more.
-      icc* | ifort*)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-fPIC'
-	lt_prog_compiler_static='-static'
-        ;;
-      # Lahey Fortran 8.1.
-      lf95*)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='--shared'
-	lt_prog_compiler_static='--static'
-	;;
-      nagfor*)
-	# NAG Fortran compiler
-	lt_prog_compiler_wl='-Wl,-Wl,,'
-	lt_prog_compiler_pic='-PIC'
-	lt_prog_compiler_static='-Bstatic'
-	;;
-      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)
-        # Portland Group compilers (*not* the Pentium gcc compiler,
-	# which looks to be a dead project)
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-fpic'
-	lt_prog_compiler_static='-Bstatic'
-        ;;
-      ccc*)
-        lt_prog_compiler_wl='-Wl,'
-        # All Alpha code is PIC.
-        lt_prog_compiler_static='-non_shared'
-        ;;
-      xl* | bgxl* | bgf* | mpixl*)
-	# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene
-	lt_prog_compiler_wl='-Wl,'
-	lt_prog_compiler_pic='-qpic'
-	lt_prog_compiler_static='-qstaticlink'
-	;;
-      *)
-	case `$CC -V 2>&1 | sed 5q` in
-	*Sun\ F* | *Sun*Fortran*)
-	  # Sun Fortran 8.3 passes all unrecognized flags to the linker
-	  lt_prog_compiler_pic='-KPIC'
-	  lt_prog_compiler_static='-Bstatic'
-	  lt_prog_compiler_wl=''
-	  ;;
-	*Sun\ C*)
-	  # Sun C 5.9
-	  lt_prog_compiler_pic='-KPIC'
-	  lt_prog_compiler_static='-Bstatic'
-	  lt_prog_compiler_wl='-Wl,'
-	  ;;
-	esac
-	;;
-      esac
-      ;;
-
-    newsos6)
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
-
-    *nto* | *qnx*)
-      # QNX uses GNU C++, but need to define -shared option too, otherwise
-      # it will coredump.
-      lt_prog_compiler_pic='-fPIC -shared'
-      ;;
-
-    osf3* | osf4* | osf5*)
-      lt_prog_compiler_wl='-Wl,'
-      # All OSF/1 code is PIC.
-      lt_prog_compiler_static='-non_shared'
-      ;;
-
-    rdos*)
-      lt_prog_compiler_static='-non_shared'
-      ;;
-
-    solaris*)
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      case $cc_basename in
-      f77* | f90* | f95* | sunf77* | sunf90* | sunf95*)
-	lt_prog_compiler_wl='-Qoption ld ';;
-      *)
-	lt_prog_compiler_wl='-Wl,';;
-      esac
-      ;;
-
-    sunos4*)
-      lt_prog_compiler_wl='-Qoption ld '
-      lt_prog_compiler_pic='-PIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
-
-    sysv4 | sysv4.2uw2* | sysv4.3*)
-      lt_prog_compiler_wl='-Wl,'
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
-
-    sysv4*MP*)
-      if test -d /usr/nec ;then
-	lt_prog_compiler_pic='-Kconform_pic'
-	lt_prog_compiler_static='-Bstatic'
-      fi
-      ;;
-
-    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
-      lt_prog_compiler_wl='-Wl,'
-      lt_prog_compiler_pic='-KPIC'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
-
-    unicos*)
-      lt_prog_compiler_wl='-Wl,'
-      lt_prog_compiler_can_build_shared=no
-      ;;
-
-    uts4*)
-      lt_prog_compiler_pic='-pic'
-      lt_prog_compiler_static='-Bstatic'
-      ;;
-
-    *)
-      lt_prog_compiler_can_build_shared=no
-      ;;
-    esac
-  fi
-
-case $host_os in
-  # For platforms which do not support PIC, -DPIC is meaningless:
-  *djgpp*)
-    lt_prog_compiler_pic=
-    ;;
-  *)
-    lt_prog_compiler_pic="$lt_prog_compiler_pic -DPIC"
-    ;;
-esac
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
-$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
-if ${lt_cv_prog_compiler_pic+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_pic=$lt_prog_compiler_pic
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic" >&5
-$as_echo "$lt_cv_prog_compiler_pic" >&6; }
-lt_prog_compiler_pic=$lt_cv_prog_compiler_pic
-
-#
-# Check to make sure the PIC flag actually works.
-#
-if test -n "$lt_prog_compiler_pic"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic works" >&5
-$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic works... " >&6; }
-if ${lt_cv_prog_compiler_pic_works+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_pic_works=no
-   ac_outfile=conftest.$ac_objext
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-   lt_compiler_flag="$lt_prog_compiler_pic -DPIC"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   # The option is referenced via a variable to avoid confusing sed.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>conftest.err)
-   ac_status=$?
-   cat conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s "$ac_outfile"; then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings other than the usual output.
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
-     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_pic_works=yes
-     fi
-   fi
-   $RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_works" >&5
-$as_echo "$lt_cv_prog_compiler_pic_works" >&6; }
-
-if test x"$lt_cv_prog_compiler_pic_works" = xyes; then
-    case $lt_prog_compiler_pic in
-     "" | " "*) ;;
-     *) lt_prog_compiler_pic=" $lt_prog_compiler_pic" ;;
-     esac
-else
-    lt_prog_compiler_pic=
-     lt_prog_compiler_can_build_shared=no
-fi
-
-fi
-
-
-
-
-
-
-
-
-
-
-
-#
-# Check to make sure the static flag actually works.
-#
-wl=$lt_prog_compiler_wl eval lt_tmp_static_flag=\"$lt_prog_compiler_static\"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
-$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
-if ${lt_cv_prog_compiler_static_works+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_static_works=no
-   save_LDFLAGS="$LDFLAGS"
-   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
-   echo "$lt_simple_link_test_code" > conftest.$ac_ext
-   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
-     # The linker can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     if test -s conftest.err; then
-       # Append any errors to the config.log.
-       cat conftest.err 1>&5
-       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
-       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-       if diff conftest.exp conftest.er2 >/dev/null; then
-         lt_cv_prog_compiler_static_works=yes
-       fi
-     else
-       lt_cv_prog_compiler_static_works=yes
-     fi
-   fi
-   $RM -r conftest*
-   LDFLAGS="$save_LDFLAGS"
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_static_works" >&5
-$as_echo "$lt_cv_prog_compiler_static_works" >&6; }
-
-if test x"$lt_cv_prog_compiler_static_works" = xyes; then
-    :
-else
-    lt_prog_compiler_static=
-fi
-
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
-$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
-if ${lt_cv_prog_compiler_c_o+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_c_o=no
-   $RM -r conftest 2>/dev/null
-   mkdir conftest
-   cd conftest
-   mkdir out
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-
-   lt_compiler_flag="-o out/conftest2.$ac_objext"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>out/conftest.err)
-   ac_status=$?
-   cat out/conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s out/conftest2.$ac_objext
-   then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
-     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
-     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_c_o=yes
-     fi
-   fi
-   chmod u+w . 2>&5
-   $RM conftest*
-   # SGI C++ compiler will create directory out/ii_files/ for
-   # template instantiation
-   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
-   $RM out/* && rmdir out
-   cd ..
-   $RM -r conftest
-   $RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
-$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
-$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
-if ${lt_cv_prog_compiler_c_o+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_c_o=no
-   $RM -r conftest 2>/dev/null
-   mkdir conftest
-   cd conftest
-   mkdir out
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-
-   lt_compiler_flag="-o out/conftest2.$ac_objext"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>out/conftest.err)
-   ac_status=$?
-   cat out/conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s out/conftest2.$ac_objext
-   then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
-     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
-     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_c_o=yes
-     fi
-   fi
-   chmod u+w . 2>&5
-   $RM conftest*
-   # SGI C++ compiler will create directory out/ii_files/ for
-   # template instantiation
-   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
-   $RM out/* && rmdir out
-   cd ..
-   $RM -r conftest
-   $RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
-$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
-
-
-
-
-hard_links="nottested"
-if test "$lt_cv_prog_compiler_c_o" = no && test "$need_locks" != no; then
-  # do not overwrite the value of need_locks provided by the user
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
-$as_echo_n "checking if we can lock with hard links... " >&6; }
-  hard_links=yes
-  $RM conftest*
-  ln conftest.a conftest.b 2>/dev/null && hard_links=no
-  touch conftest.a
-  ln conftest.a conftest.b 2>&5 || hard_links=no
-  ln conftest.a conftest.b 2>/dev/null && hard_links=no
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
-$as_echo "$hard_links" >&6; }
-  if test "$hard_links" = no; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
-$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
-    need_locks=warn
-  fi
-else
-  need_locks=no
-fi
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
-$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
-
-  runpath_var=
-  allow_undefined_flag=
-  always_export_symbols=no
-  archive_cmds=
-  archive_expsym_cmds=
-  compiler_needs_object=no
-  enable_shared_with_static_runtimes=no
-  export_dynamic_flag_spec=
-  export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
-  hardcode_automatic=no
-  hardcode_direct=no
-  hardcode_direct_absolute=no
-  hardcode_libdir_flag_spec=
-  hardcode_libdir_flag_spec_ld=
-  hardcode_libdir_separator=
-  hardcode_minus_L=no
-  hardcode_shlibpath_var=unsupported
-  inherit_rpath=no
-  link_all_deplibs=unknown
-  module_cmds=
-  module_expsym_cmds=
-  old_archive_from_new_cmds=
-  old_archive_from_expsyms_cmds=
-  thread_safe_flag_spec=
-  whole_archive_flag_spec=
-  # include_expsyms should be a list of space-separated symbols to be *always*
-  # included in the symbol list
-  include_expsyms=
-  # exclude_expsyms can be an extended regexp of symbols to exclude
-  # it will be wrapped by ` (' and `)$', so one must not match beginning or
-  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
-  # as well as any symbol that contains `d'.
-  exclude_expsyms='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
-  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
-  # platforms (ab)use it in PIC code, but their linkers get confused if
-  # the symbol is explicitly referenced.  Since portable code cannot
-  # rely on this symbol name, it's probably fine to never include it in
-  # preloaded symbol tables.
-  # Exclude shared library initialization/finalization symbols.
-  extract_expsyms_cmds=
-
-  case $host_os in
-  cygwin* | mingw* | pw32* | cegcc*)
-    # FIXME: the MSVC++ port hasn't been tested in a loooong time
-    # When not using gcc, we currently assume that we are using
-    # Microsoft Visual C++.
-    if test "$GCC" != yes; then
-      with_gnu_ld=no
-    fi
-    ;;
-  interix*)
-    # we just hope/assume this is gcc and not c89 (= MSVC++)
-    with_gnu_ld=yes
-    ;;
-  openbsd*)
-    with_gnu_ld=no
-    ;;
-  linux* | k*bsd*-gnu | gnu*)
-    link_all_deplibs=no
-    ;;
-  esac
-
-  ld_shlibs=yes
-
-  # On some targets, GNU ld is compatible enough with the native linker
-  # that we're better off using the native interface for both.
-  lt_use_gnu_ld_interface=no
-  if test "$with_gnu_ld" = yes; then
-    case $host_os in
-      aix*)
-	# The AIX port of GNU ld has always aspired to compatibility
-	# with the native linker.  However, as the warning in the GNU ld
-	# block says, versions before 2.19.5* couldn't really create working
-	# shared libraries, regardless of the interface used.
-	case `$LD -v 2>&1` in
-	  *\ \(GNU\ Binutils\)\ 2.19.5*) ;;
-	  *\ \(GNU\ Binutils\)\ 2.[2-9]*) ;;
-	  *\ \(GNU\ Binutils\)\ [3-9]*) ;;
-	  *)
-	    lt_use_gnu_ld_interface=yes
-	    ;;
-	esac
-	;;
-      *)
-	lt_use_gnu_ld_interface=yes
-	;;
-    esac
-  fi
-
-  if test "$lt_use_gnu_ld_interface" = yes; then
-    # If archive_cmds runs LD, not CC, wlarc should be empty
-    wlarc='${wl}'
-
-    # Set some defaults for GNU ld with shared library support. These
-    # are reset later if shared libraries are not supported. Putting them
-    # here allows them to be overridden if necessary.
-    runpath_var=LD_RUN_PATH
-    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-    export_dynamic_flag_spec='${wl}--export-dynamic'
-    # ancient GNU ld didn't support --whole-archive et. al.
-    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
-      whole_archive_flag_spec="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
-    else
-      whole_archive_flag_spec=
-    fi
-    supports_anon_versioning=no
-    case `$LD -v 2>&1` in
-      *GNU\ gold*) supports_anon_versioning=yes ;;
-      *\ [01].* | *\ 2.[0-9].* | *\ 2.10.*) ;; # catch versions < 2.11
-      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
-      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
-      *\ 2.11.*) ;; # other 2.11 versions
-      *) supports_anon_versioning=yes ;;
-    esac
-
-    # See if GNU ld supports shared libraries.
-    case $host_os in
-    aix[3-9]*)
-      # On AIX/PPC, the GNU linker is very broken
-      if test "$host_cpu" != ia64; then
-	ld_shlibs=no
-	cat <<_LT_EOF 1>&2
-
-*** Warning: the GNU linker, at least up to release 2.19, is reported
-*** to be unable to reliably create shared libraries on AIX.
-*** Therefore, libtool is disabling shared libraries support.  If you
-*** really care for shared libraries, you may want to install binutils
-*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.
-*** You will then need to restart the configuration process.
-
-_LT_EOF
-      fi
-      ;;
-
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-            archive_expsym_cmds=''
-        ;;
-      m68k)
-            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
-            hardcode_libdir_flag_spec='-L$libdir'
-            hardcode_minus_L=yes
-        ;;
-      esac
-      ;;
-
-    beos*)
-      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	allow_undefined_flag=unsupported
-	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
-	# support --undefined.  This deserves some investigation.  FIXME
-	archive_cmds='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
-
-    cygwin* | mingw* | pw32* | cegcc*)
-      # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
-      # as there is no search path for DLLs.
-      hardcode_libdir_flag_spec='-L$libdir'
-      export_dynamic_flag_spec='${wl}--export-all-symbols'
-      allow_undefined_flag=unsupported
-      always_export_symbols=no
-      enable_shared_with_static_runtimes=yes
-      export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1 DATA/;s/^.*[ ]__nm__\([^ ]*\)[ ][^ ]*/\1 DATA/;/^I[ ]/d;/^[AITW][ ]/s/.* //'\'' | sort | uniq > $export_symbols'
-      exclude_expsyms='[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname'
-
-      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
-        archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-	# If the export-symbols file already is a .def file (1st line
-	# is EXPORTS), use it as is; otherwise, prepend...
-	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	  cp $export_symbols $output_objdir/$soname.def;
-	else
-	  echo EXPORTS > $output_objdir/$soname.def;
-	  cat $export_symbols >> $output_objdir/$soname.def;
-	fi~
-	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
-
-    haiku*)
-      archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-      link_all_deplibs=yes
-      ;;
-
-    interix[3-9]*)
-      hardcode_direct=no
-      hardcode_shlibpath_var=no
-      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-      export_dynamic_flag_spec='${wl}-E'
-      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
-      # Instead, shared libraries are loaded at an image base (0x10000000 by
-      # default) and relocated if they conflict, which is a slow very memory
-      # consuming and fragmenting process.  To avoid this, we pick a random,
-      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
-      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
-      archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-      archive_expsym_cmds='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-      ;;
-
-    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
-      tmp_diet=no
-      if test "$host_os" = linux-dietlibc; then
-	case $cc_basename in
-	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
-	esac
-      fi
-      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
-	 && test "$tmp_diet" = no
-      then
-	tmp_addflag=' $pic_flag'
-	tmp_sharedflag='-shared'
-	case $cc_basename,$host_cpu in
-        pgcc*)				# Portland Group C compiler
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	  tmp_addflag=' $pic_flag'
-	  ;;
-	pgf77* | pgf90* | pgf95* | pgfortran*)
-					# Portland Group f77 and f90 compilers
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	  tmp_addflag=' $pic_flag -Mnomain' ;;
-	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
-	  tmp_addflag=' -i_dynamic' ;;
-	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
-	  tmp_addflag=' -i_dynamic -nofor_main' ;;
-	ifc* | ifort*)			# Intel Fortran compiler
-	  tmp_addflag=' -nofor_main' ;;
-	lf95*)				# Lahey Fortran 8.1
-	  whole_archive_flag_spec=
-	  tmp_sharedflag='--shared' ;;
-	xl[cC]* | bgxl[cC]* | mpixl[cC]*) # IBM XL C 8.0 on PPC (deal with xlf below)
-	  tmp_sharedflag='-qmkshrobj'
-	  tmp_addflag= ;;
-	nvcc*)	# Cuda Compiler Driver 2.2
-	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	  compiler_needs_object=yes
-	  ;;
-	esac
-	case `$CC -V 2>&1 | sed 5q` in
-	*Sun\ C*)			# Sun C 5.9
-	  whole_archive_flag_spec='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	  compiler_needs_object=yes
-	  tmp_sharedflag='-G' ;;
-	*Sun\ F*)			# Sun Fortran 8.3
-	  tmp_sharedflag='-G' ;;
-	esac
-	archive_cmds='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-
-        if test "x$supports_anon_versioning" = xyes; then
-          archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
-	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-	    echo "local: *; };" >> $output_objdir/$libname.ver~
-	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
-        fi
-
-	case $cc_basename in
-	xlf* | bgf* | bgxlf* | mpixlf*)
-	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
-	  whole_archive_flag_spec='--whole-archive$convenience --no-whole-archive'
-	  hardcode_libdir_flag_spec=
-	  hardcode_libdir_flag_spec_ld='-rpath $libdir'
-	  archive_cmds='$LD -shared $libobjs $deplibs $linker_flags -soname $soname -o $lib'
-	  if test "x$supports_anon_versioning" = xyes; then
-	    archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
-	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-	      echo "local: *; };" >> $output_objdir/$libname.ver~
-	      $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
-	  fi
-	  ;;
-	esac
-      else
-        ld_shlibs=no
-      fi
-      ;;
-
-    netbsd* | netbsdelf*-gnu)
-      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-	archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
-	wlarc=
-      else
-	archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-      fi
-      ;;
-
-    solaris*)
-      if $LD -v 2>&1 | $GREP 'BFD 2\.8' > /dev/null; then
-	ld_shlibs=no
-	cat <<_LT_EOF 1>&2
-
-*** Warning: The releases 2.8.* of the GNU linker cannot reliably
-*** create shared libraries on Solaris systems.  Therefore, libtool
-*** is disabling shared libraries support.  We urge you to upgrade GNU
-*** binutils to release 2.9.1 or newer.  Another option is to modify
-*** your PATH or compiler configuration so that the native linker is
-*** used, and then restart.
-
-_LT_EOF
-      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
-
-    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
-      case `$LD -v 2>&1` in
-        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
-	ld_shlibs=no
-	cat <<_LT_EOF 1>&2
-
-*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
-*** reliably create shared libraries on SCO systems.  Therefore, libtool
-*** is disabling shared libraries support.  We urge you to upgrade GNU
-*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
-*** your PATH or compiler configuration so that the native linker is
-*** used, and then restart.
-
-_LT_EOF
-	;;
-	*)
-	  # For security reasons, it is highly recommended that you always
-	  # use absolute paths for naming shared libraries, and exclude the
-	  # DT_RUNPATH tag from executables and libraries.  But doing so
-	  # requires that you compile everything twice, which is a pain.
-	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-	    archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	    archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-	  else
-	    ld_shlibs=no
-	  fi
-	;;
-      esac
-      ;;
-
-    sunos4*)
-      archive_cmds='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-      wlarc=
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    *)
-      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-      else
-	ld_shlibs=no
-      fi
-      ;;
-    esac
-
-    if test "$ld_shlibs" = no; then
-      runpath_var=
-      hardcode_libdir_flag_spec=
-      export_dynamic_flag_spec=
-      whole_archive_flag_spec=
-    fi
-  else
-    # PORTME fill in a description of your system's linker (not GNU ld)
-    case $host_os in
-    aix3*)
-      allow_undefined_flag=unsupported
-      always_export_symbols=yes
-      archive_expsym_cmds='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
-      # Note: this linker hardcodes the directories in LIBPATH if there
-      # are no directories specified by -L.
-      hardcode_minus_L=yes
-      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
-	# Neither direct hardcoding nor static linking is supported with a
-	# broken collect2.
-	hardcode_direct=unsupported
-      fi
-      ;;
-
-    aix[4-9]*)
-      if test "$host_cpu" = ia64; then
-	# On IA64, the linker does run time linking by default, so we don't
-	# have to do anything special.
-	aix_use_runtimelinking=no
-	exp_sym_flag='-Bexport'
-	no_entry_flag=""
-      else
-	# If we're using GNU nm, then we don't want the "-C" option.
-	# -C means demangle to AIX nm, but means don't demangle with GNU nm
-	# Also, AIX nm treats weak defined symbols like other global
-	# defined symbols, whereas GNU nm marks them as "W".
-	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
-	  export_symbols_cmds='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
-	else
-	  export_symbols_cmds='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
-	fi
-	aix_use_runtimelinking=no
-
-	# Test if we are trying to use run time linking or normal
-	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
-	# need to do runtime linking.
-	case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
-	  for ld_flag in $LDFLAGS; do
-	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
-	    aix_use_runtimelinking=yes
-	    break
-	  fi
-	  done
-	  ;;
-	esac
-
-	exp_sym_flag='-bexport'
-	no_entry_flag='-bnoentry'
-      fi
-
-      # When large executables or shared objects are built, AIX ld can
-      # have problems creating the table of contents.  If linking a library
-      # or program results in "error TOC overflow" add -mminimal-toc to
-      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
-      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
-
-      archive_cmds=''
-      hardcode_direct=yes
-      hardcode_direct_absolute=yes
-      hardcode_libdir_separator=':'
-      link_all_deplibs=yes
-      file_list_spec='${wl}-f,'
-
-      if test "$GCC" = yes; then
-	case $host_os in aix4.[012]|aix4.[012].*)
-	# We only want to do this on AIX 4.2 and lower, the check
-	# below for broken collect2 doesn't work under 4.3+
-	  collect2name=`${CC} -print-prog-name=collect2`
-	  if test -f "$collect2name" &&
-	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
-	  then
-	  # We have reworked collect2
-	  :
-	  else
-	  # We have old collect2
-	  hardcode_direct=unsupported
-	  # It fails to find uninstalled libraries when the uninstalled
-	  # path is not listed in the libpath.  Setting hardcode_minus_L
-	  # to unsupported forces relinking
-	  hardcode_minus_L=yes
-	  hardcode_libdir_flag_spec='-L$libdir'
-	  hardcode_libdir_separator=
-	  fi
-	  ;;
-	esac
-	shared_flag='-shared'
-	if test "$aix_use_runtimelinking" = yes; then
-	  shared_flag="$shared_flag "'${wl}-G'
-	fi
-	link_all_deplibs=no
-      else
-	# not using gcc
-	if test "$host_cpu" = ia64; then
-	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
-	# chokes on -Wl,-G. The following line is correct:
-	  shared_flag='-G'
-	else
-	  if test "$aix_use_runtimelinking" = yes; then
-	    shared_flag='${wl}-G'
-	  else
-	    shared_flag='${wl}-bM:SRE'
-	  fi
-	fi
-      fi
-
-      export_dynamic_flag_spec='${wl}-bexpall'
-      # It seems that -bexpall does not export symbols beginning with
-      # underscore (_), so it is better to generate a list of symbols to export.
-      always_export_symbols=yes
-      if test "$aix_use_runtimelinking" = yes; then
-	# Warning - without using the other runtime loading flags (-brtl),
-	# -berok will link without error, but may produce a broken library.
-	allow_undefined_flag='-berok'
-        # Determine the default libpath from the value encoded in an
-        # empty executable.
-        if test "${lt_cv_aix_libpath+set}" = set; then
-  aix_libpath=$lt_cv_aix_libpath
-else
-  if ${lt_cv_aix_libpath_+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-  lt_aix_libpath_sed='
-      /Import File Strings/,/^$/ {
-	  /^0/ {
-	      s/^0  *\([^ ]*\) *$/\1/
-	      p
-	  }
-      }'
-  lt_cv_aix_libpath_=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-  # Check for a 64-bit object if we didn't find anything.
-  if test -z "$lt_cv_aix_libpath_"; then
-    lt_cv_aix_libpath_=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-  fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-  if test -z "$lt_cv_aix_libpath_"; then
-    lt_cv_aix_libpath_="/usr/lib:/lib"
-  fi
-
-fi
-
-  aix_libpath=$lt_cv_aix_libpath_
-fi
-
-        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
-        archive_expsym_cmds='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
-      else
-	if test "$host_cpu" = ia64; then
-	  hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
-	  allow_undefined_flag="-z nodefs"
-	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
-	else
-	 # Determine the default libpath from the value encoded in an
-	 # empty executable.
-	 if test "${lt_cv_aix_libpath+set}" = set; then
-  aix_libpath=$lt_cv_aix_libpath
-else
-  if ${lt_cv_aix_libpath_+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-
-  lt_aix_libpath_sed='
-      /Import File Strings/,/^$/ {
-	  /^0/ {
-	      s/^0  *\([^ ]*\) *$/\1/
-	      p
-	  }
-      }'
-  lt_cv_aix_libpath_=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-  # Check for a 64-bit object if we didn't find anything.
-  if test -z "$lt_cv_aix_libpath_"; then
-    lt_cv_aix_libpath_=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-  fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-  if test -z "$lt_cv_aix_libpath_"; then
-    lt_cv_aix_libpath_="/usr/lib:/lib"
-  fi
-
-fi
-
-  aix_libpath=$lt_cv_aix_libpath_
-fi
-
-	 hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
-	  # Warning - without using the other run time loading flags,
-	  # -berok will link without error, but may produce a broken library.
-	  no_undefined_flag=' ${wl}-bernotok'
-	  allow_undefined_flag=' ${wl}-berok'
-	  if test "$with_gnu_ld" = yes; then
-	    # We only use this code for GNU lds that support --whole-archive.
-	    whole_archive_flag_spec='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
-	  else
-	    # Exported symbols can be pulled into shared objects from archives
-	    whole_archive_flag_spec='$convenience'
-	  fi
-	  archive_cmds_need_lc=yes
-	  # This is similar to how AIX traditionally builds its shared libraries.
-	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
-	fi
-      fi
-      ;;
-
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-            archive_expsym_cmds=''
-        ;;
-      m68k)
-            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
-            hardcode_libdir_flag_spec='-L$libdir'
-            hardcode_minus_L=yes
-        ;;
-      esac
-      ;;
-
-    bsdi[45]*)
-      export_dynamic_flag_spec=-rdynamic
-      ;;
-
-    cygwin* | mingw* | pw32* | cegcc*)
-      # When not using gcc, we currently assume that we are using
-      # Microsoft Visual C++.
-      # hardcode_libdir_flag_spec is actually meaningless, as there is
-      # no search path for DLLs.
-      case $cc_basename in
-      cl*)
-	# Native MSVC
-	hardcode_libdir_flag_spec=' '
-	allow_undefined_flag=unsupported
-	always_export_symbols=yes
-	file_list_spec='@'
-	# Tell ltmain to make .lib files, not .a files.
-	libext=lib
-	# Tell ltmain to make .dll files, not .so files.
-	shrext_cmds=".dll"
-	# FIXME: Setting linknames here is a bad hack.
-	archive_cmds='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='
-	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	    sed -n -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' -e '1\\\!p' < $export_symbols > $output_objdir/$soname.exp;
-	  else
-	    sed -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;
-	  fi~
-	  $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
-	  linknames='
-	# The linker will not automatically build a static lib if we build a DLL.
-	# _LT_TAGVAR(old_archive_from_new_cmds, )='true'
-	enable_shared_with_static_runtimes=yes
-	export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1,DATA/'\'' | $SED -e '\''/^[AITW][ ]/s/.*[ ]//'\'' | sort | uniq > $export_symbols'
-	# Don't use ranlib
-	old_postinstall_cmds='chmod 644 $oldlib'
-	postlink_cmds='lt_outputfile="@OUTPUT@"~
-	  lt_tool_outputfile="@TOOL_OUTPUT@"~
-	  case $lt_outputfile in
-	    *.exe|*.EXE) ;;
-	    *)
-	      lt_outputfile="$lt_outputfile.exe"
-	      lt_tool_outputfile="$lt_tool_outputfile.exe"
-	      ;;
-	  esac~
-	  if test "$MANIFEST_TOOL" != ":" && test -f "$lt_outputfile.manifest"; then
-	    $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
-	    $RM "$lt_outputfile.manifest";
-	  fi'
-	;;
-      *)
-	# Assume MSVC wrapper
-	hardcode_libdir_flag_spec=' '
-	allow_undefined_flag=unsupported
-	# Tell ltmain to make .lib files, not .a files.
-	libext=lib
-	# Tell ltmain to make .dll files, not .so files.
-	shrext_cmds=".dll"
-	# FIXME: Setting linknames here is a bad hack.
-	archive_cmds='$CC -o $lib $libobjs $compiler_flags `func_echo_all "$deplibs" | $SED '\''s/ -lc$//'\''` -link -dll~linknames='
-	# The linker will automatically build a .lib file if we build a DLL.
-	old_archive_from_new_cmds='true'
-	# FIXME: Should let the user specify the lib program.
-	old_archive_cmds='lib -OUT:$oldlib$oldobjs$old_deplibs'
-	enable_shared_with_static_runtimes=yes
-	;;
-      esac
-      ;;
-
-    darwin* | rhapsody*)
-
-
-  archive_cmds_need_lc=no
-  hardcode_direct=no
-  hardcode_automatic=yes
-  hardcode_shlibpath_var=unsupported
-  if test "$lt_cv_ld_force_load" = "yes"; then
-    whole_archive_flag_spec='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience ${wl}-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
-  else
-    whole_archive_flag_spec=''
-  fi
-  link_all_deplibs=yes
-  allow_undefined_flag="$_lt_dar_allow_undefined"
-  case $cc_basename in
-     ifort*) _lt_dar_can_shared=yes ;;
-     *) _lt_dar_can_shared=$GCC ;;
-  esac
-  if test "$_lt_dar_can_shared" = "yes"; then
-    output_verbose_link_cmd=func_echo_all
-    archive_cmds="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
-    module_cmds="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
-    archive_expsym_cmds="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
-    module_expsym_cmds="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
-
-  else
-  ld_shlibs=no
-  fi
-
-      ;;
-
-    dgux*)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_shlibpath_var=no
-      ;;
-
-    freebsd1*)
-      ld_shlibs=no
-      ;;
-
-    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
-    # support.  Future versions do this automatically, but an explicit c++rt0.o
-    # does not break anything, and helps significantly (at the cost of a little
-    # extra space).
-    freebsd2.2*)
-      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
-    freebsd2*)
-      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_direct=yes
-      hardcode_minus_L=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
-    freebsd* | dragonfly*)
-      archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    hpux9*)
-      if test "$GCC" = yes; then
-	archive_cmds='$RM $output_objdir/$soname~$CC -shared $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
-      else
-	archive_cmds='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
-      fi
-      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-      hardcode_libdir_separator=:
-      hardcode_direct=yes
-
-      # hardcode_minus_L: Not really in the search PATH,
-      # but as the default location of the library.
-      hardcode_minus_L=yes
-      export_dynamic_flag_spec='${wl}-E'
-      ;;
-
-    hpux10*)
-      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
-	archive_cmds='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
-      fi
-      if test "$with_gnu_ld" = no; then
-	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-	hardcode_libdir_flag_spec_ld='+b $libdir'
-	hardcode_libdir_separator=:
-	hardcode_direct=yes
-	hardcode_direct_absolute=yes
-	export_dynamic_flag_spec='${wl}-E'
-	# hardcode_minus_L: Not really in the search PATH,
-	# but as the default location of the library.
-	hardcode_minus_L=yes
-      fi
-      ;;
-
-    hpux11*)
-      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
-	case $host_cpu in
-	hppa*64*)
-	  archive_cmds='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	ia64*)
-	  archive_cmds='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	*)
-	  archive_cmds='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	esac
-      else
-	case $host_cpu in
-	hppa*64*)
-	  archive_cmds='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	ia64*)
-	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	*)
-
-	  # Older versions of the 11.00 compiler do not understand -b yet
-	  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)
-	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $CC understands -b" >&5
-$as_echo_n "checking if $CC understands -b... " >&6; }
-if ${lt_cv_prog_compiler__b+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler__b=no
-   save_LDFLAGS="$LDFLAGS"
-   LDFLAGS="$LDFLAGS -b"
-   echo "$lt_simple_link_test_code" > conftest.$ac_ext
-   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
-     # The linker can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     if test -s conftest.err; then
-       # Append any errors to the config.log.
-       cat conftest.err 1>&5
-       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
-       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-       if diff conftest.exp conftest.er2 >/dev/null; then
-         lt_cv_prog_compiler__b=yes
-       fi
-     else
-       lt_cv_prog_compiler__b=yes
-     fi
-   fi
-   $RM -r conftest*
-   LDFLAGS="$save_LDFLAGS"
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler__b" >&5
-$as_echo "$lt_cv_prog_compiler__b" >&6; }
-
-if test x"$lt_cv_prog_compiler__b" = xyes; then
-    archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
-else
-    archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
-fi
-
-	  ;;
-	esac
-      fi
-      if test "$with_gnu_ld" = no; then
-	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
-	hardcode_libdir_separator=:
-
-	case $host_cpu in
-	hppa*64*|ia64*)
-	  hardcode_direct=no
-	  hardcode_shlibpath_var=no
-	  ;;
-	*)
-	  hardcode_direct=yes
-	  hardcode_direct_absolute=yes
-	  export_dynamic_flag_spec='${wl}-E'
-
-	  # hardcode_minus_L: Not really in the search PATH,
-	  # but as the default location of the library.
-	  hardcode_minus_L=yes
-	  ;;
-	esac
-      fi
-      ;;
-
-    irix5* | irix6* | nonstopux*)
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-	# Try to use the -exported_symbol ld option, if it does not
-	# work, assume that -exports_file does not work either and
-	# implicitly export all symbols.
-	# This should be the same for all languages, so no per-tag cache variable.
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $host_os linker accepts -exported_symbol" >&5
-$as_echo_n "checking whether the $host_os linker accepts -exported_symbol... " >&6; }
-if ${lt_cv_irix_exported_symbol+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  save_LDFLAGS="$LDFLAGS"
-	   LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
-	   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-int foo (void) { return 0; }
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  lt_cv_irix_exported_symbol=yes
-else
-  lt_cv_irix_exported_symbol=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-           LDFLAGS="$save_LDFLAGS"
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_irix_exported_symbol" >&5
-$as_echo "$lt_cv_irix_exported_symbol" >&6; }
-	if test "$lt_cv_irix_exported_symbol" = yes; then
-          archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
-	fi
-      else
-	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
-      fi
-      archive_cmds_need_lc='no'
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      inherit_rpath=yes
-      link_all_deplibs=yes
-      ;;
-
-    netbsd* | netbsdelf*-gnu)
-      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
-      else
-	archive_cmds='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
-      fi
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_direct=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    newsos6)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_direct=yes
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      hardcode_shlibpath_var=no
-      ;;
-
-    *nto* | *qnx*)
-      ;;
-
-    openbsd*)
-      if test -f /usr/libexec/ld.so; then
-	hardcode_direct=yes
-	hardcode_shlibpath_var=no
-	hardcode_direct_absolute=yes
-	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-	  archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
-	  hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-	  export_dynamic_flag_spec='${wl}-E'
-	else
-	  case $host_os in
-	   openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
-	     archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
-	     hardcode_libdir_flag_spec='-R$libdir'
-	     ;;
-	   *)
-	     archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
-	     hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
-	     ;;
-	  esac
-	fi
-      else
-	ld_shlibs=no
-      fi
-      ;;
-
-    os2*)
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_minus_L=yes
-      allow_undefined_flag=unsupported
-      archive_cmds='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
-      old_archive_from_new_cmds='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
-      ;;
-
-    osf3*)
-      if test "$GCC" = yes; then
-	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-      else
-	allow_undefined_flag=' -expect_unresolved \*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-      fi
-      archive_cmds_need_lc='no'
-      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      hardcode_libdir_separator=:
-      ;;
-
-    osf4* | osf5*)	# as osf3* with the addition of -msym flag
-      if test "$GCC" = yes; then
-	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $pic_flag $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-	hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
-      else
-	allow_undefined_flag=' -expect_unresolved \*'
-	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-	archive_expsym_cmds='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
-	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
-
-	# Both c and cxx compiler support -rpath directly
-	hardcode_libdir_flag_spec='-rpath $libdir'
-      fi
-      archive_cmds_need_lc='no'
-      hardcode_libdir_separator=:
-      ;;
-
-    solaris*)
-      no_undefined_flag=' -z defs'
-      if test "$GCC" = yes; then
-	wlarc='${wl}'
-	archive_cmds='$CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
-      else
-	case `$CC -V 2>&1` in
-	*"Compilers 5.0"*)
-	  wlarc=''
-	  archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
-	  ;;
-	*)
-	  wlarc='${wl}'
-	  archive_cmds='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
-	  ;;
-	esac
-      fi
-      hardcode_libdir_flag_spec='-R$libdir'
-      hardcode_shlibpath_var=no
-      case $host_os in
-      solaris2.[0-5] | solaris2.[0-5].*) ;;
-      *)
-	# The compiler driver will combine and reorder linker options,
-	# but understands `-z linker_flag'.  GCC discards it without `$wl',
-	# but is careful enough not to reorder.
-	# Supported since Solaris 2.6 (maybe 2.5.1?)
-	if test "$GCC" = yes; then
-	  whole_archive_flag_spec='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
-	else
-	  whole_archive_flag_spec='-z allextract$convenience -z defaultextract'
-	fi
-	;;
-      esac
-      link_all_deplibs=yes
-      ;;
-
-    sunos4*)
-      if test "x$host_vendor" = xsequent; then
-	# Use $CC to link under sequent, because it throws in some extra .o
-	# files that make .init and .fini sections work.
-	archive_cmds='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
-      fi
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_direct=yes
-      hardcode_minus_L=yes
-      hardcode_shlibpath_var=no
-      ;;
-
-    sysv4)
-      case $host_vendor in
-	sni)
-	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	  hardcode_direct=yes # is this really true???
-	;;
-	siemens)
-	  ## LD is ld it makes a PLAMLIB
-	  ## CC just makes a GrossModule.
-	  archive_cmds='$LD -G -o $lib $libobjs $deplibs $linker_flags'
-	  reload_cmds='$CC -r -o $output$reload_objs'
-	  hardcode_direct=no
-        ;;
-	motorola)
-	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	  hardcode_direct=no #Motorola manual says yes, but my tests say they lie
-	;;
-      esac
-      runpath_var='LD_RUN_PATH'
-      hardcode_shlibpath_var=no
-      ;;
-
-    sysv4.3*)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_shlibpath_var=no
-      export_dynamic_flag_spec='-Bexport'
-      ;;
-
-    sysv4*MP*)
-      if test -d /usr/nec; then
-	archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-	hardcode_shlibpath_var=no
-	runpath_var=LD_RUN_PATH
-	hardcode_runpath_var=yes
-	ld_shlibs=yes
-      fi
-      ;;
-
-    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
-      no_undefined_flag='${wl}-z,text'
-      archive_cmds_need_lc=no
-      hardcode_shlibpath_var=no
-      runpath_var='LD_RUN_PATH'
-
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      fi
-      ;;
-
-    sysv5* | sco3.2v5* | sco5v6*)
-      # Note: We can NOT use -z defs as we might desire, because we do not
-      # link with -lc, and that would cause any symbols used from libc to
-      # always be unresolved, which means just about no library would
-      # ever link correctly.  If we're not using GNU ld we use -z text
-      # though, which does catch some bad symbols but isn't as heavy-handed
-      # as -z defs.
-      no_undefined_flag='${wl}-z,text'
-      allow_undefined_flag='${wl}-z,nodefs'
-      archive_cmds_need_lc=no
-      hardcode_shlibpath_var=no
-      hardcode_libdir_flag_spec='${wl}-R,$libdir'
-      hardcode_libdir_separator=':'
-      link_all_deplibs=yes
-      export_dynamic_flag_spec='${wl}-Bexport'
-      runpath_var='LD_RUN_PATH'
-
-      if test "$GCC" = yes; then
-	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      else
-	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-      fi
-      ;;
-
-    uts4*)
-      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
-      hardcode_libdir_flag_spec='-L$libdir'
-      hardcode_shlibpath_var=no
-      ;;
-
-    *)
-      ld_shlibs=no
-      ;;
-    esac
-
-    if test x$host_vendor = xsni; then
-      case $host in
-      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
-	export_dynamic_flag_spec='${wl}-Blargedynsym'
-	;;
-      esac
-    fi
-  fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs" >&5
-$as_echo "$ld_shlibs" >&6; }
-test "$ld_shlibs" = no && can_build_shared=no
-
-with_gnu_ld=$with_gnu_ld
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-#
-# Do we need to explicitly link libc?
-#
-case "x$archive_cmds_need_lc" in
-x|xyes)
-  # Assume -lc should be added
-  archive_cmds_need_lc=yes
-
-  if test "$enable_shared" = yes && test "$GCC" = yes; then
-    case $archive_cmds in
-    *'~'*)
-      # FIXME: we may have to deal with multi-command sequences.
-      ;;
-    '$CC '*)
-      # Test whether the compiler implicitly links with -lc since on some
-      # systems, -lgcc has to come before -lc. If gcc already passes -lc
-      # to ld, don't add -lc before -lgcc.
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
-$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
-if ${lt_cv_archive_cmds_need_lc+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  $RM conftest*
-	echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-
-	if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } 2>conftest.err; then
-	  soname=conftest
-	  lib=conftest
-	  libobjs=conftest.$ac_objext
-	  deplibs=
-	  wl=$lt_prog_compiler_wl
-	  pic_flag=$lt_prog_compiler_pic
-	  compiler_flags=-v
-	  linker_flags=-v
-	  verstring=
-	  output_objdir=.
-	  libname=conftest
-	  lt_save_allow_undefined_flag=$allow_undefined_flag
-	  allow_undefined_flag=
-	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\""; } >&5
-  (eval $archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-	  then
-	    lt_cv_archive_cmds_need_lc=no
-	  else
-	    lt_cv_archive_cmds_need_lc=yes
-	  fi
-	  allow_undefined_flag=$lt_save_allow_undefined_flag
-	else
-	  cat conftest.err 1>&5
-	fi
-	$RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_archive_cmds_need_lc" >&5
-$as_echo "$lt_cv_archive_cmds_need_lc" >&6; }
-      archive_cmds_need_lc=$lt_cv_archive_cmds_need_lc
-      ;;
-    esac
-  fi
-  ;;
-esac
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
-$as_echo_n "checking dynamic linker characteristics... " >&6; }
-
-if test "$GCC" = yes; then
-  case $host_os in
-    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
-    *) lt_awk_arg="/^libraries:/" ;;
-  esac
-  case $host_os in
-    mingw* | cegcc*) lt_sed_strip_eq="s,=\([A-Za-z]:\),\1,g" ;;
-    *) lt_sed_strip_eq="s,=/,/,g" ;;
-  esac
-  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e $lt_sed_strip_eq`
-  case $lt_search_path_spec in
-  *\;*)
-    # if the path contains ";" then we assume it to be the separator
-    # otherwise default to the standard path separator (i.e. ":") - it is
-    # assumed that no part of a normal pathname contains ";" but that should
-    # okay in the real world where ";" in dirpaths is itself problematic.
-    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED 's/;/ /g'`
-    ;;
-  *)
-    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED "s/$PATH_SEPARATOR/ /g"`
-    ;;
-  esac
-  # Ok, now we have the path, separated by spaces, we can step through it
-  # and add multilib dir if necessary.
-  lt_tmp_lt_search_path_spec=
-  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
-  for lt_sys_path in $lt_search_path_spec; do
-    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
-      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
-    else
-      test -d "$lt_sys_path" && \
-	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
-    fi
-  done
-  lt_search_path_spec=`$ECHO "$lt_tmp_lt_search_path_spec" | awk '
-BEGIN {RS=" "; FS="/|\n";} {
-  lt_foo="";
-  lt_count=0;
-  for (lt_i = NF; lt_i > 0; lt_i--) {
-    if ($lt_i != "" && $lt_i != ".") {
-      if ($lt_i == "..") {
-        lt_count++;
-      } else {
-        if (lt_count == 0) {
-          lt_foo="/" $lt_i lt_foo;
-        } else {
-          lt_count--;
-        }
-      }
-    }
-  }
-  if (lt_foo != "") { lt_freq[lt_foo]++; }
-  if (lt_freq[lt_foo] == 1) { print lt_foo; }
-}'`
-  # AWK program above erroneously prepends '/' to C:/dos/paths
-  # for these hosts.
-  case $host_os in
-    mingw* | cegcc*) lt_search_path_spec=`$ECHO "$lt_search_path_spec" |\
-      $SED 's,/\([A-Za-z]:\),\1,g'` ;;
-  esac
-  sys_lib_search_path_spec=`$ECHO "$lt_search_path_spec" | $lt_NL2SP`
-else
-  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
-fi
-library_names_spec=
-libname_spec='lib$name'
-soname_spec=
-shrext_cmds=".so"
-postinstall_cmds=
-postuninstall_cmds=
-finish_cmds=
-finish_eval=
-shlibpath_var=
-shlibpath_overrides_runpath=unknown
-version_type=none
-dynamic_linker="$host_os ld.so"
-sys_lib_dlsearch_path_spec="/lib /usr/lib"
-need_lib_prefix=unknown
-hardcode_into_libs=no
-
-# when you set need_version to no, make sure it does not cause -set_version
-# flags to be left without arguments
-need_version=unknown
-
-case $host_os in
-aix3*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
-  shlibpath_var=LIBPATH
-
-  # AIX 3 has no versioning support, so we append a major version to the name.
-  soname_spec='${libname}${release}${shared_ext}$major'
-  ;;
-
-aix[4-9]*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  hardcode_into_libs=yes
-  if test "$host_cpu" = ia64; then
-    # AIX 5 supports IA64
-    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
-    shlibpath_var=LD_LIBRARY_PATH
-  else
-    # With GCC up to 2.95.x, collect2 would create an import file
-    # for dependence libraries.  The import file would start with
-    # the line `#! .'.  This would cause the generated library to
-    # depend on `.', always an invalid library.  This was fixed in
-    # development snapshots of GCC prior to 3.0.
-    case $host_os in
-      aix4 | aix4.[01] | aix4.[01].*)
-      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
-	   echo ' yes '
-	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
-	:
-      else
-	can_build_shared=no
-      fi
-      ;;
-    esac
-    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
-    # soname into executable. Probably we can add versioning support to
-    # collect2, so additional links can be useful in future.
-    if test "$aix_use_runtimelinking" = yes; then
-      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
-      # instead of lib<name>.a to let people know that these are not
-      # typical AIX shared libraries.
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    else
-      # We preserve .a as extension for shared libraries through AIX4.2
-      # and later when we are not doing run time linking.
-      library_names_spec='${libname}${release}.a $libname.a'
-      soname_spec='${libname}${release}${shared_ext}$major'
-    fi
-    shlibpath_var=LIBPATH
-  fi
-  ;;
-
-amigaos*)
-  case $host_cpu in
-  powerpc)
-    # Since July 2007 AmigaOS4 officially supports .so libraries.
-    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    ;;
-  m68k)
-    library_names_spec='$libname.ixlibrary $libname.a'
-    # Create ${libname}_ixlibrary.a entries in /sys/libs.
-    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
-    ;;
-  esac
-  ;;
-
-beos*)
-  library_names_spec='${libname}${shared_ext}'
-  dynamic_linker="$host_os ld.so"
-  shlibpath_var=LIBRARY_PATH
-  ;;
-
-bsdi[45]*)
-  version_type=linux
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
-  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
-  # the default ld.so.conf also contains /usr/contrib/lib and
-  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
-  # libtool to hard-code these into programs
-  ;;
-
-cygwin* | mingw* | pw32* | cegcc*)
-  version_type=windows
-  shrext_cmds=".dll"
-  need_version=no
-  need_lib_prefix=no
-
-  case $GCC,$cc_basename in
-  yes,*)
-    # gcc
-    library_names_spec='$libname.dll.a'
-    # DLL is installed to $(libdir)/../bin by postinstall_cmds
-    postinstall_cmds='base_file=`basename \${file}`~
-      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
-      dldir=$destdir/`dirname \$dlpath`~
-      test -d \$dldir || mkdir -p \$dldir~
-      $install_prog $dir/$dlname \$dldir/$dlname~
-      chmod a+x \$dldir/$dlname~
-      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
-        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
-      fi'
-    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
-      dlpath=$dir/\$dldll~
-       $RM \$dlpath'
-    shlibpath_overrides_runpath=yes
-
-    case $host_os in
-    cygwin*)
-      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
-      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-
-      sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
-      ;;
-    mingw* | cegcc*)
-      # MinGW DLLs use traditional 'lib' prefix
-      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-      ;;
-    pw32*)
-      # pw32 DLLs use 'pw' prefix rather than 'lib'
-      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-      ;;
-    esac
-    dynamic_linker='Win32 ld.exe'
-    ;;
-
-  *,cl*)
-    # Native MSVC
-    libname_spec='$name'
-    soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-    library_names_spec='${libname}.dll.lib'
-
-    case $build_os in
-    mingw*)
-      sys_lib_search_path_spec=
-      lt_save_ifs=$IFS
-      IFS=';'
-      for lt_path in $LIB
-      do
-        IFS=$lt_save_ifs
-        # Let DOS variable expansion print the short 8.3 style file name.
-        lt_path=`cd "$lt_path" 2>/dev/null && cmd //C "for %i in (".") do @echo %~si"`
-        sys_lib_search_path_spec="$sys_lib_search_path_spec $lt_path"
-      done
-      IFS=$lt_save_ifs
-      # Convert to MSYS style.
-      sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | sed -e 's|\\\\|/|g' -e 's| \\([a-zA-Z]\\):| /\\1|g' -e 's|^ ||'`
-      ;;
-    cygwin*)
-      # Convert to unix form, then to dos form, then back to unix form
-      # but this time dos style (no spaces!) so that the unix form looks
-      # like /cygdrive/c/PROGRA~1:/cygdr...
-      sys_lib_search_path_spec=`cygpath --path --unix "$LIB"`
-      sys_lib_search_path_spec=`cygpath --path --dos "$sys_lib_search_path_spec" 2>/dev/null`
-      sys_lib_search_path_spec=`cygpath --path --unix "$sys_lib_search_path_spec" | $SED -e "s/$PATH_SEPARATOR/ /g"`
-      ;;
-    *)
-      sys_lib_search_path_spec="$LIB"
-      if $ECHO "$sys_lib_search_path_spec" | $GREP ';[c-zC-Z]:/' >/dev/null; then
-        # It is most probably a Windows format PATH.
-        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
-      else
-        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e "s/$PATH_SEPARATOR/ /g"`
-      fi
-      # FIXME: find the short name or the path components, as spaces are
-      # common. (e.g. "Program Files" -> "PROGRA~1")
-      ;;
-    esac
-
-    # DLL is installed to $(libdir)/../bin by postinstall_cmds
-    postinstall_cmds='base_file=`basename \${file}`~
-      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
-      dldir=$destdir/`dirname \$dlpath`~
-      test -d \$dldir || mkdir -p \$dldir~
-      $install_prog $dir/$dlname \$dldir/$dlname'
-    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
-      dlpath=$dir/\$dldll~
-       $RM \$dlpath'
-    shlibpath_overrides_runpath=yes
-    dynamic_linker='Win32 link.exe'
-    ;;
-
-  *)
-    # Assume MSVC wrapper
-    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
-    dynamic_linker='Win32 ld.exe'
-    ;;
-  esac
-  # FIXME: first we should search . and the directory the executable is in
-  shlibpath_var=PATH
-  ;;
-
-darwin* | rhapsody*)
-  dynamic_linker="$host_os dyld"
-  version_type=darwin
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
-  soname_spec='${libname}${release}${major}$shared_ext'
-  shlibpath_overrides_runpath=yes
-  shlibpath_var=DYLD_LIBRARY_PATH
-  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
-
-  sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/local/lib"
-  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
-  ;;
-
-dgux*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  ;;
-
-freebsd1*)
-  dynamic_linker=no
-  ;;
-
-freebsd* | dragonfly*)
-  # DragonFly does not have aout.  When/if they implement a new
-  # versioning mechanism, adjust this.
-  if test -x /usr/bin/objformat; then
-    objformat=`/usr/bin/objformat`
-  else
-    case $host_os in
-    freebsd[123]*) objformat=aout ;;
-    *) objformat=elf ;;
-    esac
-  fi
-  version_type=freebsd-$objformat
-  case $version_type in
-    freebsd-elf*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
-      need_version=no
-      need_lib_prefix=no
-      ;;
-    freebsd-*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
-      need_version=yes
-      ;;
-  esac
-  shlibpath_var=LD_LIBRARY_PATH
-  case $host_os in
-  freebsd2*)
-    shlibpath_overrides_runpath=yes
-    ;;
-  freebsd3.[01]* | freebsdelf3.[01]*)
-    shlibpath_overrides_runpath=yes
-    hardcode_into_libs=yes
-    ;;
-  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
-  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
-    shlibpath_overrides_runpath=no
-    hardcode_into_libs=yes
-    ;;
-  *) # from 4.6 on, and DragonFly
-    shlibpath_overrides_runpath=yes
-    hardcode_into_libs=yes
-    ;;
-  esac
-  ;;
-
-gnu*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  ;;
-
-haiku*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  dynamic_linker="$host_os runtime_loader"
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'
-  hardcode_into_libs=yes
-  ;;
-
-hpux9* | hpux10* | hpux11*)
-  # Give a soname corresponding to the major version so that dld.sl refuses to
-  # link against other versions.
-  version_type=sunos
-  need_lib_prefix=no
-  need_version=no
-  case $host_cpu in
-  ia64*)
-    shrext_cmds='.so'
-    hardcode_into_libs=yes
-    dynamic_linker="$host_os dld.so"
-    shlibpath_var=LD_LIBRARY_PATH
-    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    if test "X$HPUX_IA64_MODE" = X32; then
-      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
-    else
-      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
-    fi
-    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
-    ;;
-  hppa*64*)
-    shrext_cmds='.sl'
-    hardcode_into_libs=yes
-    dynamic_linker="$host_os dld.sl"
-    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
-    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
-    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
-    ;;
-  *)
-    shrext_cmds='.sl'
-    dynamic_linker="$host_os dld.sl"
-    shlibpath_var=SHLIB_PATH
-    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    ;;
-  esac
-  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...
-  postinstall_cmds='chmod 555 $lib'
-  # or fails outright, so override atomically:
-  install_override_mode=555
-  ;;
-
-interix[3-9]*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  ;;
-
-irix5* | irix6* | nonstopux*)
-  case $host_os in
-    nonstopux*) version_type=nonstopux ;;
-    *)
-	if test "$lt_cv_prog_gnu_ld" = yes; then
-		version_type=linux
-	else
-		version_type=irix
-	fi ;;
-  esac
-  need_lib_prefix=no
-  need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
-  case $host_os in
-  irix5* | nonstopux*)
-    libsuff= shlibsuff=
-    ;;
-  *)
-    case $LD in # libtool.m4 will add one of these switches to LD
-    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
-      libsuff= shlibsuff= libmagic=32-bit;;
-    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
-      libsuff=32 shlibsuff=N32 libmagic=N32;;
-    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
-      libsuff=64 shlibsuff=64 libmagic=64-bit;;
-    *) libsuff= shlibsuff= libmagic=never-match;;
-    esac
-    ;;
-  esac
-  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
-  shlibpath_overrides_runpath=no
-  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
-  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
-  hardcode_into_libs=yes
-  ;;
-
-# No shared lib support for Linux oldld, aout, or coff.
-linux*oldld* | linux*aout* | linux*coff*)
-  dynamic_linker=no
-  ;;
-
-# This must be Linux ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-
-  # Some binutils ld are patched to set DT_RUNPATH
-  if ${lt_cv_shlibpath_overrides_runpath+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_shlibpath_overrides_runpath=no
-    save_LDFLAGS=$LDFLAGS
-    save_libdir=$libdir
-    eval "libdir=/foo; wl=\"$lt_prog_compiler_wl\"; \
-	 LDFLAGS=\"\$LDFLAGS $hardcode_libdir_flag_spec\""
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then :
-  lt_cv_shlibpath_overrides_runpath=yes
-fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-    LDFLAGS=$save_LDFLAGS
-    libdir=$save_libdir
-
-fi
-
-  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath
-
-  # This implies no fast_install, which is unacceptable.
-  # Some rework will be needed to allow for fast_install
-  # before this can be enabled.
-  hardcode_into_libs=yes
-
-  # Append ld.so.conf contents to the search path
-  if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
-    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
-  fi
-
-  # We used to test for /lib/ld.so.1 and disable shared libraries on
-  # powerpc, because MkLinux only supported shared libraries with the
-  # GNU dynamic linker.  Since this was broken with cross compilers,
-  # most powerpc-linux boxes support dynamic linking these days and
-  # people can always --disable-shared, the test was removed, and we
-  # assume the GNU/Linux dynamic linker is in use.
-  dynamic_linker='GNU/Linux ld.so'
-  ;;
-
-netbsdelf*-gnu)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  dynamic_linker='NetBSD ld.elf_so'
-  ;;
-
-netbsd*)
-  version_type=sunos
-  need_lib_prefix=no
-  need_version=no
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
-    dynamic_linker='NetBSD (a.out) ld.so'
-  else
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    dynamic_linker='NetBSD ld.elf_so'
-  fi
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  ;;
-
-newsos6)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  ;;
-
-*nto* | *qnx*)
-  version_type=qnx
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  dynamic_linker='ldqnx.so'
-  ;;
-
-openbsd*)
-  version_type=sunos
-  sys_lib_dlsearch_path_spec="/usr/lib"
-  need_lib_prefix=no
-  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
-  case $host_os in
-    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
-    *)				need_version=no  ;;
-  esac
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-    case $host_os in
-      openbsd2.[89] | openbsd2.[89].*)
-	shlibpath_overrides_runpath=no
-	;;
-      *)
-	shlibpath_overrides_runpath=yes
-	;;
-      esac
-  else
-    shlibpath_overrides_runpath=yes
-  fi
-  ;;
-
-os2*)
-  libname_spec='$name'
-  shrext_cmds=".dll"
-  need_lib_prefix=no
-  library_names_spec='$libname${shared_ext} $libname.a'
-  dynamic_linker='OS/2 ld.exe'
-  shlibpath_var=LIBPATH
-  ;;
-
-osf3* | osf4* | osf5*)
-  version_type=osf
-  need_lib_prefix=no
-  need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
-  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
-  ;;
-
-rdos*)
-  dynamic_linker=no
-  ;;
-
-solaris*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  # ldd complains unless libraries are executable
-  postinstall_cmds='chmod +x $lib'
-  ;;
-
-sunos4*)
-  version_type=sunos
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  if test "$with_gnu_ld" = yes; then
-    need_lib_prefix=no
-  fi
-  need_version=yes
-  ;;
-
-sysv4 | sysv4.3*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  case $host_vendor in
-    sni)
-      shlibpath_overrides_runpath=no
-      need_lib_prefix=no
-      runpath_var=LD_RUN_PATH
-      ;;
-    siemens)
-      need_lib_prefix=no
-      ;;
-    motorola)
-      need_lib_prefix=no
-      need_version=no
-      shlibpath_overrides_runpath=no
-      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
-      ;;
-  esac
-  ;;
-
-sysv4*MP*)
-  if test -d /usr/nec ;then
-    version_type=linux
-    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
-    soname_spec='$libname${shared_ext}.$major'
-    shlibpath_var=LD_LIBRARY_PATH
-  fi
-  ;;
-
-sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
-  version_type=freebsd-elf
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  if test "$with_gnu_ld" = yes; then
-    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
-  else
-    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
-    case $host_os in
-      sco3.2v5*)
-        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
-	;;
-    esac
-  fi
-  sys_lib_dlsearch_path_spec='/usr/lib'
-  ;;
-
-tpf*)
-  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  ;;
-
-uts4*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  ;;
-
-*)
-  dynamic_linker=no
-  ;;
-esac
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
-$as_echo "$dynamic_linker" >&6; }
-test "$dynamic_linker" = no && can_build_shared=no
-
-variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
-if test "$GCC" = yes; then
-  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
-fi
-
-if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
-  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
-fi
-if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
-  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
-$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
-hardcode_action=
-if test -n "$hardcode_libdir_flag_spec" ||
-   test -n "$runpath_var" ||
-   test "X$hardcode_automatic" = "Xyes" ; then
-
-  # We can hardcode non-existent directories.
-  if test "$hardcode_direct" != no &&
-     # If the only mechanism to avoid hardcoding is shlibpath_var, we
-     # have to relink, otherwise we might link with an installed library
-     # when we should be linking with a yet-to-be-installed one
-     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, )" != no &&
-     test "$hardcode_minus_L" != no; then
-    # Linking always hardcodes the temporary library directory.
-    hardcode_action=relink
-  else
-    # We can link without hardcoding, and we can hardcode nonexisting dirs.
-    hardcode_action=immediate
-  fi
-else
-  # We cannot hardcode anything, or else we can only hardcode existing
-  # directories.
-  hardcode_action=unsupported
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action" >&5
-$as_echo "$hardcode_action" >&6; }
-
-if test "$hardcode_action" = relink ||
-   test "$inherit_rpath" = yes; then
-  # Fast installation is not supported
-  enable_fast_install=no
-elif test "$shlibpath_overrides_runpath" = yes ||
-     test "$enable_shared" = no; then
-  # Fast installation is not necessary
-  enable_fast_install=needless
-fi
-
-
-
-
-
-
-  if test "x$enable_dlopen" != xyes; then
-  enable_dlopen=unknown
-  enable_dlopen_self=unknown
-  enable_dlopen_self_static=unknown
-else
-  lt_cv_dlopen=no
-  lt_cv_dlopen_libs=
-
-  case $host_os in
-  beos*)
-    lt_cv_dlopen="load_add_on"
-    lt_cv_dlopen_libs=
-    lt_cv_dlopen_self=yes
-    ;;
-
-  mingw* | pw32* | cegcc*)
-    lt_cv_dlopen="LoadLibrary"
-    lt_cv_dlopen_libs=
-    ;;
-
-  cygwin*)
-    lt_cv_dlopen="dlopen"
-    lt_cv_dlopen_libs=
-    ;;
-
-  darwin*)
-  # if libdl is installed we need to link against it
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
-$as_echo_n "checking for dlopen in -ldl... " >&6; }
-if ${ac_cv_lib_dl_dlopen+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldl  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
-int
-main ()
-{
-return dlopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dl_dlopen=yes
-else
-  ac_cv_lib_dl_dlopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
-$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
-if test "x$ac_cv_lib_dl_dlopen" = xyes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
-else
-
-    lt_cv_dlopen="dyld"
-    lt_cv_dlopen_libs=
-    lt_cv_dlopen_self=yes
-
-fi
-
-    ;;
-
-  *)
-    ac_fn_c_check_func "$LINENO" "shl_load" "ac_cv_func_shl_load"
-if test "x$ac_cv_func_shl_load" = xyes; then :
-  lt_cv_dlopen="shl_load"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shl_load in -ldld" >&5
-$as_echo_n "checking for shl_load in -ldld... " >&6; }
-if ${ac_cv_lib_dld_shl_load+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldld  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char shl_load ();
-int
-main ()
-{
-return shl_load ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dld_shl_load=yes
-else
-  ac_cv_lib_dld_shl_load=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_shl_load" >&5
-$as_echo "$ac_cv_lib_dld_shl_load" >&6; }
-if test "x$ac_cv_lib_dld_shl_load" = xyes; then :
-  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"
-else
-  ac_fn_c_check_func "$LINENO" "dlopen" "ac_cv_func_dlopen"
-if test "x$ac_cv_func_dlopen" = xyes; then :
-  lt_cv_dlopen="dlopen"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
-$as_echo_n "checking for dlopen in -ldl... " >&6; }
-if ${ac_cv_lib_dl_dlopen+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldl  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
-int
-main ()
-{
-return dlopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dl_dlopen=yes
-else
-  ac_cv_lib_dl_dlopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
-$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
-if test "x$ac_cv_lib_dl_dlopen" = xyes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -lsvld" >&5
-$as_echo_n "checking for dlopen in -lsvld... " >&6; }
-if ${ac_cv_lib_svld_dlopen+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lsvld  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
-int
-main ()
-{
-return dlopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_svld_dlopen=yes
-else
-  ac_cv_lib_svld_dlopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_svld_dlopen" >&5
-$as_echo "$ac_cv_lib_svld_dlopen" >&6; }
-if test "x$ac_cv_lib_svld_dlopen" = xyes; then :
-  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dld_link in -ldld" >&5
-$as_echo_n "checking for dld_link in -ldld... " >&6; }
-if ${ac_cv_lib_dld_dld_link+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldld  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dld_link ();
-int
-main ()
-{
-return dld_link ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_dld_dld_link=yes
-else
-  ac_cv_lib_dld_dld_link=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_dld_link" >&5
-$as_echo "$ac_cv_lib_dld_dld_link" >&6; }
-if test "x$ac_cv_lib_dld_dld_link" = xyes; then :
-  lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"
-fi
-
-
-fi
-
-
-fi
-
-
-fi
-
-
-fi
-
-
-fi
-
-    ;;
-  esac
-
-  if test "x$lt_cv_dlopen" != xno; then
-    enable_dlopen=yes
-  else
-    enable_dlopen=no
-  fi
-
-  case $lt_cv_dlopen in
-  dlopen)
-    save_CPPFLAGS="$CPPFLAGS"
-    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
-
-    save_LDFLAGS="$LDFLAGS"
-    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
-
-    save_LIBS="$LIBS"
-    LIBS="$lt_cv_dlopen_libs $LIBS"
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program can dlopen itself" >&5
-$as_echo_n "checking whether a program can dlopen itself... " >&6; }
-if ${lt_cv_dlopen_self+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  	  if test "$cross_compiling" = yes; then :
-  lt_cv_dlopen_self=cross
-else
-  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
-  lt_status=$lt_dlunknown
-  cat > conftest.$ac_ext <<_LT_EOF
-#line $LINENO "configure"
-#include "confdefs.h"
-
-#if HAVE_DLFCN_H
-#include <dlfcn.h>
-#endif
-
-#include <stdio.h>
-
-#ifdef RTLD_GLOBAL
-#  define LT_DLGLOBAL		RTLD_GLOBAL
-#else
-#  ifdef DL_GLOBAL
-#    define LT_DLGLOBAL		DL_GLOBAL
-#  else
-#    define LT_DLGLOBAL		0
-#  endif
-#endif
-
-/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
-   find out it does not work in some platform. */
-#ifndef LT_DLLAZY_OR_NOW
-#  ifdef RTLD_LAZY
-#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
-#  else
-#    ifdef DL_LAZY
-#      define LT_DLLAZY_OR_NOW		DL_LAZY
-#    else
-#      ifdef RTLD_NOW
-#        define LT_DLLAZY_OR_NOW	RTLD_NOW
-#      else
-#        ifdef DL_NOW
-#          define LT_DLLAZY_OR_NOW	DL_NOW
-#        else
-#          define LT_DLLAZY_OR_NOW	0
-#        endif
-#      endif
-#    endif
-#  endif
-#endif
-
-/* When -fvisbility=hidden is used, assume the code has been annotated
-   correspondingly for the symbols needed.  */
-#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
-int fnord () __attribute__((visibility("default")));
-#endif
-
-int fnord () { return 42; }
-int main ()
-{
-  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
-  int status = $lt_dlunknown;
-
-  if (self)
-    {
-      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
-      else
-        {
-	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
-          else puts (dlerror ());
-	}
-      /* dlclose (self); */
-    }
-  else
-    puts (dlerror ());
-
-  return status;
-}
-_LT_EOF
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
-    (./conftest; exit; ) >&5 2>/dev/null
-    lt_status=$?
-    case x$lt_status in
-      x$lt_dlno_uscore) lt_cv_dlopen_self=yes ;;
-      x$lt_dlneed_uscore) lt_cv_dlopen_self=yes ;;
-      x$lt_dlunknown|x*) lt_cv_dlopen_self=no ;;
-    esac
-  else :
-    # compilation failed
-    lt_cv_dlopen_self=no
-  fi
-fi
-rm -fr conftest*
-
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self" >&5
-$as_echo "$lt_cv_dlopen_self" >&6; }
-
-    if test "x$lt_cv_dlopen_self" = xyes; then
-      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a statically linked program can dlopen itself" >&5
-$as_echo_n "checking whether a statically linked program can dlopen itself... " >&6; }
-if ${lt_cv_dlopen_self_static+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  	  if test "$cross_compiling" = yes; then :
-  lt_cv_dlopen_self_static=cross
-else
-  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
-  lt_status=$lt_dlunknown
-  cat > conftest.$ac_ext <<_LT_EOF
-#line $LINENO "configure"
-#include "confdefs.h"
-
-#if HAVE_DLFCN_H
-#include <dlfcn.h>
-#endif
-
-#include <stdio.h>
-
-#ifdef RTLD_GLOBAL
-#  define LT_DLGLOBAL		RTLD_GLOBAL
-#else
-#  ifdef DL_GLOBAL
-#    define LT_DLGLOBAL		DL_GLOBAL
-#  else
-#    define LT_DLGLOBAL		0
-#  endif
-#endif
-
-/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
-   find out it does not work in some platform. */
-#ifndef LT_DLLAZY_OR_NOW
-#  ifdef RTLD_LAZY
-#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
-#  else
-#    ifdef DL_LAZY
-#      define LT_DLLAZY_OR_NOW		DL_LAZY
-#    else
-#      ifdef RTLD_NOW
-#        define LT_DLLAZY_OR_NOW	RTLD_NOW
-#      else
-#        ifdef DL_NOW
-#          define LT_DLLAZY_OR_NOW	DL_NOW
-#        else
-#          define LT_DLLAZY_OR_NOW	0
-#        endif
-#      endif
-#    endif
-#  endif
-#endif
-
-/* When -fvisbility=hidden is used, assume the code has been annotated
-   correspondingly for the symbols needed.  */
-#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
-int fnord () __attribute__((visibility("default")));
-#endif
-
-int fnord () { return 42; }
-int main ()
-{
-  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
-  int status = $lt_dlunknown;
-
-  if (self)
-    {
-      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
-      else
-        {
-	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
-          else puts (dlerror ());
-	}
-      /* dlclose (self); */
-    }
-  else
-    puts (dlerror ());
-
-  return status;
-}
-_LT_EOF
-  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
-    (./conftest; exit; ) >&5 2>/dev/null
-    lt_status=$?
-    case x$lt_status in
-      x$lt_dlno_uscore) lt_cv_dlopen_self_static=yes ;;
-      x$lt_dlneed_uscore) lt_cv_dlopen_self_static=yes ;;
-      x$lt_dlunknown|x*) lt_cv_dlopen_self_static=no ;;
-    esac
-  else :
-    # compilation failed
-    lt_cv_dlopen_self_static=no
-  fi
-fi
-rm -fr conftest*
-
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self_static" >&5
-$as_echo "$lt_cv_dlopen_self_static" >&6; }
-    fi
-
-    CPPFLAGS="$save_CPPFLAGS"
-    LDFLAGS="$save_LDFLAGS"
-    LIBS="$save_LIBS"
-    ;;
-  esac
-
-  case $lt_cv_dlopen_self in
-  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
-  *) enable_dlopen_self=unknown ;;
-  esac
-
-  case $lt_cv_dlopen_self_static in
-  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
-  *) enable_dlopen_self_static=unknown ;;
-  esac
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-striplib=
-old_striplib=
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stripping libraries is possible" >&5
-$as_echo_n "checking whether stripping libraries is possible... " >&6; }
-if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
-  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
-  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-else
-# FIXME - insert some real tests, host_os isn't really good enough
-  case $host_os in
-  darwin*)
-    if test -n "$STRIP" ; then
-      striplib="$STRIP -x"
-      old_striplib="$STRIP -S"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-    else
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-    fi
-    ;;
-  *)
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-    ;;
-  esac
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-  # Report which library types will actually be built
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if libtool supports shared libraries" >&5
-$as_echo_n "checking if libtool supports shared libraries... " >&6; }
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $can_build_shared" >&5
-$as_echo "$can_build_shared" >&6; }
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build shared libraries" >&5
-$as_echo_n "checking whether to build shared libraries... " >&6; }
-  test "$can_build_shared" = "no" && enable_shared=no
-
-  # On AIX, shared libraries and static libraries use the same namespace, and
-  # are all built from PIC.
-  case $host_os in
-  aix3*)
-    test "$enable_shared" = yes && enable_static=no
-    if test -n "$RANLIB"; then
-      archive_cmds="$archive_cmds~\$RANLIB \$lib"
-      postinstall_cmds='$RANLIB $lib'
-    fi
-    ;;
-
-  aix[4-9]*)
-    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
-      test "$enable_shared" = yes && enable_static=no
-    fi
-    ;;
-  esac
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_shared" >&5
-$as_echo "$enable_shared" >&6; }
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build static libraries" >&5
-$as_echo_n "checking whether to build static libraries... " >&6; }
-  # Make sure either enable_shared or enable_static is yes.
-  test "$enable_shared" = yes || enable_static=yes
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_static" >&5
-$as_echo "$enable_static" >&6; }
-
-
-
-
-fi
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-
-CC="$lt_save_CC"
-
-      if test -n "$CXX" && ( test "X$CXX" != "Xno" &&
-    ( (test "X$CXX" = "Xg++" && `g++ -v >/dev/null 2>&1` ) ||
-    (test "X$CXX" != "Xg++"))) ; then
-  ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C++ preprocessor" >&5
-$as_echo_n "checking how to run the C++ preprocessor... " >&6; }
-if test -z "$CXXCPP"; then
-  if ${ac_cv_prog_CXXCPP+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-      # Double quotes because CXXCPP needs to be expanded
-    for CXXCPP in "$CXX -E" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_cxx_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_cxx_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_cxx_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.i conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-  break
-fi
-
-    done
-    ac_cv_prog_CXXCPP=$CXXCPP
-
-fi
-  CXXCPP=$ac_cv_prog_CXXCPP
-else
-  ac_cv_prog_CXXCPP=$CXXCPP
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CXXCPP" >&5
-$as_echo "$CXXCPP" >&6; }
-ac_preproc_ok=false
-for ac_cxx_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if ac_fn_cxx_try_cpp "$LINENO"; then :
-
-else
-  # Broken: fails on valid input.
-continue
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if ac_fn_cxx_try_cpp "$LINENO"; then :
-  # Broken: success on invalid input.
-continue
-else
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.i conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then :
-
-else
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "C++ preprocessor \"$CXXCPP\" fails sanity check
-See \`config.log' for more details" "$LINENO" 5; }
-fi
-
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-
-else
-  _lt_caught_CXX_error=yes
-fi
-
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-
-archive_cmds_need_lc_CXX=no
-allow_undefined_flag_CXX=
-always_export_symbols_CXX=no
-archive_expsym_cmds_CXX=
-compiler_needs_object_CXX=no
-export_dynamic_flag_spec_CXX=
-hardcode_direct_CXX=no
-hardcode_direct_absolute_CXX=no
-hardcode_libdir_flag_spec_CXX=
-hardcode_libdir_flag_spec_ld_CXX=
-hardcode_libdir_separator_CXX=
-hardcode_minus_L_CXX=no
-hardcode_shlibpath_var_CXX=unsupported
-hardcode_automatic_CXX=no
-inherit_rpath_CXX=no
-module_cmds_CXX=
-module_expsym_cmds_CXX=
-link_all_deplibs_CXX=unknown
-old_archive_cmds_CXX=$old_archive_cmds
-reload_flag_CXX=$reload_flag
-reload_cmds_CXX=$reload_cmds
-no_undefined_flag_CXX=
-whole_archive_flag_spec_CXX=
-enable_shared_with_static_runtimes_CXX=no
-
-# Source file extension for C++ test sources.
-ac_ext=cpp
-
-# Object file extension for compiled C++ test sources.
-objext=o
-objext_CXX=$objext
-
-# No sense in running all these tests if we already determined that
-# the CXX compiler isn't working.  Some variables (like enable_shared)
-# are currently assumed to apply to all compilers on this platform,
-# and will be corrupted by setting them based on a non-working compiler.
-if test "$_lt_caught_CXX_error" != yes; then
-  # Code to be used in simple compile tests
-  lt_simple_compile_test_code="int some_variable = 0;"
-
-  # Code to be used in simple link tests
-  lt_simple_link_test_code='int main(int, char *[]) { return(0); }'
-
-  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
-
-
-
-
-
-
-# If no C compiler was specified, use CC.
-LTCC=${LTCC-"$CC"}
-
-# If no C compiler flags were specified, use CFLAGS.
-LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
-
-# Allow CC to be a program name with arguments.
-compiler=$CC
-
-
-  # save warnings/boilerplate of simple test code
-  ac_outfile=conftest.$ac_objext
-echo "$lt_simple_compile_test_code" >conftest.$ac_ext
-eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
-_lt_compiler_boilerplate=`cat conftest.err`
-$RM conftest*
-
-  ac_outfile=conftest.$ac_objext
-echo "$lt_simple_link_test_code" >conftest.$ac_ext
-eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
-_lt_linker_boilerplate=`cat conftest.err`
-$RM -r conftest*
-
-
-  # Allow CC to be a program name with arguments.
-  lt_save_CC=$CC
-  lt_save_CFLAGS=$CFLAGS
-  lt_save_LD=$LD
-  lt_save_GCC=$GCC
-  GCC=$GXX
-  lt_save_with_gnu_ld=$with_gnu_ld
-  lt_save_path_LD=$lt_cv_path_LD
-  if test -n "${lt_cv_prog_gnu_ldcxx+set}"; then
-    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx
-  else
-    $as_unset lt_cv_prog_gnu_ld
-  fi
-  if test -n "${lt_cv_path_LDCXX+set}"; then
-    lt_cv_path_LD=$lt_cv_path_LDCXX
-  else
-    $as_unset lt_cv_path_LD
-  fi
-  test -z "${LDCXX+set}" || LD=$LDCXX
-  CC=${CXX-"c++"}
-  CFLAGS=$CXXFLAGS
-  compiler=$CC
-  compiler_CXX=$CC
-  for cc_temp in $compiler""; do
-  case $cc_temp in
-    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
-    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
-    \-*) ;;
-    *) break;;
-  esac
-done
-cc_basename=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
-
-
-  if test -n "$compiler"; then
-    # We don't want -fno-exception when compiling C++ code, so set the
-    # no_builtin_flag separately
-    if test "$GXX" = yes; then
-      lt_prog_compiler_no_builtin_flag_CXX=' -fno-builtin'
-    else
-      lt_prog_compiler_no_builtin_flag_CXX=
-    fi
-
-    if test "$GXX" = yes; then
-      # Set up default GNU C++ configuration
-
-
-
-# Check whether --with-gnu-ld was given.
-if test "${with_gnu_ld+set}" = set; then :
-  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
-else
-  with_gnu_ld=no
-fi
-
-ac_prog=ld
-if test "$GCC" = yes; then
-  # Check if gcc -print-prog-name=ld gives a path.
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
-$as_echo_n "checking for ld used by $CC... " >&6; }
-  case $host in
-  *-*-mingw*)
-    # gcc leaves a trailing carriage return which upsets mingw
-    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
-  *)
-    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
-  esac
-  case $ac_prog in
-    # Accept absolute paths.
-    [\\/]* | ?:[\\/]*)
-      re_direlt='/[^/][^/]*/\.\./'
-      # Canonicalize the pathname of ld
-      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
-      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
-	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
-      done
-      test -z "$LD" && LD="$ac_prog"
-      ;;
-  "")
-    # If it fails, then pretend we aren't using GCC.
-    ac_prog=ld
-    ;;
-  *)
-    # If it is relative, then search for the first ld in PATH.
-    with_gnu_ld=unknown
-    ;;
-  esac
-elif test "$with_gnu_ld" = yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
-$as_echo_n "checking for GNU ld... " >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for non-GNU ld" >&5
-$as_echo_n "checking for non-GNU ld... " >&6; }
-fi
-if ${lt_cv_path_LD+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test -z "$LD"; then
-  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
-  for ac_dir in $PATH; do
-    IFS="$lt_save_ifs"
-    test -z "$ac_dir" && ac_dir=.
-    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
-      lt_cv_path_LD="$ac_dir/$ac_prog"
-      # Check to see if the program is GNU ld.  I'd rather use --version,
-      # but apparently some variants of GNU ld only accept -v.
-      # Break only if it was the GNU/non-GNU ld that we prefer.
-      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
-      *GNU* | *'with BFD'*)
-	test "$with_gnu_ld" != no && break
-	;;
-      *)
-	test "$with_gnu_ld" != yes && break
-	;;
-      esac
-    fi
-  done
-  IFS="$lt_save_ifs"
-else
-  lt_cv_path_LD="$LD" # Let the user override the test with a path.
-fi
-fi
-
-LD="$lt_cv_path_LD"
-if test -n "$LD"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
-$as_echo "$LD" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-test -z "$LD" && as_fn_error $? "no acceptable ld found in \$PATH" "$LINENO" 5
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
-$as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
-if ${lt_cv_prog_gnu_ld+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  # I'd rather use --version here, but apparently some GNU lds only accept -v.
-case `$LD -v 2>&1 </dev/null` in
-*GNU* | *'with BFD'*)
-  lt_cv_prog_gnu_ld=yes
-  ;;
-*)
-  lt_cv_prog_gnu_ld=no
-  ;;
-esac
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_gnu_ld" >&5
-$as_echo "$lt_cv_prog_gnu_ld" >&6; }
-with_gnu_ld=$lt_cv_prog_gnu_ld
-
-
-
-
-
-
-
-      # Check if GNU C++ uses GNU ld as the underlying linker, since the
-      # archiving commands below assume that GNU ld is being used.
-      if test "$with_gnu_ld" = yes; then
-        archive_cmds_CXX='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
-        archive_expsym_cmds_CXX='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-
-        hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
-        export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
-
-        # If archive_cmds runs LD, not CC, wlarc should be empty
-        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to
-        #     investigate it a little bit more. (MM)
-        wlarc='${wl}'
-
-        # ancient GNU ld didn't support --whole-archive et. al.
-        if eval "`$CC -print-prog-name=ld` --help 2>&1" |
-	  $GREP 'no-whole-archive' > /dev/null; then
-          whole_archive_flag_spec_CXX="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
-        else
-          whole_archive_flag_spec_CXX=
-        fi
-      else
-        with_gnu_ld=no
-        wlarc=
-
-        # A generic and very simple default shared library creation
-        # command for GNU C++ for the case where it uses the native
-        # linker, instead of GNU ld.  If possible, this setting should
-        # overridden to take advantage of the native linker features on
-        # the platform it is being used on.
-        archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
-      fi
-
-      # Commands to make compiler produce verbose output that lists
-      # what "hidden" libraries, object files and flags are used when
-      # linking a shared library.
-      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
-
-    else
-      GXX=no
-      with_gnu_ld=no
-      wlarc=
-    fi
-
-    # PORTME: fill in a description of your system's C++ link characteristics
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
-$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
-    ld_shlibs_CXX=yes
-    case $host_os in
-      aix3*)
-        # FIXME: insert proper C++ library support
-        ld_shlibs_CXX=no
-        ;;
-      aix[4-9]*)
-        if test "$host_cpu" = ia64; then
-          # On IA64, the linker does run time linking by default, so we don't
-          # have to do anything special.
-          aix_use_runtimelinking=no
-          exp_sym_flag='-Bexport'
-          no_entry_flag=""
-        else
-          aix_use_runtimelinking=no
-
-          # Test if we are trying to use run time linking or normal
-          # AIX style linking. If -brtl is somewhere in LDFLAGS, we
-          # need to do runtime linking.
-          case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
-	    for ld_flag in $LDFLAGS; do
-	      case $ld_flag in
-	      *-brtl*)
-	        aix_use_runtimelinking=yes
-	        break
-	        ;;
-	      esac
-	    done
-	    ;;
-          esac
-
-          exp_sym_flag='-bexport'
-          no_entry_flag='-bnoentry'
-        fi
-
-        # When large executables or shared objects are built, AIX ld can
-        # have problems creating the table of contents.  If linking a library
-        # or program results in "error TOC overflow" add -mminimal-toc to
-        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
-        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
-
-        archive_cmds_CXX=''
-        hardcode_direct_CXX=yes
-        hardcode_direct_absolute_CXX=yes
-        hardcode_libdir_separator_CXX=':'
-        link_all_deplibs_CXX=yes
-        file_list_spec_CXX='${wl}-f,'
-
-        if test "$GXX" = yes; then
-          case $host_os in aix4.[012]|aix4.[012].*)
-          # We only want to do this on AIX 4.2 and lower, the check
-          # below for broken collect2 doesn't work under 4.3+
-	  collect2name=`${CC} -print-prog-name=collect2`
-	  if test -f "$collect2name" &&
-	     strings "$collect2name" | $GREP resolve_lib_name >/dev/null
-	  then
-	    # We have reworked collect2
-	    :
-	  else
-	    # We have old collect2
-	    hardcode_direct_CXX=unsupported
-	    # It fails to find uninstalled libraries when the uninstalled
-	    # path is not listed in the libpath.  Setting hardcode_minus_L
-	    # to unsupported forces relinking
-	    hardcode_minus_L_CXX=yes
-	    hardcode_libdir_flag_spec_CXX='-L$libdir'
-	    hardcode_libdir_separator_CXX=
-	  fi
-          esac
-          shared_flag='-shared'
-	  if test "$aix_use_runtimelinking" = yes; then
-	    shared_flag="$shared_flag "'${wl}-G'
-	  fi
-        else
-          # not using gcc
-          if test "$host_cpu" = ia64; then
-	  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
-	  # chokes on -Wl,-G. The following line is correct:
-	  shared_flag='-G'
-          else
-	    if test "$aix_use_runtimelinking" = yes; then
-	      shared_flag='${wl}-G'
-	    else
-	      shared_flag='${wl}-bM:SRE'
-	    fi
-          fi
-        fi
-
-        export_dynamic_flag_spec_CXX='${wl}-bexpall'
-        # It seems that -bexpall does not export symbols beginning with
-        # underscore (_), so it is better to generate a list of symbols to
-	# export.
-        always_export_symbols_CXX=yes
-        if test "$aix_use_runtimelinking" = yes; then
-          # Warning - without using the other runtime loading flags (-brtl),
-          # -berok will link without error, but may produce a broken library.
-          allow_undefined_flag_CXX='-berok'
-          # Determine the default libpath from the value encoded in an empty
-          # executable.
-          if test "${lt_cv_aix_libpath+set}" = set; then
-  aix_libpath=$lt_cv_aix_libpath
-else
-  if ${lt_cv_aix_libpath__CXX+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-
-  lt_aix_libpath_sed='
-      /Import File Strings/,/^$/ {
-	  /^0/ {
-	      s/^0  *\([^ ]*\) *$/\1/
-	      p
-	  }
-      }'
-  lt_cv_aix_libpath__CXX=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-  # Check for a 64-bit object if we didn't find anything.
-  if test -z "$lt_cv_aix_libpath__CXX"; then
-    lt_cv_aix_libpath__CXX=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-  fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-  if test -z "$lt_cv_aix_libpath__CXX"; then
-    lt_cv_aix_libpath__CXX="/usr/lib:/lib"
-  fi
-
-fi
-
-  aix_libpath=$lt_cv_aix_libpath__CXX
-fi
-
-          hardcode_libdir_flag_spec_CXX='${wl}-blibpath:$libdir:'"$aix_libpath"
-
-          archive_expsym_cmds_CXX='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
-        else
-          if test "$host_cpu" = ia64; then
-	    hardcode_libdir_flag_spec_CXX='${wl}-R $libdir:/usr/lib:/lib'
-	    allow_undefined_flag_CXX="-z nodefs"
-	    archive_expsym_cmds_CXX="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
-          else
-	    # Determine the default libpath from the value encoded in an
-	    # empty executable.
-	    if test "${lt_cv_aix_libpath+set}" = set; then
-  aix_libpath=$lt_cv_aix_libpath
-else
-  if ${lt_cv_aix_libpath__CXX+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-
-  lt_aix_libpath_sed='
-      /Import File Strings/,/^$/ {
-	  /^0/ {
-	      s/^0  *\([^ ]*\) *$/\1/
-	      p
-	  }
-      }'
-  lt_cv_aix_libpath__CXX=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-  # Check for a 64-bit object if we didn't find anything.
-  if test -z "$lt_cv_aix_libpath__CXX"; then
-    lt_cv_aix_libpath__CXX=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
-  fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-  if test -z "$lt_cv_aix_libpath__CXX"; then
-    lt_cv_aix_libpath__CXX="/usr/lib:/lib"
-  fi
-
-fi
-
-  aix_libpath=$lt_cv_aix_libpath__CXX
-fi
-
-	    hardcode_libdir_flag_spec_CXX='${wl}-blibpath:$libdir:'"$aix_libpath"
-	    # Warning - without using the other run time loading flags,
-	    # -berok will link without error, but may produce a broken library.
-	    no_undefined_flag_CXX=' ${wl}-bernotok'
-	    allow_undefined_flag_CXX=' ${wl}-berok'
-	    if test "$with_gnu_ld" = yes; then
-	      # We only use this code for GNU lds that support --whole-archive.
-	      whole_archive_flag_spec_CXX='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
-	    else
-	      # Exported symbols can be pulled into shared objects from archives
-	      whole_archive_flag_spec_CXX='$convenience'
-	    fi
-	    archive_cmds_need_lc_CXX=yes
-	    # This is similar to how AIX traditionally builds its shared
-	    # libraries.
-	    archive_expsym_cmds_CXX="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
-          fi
-        fi
-        ;;
-
-      beos*)
-	if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
-	  allow_undefined_flag_CXX=unsupported
-	  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc
-	  # support --undefined.  This deserves some investigation.  FIXME
-	  archive_cmds_CXX='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	else
-	  ld_shlibs_CXX=no
-	fi
-	;;
-
-      chorus*)
-        case $cc_basename in
-          *)
-	  # FIXME: insert proper C++ library support
-	  ld_shlibs_CXX=no
-	  ;;
-        esac
-        ;;
-
-      cygwin* | mingw* | pw32* | cegcc*)
-	case $GXX,$cc_basename in
-	,cl* | no,cl*)
-	  # Native MSVC
-	  # hardcode_libdir_flag_spec is actually meaningless, as there is
-	  # no search path for DLLs.
-	  hardcode_libdir_flag_spec_CXX=' '
-	  allow_undefined_flag_CXX=unsupported
-	  always_export_symbols_CXX=yes
-	  file_list_spec_CXX='@'
-	  # Tell ltmain to make .lib files, not .a files.
-	  libext=lib
-	  # Tell ltmain to make .dll files, not .so files.
-	  shrext_cmds=".dll"
-	  # FIXME: Setting linknames here is a bad hack.
-	  archive_cmds_CXX='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='
-	  archive_expsym_cmds_CXX='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	      $SED -n -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' -e '1\\\!p' < $export_symbols > $output_objdir/$soname.exp;
-	    else
-	      $SED -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;
-	    fi~
-	    $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
-	    linknames='
-	  # The linker will not automatically build a static lib if we build a DLL.
-	  # _LT_TAGVAR(old_archive_from_new_cmds, CXX)='true'
-	  enable_shared_with_static_runtimes_CXX=yes
-	  # Don't use ranlib
-	  old_postinstall_cmds_CXX='chmod 644 $oldlib'
-	  postlink_cmds_CXX='lt_outputfile="@OUTPUT@"~
-	    lt_tool_outputfile="@TOOL_OUTPUT@"~
-	    case $lt_outputfile in
-	      *.exe|*.EXE) ;;
-	      *)
-		lt_outputfile="$lt_outputfile.exe"
-		lt_tool_outputfile="$lt_tool_outputfile.exe"
-		;;
-	    esac~
-	    func_to_tool_file "$lt_outputfile"~
-	    if test "$MANIFEST_TOOL" != ":" && test -f "$lt_outputfile.manifest"; then
-	      $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
-	      $RM "$lt_outputfile.manifest";
-	    fi'
-	  ;;
-	*)
-	  # g++
-	  # _LT_TAGVAR(hardcode_libdir_flag_spec, CXX) is actually meaningless,
-	  # as there is no search path for DLLs.
-	  hardcode_libdir_flag_spec_CXX='-L$libdir'
-	  export_dynamic_flag_spec_CXX='${wl}--export-all-symbols'
-	  allow_undefined_flag_CXX=unsupported
-	  always_export_symbols_CXX=no
-	  enable_shared_with_static_runtimes_CXX=yes
-
-	  if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
-	    archive_cmds_CXX='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-	    # If the export-symbols file already is a .def file (1st line
-	    # is EXPORTS), use it as is; otherwise, prepend...
-	    archive_expsym_cmds_CXX='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
-	      cp $export_symbols $output_objdir/$soname.def;
-	    else
-	      echo EXPORTS > $output_objdir/$soname.def;
-	      cat $export_symbols >> $output_objdir/$soname.def;
-	    fi~
-	    $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
-	  else
-	    ld_shlibs_CXX=no
-	  fi
-	  ;;
-	esac
-	;;
-      darwin* | rhapsody*)
-
-
-  archive_cmds_need_lc_CXX=no
-  hardcode_direct_CXX=no
-  hardcode_automatic_CXX=yes
-  hardcode_shlibpath_var_CXX=unsupported
-  if test "$lt_cv_ld_force_load" = "yes"; then
-    whole_archive_flag_spec_CXX='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience ${wl}-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
-  else
-    whole_archive_flag_spec_CXX=''
-  fi
-  link_all_deplibs_CXX=yes
-  allow_undefined_flag_CXX="$_lt_dar_allow_undefined"
-  case $cc_basename in
-     ifort*) _lt_dar_can_shared=yes ;;
-     *) _lt_dar_can_shared=$GCC ;;
-  esac
-  if test "$_lt_dar_can_shared" = "yes"; then
-    output_verbose_link_cmd=func_echo_all
-    archive_cmds_CXX="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
-    module_cmds_CXX="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
-    archive_expsym_cmds_CXX="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
-    module_expsym_cmds_CXX="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
-       if test "$lt_cv_apple_cc_single_mod" != "yes"; then
-      archive_cmds_CXX="\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dsymutil}"
-      archive_expsym_cmds_CXX="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dar_export_syms}${_lt_dsymutil}"
-    fi
-
-  else
-  ld_shlibs_CXX=no
-  fi
-
-	;;
-
-      dgux*)
-        case $cc_basename in
-          ec++*)
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-          ghcx*)
-	    # Green Hills C++ Compiler
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-          *)
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-        esac
-        ;;
-
-      freebsd[12]*)
-        # C++ shared libraries reported to be fairly broken before
-	# switch to ELF
-        ld_shlibs_CXX=no
-        ;;
-
-      freebsd-elf*)
-        archive_cmds_need_lc_CXX=no
-        ;;
-
-      freebsd* | dragonfly*)
-        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF
-        # conventions
-        ld_shlibs_CXX=yes
-        ;;
-
-      gnu*)
-        ;;
-
-      haiku*)
-        archive_cmds_CXX='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-        link_all_deplibs_CXX=yes
-        ;;
-
-      hpux9*)
-        hardcode_libdir_flag_spec_CXX='${wl}+b ${wl}$libdir'
-        hardcode_libdir_separator_CXX=:
-        export_dynamic_flag_spec_CXX='${wl}-E'
-        hardcode_direct_CXX=yes
-        hardcode_minus_L_CXX=yes # Not in the search PATH,
-				             # but as the default
-				             # location of the library.
-
-        case $cc_basename in
-          CC*)
-            # FIXME: insert proper C++ library support
-            ld_shlibs_CXX=no
-            ;;
-          aCC*)
-            archive_cmds_CXX='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
-            # Commands to make compiler produce verbose output that lists
-            # what "hidden" libraries, object files and flags are used when
-            # linking a shared library.
-            #
-            # There doesn't appear to be a way to prevent this compiler from
-            # explicitly linking system object files so we need to strip them
-            # from the output so that they don't get included in the library
-            # dependencies.
-            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
-            ;;
-          *)
-            if test "$GXX" = yes; then
-              archive_cmds_CXX='$RM $output_objdir/$soname~$CC -shared -nostdlib $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
-            else
-              # FIXME: insert proper C++ library support
-              ld_shlibs_CXX=no
-            fi
-            ;;
-        esac
-        ;;
-
-      hpux10*|hpux11*)
-        if test $with_gnu_ld = no; then
-	  hardcode_libdir_flag_spec_CXX='${wl}+b ${wl}$libdir'
-	  hardcode_libdir_separator_CXX=:
-
-          case $host_cpu in
-            hppa*64*|ia64*)
-              ;;
-            *)
-	      export_dynamic_flag_spec_CXX='${wl}-E'
-              ;;
-          esac
-        fi
-        case $host_cpu in
-          hppa*64*|ia64*)
-            hardcode_direct_CXX=no
-            hardcode_shlibpath_var_CXX=no
-            ;;
-          *)
-            hardcode_direct_CXX=yes
-            hardcode_direct_absolute_CXX=yes
-            hardcode_minus_L_CXX=yes # Not in the search PATH,
-					         # but as the default
-					         # location of the library.
-            ;;
-        esac
-
-        case $cc_basename in
-          CC*)
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-          aCC*)
-	    case $host_cpu in
-	      hppa*64*)
-	        archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	        ;;
-	      ia64*)
-	        archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	        ;;
-	      *)
-	        archive_cmds_CXX='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	        ;;
-	    esac
-	    # Commands to make compiler produce verbose output that lists
-	    # what "hidden" libraries, object files and flags are used when
-	    # linking a shared library.
-	    #
-	    # There doesn't appear to be a way to prevent this compiler from
-	    # explicitly linking system object files so we need to strip them
-	    # from the output so that they don't get included in the library
-	    # dependencies.
-	    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
-	    ;;
-          *)
-	    if test "$GXX" = yes; then
-	      if test $with_gnu_ld = no; then
-	        case $host_cpu in
-	          hppa*64*)
-	            archive_cmds_CXX='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	            ;;
-	          ia64*)
-	            archive_cmds_CXX='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	            ;;
-	          *)
-	            archive_cmds_CXX='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	            ;;
-	        esac
-	      fi
-	    else
-	      # FIXME: insert proper C++ library support
-	      ld_shlibs_CXX=no
-	    fi
-	    ;;
-        esac
-        ;;
-
-      interix[3-9]*)
-	hardcode_direct_CXX=no
-	hardcode_shlibpath_var_CXX=no
-	hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
-	export_dynamic_flag_spec_CXX='${wl}-E'
-	# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
-	# Instead, shared libraries are loaded at an image base (0x10000000 by
-	# default) and relocated if they conflict, which is a slow very memory
-	# consuming and fragmenting process.  To avoid this, we pick a random,
-	# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
-	# time.  Moving up from 0x10000000 also allows more sbrk(2) space.
-	archive_cmds_CXX='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-	archive_expsym_cmds_CXX='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
-	;;
-      irix5* | irix6*)
-        case $cc_basename in
-          CC*)
-	    # SGI C++
-	    archive_cmds_CXX='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-
-	    # Archives containing C++ object files must be created using
-	    # "CC -ar", where "CC" is the IRIX C++ compiler.  This is
-	    # necessary to make sure instantiated templates are included
-	    # in the archive.
-	    old_archive_cmds_CXX='$CC -ar -WR,-u -o $oldlib $oldobjs'
-	    ;;
-          *)
-	    if test "$GXX" = yes; then
-	      if test "$with_gnu_ld" = no; then
-	        archive_cmds_CXX='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-	      else
-	        archive_cmds_CXX='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` -o $lib'
-	      fi
-	    fi
-	    link_all_deplibs_CXX=yes
-	    ;;
-        esac
-        hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
-        hardcode_libdir_separator_CXX=:
-        inherit_rpath_CXX=yes
-        ;;
-
-      linux* | k*bsd*-gnu | kopensolaris*-gnu)
-        case $cc_basename in
-          KCC*)
-	    # Kuck and Associates, Inc. (KAI) C++ Compiler
-
-	    # KCC will only create a shared library if the output file
-	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
-	    # to its proper name (with version) after linking.
-	    archive_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
-	    archive_expsym_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib ${wl}-retain-symbols-file,$export_symbols; mv \$templib $lib'
-	    # Commands to make compiler produce verbose output that lists
-	    # what "hidden" libraries, object files and flags are used when
-	    # linking a shared library.
-	    #
-	    # There doesn't appear to be a way to prevent this compiler from
-	    # explicitly linking system object files so we need to strip them
-	    # from the output so that they don't get included in the library
-	    # dependencies.
-	    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP "ld"`; rm -f libconftest$shared_ext; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
-
-	    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
-	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
-
-	    # Archives containing C++ object files must be created using
-	    # "CC -Bstatic", where "CC" is the KAI C++ compiler.
-	    old_archive_cmds_CXX='$CC -Bstatic -o $oldlib $oldobjs'
-	    ;;
-	  icpc* | ecpc* )
-	    # Intel C++
-	    with_gnu_ld=yes
-	    # version 8.0 and above of icpc choke on multiply defined symbols
-	    # if we add $predep_objects and $postdep_objects, however 7.1 and
-	    # earlier do not add the objects themselves.
-	    case `$CC -V 2>&1` in
-	      *"Version 7."*)
-	        archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
-		archive_expsym_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-		;;
-	      *)  # Version 8.0 or newer
-	        tmp_idyn=
-	        case $host_cpu in
-		  ia64*) tmp_idyn=' -i_dynamic';;
-		esac
-	        archive_cmds_CXX='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-		archive_expsym_cmds_CXX='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
-		;;
-	    esac
-	    archive_cmds_need_lc_CXX=no
-	    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
-	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
-	    whole_archive_flag_spec_CXX='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
-	    ;;
-          pgCC* | pgcpp*)
-            # Portland Group C++ compiler
-	    case `$CC -V` in
-	    *pgCC\ [1-5].* | *pgcpp\ [1-5].*)
-	      prelink_cmds_CXX='tpldir=Template.dir~
-		rm -rf $tpldir~
-		$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~
-		compile_command="$compile_command `find $tpldir -name \*.o | sort | $NL2SP`"'
-	      old_archive_cmds_CXX='tpldir=Template.dir~
-		rm -rf $tpldir~
-		$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~
-		$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \*.o | sort | $NL2SP`~
-		$RANLIB $oldlib'
-	      archive_cmds_CXX='tpldir=Template.dir~
-		rm -rf $tpldir~
-		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
-		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
-	      archive_expsym_cmds_CXX='tpldir=Template.dir~
-		rm -rf $tpldir~
-		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
-		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
-	      ;;
-	    *) # Version 6 and above use weak symbols
-	      archive_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
-	      archive_expsym_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
-	      ;;
-	    esac
-
-	    hardcode_libdir_flag_spec_CXX='${wl}--rpath ${wl}$libdir'
-	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
-	    whole_archive_flag_spec_CXX='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-            ;;
-	  cxx*)
-	    # Compaq C++
-	    archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	    archive_expsym_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'
-
-	    runpath_var=LD_RUN_PATH
-	    hardcode_libdir_flag_spec_CXX='-rpath $libdir'
-	    hardcode_libdir_separator_CXX=:
-
-	    # Commands to make compiler produce verbose output that lists
-	    # what "hidden" libraries, object files and flags are used when
-	    # linking a shared library.
-	    #
-	    # There doesn't appear to be a way to prevent this compiler from
-	    # explicitly linking system object files so we need to strip them
-	    # from the output so that they don't get included in the library
-	    # dependencies.
-	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld .*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "X$list" | $Xsed'
-	    ;;
-	  xl* | mpixl* | bgxl*)
-	    # IBM XL 8.0 on PPC, with GNU ld
-	    hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
-	    export_dynamic_flag_spec_CXX='${wl}--export-dynamic'
-	    archive_cmds_CXX='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
-	    if test "x$supports_anon_versioning" = xyes; then
-	      archive_expsym_cmds_CXX='echo "{ global:" > $output_objdir/$libname.ver~
-		cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
-		echo "local: *; };" >> $output_objdir/$libname.ver~
-		$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
-	    fi
-	    ;;
-	  *)
-	    case `$CC -V 2>&1 | sed 5q` in
-	    *Sun\ C*)
-	      # Sun C++ 5.9
-	      no_undefined_flag_CXX=' -zdefs'
-	      archive_cmds_CXX='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	      archive_expsym_cmds_CXX='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'
-	      hardcode_libdir_flag_spec_CXX='-R$libdir'
-	      whole_archive_flag_spec_CXX='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
-	      compiler_needs_object_CXX=yes
-
-	      # Not sure whether something based on
-	      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1
-	      # would be better.
-	      output_verbose_link_cmd='func_echo_all'
-
-	      # Archives containing C++ object files must be created using
-	      # "CC -xar", where "CC" is the Sun C++ compiler.  This is
-	      # necessary to make sure instantiated templates are included
-	      # in the archive.
-	      old_archive_cmds_CXX='$CC -xar -o $oldlib $oldobjs'
-	      ;;
-	    esac
-	    ;;
-	esac
-	;;
-
-      lynxos*)
-        # FIXME: insert proper C++ library support
-	ld_shlibs_CXX=no
-	;;
-
-      m88k*)
-        # FIXME: insert proper C++ library support
-        ld_shlibs_CXX=no
-	;;
-
-      mvs*)
-        case $cc_basename in
-          cxx*)
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-	  *)
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-	esac
-	;;
-
-      netbsd*)
-        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-	  archive_cmds_CXX='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'
-	  wlarc=
-	  hardcode_libdir_flag_spec_CXX='-R$libdir'
-	  hardcode_direct_CXX=yes
-	  hardcode_shlibpath_var_CXX=no
-	fi
-	# Workaround some broken pre-1.5 toolchains
-	output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e "s:-lgcc -lc -lgcc::"'
-	;;
-
-      *nto* | *qnx*)
-        ld_shlibs_CXX=yes
-	;;
-
-      openbsd2*)
-        # C++ shared libraries are fairly broken
-	ld_shlibs_CXX=no
-	;;
-
-      openbsd*)
-	if test -f /usr/libexec/ld.so; then
-	  hardcode_direct_CXX=yes
-	  hardcode_shlibpath_var_CXX=no
-	  hardcode_direct_absolute_CXX=yes
-	  archive_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
-	  hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
-	  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-	    archive_expsym_cmds_CXX='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'
-	    export_dynamic_flag_spec_CXX='${wl}-E'
-	    whole_archive_flag_spec_CXX="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
-	  fi
-	  output_verbose_link_cmd=func_echo_all
-	else
-	  ld_shlibs_CXX=no
-	fi
-	;;
-
-      osf3* | osf4* | osf5*)
-        case $cc_basename in
-          KCC*)
-	    # Kuck and Associates, Inc. (KAI) C++ Compiler
-
-	    # KCC will only create a shared library if the output file
-	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
-	    # to its proper name (with version) after linking.
-	    archive_cmds_CXX='tempext=`echo $shared_ext | $SED -e '\''s/\([^()0-9A-Za-z{}]\)/\\\\\1/g'\''`; templib=`echo "$lib" | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
-
-	    hardcode_libdir_flag_spec_CXX='${wl}-rpath,$libdir'
-	    hardcode_libdir_separator_CXX=:
-
-	    # Archives containing C++ object files must be created using
-	    # the KAI C++ compiler.
-	    case $host in
-	      osf3*) old_archive_cmds_CXX='$CC -Bstatic -o $oldlib $oldobjs' ;;
-	      *) old_archive_cmds_CXX='$CC -o $oldlib $oldobjs' ;;
-	    esac
-	    ;;
-          RCC*)
-	    # Rational C++ 2.4.1
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-          cxx*)
-	    case $host in
-	      osf3*)
-	        allow_undefined_flag_CXX=' ${wl}-expect_unresolved ${wl}\*'
-	        archive_cmds_CXX='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n "$verstring" && func_echo_all "${wl}-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-	        hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
-		;;
-	      *)
-	        allow_undefined_flag_CXX=' -expect_unresolved \*'
-	        archive_cmds_CXX='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
-	        archive_expsym_cmds_CXX='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done~
-	          echo "-hidden">> $lib.exp~
-	          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~
-	          $RM $lib.exp'
-	        hardcode_libdir_flag_spec_CXX='-rpath $libdir'
-		;;
-	    esac
-
-	    hardcode_libdir_separator_CXX=:
-
-	    # Commands to make compiler produce verbose output that lists
-	    # what "hidden" libraries, object files and flags are used when
-	    # linking a shared library.
-	    #
-	    # There doesn't appear to be a way to prevent this compiler from
-	    # explicitly linking system object files so we need to strip them
-	    # from the output so that they don't get included in the library
-	    # dependencies.
-	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld" | $GREP -v "ld:"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld.*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
-	    ;;
-	  *)
-	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
-	      allow_undefined_flag_CXX=' ${wl}-expect_unresolved ${wl}\*'
-	      case $host in
-	        osf3*)
-	          archive_cmds_CXX='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-		  ;;
-	        *)
-	          archive_cmds_CXX='$CC -shared $pic_flag -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
-		  ;;
-	      esac
-
-	      hardcode_libdir_flag_spec_CXX='${wl}-rpath ${wl}$libdir'
-	      hardcode_libdir_separator_CXX=:
-
-	      # Commands to make compiler produce verbose output that lists
-	      # what "hidden" libraries, object files and flags are used when
-	      # linking a shared library.
-	      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
-
-	    else
-	      # FIXME: insert proper C++ library support
-	      ld_shlibs_CXX=no
-	    fi
-	    ;;
-        esac
-        ;;
-
-      psos*)
-        # FIXME: insert proper C++ library support
-        ld_shlibs_CXX=no
-        ;;
-
-      sunos4*)
-        case $cc_basename in
-          CC*)
-	    # Sun C++ 4.x
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-          lcc*)
-	    # Lucid
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-          *)
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-        esac
-        ;;
-
-      solaris*)
-        case $cc_basename in
-          CC* | sunCC*)
-	    # Sun C++ 4.2, 5.x and Centerline C++
-            archive_cmds_need_lc_CXX=yes
-	    no_undefined_flag_CXX=' -zdefs'
-	    archive_cmds_CXX='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
-	    archive_expsym_cmds_CXX='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-	      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
-
-	    hardcode_libdir_flag_spec_CXX='-R$libdir'
-	    hardcode_shlibpath_var_CXX=no
-	    case $host_os in
-	      solaris2.[0-5] | solaris2.[0-5].*) ;;
-	      *)
-		# The compiler driver will combine and reorder linker options,
-		# but understands `-z linker_flag'.
-	        # Supported since Solaris 2.6 (maybe 2.5.1?)
-		whole_archive_flag_spec_CXX='-z allextract$convenience -z defaultextract'
-	        ;;
-	    esac
-	    link_all_deplibs_CXX=yes
-
-	    output_verbose_link_cmd='func_echo_all'
-
-	    # Archives containing C++ object files must be created using
-	    # "CC -xar", where "CC" is the Sun C++ compiler.  This is
-	    # necessary to make sure instantiated templates are included
-	    # in the archive.
-	    old_archive_cmds_CXX='$CC -xar -o $oldlib $oldobjs'
-	    ;;
-          gcx*)
-	    # Green Hills C++ Compiler
-	    archive_cmds_CXX='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
-
-	    # The C++ compiler must be used to create the archive.
-	    old_archive_cmds_CXX='$CC $LDFLAGS -archive -o $oldlib $oldobjs'
-	    ;;
-          *)
-	    # GNU C++ compiler with Solaris linker
-	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
-	      no_undefined_flag_CXX=' ${wl}-z ${wl}defs'
-	      if $CC --version | $GREP -v '^2\.7' > /dev/null; then
-	        archive_cmds_CXX='$CC -shared $pic_flag -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
-	        archive_expsym_cmds_CXX='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-		  $CC -shared $pic_flag -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
-
-	        # Commands to make compiler produce verbose output that lists
-	        # what "hidden" libraries, object files and flags are used when
-	        # linking a shared library.
-	        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
-	      else
-	        # g++ 2.7 appears to require `-G' NOT `-shared' on this
-	        # platform.
-	        archive_cmds_CXX='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
-	        archive_expsym_cmds_CXX='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
-		  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
-
-	        # Commands to make compiler produce verbose output that lists
-	        # what "hidden" libraries, object files and flags are used when
-	        # linking a shared library.
-	        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
-	      fi
-
-	      hardcode_libdir_flag_spec_CXX='${wl}-R $wl$libdir'
-	      case $host_os in
-		solaris2.[0-5] | solaris2.[0-5].*) ;;
-		*)
-		  whole_archive_flag_spec_CXX='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
-		  ;;
-	      esac
-	    fi
-	    ;;
-        esac
-        ;;
-
-    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
-      no_undefined_flag_CXX='${wl}-z,text'
-      archive_cmds_need_lc_CXX=no
-      hardcode_shlibpath_var_CXX=no
-      runpath_var='LD_RUN_PATH'
-
-      case $cc_basename in
-        CC*)
-	  archive_cmds_CXX='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds_CXX='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-	*)
-	  archive_cmds_CXX='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  archive_expsym_cmds_CXX='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	  ;;
-      esac
-      ;;
-
-      sysv5* | sco3.2v5* | sco5v6*)
-	# Note: We can NOT use -z defs as we might desire, because we do not
-	# link with -lc, and that would cause any symbols used from libc to
-	# always be unresolved, which means just about no library would
-	# ever link correctly.  If we're not using GNU ld we use -z text
-	# though, which does catch some bad symbols but isn't as heavy-handed
-	# as -z defs.
-	no_undefined_flag_CXX='${wl}-z,text'
-	allow_undefined_flag_CXX='${wl}-z,nodefs'
-	archive_cmds_need_lc_CXX=no
-	hardcode_shlibpath_var_CXX=no
-	hardcode_libdir_flag_spec_CXX='${wl}-R,$libdir'
-	hardcode_libdir_separator_CXX=':'
-	link_all_deplibs_CXX=yes
-	export_dynamic_flag_spec_CXX='${wl}-Bexport'
-	runpath_var='LD_RUN_PATH'
-
-	case $cc_basename in
-          CC*)
-	    archive_cmds_CXX='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	    archive_expsym_cmds_CXX='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	    old_archive_cmds_CXX='$CC -Tprelink_objects $oldobjs~
-	      '"$old_archive_cmds_CXX"
-	    reload_cmds_CXX='$CC -Tprelink_objects $reload_objs~
-	      '"$reload_cmds_CXX"
-	    ;;
-	  *)
-	    archive_cmds_CXX='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	    archive_expsym_cmds_CXX='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
-	    ;;
-	esac
-      ;;
-
-      tandem*)
-        case $cc_basename in
-          NCC*)
-	    # NonStop-UX NCC 3.20
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-          *)
-	    # FIXME: insert proper C++ library support
-	    ld_shlibs_CXX=no
-	    ;;
-        esac
-        ;;
-
-      vxworks*)
-        # FIXME: insert proper C++ library support
-        ld_shlibs_CXX=no
-        ;;
-
-      *)
-        # FIXME: insert proper C++ library support
-        ld_shlibs_CXX=no
-        ;;
-    esac
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs_CXX" >&5
-$as_echo "$ld_shlibs_CXX" >&6; }
-    test "$ld_shlibs_CXX" = no && can_build_shared=no
-
-    GCC_CXX="$GXX"
-    LD_CXX="$LD"
-
-    ## CAVEAT EMPTOR:
-    ## There is no encapsulation within the following macros, do not change
-    ## the running order or otherwise move them around unless you know exactly
-    ## what you are doing...
-    # Dependencies to place before and after the object being linked:
-predep_objects_CXX=
-postdep_objects_CXX=
-predeps_CXX=
-postdeps_CXX=
-compiler_lib_search_path_CXX=
-
-cat > conftest.$ac_ext <<_LT_EOF
-class Foo
-{
-public:
-  Foo (void) { a = 0; }
-private:
-  int a;
-};
-_LT_EOF
-
-
-_lt_libdeps_save_CFLAGS=$CFLAGS
-case "$CC $CFLAGS " in #(
-*\ -flto*\ *) CFLAGS="$CFLAGS -fno-lto" ;;
-*\ -fwhopr*\ *) CFLAGS="$CFLAGS -fno-whopr" ;;
-esac
-
-if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }; then
-  # Parse the compiler output and extract the necessary
-  # objects, libraries and library flags.
-
-  # Sentinel used to keep track of whether or not we are before
-  # the conftest object file.
-  pre_test_object_deps_done=no
-
-  for p in `eval "$output_verbose_link_cmd"`; do
-    case ${prev}${p} in
-
-    -L* | -R* | -l*)
-       # Some compilers place space between "-{L,R}" and the path.
-       # Remove the space.
-       if test $p = "-L" ||
-          test $p = "-R"; then
-	 prev=$p
-	 continue
-       fi
-
-       # Expand the sysroot to ease extracting the directories later.
-       if test -z "$prev"; then
-         case $p in
-         -L*) func_stripname_cnf '-L' '' "$p"; prev=-L; p=$func_stripname_result ;;
-         -R*) func_stripname_cnf '-R' '' "$p"; prev=-R; p=$func_stripname_result ;;
-         -l*) func_stripname_cnf '-l' '' "$p"; prev=-l; p=$func_stripname_result ;;
-         esac
-       fi
-       case $p in
-       =*) func_stripname_cnf '=' '' "$p"; p=$lt_sysroot$func_stripname_result ;;
-       esac
-       if test "$pre_test_object_deps_done" = no; then
-	 case ${prev} in
-	 -L | -R)
-	   # Internal compiler library paths should come after those
-	   # provided the user.  The postdeps already come after the
-	   # user supplied libs so there is no need to process them.
-	   if test -z "$compiler_lib_search_path_CXX"; then
-	     compiler_lib_search_path_CXX="${prev}${p}"
-	   else
-	     compiler_lib_search_path_CXX="${compiler_lib_search_path_CXX} ${prev}${p}"
-	   fi
-	   ;;
-	 # The "-l" case would never come before the object being
-	 # linked, so don't bother handling this case.
-	 esac
-       else
-	 if test -z "$postdeps_CXX"; then
-	   postdeps_CXX="${prev}${p}"
-	 else
-	   postdeps_CXX="${postdeps_CXX} ${prev}${p}"
-	 fi
-       fi
-       prev=
-       ;;
-
-    *.lto.$objext) ;; # Ignore GCC LTO objects
-    *.$objext)
-       # This assumes that the test object file only shows up
-       # once in the compiler output.
-       if test "$p" = "conftest.$objext"; then
-	 pre_test_object_deps_done=yes
-	 continue
-       fi
-
-       if test "$pre_test_object_deps_done" = no; then
-	 if test -z "$predep_objects_CXX"; then
-	   predep_objects_CXX="$p"
-	 else
-	   predep_objects_CXX="$predep_objects_CXX $p"
-	 fi
-       else
-	 if test -z "$postdep_objects_CXX"; then
-	   postdep_objects_CXX="$p"
-	 else
-	   postdep_objects_CXX="$postdep_objects_CXX $p"
-	 fi
-       fi
-       ;;
-
-    *) ;; # Ignore the rest.
-
-    esac
-  done
-
-  # Clean up.
-  rm -f a.out a.exe
-else
-  echo "libtool.m4: error: problem compiling CXX test program"
-fi
-
-$RM -f confest.$objext
-CFLAGS=$_lt_libdeps_save_CFLAGS
-
-# PORTME: override above test on systems where it is broken
-case $host_os in
-interix[3-9]*)
-  # Interix 3.5 installs completely hosed .la files for C++, so rather than
-  # hack all around it, let's just trust "g++" to DTRT.
-  predep_objects_CXX=
-  postdep_objects_CXX=
-  postdeps_CXX=
-  ;;
-
-linux*)
-  case `$CC -V 2>&1 | sed 5q` in
-  *Sun\ C*)
-    # Sun C++ 5.9
-
-    # The more standards-conforming stlport4 library is
-    # incompatible with the Cstd library. Avoid specifying
-    # it if it's in CXXFLAGS. Ignore libCrun as
-    # -library=stlport4 depends on it.
-    case " $CXX $CXXFLAGS " in
-    *" -library=stlport4 "*)
-      solaris_use_stlport4=yes
-      ;;
-    esac
-
-    if test "$solaris_use_stlport4" != yes; then
-      postdeps_CXX='-library=Cstd -library=Crun'
-    fi
-    ;;
-  esac
-  ;;
-
-solaris*)
-  case $cc_basename in
-  CC* | sunCC*)
-    # The more standards-conforming stlport4 library is
-    # incompatible with the Cstd library. Avoid specifying
-    # it if it's in CXXFLAGS. Ignore libCrun as
-    # -library=stlport4 depends on it.
-    case " $CXX $CXXFLAGS " in
-    *" -library=stlport4 "*)
-      solaris_use_stlport4=yes
-      ;;
-    esac
-
-    # Adding this requires a known-good setup of shared libraries for
-    # Sun compiler versions before 5.6, else PIC objects from an old
-    # archive will be linked into the output, leading to subtle bugs.
-    if test "$solaris_use_stlport4" != yes; then
-      postdeps_CXX='-library=Cstd -library=Crun'
-    fi
-    ;;
-  esac
-  ;;
-esac
-
-
-case " $postdeps_CXX " in
-*" -lc "*) archive_cmds_need_lc_CXX=no ;;
-esac
- compiler_lib_search_dirs_CXX=
-if test -n "${compiler_lib_search_path_CXX}"; then
- compiler_lib_search_dirs_CXX=`echo " ${compiler_lib_search_path_CXX}" | ${SED} -e 's! -L! !g' -e 's!^ !!'`
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-    lt_prog_compiler_wl_CXX=
-lt_prog_compiler_pic_CXX=
-lt_prog_compiler_static_CXX=
-
-
-  # C++ specific cases for pic, static, wl, etc.
-  if test "$GXX" = yes; then
-    lt_prog_compiler_wl_CXX='-Wl,'
-    lt_prog_compiler_static_CXX='-static'
-
-    case $host_os in
-    aix*)
-      # All AIX code is PIC.
-      if test "$host_cpu" = ia64; then
-	# AIX 5 now supports IA64 processor
-	lt_prog_compiler_static_CXX='-Bstatic'
-      fi
-      ;;
-
-    amigaos*)
-      case $host_cpu in
-      powerpc)
-            # see comment about AmigaOS4 .so support
-            lt_prog_compiler_pic_CXX='-fPIC'
-        ;;
-      m68k)
-            # FIXME: we need at least 68020 code to build shared libraries, but
-            # adding the `-m68020' flag to GCC prevents building anything better,
-            # like `-m68040'.
-            lt_prog_compiler_pic_CXX='-m68020 -resident32 -malways-restore-a4'
-        ;;
-      esac
-      ;;
-
-    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
-      # PIC is the default for these OSes.
-      ;;
-    mingw* | cygwin* | os2* | pw32* | cegcc*)
-      # This hack is so that the source file can tell whether it is being
-      # built for inclusion in a dll (and should export symbols for example).
-      # Although the cygwin gcc ignores -fPIC, still need this for old-style
-      # (--disable-auto-import) libraries
-      lt_prog_compiler_pic_CXX='-DDLL_EXPORT'
-      ;;
-    darwin* | rhapsody*)
-      # PIC is the default on this platform
-      # Common symbols not allowed in MH_DYLIB files
-      lt_prog_compiler_pic_CXX='-fno-common'
-      ;;
-    *djgpp*)
-      # DJGPP does not support shared libraries at all
-      lt_prog_compiler_pic_CXX=
-      ;;
-    haiku*)
-      # PIC is the default for Haiku.
-      # The "-static" flag exists, but is broken.
-      lt_prog_compiler_static_CXX=
-      ;;
-    interix[3-9]*)
-      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
-      # Instead, we relocate shared libraries at runtime.
-      ;;
-    sysv4*MP*)
-      if test -d /usr/nec; then
-	lt_prog_compiler_pic_CXX=-Kconform_pic
-      fi
-      ;;
-    hpux*)
-      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
-      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
-      # sets the default TLS model and affects inlining.
-      case $host_cpu in
-      hppa*64*)
-	;;
-      *)
-	lt_prog_compiler_pic_CXX='-fPIC'
-	;;
-      esac
-      ;;
-    *qnx* | *nto*)
-      # QNX uses GNU C++, but need to define -shared option too, otherwise
-      # it will coredump.
-      lt_prog_compiler_pic_CXX='-fPIC -shared'
-      ;;
-    *)
-      lt_prog_compiler_pic_CXX='-fPIC'
-      ;;
-    esac
-  else
-    case $host_os in
-      aix[4-9]*)
-	# All AIX code is PIC.
-	if test "$host_cpu" = ia64; then
-	  # AIX 5 now supports IA64 processor
-	  lt_prog_compiler_static_CXX='-Bstatic'
-	else
-	  lt_prog_compiler_static_CXX='-bnso -bI:/lib/syscalls.exp'
-	fi
-	;;
-      chorus*)
-	case $cc_basename in
-	cxch68*)
-	  # Green Hills C++ Compiler
-	  # _LT_TAGVAR(lt_prog_compiler_static, CXX)="--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a"
-	  ;;
-	esac
-	;;
-      mingw* | cygwin* | os2* | pw32* | cegcc*)
-	# This hack is so that the source file can tell whether it is being
-	# built for inclusion in a dll (and should export symbols for example).
-	lt_prog_compiler_pic_CXX='-DDLL_EXPORT'
-	;;
-      dgux*)
-	case $cc_basename in
-	  ec++*)
-	    lt_prog_compiler_pic_CXX='-KPIC'
-	    ;;
-	  ghcx*)
-	    # Green Hills C++ Compiler
-	    lt_prog_compiler_pic_CXX='-pic'
-	    ;;
-	  *)
-	    ;;
-	esac
-	;;
-      freebsd* | dragonfly*)
-	# FreeBSD uses GNU C++
-	;;
-      hpux9* | hpux10* | hpux11*)
-	case $cc_basename in
-	  CC*)
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_static_CXX='${wl}-a ${wl}archive'
-	    if test "$host_cpu" != ia64; then
-	      lt_prog_compiler_pic_CXX='+Z'
-	    fi
-	    ;;
-	  aCC*)
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_static_CXX='${wl}-a ${wl}archive'
-	    case $host_cpu in
-	    hppa*64*|ia64*)
-	      # +Z the default
-	      ;;
-	    *)
-	      lt_prog_compiler_pic_CXX='+Z'
-	      ;;
-	    esac
-	    ;;
-	  *)
-	    ;;
-	esac
-	;;
-      interix*)
-	# This is c89, which is MS Visual C++ (no shared libs)
-	# Anyone wants to do a port?
-	;;
-      irix5* | irix6* | nonstopux*)
-	case $cc_basename in
-	  CC*)
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_static_CXX='-non_shared'
-	    # CC pic flag -KPIC is the default.
-	    ;;
-	  *)
-	    ;;
-	esac
-	;;
-      linux* | k*bsd*-gnu | kopensolaris*-gnu)
-	case $cc_basename in
-	  KCC*)
-	    # KAI C++ Compiler
-	    lt_prog_compiler_wl_CXX='--backend -Wl,'
-	    lt_prog_compiler_pic_CXX='-fPIC'
-	    ;;
-	  ecpc* )
-	    # old Intel C++ for x86_64 which still supported -KPIC.
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_pic_CXX='-KPIC'
-	    lt_prog_compiler_static_CXX='-static'
-	    ;;
-	  icpc* )
-	    # Intel C++, used to be incompatible with GCC.
-	    # ICC 10 doesn't accept -KPIC any more.
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_pic_CXX='-fPIC'
-	    lt_prog_compiler_static_CXX='-static'
-	    ;;
-	  pgCC* | pgcpp*)
-	    # Portland Group C++ compiler
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_pic_CXX='-fpic'
-	    lt_prog_compiler_static_CXX='-Bstatic'
-	    ;;
-	  cxx*)
-	    # Compaq C++
-	    # Make sure the PIC flag is empty.  It appears that all Alpha
-	    # Linux and Compaq Tru64 Unix objects are PIC.
-	    lt_prog_compiler_pic_CXX=
-	    lt_prog_compiler_static_CXX='-non_shared'
-	    ;;
-	  xlc* | xlC* | bgxl[cC]* | mpixl[cC]*)
-	    # IBM XL 8.0, 9.0 on PPC and BlueGene
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_pic_CXX='-qpic'
-	    lt_prog_compiler_static_CXX='-qstaticlink'
-	    ;;
-	  *)
-	    case `$CC -V 2>&1 | sed 5q` in
-	    *Sun\ C*)
-	      # Sun C++ 5.9
-	      lt_prog_compiler_pic_CXX='-KPIC'
-	      lt_prog_compiler_static_CXX='-Bstatic'
-	      lt_prog_compiler_wl_CXX='-Qoption ld '
-	      ;;
-	    esac
-	    ;;
-	esac
-	;;
-      lynxos*)
-	;;
-      m88k*)
-	;;
-      mvs*)
-	case $cc_basename in
-	  cxx*)
-	    lt_prog_compiler_pic_CXX='-W c,exportall'
-	    ;;
-	  *)
-	    ;;
-	esac
-	;;
-      netbsd* | netbsdelf*-gnu)
-	;;
-      *qnx* | *nto*)
-        # QNX uses GNU C++, but need to define -shared option too, otherwise
-        # it will coredump.
-        lt_prog_compiler_pic_CXX='-fPIC -shared'
-        ;;
-      osf3* | osf4* | osf5*)
-	case $cc_basename in
-	  KCC*)
-	    lt_prog_compiler_wl_CXX='--backend -Wl,'
-	    ;;
-	  RCC*)
-	    # Rational C++ 2.4.1
-	    lt_prog_compiler_pic_CXX='-pic'
-	    ;;
-	  cxx*)
-	    # Digital/Compaq C++
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    # Make sure the PIC flag is empty.  It appears that all Alpha
-	    # Linux and Compaq Tru64 Unix objects are PIC.
-	    lt_prog_compiler_pic_CXX=
-	    lt_prog_compiler_static_CXX='-non_shared'
-	    ;;
-	  *)
-	    ;;
-	esac
-	;;
-      psos*)
-	;;
-      solaris*)
-	case $cc_basename in
-	  CC* | sunCC*)
-	    # Sun C++ 4.2, 5.x and Centerline C++
-	    lt_prog_compiler_pic_CXX='-KPIC'
-	    lt_prog_compiler_static_CXX='-Bstatic'
-	    lt_prog_compiler_wl_CXX='-Qoption ld '
-	    ;;
-	  gcx*)
-	    # Green Hills C++ Compiler
-	    lt_prog_compiler_pic_CXX='-PIC'
-	    ;;
-	  *)
-	    ;;
-	esac
-	;;
-      sunos4*)
-	case $cc_basename in
-	  CC*)
-	    # Sun C++ 4.x
-	    lt_prog_compiler_pic_CXX='-pic'
-	    lt_prog_compiler_static_CXX='-Bstatic'
-	    ;;
-	  lcc*)
-	    # Lucid
-	    lt_prog_compiler_pic_CXX='-pic'
-	    ;;
-	  *)
-	    ;;
-	esac
-	;;
-      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
-	case $cc_basename in
-	  CC*)
-	    lt_prog_compiler_wl_CXX='-Wl,'
-	    lt_prog_compiler_pic_CXX='-KPIC'
-	    lt_prog_compiler_static_CXX='-Bstatic'
-	    ;;
-	esac
-	;;
-      tandem*)
-	case $cc_basename in
-	  NCC*)
-	    # NonStop-UX NCC 3.20
-	    lt_prog_compiler_pic_CXX='-KPIC'
-	    ;;
-	  *)
-	    ;;
-	esac
-	;;
-      vxworks*)
-	;;
-      *)
-	lt_prog_compiler_can_build_shared_CXX=no
-	;;
-    esac
-  fi
-
-case $host_os in
-  # For platforms which do not support PIC, -DPIC is meaningless:
-  *djgpp*)
-    lt_prog_compiler_pic_CXX=
-    ;;
-  *)
-    lt_prog_compiler_pic_CXX="$lt_prog_compiler_pic_CXX -DPIC"
-    ;;
-esac
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
-$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
-if ${lt_cv_prog_compiler_pic_CXX+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_pic_CXX=$lt_prog_compiler_pic_CXX
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_CXX" >&5
-$as_echo "$lt_cv_prog_compiler_pic_CXX" >&6; }
-lt_prog_compiler_pic_CXX=$lt_cv_prog_compiler_pic_CXX
-
-#
-# Check to make sure the PIC flag actually works.
-#
-if test -n "$lt_prog_compiler_pic_CXX"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic_CXX works" >&5
-$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic_CXX works... " >&6; }
-if ${lt_cv_prog_compiler_pic_works_CXX+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_pic_works_CXX=no
-   ac_outfile=conftest.$ac_objext
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-   lt_compiler_flag="$lt_prog_compiler_pic_CXX -DPIC"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   # The option is referenced via a variable to avoid confusing sed.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>conftest.err)
-   ac_status=$?
-   cat conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s "$ac_outfile"; then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings other than the usual output.
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
-     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_pic_works_CXX=yes
-     fi
-   fi
-   $RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_works_CXX" >&5
-$as_echo "$lt_cv_prog_compiler_pic_works_CXX" >&6; }
-
-if test x"$lt_cv_prog_compiler_pic_works_CXX" = xyes; then
-    case $lt_prog_compiler_pic_CXX in
-     "" | " "*) ;;
-     *) lt_prog_compiler_pic_CXX=" $lt_prog_compiler_pic_CXX" ;;
-     esac
-else
-    lt_prog_compiler_pic_CXX=
-     lt_prog_compiler_can_build_shared_CXX=no
-fi
-
-fi
-
-
-
-
-
-#
-# Check to make sure the static flag actually works.
-#
-wl=$lt_prog_compiler_wl_CXX eval lt_tmp_static_flag=\"$lt_prog_compiler_static_CXX\"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
-$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
-if ${lt_cv_prog_compiler_static_works_CXX+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_static_works_CXX=no
-   save_LDFLAGS="$LDFLAGS"
-   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
-   echo "$lt_simple_link_test_code" > conftest.$ac_ext
-   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
-     # The linker can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     if test -s conftest.err; then
-       # Append any errors to the config.log.
-       cat conftest.err 1>&5
-       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
-       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
-       if diff conftest.exp conftest.er2 >/dev/null; then
-         lt_cv_prog_compiler_static_works_CXX=yes
-       fi
-     else
-       lt_cv_prog_compiler_static_works_CXX=yes
-     fi
-   fi
-   $RM -r conftest*
-   LDFLAGS="$save_LDFLAGS"
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_static_works_CXX" >&5
-$as_echo "$lt_cv_prog_compiler_static_works_CXX" >&6; }
-
-if test x"$lt_cv_prog_compiler_static_works_CXX" = xyes; then
-    :
-else
-    lt_prog_compiler_static_CXX=
-fi
-
-
-
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
-$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
-if ${lt_cv_prog_compiler_c_o_CXX+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_c_o_CXX=no
-   $RM -r conftest 2>/dev/null
-   mkdir conftest
-   cd conftest
-   mkdir out
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-
-   lt_compiler_flag="-o out/conftest2.$ac_objext"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>out/conftest.err)
-   ac_status=$?
-   cat out/conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s out/conftest2.$ac_objext
-   then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
-     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
-     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_c_o_CXX=yes
-     fi
-   fi
-   chmod u+w . 2>&5
-   $RM conftest*
-   # SGI C++ compiler will create directory out/ii_files/ for
-   # template instantiation
-   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
-   $RM out/* && rmdir out
-   cd ..
-   $RM -r conftest
-   $RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o_CXX" >&5
-$as_echo "$lt_cv_prog_compiler_c_o_CXX" >&6; }
-
-
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
-$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
-if ${lt_cv_prog_compiler_c_o_CXX+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_prog_compiler_c_o_CXX=no
-   $RM -r conftest 2>/dev/null
-   mkdir conftest
-   cd conftest
-   mkdir out
-   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-
-   lt_compiler_flag="-o out/conftest2.$ac_objext"
-   # Insert the option either (1) after the last *FLAGS variable, or
-   # (2) before a word containing "conftest.", or (3) at the end.
-   # Note that $ac_compile itself does not contain backslashes and begins
-   # with a dollar sign (not a hyphen), so the echo should work correctly.
-   lt_compile=`echo "$ac_compile" | $SED \
-   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
-   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
-   -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
-   (eval "$lt_compile" 2>out/conftest.err)
-   ac_status=$?
-   cat out/conftest.err >&5
-   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-   if (exit $ac_status) && test -s out/conftest2.$ac_objext
-   then
-     # The compiler can only warn and ignore the option if not recognized
-     # So say no if there are warnings
-     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
-     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
-     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
-       lt_cv_prog_compiler_c_o_CXX=yes
-     fi
-   fi
-   chmod u+w . 2>&5
-   $RM conftest*
-   # SGI C++ compiler will create directory out/ii_files/ for
-   # template instantiation
-   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
-   $RM out/* && rmdir out
-   cd ..
-   $RM -r conftest
-   $RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o_CXX" >&5
-$as_echo "$lt_cv_prog_compiler_c_o_CXX" >&6; }
-
-
-
-
-hard_links="nottested"
-if test "$lt_cv_prog_compiler_c_o_CXX" = no && test "$need_locks" != no; then
-  # do not overwrite the value of need_locks provided by the user
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
-$as_echo_n "checking if we can lock with hard links... " >&6; }
-  hard_links=yes
-  $RM conftest*
-  ln conftest.a conftest.b 2>/dev/null && hard_links=no
-  touch conftest.a
-  ln conftest.a conftest.b 2>&5 || hard_links=no
-  ln conftest.a conftest.b 2>/dev/null && hard_links=no
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
-$as_echo "$hard_links" >&6; }
-  if test "$hard_links" = no; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
-$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
-    need_locks=warn
-  fi
-else
-  need_locks=no
-fi
-
-
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
-$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
-
-  export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
-  exclude_expsyms_CXX='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
-  case $host_os in
-  aix[4-9]*)
-    # If we're using GNU nm, then we don't want the "-C" option.
-    # -C means demangle to AIX nm, but means don't demangle with GNU nm
-    # Also, AIX nm treats weak defined symbols like other global defined
-    # symbols, whereas GNU nm marks them as "W".
-    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
-      export_symbols_cmds_CXX='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
-    else
-      export_symbols_cmds_CXX='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
-    fi
-    ;;
-  pw32*)
-    export_symbols_cmds_CXX="$ltdll_cmds"
-    ;;
-  cygwin* | mingw* | cegcc*)
-    case $cc_basename in
-    cl*) ;;
-    *)
-      export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1 DATA/;s/^.*[ ]__nm__\([^ ]*\)[ ][^ ]*/\1 DATA/;/^I[ ]/d;/^[AITW][ ]/s/.* //'\'' | sort | uniq > $export_symbols'
-      exclude_expsyms_CXX='[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname'
-      ;;
-    esac
-    ;;
-  linux* | k*bsd*-gnu | gnu*)
-    link_all_deplibs_CXX=no
-    ;;
-  *)
-    export_symbols_cmds_CXX='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
-    ;;
-  esac
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs_CXX" >&5
-$as_echo "$ld_shlibs_CXX" >&6; }
-test "$ld_shlibs_CXX" = no && can_build_shared=no
-
-with_gnu_ld_CXX=$with_gnu_ld
-
-
-
-
-
-
-#
-# Do we need to explicitly link libc?
-#
-case "x$archive_cmds_need_lc_CXX" in
-x|xyes)
-  # Assume -lc should be added
-  archive_cmds_need_lc_CXX=yes
-
-  if test "$enable_shared" = yes && test "$GCC" = yes; then
-    case $archive_cmds_CXX in
-    *'~'*)
-      # FIXME: we may have to deal with multi-command sequences.
-      ;;
-    '$CC '*)
-      # Test whether the compiler implicitly links with -lc since on some
-      # systems, -lgcc has to come before -lc. If gcc already passes -lc
-      # to ld, don't add -lc before -lgcc.
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
-$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
-if ${lt_cv_archive_cmds_need_lc_CXX+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  $RM conftest*
-	echo "$lt_simple_compile_test_code" > conftest.$ac_ext
-
-	if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; } 2>conftest.err; then
-	  soname=conftest
-	  lib=conftest
-	  libobjs=conftest.$ac_objext
-	  deplibs=
-	  wl=$lt_prog_compiler_wl_CXX
-	  pic_flag=$lt_prog_compiler_pic_CXX
-	  compiler_flags=-v
-	  linker_flags=-v
-	  verstring=
-	  output_objdir=.
-	  libname=conftest
-	  lt_save_allow_undefined_flag=$allow_undefined_flag_CXX
-	  allow_undefined_flag_CXX=
-	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds_CXX 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\""; } >&5
-  (eval $archive_cmds_CXX 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1) 2>&5
-  ac_status=$?
-  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
-  test $ac_status = 0; }
-	  then
-	    lt_cv_archive_cmds_need_lc_CXX=no
-	  else
-	    lt_cv_archive_cmds_need_lc_CXX=yes
-	  fi
-	  allow_undefined_flag_CXX=$lt_save_allow_undefined_flag
-	else
-	  cat conftest.err 1>&5
-	fi
-	$RM conftest*
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_archive_cmds_need_lc_CXX" >&5
-$as_echo "$lt_cv_archive_cmds_need_lc_CXX" >&6; }
-      archive_cmds_need_lc_CXX=$lt_cv_archive_cmds_need_lc_CXX
-      ;;
-    esac
-  fi
-  ;;
-esac
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
-$as_echo_n "checking dynamic linker characteristics... " >&6; }
-
-library_names_spec=
-libname_spec='lib$name'
-soname_spec=
-shrext_cmds=".so"
-postinstall_cmds=
-postuninstall_cmds=
-finish_cmds=
-finish_eval=
-shlibpath_var=
-shlibpath_overrides_runpath=unknown
-version_type=none
-dynamic_linker="$host_os ld.so"
-sys_lib_dlsearch_path_spec="/lib /usr/lib"
-need_lib_prefix=unknown
-hardcode_into_libs=no
-
-# when you set need_version to no, make sure it does not cause -set_version
-# flags to be left without arguments
-need_version=unknown
-
-case $host_os in
-aix3*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
-  shlibpath_var=LIBPATH
-
-  # AIX 3 has no versioning support, so we append a major version to the name.
-  soname_spec='${libname}${release}${shared_ext}$major'
-  ;;
-
-aix[4-9]*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  hardcode_into_libs=yes
-  if test "$host_cpu" = ia64; then
-    # AIX 5 supports IA64
-    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
-    shlibpath_var=LD_LIBRARY_PATH
-  else
-    # With GCC up to 2.95.x, collect2 would create an import file
-    # for dependence libraries.  The import file would start with
-    # the line `#! .'.  This would cause the generated library to
-    # depend on `.', always an invalid library.  This was fixed in
-    # development snapshots of GCC prior to 3.0.
-    case $host_os in
-      aix4 | aix4.[01] | aix4.[01].*)
-      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
-	   echo ' yes '
-	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
-	:
-      else
-	can_build_shared=no
-      fi
-      ;;
-    esac
-    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
-    # soname into executable. Probably we can add versioning support to
-    # collect2, so additional links can be useful in future.
-    if test "$aix_use_runtimelinking" = yes; then
-      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
-      # instead of lib<name>.a to let people know that these are not
-      # typical AIX shared libraries.
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    else
-      # We preserve .a as extension for shared libraries through AIX4.2
-      # and later when we are not doing run time linking.
-      library_names_spec='${libname}${release}.a $libname.a'
-      soname_spec='${libname}${release}${shared_ext}$major'
-    fi
-    shlibpath_var=LIBPATH
-  fi
-  ;;
-
-amigaos*)
-  case $host_cpu in
-  powerpc)
-    # Since July 2007 AmigaOS4 officially supports .so libraries.
-    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    ;;
-  m68k)
-    library_names_spec='$libname.ixlibrary $libname.a'
-    # Create ${libname}_ixlibrary.a entries in /sys/libs.
-    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
-    ;;
-  esac
-  ;;
-
-beos*)
-  library_names_spec='${libname}${shared_ext}'
-  dynamic_linker="$host_os ld.so"
-  shlibpath_var=LIBRARY_PATH
-  ;;
-
-bsdi[45]*)
-  version_type=linux
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
-  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
-  # the default ld.so.conf also contains /usr/contrib/lib and
-  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
-  # libtool to hard-code these into programs
-  ;;
-
-cygwin* | mingw* | pw32* | cegcc*)
-  version_type=windows
-  shrext_cmds=".dll"
-  need_version=no
-  need_lib_prefix=no
-
-  case $GCC,$cc_basename in
-  yes,*)
-    # gcc
-    library_names_spec='$libname.dll.a'
-    # DLL is installed to $(libdir)/../bin by postinstall_cmds
-    postinstall_cmds='base_file=`basename \${file}`~
-      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
-      dldir=$destdir/`dirname \$dlpath`~
-      test -d \$dldir || mkdir -p \$dldir~
-      $install_prog $dir/$dlname \$dldir/$dlname~
-      chmod a+x \$dldir/$dlname~
-      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
-        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
-      fi'
-    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
-      dlpath=$dir/\$dldll~
-       $RM \$dlpath'
-    shlibpath_overrides_runpath=yes
-
-    case $host_os in
-    cygwin*)
-      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
-      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-
-      ;;
-    mingw* | cegcc*)
-      # MinGW DLLs use traditional 'lib' prefix
-      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-      ;;
-    pw32*)
-      # pw32 DLLs use 'pw' prefix rather than 'lib'
-      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-      ;;
-    esac
-    dynamic_linker='Win32 ld.exe'
-    ;;
-
-  *,cl*)
-    # Native MSVC
-    libname_spec='$name'
-    soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
-    library_names_spec='${libname}.dll.lib'
-
-    case $build_os in
-    mingw*)
-      sys_lib_search_path_spec=
-      lt_save_ifs=$IFS
-      IFS=';'
-      for lt_path in $LIB
-      do
-        IFS=$lt_save_ifs
-        # Let DOS variable expansion print the short 8.3 style file name.
-        lt_path=`cd "$lt_path" 2>/dev/null && cmd //C "for %i in (".") do @echo %~si"`
-        sys_lib_search_path_spec="$sys_lib_search_path_spec $lt_path"
-      done
-      IFS=$lt_save_ifs
-      # Convert to MSYS style.
-      sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | sed -e 's|\\\\|/|g' -e 's| \\([a-zA-Z]\\):| /\\1|g' -e 's|^ ||'`
-      ;;
-    cygwin*)
-      # Convert to unix form, then to dos form, then back to unix form
-      # but this time dos style (no spaces!) so that the unix form looks
-      # like /cygdrive/c/PROGRA~1:/cygdr...
-      sys_lib_search_path_spec=`cygpath --path --unix "$LIB"`
-      sys_lib_search_path_spec=`cygpath --path --dos "$sys_lib_search_path_spec" 2>/dev/null`
-      sys_lib_search_path_spec=`cygpath --path --unix "$sys_lib_search_path_spec" | $SED -e "s/$PATH_SEPARATOR/ /g"`
-      ;;
-    *)
-      sys_lib_search_path_spec="$LIB"
-      if $ECHO "$sys_lib_search_path_spec" | $GREP ';[c-zC-Z]:/' >/dev/null; then
-        # It is most probably a Windows format PATH.
-        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
-      else
-        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e "s/$PATH_SEPARATOR/ /g"`
-      fi
-      # FIXME: find the short name or the path components, as spaces are
-      # common. (e.g. "Program Files" -> "PROGRA~1")
-      ;;
-    esac
-
-    # DLL is installed to $(libdir)/../bin by postinstall_cmds
-    postinstall_cmds='base_file=`basename \${file}`~
-      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
-      dldir=$destdir/`dirname \$dlpath`~
-      test -d \$dldir || mkdir -p \$dldir~
-      $install_prog $dir/$dlname \$dldir/$dlname'
-    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
-      dlpath=$dir/\$dldll~
-       $RM \$dlpath'
-    shlibpath_overrides_runpath=yes
-    dynamic_linker='Win32 link.exe'
-    ;;
-
-  *)
-    # Assume MSVC wrapper
-    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
-    dynamic_linker='Win32 ld.exe'
-    ;;
-  esac
-  # FIXME: first we should search . and the directory the executable is in
-  shlibpath_var=PATH
-  ;;
-
-darwin* | rhapsody*)
-  dynamic_linker="$host_os dyld"
-  version_type=darwin
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
-  soname_spec='${libname}${release}${major}$shared_ext'
-  shlibpath_overrides_runpath=yes
-  shlibpath_var=DYLD_LIBRARY_PATH
-  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
-
-  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
-  ;;
-
-dgux*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  ;;
-
-freebsd1*)
-  dynamic_linker=no
-  ;;
-
-freebsd* | dragonfly*)
-  # DragonFly does not have aout.  When/if they implement a new
-  # versioning mechanism, adjust this.
-  if test -x /usr/bin/objformat; then
-    objformat=`/usr/bin/objformat`
-  else
-    case $host_os in
-    freebsd[123]*) objformat=aout ;;
-    *) objformat=elf ;;
-    esac
-  fi
-  version_type=freebsd-$objformat
-  case $version_type in
-    freebsd-elf*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
-      need_version=no
-      need_lib_prefix=no
-      ;;
-    freebsd-*)
-      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
-      need_version=yes
-      ;;
-  esac
-  shlibpath_var=LD_LIBRARY_PATH
-  case $host_os in
-  freebsd2*)
-    shlibpath_overrides_runpath=yes
-    ;;
-  freebsd3.[01]* | freebsdelf3.[01]*)
-    shlibpath_overrides_runpath=yes
-    hardcode_into_libs=yes
-    ;;
-  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
-  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
-    shlibpath_overrides_runpath=no
-    hardcode_into_libs=yes
-    ;;
-  *) # from 4.6 on, and DragonFly
-    shlibpath_overrides_runpath=yes
-    hardcode_into_libs=yes
-    ;;
-  esac
-  ;;
-
-gnu*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  ;;
-
-haiku*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  dynamic_linker="$host_os runtime_loader"
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'
-  hardcode_into_libs=yes
-  ;;
-
-hpux9* | hpux10* | hpux11*)
-  # Give a soname corresponding to the major version so that dld.sl refuses to
-  # link against other versions.
-  version_type=sunos
-  need_lib_prefix=no
-  need_version=no
-  case $host_cpu in
-  ia64*)
-    shrext_cmds='.so'
-    hardcode_into_libs=yes
-    dynamic_linker="$host_os dld.so"
-    shlibpath_var=LD_LIBRARY_PATH
-    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    if test "X$HPUX_IA64_MODE" = X32; then
-      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
-    else
-      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
-    fi
-    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
-    ;;
-  hppa*64*)
-    shrext_cmds='.sl'
-    hardcode_into_libs=yes
-    dynamic_linker="$host_os dld.sl"
-    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
-    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
-    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
-    ;;
-  *)
-    shrext_cmds='.sl'
-    dynamic_linker="$host_os dld.sl"
-    shlibpath_var=SHLIB_PATH
-    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    ;;
-  esac
-  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...
-  postinstall_cmds='chmod 555 $lib'
-  # or fails outright, so override atomically:
-  install_override_mode=555
-  ;;
-
-interix[3-9]*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  ;;
-
-irix5* | irix6* | nonstopux*)
-  case $host_os in
-    nonstopux*) version_type=nonstopux ;;
-    *)
-	if test "$lt_cv_prog_gnu_ld" = yes; then
-		version_type=linux
-	else
-		version_type=irix
-	fi ;;
-  esac
-  need_lib_prefix=no
-  need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
-  case $host_os in
-  irix5* | nonstopux*)
-    libsuff= shlibsuff=
-    ;;
-  *)
-    case $LD in # libtool.m4 will add one of these switches to LD
-    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
-      libsuff= shlibsuff= libmagic=32-bit;;
-    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
-      libsuff=32 shlibsuff=N32 libmagic=N32;;
-    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
-      libsuff=64 shlibsuff=64 libmagic=64-bit;;
-    *) libsuff= shlibsuff= libmagic=never-match;;
-    esac
-    ;;
-  esac
-  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
-  shlibpath_overrides_runpath=no
-  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
-  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
-  hardcode_into_libs=yes
-  ;;
-
-# No shared lib support for Linux oldld, aout, or coff.
-linux*oldld* | linux*aout* | linux*coff*)
-  dynamic_linker=no
-  ;;
-
-# This must be Linux ELF.
-linux* | k*bsd*-gnu | kopensolaris*-gnu)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-
-  # Some binutils ld are patched to set DT_RUNPATH
-  if ${lt_cv_shlibpath_overrides_runpath+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  lt_cv_shlibpath_overrides_runpath=no
-    save_LDFLAGS=$LDFLAGS
-    save_libdir=$libdir
-    eval "libdir=/foo; wl=\"$lt_prog_compiler_wl_CXX\"; \
-	 LDFLAGS=\"\$LDFLAGS $hardcode_libdir_flag_spec_CXX\""
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then :
-  lt_cv_shlibpath_overrides_runpath=yes
-fi
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-    LDFLAGS=$save_LDFLAGS
-    libdir=$save_libdir
-
-fi
-
-  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath
-
-  # This implies no fast_install, which is unacceptable.
-  # Some rework will be needed to allow for fast_install
-  # before this can be enabled.
-  hardcode_into_libs=yes
-
-  # Append ld.so.conf contents to the search path
-  if test -f /etc/ld.so.conf; then
-    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
-    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
-  fi
-
-  # We used to test for /lib/ld.so.1 and disable shared libraries on
-  # powerpc, because MkLinux only supported shared libraries with the
-  # GNU dynamic linker.  Since this was broken with cross compilers,
-  # most powerpc-linux boxes support dynamic linking these days and
-  # people can always --disable-shared, the test was removed, and we
-  # assume the GNU/Linux dynamic linker is in use.
-  dynamic_linker='GNU/Linux ld.so'
-  ;;
-
-netbsdelf*-gnu)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  dynamic_linker='NetBSD ld.elf_so'
-  ;;
-
-netbsd*)
-  version_type=sunos
-  need_lib_prefix=no
-  need_version=no
-  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
-    dynamic_linker='NetBSD (a.out) ld.so'
-  else
-    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
-    soname_spec='${libname}${release}${shared_ext}$major'
-    dynamic_linker='NetBSD ld.elf_so'
-  fi
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  ;;
-
-newsos6)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  ;;
-
-*nto* | *qnx*)
-  version_type=qnx
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  dynamic_linker='ldqnx.so'
-  ;;
-
-openbsd*)
-  version_type=sunos
-  sys_lib_dlsearch_path_spec="/usr/lib"
-  need_lib_prefix=no
-  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
-  case $host_os in
-    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
-    *)				need_version=no  ;;
-  esac
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
-    case $host_os in
-      openbsd2.[89] | openbsd2.[89].*)
-	shlibpath_overrides_runpath=no
-	;;
-      *)
-	shlibpath_overrides_runpath=yes
-	;;
-      esac
-  else
-    shlibpath_overrides_runpath=yes
-  fi
-  ;;
-
-os2*)
-  libname_spec='$name'
-  shrext_cmds=".dll"
-  need_lib_prefix=no
-  library_names_spec='$libname${shared_ext} $libname.a'
-  dynamic_linker='OS/2 ld.exe'
-  shlibpath_var=LIBPATH
-  ;;
-
-osf3* | osf4* | osf5*)
-  version_type=osf
-  need_lib_prefix=no
-  need_version=no
-  soname_spec='${libname}${release}${shared_ext}$major'
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
-  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
-  ;;
-
-rdos*)
-  dynamic_linker=no
-  ;;
-
-solaris*)
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  # ldd complains unless libraries are executable
-  postinstall_cmds='chmod +x $lib'
-  ;;
-
-sunos4*)
-  version_type=sunos
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
-  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  if test "$with_gnu_ld" = yes; then
-    need_lib_prefix=no
-  fi
-  need_version=yes
-  ;;
-
-sysv4 | sysv4.3*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  case $host_vendor in
-    sni)
-      shlibpath_overrides_runpath=no
-      need_lib_prefix=no
-      runpath_var=LD_RUN_PATH
-      ;;
-    siemens)
-      need_lib_prefix=no
-      ;;
-    motorola)
-      need_lib_prefix=no
-      need_version=no
-      shlibpath_overrides_runpath=no
-      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
-      ;;
-  esac
-  ;;
-
-sysv4*MP*)
-  if test -d /usr/nec ;then
-    version_type=linux
-    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
-    soname_spec='$libname${shared_ext}.$major'
-    shlibpath_var=LD_LIBRARY_PATH
-  fi
-  ;;
-
-sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
-  version_type=freebsd-elf
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=yes
-  hardcode_into_libs=yes
-  if test "$with_gnu_ld" = yes; then
-    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
-  else
-    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
-    case $host_os in
-      sco3.2v5*)
-        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
-	;;
-    esac
-  fi
-  sys_lib_dlsearch_path_spec='/usr/lib'
-  ;;
-
-tpf*)
-  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
-  version_type=linux
-  need_lib_prefix=no
-  need_version=no
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  shlibpath_var=LD_LIBRARY_PATH
-  shlibpath_overrides_runpath=no
-  hardcode_into_libs=yes
-  ;;
-
-uts4*)
-  version_type=linux
-  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
-  soname_spec='${libname}${release}${shared_ext}$major'
-  shlibpath_var=LD_LIBRARY_PATH
-  ;;
-
-*)
-  dynamic_linker=no
-  ;;
-esac
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
-$as_echo "$dynamic_linker" >&6; }
-test "$dynamic_linker" = no && can_build_shared=no
-
-variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
-if test "$GCC" = yes; then
-  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
-fi
-
-if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
-  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
-fi
-if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
-  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
-$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
-hardcode_action_CXX=
-if test -n "$hardcode_libdir_flag_spec_CXX" ||
-   test -n "$runpath_var_CXX" ||
-   test "X$hardcode_automatic_CXX" = "Xyes" ; then
-
-  # We can hardcode non-existent directories.
-  if test "$hardcode_direct_CXX" != no &&
-     # If the only mechanism to avoid hardcoding is shlibpath_var, we
-     # have to relink, otherwise we might link with an installed library
-     # when we should be linking with a yet-to-be-installed one
-     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, CXX)" != no &&
-     test "$hardcode_minus_L_CXX" != no; then
-    # Linking always hardcodes the temporary library directory.
-    hardcode_action_CXX=relink
-  else
-    # We can link without hardcoding, and we can hardcode nonexisting dirs.
-    hardcode_action_CXX=immediate
-  fi
-else
-  # We cannot hardcode anything, or else we can only hardcode existing
-  # directories.
-  hardcode_action_CXX=unsupported
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action_CXX" >&5
-$as_echo "$hardcode_action_CXX" >&6; }
-
-if test "$hardcode_action_CXX" = relink ||
-   test "$inherit_rpath_CXX" = yes; then
-  # Fast installation is not supported
-  enable_fast_install=no
-elif test "$shlibpath_overrides_runpath" = yes ||
-     test "$enable_shared" = no; then
-  # Fast installation is not necessary
-  enable_fast_install=needless
-fi
-
-
-
-
-
-
-
-  fi # test -n "$compiler"
-
-  CC=$lt_save_CC
-  CFLAGS=$lt_save_CFLAGS
-  LDCXX=$LD
-  LD=$lt_save_LD
-  GCC=$lt_save_GCC
-  with_gnu_ld=$lt_save_with_gnu_ld
-  lt_cv_path_LDCXX=$lt_cv_path_LD
-  lt_cv_path_LD=$lt_save_path_LD
-  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld
-  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld
-fi # test "$_lt_caught_CXX_error" != yes
-
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-
-
-
-
-
-
-
-
-
-
-
-
-
-        ac_config_commands="$ac_config_commands libtool"
-
-
-
-
-# Only expand once:
-
-
-
-
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for 64-bit OS" >&5
-$as_echo_n "checking for 64-bit OS... " >&6; }
-if test "$cross_compiling" = yes; then :
-  result="maybe"
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
- int main () {
-    if (sizeof(long) == 8) { return 0; } return 1; }
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-  result="yes"
-else
-  result="no"
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $result" >&5
-$as_echo "$result" >&6; }
-if test "$result" = "yes"; then
-
-$as_echo "#define HAVE_64BIT_OS 1" >>confdefs.h
-
-fi
-
-ac_ext=cpp
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing dlopen" >&5
-$as_echo_n "checking for library containing dlopen... " >&6; }
-if ${ac_cv_search_dlopen+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_func_search_save_LIBS=$LIBS
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char dlopen ();
-int
-main ()
-{
-return dlopen ();
-  ;
-  return 0;
-}
-_ACEOF
-for ac_lib in '' dl; do
-  if test -z "$ac_lib"; then
-    ac_res="none required"
-  else
-    ac_res=-l$ac_lib
-    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
-  fi
-  if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_search_dlopen=$ac_res
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext
-  if ${ac_cv_search_dlopen+:} false; then :
-  break
-fi
-done
-if ${ac_cv_search_dlopen+:} false; then :
-
-else
-  ac_cv_search_dlopen=no
-fi
-rm conftest.$ac_ext
-LIBS=$ac_func_search_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_dlopen" >&5
-$as_echo "$ac_cv_search_dlopen" >&6; }
-ac_res=$ac_cv_search_dlopen
-if test "$ac_res" != no; then :
-  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
-
-fi
-
-if test x"$ac_cv_search_dlopen" = x-ldl; then
-LIBS="$LIBS -ldl"
-fi
-
-
-# Check whether --enable-python_module was given.
-if test "${enable_python_module+set}" = set; then :
-  enableval=$enable_python_module;  PYTHON_MODULE="$enableval"
-
-fi
-
-
-if test "x$PYTHON_MODULE" = "xyes"; then
-
-$as_echo "#define PYTHON_MODULE 1" >>confdefs.h
-
-fi
- if test "x$PYTHON_MODULE" = "xyes"; then
-  BUILDASLIBRARY_TRUE=
-  BUILDASLIBRARY_FALSE='#'
-else
-  BUILDASLIBRARY_TRUE='#'
-  BUILDASLIBRARY_FALSE=
-fi
-
-
-
-for ac_func in malloc_zone_statistics sbrk mallinfo
-do :
-  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
-ac_fn_cxx_check_func "$LINENO" "$ac_func" "$as_ac_var"
-if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-done
-
-
-for ac_header in malloc.h malloc/malloc.h
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-for ac_header in locale.h
-do :
-  ac_fn_cxx_check_header_mongrel "$LINENO" "locale.h" "ac_cv_header_locale_h" "$ac_includes_default"
-if test "x$ac_cv_header_locale_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LOCALE_H 1
-_ACEOF
-
-fi
-
-done
-
-
-for ac_func in nexttoward
-do :
-  ac_fn_cxx_check_func "$LINENO" "nexttoward" "ac_cv_func_nexttoward"
-if test "x$ac_cv_func_nexttoward" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_NEXTTOWARD 1
-_ACEOF
-
-fi
-done
-
-
-for ac_header in ext/stdio_filebuf.h
-do :
-  ac_fn_cxx_check_header_mongrel "$LINENO" "ext/stdio_filebuf.h" "ac_cv_header_ext_stdio_filebuf_h" "$ac_includes_default"
-if test "x$ac_cv_header_ext_stdio_filebuf_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_EXT_STDIO_FILEBUF_H 1
-_ACEOF
-
-fi
-
-done
-
-
-
-
-# Check whether --with-ncursesdir was given.
-if test "${with_ncursesdir+set}" = set; then :
-  withval=$with_ncursesdir;  LIBS="$LIBS -L$withval/lib"
-         INCLUDES="$INCLUDES -I$withval/include"
-
-fi
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for initscr in -lncurses" >&5
-$as_echo_n "checking for initscr in -lncurses... " >&6; }
-if ${ac_cv_lib_ncurses_initscr+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lncurses  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char initscr ();
-int
-main ()
-{
-return initscr ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_ncurses_initscr=yes
-else
-  ac_cv_lib_ncurses_initscr=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ncurses_initscr" >&5
-$as_echo "$ac_cv_lib_ncurses_initscr" >&6; }
-if test "x$ac_cv_lib_ncurses_initscr" = xyes; then :
-
-$as_echo "#define HAVE_LIBNCURSES 1" >>confdefs.h
-
-  LIBS="-lncurses $LIBS"
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for initscr in -lcurses" >&5
-$as_echo_n "checking for initscr in -lcurses... " >&6; }
-if ${ac_cv_lib_curses_initscr+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lcurses  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char initscr ();
-int
-main ()
-{
-return initscr ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_curses_initscr=yes
-else
-  ac_cv_lib_curses_initscr=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_curses_initscr" >&5
-$as_echo "$ac_cv_lib_curses_initscr" >&6; }
-if test "x$ac_cv_lib_curses_initscr" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBCURSES 1
-_ACEOF
-
-  LIBS="-lcurses $LIBS"
-
-fi
-
-fi
-
-
-
-
-# Check whether --with-readlinedir was given.
-if test "${with_readlinedir+set}" = set; then :
-  withval=$with_readlinedir;  with_readlinedir="$withval"
-fi
-
-
-if test "x$with_readlinedir" != "xno"; then
-
-  if test "x$with_readlinedir" != "xyes"; then
-    LIBS="-L$with_readlinedir/lib -L$with_readlinedir $LIBS -lreadline"
-    INCLUDES="$INCLUDES -I$with_readlinedir/include -I$with_readlinedir"
-  else
-    LIBS="$LIBS -lreadline"
-  fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for stifle_history in -lreadline" >&5
-$as_echo_n "checking for stifle_history in -lreadline... " >&6; }
-if ${ac_cv_lib_readline_stifle_history+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lreadline  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char stifle_history ();
-int
-main ()
-{
-return stifle_history ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_readline_stifle_history=yes
-else
-  ac_cv_lib_readline_stifle_history=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_readline_stifle_history" >&5
-$as_echo "$ac_cv_lib_readline_stifle_history" >&6; }
-if test "x$ac_cv_lib_readline_stifle_history" = xyes; then :
-
-$as_echo "#define HAVE_LIBREADLINE 1" >>confdefs.h
-
-else
-
-	echo ""
-	echo "Error! GNU readline was not found."
-	echo "       Use --with-readlinedir=no to expicitely disable it"
-	echo "       Check the README or use configure --help for other libraries needed"
-        echo ""
-        echo "       (suitable Debian/Ubuntu package: libreadline5-dev)"
-	exit -1
-
-fi
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for rl_get_screen_size in -lreadline" >&5
-$as_echo_n "checking for rl_get_screen_size in -lreadline... " >&6; }
-if ${ac_cv_lib_readline_rl_get_screen_size+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lreadline  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char rl_get_screen_size ();
-int
-main ()
-{
-return rl_get_screen_size ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_readline_rl_get_screen_size=yes
-else
-  ac_cv_lib_readline_rl_get_screen_size=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_readline_rl_get_screen_size" >&5
-$as_echo "$ac_cv_lib_readline_rl_get_screen_size" >&6; }
-if test "x$ac_cv_lib_readline_rl_get_screen_size" = xyes; then :
-
-
-$as_echo "#define RL_GET_SCREEN_SIZE 1" >>confdefs.h
-
-else
-
-	echo ""
-	echo "Warning! Older GNU readline without 'rl_get_screen_size' was found."
-	echo "         For resized terminals the size might not be updated correctly"
-	echo "         If this is a problem please install a recent version of readline"
-
-fi
-
-fi
-
-
-
-# Check whether --with-zlibdir was given.
-if test "${with_zlibdir+set}" = set; then :
-  withval=$with_zlibdir; with_zlib="$withval"
-fi
-
-
-if test "x$with_zlib" = "x"; then
-  with_zlib=yes
-fi
-
-if test "x$with_zlib" = "xno"; then
-	echo ""
-	echo "Error! ZLIB library is obligatory."
-        exit -1
-fi
-
-if test "x$with_zlib" != "xyes"; then
-    LIBS="$LIBS -L$with_zlib/lib -lz"
-    INCLUDES="$INCLUDES -I$with_zlib/include"
-else
-    LIBS="$LIBS -lz"
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for gzopen in -lz" >&5
-$as_echo_n "checking for gzopen in -lz... " >&6; }
-if ${ac_cv_lib_z_gzopen+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lz  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char gzopen ();
-int
-main ()
-{
-return gzopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_z_gzopen=yes
-else
-  ac_cv_lib_z_gzopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_z_gzopen" >&5
-$as_echo "$ac_cv_lib_z_gzopen" >&6; }
-if test "x$ac_cv_lib_z_gzopen" = xyes; then :
-
-$as_echo "#define HAVE_LIBZ 1" >>confdefs.h
-
-else
-
- 	echo ""
- 	echo "Error! zlib library is required but was not found"
- 	echo "       Use --with-zlibdir=DIR to specify the zlib directory tree"
-        echo ""
-        echo "       (suitable Debian/Ubuntu package: zlib1g-dev)"
- 	exit -1
-
-fi
-
-
-
-
-
-# Check whether --with-openmp was given.
-if test "${with_openmp+set}" = set; then :
-  withval=$with_openmp; with_openmp="$withval"
-fi
-
-
-openmp_autodetected=no
-if test "x$with_openmp" = "x"; then
-   for ac_header in "omp.h"
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-     with_openmp=yes
-     openmp_autodetected=yes
-     echo ""
-     echo "OpenMP enabled (omp.h file was found)."
-     echo "Try --with-openmp=no if your compiler does not support it (e.g. GCC < 4.2)"
-     echo ""
-
-else
-
-     with_openmp=no
-     echo ""
-     echo "OpenMP disabled (omp.h file was not found)."
-     echo "Try --with-openmp=yes if your compiler does support it (e.g. GCC >= 4.2)"
-     echo ""
-
-fi
-
-done
-
-fi
-
-if test "x$with_openmp" != "xno"; then
-	CPPFLAGS="$CPPFLAGS -fopenmp"
-	LDFLAGS="$LDFLAGS -fopenmp"
-fi
-
-
-
-
-# Check whether --with-gsldir was given.
-if test "${with_gsldir+set}" = set; then :
-  withval=$with_gsldir; with_gsl="$withval"
-fi
-
-
-if test "x$with_gsl" = "x"; then
-  with_gsl=yes
-fi
-
-if test "x$with_gsl" = "xno"; then
-	echo ""
-	echo "Error! Gnu Scientific Library (1.7 or higher) is mandatory"
-        exit -1
-fi
-
-if test "x$with_gsl" != "xyes"; then
-    LIBS="$LIBS -L$with_gsl/lib -lgsl -lgslcblas"
-    INCLUDES="$INCLUDES -I$with_gsl/include"
-else
-    LIBS="$LIBS -lgsl -lgslcblas"
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for gsl_ran_binomial_knuth in -lgsl" >&5
-$as_echo_n "checking for gsl_ran_binomial_knuth in -lgsl... " >&6; }
-if ${ac_cv_lib_gsl_gsl_ran_binomial_knuth+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lgsl  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char gsl_ran_binomial_knuth ();
-int
-main ()
-{
-return gsl_ran_binomial_knuth ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_gsl_gsl_ran_binomial_knuth=yes
-else
-  ac_cv_lib_gsl_gsl_ran_binomial_knuth=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gsl_gsl_ran_binomial_knuth" >&5
-$as_echo "$ac_cv_lib_gsl_gsl_ran_binomial_knuth" >&6; }
-if test "x$ac_cv_lib_gsl_gsl_ran_binomial_knuth" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBGSL 1
-_ACEOF
-
-  LIBS="-lgsl $LIBS"
-
-else
-
-	echo ""
-	echo "Error! Gnu Scientific Library (1.7 or higher) is mandatory"
-        echo ""
-        echo "       (suitable Debian/Ubuntu package: libgsl0-dev)"
-        exit -1
-
-fi
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for cblas_drot in -lgslcblas" >&5
-$as_echo_n "checking for cblas_drot in -lgslcblas... " >&6; }
-if ${ac_cv_lib_gslcblas_cblas_drot+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lgslcblas  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char cblas_drot ();
-int
-main ()
-{
-return cblas_drot ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_gslcblas_cblas_drot=yes
-else
-  ac_cv_lib_gslcblas_cblas_drot=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gslcblas_cblas_drot" >&5
-$as_echo "$ac_cv_lib_gslcblas_cblas_drot" >&6; }
-if test "x$ac_cv_lib_gslcblas_cblas_drot" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBGSLCBLAS 1
-_ACEOF
-
-  LIBS="-lgslcblas $LIBS"
-
-else
-
-	echo ""
-	echo "Error! libgslcblas (part of GSL) is mandatory"
-        exit -1
-
-fi
-
-
-
-
-# Check whether --with-plplotdir was given.
-if test "${with_plplotdir+set}" = set; then :
-  withval=$with_plplotdir; with_plplot="$withval"
-fi
-
-
-if test "x$with_plplot" = "x"; then
-  with_plplot=yes
-fi
-
-if test "x$with_plplot" = "xno"; then
-	echo ""
-	echo "Error! PLPLOT library is mandatory."
-        exit -1
-fi
-
-OLDPLPLOT="no"
-# Check whether --enable-oldplplot was given.
-if test "${enable_oldplplot+set}" = set; then :
-  enableval=$enable_oldplplot;  OLDPLPLOT="$enableval"
-
-fi
-
-
-if test "x$OLDPLPLOT" = "xyes"; then
-
-$as_echo "#define HAVE_OLDPLPLOT 1" >>confdefs.h
-
-fi
-
-if test "x$with_plplot" != "xyes"; then
-    LIBS="$LIBS -L$with_plplot/lib -lplplotd -lplplotcxxd"
-    INCLUDES="$INCLUDES -I$with_plplot/include"
-else
-    LIBS="$LIBS -lplplotd -lplplotcxxd"
-fi
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for plsexit in -lplplotcxxd" >&5
-$as_echo_n "checking for plsexit in -lplplotcxxd... " >&6; }
-if ${ac_cv_lib_plplotcxxd_plsexit+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lplplotcxxd  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char plsexit ();
-int
-main ()
-{
-return plsexit ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_plplotcxxd_plsexit=yes
-else
-  ac_cv_lib_plplotcxxd_plsexit=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_plplotcxxd_plsexit" >&5
-$as_echo "$ac_cv_lib_plplotcxxd_plsexit" >&6; }
-if test "x$ac_cv_lib_plplotcxxd_plsexit" = xyes; then :
-
-$as_echo "#define HAVE_LIBPLPLOTCXXD 1" >>confdefs.h
-
-else
-
-	echo ""
-	echo "Error! plplot library is required but was not found"
-	echo "       Use --with-plplot=DIR to specify the plplot directory tree"
-        echo ""
-        echo "       (suitable Debian/Ubuntu packages: libplplot-dev, plplot9-driver-xwin)"
-	exit -1
-
-fi
-
-
-if test "x$with_Magick" != "xno"; then
-  # https://sourceforge.net/tracker/index.php?func=detail&aid=2974380&group_id=97659&atid=618683
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for plGetDrvDir in -lplplotd" >&5
-$as_echo_n "checking for plGetDrvDir in -lplplotd... " >&6; }
-if ${ac_cv_lib_plplotd_plGetDrvDir+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lplplotd  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char plGetDrvDir ();
-int
-main ()
-{
-return plGetDrvDir ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_plplotd_plGetDrvDir=yes
-else
-  ac_cv_lib_plplotd_plGetDrvDir=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_plplotd_plGetDrvDir" >&5
-$as_echo "$ac_cv_lib_plplotd_plGetDrvDir" >&6; }
-if test "x$ac_cv_lib_plplotd_plGetDrvDir" = xyes; then :
-
-    echo ""
-    echo "Warning! Dynamic drivers have to be disabled in plplot"
-    echo "         to make plplot work with ImageMagic:"
-    echo "         - use the -DENABLE_DYNDRIVERS=OFF cmake option when"
-    echo "           compiling plplot to disable dynamic drivers in plplot, or"
-    echo "         - use --with-Magick=no here to not use ImageMagick in GDL."
-    echo ""
-
-fi
-
-fi
-
-
-
-
-# Check whether --with-wxWidgets was given.
-if test "${with_wxWidgets+set}" = set; then :
-  withval=$with_wxWidgets; with_wxWidgets="$withval"
-fi
-
-
-if test "x$with_wxWidgets" != "xno"; then
-
-  if test "x$with_wxWidgets" = "xyes"; then
-    # Extract the first word of "wx-config", so it can be a program name with args.
-set dummy wx-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_wxConfig+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $wxConfig in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_wxConfig="$wxConfig" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_wxConfig="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-  test -z "$ac_cv_path_wxConfig" && ac_cv_path_wxConfig="no"
-  ;;
-esac
-fi
-wxConfig=$ac_cv_path_wxConfig
-if test -n "$wxConfig"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $wxConfig" >&5
-$as_echo "$wxConfig" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  else
-    # Extract the first word of "wx-config", so it can be a program name with args.
-set dummy wx-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_wxConfig+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $wxConfig in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_wxConfig="$wxConfig" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in "$with_wxWidgets/bin"
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_wxConfig="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-  test -z "$ac_cv_path_wxConfig" && ac_cv_path_wxConfig="no"
-  ;;
-esac
-fi
-wxConfig=$ac_cv_path_wxConfig
-if test -n "$wxConfig"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $wxConfig" >&5
-$as_echo "$wxConfig" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  fi
-
-  if test "x$wxConfig" = "xno"; then
-    echo ""
-    echo "Error! wxWidgets version 2.8 or later is required but was not found (wx-config program not found)"
-    echo "       Use --with-wxWidgets=DIR to specify the wxWidgets directory tree"
-    echo "       Use --with-wxWidgets=no  to not use it"
-    echo "       Check the README or use configure --help for other libraries needed"
-    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-    echo ""
-    echo "       (suitable Debian/Ubuntu package: libwxgtk2.8-dev)"
-    exit -1
-  else
-    LIBS="$LIBS `wx-config --libs`"
-    INCLUDES="$INCLUDES `wx-config --cxxflags`"
-              fi
-
-
-$as_echo "#define HAVE_LIBWXWIDGETS 1" >>confdefs.h
-
-
-  # SA: the code below worked for me on Ubuntu and Macports... but it does not work e.g. on Fedora
-  #
-  #tmp="`wx-config --basename`-`wx-config --release`"
-  #AC_CHECK_LIB($tmp, wxFatalSignalHandler,
-  #  [AC_DEFINE([HAVE_LIBWXWIDGETS], [1], [wxWidgets library])], [
-  #    dnl SA: handling the multi-port wxWidgets installation case
-  #    tmp="`wx-config --basename --toolkit=base`-`wx-config --release`"
-  #    AC_CHECK_LIB($tmp, wxInteger_compare, [AC_DEFINE([HAVE_LIBWXWIDGETS], [1])], [
-  #      echo ""
-  #      echo "Error! wxWidgets version 2.8 or later is required but was not found"
-  #      echo "       Use --with-wxWidgets=DIR to specify the wxWidgets directory tree"
-  #      echo "       Use --with-wxWidgets=no  to not use it"
-  #      echo "       Check the README or use configure --help for other libraries needed"
-  #      echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-  #      exit -1
-  #    ])
-  #])
-fi
-
-
-
-# Check whether --with-Magick was given.
-if test "${with_Magick+set}" = set; then :
-  withval=$with_Magick; with_Magick="$withval"
-fi
-
-
-if test "x$with_Magick" != "xno"; then
-  if test "x$with_Magick" = "xyes"; then
-    # Extract the first word of "Magick++-config", so it can be a program name with args.
-set dummy Magick++-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_MagickConfig+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $MagickConfig in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_MagickConfig="$MagickConfig" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_MagickConfig="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-  test -z "$ac_cv_path_MagickConfig" && ac_cv_path_MagickConfig="no"
-  ;;
-esac
-fi
-MagickConfig=$ac_cv_path_MagickConfig
-if test -n "$MagickConfig"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MagickConfig" >&5
-$as_echo "$MagickConfig" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  else
-    # Extract the first word of "Magick++-config", so it can be a program name with args.
-set dummy Magick++-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_MagickConfig+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $MagickConfig in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_MagickConfig="$MagickConfig" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in "$with_Magick/bin"
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_MagickConfig="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-  test -z "$ac_cv_path_MagickConfig" && ac_cv_path_MagickConfig="no"
-  ;;
-esac
-fi
-MagickConfig=$ac_cv_path_MagickConfig
-if test -n "$MagickConfig"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MagickConfig" >&5
-$as_echo "$MagickConfig" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  fi
-
-  if test "x$MagickConfig" = "xno"; then
-    as_fn_error $? "ImageMagick is required but was not found (Magick++-config program not found)
-      Use --with-Magick=DIR to specify the ImageMagick directory tree
-      Use --with-Magick=no  to not use it
-
-      (suitable Debian/Ubuntu package: libmagick++-dev)
-    " "$LINENO" 5
-  else
-    LIBS="$LIBS `$MagickConfig --libs`"
-    INCLUDES="$INCLUDES `$MagickConfig --cppflags`"
-    LDFLAGS="$LDFLAGS `$MagickConfig --ldflags`"
-  fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GetMagickVersion in -lMagick++" >&5
-$as_echo_n "checking for GetMagickVersion in -lMagick++... " >&6; }
-if ${ac_cv_lib_Magickpp_GetMagickVersion+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lMagick++  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char GetMagickVersion ();
-int
-main ()
-{
-return GetMagickVersion ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_Magickpp_GetMagickVersion=yes
-else
-  ac_cv_lib_Magickpp_GetMagickVersion=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Magickpp_GetMagickVersion" >&5
-$as_echo "$ac_cv_lib_Magickpp_GetMagickVersion" >&6; }
-if test "x$ac_cv_lib_Magickpp_GetMagickVersion" = xyes; then :
-
-$as_echo "#define USE_MAGICK 1" >>confdefs.h
-
-else
-
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking if adding X library path helps" >&5
-$as_echo_n "checking if adding X library path helps... " >&6; }
-      { $as_echo "$as_me:${as_lineno-$LINENO}: result: ?" >&5
-$as_echo "?" >&6; }
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for X" >&5
-$as_echo_n "checking for X... " >&6; }
-
-
-# Check whether --with-x was given.
-if test "${with_x+set}" = set; then :
-  withval=$with_x;
-fi
-
-# $have_x is `yes', `no', `disabled', or empty when we do not yet know.
-if test "x$with_x" = xno; then
-  # The user explicitly disabled X.
-  have_x=disabled
-else
-  case $x_includes,$x_libraries in #(
-    *\'*) as_fn_error $? "cannot use X directory names containing '" "$LINENO" 5;; #(
-    *,NONE | NONE,*) if ${ac_cv_have_x+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  # One or both of the vars are not set, and there is no cached value.
-ac_x_includes=no ac_x_libraries=no
-rm -f -r conftest.dir
-if mkdir conftest.dir; then
-  cd conftest.dir
-  cat >Imakefile <<'_ACEOF'
-incroot:
-	@echo incroot='${INCROOT}'
-usrlibdir:
-	@echo usrlibdir='${USRLIBDIR}'
-libdir:
-	@echo libdir='${LIBDIR}'
-_ACEOF
-  if (export CC; ${XMKMF-xmkmf}) >/dev/null 2>/dev/null && test -f Makefile; then
-    # GNU make sometimes prints "make[1]: Entering ...", which would confuse us.
-    for ac_var in incroot usrlibdir libdir; do
-      eval "ac_im_$ac_var=\`\${MAKE-make} $ac_var 2>/dev/null | sed -n 's/^$ac_var=//p'\`"
-    done
-    # Open Windows xmkmf reportedly sets LIBDIR instead of USRLIBDIR.
-    for ac_extension in a so sl dylib la dll; do
-      if test ! -f "$ac_im_usrlibdir/libX11.$ac_extension" &&
-	 test -f "$ac_im_libdir/libX11.$ac_extension"; then
-	ac_im_usrlibdir=$ac_im_libdir; break
-      fi
-    done
-    # Screen out bogus values from the imake configuration.  They are
-    # bogus both because they are the default anyway, and because
-    # using them would break gcc on systems where it needs fixed includes.
-    case $ac_im_incroot in
-	/usr/include) ac_x_includes= ;;
-	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes=$ac_im_incroot;;
-    esac
-    case $ac_im_usrlibdir in
-	/usr/lib | /usr/lib64 | /lib | /lib64) ;;
-	*) test -d "$ac_im_usrlibdir" && ac_x_libraries=$ac_im_usrlibdir ;;
-    esac
-  fi
-  cd ..
-  rm -f -r conftest.dir
-fi
-
-# Standard set of common directories for X headers.
-# Check X11 before X11Rn because it is often a symlink to the current release.
-ac_x_header_dirs='
-/usr/X11/include
-/usr/X11R7/include
-/usr/X11R6/include
-/usr/X11R5/include
-/usr/X11R4/include
-
-/usr/include/X11
-/usr/include/X11R7
-/usr/include/X11R6
-/usr/include/X11R5
-/usr/include/X11R4
-
-/usr/local/X11/include
-/usr/local/X11R7/include
-/usr/local/X11R6/include
-/usr/local/X11R5/include
-/usr/local/X11R4/include
-
-/usr/local/include/X11
-/usr/local/include/X11R7
-/usr/local/include/X11R6
-/usr/local/include/X11R5
-/usr/local/include/X11R4
-
-/usr/X386/include
-/usr/x386/include
-/usr/XFree86/include/X11
-
-/usr/include
-/usr/local/include
-/usr/unsupported/include
-/usr/athena/include
-/usr/local/x11r5/include
-/usr/lpp/Xamples/include
-
-/usr/openwin/include
-/usr/openwin/share/include'
-
-if test "$ac_x_includes" = no; then
-  # Guess where to find include files, by looking for Xlib.h.
-  # First, try using that file with no special directory specified.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <X11/Xlib.h>
-_ACEOF
-if ac_fn_cxx_try_cpp "$LINENO"; then :
-  # We can compile using X headers with no special include directory.
-ac_x_includes=
-else
-  for ac_dir in $ac_x_header_dirs; do
-  if test -r "$ac_dir/X11/Xlib.h"; then
-    ac_x_includes=$ac_dir
-    break
-  fi
-done
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-fi # $ac_x_includes = no
-
-if test "$ac_x_libraries" = no; then
-  # Check for the libraries.
-  # See if we find them without any special options.
-  # Don't add to $LIBS permanently.
-  ac_save_LIBS=$LIBS
-  LIBS="-lX11 $LIBS"
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <X11/Xlib.h>
-int
-main ()
-{
-XrmInitialize ()
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  LIBS=$ac_save_LIBS
-# We can link X programs with no special library path.
-ac_x_libraries=
-else
-  LIBS=$ac_save_LIBS
-for ac_dir in `$as_echo "$ac_x_includes $ac_x_header_dirs" | sed s/include/lib/g`
-do
-  # Don't even attempt the hair of trying to link an X program!
-  for ac_extension in a so sl dylib la dll; do
-    if test -r "$ac_dir/libX11.$ac_extension"; then
-      ac_x_libraries=$ac_dir
-      break 2
-    fi
-  done
-done
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-fi # $ac_x_libraries = no
-
-case $ac_x_includes,$ac_x_libraries in #(
-  no,* | *,no | *\'*)
-    # Didn't find X, or a directory has "'" in its name.
-    ac_cv_have_x="have_x=no";; #(
-  *)
-    # Record where we found X for the cache.
-    ac_cv_have_x="have_x=yes\
-	ac_x_includes='$ac_x_includes'\
-	ac_x_libraries='$ac_x_libraries'"
-esac
-fi
-;; #(
-    *) have_x=yes;;
-  esac
-  eval "$ac_cv_have_x"
-fi # $with_x != no
-
-if test "$have_x" != yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $have_x" >&5
-$as_echo "$have_x" >&6; }
-  no_x=yes
-else
-  # If each of the values was on the command line, it overrides each guess.
-  test "x$x_includes" = xNONE && x_includes=$ac_x_includes
-  test "x$x_libraries" = xNONE && x_libraries=$ac_x_libraries
-  # Update the cache value to reflect the command line values.
-  ac_cv_have_x="have_x=yes\
-	ac_x_includes='$x_includes'\
-	ac_x_libraries='$x_libraries'"
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: libraries $x_libraries, headers $x_includes" >&5
-$as_echo "libraries $x_libraries, headers $x_includes" >&6; }
-fi
-
-      LDFLAGS="$LDFLAGS -L$x_libraries"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GetMagickReleaseDate in -lMagick++" >&5
-$as_echo_n "checking for GetMagickReleaseDate in -lMagick++... " >&6; }
-if ${ac_cv_lib_Magickpp_GetMagickReleaseDate+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lMagick++  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char GetMagickReleaseDate ();
-int
-main ()
-{
-return GetMagickReleaseDate ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_Magickpp_GetMagickReleaseDate=yes
-else
-  ac_cv_lib_Magickpp_GetMagickReleaseDate=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_Magickpp_GetMagickReleaseDate" >&5
-$as_echo "$ac_cv_lib_Magickpp_GetMagickReleaseDate" >&6; }
-if test "x$ac_cv_lib_Magickpp_GetMagickReleaseDate" = xyes; then :
-  $as_echo "#define USE_MAGICK 1" >>confdefs.h
-
-else
-
-        echo ""
-        echo "Error! ImageMagick version 5.5.7 or later is required but was not found"
-        echo "       Use --with-Magick=DIR to specify the ImageMagick directory tree"
-        echo "       Use --with-Magick=no  to not use it"
-        echo "       Check the README or use configure --help for other libraries needed"
-        echo "       (--with-xxxdir = mandatory, --with-xxx = optional (--with-xxx=no to disable))"
-        echo ""
-        echo "       (suitable Debian/Ubuntu package: libmagick-dev)"
-        exit -1
-
-fi
-
-
-
-fi
-
-fi
-
-
-
-# Check whether --with-netcdf was given.
-if test "${with_netcdf+set}" = set; then :
-  withval=$with_netcdf; with_netcdf="$withval"
-fi
-
-
-if test "x$with_netcdf" != "xno"; then
-
-  if test "x$with_netcdf" = "xyes"; then
-    # Extract the first word of "nc-config", so it can be a program name with args.
-set dummy nc-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_nc_config+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $nc_config in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_nc_config="$nc_config" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_nc_config="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-  test -z "$ac_cv_path_nc_config" && ac_cv_path_nc_config="no"
-  ;;
-esac
-fi
-nc_config=$ac_cv_path_nc_config
-if test -n "$nc_config"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $nc_config" >&5
-$as_echo "$nc_config" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  else
-    # Extract the first word of "nc-config", so it can be a program name with args.
-set dummy nc-config; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_nc_config+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $nc_config in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_nc_config="$nc_config" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in "$with_netcdf/bin"
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_nc_config="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-  test -z "$ac_cv_path_nc_config" && ac_cv_path_nc_config="no"
-  ;;
-esac
-fi
-nc_config=$ac_cv_path_nc_config
-if test -n "$nc_config"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $nc_config" >&5
-$as_echo "$nc_config" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  fi
-
-  if test "x$nc_config" != "xno"; then
-    LIBS="$LIBS `$nc_config --libs`"
-    INCLUDES="$INCLUDES `$nc_config --cflags`"
-    ncdfincdir="`$nc_config --prefix`/include"
-  else
-    if test "x$with_netcdf" != "xyes"; then
-	LIBS="$LIBS -L$with_netcdf/lib -lnetcdf"
-	ncdfincdir="$with_netcdf/include"
-    else
-	LIBS="$LIBS -L/usr/lib/netcdf-3 -lnetcdf"
-        ncdfincdir="/usr/include/netcdf-3"
-    fi
-    INCLUDES="$INCLUDES -I$ncdfincdir"
-  fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for nc_open in -lnetcdf" >&5
-$as_echo_n "checking for nc_open in -lnetcdf... " >&6; }
-if ${ac_cv_lib_netcdf_nc_open+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lnetcdf  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char nc_open ();
-int
-main ()
-{
-return nc_open ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_netcdf_nc_open=yes
-else
-  ac_cv_lib_netcdf_nc_open=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_netcdf_nc_open" >&5
-$as_echo "$ac_cv_lib_netcdf_nc_open" >&6; }
-if test "x$ac_cv_lib_netcdf_nc_open" = xyes; then :
-
-$as_echo "#define USE_NETCDF 1" >>confdefs.h
-
-else
-
-    echo ""
-    echo "Error! netCDF version 3.5.1 or later is required but was not found"
-    echo "       Use --with-netcdf=DIR to specify the netcdf directory tree"
-    echo "       Use --with-netcdf=no  to not use it"
-    echo "       Check the README or use configure --help for other libraries needed"
-    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-    echo ""
-    echo "       (suitable Debian/Ubuntu package: libnetcdf-dev)"
-    exit -1
-
-fi
-
-
-  for ac_header in "netcdfcpp.h"
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-else
-
-    for ac_header in "$ncdfincdir/netcdfcpp.h"
-do :
-  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
-ac_fn_cxx_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-else
-
-      echo ""
-      echo "Error! netCDF installation seems not to be usable"
-      echo "       This suggests a conflicting netCDF-HDF4 installation, e.g."
-      echo "       - uninstalling HDF4 after installation of netCDF"
-      echo "       - installing netCDF before HDF4"
-      exit -1
-
-fi
-
-done
-
-
-fi
-
-done
-
-
-fi
-
-
-
-# Check whether --with-hdf was given.
-if test "${with_hdf+set}" = set; then :
-  withval=$with_hdf; with_hdf="$withval"
-fi
-
-
-if test "x$with_hdf" != "xno"; then
-
-  # on Debian the no-netcdf flavour of HDF4 libraries has an alt-suffixed naming
-  _LIBS=$LIBS
-  _INCLUDES=$INCLUDES
-  for sfx in "dfalt" "df"; do
-
-    if test "x$with_hdf" != "xyes"; then
-      LIBS="$_LIBS -L$with_hdf/lib -L$with_hdf/lib/hdf -lmfh$sfx -l$sfx -ljpeg -lz"
-      INCLUDES="$_INCLUDES -I$with_hdf/include -I$with_hdf/include/hdf"
-    else
-      LIBS="$_LIBS -L/usr/lib/hdf -lmfh$sfx -l$sfx -ljpeg -lz"
-      INCLUDES="$_INCLUDES -I/usr/include/hdf"
-    fi
-
-    as_ac_Lib=`$as_echo "ac_cv_lib_$sfx''_Hopen" | $as_tr_sh`
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Hopen in -l$sfx" >&5
-$as_echo_n "checking for Hopen in -l$sfx... " >&6; }
-if eval \${$as_ac_Lib+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-l$sfx  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char Hopen ();
-int
-main ()
-{
-return Hopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  eval "$as_ac_Lib=yes"
-else
-  eval "$as_ac_Lib=no"
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-eval ac_res=\$$as_ac_Lib
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
-
-$as_echo "#define USE_HDF 1" >>confdefs.h
-
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if linking with SZIP helps" >&5
-$as_echo_n "checking if linking with SZIP helps... " >&6; }
-      echo ""
-      as_ac_Lib=`$as_echo "ac_cv_lib_$sfx''_Hclose" | $as_tr_sh`
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Hclose in -l$sfx" >&5
-$as_echo_n "checking for Hclose in -l$sfx... " >&6; }
-if eval \${$as_ac_Lib+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-l$sfx -lsz $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char Hclose ();
-int
-main ()
-{
-return Hclose ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  eval "$as_ac_Lib=yes"
-else
-  eval "$as_ac_Lib=no"
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-eval ac_res=\$$as_ac_Lib
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
-
-        LIBS="$LIBS -lsz"
-
-$as_echo "#define USE_HDF 1" >>confdefs.h
-
-
-else
-
-        if test $sfx != "dfalt"; then
-          echo ""
-          echo "Error! HDF4 libraries were not found"
-          echo "       Use --with-hdf=DIR to specify the HDF directory tree"
-          echo "       Use --with-hdf=no  to not use it"
-          echo "       Check the README or use configure --help for other libraries needed"
-          echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-          echo ""
-          echo "       (suitable Debian/Ubuntu package: libhdf4-alt-dev)"
-          exit -1
-        else
-          continue # switchng to non-alt-suffixed naming
-        fi
-
-fi
-
-
-fi
-
-
-    as_ac_Lib=`$as_echo "ac_cv_lib_mfh$sfx''_SDstart" | $as_tr_sh`
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for SDstart in -lmfh$sfx" >&5
-$as_echo_n "checking for SDstart in -lmfh$sfx... " >&6; }
-if eval \${$as_ac_Lib+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lmfh$sfx  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char SDstart ();
-int
-main ()
-{
-return SDstart ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  eval "$as_ac_Lib=yes"
-else
-  eval "$as_ac_Lib=no"
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-eval ac_res=\$$as_ac_Lib
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
-
-$as_echo "#define USE_HDF 1" >>confdefs.h
-
-else
-
-      echo ""
-      echo "Error! HDF4 libraries were not found"
-      echo "       Use --with-hdf=DIR to specify the HDF directory tree"
-      echo "       Use --with-hdf=no  to not use it"
-      echo "       Check the README or use configure --help for other libraries needed"
-      echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-      echo ""
-      echo "       (suitable Debian/Ubuntu package: libhdf4-alt-dev)"
-      exit -1
-
-fi
-
-
-    # checking if HDF4 was compiled with the '--disable-netcdf' option
-    if test "x$with_netcdf" != "xno"; then
-      as_ac_Lib=`$as_echo "ac_cv_lib_mfh$sfx''_sd_nccreate" | $as_tr_sh`
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sd_nccreate in -lmfh$sfx" >&5
-$as_echo_n "checking for sd_nccreate in -lmfh$sfx... " >&6; }
-if eval \${$as_ac_Lib+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lmfh$sfx  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char sd_nccreate ();
-int
-main ()
-{
-return sd_nccreate ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  eval "$as_ac_Lib=yes"
-else
-  eval "$as_ac_Lib=no"
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-eval ac_res=\$$as_ac_Lib
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
-  cat >>confdefs.h <<_ACEOF
-#define `$as_echo "HAVE_LIBmfh$sfx" | $as_tr_cpp` 1
-_ACEOF
-
-  LIBS="-lmfh$sfx $LIBS"
-
-else
-
-        echo ""
-        echo "Error! HDF4 needs to be configured with the --disable-netcdf option"
-        echo "       in order to be used with the original netCDF library"
-        echo "       (-alt suffixed HDF4 packages in case of Debian)"
-        echo "       Check the INSTALL file of the HDF4 package for details"
-        echo ""
-        echo "       (suitable Debian/Ubuntu package: libhdf4-alt-dev)"
-        echo "                                                ^^^"
-        exit -1
-
-fi
-
-    fi
-
-    # all went OK with the alt-suffixed naming -> skipping tests for the non-alt-suffixed naming
-    if test $sfx == "dfalt"; then break; fi
-
-  done
-fi
-
-
-
-# Check whether --with-hdf5 was given.
-if test "${with_hdf5+set}" = set; then :
-  withval=$with_hdf5; with_hdf5="$withval"
-fi
-
-
-if test "x$with_hdf5" != "xno"; then
-  if test "x$with_hdf5" != "xyes"; then
-    LIBS="$LIBS -L$with_hdf5/lib -L$with_hdf5/lib/hdf -L$with_hdf5/lib/hdf5 -lhdf5"
-    INCLUDES="$INCLUDES -I$with_hdf5/include -I$with_hdf5/include/hdf -I$with_hdf5/include/hdf5"
-  else
-    INCLUDES="$INCLUDES -I/usr/include/hdf -I/usr/include/hdf5"
-    LIBS="$LIBS -L/usr/lib/hdf -L/usr/lib/hdf5 -lhdf5"
-  fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for H5Fopen in -lhdf5" >&5
-$as_echo_n "checking for H5Fopen in -lhdf5... " >&6; }
-if ${ac_cv_lib_hdf5_H5Fopen+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lhdf5  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char H5Fopen ();
-int
-main ()
-{
-return H5Fopen ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_hdf5_H5Fopen=yes
-else
-  ac_cv_lib_hdf5_H5Fopen=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_hdf5_H5Fopen" >&5
-$as_echo "$ac_cv_lib_hdf5_H5Fopen" >&6; }
-if test "x$ac_cv_lib_hdf5_H5Fopen" = xyes; then :
-
-$as_echo "#define USE_HDF5 1" >>confdefs.h
-
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if linking with SZIP helps" >&5
-$as_echo_n "checking if linking with SZIP helps... " >&6; }
-    echo ""
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for H5Fclose in -lhdf5" >&5
-$as_echo_n "checking for H5Fclose in -lhdf5... " >&6; }
-if ${ac_cv_lib_hdf5_H5Fclose+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lhdf5 -lsz $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char H5Fclose ();
-int
-main ()
-{
-return H5Fclose ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_hdf5_H5Fclose=yes
-else
-  ac_cv_lib_hdf5_H5Fclose=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_hdf5_H5Fclose" >&5
-$as_echo "$ac_cv_lib_hdf5_H5Fclose" >&6; }
-if test "x$ac_cv_lib_hdf5_H5Fclose" = xyes; then :
-
-      LIBS="$LIBS -lsz"
-
-$as_echo "#define USE_HDF5 1" >>confdefs.h
-
-
-else
-
-    echo ""
-    echo "Error! HDF version 5 is required but was not found"
-    echo "       Use --with-hdf5=DIR to specify the HDF5 directory tree"
-    echo "       Use --with-hdf5=no  to not use it"
-    echo "       Check the README or use configure --help for other libraries needed"
-    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-    echo ""
-    echo "       (suitable Debian/Ubuntu package: libhdf5-serial-dev)"
-    exit -1
-
-fi
-
-fi
-
-fi
-
-
-if test "x$with_fftw" = "xauto"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fftw_malloc in -lfftw3" >&5
-$as_echo_n "checking for fftw_malloc in -lfftw3... " >&6; }
-if ${ac_cv_lib_fftw3_fftw_malloc+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lfftw3  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char fftw_malloc ();
-int
-main ()
-{
-return fftw_malloc ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_fftw3_fftw_malloc=yes
-else
-  ac_cv_lib_fftw3_fftw_malloc=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_fftw3_fftw_malloc" >&5
-$as_echo "$ac_cv_lib_fftw3_fftw_malloc" >&6; }
-if test "x$ac_cv_lib_fftw3_fftw_malloc" = xyes; then :
-
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fftwf_malloc in -lfftw3f" >&5
-$as_echo_n "checking for fftwf_malloc in -lfftw3f... " >&6; }
-if ${ac_cv_lib_fftw3f_fftwf_malloc+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lfftw3f  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char fftwf_malloc ();
-int
-main ()
-{
-return fftwf_malloc ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_fftw3f_fftwf_malloc=yes
-else
-  ac_cv_lib_fftw3f_fftwf_malloc=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_fftw3f_fftwf_malloc" >&5
-$as_echo "$ac_cv_lib_fftw3f_fftwf_malloc" >&6; }
-if test "x$ac_cv_lib_fftw3f_fftwf_malloc" = xyes; then :
-  with_fftw=yes
-else
-  with_fftw=no
-fi
-
-
-else
-  with_fftw=no
-fi
-
-fi
-
-
-# Check whether --with-fftw was given.
-if test "${with_fftw+set}" = set; then :
-  withval=$with_fftw; with_fftw="$withval"
-fi
-
-
-if test "x$with_fftw" != "xno"; then
-  if test "x$with_fftw" != "xyes"; then
-    LIBS="$LIBS -L$with_fftw/lib -lfftw3"
-    INCLUDES="$INCLUDES -I$with_fftw/include"
-  else
-    INCLUDES="$INCLUDES -I/usr/include"
-    LIBS="$LIBS -lfftw3"
-  fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fftw_malloc in -lfftw3" >&5
-$as_echo_n "checking for fftw_malloc in -lfftw3... " >&6; }
-if ${ac_cv_lib_fftw3_fftw_malloc+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lfftw3  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char fftw_malloc ();
-int
-main ()
-{
-return fftw_malloc ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_fftw3_fftw_malloc=yes
-else
-  ac_cv_lib_fftw3_fftw_malloc=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_fftw3_fftw_malloc" >&5
-$as_echo "$ac_cv_lib_fftw3_fftw_malloc" >&6; }
-if test "x$ac_cv_lib_fftw3_fftw_malloc" = xyes; then :
-
-$as_echo "#define USE_FFTW 1" >>confdefs.h
-
-else
-
-    echo ""
-    echo "Error! FFTW3 version 3 is required but was not found"
-    echo "       Use --with-fftw=DIR to specify the FFTW directory tree"
-    echo "       Use --with-fftw=no  to not use it"
-    echo "       Check the README or use configure --help for other libraries needed"
-    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-    echo ""
-    echo "       (suitable Debian/Ubuntu package: libfftw3-dev)"
-    exit -1
-
-fi
-
-fi
-
-if test "x$with_fftw" != "xno"; then
-  if test "x$with_fftw" != "xyes"; then
-    LIBS="$LIBS -L$with_fftw/lib -lfftw3f"
-    INCLUDES="$INCLUDES -I$with_fftw/include"
-  else
-    INCLUDES="$INCLUDES -I/usr/include"
-    LIBS="$LIBS -lfftw3f"
-  fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fftwf_malloc in -lfftw3f" >&5
-$as_echo_n "checking for fftwf_malloc in -lfftw3f... " >&6; }
-if ${ac_cv_lib_fftw3f_fftwf_malloc+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lfftw3f  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char fftwf_malloc ();
-int
-main ()
-{
-return fftwf_malloc ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_fftw3f_fftwf_malloc=yes
-else
-  ac_cv_lib_fftw3f_fftwf_malloc=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_fftw3f_fftwf_malloc" >&5
-$as_echo "$ac_cv_lib_fftw3f_fftwf_malloc" >&6; }
-if test "x$ac_cv_lib_fftw3f_fftwf_malloc" = xyes; then :
-
-$as_echo "#define USE_FFTW 1" >>confdefs.h
-
-else
-
-    echo ""
-    echo "Error! FFTW3F version 3 is required but was not found"
-    echo "       Use --with-fftw=DIR to specify the FFTW directory tree"
-    echo "       Use --with-fftw=no  to not use it"
-    echo "       Check the README or use configure --help for other libraries needed"
-    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-    exit -1
-
-fi
-
-fi
-
-
-
-# Check whether --with-libproj4 was given.
-if test "${with_libproj4+set}" = set; then :
-  withval=$with_libproj4; with_libproj4="$withval"
-fi
-
-
-if test "x$with_libproj4" != "xno"; then
-  if test "x$with_libproj4" != "xyes"; then
-    LIBS="$LIBS -L$with_libproj4/lib -lproj4"
-    INCLUDES="$INCLUDES -I$with_libproj4/include"
-  else
-    INCLUDES="$INCLUDES -I/usr/include"
-    LIBS="$LIBS -lproj4"
-  fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for proj_init in -lproj4" >&5
-$as_echo_n "checking for proj_init in -lproj4... " >&6; }
-if ${ac_cv_lib_proj4_proj_init+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lproj4  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char proj_init ();
-int
-main ()
-{
-return proj_init ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_proj4_proj_init=yes
-else
-  ac_cv_lib_proj4_proj_init=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_proj4_proj_init" >&5
-$as_echo "$ac_cv_lib_proj4_proj_init" >&6; }
-if test "x$ac_cv_lib_proj4_proj_init" = xyes; then :
-
-$as_echo "#define USE_LIBPROJ4 1" >>confdefs.h
-
-fi
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for proj_init in -lproj4" >&5
-$as_echo_n "checking for proj_init in -lproj4... " >&6; }
-if ${ac_cv_lib_proj4_proj_init+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lproj4  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char proj_init ();
-int
-main ()
-{
-return proj_init ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_proj4_proj_init=yes
-else
-  ac_cv_lib_proj4_proj_init=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_proj4_proj_init" >&5
-$as_echo "$ac_cv_lib_proj4_proj_init" >&6; }
-if test "x$ac_cv_lib_proj4_proj_init" = xyes; then :
-
-$as_echo "#define USE_LIBPROJ4_NEW 1" >>confdefs.h
-
-else
-
-
-     { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pj_init in -lproj4" >&5
-$as_echo_n "checking for pj_init in -lproj4... " >&6; }
-if ${ac_cv_lib_proj4_pj_init+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lproj4  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char pj_init ();
-int
-main ()
-{
-return pj_init ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_proj4_pj_init=yes
-else
-  ac_cv_lib_proj4_pj_init=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_proj4_pj_init" >&5
-$as_echo "$ac_cv_lib_proj4_pj_init" >&6; }
-if test "x$ac_cv_lib_proj4_pj_init" = xyes; then :
-
-$as_echo "#define USE_LIBPROJ4 1" >>confdefs.h
-
-else
-
-       echo ""
-       echo "Error! LIBPROJ4 is required but was not found"
-       echo "       Use --with-libproj4=DIR to specify the LIBPROJ4 directory tree"
-       echo "       Use --with-libproj4=no  to not use it"
-       echo "       Check the README or use configure --help for other libraries needed"
-       echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-       exit -1
-
-fi
-
-
-fi
-
-fi
-
-
-
-# Check whether --with-mpich was given.
-if test "${with_mpich+set}" = set; then :
-  withval=$with_mpich; with_mpich="$withval"
-fi
-
-
-if test "x$with_mpich" != "xno"; then
-  if test "x$with_mpich" != "xyes"; then
-    LIBS="$LIBS -L$with_mpich/lib -lmpich"
-    INCLUDES="$INCLUDES -I$with_mpich/include"
-  else
-    INCLUDES="$INCLUDES -I/usr/include"
-    LIBS="$LIBS -lmpich"
-  fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for MPI_Init in -lmpich" >&5
-$as_echo_n "checking for MPI_Init in -lmpich... " >&6; }
-if ${ac_cv_lib_mpich_MPI_Init+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lmpich  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char MPI_Init ();
-int
-main ()
-{
-return MPI_Init ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_mpich_MPI_Init=yes
-else
-  ac_cv_lib_mpich_MPI_Init=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_mpich_MPI_Init" >&5
-$as_echo "$ac_cv_lib_mpich_MPI_Init" >&6; }
-if test "x$ac_cv_lib_mpich_MPI_Init" = xyes; then :
-
-$as_echo "#define USE_MPI 1" >>confdefs.h
-
-else
-
-    echo ""
-    echo "Error! MPICH is required but was not found"
-    echo "       Use --with-mpich=DIR to specify the MPICH directory tree"
-    echo "       Use --with-mpich=no  to not use it"
-    echo "       Check the README or use configure --help for other libraries needed"
-    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-    exit -1
-
-fi
-
-fi
-
-
-
-# Check whether --with-python was given.
-if test "${with_python+set}" = set; then :
-  withval=$with_python; with_python="$withval"
-fi
-
-
-if test "x$with_python" != "xno"; then
-
-
-
-
-        # Find any Python interpreter.
-    if test -z "$PYTHON"; then
-      for ac_prog in python python2 python3 python3.2 python3.1 python3.0 python2.7 python2.6 python2.5 python2.4 python2.3 python2.2 python2.1 python2.0
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
-$as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_path_PYTHON+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  case $PYTHON in
-  [\\/]* | ?:[\\/]*)
-  ac_cv_path_PYTHON="$PYTHON" # Let the user override the test with a path.
-  ;;
-  *)
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_path_PYTHON="$as_dir/$ac_word$ac_exec_ext"
-    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-  done
-IFS=$as_save_IFS
-
-  ;;
-esac
-fi
-PYTHON=$ac_cv_path_PYTHON
-if test -n "$PYTHON"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PYTHON" >&5
-$as_echo "$PYTHON" >&6; }
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-
-
-  test -n "$PYTHON" && break
-done
-test -n "$PYTHON" || PYTHON=":"
-
-    fi
-    am_display_PYTHON=python
-
-
-  if test "$PYTHON" = :; then
-      as_fn_error $? "no suitable Python interpreter found" "$LINENO" 5
-  else
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $am_display_PYTHON version" >&5
-$as_echo_n "checking for $am_display_PYTHON version... " >&6; }
-if ${am_cv_python_version+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  am_cv_python_version=`$PYTHON -c "import sys; sys.stdout.write(sys.version[:3])"`
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_python_version" >&5
-$as_echo "$am_cv_python_version" >&6; }
-  PYTHON_VERSION=$am_cv_python_version
-
-
-
-  PYTHON_PREFIX='${prefix}'
-
-  PYTHON_EXEC_PREFIX='${exec_prefix}'
-
-
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $am_display_PYTHON platform" >&5
-$as_echo_n "checking for $am_display_PYTHON platform... " >&6; }
-if ${am_cv_python_platform+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  am_cv_python_platform=`$PYTHON -c "import sys; sys.stdout.write(sys.platform)"`
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_python_platform" >&5
-$as_echo "$am_cv_python_platform" >&6; }
-  PYTHON_PLATFORM=$am_cv_python_platform
-
-
-
-
-                { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $am_display_PYTHON script directory" >&5
-$as_echo_n "checking for $am_display_PYTHON script directory... " >&6; }
-if ${am_cv_python_pythondir+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test "x$prefix" = xNONE
-     then
-       am_py_prefix=$ac_default_prefix
-     else
-       am_py_prefix=$prefix
-     fi
-     am_cv_python_pythondir=`$PYTHON -c "import sys; from distutils import sysconfig; sys.stdout.write(sysconfig.get_python_lib(0,0,prefix='$am_py_prefix'))" 2>/dev/null ||
-     echo "$PYTHON_PREFIX/lib/python$PYTHON_VERSION/site-packages"`
-     case $am_cv_python_pythondir in
-     $am_py_prefix*)
-       am__strip_prefix=`echo "$am_py_prefix" | sed 's|.|.|g'`
-       am_cv_python_pythondir=`echo "$am_cv_python_pythondir" | sed "s,^$am__strip_prefix,$PYTHON_PREFIX,"`
-       ;;
-     *)
-       case $am_py_prefix in
-         /usr|/System*) ;;
-         *)
-	  am_cv_python_pythondir=$PYTHON_PREFIX/lib/python$PYTHON_VERSION/site-packages
-	  ;;
-       esac
-       ;;
-     esac
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_python_pythondir" >&5
-$as_echo "$am_cv_python_pythondir" >&6; }
-  pythondir=$am_cv_python_pythondir
-
-
-
-  pkgpythondir=\${pythondir}/$PACKAGE
-
-
-            { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $am_display_PYTHON extension module directory" >&5
-$as_echo_n "checking for $am_display_PYTHON extension module directory... " >&6; }
-if ${am_cv_python_pyexecdir+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  if test "x$exec_prefix" = xNONE
-     then
-       am_py_exec_prefix=$am_py_prefix
-     else
-       am_py_exec_prefix=$exec_prefix
-     fi
-     am_cv_python_pyexecdir=`$PYTHON -c "import sys; from distutils import sysconfig; sys.stdout.write(sysconfig.get_python_lib(1,0,prefix='$am_py_exec_prefix'))" 2>/dev/null ||
-     echo "$PYTHON_EXEC_PREFIX/lib/python$PYTHON_VERSION/site-packages"`
-     case $am_cv_python_pyexecdir in
-     $am_py_exec_prefix*)
-       am__strip_prefix=`echo "$am_py_exec_prefix" | sed 's|.|.|g'`
-       am_cv_python_pyexecdir=`echo "$am_cv_python_pyexecdir" | sed "s,^$am__strip_prefix,$PYTHON_EXEC_PREFIX,"`
-       ;;
-     *)
-       case $am_py_exec_prefix in
-         /usr|/System*) ;;
-         *)
-	   am_cv_python_pyexecdir=$PYTHON_EXEC_PREFIX/lib/python$PYTHON_VERSION/site-packages
-	   ;;
-       esac
-       ;;
-     esac
-
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_python_pyexecdir" >&5
-$as_echo "$am_cv_python_pyexecdir" >&6; }
-  pyexecdir=$am_cv_python_pyexecdir
-
-
-
-  pkgpyexecdir=\${pyexecdir}/$PACKAGE
-
-
-
-  fi
-
-
-  # Check whether --enable-python_version was given.
-if test "${enable_python_version+set}" = set; then :
-  enableval=$enable_python_version;  PYTHON_VERSION="$enableval"
-
-fi
-
-
-  if test "x$PYTHON_VERSION" = "x"; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for Python version" >&5
-$as_echo_n "checking for Python version... " >&6; }
-    queryfile=$ac_confdir/query_version.py
-    echo "# tmp file auto (re)generated by GDL configure. Please delete" > $queryfile
-    echo import sys >> $queryfile
-    echo print \'%s.%s\' % sys.version_info\[0:2\] >> $queryfile
-    PYTHON_VERSION=`python $queryfile`
-    rm $queryfile
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $PYTHON_VERSION" >&5
-$as_echo "$PYTHON_VERSION" >&6; }
-  fi
-
-  if test "x$with_python" != "xyes"; then
-    LIBS="$LIBS -L$with_python/lib"
-    LIBS="$LIBS -L$with_python/lib/python$PYTHON_VERSION/config -lpython$PYTHON_VERSION"
-    PYTHON_INCLUDES="$with_python/include/python$PYTHON_VERSION"
-  else
-    LIBS="$LIBS -lpython$PYTHON_VERSION"
-    PYTHON_INCLUDES="/usr/include/python$PYTHON_VERSION"
-  fi
-
-  as_ac_Lib=`$as_echo "ac_cv_lib_python$PYTHON_VERSION''_Py_Initialize" | $as_tr_sh`
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for Py_Initialize in -lpython$PYTHON_VERSION" >&5
-$as_echo_n "checking for Py_Initialize in -lpython$PYTHON_VERSION... " >&6; }
-if eval \${$as_ac_Lib+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lpython$PYTHON_VERSION  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char Py_Initialize ();
-int
-main ()
-{
-return Py_Initialize ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  eval "$as_ac_Lib=yes"
-else
-  eval "$as_ac_Lib=no"
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-eval ac_res=\$$as_ac_Lib
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
-
-$as_echo "#define USE_PYTHON 1" >>confdefs.h
-
-else
-
-    echo ""
-    echo "Error! Python version $PYTHON_VERSION is required but was not found"
-    echo "       Use --with-python=DIR to specify the python directory tree"
-    echo "       Use --with-python=no  to not use it"
-    echo ""
-    echo "       (suitable Debian/Ubuntu package: python$PYTHON_VERSION-dev)"
-    exit -1
-
-fi
-
-
-  as_ac_Header=`$as_echo "ac_cv_header_$PYTHON_INCLUDES/Python.h" | $as_tr_sh`
-ac_fn_cxx_check_header_mongrel "$LINENO" "$PYTHON_INCLUDES/Python.h" "$as_ac_Header" "$ac_includes_default"
-if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
-
-else
-
-    echo ""
-    echo "Error! Python header file not found (missing '-devel' package?)"
-    echo "  Use --with-python=no to disable Python support"
-    exit -1
-
-fi
-
-
-
-  OLDCPPFLAGS=$CPPFLAGS
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for Numpy include directory" >&5
-$as_echo_n "checking for Numpy include directory... " >&6; }
-  pinc=`echo "import numpy; print numpy.get_include()" | $PYTHON - 2>/dev/null`
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: ${pinc:-unknown}" >&5
-$as_echo "${pinc:-unknown}" >&6; }
-  test -n "$pinc" && PYTHON_INCLUDES="$PYTHON_INCLUDES -I$pinc"
-  CPPFLAGS="$CPPFLAGS -I$PYTHON_INCLUDES"
-  ac_fn_cxx_check_header_compile "$LINENO" "numpy/arrayobject.h" "ac_cv_header_numpy_arrayobject_h" "#include <Python.h>
-"
-if test "x$ac_cv_header_numpy_arrayobject_h" = xyes; then :
-
-else
-
-    echo ""
-    echo "Error! Python numpy package was not found"
-    echo "  Use --with-python=no to disable Python support"
-    echo ""
-    echo "  (suitable Debian/Ubuntu package: python-numpy)"
-    exit -1
-
-fi
-
-
-  CPPFLAGS=$OLDCPPFLAGS
-  unset OLDCPPFLAGS
-  INCLUDES="$INCLUDES -I$PYTHON_INCLUDES"
-fi
-
-
-
-# Check whether --with-udunits was given.
-if test "${with_udunits+set}" = set; then :
-  withval=$with_udunits; with_udunits="$withval"
-fi
-
-
-if test "x$with_udunits" != "xno"; then
-  if test "x$with_udunits" != "xyes"; then
-    LIBS="$LIBS -L$with_udunits/lib -ludunits2"
-    INCLUDES="$INCLUDES -I$with_udunits/include"
-  else
-    INCLUDES="$INCLUDES -I/usr/include"
-    LIBS="$LIBS -ludunits2"
-  fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ut_get_unit_by_name in -ludunits2" >&5
-$as_echo_n "checking for ut_get_unit_by_name in -ludunits2... " >&6; }
-if ${ac_cv_lib_udunits2_ut_get_unit_by_name+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ludunits2  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char ut_get_unit_by_name ();
-int
-main ()
-{
-return ut_get_unit_by_name ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_udunits2_ut_get_unit_by_name=yes
-else
-  ac_cv_lib_udunits2_ut_get_unit_by_name=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_udunits2_ut_get_unit_by_name" >&5
-$as_echo "$ac_cv_lib_udunits2_ut_get_unit_by_name" >&6; }
-if test "x$ac_cv_lib_udunits2_ut_get_unit_by_name" = xyes; then :
-
-$as_echo "#define USE_UDUNITS 1" >>confdefs.h
-
-else
-
-    echo ""
-    echo "Error! UDUNITS-2 is required but was not found"
-    echo "       Use --with-udunits=DIR to specify the UDUNITS-2 directory tree"
-    echo "       Use --with-udunits=no  to not use it"
-    echo "       Check the README or use configure --help for other libraries needed"
-    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-    echo ""
-    echo "       (suitable Debian/Ubuntu package: libudunits2-dev)"
-    exit -1
-
-fi
-
-  for ac_header in udunits2/udunits2.h
-do :
-  ac_fn_cxx_check_header_mongrel "$LINENO" "udunits2/udunits2.h" "ac_cv_header_udunits2_udunits2_h" "$ac_includes_default"
-if test "x$ac_cv_header_udunits2_udunits2_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_UDUNITS2_UDUNITS2_H 1
-_ACEOF
-
-fi
-
-done
-
-fi
-
-
-
-# Check whether --with-grib was given.
-if test "${with_grib+set}" = set; then :
-  withval=$with_grib; with_grib="$withval"
-fi
-
-
-if test "x$with_grib" != "xno"; then
-  if test "x$with_grib" != "xyes"; then
-    LIBS="$LIBS -L$with_grib/lib -lgrib_api"
-    INCLUDES="$INCLUDES -I$with_grib/include"
-  else
-    INCLUDES="$INCLUDES -I/usr/include"
-    LIBS="$LIBS -lgrib_api"
-  fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for grib_handle_new_from_file in -lgrib_api" >&5
-$as_echo_n "checking for grib_handle_new_from_file in -lgrib_api... " >&6; }
-if ${ac_cv_lib_grib_api_grib_handle_new_from_file+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lgrib_api  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char grib_handle_new_from_file ();
-int
-main ()
-{
-return grib_handle_new_from_file ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_grib_api_grib_handle_new_from_file=yes
-else
-  ac_cv_lib_grib_api_grib_handle_new_from_file=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_grib_api_grib_handle_new_from_file" >&5
-$as_echo "$ac_cv_lib_grib_api_grib_handle_new_from_file" >&6; }
-if test "x$ac_cv_lib_grib_api_grib_handle_new_from_file" = xyes; then :
-
-
-$as_echo "#define USE_GRIB 1" >>confdefs.h
-
-
-else
-
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking if linking with Jasper helps" >&5
-$as_echo_n "checking if linking with Jasper helps... " >&6; }
-      echo ""
-      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for grib_handle_clone in -lgrib_api" >&5
-$as_echo_n "checking for grib_handle_clone in -lgrib_api... " >&6; }
-if ${ac_cv_lib_grib_api_grib_handle_clone+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lgrib_api -ljasper $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char grib_handle_clone ();
-int
-main ()
-{
-return grib_handle_clone ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_grib_api_grib_handle_clone=yes
-else
-  ac_cv_lib_grib_api_grib_handle_clone=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_grib_api_grib_handle_clone" >&5
-$as_echo "$ac_cv_lib_grib_api_grib_handle_clone" >&6; }
-if test "x$ac_cv_lib_grib_api_grib_handle_clone" = xyes; then :
-
-        LIBS="$LIBS -ljasper"
-
-$as_echo "#define USE_GRIB 1" >>confdefs.h
-
-
-else
-
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking if linking with Jasper and OpenJPEG helps" >&5
-$as_echo_n "checking if linking with Jasper and OpenJPEG helps... " >&6; }
-        echo ""
-        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for grib_handle_delete in -lgrib_api" >&5
-$as_echo_n "checking for grib_handle_delete in -lgrib_api... " >&6; }
-if ${ac_cv_lib_grib_api_grib_handle_delete+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lgrib_api -ljasper -lopenjpeg $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char grib_handle_delete ();
-int
-main ()
-{
-return grib_handle_delete ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_grib_api_grib_handle_delete=yes
-else
-  ac_cv_lib_grib_api_grib_handle_delete=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_grib_api_grib_handle_delete" >&5
-$as_echo "$ac_cv_lib_grib_api_grib_handle_delete" >&6; }
-if test "x$ac_cv_lib_grib_api_grib_handle_delete" = xyes; then :
-
-          LIBS="$LIBS -ljasper -lopenjpeg"
-
-$as_echo "#define USE_GRIB 1" >>confdefs.h
-
-
-else
-
-          { $as_echo "$as_me:${as_lineno-$LINENO}: checking if linking with Jasper and OpenJPEG and PNG helps" >&5
-$as_echo_n "checking if linking with Jasper and OpenJPEG and PNG helps... " >&6; }
-          echo ""
-          { $as_echo "$as_me:${as_lineno-$LINENO}: checking for grib_handle_new_from_message in -lgrib_api" >&5
-$as_echo_n "checking for grib_handle_new_from_message in -lgrib_api... " >&6; }
-if ${ac_cv_lib_grib_api_grib_handle_new_from_message+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lgrib_api -ljasper -lopenjpeg -lpng $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char grib_handle_new_from_message ();
-int
-main ()
-{
-return grib_handle_new_from_message ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_grib_api_grib_handle_new_from_message=yes
-else
-  ac_cv_lib_grib_api_grib_handle_new_from_message=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_grib_api_grib_handle_new_from_message" >&5
-$as_echo "$ac_cv_lib_grib_api_grib_handle_new_from_message" >&6; }
-if test "x$ac_cv_lib_grib_api_grib_handle_new_from_message" = xyes; then :
-
-            LIBS="$LIBS -ljasper -lopenjpeg -lpng"
-
-$as_echo "#define USE_GRIB 1" >>confdefs.h
-
-
-else
-
-            echo ""
-            echo "Error! GRIB is required but was not found"
-            echo "       Use --with-grib=DIR to specify the GRIB directory tree"
-            echo "       Use --with-grib=no  to not use it"
-            echo "       Check the README or use configure --help for other libraries needed"
-            echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-            echo ""
-            echo "       (suitable Debian/Ubuntu package: libgrib-api-dev)"
-            exit -1
-
-fi
-
-
-fi
-
-
-fi
-
-
-
-fi
-
-
-fi
-
-
-
-# Check whether --with-gshhs was given.
-if test "${with_gshhs+set}" = set; then :
-  withval=$with_gshhs; with_gshhs="$withval"
-fi
-
-
-if test "x$with_gshhs" != "xno"; then
-  if test "x$with_gshhs" != "xyes"; then
-    INCLUDES="$INCLUDES -I$with_gshhs/include"
-  fi
-
-  for ac_header in gshhs.h
-do :
-  ac_fn_cxx_check_header_mongrel "$LINENO" "gshhs.h" "ac_cv_header_gshhs_h" "$ac_includes_default"
-if test "x$ac_cv_header_gshhs_h" = xyes; then :
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_GSHHS_H 1
-_ACEOF
-
-
-$as_echo "#define USE_GSHHS 1" >>confdefs.h
-
-
-else
-
-    echo ""
-    echo "Error! GSHHS is required but gshhs.h was not found"
-    echo "       Use --with-gshhs=DIR to specify the GSHHS directory tree"
-    echo "       Use --with-gshhs=no  to not use it"
-    echo "       Check the README or use configure --help for other libraries needed"
-    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-    exit -1
-
-fi
-
-done
-
-
-fi
-
-
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for X" >&5
-$as_echo_n "checking for X... " >&6; }
-
-
-# Check whether --with-x was given.
-if test "${with_x+set}" = set; then :
-  withval=$with_x;
-fi
-
-# $have_x is `yes', `no', `disabled', or empty when we do not yet know.
-if test "x$with_x" = xno; then
-  # The user explicitly disabled X.
-  have_x=disabled
-else
-  case $x_includes,$x_libraries in #(
-    *\'*) as_fn_error $? "cannot use X directory names containing '" "$LINENO" 5;; #(
-    *,NONE | NONE,*) if ${ac_cv_have_x+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  # One or both of the vars are not set, and there is no cached value.
-ac_x_includes=no ac_x_libraries=no
-rm -f -r conftest.dir
-if mkdir conftest.dir; then
-  cd conftest.dir
-  cat >Imakefile <<'_ACEOF'
-incroot:
-	@echo incroot='${INCROOT}'
-usrlibdir:
-	@echo usrlibdir='${USRLIBDIR}'
-libdir:
-	@echo libdir='${LIBDIR}'
-_ACEOF
-  if (export CC; ${XMKMF-xmkmf}) >/dev/null 2>/dev/null && test -f Makefile; then
-    # GNU make sometimes prints "make[1]: Entering ...", which would confuse us.
-    for ac_var in incroot usrlibdir libdir; do
-      eval "ac_im_$ac_var=\`\${MAKE-make} $ac_var 2>/dev/null | sed -n 's/^$ac_var=//p'\`"
-    done
-    # Open Windows xmkmf reportedly sets LIBDIR instead of USRLIBDIR.
-    for ac_extension in a so sl dylib la dll; do
-      if test ! -f "$ac_im_usrlibdir/libX11.$ac_extension" &&
-	 test -f "$ac_im_libdir/libX11.$ac_extension"; then
-	ac_im_usrlibdir=$ac_im_libdir; break
-      fi
-    done
-    # Screen out bogus values from the imake configuration.  They are
-    # bogus both because they are the default anyway, and because
-    # using them would break gcc on systems where it needs fixed includes.
-    case $ac_im_incroot in
-	/usr/include) ac_x_includes= ;;
-	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes=$ac_im_incroot;;
-    esac
-    case $ac_im_usrlibdir in
-	/usr/lib | /usr/lib64 | /lib | /lib64) ;;
-	*) test -d "$ac_im_usrlibdir" && ac_x_libraries=$ac_im_usrlibdir ;;
-    esac
-  fi
-  cd ..
-  rm -f -r conftest.dir
-fi
-
-# Standard set of common directories for X headers.
-# Check X11 before X11Rn because it is often a symlink to the current release.
-ac_x_header_dirs='
-/usr/X11/include
-/usr/X11R7/include
-/usr/X11R6/include
-/usr/X11R5/include
-/usr/X11R4/include
-
-/usr/include/X11
-/usr/include/X11R7
-/usr/include/X11R6
-/usr/include/X11R5
-/usr/include/X11R4
-
-/usr/local/X11/include
-/usr/local/X11R7/include
-/usr/local/X11R6/include
-/usr/local/X11R5/include
-/usr/local/X11R4/include
-
-/usr/local/include/X11
-/usr/local/include/X11R7
-/usr/local/include/X11R6
-/usr/local/include/X11R5
-/usr/local/include/X11R4
-
-/usr/X386/include
-/usr/x386/include
-/usr/XFree86/include/X11
-
-/usr/include
-/usr/local/include
-/usr/unsupported/include
-/usr/athena/include
-/usr/local/x11r5/include
-/usr/lpp/Xamples/include
-
-/usr/openwin/include
-/usr/openwin/share/include'
-
-if test "$ac_x_includes" = no; then
-  # Guess where to find include files, by looking for Xlib.h.
-  # First, try using that file with no special directory specified.
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <X11/Xlib.h>
-_ACEOF
-if ac_fn_cxx_try_cpp "$LINENO"; then :
-  # We can compile using X headers with no special include directory.
-ac_x_includes=
-else
-  for ac_dir in $ac_x_header_dirs; do
-  if test -r "$ac_dir/X11/Xlib.h"; then
-    ac_x_includes=$ac_dir
-    break
-  fi
-done
-fi
-rm -f conftest.err conftest.i conftest.$ac_ext
-fi # $ac_x_includes = no
-
-if test "$ac_x_libraries" = no; then
-  # Check for the libraries.
-  # See if we find them without any special options.
-  # Don't add to $LIBS permanently.
-  ac_save_LIBS=$LIBS
-  LIBS="-lX11 $LIBS"
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-#include <X11/Xlib.h>
-int
-main ()
-{
-XrmInitialize ()
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  LIBS=$ac_save_LIBS
-# We can link X programs with no special library path.
-ac_x_libraries=
-else
-  LIBS=$ac_save_LIBS
-for ac_dir in `$as_echo "$ac_x_includes $ac_x_header_dirs" | sed s/include/lib/g`
-do
-  # Don't even attempt the hair of trying to link an X program!
-  for ac_extension in a so sl dylib la dll; do
-    if test -r "$ac_dir/libX11.$ac_extension"; then
-      ac_x_libraries=$ac_dir
-      break 2
-    fi
-  done
-done
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-fi # $ac_x_libraries = no
-
-case $ac_x_includes,$ac_x_libraries in #(
-  no,* | *,no | *\'*)
-    # Didn't find X, or a directory has "'" in its name.
-    ac_cv_have_x="have_x=no";; #(
-  *)
-    # Record where we found X for the cache.
-    ac_cv_have_x="have_x=yes\
-	ac_x_includes='$ac_x_includes'\
-	ac_x_libraries='$ac_x_libraries'"
-esac
-fi
-;; #(
-    *) have_x=yes;;
-  esac
-  eval "$ac_cv_have_x"
-fi # $with_x != no
-
-if test "$have_x" != yes; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $have_x" >&5
-$as_echo "$have_x" >&6; }
-  no_x=yes
-else
-  # If each of the values was on the command line, it overrides each guess.
-  test "x$x_includes" = xNONE && x_includes=$ac_x_includes
-  test "x$x_libraries" = xNONE && x_libraries=$ac_x_libraries
-  # Update the cache value to reflect the command line values.
-  ac_cv_have_x="have_x=yes\
-	ac_x_includes='$x_includes'\
-	ac_x_libraries='$x_libraries'"
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: libraries $x_libraries, headers $x_includes" >&5
-$as_echo "libraries $x_libraries, headers $x_includes" >&6; }
-fi
-
-if test "x$no_x" = "xyes"; then
-  echo ""
-  echo "Warning! X Window System not detected, building with Xlib calls disabled"
-  echo "         Use --x-includes=DIR and --x-libraries=DIR to pass any needed paths"
-  echo ""
-else
-
-$as_echo "#define HAVE_X 1" >>confdefs.h
-
-fi
-
-
-
-# Check whether --with-pslib was given.
-if test "${with_pslib+set}" = set; then :
-  withval=$with_pslib; with_pslib="$withval"
-fi
-
-
-if test "x$with_pslib" != "xno"; then
-  if test "x$with_pslib" != "xyes"; then
-    LIBS="$LIBS -L$with_pslib/lib -lps"
-    INCLUDES="$INCLUDES -I$with_pslib/include"
-  else
-    INCLUDES="$INCLUDES -I/usr/include"
-    LIBS="$LIBS -lps"
-  fi
-
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for PS_new in -lps" >&5
-$as_echo_n "checking for PS_new in -lps... " >&6; }
-if ${ac_cv_lib_ps_PS_new+:} false; then :
-  $as_echo_n "(cached) " >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lps  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char PS_new ();
-int
-main ()
-{
-return PS_new ();
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_cxx_try_link "$LINENO"; then :
-  ac_cv_lib_ps_PS_new=yes
-else
-  ac_cv_lib_ps_PS_new=no
-fi
-rm -f core conftest.err conftest.$ac_objext \
-    conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_ps_PS_new" >&5
-$as_echo "$ac_cv_lib_ps_PS_new" >&6; }
-if test "x$ac_cv_lib_ps_PS_new" = xyes; then :
-
-$as_echo "#define USE_PSLIB 1" >>confdefs.h
-
-else
-
-    echo ""
-    echo "Error! pslib is required but it was not found"
-    echo "       Use --with-pslib=DIR to specify the pslib directory tree"
-    echo "       Use --with-pslib=no  to not use it"
-    echo "       Check the README or use configure --help for other libraries needed"
-    echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
-    echo ""
-    echo "       (suitable Debian/Ubuntu package: pslib-dev)"
-    exit -1
-
-fi
-
-
-fi
-
-
-
-
-
-
-  prefix_NONE=
-  exec_prefix_NONE=
-  test "x$prefix" = xNONE && prefix_NONE=yes && prefix=$ac_default_prefix
-  test "x$exec_prefix" = xNONE && exec_prefix_NONE=yes && exec_prefix=$prefix
-  eval ac_define_dir="\"$exec_prefix\""
-  eval ac_define_dir="\"$ac_define_dir\""
-  EXEC_PREFIX="$ac_define_dir"
-
-
-cat >>confdefs.h <<_ACEOF
-#define EXEC_PREFIX "$ac_define_dir"
-_ACEOF
-
-  test "$prefix_NONE" && prefix=NONE
-  test "$exec_prefix_NONE" && exec_prefix=NONE
-
-#AC_DEFINE([EXEC_PREFIX],[\"`echo ${exec_prefix}`\"],[GDL installation directory])
-
-  prefix_NONE=
-  exec_prefix_NONE=
-  test "x$prefix" = xNONE && prefix_NONE=yes && prefix=$ac_default_prefix
-  test "x$exec_prefix" = xNONE && exec_prefix_NONE=yes && exec_prefix=$prefix
-  eval ac_define_dir="\"$datadir/$datasubdir\""
-  eval ac_define_dir="\"$ac_define_dir\""
-  GDLDATADIR="$ac_define_dir"
-
-
-cat >>confdefs.h <<_ACEOF
-#define GDLDATADIR "$ac_define_dir"
-_ACEOF
-
-  test "$prefix_NONE" && prefix=NONE
-  test "$exec_prefix_NONE" && exec_prefix=NONE
-
-
-
-DARWIN="no"
-case "${host}" in
-  *darwin*)
-    DARWIN="yes"
-esac
-
-case "${host}" in
-  powerpc-*-darwin* )
-        LDFLAGS="$LDFLAGS -bind_at_load"
-    ;;
-
-  powerpc*-*-linux* )
-    LDFLAGS="$LDFLAGS -rdynamic"
-    ;;
-
-  *linux*)
-                    LDFLAGS="$LDFLAGS -rdynamic -z muldefs"
-    ;;
-
-  *solaris* )
-    LIBS="$LIBS -lsocket -lnsl"
-    ;;
-
-  *cygwin* )
-    LIBS="$LIBS -lrpc"
-    ;;
-
-esac
-
-case "${host}" in
-
-  *darwin6*)
-
-$as_echo "#define OLD_DARWIN 1" >>confdefs.h
-
-    ;;
-  *darwin7*)
-
-$as_echo "#define OLD_DARWIN 1" >>confdefs.h
-
-    ;;
-  *darwin8.8*)
-        ;;
-  *darwin8.9*)
-        ;;
-  *darwin8.10*)
-        ;;
-  *darwin8.11*)
-        ;;
-  *darwin8.12*)
-        ;;
-  *darwin8.13*)
-        ;;
-  *darwin8.14*)
-        ;;
-  *darwin8.15*)
-        ;;
-  *darwin9*)
-        ;;
-  *darwin8*)
-
-$as_echo "#define OLD_DARWIN 1" >>confdefs.h
-
-    ;;
-esac
-
- if test "x$DARWIN" = "xyes"; then
-  DARWIN_TRUE=
-  DARWIN_FALSE='#'
-else
-  DARWIN_TRUE='#'
-  DARWIN_FALSE=
-fi
-
-
-
-EXT_LIBS="$EXT_LIBS $LIBS"
-EXT_INCLUDES="$EXT_INCLUDES $INCLUDES"
-
-
-
-
-
-
-case ${INSTALL} in
-  /* ) # Absolute
-     ;;
-  ?:* ) # Drive letter, considered as absolute.
-     ;;
-  *)
-     INSTALL=`pwd`/${INSTALL} ;;
-esac
-
-case "${host}" in
-
-                *-*-darwin* )
-        INSTALL_PROGRAM="cp -fp"
-        INSTALL_DATA="cp -fp"
-        ;;
-    *)
-        ;;
-esac
-
-
-
-
-
-
-ac_config_files="$ac_config_files Makefile src/Makefile src/antlr/Makefile src/pro/Makefile src/pro/dicom/Makefile testsuite/Makefile doc/Makefile"
-
-cat >confcache <<\_ACEOF
-# This file is a shell script that caches the results of configure
-# tests run on this system so they can be shared between configure
-# scripts and configure runs, see configure's option --config-cache.
-# It is not useful on other systems.  If it contains results you don't
-# want to keep, you may remove or edit it.
-#
-# config.status only pays attention to the cache file if you give it
-# the --recheck option to rerun configure.
-#
-# `ac_cv_env_foo' variables (set or unset) will be overridden when
-# loading this file, other *unset* `ac_cv_foo' will be assigned the
-# following values.
-
-_ACEOF
-
-# The following way of writing the cache mishandles newlines in values,
-# but we know of no workaround that is simple, portable, and efficient.
-# So, we kill variables containing newlines.
-# Ultrix sh set writes to stderr and can't be redirected directly,
-# and sets the high bit in the cache file unless we assign to the vars.
-(
-  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
-    eval ac_val=\$$ac_var
-    case $ac_val in #(
-    *${as_nl}*)
-      case $ac_var in #(
-      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
-$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
-      esac
-      case $ac_var in #(
-      _ | IFS | as_nl) ;; #(
-      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
-      *) { eval $ac_var=; unset $ac_var;} ;;
-      esac ;;
-    esac
-  done
-
-  (set) 2>&1 |
-    case $as_nl`(ac_space=' '; set) 2>&1` in #(
-    *${as_nl}ac_space=\ *)
-      # `set' does not quote correctly, so add quotes: double-quote
-      # substitution turns \\\\ into \\, and sed turns \\ into \.
-      sed -n \
-	"s/'/'\\\\''/g;
-	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
-      ;; #(
-    *)
-      # `set' quotes correctly as required by POSIX, so do not add quotes.
-      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
-      ;;
-    esac |
-    sort
-) |
-  sed '
-     /^ac_cv_env_/b end
-     t clear
-     :clear
-     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
-     t end
-     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
-     :end' >>confcache
-if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
-  if test -w "$cache_file"; then
-    if test "x$cache_file" != "x/dev/null"; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
-$as_echo "$as_me: updating cache $cache_file" >&6;}
-      if test ! -f "$cache_file" || test -h "$cache_file"; then
-	cat confcache >"$cache_file"
-      else
-        case $cache_file in #(
-        */* | ?:*)
-	  mv -f confcache "$cache_file"$$ &&
-	  mv -f "$cache_file"$$ "$cache_file" ;; #(
-        *)
-	  mv -f confcache "$cache_file" ;;
-	esac
-      fi
-    fi
-  else
-    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
-$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
-  fi
-fi
-rm -f confcache
-
-test "x$prefix" = xNONE && prefix=$ac_default_prefix
-# Let make expand exec_prefix.
-test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
-
-DEFS=-DHAVE_CONFIG_H
-
-ac_libobjs=
-ac_ltlibobjs=
-U=
-for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
-  # 1. Remove the extension, and $U if already installed.
-  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
-  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
-  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
-  #    will be set to the directory where LIBOBJS objects are built.
-  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
-  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
-done
-LIBOBJS=$ac_libobjs
-
-LTLIBOBJS=$ac_ltlibobjs
-
-
- if test -n "$EXEEXT"; then
-  am__EXEEXT_TRUE=
-  am__EXEEXT_FALSE='#'
-else
-  am__EXEEXT_TRUE='#'
-  am__EXEEXT_FALSE=
-fi
-
-if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
-  as_fn_error $? "conditional \"AMDEP\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
-fi
-if test -z "${am__fastdepCXX_TRUE}" && test -z "${am__fastdepCXX_FALSE}"; then
-  as_fn_error $? "conditional \"am__fastdepCXX\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
-fi
-if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
-  as_fn_error $? "conditional \"am__fastdepCC\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
-fi
-if test -z "${BUILDASLIBRARY_TRUE}" && test -z "${BUILDASLIBRARY_FALSE}"; then
-  as_fn_error $? "conditional \"BUILDASLIBRARY\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
-fi
-if test -z "${DARWIN_TRUE}" && test -z "${DARWIN_FALSE}"; then
-  as_fn_error $? "conditional \"DARWIN\" was never defined.
-Usually this means the macro was only invoked conditionally." "$LINENO" 5
-fi
-
-: "${CONFIG_STATUS=./config.status}"
-ac_write_fail=0
-ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files $CONFIG_STATUS"
-{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
-$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
-as_write_fail=0
-cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
-#! $SHELL
-# Generated by $as_me.
-# Run this file to recreate the current configuration.
-# Compiler output produced by configure, useful for debugging
-# configure, is in config.log if it exists.
-
-debug=false
-ac_cs_recheck=false
-ac_cs_silent=false
-
-SHELL=\${CONFIG_SHELL-$SHELL}
-export SHELL
-_ASEOF
-cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
-## -------------------- ##
-## M4sh Initialization. ##
-## -------------------- ##
-
-# Be more Bourne compatible
-DUALCASE=1; export DUALCASE # for MKS sh
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
-  emulate sh
-  NULLCMD=:
-  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in #(
-  *posix*) :
-    set -o posix ;; #(
-  *) :
-     ;;
-esac
-fi
-
-
-as_nl='
-'
-export as_nl
-# Printing a long string crashes Solaris 7 /usr/bin/printf.
-as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
-as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
-# Prefer a ksh shell builtin over an external printf program on Solaris,
-# but without wasting forks for bash or zsh.
-if test -z "$BASH_VERSION$ZSH_VERSION" \
-    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='print -r --'
-  as_echo_n='print -rn --'
-elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
-  as_echo='printf %s\n'
-  as_echo_n='printf %s'
-else
-  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
-    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
-    as_echo_n='/usr/ucb/echo -n'
-  else
-    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
-    as_echo_n_body='eval
-      arg=$1;
-      case $arg in #(
-      *"$as_nl"*)
-	expr "X$arg" : "X\\(.*\\)$as_nl";
-	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
-      esac;
-      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
-    '
-    export as_echo_n_body
-    as_echo_n='sh -c $as_echo_n_body as_echo'
-  fi
-  export as_echo_body
-  as_echo='sh -c $as_echo_body as_echo'
-fi
-
-# The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
-  PATH_SEPARATOR=:
-  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
-    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
-      PATH_SEPARATOR=';'
-  }
-fi
-
-
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-IFS=" ""	$as_nl"
-
-# Find who we are.  Look in the path if we contain no directory separator.
-as_myself=
-case $0 in #((
-  *[\\/]* ) as_myself=$0 ;;
-  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-  done
-IFS=$as_save_IFS
-
-     ;;
-esac
-# We did not find ourselves, most probably we were run as `sh COMMAND'
-# in which case we are not to be found in the path.
-if test "x$as_myself" = x; then
-  as_myself=$0
-fi
-if test ! -f "$as_myself"; then
-  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  exit 1
-fi
-
-# Unset variables that we do not need and which cause bugs (e.g. in
-# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
-# suppresses any "Segmentation fault" message there.  '((' could
-# trigger a bug in pdksh 5.2.14.
-for as_var in BASH_ENV ENV MAIL MAILPATH
-do eval test x\${$as_var+set} = xset \
-  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
-done
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-LC_ALL=C
-export LC_ALL
-LANGUAGE=C
-export LANGUAGE
-
-# CDPATH.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
-
-
-# as_fn_error STATUS ERROR [LINENO LOG_FD]
-# ----------------------------------------
-# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
-# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with STATUS, using 1 if that was 0.
-as_fn_error ()
-{
-  as_status=$1; test $as_status -eq 0 && as_status=1
-  if test "$4"; then
-    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
-  fi
-  $as_echo "$as_me: error: $2" >&2
-  as_fn_exit $as_status
-} # as_fn_error
-
-
-# as_fn_set_status STATUS
-# -----------------------
-# Set $? to STATUS, without forking.
-as_fn_set_status ()
-{
-  return $1
-} # as_fn_set_status
-
-# as_fn_exit STATUS
-# -----------------
-# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
-as_fn_exit ()
-{
-  set +e
-  as_fn_set_status $1
-  exit $1
-} # as_fn_exit
-
-# as_fn_unset VAR
-# ---------------
-# Portably unset VAR.
-as_fn_unset ()
-{
-  { eval $1=; unset $1;}
-}
-as_unset=as_fn_unset
-# as_fn_append VAR VALUE
-# ----------------------
-# Append the text in VALUE to the end of the definition contained in VAR. Take
-# advantage of any shell optimizations that allow amortized linear growth over
-# repeated appends, instead of the typical quadratic growth present in naive
-# implementations.
-if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
-  eval 'as_fn_append ()
-  {
-    eval $1+=\$2
-  }'
-else
-  as_fn_append ()
-  {
-    eval $1=\$$1\$2
-  }
-fi # as_fn_append
-
-# as_fn_arith ARG...
-# ------------------
-# Perform arithmetic evaluation on the ARGs, and store the result in the
-# global $as_val. Take advantage of shells that can avoid forks. The arguments
-# must be portable across $(()) and expr.
-if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
-  eval 'as_fn_arith ()
-  {
-    as_val=$(( $* ))
-  }'
-else
-  as_fn_arith ()
-  {
-    as_val=`expr "$@" || test $? -eq 1`
-  }
-fi # as_fn_arith
-
-
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
-  as_basename=basename
-else
-  as_basename=false
-fi
-
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
-fi
-
-as_me=`$as_basename -- "$0" ||
-$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X/"$0" |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
-ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in #(((((
--n*)
-  case `echo 'xy\c'` in
-  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  xy)  ECHO_C='\c';;
-  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
-       ECHO_T='	';;
-  esac;;
-*)
-  ECHO_N='-n';;
-esac
-
-rm -f conf$$ conf$$.exe conf$$.file
-if test -d conf$$.dir; then
-  rm -f conf$$.dir/conf$$.file
-else
-  rm -f conf$$.dir
-  mkdir conf$$.dir 2>/dev/null
-fi
-if (echo >conf$$.file) 2>/dev/null; then
-  if ln -s conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s='ln -s'
-    # ... but there are two gotchas:
-    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
-    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-    # In both cases, we have to default to `cp -p'.
-    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-      as_ln_s='cp -p'
-  elif ln conf$$.file conf$$ 2>/dev/null; then
-    as_ln_s=ln
-  else
-    as_ln_s='cp -p'
-  fi
-else
-  as_ln_s='cp -p'
-fi
-rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
-rmdir conf$$.dir 2>/dev/null
-
-
-# as_fn_mkdir_p
-# -------------
-# Create "$as_dir" as a directory, including parents if necessary.
-as_fn_mkdir_p ()
-{
-
-  case $as_dir in #(
-  -*) as_dir=./$as_dir;;
-  esac
-  test -d "$as_dir" || eval $as_mkdir_p || {
-    as_dirs=
-    while :; do
-      case $as_dir in #(
-      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
-      *) as_qdir=$as_dir;;
-      esac
-      as_dirs="'$as_qdir' $as_dirs"
-      as_dir=`$as_dirname -- "$as_dir" ||
-$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_dir" : 'X\(//\)[^/]' \| \
-	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      test -d "$as_dir" && break
-    done
-    test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
-
-
-} # as_fn_mkdir_p
-if mkdir -p . 2>/dev/null; then
-  as_mkdir_p='mkdir -p "$as_dir"'
-else
-  test -d ./-p && rmdir ./-p
-  as_mkdir_p=false
-fi
-
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-	test -d "$1/.";
-      else
-	case $1 in #(
-	-*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
-
-# Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
-
-# Sed expression to map a string onto a valid variable name.
-as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
-
-
-exec 6>&1
-## ----------------------------------- ##
-## Main body of $CONFIG_STATUS script. ##
-## ----------------------------------- ##
-_ASEOF
-test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-# Save the log message, to keep $0 and so on meaningful, and to
-# report actual input values of CONFIG_FILES etc. instead of their
-# values after options handling.
-ac_log="
-This file was extended by gdl $as_me 0.9.2, which was
-generated by GNU Autoconf 2.68.  Invocation command line was
-
-  CONFIG_FILES    = $CONFIG_FILES
-  CONFIG_HEADERS  = $CONFIG_HEADERS
-  CONFIG_LINKS    = $CONFIG_LINKS
-  CONFIG_COMMANDS = $CONFIG_COMMANDS
-  $ $0 $@
-
-on `(hostname || uname -n) 2>/dev/null | sed 1q`
-"
-
-_ACEOF
-
-case $ac_config_files in *"
-"*) set x $ac_config_files; shift; ac_config_files=$*;;
-esac
-
-case $ac_config_headers in *"
-"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
-esac
-
-
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-# Files that config.status was made for.
-config_files="$ac_config_files"
-config_headers="$ac_config_headers"
-config_commands="$ac_config_commands"
-
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-ac_cs_usage="\
-\`$as_me' instantiates files and other configuration actions
-from templates according to the current configuration.  Unless the files
-and actions are specified as TAGs, all are instantiated by default.
-
-Usage: $0 [OPTION]... [TAG]...
-
-  -h, --help       print this help, then exit
-  -V, --version    print version number and configuration settings, then exit
-      --config     print configuration, then exit
-  -q, --quiet, --silent
-                   do not print progress messages
-  -d, --debug      don't remove temporary files
-      --recheck    update $as_me by reconfiguring in the same conditions
-      --file=FILE[:TEMPLATE]
-                   instantiate the configuration file FILE
-      --header=FILE[:TEMPLATE]
-                   instantiate the configuration header FILE
-
-Configuration files:
-$config_files
-
-Configuration headers:
-$config_headers
-
-Configuration commands:
-$config_commands
-
-Report bugs to the package provider."
-
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
-ac_cs_version="\\
-gdl config.status 0.9.2
-configured by $0, generated by GNU Autoconf 2.68,
-  with options \\"\$ac_cs_config\\"
-
-Copyright (C) 2010 Free Software Foundation, Inc.
-This config.status script is free software; the Free Software Foundation
-gives unlimited permission to copy, distribute and modify it."
-
-ac_pwd='$ac_pwd'
-srcdir='$srcdir'
-INSTALL='$INSTALL'
-MKDIR_P='$MKDIR_P'
-AWK='$AWK'
-test -n "\$AWK" || AWK=awk
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-# The default lists apply if the user does not specify any file.
-ac_need_defaults=:
-while test $# != 0
-do
-  case $1 in
-  --*=?*)
-    ac_option=`expr "X$1" : 'X\([^=]*\)='`
-    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
-    ac_shift=:
-    ;;
-  --*=)
-    ac_option=`expr "X$1" : 'X\([^=]*\)='`
-    ac_optarg=
-    ac_shift=:
-    ;;
-  *)
-    ac_option=$1
-    ac_optarg=$2
-    ac_shift=shift
-    ;;
-  esac
-
-  case $ac_option in
-  # Handling of the options.
-  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
-    ac_cs_recheck=: ;;
-  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
-    $as_echo "$ac_cs_version"; exit ;;
-  --config | --confi | --conf | --con | --co | --c )
-    $as_echo "$ac_cs_config"; exit ;;
-  --debug | --debu | --deb | --de | --d | -d )
-    debug=: ;;
-  --file | --fil | --fi | --f )
-    $ac_shift
-    case $ac_optarg in
-    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    '') as_fn_error $? "missing file argument" ;;
-    esac
-    as_fn_append CONFIG_FILES " '$ac_optarg'"
-    ac_need_defaults=false;;
-  --header | --heade | --head | --hea )
-    $ac_shift
-    case $ac_optarg in
-    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    esac
-    as_fn_append CONFIG_HEADERS " '$ac_optarg'"
-    ac_need_defaults=false;;
-  --he | --h)
-    # Conflict between --help and --header
-    as_fn_error $? "ambiguous option: \`$1'
-Try \`$0 --help' for more information.";;
-  --help | --hel | -h )
-    $as_echo "$ac_cs_usage"; exit ;;
-  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-  | -silent | --silent | --silen | --sile | --sil | --si | --s)
-    ac_cs_silent=: ;;
-
-  # This is an error.
-  -*) as_fn_error $? "unrecognized option: \`$1'
-Try \`$0 --help' for more information." ;;
-
-  *) as_fn_append ac_config_targets " $1"
-     ac_need_defaults=false ;;
-
-  esac
-  shift
-done
-
-ac_configure_extra_args=
-
-if $ac_cs_silent; then
-  exec 6>/dev/null
-  ac_configure_extra_args="$ac_configure_extra_args --silent"
-fi
-
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-if \$ac_cs_recheck; then
-  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
-  shift
-  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
-  CONFIG_SHELL='$SHELL'
-  export CONFIG_SHELL
-  exec "\$@"
-fi
-
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-exec 5>>config.log
-{
-  echo
-  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
-## Running $as_me. ##
-_ASBOX
-  $as_echo "$ac_log"
-} >&5
-
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-#
-# INIT-COMMANDS
-#
-AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
-
-
-# The HP-UX ksh and POSIX shell print the target directory to stdout
-# if CDPATH is set.
-(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
-
-sed_quote_subst='$sed_quote_subst'
-double_quote_subst='$double_quote_subst'
-delay_variable_subst='$delay_variable_subst'
-macro_version='`$ECHO "$macro_version" | $SED "$delay_single_quote_subst"`'
-macro_revision='`$ECHO "$macro_revision" | $SED "$delay_single_quote_subst"`'
-enable_shared='`$ECHO "$enable_shared" | $SED "$delay_single_quote_subst"`'
-enable_static='`$ECHO "$enable_static" | $SED "$delay_single_quote_subst"`'
-pic_mode='`$ECHO "$pic_mode" | $SED "$delay_single_quote_subst"`'
-enable_fast_install='`$ECHO "$enable_fast_install" | $SED "$delay_single_quote_subst"`'
-SHELL='`$ECHO "$SHELL" | $SED "$delay_single_quote_subst"`'
-ECHO='`$ECHO "$ECHO" | $SED "$delay_single_quote_subst"`'
-host_alias='`$ECHO "$host_alias" | $SED "$delay_single_quote_subst"`'
-host='`$ECHO "$host" | $SED "$delay_single_quote_subst"`'
-host_os='`$ECHO "$host_os" | $SED "$delay_single_quote_subst"`'
-build_alias='`$ECHO "$build_alias" | $SED "$delay_single_quote_subst"`'
-build='`$ECHO "$build" | $SED "$delay_single_quote_subst"`'
-build_os='`$ECHO "$build_os" | $SED "$delay_single_quote_subst"`'
-SED='`$ECHO "$SED" | $SED "$delay_single_quote_subst"`'
-Xsed='`$ECHO "$Xsed" | $SED "$delay_single_quote_subst"`'
-GREP='`$ECHO "$GREP" | $SED "$delay_single_quote_subst"`'
-EGREP='`$ECHO "$EGREP" | $SED "$delay_single_quote_subst"`'
-FGREP='`$ECHO "$FGREP" | $SED "$delay_single_quote_subst"`'
-LD='`$ECHO "$LD" | $SED "$delay_single_quote_subst"`'
-NM='`$ECHO "$NM" | $SED "$delay_single_quote_subst"`'
-LN_S='`$ECHO "$LN_S" | $SED "$delay_single_quote_subst"`'
-max_cmd_len='`$ECHO "$max_cmd_len" | $SED "$delay_single_quote_subst"`'
-ac_objext='`$ECHO "$ac_objext" | $SED "$delay_single_quote_subst"`'
-exeext='`$ECHO "$exeext" | $SED "$delay_single_quote_subst"`'
-lt_unset='`$ECHO "$lt_unset" | $SED "$delay_single_quote_subst"`'
-lt_SP2NL='`$ECHO "$lt_SP2NL" | $SED "$delay_single_quote_subst"`'
-lt_NL2SP='`$ECHO "$lt_NL2SP" | $SED "$delay_single_quote_subst"`'
-lt_cv_to_host_file_cmd='`$ECHO "$lt_cv_to_host_file_cmd" | $SED "$delay_single_quote_subst"`'
-lt_cv_to_tool_file_cmd='`$ECHO "$lt_cv_to_tool_file_cmd" | $SED "$delay_single_quote_subst"`'
-reload_flag='`$ECHO "$reload_flag" | $SED "$delay_single_quote_subst"`'
-reload_cmds='`$ECHO "$reload_cmds" | $SED "$delay_single_quote_subst"`'
-OBJDUMP='`$ECHO "$OBJDUMP" | $SED "$delay_single_quote_subst"`'
-deplibs_check_method='`$ECHO "$deplibs_check_method" | $SED "$delay_single_quote_subst"`'
-file_magic_cmd='`$ECHO "$file_magic_cmd" | $SED "$delay_single_quote_subst"`'
-file_magic_glob='`$ECHO "$file_magic_glob" | $SED "$delay_single_quote_subst"`'
-want_nocaseglob='`$ECHO "$want_nocaseglob" | $SED "$delay_single_quote_subst"`'
-DLLTOOL='`$ECHO "$DLLTOOL" | $SED "$delay_single_quote_subst"`'
-sharedlib_from_linklib_cmd='`$ECHO "$sharedlib_from_linklib_cmd" | $SED "$delay_single_quote_subst"`'
-AR='`$ECHO "$AR" | $SED "$delay_single_quote_subst"`'
-AR_FLAGS='`$ECHO "$AR_FLAGS" | $SED "$delay_single_quote_subst"`'
-archiver_list_spec='`$ECHO "$archiver_list_spec" | $SED "$delay_single_quote_subst"`'
-STRIP='`$ECHO "$STRIP" | $SED "$delay_single_quote_subst"`'
-RANLIB='`$ECHO "$RANLIB" | $SED "$delay_single_quote_subst"`'
-old_postinstall_cmds='`$ECHO "$old_postinstall_cmds" | $SED "$delay_single_quote_subst"`'
-old_postuninstall_cmds='`$ECHO "$old_postuninstall_cmds" | $SED "$delay_single_quote_subst"`'
-old_archive_cmds='`$ECHO "$old_archive_cmds" | $SED "$delay_single_quote_subst"`'
-lock_old_archive_extraction='`$ECHO "$lock_old_archive_extraction" | $SED "$delay_single_quote_subst"`'
-CC='`$ECHO "$CC" | $SED "$delay_single_quote_subst"`'
-CFLAGS='`$ECHO "$CFLAGS" | $SED "$delay_single_quote_subst"`'
-compiler='`$ECHO "$compiler" | $SED "$delay_single_quote_subst"`'
-GCC='`$ECHO "$GCC" | $SED "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_pipe='`$ECHO "$lt_cv_sys_global_symbol_pipe" | $SED "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_to_cdecl='`$ECHO "$lt_cv_sys_global_symbol_to_cdecl" | $SED "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_to_c_name_address='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address" | $SED "$delay_single_quote_subst"`'
-lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address_lib_prefix" | $SED "$delay_single_quote_subst"`'
-nm_file_list_spec='`$ECHO "$nm_file_list_spec" | $SED "$delay_single_quote_subst"`'
-lt_sysroot='`$ECHO "$lt_sysroot" | $SED "$delay_single_quote_subst"`'
-objdir='`$ECHO "$objdir" | $SED "$delay_single_quote_subst"`'
-MAGIC_CMD='`$ECHO "$MAGIC_CMD" | $SED "$delay_single_quote_subst"`'
-lt_prog_compiler_no_builtin_flag='`$ECHO "$lt_prog_compiler_no_builtin_flag" | $SED "$delay_single_quote_subst"`'
-lt_prog_compiler_pic='`$ECHO "$lt_prog_compiler_pic" | $SED "$delay_single_quote_subst"`'
-lt_prog_compiler_wl='`$ECHO "$lt_prog_compiler_wl" | $SED "$delay_single_quote_subst"`'
-lt_prog_compiler_static='`$ECHO "$lt_prog_compiler_static" | $SED "$delay_single_quote_subst"`'
-lt_cv_prog_compiler_c_o='`$ECHO "$lt_cv_prog_compiler_c_o" | $SED "$delay_single_quote_subst"`'
-need_locks='`$ECHO "$need_locks" | $SED "$delay_single_quote_subst"`'
-MANIFEST_TOOL='`$ECHO "$MANIFEST_TOOL" | $SED "$delay_single_quote_subst"`'
-DSYMUTIL='`$ECHO "$DSYMUTIL" | $SED "$delay_single_quote_subst"`'
-NMEDIT='`$ECHO "$NMEDIT" | $SED "$delay_single_quote_subst"`'
-LIPO='`$ECHO "$LIPO" | $SED "$delay_single_quote_subst"`'
-OTOOL='`$ECHO "$OTOOL" | $SED "$delay_single_quote_subst"`'
-OTOOL64='`$ECHO "$OTOOL64" | $SED "$delay_single_quote_subst"`'
-libext='`$ECHO "$libext" | $SED "$delay_single_quote_subst"`'
-shrext_cmds='`$ECHO "$shrext_cmds" | $SED "$delay_single_quote_subst"`'
-extract_expsyms_cmds='`$ECHO "$extract_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
-archive_cmds_need_lc='`$ECHO "$archive_cmds_need_lc" | $SED "$delay_single_quote_subst"`'
-enable_shared_with_static_runtimes='`$ECHO "$enable_shared_with_static_runtimes" | $SED "$delay_single_quote_subst"`'
-export_dynamic_flag_spec='`$ECHO "$export_dynamic_flag_spec" | $SED "$delay_single_quote_subst"`'
-whole_archive_flag_spec='`$ECHO "$whole_archive_flag_spec" | $SED "$delay_single_quote_subst"`'
-compiler_needs_object='`$ECHO "$compiler_needs_object" | $SED "$delay_single_quote_subst"`'
-old_archive_from_new_cmds='`$ECHO "$old_archive_from_new_cmds" | $SED "$delay_single_quote_subst"`'
-old_archive_from_expsyms_cmds='`$ECHO "$old_archive_from_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
-archive_cmds='`$ECHO "$archive_cmds" | $SED "$delay_single_quote_subst"`'
-archive_expsym_cmds='`$ECHO "$archive_expsym_cmds" | $SED "$delay_single_quote_subst"`'
-module_cmds='`$ECHO "$module_cmds" | $SED "$delay_single_quote_subst"`'
-module_expsym_cmds='`$ECHO "$module_expsym_cmds" | $SED "$delay_single_quote_subst"`'
-with_gnu_ld='`$ECHO "$with_gnu_ld" | $SED "$delay_single_quote_subst"`'
-allow_undefined_flag='`$ECHO "$allow_undefined_flag" | $SED "$delay_single_quote_subst"`'
-no_undefined_flag='`$ECHO "$no_undefined_flag" | $SED "$delay_single_quote_subst"`'
-hardcode_libdir_flag_spec='`$ECHO "$hardcode_libdir_flag_spec" | $SED "$delay_single_quote_subst"`'
-hardcode_libdir_flag_spec_ld='`$ECHO "$hardcode_libdir_flag_spec_ld" | $SED "$delay_single_quote_subst"`'
-hardcode_libdir_separator='`$ECHO "$hardcode_libdir_separator" | $SED "$delay_single_quote_subst"`'
-hardcode_direct='`$ECHO "$hardcode_direct" | $SED "$delay_single_quote_subst"`'
-hardcode_direct_absolute='`$ECHO "$hardcode_direct_absolute" | $SED "$delay_single_quote_subst"`'
-hardcode_minus_L='`$ECHO "$hardcode_minus_L" | $SED "$delay_single_quote_subst"`'
-hardcode_shlibpath_var='`$ECHO "$hardcode_shlibpath_var" | $SED "$delay_single_quote_subst"`'
-hardcode_automatic='`$ECHO "$hardcode_automatic" | $SED "$delay_single_quote_subst"`'
-inherit_rpath='`$ECHO "$inherit_rpath" | $SED "$delay_single_quote_subst"`'
-link_all_deplibs='`$ECHO "$link_all_deplibs" | $SED "$delay_single_quote_subst"`'
-always_export_symbols='`$ECHO "$always_export_symbols" | $SED "$delay_single_quote_subst"`'
-export_symbols_cmds='`$ECHO "$export_symbols_cmds" | $SED "$delay_single_quote_subst"`'
-exclude_expsyms='`$ECHO "$exclude_expsyms" | $SED "$delay_single_quote_subst"`'
-include_expsyms='`$ECHO "$include_expsyms" | $SED "$delay_single_quote_subst"`'
-prelink_cmds='`$ECHO "$prelink_cmds" | $SED "$delay_single_quote_subst"`'
-postlink_cmds='`$ECHO "$postlink_cmds" | $SED "$delay_single_quote_subst"`'
-file_list_spec='`$ECHO "$file_list_spec" | $SED "$delay_single_quote_subst"`'
-variables_saved_for_relink='`$ECHO "$variables_saved_for_relink" | $SED "$delay_single_quote_subst"`'
-need_lib_prefix='`$ECHO "$need_lib_prefix" | $SED "$delay_single_quote_subst"`'
-need_version='`$ECHO "$need_version" | $SED "$delay_single_quote_subst"`'
-version_type='`$ECHO "$version_type" | $SED "$delay_single_quote_subst"`'
-runpath_var='`$ECHO "$runpath_var" | $SED "$delay_single_quote_subst"`'
-shlibpath_var='`$ECHO "$shlibpath_var" | $SED "$delay_single_quote_subst"`'
-shlibpath_overrides_runpath='`$ECHO "$shlibpath_overrides_runpath" | $SED "$delay_single_quote_subst"`'
-libname_spec='`$ECHO "$libname_spec" | $SED "$delay_single_quote_subst"`'
-library_names_spec='`$ECHO "$library_names_spec" | $SED "$delay_single_quote_subst"`'
-soname_spec='`$ECHO "$soname_spec" | $SED "$delay_single_quote_subst"`'
-install_override_mode='`$ECHO "$install_override_mode" | $SED "$delay_single_quote_subst"`'
-postinstall_cmds='`$ECHO "$postinstall_cmds" | $SED "$delay_single_quote_subst"`'
-postuninstall_cmds='`$ECHO "$postuninstall_cmds" | $SED "$delay_single_quote_subst"`'
-finish_cmds='`$ECHO "$finish_cmds" | $SED "$delay_single_quote_subst"`'
-finish_eval='`$ECHO "$finish_eval" | $SED "$delay_single_quote_subst"`'
-hardcode_into_libs='`$ECHO "$hardcode_into_libs" | $SED "$delay_single_quote_subst"`'
-sys_lib_search_path_spec='`$ECHO "$sys_lib_search_path_spec" | $SED "$delay_single_quote_subst"`'
-sys_lib_dlsearch_path_spec='`$ECHO "$sys_lib_dlsearch_path_spec" | $SED "$delay_single_quote_subst"`'
-hardcode_action='`$ECHO "$hardcode_action" | $SED "$delay_single_quote_subst"`'
-enable_dlopen='`$ECHO "$enable_dlopen" | $SED "$delay_single_quote_subst"`'
-enable_dlopen_self='`$ECHO "$enable_dlopen_self" | $SED "$delay_single_quote_subst"`'
-enable_dlopen_self_static='`$ECHO "$enable_dlopen_self_static" | $SED "$delay_single_quote_subst"`'
-old_striplib='`$ECHO "$old_striplib" | $SED "$delay_single_quote_subst"`'
-striplib='`$ECHO "$striplib" | $SED "$delay_single_quote_subst"`'
-compiler_lib_search_dirs='`$ECHO "$compiler_lib_search_dirs" | $SED "$delay_single_quote_subst"`'
-predep_objects='`$ECHO "$predep_objects" | $SED "$delay_single_quote_subst"`'
-postdep_objects='`$ECHO "$postdep_objects" | $SED "$delay_single_quote_subst"`'
-predeps='`$ECHO "$predeps" | $SED "$delay_single_quote_subst"`'
-postdeps='`$ECHO "$postdeps" | $SED "$delay_single_quote_subst"`'
-compiler_lib_search_path='`$ECHO "$compiler_lib_search_path" | $SED "$delay_single_quote_subst"`'
-LD_CXX='`$ECHO "$LD_CXX" | $SED "$delay_single_quote_subst"`'
-reload_flag_CXX='`$ECHO "$reload_flag_CXX" | $SED "$delay_single_quote_subst"`'
-reload_cmds_CXX='`$ECHO "$reload_cmds_CXX" | $SED "$delay_single_quote_subst"`'
-old_archive_cmds_CXX='`$ECHO "$old_archive_cmds_CXX" | $SED "$delay_single_quote_subst"`'
-compiler_CXX='`$ECHO "$compiler_CXX" | $SED "$delay_single_quote_subst"`'
-GCC_CXX='`$ECHO "$GCC_CXX" | $SED "$delay_single_quote_subst"`'
-lt_prog_compiler_no_builtin_flag_CXX='`$ECHO "$lt_prog_compiler_no_builtin_flag_CXX" | $SED "$delay_single_quote_subst"`'
-lt_prog_compiler_pic_CXX='`$ECHO "$lt_prog_compiler_pic_CXX" | $SED "$delay_single_quote_subst"`'
-lt_prog_compiler_wl_CXX='`$ECHO "$lt_prog_compiler_wl_CXX" | $SED "$delay_single_quote_subst"`'
-lt_prog_compiler_static_CXX='`$ECHO "$lt_prog_compiler_static_CXX" | $SED "$delay_single_quote_subst"`'
-lt_cv_prog_compiler_c_o_CXX='`$ECHO "$lt_cv_prog_compiler_c_o_CXX" | $SED "$delay_single_quote_subst"`'
-archive_cmds_need_lc_CXX='`$ECHO "$archive_cmds_need_lc_CXX" | $SED "$delay_single_quote_subst"`'
-enable_shared_with_static_runtimes_CXX='`$ECHO "$enable_shared_with_static_runtimes_CXX" | $SED "$delay_single_quote_subst"`'
-export_dynamic_flag_spec_CXX='`$ECHO "$export_dynamic_flag_spec_CXX" | $SED "$delay_single_quote_subst"`'
-whole_archive_flag_spec_CXX='`$ECHO "$whole_archive_flag_spec_CXX" | $SED "$delay_single_quote_subst"`'
-compiler_needs_object_CXX='`$ECHO "$compiler_needs_object_CXX" | $SED "$delay_single_quote_subst"`'
-old_archive_from_new_cmds_CXX='`$ECHO "$old_archive_from_new_cmds_CXX" | $SED "$delay_single_quote_subst"`'
-old_archive_from_expsyms_cmds_CXX='`$ECHO "$old_archive_from_expsyms_cmds_CXX" | $SED "$delay_single_quote_subst"`'
-archive_cmds_CXX='`$ECHO "$archive_cmds_CXX" | $SED "$delay_single_quote_subst"`'
-archive_expsym_cmds_CXX='`$ECHO "$archive_expsym_cmds_CXX" | $SED "$delay_single_quote_subst"`'
-module_cmds_CXX='`$ECHO "$module_cmds_CXX" | $SED "$delay_single_quote_subst"`'
-module_expsym_cmds_CXX='`$ECHO "$module_expsym_cmds_CXX" | $SED "$delay_single_quote_subst"`'
-with_gnu_ld_CXX='`$ECHO "$with_gnu_ld_CXX" | $SED "$delay_single_quote_subst"`'
-allow_undefined_flag_CXX='`$ECHO "$allow_undefined_flag_CXX" | $SED "$delay_single_quote_subst"`'
-no_undefined_flag_CXX='`$ECHO "$no_undefined_flag_CXX" | $SED "$delay_single_quote_subst"`'
-hardcode_libdir_flag_spec_CXX='`$ECHO "$hardcode_libdir_flag_spec_CXX" | $SED "$delay_single_quote_subst"`'
-hardcode_libdir_flag_spec_ld_CXX='`$ECHO "$hardcode_libdir_flag_spec_ld_CXX" | $SED "$delay_single_quote_subst"`'
-hardcode_libdir_separator_CXX='`$ECHO "$hardcode_libdir_separator_CXX" | $SED "$delay_single_quote_subst"`'
-hardcode_direct_CXX='`$ECHO "$hardcode_direct_CXX" | $SED "$delay_single_quote_subst"`'
-hardcode_direct_absolute_CXX='`$ECHO "$hardcode_direct_absolute_CXX" | $SED "$delay_single_quote_subst"`'
-hardcode_minus_L_CXX='`$ECHO "$hardcode_minus_L_CXX" | $SED "$delay_single_quote_subst"`'
-hardcode_shlibpath_var_CXX='`$ECHO "$hardcode_shlibpath_var_CXX" | $SED "$delay_single_quote_subst"`'
-hardcode_automatic_CXX='`$ECHO "$hardcode_automatic_CXX" | $SED "$delay_single_quote_subst"`'
-inherit_rpath_CXX='`$ECHO "$inherit_rpath_CXX" | $SED "$delay_single_quote_subst"`'
-link_all_deplibs_CXX='`$ECHO "$link_all_deplibs_CXX" | $SED "$delay_single_quote_subst"`'
-always_export_symbols_CXX='`$ECHO "$always_export_symbols_CXX" | $SED "$delay_single_quote_subst"`'
-export_symbols_cmds_CXX='`$ECHO "$export_symbols_cmds_CXX" | $SED "$delay_single_quote_subst"`'
-exclude_expsyms_CXX='`$ECHO "$exclude_expsyms_CXX" | $SED "$delay_single_quote_subst"`'
-include_expsyms_CXX='`$ECHO "$include_expsyms_CXX" | $SED "$delay_single_quote_subst"`'
-prelink_cmds_CXX='`$ECHO "$prelink_cmds_CXX" | $SED "$delay_single_quote_subst"`'
-postlink_cmds_CXX='`$ECHO "$postlink_cmds_CXX" | $SED "$delay_single_quote_subst"`'
-file_list_spec_CXX='`$ECHO "$file_list_spec_CXX" | $SED "$delay_single_quote_subst"`'
-hardcode_action_CXX='`$ECHO "$hardcode_action_CXX" | $SED "$delay_single_quote_subst"`'
-compiler_lib_search_dirs_CXX='`$ECHO "$compiler_lib_search_dirs_CXX" | $SED "$delay_single_quote_subst"`'
-predep_objects_CXX='`$ECHO "$predep_objects_CXX" | $SED "$delay_single_quote_subst"`'
-postdep_objects_CXX='`$ECHO "$postdep_objects_CXX" | $SED "$delay_single_quote_subst"`'
-predeps_CXX='`$ECHO "$predeps_CXX" | $SED "$delay_single_quote_subst"`'
-postdeps_CXX='`$ECHO "$postdeps_CXX" | $SED "$delay_single_quote_subst"`'
-compiler_lib_search_path_CXX='`$ECHO "$compiler_lib_search_path_CXX" | $SED "$delay_single_quote_subst"`'
-
-LTCC='$LTCC'
-LTCFLAGS='$LTCFLAGS'
-compiler='$compiler_DEFAULT'
-
-# A function that is used when there is no print builtin or printf.
-func_fallback_echo ()
-{
-  eval 'cat <<_LTECHO_EOF
-\$1
-_LTECHO_EOF'
-}
-
-# Quote evaled strings.
-for var in SHELL \
-ECHO \
-SED \
-GREP \
-EGREP \
-FGREP \
-LD \
-NM \
-LN_S \
-lt_SP2NL \
-lt_NL2SP \
-reload_flag \
-OBJDUMP \
-deplibs_check_method \
-file_magic_cmd \
-file_magic_glob \
-want_nocaseglob \
-DLLTOOL \
-sharedlib_from_linklib_cmd \
-AR \
-AR_FLAGS \
-archiver_list_spec \
-STRIP \
-RANLIB \
-CC \
-CFLAGS \
-compiler \
-lt_cv_sys_global_symbol_pipe \
-lt_cv_sys_global_symbol_to_cdecl \
-lt_cv_sys_global_symbol_to_c_name_address \
-lt_cv_sys_global_symbol_to_c_name_address_lib_prefix \
-nm_file_list_spec \
-lt_prog_compiler_no_builtin_flag \
-lt_prog_compiler_pic \
-lt_prog_compiler_wl \
-lt_prog_compiler_static \
-lt_cv_prog_compiler_c_o \
-need_locks \
-MANIFEST_TOOL \
-DSYMUTIL \
-NMEDIT \
-LIPO \
-OTOOL \
-OTOOL64 \
-shrext_cmds \
-export_dynamic_flag_spec \
-whole_archive_flag_spec \
-compiler_needs_object \
-with_gnu_ld \
-allow_undefined_flag \
-no_undefined_flag \
-hardcode_libdir_flag_spec \
-hardcode_libdir_flag_spec_ld \
-hardcode_libdir_separator \
-exclude_expsyms \
-include_expsyms \
-file_list_spec \
-variables_saved_for_relink \
-libname_spec \
-library_names_spec \
-soname_spec \
-install_override_mode \
-finish_eval \
-old_striplib \
-striplib \
-compiler_lib_search_dirs \
-predep_objects \
-postdep_objects \
-predeps \
-postdeps \
-compiler_lib_search_path \
-LD_CXX \
-reload_flag_CXX \
-compiler_CXX \
-lt_prog_compiler_no_builtin_flag_CXX \
-lt_prog_compiler_pic_CXX \
-lt_prog_compiler_wl_CXX \
-lt_prog_compiler_static_CXX \
-lt_cv_prog_compiler_c_o_CXX \
-export_dynamic_flag_spec_CXX \
-whole_archive_flag_spec_CXX \
-compiler_needs_object_CXX \
-with_gnu_ld_CXX \
-allow_undefined_flag_CXX \
-no_undefined_flag_CXX \
-hardcode_libdir_flag_spec_CXX \
-hardcode_libdir_flag_spec_ld_CXX \
-hardcode_libdir_separator_CXX \
-exclude_expsyms_CXX \
-include_expsyms_CXX \
-file_list_spec_CXX \
-compiler_lib_search_dirs_CXX \
-predep_objects_CXX \
-postdep_objects_CXX \
-predeps_CXX \
-postdeps_CXX \
-compiler_lib_search_path_CXX; do
-    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
-    *[\\\\\\\`\\"\\\$]*)
-      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
-      ;;
-    *)
-      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
-      ;;
-    esac
-done
-
-# Double-quote double-evaled strings.
-for var in reload_cmds \
-old_postinstall_cmds \
-old_postuninstall_cmds \
-old_archive_cmds \
-extract_expsyms_cmds \
-old_archive_from_new_cmds \
-old_archive_from_expsyms_cmds \
-archive_cmds \
-archive_expsym_cmds \
-module_cmds \
-module_expsym_cmds \
-export_symbols_cmds \
-prelink_cmds \
-postlink_cmds \
-postinstall_cmds \
-postuninstall_cmds \
-finish_cmds \
-sys_lib_search_path_spec \
-sys_lib_dlsearch_path_spec \
-reload_cmds_CXX \
-old_archive_cmds_CXX \
-old_archive_from_new_cmds_CXX \
-old_archive_from_expsyms_cmds_CXX \
-archive_cmds_CXX \
-archive_expsym_cmds_CXX \
-module_cmds_CXX \
-module_expsym_cmds_CXX \
-export_symbols_cmds_CXX \
-prelink_cmds_CXX \
-postlink_cmds_CXX; do
-    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
-    *[\\\\\\\`\\"\\\$]*)
-      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
-      ;;
-    *)
-      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
-      ;;
-    esac
-done
-
-ac_aux_dir='$ac_aux_dir'
-xsi_shell='$xsi_shell'
-lt_shell_append='$lt_shell_append'
-
-# See if we are running on zsh, and set the options which allow our
-# commands through without removal of \ escapes INIT.
-if test -n "\${ZSH_VERSION+set}" ; then
-   setopt NO_GLOB_SUBST
-fi
-
-
-    PACKAGE='$PACKAGE'
-    VERSION='$VERSION'
-    TIMESTAMP='$TIMESTAMP'
-    RM='$RM'
-    ofile='$ofile'
-
-
-
-
-
-
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-
-# Handling of arguments.
-for ac_config_target in $ac_config_targets
-do
-  case $ac_config_target in
-    "config.h") CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
-    "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
-    "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
-    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
-    "src/Makefile") CONFIG_FILES="$CONFIG_FILES src/Makefile" ;;
-    "src/antlr/Makefile") CONFIG_FILES="$CONFIG_FILES src/antlr/Makefile" ;;
-    "src/pro/Makefile") CONFIG_FILES="$CONFIG_FILES src/pro/Makefile" ;;
-    "src/pro/dicom/Makefile") CONFIG_FILES="$CONFIG_FILES src/pro/dicom/Makefile" ;;
-    "testsuite/Makefile") CONFIG_FILES="$CONFIG_FILES testsuite/Makefile" ;;
-    "doc/Makefile") CONFIG_FILES="$CONFIG_FILES doc/Makefile" ;;
-
-  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
-  esac
-done
-
-
-# If the user did not use the arguments to specify the items to instantiate,
-# then the envvar interface is used.  Set only those that are not.
-# We use the long form for the default assignment because of an extremely
-# bizarre bug on SunOS 4.1.3.
-if $ac_need_defaults; then
-  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
-  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
-  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
-fi
-
-# Have a temporary directory for convenience.  Make it in the build tree
-# simply because there is no reason against having it here, and in addition,
-# creating and moving files from /tmp can sometimes cause problems.
-# Hook for its removal unless debugging.
-# Note that there is a small window in which the directory will not be cleaned:
-# after its creation but before its name has been assigned to `$tmp'.
-$debug ||
-{
-  tmp= ac_tmp=
-  trap 'exit_status=$?
-  : "${ac_tmp:=$tmp}"
-  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
-' 0
-  trap 'as_fn_exit 1' 1 2 13 15
-}
-# Create a (secure) tmp directory for tmp files.
-
-{
-  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
-  test -d "$tmp"
-}  ||
-{
-  tmp=./conf$$-$RANDOM
-  (umask 077 && mkdir "$tmp")
-} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
-ac_tmp=$tmp
-
-# Set up the scripts for CONFIG_FILES section.
-# No need to generate them if there are no CONFIG_FILES.
-# This happens for instance with `./config.status config.h'.
-if test -n "$CONFIG_FILES"; then
-
-
-ac_cr=`echo X | tr X '\015'`
-# On cygwin, bash can eat \r inside `` if the user requested igncr.
-# But we know of no other shell where ac_cr would be empty at this
-# point, so we can use a bashism as a fallback.
-if test "x$ac_cr" = x; then
-  eval ac_cr=\$\'\\r\'
-fi
-ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
-if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
-  ac_cs_awk_cr='\\r'
-else
-  ac_cs_awk_cr=$ac_cr
-fi
-
-echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
-_ACEOF
-
-
-{
-  echo "cat >conf$$subs.awk <<_ACEOF" &&
-  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
-  echo "_ACEOF"
-} >conf$$subs.sh ||
-  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
-ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
-ac_delim='%!_!# '
-for ac_last_try in false false false false false :; do
-  . ./conf$$subs.sh ||
-    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
-
-  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
-  if test $ac_delim_n = $ac_delim_num; then
-    break
-  elif $ac_last_try; then
-    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
-  else
-    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
-  fi
-done
-rm -f conf$$subs.sh
-
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&
-_ACEOF
-sed -n '
-h
-s/^/S["/; s/!.*/"]=/
-p
-g
-s/^[^!]*!//
-:repl
-t repl
-s/'"$ac_delim"'$//
-t delim
-:nl
-h
-s/\(.\{148\}\)..*/\1/
-t more1
-s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
-p
-n
-b repl
-:more1
-s/["\\]/\\&/g; s/^/"/; s/$/"\\/
-p
-g
-s/.\{148\}//
-t nl
-:delim
-h
-s/\(.\{148\}\)..*/\1/
-t more2
-s/["\\]/\\&/g; s/^/"/; s/$/"/
-p
-b
-:more2
-s/["\\]/\\&/g; s/^/"/; s/$/"\\/
-p
-g
-s/.\{148\}//
-t delim
-' <conf$$subs.awk | sed '
-/^[^""]/{
-  N
-  s/\n//
-}
-' >>$CONFIG_STATUS || ac_write_fail=1
-rm -f conf$$subs.awk
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-_ACAWK
-cat >>"\$ac_tmp/subs1.awk" <<_ACAWK &&
-  for (key in S) S_is_set[key] = 1
-  FS = ""
-
-}
-{
-  line = $ 0
-  nfields = split(line, field, "@")
-  substed = 0
-  len = length(field[1])
-  for (i = 2; i < nfields; i++) {
-    key = field[i]
-    keylen = length(key)
-    if (S_is_set[key]) {
-      value = S[key]
-      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
-      len += length(value) + length(field[++i])
-      substed = 1
-    } else
-      len += 1 + keylen
-  }
-
-  print line
-}
-
-_ACAWK
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
-  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
-else
-  cat
-fi < "$ac_tmp/subs1.awk" > "$ac_tmp/subs.awk" \
-  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
-_ACEOF
-
-# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
-# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
-# trailing colons and then remove the whole line if VPATH becomes empty
-# (actually we leave an empty line to preserve line numbers).
-if test "x$srcdir" = x.; then
-  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
-h
-s///
-s/^/:/
-s/[	 ]*$/:/
-s/:\$(srcdir):/:/g
-s/:\${srcdir}:/:/g
-s/:@srcdir@:/:/g
-s/^:*//
-s/:*$//
-x
-s/\(=[	 ]*\).*/\1/
-G
-s/\n//
-s/^[^=]*=[	 ]*$//
-}'
-fi
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-fi # test -n "$CONFIG_FILES"
-
-# Set up the scripts for CONFIG_HEADERS section.
-# No need to generate them if there are no CONFIG_HEADERS.
-# This happens for instance with `./config.status Makefile'.
-if test -n "$CONFIG_HEADERS"; then
-cat >"$ac_tmp/defines.awk" <<\_ACAWK ||
-BEGIN {
-_ACEOF
-
-# Transform confdefs.h into an awk script `defines.awk', embedded as
-# here-document in config.status, that substitutes the proper values into
-# config.h.in to produce config.h.
-
-# Create a delimiter string that does not exist in confdefs.h, to ease
-# handling of long lines.
-ac_delim='%!_!# '
-for ac_last_try in false false :; do
-  ac_tt=`sed -n "/$ac_delim/p" confdefs.h`
-  if test -z "$ac_tt"; then
-    break
-  elif $ac_last_try; then
-    as_fn_error $? "could not make $CONFIG_HEADERS" "$LINENO" 5
-  else
-    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
-  fi
-done
-
-# For the awk script, D is an array of macro values keyed by name,
-# likewise P contains macro parameters if any.  Preserve backslash
-# newline sequences.
-
-ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
-sed -n '
-s/.\{148\}/&'"$ac_delim"'/g
-t rset
-:rset
-s/^[	 ]*#[	 ]*define[	 ][	 ]*/ /
-t def
-d
-:def
-s/\\$//
-t bsnl
-s/["\\]/\\&/g
-s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
-D["\1"]=" \3"/p
-s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2"/p
-d
-:bsnl
-s/["\\]/\\&/g
-s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
-D["\1"]=" \3\\\\\\n"\\/p
-t cont
-s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2\\\\\\n"\\/p
-t cont
-d
-:cont
-n
-s/.\{148\}/&'"$ac_delim"'/g
-t clear
-:clear
-s/\\$//
-t bsnlc
-s/["\\]/\\&/g; s/^/"/; s/$/"/p
-d
-:bsnlc
-s/["\\]/\\&/g; s/^/"/; s/$/\\\\\\n"\\/p
-b cont
-' <confdefs.h | sed '
-s/'"$ac_delim"'/"\\\
-"/g' >>$CONFIG_STATUS || ac_write_fail=1
-
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-  for (key in D) D_is_set[key] = 1
-  FS = ""
-}
-/^[\t ]*#[\t ]*(define|undef)[\t ]+$ac_word_re([\t (]|\$)/ {
-  line = \$ 0
-  split(line, arg, " ")
-  if (arg[1] == "#") {
-    defundef = arg[2]
-    mac1 = arg[3]
-  } else {
-    defundef = substr(arg[1], 2)
-    mac1 = arg[2]
-  }
-  split(mac1, mac2, "(") #)
-  macro = mac2[1]
-  prefix = substr(line, 1, index(line, defundef) - 1)
-  if (D_is_set[macro]) {
-    # Preserve the white space surrounding the "#".
-    print prefix "define", macro P[macro] D[macro]
-    next
-  } else {
-    # Replace #undef with comments.  This is necessary, for example,
-    # in the case of _POSIX_SOURCE, which is predefined and required
-    # on some systems where configure will not decide to define it.
-    if (defundef == "undef") {
-      print "/*", prefix defundef, macro, "*/"
-      next
-    }
-  }
-}
-{ print }
-_ACAWK
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-  as_fn_error $? "could not setup config headers machinery" "$LINENO" 5
-fi # test -n "$CONFIG_HEADERS"
-
-
-eval set X "  :F $CONFIG_FILES  :H $CONFIG_HEADERS    :C $CONFIG_COMMANDS"
-shift
-for ac_tag
-do
-  case $ac_tag in
-  :[FHLC]) ac_mode=$ac_tag; continue;;
-  esac
-  case $ac_mode$ac_tag in
-  :[FHL]*:*);;
-  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5;;
-  :[FH]-) ac_tag=-:-;;
-  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
-  esac
-  ac_save_IFS=$IFS
-  IFS=:
-  set x $ac_tag
-  IFS=$ac_save_IFS
-  shift
-  ac_file=$1
-  shift
-
-  case $ac_mode in
-  :L) ac_source=$1;;
-  :[FH])
-    ac_file_inputs=
-    for ac_f
-    do
-      case $ac_f in
-      -) ac_f="$ac_tmp/stdin";;
-      *) # Look for the file first in the build tree, then in the source tree
-	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
-	 # because $ac_f cannot contain `:'.
-	 test -f "$ac_f" ||
-	   case $ac_f in
-	   [\\/$]*) false;;
-	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
-	   esac ||
-	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
-      esac
-      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
-      as_fn_append ac_file_inputs " '$ac_f'"
-    done
-
-    # Let's still pretend it is `configure' which instantiates (i.e., don't
-    # use $as_me), people would be surprised to read:
-    #    /* config.h.  Generated by config.status.  */
-    configure_input='Generated from '`
-	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
-	`' by configure.'
-    if test x"$ac_file" != x-; then
-      configure_input="$ac_file.  $configure_input"
-      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
-$as_echo "$as_me: creating $ac_file" >&6;}
-    fi
-    # Neutralize special characters interpreted by sed in replacement strings.
-    case $configure_input in #(
-    *\&* | *\|* | *\\* )
-       ac_sed_conf_input=`$as_echo "$configure_input" |
-       sed 's/[\\\\&|]/\\\\&/g'`;; #(
-    *) ac_sed_conf_input=$configure_input;;
-    esac
-
-    case $ac_tag in
-    *:-:* | *:-) cat >"$ac_tmp/stdin" \
-      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
-    esac
-    ;;
-  esac
-
-  ac_dir=`$as_dirname -- "$ac_file" ||
-$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$ac_file" : 'X\(//\)[^/]' \| \
-	 X"$ac_file" : 'X\(//\)$' \| \
-	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$ac_file" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-  as_dir="$ac_dir"; as_fn_mkdir_p
-  ac_builddir=.
-
-case "$ac_dir" in
-.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
-*)
-  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
-  # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
-  case $ac_top_builddir_sub in
-  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
-  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
-  esac ;;
-esac
-ac_abs_top_builddir=$ac_pwd
-ac_abs_builddir=$ac_pwd$ac_dir_suffix
-# for backward compatibility:
-ac_top_builddir=$ac_top_build_prefix
-
-case $srcdir in
-  .)  # We are building in place.
-    ac_srcdir=.
-    ac_top_srcdir=$ac_top_builddir_sub
-    ac_abs_top_srcdir=$ac_pwd ;;
-  [\\/]* | ?:[\\/]* )  # Absolute name.
-    ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir
-    ac_abs_top_srcdir=$srcdir ;;
-  *) # Relative name.
-    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_build_prefix$srcdir
-    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
-esac
-ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
-
-
-  case $ac_mode in
-  :F)
-  #
-  # CONFIG_FILE
-  #
-
-  case $INSTALL in
-  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
-  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
-  esac
-  ac_MKDIR_P=$MKDIR_P
-  case $MKDIR_P in
-  [\\/$]* | ?:[\\/]* ) ;;
-  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
-  esac
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-# If the template does not know about datarootdir, expand it.
-# FIXME: This hack should be removed a few years after 2.60.
-ac_datarootdir_hack=; ac_datarootdir_seen=
-ac_sed_dataroot='
-/datarootdir/ {
-  p
-  q
-}
-/@datadir@/p
-/@docdir@/p
-/@infodir@/p
-/@localedir@/p
-/@mandir@/p'
-case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
-*datarootdir*) ac_datarootdir_seen=yes;;
-*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
-$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-  ac_datarootdir_hack='
-  s&@datadir@&$datadir&g
-  s&@docdir@&$docdir&g
-  s&@infodir@&$infodir&g
-  s&@localedir@&$localedir&g
-  s&@mandir@&$mandir&g
-  s&\\\${datarootdir}&$datarootdir&g' ;;
-esac
-_ACEOF
-
-# Neutralize VPATH when `$srcdir' = `.'.
-# Shell code in configure.ac might set extrasub.
-# FIXME: do we really want to maintain this feature?
-cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-ac_sed_extra="$ac_vpsub
-$extrasub
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
-:t
-/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
-s|@configure_input@|$ac_sed_conf_input|;t t
-s&@top_builddir@&$ac_top_builddir_sub&;t t
-s&@top_build_prefix@&$ac_top_build_prefix&;t t
-s&@srcdir@&$ac_srcdir&;t t
-s&@abs_srcdir@&$ac_abs_srcdir&;t t
-s&@top_srcdir@&$ac_top_srcdir&;t t
-s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
-s&@builddir@&$ac_builddir&;t t
-s&@abs_builddir@&$ac_abs_builddir&;t t
-s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
-s&@INSTALL@&$ac_INSTALL&;t t
-s&@MKDIR_P@&$ac_MKDIR_P&;t t
-$ac_datarootdir_hack
-"
-eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
-  >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5
-
-test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
-  { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
-  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
-      "$ac_tmp/out"`; test -z "$ac_out"; } &&
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined" >&5
-$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined" >&2;}
-
-  rm -f "$ac_tmp/stdin"
-  case $ac_file in
-  -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
-  *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
-  esac \
-  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
- ;;
-  :H)
-  #
-  # CONFIG_HEADER
-  #
-  if test x"$ac_file" != x-; then
-    {
-      $as_echo "/* $configure_input  */" \
-      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs"
-    } >"$ac_tmp/config.h" \
-      || as_fn_error $? "could not create $ac_file" "$LINENO" 5
-    if diff "$ac_file" "$ac_tmp/config.h" >/dev/null 2>&1; then
-      { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
-$as_echo "$as_me: $ac_file is unchanged" >&6;}
-    else
-      rm -f "$ac_file"
-      mv "$ac_tmp/config.h" "$ac_file" \
-	|| as_fn_error $? "could not create $ac_file" "$LINENO" 5
-    fi
-  else
-    $as_echo "/* $configure_input  */" \
-      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs" \
-      || as_fn_error $? "could not create -" "$LINENO" 5
-  fi
-# Compute "$ac_file"'s index in $config_headers.
-_am_arg="$ac_file"
-_am_stamp_count=1
-for _am_header in $config_headers :; do
-  case $_am_header in
-    $_am_arg | $_am_arg:* )
-      break ;;
-    * )
-      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
-  esac
-done
-echo "timestamp for $_am_arg" >`$as_dirname -- "$_am_arg" ||
-$as_expr X"$_am_arg" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$_am_arg" : 'X\(//\)[^/]' \| \
-	 X"$_am_arg" : 'X\(//\)$' \| \
-	 X"$_am_arg" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$_am_arg" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`/stamp-h$_am_stamp_count
- ;;
-
-  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
-$as_echo "$as_me: executing $ac_file commands" >&6;}
- ;;
-  esac
-
-
-  case $ac_file$ac_mode in
-    "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
-  # Autoconf 2.62 quotes --file arguments for eval, but not when files
-  # are listed without --file.  Let's play safe and only enable the eval
-  # if we detect the quoting.
-  case $CONFIG_FILES in
-  *\'*) eval set x "$CONFIG_FILES" ;;
-  *)   set x $CONFIG_FILES ;;
-  esac
-  shift
-  for mf
-  do
-    # Strip MF so we end up with the name of the file.
-    mf=`echo "$mf" | sed -e 's/:.*$//'`
-    # Check whether this is an Automake generated Makefile or not.
-    # We used to match only the files named `Makefile.in', but
-    # some people rename them; so instead we look at the file content.
-    # Grep'ing the first line is not enough: some people post-process
-    # each Makefile.in and add a new line on top of each file to say so.
-    # Grep'ing the whole file is not good either: AIX grep has a line
-    # limit of 2048, but all sed's we know have understand at least 4000.
-    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
-      dirpart=`$as_dirname -- "$mf" ||
-$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$mf" : 'X\(//\)[^/]' \| \
-	 X"$mf" : 'X\(//\)$' \| \
-	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$mf" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-    else
-      continue
-    fi
-    # Extract the definition of DEPDIR, am__include, and am__quote
-    # from the Makefile without running `make'.
-    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
-    test -z "$DEPDIR" && continue
-    am__include=`sed -n 's/^am__include = //p' < "$mf"`
-    test -z "am__include" && continue
-    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-    # When using ansi2knr, U may be empty or an underscore; expand it
-    U=`sed -n 's/^U = //p' < "$mf"`
-    # Find all dependency output files, they are included files with
-    # $(DEPDIR) in their names.  We invoke sed twice because it is the
-    # simplest approach to changing $(DEPDIR) to its actual value in the
-    # expansion.
-    for file in `sed -n "
-      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
-	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
-      # Make sure the directory exists.
-      test -f "$dirpart/$file" && continue
-      fdir=`$as_dirname -- "$file" ||
-$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$file" : 'X\(//\)[^/]' \| \
-	 X"$file" : 'X\(//\)$' \| \
-	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
-$as_echo X"$file" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      as_dir=$dirpart/$fdir; as_fn_mkdir_p
-      # echo "creating $dirpart/$file"
-      echo '# dummy' > "$dirpart/$file"
-    done
-  done
-}
- ;;
-    "libtool":C)
-
-    # See if we are running on zsh, and set the options which allow our
-    # commands through without removal of \ escapes.
-    if test -n "${ZSH_VERSION+set}" ; then
-      setopt NO_GLOB_SUBST
-    fi
-
-    cfgfile="${ofile}T"
-    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
-    $RM "$cfgfile"
-
-    cat <<_LT_EOF >> "$cfgfile"
-#! $SHELL
-
-# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
-# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
-# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
-# NOTE: Changes made to this file will be lost: look at ltmain.sh.
-#
-#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
-#                 2006, 2007, 2008, 2009, 2010 Free Software Foundation,
-#                 Inc.
-#   Written by Gordon Matzigkeit, 1996
-#
-#   This file is part of GNU Libtool.
-#
-# GNU Libtool is free software; you can redistribute it and/or
-# modify it under the terms of the GNU General Public License as
-# published by the Free Software Foundation; either version 2 of
-# the License, or (at your option) any later version.
-#
-# As a special exception to the GNU General Public License,
-# if you distribute this file as part of a program or library that
-# is built using GNU Libtool, you may include this file under the
-# same distribution terms that you use for the rest of that program.
-#
-# GNU Libtool is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with GNU Libtool; see the file COPYING.  If not, a copy
-# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
-# obtained by writing to the Free Software Foundation, Inc.,
-# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-
-
-# The names of the tagged configurations supported by this script.
-available_tags="CXX "
-
-# ### BEGIN LIBTOOL CONFIG
-
-# Which release of libtool.m4 was used?
-macro_version=$macro_version
-macro_revision=$macro_revision
-
-# Whether or not to build shared libraries.
-build_libtool_libs=$enable_shared
-
-# Whether or not to build static libraries.
-build_old_libs=$enable_static
-
-# What type of objects to build.
-pic_mode=$pic_mode
-
-# Whether or not to optimize for fast installation.
-fast_install=$enable_fast_install
-
-# Shell to use when invoking shell scripts.
-SHELL=$lt_SHELL
-
-# An echo program that protects backslashes.
-ECHO=$lt_ECHO
-
-# The host system.
-host_alias=$host_alias
-host=$host
-host_os=$host_os
-
-# The build system.
-build_alias=$build_alias
-build=$build
-build_os=$build_os
-
-# A sed program that does not truncate output.
-SED=$lt_SED
-
-# Sed that helps us avoid accidentally triggering echo(1) options like -n.
-Xsed="\$SED -e 1s/^X//"
-
-# A grep program that handles long lines.
-GREP=$lt_GREP
-
-# An ERE matcher.
-EGREP=$lt_EGREP
-
-# A literal string matcher.
-FGREP=$lt_FGREP
-
-# A BSD- or MS-compatible name lister.
-NM=$lt_NM
-
-# Whether we need soft or hard links.
-LN_S=$lt_LN_S
-
-# What is the maximum length of a command?
-max_cmd_len=$max_cmd_len
-
-# Object file suffix (normally "o").
-objext=$ac_objext
-
-# Executable file suffix (normally "").
-exeext=$exeext
-
-# whether the shell understands "unset".
-lt_unset=$lt_unset
-
-# turn spaces into newlines.
-SP2NL=$lt_lt_SP2NL
-
-# turn newlines into spaces.
-NL2SP=$lt_lt_NL2SP
-
-# convert \$build file names to \$host format.
-to_host_file_cmd=$lt_cv_to_host_file_cmd
-
-# convert \$build files to toolchain format.
-to_tool_file_cmd=$lt_cv_to_tool_file_cmd
-
-# An object symbol dumper.
-OBJDUMP=$lt_OBJDUMP
-
-# Method to check whether dependent libraries are shared objects.
-deplibs_check_method=$lt_deplibs_check_method
-
-# Command to use when deplibs_check_method = "file_magic".
-file_magic_cmd=$lt_file_magic_cmd
-
-# How to find potential files when deplibs_check_method = "file_magic".
-file_magic_glob=$lt_file_magic_glob
-
-# Find potential files using nocaseglob when deplibs_check_method = "file_magic".
-want_nocaseglob=$lt_want_nocaseglob
-
-# DLL creation program.
-DLLTOOL=$lt_DLLTOOL
-
-# Command to associate shared and link libraries.
-sharedlib_from_linklib_cmd=$lt_sharedlib_from_linklib_cmd
-
-# The archiver.
-AR=$lt_AR
-
-# Flags to create an archive.
-AR_FLAGS=$lt_AR_FLAGS
-
-# How to feed a file listing to the archiver.
-archiver_list_spec=$lt_archiver_list_spec
-
-# A symbol stripping program.
-STRIP=$lt_STRIP
-
-# Commands used to install an old-style archive.
-RANLIB=$lt_RANLIB
-old_postinstall_cmds=$lt_old_postinstall_cmds
-old_postuninstall_cmds=$lt_old_postuninstall_cmds
-
-# Whether to use a lock for old archive extraction.
-lock_old_archive_extraction=$lock_old_archive_extraction
-
-# A C compiler.
-LTCC=$lt_CC
-
-# LTCC compiler flags.
-LTCFLAGS=$lt_CFLAGS
-
-# Take the output of nm and produce a listing of raw symbols and C names.
-global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe
-
-# Transform the output of nm in a proper C declaration.
-global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl
-
-# Transform the output of nm in a C name address pair.
-global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address
-
-# Transform the output of nm in a C name address pair when lib prefix is needed.
-global_symbol_to_c_name_address_lib_prefix=$lt_lt_cv_sys_global_symbol_to_c_name_address_lib_prefix
-
-# Specify filename containing input files for \$NM.
-nm_file_list_spec=$lt_nm_file_list_spec
-
-# The root where to search for dependent libraries,and in which our libraries should be installed.
-lt_sysroot=$lt_sysroot
-
-# The name of the directory that contains temporary libtool files.
-objdir=$objdir
-
-# Used to examine libraries when file_magic_cmd begins with "file".
-MAGIC_CMD=$MAGIC_CMD
-
-# Must we lock files when doing compilation?
-need_locks=$lt_need_locks
-
-# Manifest tool.
-MANIFEST_TOOL=$lt_MANIFEST_TOOL
-
-# Tool to manipulate archived DWARF debug symbol files on Mac OS X.
-DSYMUTIL=$lt_DSYMUTIL
-
-# Tool to change global to local symbols on Mac OS X.
-NMEDIT=$lt_NMEDIT
-
-# Tool to manipulate fat objects and archives on Mac OS X.
-LIPO=$lt_LIPO
-
-# ldd/readelf like tool for Mach-O binaries on Mac OS X.
-OTOOL=$lt_OTOOL
-
-# ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4.
-OTOOL64=$lt_OTOOL64
-
-# Old archive suffix (normally "a").
-libext=$libext
-
-# Shared library suffix (normally ".so").
-shrext_cmds=$lt_shrext_cmds
-
-# The commands to extract the exported symbol list from a shared archive.
-extract_expsyms_cmds=$lt_extract_expsyms_cmds
-
-# Variables whose values should be saved in libtool wrapper scripts and
-# restored at link time.
-variables_saved_for_relink=$lt_variables_saved_for_relink
-
-# Do we need the "lib" prefix for modules?
-need_lib_prefix=$need_lib_prefix
-
-# Do we need a version for libraries?
-need_version=$need_version
-
-# Library versioning type.
-version_type=$version_type
-
-# Shared library runtime path variable.
-runpath_var=$runpath_var
-
-# Shared library path variable.
-shlibpath_var=$shlibpath_var
-
-# Is shlibpath searched before the hard-coded library search path?
-shlibpath_overrides_runpath=$shlibpath_overrides_runpath
-
-# Format of library name prefix.
-libname_spec=$lt_libname_spec
-
-# List of archive names.  First name is the real one, the rest are links.
-# The last name is the one that the linker finds with -lNAME
-library_names_spec=$lt_library_names_spec
-
-# The coded name of the library, if different from the real name.
-soname_spec=$lt_soname_spec
-
-# Permission mode override for installation of shared libraries.
-install_override_mode=$lt_install_override_mode
-
-# Command to use after installation of a shared archive.
-postinstall_cmds=$lt_postinstall_cmds
-
-# Command to use after uninstallation of a shared archive.
-postuninstall_cmds=$lt_postuninstall_cmds
-
-# Commands used to finish a libtool library installation in a directory.
-finish_cmds=$lt_finish_cmds
-
-# As "finish_cmds", except a single script fragment to be evaled but
-# not shown.
-finish_eval=$lt_finish_eval
-
-# Whether we should hardcode library paths into libraries.
-hardcode_into_libs=$hardcode_into_libs
-
-# Compile-time system search path for libraries.
-sys_lib_search_path_spec=$lt_sys_lib_search_path_spec
-
-# Run-time system search path for libraries.
-sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
-
-# Whether dlopen is supported.
-dlopen_support=$enable_dlopen
-
-# Whether dlopen of programs is supported.
-dlopen_self=$enable_dlopen_self
-
-# Whether dlopen of statically linked programs is supported.
-dlopen_self_static=$enable_dlopen_self_static
-
-# Commands to strip libraries.
-old_striplib=$lt_old_striplib
-striplib=$lt_striplib
-
-
-# The linker used to build libraries.
-LD=$lt_LD
-
-# How to create reloadable object files.
-reload_flag=$lt_reload_flag
-reload_cmds=$lt_reload_cmds
-
-# Commands used to build an old-style archive.
-old_archive_cmds=$lt_old_archive_cmds
-
-# A language specific compiler.
-CC=$lt_compiler
-
-# Is the compiler the GNU compiler?
-with_gcc=$GCC
-
-# Compiler flag to turn off builtin functions.
-no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag
-
-# Additional compiler flags for building library objects.
-pic_flag=$lt_lt_prog_compiler_pic
-
-# How to pass a linker flag through the compiler.
-wl=$lt_lt_prog_compiler_wl
-
-# Compiler flag to prevent dynamic linking.
-link_static_flag=$lt_lt_prog_compiler_static
-
-# Does compiler simultaneously support -c and -o options?
-compiler_c_o=$lt_lt_cv_prog_compiler_c_o
-
-# Whether or not to add -lc for building shared libraries.
-build_libtool_need_lc=$archive_cmds_need_lc
-
-# Whether or not to disallow shared libs when runtime libs are static.
-allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes
-
-# Compiler flag to allow reflexive dlopens.
-export_dynamic_flag_spec=$lt_export_dynamic_flag_spec
-
-# Compiler flag to generate shared objects directly from archives.
-whole_archive_flag_spec=$lt_whole_archive_flag_spec
-
-# Whether the compiler copes with passing no objects directly.
-compiler_needs_object=$lt_compiler_needs_object
-
-# Create an old-style archive from a shared archive.
-old_archive_from_new_cmds=$lt_old_archive_from_new_cmds
-
-# Create a temporary old-style archive to link instead of a shared archive.
-old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds
-
-# Commands used to build a shared archive.
-archive_cmds=$lt_archive_cmds
-archive_expsym_cmds=$lt_archive_expsym_cmds
-
-# Commands used to build a loadable module if different from building
-# a shared archive.
-module_cmds=$lt_module_cmds
-module_expsym_cmds=$lt_module_expsym_cmds
-
-# Whether we are building with GNU ld or not.
-with_gnu_ld=$lt_with_gnu_ld
-
-# Flag that allows shared libraries with undefined symbols to be built.
-allow_undefined_flag=$lt_allow_undefined_flag
-
-# Flag that enforces no undefined symbols.
-no_undefined_flag=$lt_no_undefined_flag
-
-# Flag to hardcode \$libdir into a binary during linking.
-# This must work even if \$libdir does not exist
-hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec
-
-# If ld is used when linking, flag to hardcode \$libdir into a binary
-# during linking.  This must work even if \$libdir does not exist.
-hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld
-
-# Whether we need a single "-rpath" flag with a separated argument.
-hardcode_libdir_separator=$lt_hardcode_libdir_separator
-
-# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
-# DIR into the resulting binary.
-hardcode_direct=$hardcode_direct
-
-# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
-# DIR into the resulting binary and the resulting library dependency is
-# "absolute",i.e impossible to change by setting \${shlibpath_var} if the
-# library is relocated.
-hardcode_direct_absolute=$hardcode_direct_absolute
-
-# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
-# into the resulting binary.
-hardcode_minus_L=$hardcode_minus_L
-
-# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
-# into the resulting binary.
-hardcode_shlibpath_var=$hardcode_shlibpath_var
-
-# Set to "yes" if building a shared library automatically hardcodes DIR
-# into the library and all subsequent libraries and executables linked
-# against it.
-hardcode_automatic=$hardcode_automatic
-
-# Set to yes if linker adds runtime paths of dependent libraries
-# to runtime path list.
-inherit_rpath=$inherit_rpath
-
-# Whether libtool must link a program against all its dependency libraries.
-link_all_deplibs=$link_all_deplibs
-
-# Set to "yes" if exported symbols are required.
-always_export_symbols=$always_export_symbols
-
-# The commands to list exported symbols.
-export_symbols_cmds=$lt_export_symbols_cmds
-
-# Symbols that should not be listed in the preloaded symbols.
-exclude_expsyms=$lt_exclude_expsyms
-
-# Symbols that must always be exported.
-include_expsyms=$lt_include_expsyms
-
-# Commands necessary for linking programs (against libraries) with templates.
-prelink_cmds=$lt_prelink_cmds
-
-# Commands necessary for finishing linking programs.
-postlink_cmds=$lt_postlink_cmds
-
-# Specify filename containing input files.
-file_list_spec=$lt_file_list_spec
-
-# How to hardcode a shared library path into an executable.
-hardcode_action=$hardcode_action
-
-# The directories searched by this compiler when creating a shared library.
-compiler_lib_search_dirs=$lt_compiler_lib_search_dirs
-
-# Dependencies to place before and after the objects being linked to
-# create a shared library.
-predep_objects=$lt_predep_objects
-postdep_objects=$lt_postdep_objects
-predeps=$lt_predeps
-postdeps=$lt_postdeps
-
-# The library search path used internally by the compiler when linking
-# a shared library.
-compiler_lib_search_path=$lt_compiler_lib_search_path
-
-# ### END LIBTOOL CONFIG
-
-_LT_EOF
-
-  case $host_os in
-  aix3*)
-    cat <<\_LT_EOF >> "$cfgfile"
-# AIX sometimes has problems with the GCC collect2 program.  For some
-# reason, if we set the COLLECT_NAMES environment variable, the problems
-# vanish in a puff of smoke.
-if test "X${COLLECT_NAMES+set}" != Xset; then
-  COLLECT_NAMES=
-  export COLLECT_NAMES
-fi
-_LT_EOF
-    ;;
-  esac
-
-
-ltmain="$ac_aux_dir/ltmain.sh"
-
-
-  # We use sed instead of cat because bash on DJGPP gets confused if
-  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
-  # text mode, it properly converts lines to CR/LF.  This bash problem
-  # is reportedly fixed, but why not run on old versions too?
-  sed '$q' "$ltmain" >> "$cfgfile" \
-     || (rm -f "$cfgfile"; exit 1)
-
-  if test x"$xsi_shell" = xyes; then
-  sed -e '/^func_dirname ()$/,/^} # func_dirname /c\
-func_dirname ()\
-{\
-\    case ${1} in\
-\      */*) func_dirname_result="${1%/*}${2}" ;;\
-\      *  ) func_dirname_result="${3}" ;;\
-\    esac\
-} # Extended-shell func_dirname implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_basename ()$/,/^} # func_basename /c\
-func_basename ()\
-{\
-\    func_basename_result="${1##*/}"\
-} # Extended-shell func_basename implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_dirname_and_basename ()$/,/^} # func_dirname_and_basename /c\
-func_dirname_and_basename ()\
-{\
-\    case ${1} in\
-\      */*) func_dirname_result="${1%/*}${2}" ;;\
-\      *  ) func_dirname_result="${3}" ;;\
-\    esac\
-\    func_basename_result="${1##*/}"\
-} # Extended-shell func_dirname_and_basename implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_stripname ()$/,/^} # func_stripname /c\
-func_stripname ()\
-{\
-\    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are\
-\    # positional parameters, so assign one to ordinary parameter first.\
-\    func_stripname_result=${3}\
-\    func_stripname_result=${func_stripname_result#"${1}"}\
-\    func_stripname_result=${func_stripname_result%"${2}"}\
-} # Extended-shell func_stripname implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_split_long_opt ()$/,/^} # func_split_long_opt /c\
-func_split_long_opt ()\
-{\
-\    func_split_long_opt_name=${1%%=*}\
-\    func_split_long_opt_arg=${1#*=}\
-} # Extended-shell func_split_long_opt implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_split_short_opt ()$/,/^} # func_split_short_opt /c\
-func_split_short_opt ()\
-{\
-\    func_split_short_opt_arg=${1#??}\
-\    func_split_short_opt_name=${1%"$func_split_short_opt_arg"}\
-} # Extended-shell func_split_short_opt implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_lo2o ()$/,/^} # func_lo2o /c\
-func_lo2o ()\
-{\
-\    case ${1} in\
-\      *.lo) func_lo2o_result=${1%.lo}.${objext} ;;\
-\      *)    func_lo2o_result=${1} ;;\
-\    esac\
-} # Extended-shell func_lo2o implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_xform ()$/,/^} # func_xform /c\
-func_xform ()\
-{\
-    func_xform_result=${1%.*}.lo\
-} # Extended-shell func_xform implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_arith ()$/,/^} # func_arith /c\
-func_arith ()\
-{\
-    func_arith_result=$(( $* ))\
-} # Extended-shell func_arith implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_len ()$/,/^} # func_len /c\
-func_len ()\
-{\
-    func_len_result=${#1}\
-} # Extended-shell func_len implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-fi
-
-if test x"$lt_shell_append" = xyes; then
-  sed -e '/^func_append ()$/,/^} # func_append /c\
-func_append ()\
-{\
-    eval "${1}+=\\${2}"\
-} # Extended-shell func_append implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  sed -e '/^func_append_quoted ()$/,/^} # func_append_quoted /c\
-func_append_quoted ()\
-{\
-\    func_quote_for_eval "${2}"\
-\    eval "${1}+=\\\\ \\$func_quote_for_eval_result"\
-} # Extended-shell func_append_quoted implementation' "$cfgfile" > $cfgfile.tmp \
-  && mv -f "$cfgfile.tmp" "$cfgfile" \
-    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-test 0 -eq $? || _lt_function_replace_fail=:
-
-
-  # Save a `func_append' function call where possible by direct use of '+='
-  sed -e 's%func_append \([a-zA-Z_]\{1,\}\) "%\1+="%g' $cfgfile > $cfgfile.tmp \
-    && mv -f "$cfgfile.tmp" "$cfgfile" \
-      || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-  test 0 -eq $? || _lt_function_replace_fail=:
-else
-  # Save a `func_append' function call even when '+=' is not available
-  sed -e 's%func_append \([a-zA-Z_]\{1,\}\) "%\1="$\1%g' $cfgfile > $cfgfile.tmp \
-    && mv -f "$cfgfile.tmp" "$cfgfile" \
-      || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
-  test 0 -eq $? || _lt_function_replace_fail=:
-fi
-
-if test x"$_lt_function_replace_fail" = x":"; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Unable to substitute extended shell functions in $ofile" >&5
-$as_echo "$as_me: WARNING: Unable to substitute extended shell functions in $ofile" >&2;}
-fi
-
-
-   mv -f "$cfgfile" "$ofile" ||
-    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
-  chmod +x "$ofile"
-
-
-    cat <<_LT_EOF >> "$ofile"
-
-# ### BEGIN LIBTOOL TAG CONFIG: CXX
-
-# The linker used to build libraries.
-LD=$lt_LD_CXX
-
-# How to create reloadable object files.
-reload_flag=$lt_reload_flag_CXX
-reload_cmds=$lt_reload_cmds_CXX
-
-# Commands used to build an old-style archive.
-old_archive_cmds=$lt_old_archive_cmds_CXX
-
-# A language specific compiler.
-CC=$lt_compiler_CXX
-
-# Is the compiler the GNU compiler?
-with_gcc=$GCC_CXX
-
-# Compiler flag to turn off builtin functions.
-no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag_CXX
-
-# Additional compiler flags for building library objects.
-pic_flag=$lt_lt_prog_compiler_pic_CXX
-
-# How to pass a linker flag through the compiler.
-wl=$lt_lt_prog_compiler_wl_CXX
-
-# Compiler flag to prevent dynamic linking.
-link_static_flag=$lt_lt_prog_compiler_static_CXX
-
-# Does compiler simultaneously support -c and -o options?
-compiler_c_o=$lt_lt_cv_prog_compiler_c_o_CXX
-
-# Whether or not to add -lc for building shared libraries.
-build_libtool_need_lc=$archive_cmds_need_lc_CXX
-
-# Whether or not to disallow shared libs when runtime libs are static.
-allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes_CXX
-
-# Compiler flag to allow reflexive dlopens.
-export_dynamic_flag_spec=$lt_export_dynamic_flag_spec_CXX
-
-# Compiler flag to generate shared objects directly from archives.
-whole_archive_flag_spec=$lt_whole_archive_flag_spec_CXX
-
-# Whether the compiler copes with passing no objects directly.
-compiler_needs_object=$lt_compiler_needs_object_CXX
-
-# Create an old-style archive from a shared archive.
-old_archive_from_new_cmds=$lt_old_archive_from_new_cmds_CXX
-
-# Create a temporary old-style archive to link instead of a shared archive.
-old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds_CXX
-
-# Commands used to build a shared archive.
-archive_cmds=$lt_archive_cmds_CXX
-archive_expsym_cmds=$lt_archive_expsym_cmds_CXX
-
-# Commands used to build a loadable module if different from building
-# a shared archive.
-module_cmds=$lt_module_cmds_CXX
-module_expsym_cmds=$lt_module_expsym_cmds_CXX
-
-# Whether we are building with GNU ld or not.
-with_gnu_ld=$lt_with_gnu_ld_CXX
-
-# Flag that allows shared libraries with undefined symbols to be built.
-allow_undefined_flag=$lt_allow_undefined_flag_CXX
-
-# Flag that enforces no undefined symbols.
-no_undefined_flag=$lt_no_undefined_flag_CXX
-
-# Flag to hardcode \$libdir into a binary during linking.
-# This must work even if \$libdir does not exist
-hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec_CXX
-
-# If ld is used when linking, flag to hardcode \$libdir into a binary
-# during linking.  This must work even if \$libdir does not exist.
-hardcode_libdir_flag_spec_ld=$lt_hardcode_libdir_flag_spec_ld_CXX
-
-# Whether we need a single "-rpath" flag with a separated argument.
-hardcode_libdir_separator=$lt_hardcode_libdir_separator_CXX
-
-# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
-# DIR into the resulting binary.
-hardcode_direct=$hardcode_direct_CXX
-
-# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
-# DIR into the resulting binary and the resulting library dependency is
-# "absolute",i.e impossible to change by setting \${shlibpath_var} if the
-# library is relocated.
-hardcode_direct_absolute=$hardcode_direct_absolute_CXX
-
-# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
-# into the resulting binary.
-hardcode_minus_L=$hardcode_minus_L_CXX
-
-# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
-# into the resulting binary.
-hardcode_shlibpath_var=$hardcode_shlibpath_var_CXX
-
-# Set to "yes" if building a shared library automatically hardcodes DIR
-# into the library and all subsequent libraries and executables linked
-# against it.
-hardcode_automatic=$hardcode_automatic_CXX
-
-# Set to yes if linker adds runtime paths of dependent libraries
-# to runtime path list.
-inherit_rpath=$inherit_rpath_CXX
-
-# Whether libtool must link a program against all its dependency libraries.
-link_all_deplibs=$link_all_deplibs_CXX
-
-# Set to "yes" if exported symbols are required.
-always_export_symbols=$always_export_symbols_CXX
-
-# The commands to list exported symbols.
-export_symbols_cmds=$lt_export_symbols_cmds_CXX
-
-# Symbols that should not be listed in the preloaded symbols.
-exclude_expsyms=$lt_exclude_expsyms_CXX
-
-# Symbols that must always be exported.
-include_expsyms=$lt_include_expsyms_CXX
-
-# Commands necessary for linking programs (against libraries) with templates.
-prelink_cmds=$lt_prelink_cmds_CXX
-
-# Commands necessary for finishing linking programs.
-postlink_cmds=$lt_postlink_cmds_CXX
-
-# Specify filename containing input files.
-file_list_spec=$lt_file_list_spec_CXX
-
-# How to hardcode a shared library path into an executable.
-hardcode_action=$hardcode_action_CXX
-
-# The directories searched by this compiler when creating a shared library.
-compiler_lib_search_dirs=$lt_compiler_lib_search_dirs_CXX
-
-# Dependencies to place before and after the objects being linked to
-# create a shared library.
-predep_objects=$lt_predep_objects_CXX
-postdep_objects=$lt_postdep_objects_CXX
-predeps=$lt_predeps_CXX
-postdeps=$lt_postdeps_CXX
-
-# The library search path used internally by the compiler when linking
-# a shared library.
-compiler_lib_search_path=$lt_compiler_lib_search_path_CXX
-
-# ### END LIBTOOL TAG CONFIG: CXX
-_LT_EOF
-
- ;;
-
-  esac
-done # for ac_tag
-
-
-as_fn_exit 0
-_ACEOF
-ac_clean_files=$ac_clean_files_save
-
-test $ac_write_fail = 0 ||
-  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5
-
-
-# configure is writing to config.log, and then calls config.status.
-# config.status does its own redirection, appending to config.log.
-# Unfortunately, on DOS this fails, as config.log is still kept open
-# by configure, so config.status won't be able to write to it; its
-# output is simply discarded.  So we exec the FD to /dev/null,
-# effectively closing config.log, so it can be properly (re)opened and
-# appended to by config.status.  When coming back to configure, we
-# need to make the FD available again.
-if test "$no_create" != yes; then
-  ac_cs_success=:
-  ac_config_status_args=
-  test "$silent" = yes &&
-    ac_config_status_args="$ac_config_status_args --quiet"
-  exec 5>/dev/null
-  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
-  exec 5>>config.log
-  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
-  # would make configure fail if this is the last instruction.
-  $ac_cs_success || as_fn_exit 1
-fi
-if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
-$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
-fi
-
-
-
-echo "
-                  GDL - GNU Data Language
-  ----- compilation options: ---------------------------
-  System:              $host
-  Installation prefix: $prefix
-  C++ compiler:        $CXX $CXXFLAGS
-  OpenMP support:      `if test "x$with_openmp" = "xno";
-    then echo 'no'; else echo 'yes'; fi`
-  Build type:          `if test "x$PYTHON_MODULE" = "xyes";
-    then echo 'library (Python module)'; else echo 'standalone (other: Python module)'; fi`
-  ----- optional libraries (consult README/INSTALL): ---
-  wxWidgets:           `if test no = $with_wxWidgets;
-    then echo 'no'; else echo yes; fi`
-  Magick:              `if test no = $with_Magick;
-    then echo 'no'; else echo yes; fi`
-  NetCDF:              `if test no = $with_netcdf;
-    then echo 'no'; else echo yes; fi`
-  HDF4:                `if test no = $with_hdf;
-    then echo 'no'; else echo yes; fi`
-  HDF5:                `if test no = $with_hdf5;
-    then echo 'no'; else echo yes; fi`
-  FFTW:                `if test no = $with_fftw;
-    then echo 'no  (GSL version used)'; else echo yes; fi`
-  libproject:          `if test no = $with_libproj4;
-    then echo 'no  (see also MAP_INSTALL)'; else echo yes; fi`
-  MPICH:               `if test no = $with_mpich;
-    then echo 'no  (needs explicit enabling)'; else echo yes; fi`
-  Python:              `if test no = $with_python;
-    then echo 'no  (see also PYTHON.txt)'; else echo \"yes ($PYTHON_VERSION)\"; fi`
-  UDUNITS-2:           `if test no = $with_udunits;
-    then echo 'no  (needs explicit enabling)'; else echo yes; fi`
-  GRIB:                `if test no = $with_grib;
-    then echo 'no  (needs explicit enabling)'; else echo yes; fi`
-  GSHHS:               `if test no = $with_gshhs;
-    then echo 'no  (see also MAP_INSTALL)'; else echo yes; fi`
-  Xlib:                `if test xyes = x$no_x;
-    then echo 'no'; else echo yes; fi`
-  pslib:               `if test no = $with_pslib;
-    then echo 'no'; else echo yes; fi`
-  ----- notes on auxiliary files: ----------------------
-  - consult MAP_INSTALL for details concerning auxiliary
-    files needed for mapping support
-  - SAVE and RESTORE procedures require *.pro files from
-    the CMSVLIB package (see README for details)
-  ------------------------------------------------------
-`if test yes = $openmp_autodetected; then
-  echo '  ----- note on OpenMP support -------------------------'
-  echo '   OpenMP was autodetected, use --with-openmp=no if your'
-  echo '   compiler does not support it (e.g. GCC < 4.2)'
-  echo '  ------------------------------------------------------'; fi`
-  use 'make' to build and 'make install' to install GDL
-  (optional 'make check' tests the build - experimental)
-"
-
diff -ruN --exclude CVS gdl-0.9.2/configure.in gdl/configure.in
--- gdl-0.9.2/configure.in	2011-11-08 16:44:26.000000000 -0700
+++ gdl/configure.in	2012-05-10 03:21:15.000000000 -0600
@@ -1,4 +1,4 @@
-AC_INIT(gdl, 0.9.2)
+AC_INIT(gdl, 0.9.2 CVS)
 AC_CONFIG_MACRO_DIR([m4])
 
 dnl == Configuration (of the configure script)  ============
@@ -15,6 +15,7 @@
 if test "x$with_udunits"     = "x"; then with_udunits=no;      fi
 if test "x$with_grib"        = "x"; then with_grib=no;         fi
 if test "x$with_Magick"      = "x"; then with_Magick=yes;      fi
+if test "x$with_GraphicsMagick" = "x"; then with_GraphicsMagick=no;      fi
 if test "x$with_netcdf"      = "x"; then with_netcdf=yes;      fi
 if test "x$with_hdf"         = "x"; then with_hdf=yes;         fi
 if test "x$with_hdf5"        = "x"; then with_hdf5=yes;        fi
@@ -143,6 +144,7 @@
 	echo "       Check the README or use configure --help for other libraries needed"
         echo ""
         echo "       (suitable Debian/Ubuntu package: libreadline5-dev)"
+        echo "       (suitable Fedora package: readline-devel)"
 	exit -1
 	])
 
@@ -187,6 +189,7 @@
  	echo "       Use --with-zlibdir=DIR to specify the zlib directory tree"
         echo ""
         echo "       (suitable Debian/Ubuntu package: zlib1g-dev)"
+        echo "       (suitable Fedora package: zlib-devel)"
  	exit -1
  	])
 
@@ -260,6 +263,7 @@
 	echo "Error! Gnu Scientific Library (1.7 or higher) is mandatory"
         echo ""
         echo "       (suitable Debian/Ubuntu package: libgsl0-dev)"
+        echo "       (suitable Fedora package: gsl-dev)"
         exit -1
 	])
 AC_CHECK_LIB(gslcblas, cblas_drot, [], [
@@ -312,6 +316,7 @@
 	echo "       Use --with-plplot=DIR to specify the plplot directory tree"
         echo ""
         echo "       (suitable Debian/Ubuntu packages: libplplot-dev, [plplot9-driver-xwin])"
+        echo "       (suitable Fedora package: plplot-devel)"
 	exit -1
 	])
 
@@ -353,6 +358,7 @@
     echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
     echo ""
     echo "       (suitable Debian/Ubuntu package: libwxgtk2.8-dev)"
+    echo "       (suitable Fedora package: wxGTK-devel)"
     exit -1
   else
     LIBS="$LIBS `wx-config --libs`"
@@ -403,6 +409,7 @@
       Use --with-Magick=no  to not use it
     
       (suitable Debian/Ubuntu package: libmagick++-dev)
+      (suitable Fedora package: ImageMagick-c++-devel)
     )
   else
     LIBS="$LIBS `$MagickConfig --libs`"
@@ -426,7 +433,59 @@
         echo "       Check the README or use configure --help for other libraries needed"
         echo "       (--with-xxxdir = mandatory, --with-xxx = optional (--with-xxx=no to disable))"
         echo ""
-        echo "       (suitable Debian/Ubuntu package: libmagick-dev)"
+        echo "       (suitable Debian/Ubuntu package: libmagick++-dev)"
+        echo "       (suitable Fedora package: ImageMagick-c++-devel)"
+        exit -1
+      ])
+    ]
+  )
+fi
+dnl == GraphicsMagick ======================================
+dnl ========================================================
+ 
+AC_ARG_WITH(GraphicsMagick,	
+	[  --with-GraphicsMagick[=DIR]  use GraphicsMagick package (with optional path DIR) ],
+	[with_GraphicsMagick="$withval" ])
+
+if test "x$with_GraphicsMagick" != "xno"; then
+  if test "x$with_GraphicsMagick" = "xyes"; then
+    AC_PATH_PROG(GraphicsMagickConfig, GraphicsMagick++-config, no)
+  else
+    AC_PATH_PROG(GraphicsMagickConfig, GraphicsMagick++-config, no, "$with_GraphicsMagick/bin")
+  fi
+
+  if test "x$GraphicsMagickConfig" = "xno"; then
+    AC_MSG_ERROR(GraphicsMagick is required but was not found (GraphicsMagick++-config program not found)
+      Use --with-GraphicsMagick=DIR to specify the GraphicsMagick directory tree
+      Use --with-GraphicsMagick=no  to not use it
+    
+      (suitable Debian/Ubuntu package: libmagick++-dev)
+      (suitable Fedora package: GraphicsMagick-c++-devel)
+    )
+  else
+    LIBS="$LIBS `$GraphicsMagickConfig --libs`"
+    INCLUDES="$INCLUDES `$GraphicsMagickConfig --cppflags`"
+    LDFLAGS="$LDFLAGS `$GraphicsMagickConfig --ldflags`"
+  fi
+
+  AC_CHECK_LIB(
+    GraphicsMagick++, 
+    GetMagickVersion, 
+    [AC_DEFINE([USE_MAGICK], [1], [Define if you want to use GraphicsMagick])], [
+      AC_MSG_CHECKING(if adding X library path helps)
+      AC_MSG_RESULT(?)
+      AC_PATH_X
+      LDFLAGS="$LDFLAGS -L$x_libraries"
+      AC_CHECK_LIB(GraphicsMagick++, GetMagickReleaseDate, AC_DEFINE([USE_MAGICK], [1]), [
+        echo ""
+        echo "Error! GraphicsMagick version 1.3 or later is required but was not found"
+        echo "       Use --with-GraphicsMagick=DIR to specify the GraphicsMagick directory tree"
+        echo "       Use --with-GraphicsMagick=no  to not use it"
+        echo "       Check the README or use configure --help for other libraries needed"
+        echo "       (--with-xxxdir = mandatory, --with-xxx = optional (--with-xxx=no to disable))"
+        echo ""
+        echo "       (suitable Debian/Ubuntu package: libgraphicsmagick++-dev)"
+        echo "       (suitable Fedora package: graphicsMagick-c++-devel)"
         exit -1
       ])
     ]
@@ -472,6 +531,7 @@
     echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
     echo ""
     echo "       (suitable Debian/Ubuntu package: libnetcdf-dev)"
+    echo "       (suitable Fedora package: netcdf-devel)"
     exit -1
     ])
 
@@ -597,6 +657,7 @@
     echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
     echo ""
     echo "       (suitable Debian/Ubuntu package: libhdf5-serial-dev)"
+    echo "       (suitable Fedora package: hdf-devel)"
     exit -1
     ], [-lsz]))
 fi
@@ -632,6 +693,7 @@
     echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
     echo ""
     echo "       (suitable Debian/Ubuntu package: libfftw3-dev)"
+    echo "       (suitable Fedora package: fftw-devel)"
     exit -1
     ])
 fi
@@ -762,6 +824,7 @@
     echo "       Use --with-python=no  to not use it"
     echo ""
     echo "       (suitable Debian/Ubuntu package: python$PYTHON_VERSION-dev)"
+    echo "       (suitable Fedora package: python-devel)"
     exit -1
     ])
 
@@ -816,6 +879,7 @@
     echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
     echo ""
     echo "       (suitable Debian/Ubuntu package: libudunits2-dev)"
+    echo "       (suitable Fedora package: udunits2-devel)"
     exit -1
     ])
   AC_CHECK_HEADERS(udunits2/udunits2.h)
@@ -866,6 +930,7 @@
             echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
             echo ""
             echo "       (suitable Debian/Ubuntu package: libgrib-api-dev)"
+            echo "       (suitable Fedora package: grib_api-devel)"
             exit -1
           ], [-ljasper -lopenjpeg -lpng])
         ], [-ljasper -lopenjpeg])
@@ -939,6 +1004,7 @@
     echo "       (--with-xxxdir = obligatory, --with-xxx = optional (--with-xxx=no to disable))"
     echo ""
     echo "       (suitable Debian/Ubuntu package: pslib-dev)"
+    echo "       (suitable Fedora package: pslib-devel)"
     exit -1
   ])
 
@@ -1129,6 +1195,8 @@
     then echo 'no'; else echo yes; fi`
   Magick:              `if test no = $with_Magick;
     then echo 'no'; else echo yes; fi`
+  GraphicsMagick:      `if test no = $with_GraphicsMagick;
+    then echo 'no'; else echo yes; fi`
   NetCDF:              `if test no = $with_netcdf;
     then echo 'no'; else echo yes; fi`
   HDF4:                `if test no = $with_hdf;
@@ -1167,5 +1235,14 @@
   use 'make' to build and 'make install' to install GDL
   (optional 'make check' tests the build - experimental)
 "
+echo "
+*********************** WARNING ******************************
+We plan to drop support for Autotools-based configuration
+(i.e. the configure script) and switch to CMake. If possible,
+please try to compile GDL with CMake (e.g. by typing \"cmake .\"
+instead of \"./configure\") and please do report any problems.
+Consult INSTALL.CMake for help on passing options to CMake.
+**************************************************************
+"
 
 dnl == EOF =================================================
diff -ruN --exclude CVS gdl-0.9.2/doc/gdl.1 gdl/doc/gdl.1
--- gdl-0.9.2/doc/gdl.1	2011-10-12 17:44:01.000000000 -0600
+++ gdl/doc/gdl.1	2012-01-02 14:22:15.000000000 -0700
@@ -1,4 +1,4 @@
-.TH GDL 1 "2011-10-01" "The GDL Team"
+.TH GDL 1 "2011-12-27" "The GDL Team"
 .SH NAME
 gdl \- GNU Data Language incremental compiler
 .SH SYNOPSIS
@@ -38,7 +38,7 @@
 
 Information on GDL/IDL/PV-WAVE syntax and library routines can be found in e.g.:
 
-- Getting started with GDL by Sven Geier: http://www.sgeier.net/tools/GDL-intro.pdf
+- GDL documentation draft at: http://gnudatalanguage.sf.net/gdl.pdf
 
 - IDL manual on-line @ NASA.gov: http://idlastro.gsfc.nasa.gov/idl_html_help/home.html
 
@@ -105,7 +105,7 @@
 .B PATH
 Determines search path when spawning child processes using the SPAWN procedure with the /NOSHELL keyword set.
 .TP
-.B PYTHON_PATH
+.B PYTHONPATH
 Influences behaviour of PYTHON procedure and PYTHON() function (available if GDL is compiled with support 
 for calling Python code)
 .TP
diff -ruN --exclude CVS gdl-0.9.2/doc/Makefile.in gdl/doc/Makefile.in
--- gdl-0.9.2/doc/Makefile.in	2011-11-01 17:46:37.000000000 -0600
+++ gdl/doc/Makefile.in	2012-06-28 03:54:54.000000000 -0600
@@ -104,6 +104,7 @@
 FGREP = @FGREP@
 GDLDATADIR = @GDLDATADIR@
 GREP = @GREP@
+GraphicsMagickConfig = @GraphicsMagickConfig@
 HAVE_64BIT_OS = @HAVE_64BIT_OS@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/chapters/credits.tex gdl/doc/udg/chapters/credits.tex
--- gdl-0.9.2/doc/udg/chapters/credits.tex	2011-08-24 06:20:40.000000000 -0600
+++ gdl/doc/udg/chapters/credits.tex	2012-01-03 03:09:18.000000000 -0700
@@ -2,13 +2,15 @@
 
 GDL have been developed by a team of volunteers led by {\bf Marc~Schellens} --
   the project's founder and maintainer.
-As of 2011 the core team consists additionally of 
+As of 2011 the core team consists additionally of (in alphabetical order)
   Sylwester~Arabas, Alain~Coulais and Jeol~Gales.
 
 Among many good folks who provided patches and valuable feedback (in alphabetical order) there are:
 M\'ed\'eric~Bocquien, %
 Justin~Bronn, %
 Pierre~Chanial, %
+Pedro~Corona~Romero, % dialog_pickfile
+Gilles~Duvert, % USERSYM
 Christoph~Fuchs, % CALL_EXTERNAL
 Nicolas~Galmiche, %
 Greg~Huey, % UNIT kw for SPAWN
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/diag/broken-references gdl/doc/udg/diag/broken-references
--- gdl-0.9.2/doc/udg/diag/broken-references	2011-08-24 06:20:40.000000000 -0600
+++ gdl/doc/udg/diag/broken-references	2012-01-03 03:09:19.000000000 -0700
@@ -27,7 +27,9 @@
 LIB.READS.FUN
 LIB.IDL-VALIDANEM.FUN
 LIB.LINKIMAGE.FUN
-LIB.APPLEMAN.PRO.KW.RESULT
+LIB.APPLEMAN.PRO.KW.HELP
+LIB.APPLEMAN.PRO.KW.NODISPLAY
+LIB.APPLEMAN.PRO.KW.TEST
 LIB.ARRAY-EQUAL.FUN.KW.NO-TYPECONV
 LIB.ASSOC.FUN.KW.PACKED
 LIB.ATAN.FUN.KW.PHASE
@@ -104,6 +106,7 @@
 LIB.BESELY.FUN.KW.HELP
 LIB.BESELY.FUN.KW.ITER
 LIB.BETA.FUN.KW.DOUBLE
+LIB.BILINEAR.FUN.KW.MISSING
 LIB.BROYDEN.FUN.KW.DOUBLE
 LIB.BROYDEN.FUN.KW.ITMAX
 LIB.BROYDEN.FUN.KW.TOLF
@@ -146,6 +149,13 @@
 LIB.CLOSE.PRO.KW.FORCE
 LIB.COMMAND-LINE-ARGS.FUN.KW.COUNT
 LIB.COMPLEXARR.FUN.KW.NOZERO
+LIB.CONGRID.FUN.KW.CENTER
+LIB.CONGRID.FUN.KW.CUBIC
+LIB.CONGRID.FUN.KW.HELP
+LIB.CONGRID.FUN.KW.INTERP
+LIB.CONGRID.FUN.KW.MINUS-ONE
+LIB.CONGRID.FUN.KW.MISSING
+LIB.CONGRID.FUN.KW.TEST
 LIB.CONTOUR.PRO.KW.BACKGROUND
 LIB.CONTOUR.PRO.KW.CHARSIZE
 LIB.CONTOUR.PRO.KW.CHARTHICK
@@ -256,9 +266,11 @@
 LIB.DERIV.FUN.KW.HELP
 LIB.DERIV.FUN.KW.NO-CHECK
 LIB.DERIV.FUN.KW.TEST
+LIB.DETERM.FUN.KW.DOUBLE
 LIB.DEVICE.PRO.KW.CLOSE-FILE
 LIB.DEVICE.PRO.KW.COLOR
 LIB.DEVICE.PRO.KW.DECOMPOSED
+LIB.DEVICE.PRO.KW.ENCAPSULATED
 LIB.DEVICE.PRO.KW.FILENAME
 LIB.DEVICE.PRO.KW.GET-DECOMPOSED
 LIB.DEVICE.PRO.KW.GET-SCREEN-SIZE
@@ -266,10 +278,13 @@
 LIB.DEVICE.PRO.KW.INCHES
 LIB.DEVICE.PRO.KW.LANDSCAPE
 LIB.DEVICE.PRO.KW.PORTRAIT
+LIB.DEVICE.PRO.KW.SCALE-FACTOR
 LIB.DEVICE.PRO.KW.SET-CHARACTER-SIZE
 LIB.DEVICE.PRO.KW.SET-RESOLUTION
 LIB.DEVICE.PRO.KW.WINDOW-STATE
+LIB.DEVICE.PRO.KW.XOFFSET
 LIB.DEVICE.PRO.KW.XSIZE
+LIB.DEVICE.PRO.KW.YOFFSET
 LIB.DEVICE.PRO.KW.YSIZE
 LIB.DEVICE.PRO.KW.Z-BUFFERING
 LIB.DIALOG-MESSAGE.FUN.KW.CANCEL
@@ -309,6 +324,7 @@
 LIB.DIALOG-PICKFILE.FUN.KW.WRITE
 LIB.DIALOG-PICKFILE.FUN.KW.ZENITY-NAME
 LIB.DIALOG-PICKFILE.FUN.KW.ZENITY-PATH
+LIB.DIALOG-PICKFILE.FUN.KW.ZENITY-SEP
 LIB.ERF.FUN.KW.DOUBLE
 LIB.ERFC.FUN.KW.DOUBLE
 LIB.ERRORF.FUN.KW.DOUBLE
@@ -381,7 +397,10 @@
 LIB.FILE-TEST.FUN.KW.SYMLINK
 LIB.FILE-TEST.FUN.KW.WRITE
 LIB.FILE-TEST.FUN.KW.ZERO-LENGTH
+LIB.FILE-WHICH.FUN.KW.DEBUG
+LIB.FILE-WHICH.FUN.KW.HELP
 LIB.FILE-WHICH.FUN.KW.INCLUDE-CURRENT-DIR
+LIB.FILE-WHICH.FUN.KW.TEST
 LIB.FINDFILE.FUN.KW.COUNT
 LIB.FINDFILE.FUN.KW.HELP
 LIB.FINDFILE.FUN.KW.QUIET
@@ -498,6 +517,7 @@
 LIB.HISTOGRAM.FUN.KW.LOCATIONS
 LIB.HISTOGRAM.FUN.KW.MAX
 LIB.HISTOGRAM.FUN.KW.MIN
+LIB.HISTOGRAM.FUN.KW.NAN
 LIB.HISTOGRAM.FUN.KW.NBINS
 LIB.HISTOGRAM.FUN.KW.OMAX
 LIB.HISTOGRAM.FUN.KW.OMIN
@@ -509,7 +529,27 @@
 LIB.HIST-2D.FUN.KW.MIN1
 LIB.HIST-2D.FUN.KW.MIN2
 LIB.IDENTITY.FUN.KW.DOUBLE
+LIB.IDL-VALIDNAME.FUN.KW.CONVERT-ALL
+LIB.IDL-VALIDNAME.FUN.KW.CONVERT-SPACES
+LIB.IDL-VALIDNAME.FUN.KW.HELP
+LIB.IDL-VALIDNAME.FUN.KW.TEST
 LIB.IGAMMA.FUN.KW.DOUBLE
+LIB.IMAGE-STATISTICS.PRO.KW.COUNT
+LIB.IMAGE-STATISTICS.PRO.KW.DATA-SUM
+LIB.IMAGE-STATISTICS.PRO.KW.HELP
+LIB.IMAGE-STATISTICS.PRO.KW.LUT
+LIB.IMAGE-STATISTICS.PRO.KW.MASK
+LIB.IMAGE-STATISTICS.PRO.KW.MAXIMUM
+LIB.IMAGE-STATISTICS.PRO.KW.MEAN
+LIB.IMAGE-STATISTICS.PRO.KW.MINIMUM
+LIB.IMAGE-STATISTICS.PRO.KW.STDDEV
+LIB.IMAGE-STATISTICS.PRO.KW.SUM-OF-SQUARES
+LIB.IMAGE-STATISTICS.PRO.KW.TEST
+LIB.IMAGE-STATISTICS.PRO.KW.VARIANCE
+LIB.IMAGE-STATISTICS.PRO.KW.VECTOR
+LIB.IMAGE-STATISTICS.PRO.KW.VERBOSE
+LIB.IMAGE-STATISTICS.PRO.KW.WEIGHTED
+LIB.IMAGE-STATISTICS.PRO.KW.WEIGHT-SUM
 LIB.IMSL-CONSTANT.FUN.KW.DOUBLE
 LIB.IMSL-ERF.FUN.KW.DOUBLE
 LIB.IMSL-ERF.FUN.KW.INVERSE
@@ -571,6 +611,11 @@
 LIB.LOADCT-INTERNALGDL.PRO.KW.GET-NAMES
 LIB.LON64ARR.FUN.KW.NOZERO
 LIB.LONARR.FUN.KW.NOZERO
+LIB.LUDC.PRO.KW.COLUMN
+LIB.LUDC.PRO.KW.DOUBLE
+LIB.LUDC.PRO.KW.INTERCHANGES
+LIB.LUSOL.FUN.KW.COLUMN
+LIB.LUSOL.FUN.KW.DOUBLE
 LIB.MACHAR.FUN.KW.DOUBLE
 LIB.MAGICK-ADDNOISE.PRO.KW.GAUSSIANNOISE
 LIB.MAGICK-ADDNOISE.PRO.KW.IMPULSENOISE
@@ -635,13 +680,6 @@
 LIB.MAP-CONTINENTS.PRO.KW.FILL-CONTINENTS
 LIB.MAP-CONTINENTS.PRO.KW.HIRES
 LIB.MAP-CONTINENTS.PRO.KW.RIVERS
-LIB.MAP-PROJ-FORWARD.FUN.KW.CONNECTIVITY
-LIB.MAP-PROJ-FORWARD.FUN.KW.FILL
-LIB.MAP-PROJ-FORWARD.FUN.KW.MAP-STRUCTURE
-LIB.MAP-PROJ-FORWARD.FUN.KW.POLYGONS
-LIB.MAP-PROJ-FORWARD.FUN.KW.POLYLINES
-LIB.MAP-PROJ-FORWARD.FUN.KW.RADIANS
-LIB.MAP-PROJ-INVERSE.FUN.KW.RADIANS
 LIB.MATRIX-MULTIPLY.FUN.KW.ATRANSPOSE
 LIB.MATRIX-MULTIPLY.FUN.KW.BTRANSPOSE
 LIB.MAX.FUN.KW.DIMENSION
@@ -983,10 +1021,12 @@
 LIB.READ-ASCII.FUN.KW.DATA-START
 LIB.READ-ASCII.FUN.KW.DELIMITER
 LIB.READ-ASCII.FUN.KW.HEADER
+LIB.READ-ASCII.FUN.KW.HELP
 LIB.READ-ASCII.FUN.KW.MISSING-VALUE
 LIB.READ-ASCII.FUN.KW.NUM-RECORDS
 LIB.READ-ASCII.FUN.KW.RECORD-START
 LIB.READ-ASCII.FUN.KW.TEMPLATE
+LIB.READ-ASCII.FUN.KW.TEST
 LIB.READ-ASCII.FUN.KW.VERBOSE
 LIB.READ-BINARY.FUN.KW.DATA-DIMS
 LIB.READ-BINARY.FUN.KW.DATA-START
@@ -995,15 +1035,23 @@
 LIB.READ-BINARY.FUN.KW.TEMPLATE
 LIB.READ-BMP.FUN.KW.RGB
 LIB.READ-DICOM.FUN.KW.IMAGE-INDEX
+LIB.READ-GIF.PRO.KW.DEBUG
+LIB.READ-GIF.PRO.KW.HELP
+LIB.READ-GIF.PRO.KW.TEST
 LIB.READ-JPEG.PRO.KW.BUFFER
 LIB.READ-JPEG.PRO.KW.COLORS
+LIB.READ-JPEG.PRO.KW.DEBUG
 LIB.READ-JPEG.PRO.KW.DITHER
 LIB.READ-JPEG.PRO.KW.GRAYSCALE
+LIB.READ-JPEG.PRO.KW.HELP
 LIB.READ-JPEG.PRO.KW.ORDER
+LIB.READ-JPEG.PRO.KW.TEST
 LIB.READ-JPEG.PRO.KW.TRUE
 LIB.READ-JPEG.PRO.KW.TWO-PASS-QUANTIZE
 LIB.READ-JPEG.PRO.KW.UNIT
+LIB.READ-PNG.FUN.KW.HELP
 LIB.READ-PNG.FUN.KW.ORDER
+LIB.READ-PNG.FUN.KW.TEST
 LIB.READ-PNG.FUN.KW.TRANSPARENT
 LIB.READ-PNG.FUN.KW.VERBOSE
 LIB.READ-TIFF.FUN.KW.CHANNELS
@@ -1128,6 +1176,7 @@
 LIB.STRING.FUN.KW.DAYS-OF-WEEK
 LIB.STRING.FUN.KW.FORMAT
 LIB.STRING.FUN.KW.MONTH
+LIB.STRMATCH.FUN.KW.FOLD-CASE
 LIB.STRMID.FUN.KW.REVERSE-OFFSET
 LIB.STRPOS.FUN.KW.REVERSE-OFFSET
 LIB.STRPOS.FUN.KW.REVERSE-SEARCH
@@ -1254,6 +1303,7 @@
 LIB.TRIGRID.FUN.KW.NX
 LIB.TRIGRID.FUN.KW.NY
 LIB.TV.PRO.KW.CHANNEL
+LIB.TV.PRO.KW.DATA
 LIB.TV.PRO.KW.DEVICE
 LIB.TV.PRO.KW.NORMAL
 LIB.TV.PRO.KW.ORDER
@@ -1272,6 +1322,9 @@
 LIB.UINTARR.FUN.KW.NOZERO
 LIB.ULON64ARR.FUN.KW.NOZERO
 LIB.ULONARR.FUN.KW.NOZERO
+LIB.USERSYM.PRO.KW.COLOR
+LIB.USERSYM.PRO.KW.FILL
+LIB.USERSYM.PRO.KW.THICK
 LIB.VALUE-LOCATE.FUN.KW.L64
 LIB.VARIANCE.FUN.KW.DOUBLE
 LIB.VARIANCE.FUN.KW.NAN
@@ -1499,16 +1552,39 @@
 LIB.WINDOW.PRO.KW.YPOS
 LIB.WINDOW.PRO.KW.YSIZE
 LIB.WRITEU.PRO.KW.TRANSFER-COUNT
+LIB.WRITE-BMP.PRO.KW.DEBUG
 LIB.WRITE-BMP.PRO.KW.FOUR-BIT
 LIB.WRITE-BMP.PRO.KW.HEADER-DEFINE
+LIB.WRITE-BMP.PRO.KW.HELP
 LIB.WRITE-BMP.PRO.KW.IHDR
 LIB.WRITE-BMP.PRO.KW.RGB
+LIB.WRITE-BMP.PRO.KW.TEST
+LIB.WRITE-GIF.PRO.KW.BACKGROUND-COLOR
+LIB.WRITE-GIF.PRO.KW.CLOSE
+LIB.WRITE-GIF.PRO.KW.DEBUG
+LIB.WRITE-GIF.PRO.KW.DELAY-TIME
+LIB.WRITE-GIF.PRO.KW.DISPOSAL-METHOD
+LIB.WRITE-GIF.PRO.KW.HELP
+LIB.WRITE-GIF.PRO.KW.MULTIPLE
+LIB.WRITE-GIF.PRO.KW.REPEAT-COUNT
+LIB.WRITE-GIF.PRO.KW.TEST
+LIB.WRITE-GIF.PRO.KW.TRANSPARENT
+LIB.WRITE-GIF.PRO.KW.USER-INPUT
+LIB.WRITE-JPEG.PRO.KW.DEBUG
+LIB.WRITE-JPEG.PRO.KW.HELP
 LIB.WRITE-JPEG.PRO.KW.ORDER
 LIB.WRITE-JPEG.PRO.KW.PROGRESSIVE
 LIB.WRITE-JPEG.PRO.KW.QUALITY
+LIB.WRITE-JPEG.PRO.KW.TEST
 LIB.WRITE-JPEG.PRO.KW.TRUE
 LIB.WRITE-JPEG.PRO.KW.UNIT
+LIB.WRITE-PICT.PRO.KW.DEBUG
+LIB.WRITE-PICT.PRO.KW.HELP
+LIB.WRITE-PICT.PRO.KW.TEST
+LIB.WRITE-PNG.PRO.KW.DEBUG
+LIB.WRITE-PNG.PRO.KW.HELP
 LIB.WRITE-PNG.PRO.KW.ORDER
+LIB.WRITE-PNG.PRO.KW.TEST
 LIB.WRITE-PNG.PRO.KW.TRANSPARENT
 LIB.WRITE-PNG.PRO.KW.VERBOSE
 LIB.WTN.FUN.KW.COLUMN
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/examples/appleman_0/appleman_0.out.txt gdl/doc/udg/examples/appleman_0/appleman_0.out.txt
--- gdl-0.9.2/doc/udg/examples/appleman_0/appleman_0.out.txt	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/udg/examples/appleman_0/appleman_0.out.txt	2012-01-03 03:09:21.000000000 -0700
@@ -0,0 +1,4 @@
+% Compiled module: APPLEMAN.
+% Compiled module: LOADCT.
+% LOADCT: Loading table BOW SPECIAL
+% Compiled module: TVSCL.
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/examples/appleman_0/appleman_0.pro gdl/doc/udg/examples/appleman_0/appleman_0.pro
--- gdl-0.9.2/doc/udg/examples/appleman_0/appleman_0.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/udg/examples/appleman_0/appleman_0.pro	2012-01-03 03:09:21.000000000 -0700
@@ -0,0 +1,8 @@
+rng_x = [-1, 2.3]
+rng_y = [-1.3, 1.3]
+appleman, rng_x, rng_y, result=fractal, xsize=165, ysize=130
+device, /color
+plot, [0], /nodata, xrange=rng_x, yrange=rng_y
+loadct, 15
+tvscl, fractal, rng_x[0], rng_y[0], $
+  xsize=rng_x[1]-rng_x[0], ysize=rng_y[1]-rng_y[0]
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/examples/arguments-abbr/arguments-abbr.out.txt gdl/doc/udg/examples/arguments-abbr/arguments-abbr.out.txt
--- gdl-0.9.2/doc/udg/examples/arguments-abbr/arguments-abbr.out.txt	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/udg/examples/arguments-abbr/arguments-abbr.out.txt	2012-01-03 03:09:20.000000000 -0700
@@ -0,0 +1,5 @@
+<Expression>    LONG      =            3
+<Expression>    LONG      =            3
+% STRPOS: Ambiguous keyword abbreviation: REV
+% Execution halted at: $MAIN$          
+<Expression>    LONG      =            1
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/examples/arguments-abbr/arguments-abbr.pro gdl/doc/udg/examples/arguments-abbr/arguments-abbr.pro
--- gdl-0.9.2/doc/udg/examples/arguments-abbr/arguments-abbr.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/udg/examples/arguments-abbr/arguments-abbr.pro	2012-01-03 03:09:20.000000000 -0700
@@ -0,0 +1,4 @@
+help, strpos('kayak', 'a', /reverse_search)
+help, strpos('kayak', 'a', /reverse_s)
+help, strpos('kayak', 'a', /rev)
+help, strpos('kayak', 'a', 2, /reverse_search, /reverse_offset)
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/examples/call_external_0/call_external_0.pro gdl/doc/udg/examples/call_external_0/call_external_0.pro
--- gdl-0.9.2/doc/udg/examples/call_external_0/call_external_0.pro	2011-04-27 02:42:50.000000000 -0600
+++ gdl/doc/udg/examples/call_external_0/call_external_0.pro	2012-01-03 03:09:23.000000000 -0700
@@ -9,7 +9,7 @@
 $ make
 $ echo
 
-img = 'libexample.'+(!VERSION.OS_NAME eq 'Darwin'?"dylib":"so")
+img = 'libexample.'+(!VERSION.OS_NAME eq 'darwin'?"dylib":"so")
 message, '1d308 vs. a next representable double:', /continue
 print, format='(E)', 1d308, $
   call_external(img, 'c_nextafter', 1d308, 2d308, /d_value)
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/examples/file_lines_0/file_lines_0.out.txt gdl/doc/udg/examples/file_lines_0/file_lines_0.out.txt
--- gdl-0.9.2/doc/udg/examples/file_lines_0/file_lines_0.out.txt	2011-07-03 16:44:28.000000000 -0600
+++ gdl/doc/udg/examples/file_lines_0/file_lines_0.out.txt	2012-01-03 03:09:23.000000000 -0700
@@ -1,2 +1,2 @@
 % Compiled module: FILE_LINES.
-        5290
+        6335
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/examples/h5_get_libversion_0/h5_get_libversion_0.out.txt gdl/doc/udg/examples/h5_get_libversion_0/h5_get_libversion_0.out.txt
--- gdl-0.9.2/doc/udg/examples/h5_get_libversion_0/h5_get_libversion_0.out.txt	2011-04-09 15:19:14.000000000 -0600
+++ gdl/doc/udg/examples/h5_get_libversion_0/h5_get_libversion_0.out.txt	2012-01-03 03:09:23.000000000 -0700
@@ -1 +1 @@
-<Expression>    STRING    = '1.8.6'
+<Expression>    STRING    = '1.8.8'
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/examples/mathfunc_0/mathfunc_0.out.txt gdl/doc/udg/examples/mathfunc_0/mathfunc_0.out.txt
--- gdl-0.9.2/doc/udg/examples/mathfunc_0/mathfunc_0.out.txt	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/udg/examples/mathfunc_0/mathfunc_0.out.txt	2012-01-03 03:09:21.000000000 -0700
@@ -0,0 +1,2 @@
+<Expression>    LONG      =            1
+<Expression>    FLOAT     = Array[3]
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/examples/mathfunc_0/mathfunc_0.pro gdl/doc/udg/examples/mathfunc_0/mathfunc_0.pro
--- gdl-0.9.2/doc/udg/examples/mathfunc_0/mathfunc_0.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/udg/examples/mathfunc_0/mathfunc_0.pro	2012-01-03 03:09:21.000000000 -0700
@@ -0,0 +1 @@
+help, abs(-1l), abs([-!PI,0,!PI])
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/examples/mathfunc_1/mathfunc_1.out.txt gdl/doc/udg/examples/mathfunc_1/mathfunc_1.out.txt
--- gdl-0.9.2/doc/udg/examples/mathfunc_1/mathfunc_1.out.txt	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/udg/examples/mathfunc_1/mathfunc_1.out.txt	2012-01-03 03:09:22.000000000 -0700
@@ -0,0 +1,2 @@
+<Expression>    FLOAT     =           inf
+<Expression>    DOUBLE    =    1.0333148e+40
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/examples/mathfunc_1/mathfunc_1.pro gdl/doc/udg/examples/mathfunc_1/mathfunc_1.pro
--- gdl-0.9.2/doc/udg/examples/mathfunc_1/mathfunc_1.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/udg/examples/mathfunc_1/mathfunc_1.pro	2012-01-03 03:09:22.000000000 -0700
@@ -0,0 +1 @@
+help, gamma(36b), gamma(36b, /double)
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/examples/mathfunc_2/mathfunc_2.out.txt gdl/doc/udg/examples/mathfunc_2/mathfunc_2.out.txt
--- gdl-0.9.2/doc/udg/examples/mathfunc_2/mathfunc_2.out.txt	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/udg/examples/mathfunc_2/mathfunc_2.out.txt	2012-01-03 03:09:22.000000000 -0700
@@ -0,0 +1,2 @@
+<Expression>    LONG      =  -2147483648
+<Expression>    LONG64    =            10000000000
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/examples/mathfunc_2/mathfunc_2.pro gdl/doc/udg/examples/mathfunc_2/mathfunc_2.pro
--- gdl-0.9.2/doc/udg/examples/mathfunc_2/mathfunc_2.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/udg/examples/mathfunc_2/mathfunc_2.pro	2012-01-03 03:09:22.000000000 -0700
@@ -0,0 +1 @@
+help, round(1d10), round(1d10, /l64)
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/examples/obj_class_1/obj_class_1.out.txt gdl/doc/udg/examples/obj_class_1/obj_class_1.out.txt
--- gdl-0.9.2/doc/udg/examples/obj_class_1/obj_class_1.out.txt	2011-04-09 15:19:14.000000000 -0600
+++ gdl/doc/udg/examples/obj_class_1/obj_class_1.out.txt	2012-01-03 03:09:24.000000000 -0700
@@ -1,3 +1,3 @@
-CLASSES         STRING    = Array[23]
-!PLT !GNUDATALANGUAGE !AXIS !VERSION !MOUSE !ERROR_STATE !VALUES !MAP !CPU !WARN IDL_SIZE FSTAT64 FSTAT FILE_INFO IDL_MEMORY IDL_MEMORY64 MACHAR 
-DMACHAR WIDGET_BUTTON WIDGET_DROPLIST WIDGET_TEXT WIDGET_VERSION !DEVICE
+CLASSES         STRING    = Array[24]
+!PLT !GNUDATALANGUAGE !AXIS !VERSION !MOUSE !ERROR_STATE !VALUES !MAP !CPU !WARN !USERSYM IDL_SIZE FSTAT64 FSTAT FILE_INFO IDL_MEMORY 
+IDL_MEMORY64 MACHAR DMACHAR WIDGET_BUTTON WIDGET_DROPLIST WIDGET_TEXT WIDGET_VERSION !DEVICE
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/gdl.tex gdl/doc/udg/gdl.tex
--- gdl-0.9.2/doc/udg/gdl.tex	2011-08-24 06:20:39.000000000 -0600
+++ gdl/doc/udg/gdl.tex	2012-01-03 03:09:17.000000000 -0700
@@ -112,7 +112,7 @@
   \Large a free/libre/open-source implementation of IDL/PV-WAVE\textsuperscript{*}\nnfoottext{
     \textsuperscript{*}
     IDL (Interactive Data Language) and PV-WAVE (Precision Visuals - Workstation Analysis and Visualization Environment)\\
-    are/were registered trademarks of Research Systems, Inc./ITT Visual Information Solutions and Precision Visuals/Visual Numerics/Rogue Wave Software, respectively
+    are (were) registered trademarks of EXELIS VIS (ITT VIS; Research Systems, Inc.) and Rogue Wave Software (Visual Numerics; Precision Visuals), respectively
   }
 }
 \author{
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/makeall gdl/doc/udg/makeall
--- gdl-0.9.2/doc/udg/makeall	2011-09-19 06:06:11.000000000 -0600
+++ gdl/doc/udg/makeall	2012-01-03 03:09:17.000000000 -0700
@@ -19,7 +19,7 @@
 echo -n "--- Generating routinelist.tmp file (may take a while) ... "
 newest=`ls -1 -t ../../src/pro/*.pro ../../src/gdl ./gdl.pro ./routinelist.pro | head -1`
 if `test ! -e routinelist.tmp` || `test $newest -nt routinelist.tmp`; then
-  ../../src/gdl -quiet -e "routinelist, 'routinelist.tmp'" &>routinelist.log;
+  IDL_PATH= GDL_PATH=+../../src/pro ../../src/gdl -quiet -e "routinelist, 'routinelist.tmp'" &>routinelist.log;
   if `test 0 -eq $?`; then
     echo "done";
   else
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/README.txt gdl/doc/udg/README.txt
--- gdl-0.9.2/doc/udg/README.txt	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/udg/README.txt	2012-01-24 06:45:41.000000000 -0700
@@ -0,0 +1,34 @@
+
+Sylwester Arabas and Alain Coulais
+24 Jan 2012
+
+How to compile the documentation ?
+
+0/ You must have compiled GDL before
+
+1/ You must collect some external files before:
+
+-- pdfdraftcopy.sty  
+see http://sarovar.org/projects/pdfdraftcopy/
+(wget http://sarovar.org/projects/pdfdraftcopy/pdfdraftcopy.sty)
+
+-- nnfootnote.sty   
+see http://ctan.org/pkg/nnfootnote/
+(wget http://ctan.org/pkg/nnfootnote/nnfootnote.sty)
+
+-- copernicus.bst
+see http://publications.copernicus.org/
+(wget http://publications.copernicus.org/Copernicus.bst)
+
+-- Perl Script authorindex
+see http://mirrors.ctan.org/indexing/authorindex/
+(wget http://mirrors.ctan.org/indexing/authorindex/authorindex)
+
+Take care that you must put this self-executable script in a directory see by your PATH
+(maybe the current directory is not allowed to contain executables)
+
+2/ Then you can start to compile the doc.
+You have to do in the current directory: ./makeall
+(and wait for a while)
+
+Please report any broken link(s)
diff -ruN --exclude CVS gdl-0.9.2/doc/udg/routines/appleman.pro.tex gdl/doc/udg/routines/appleman.pro.tex
--- gdl-0.9.2/doc/udg/routines/appleman.pro.tex	2011-02-27 15:32:34.000000000 -0700
+++ gdl/doc/udg/routines/appleman.pro.tex	2012-01-03 03:09:24.000000000 -0700
@@ -1 +1,12 @@
-Mandelbrot set\index{Mandelbrot set}
+Computes and optionally renders the Mandelbrot set\index{Mandelbrot set}.
+The two positional arguments are optional and allow specification of the
+range over which the set is computed (default values: 
+[-1.0,2.3] and [-1.3,1.3]).
+\gdlkeyworddesc{RESULT}
+Allows passing a variable into which the computed data will be sotred.
+If set, no rendering is done.
+\gdlkeyworddesc{XSIZE}
+Allows specification of the width of the domain over which the set is computed.
+\gdlkeyworddesc{YSIZE}
+Allows specification of the height of the domain over which the set is computed.
+\gdlcodeexample{appleman_0}{}{}
diff -ruN --exclude CVS gdl-0.9.2/doc/www/contribute.html gdl/doc/www/contribute.html
--- gdl-0.9.2/doc/www/contribute.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/contribute.html	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL Contribute</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/support.php"></HEAD>
+  </head>
+  <body>
+  </body>
+</html>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/credits.html gdl/doc/www/credits.html
--- gdl-0.9.2/doc/www/credits.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/credits.html	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL credits</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/credits.php"></HEAD>
+  </head>
+  <body>
+  </body>
+</html>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/credits.php gdl/doc/www/credits.php
--- gdl-0.9.2/doc/www/credits.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/credits.php	2011-08-10 03:35:34.000000000 -0600
@@ -0,0 +1,118 @@
+<?php require('_header.inc.php'); ?>
+			
+<h2>Credits</h2>
+
+<p>
+The project was founded and is maintained by:
+</p>
+
+<ul><li>
+<a href="mailto:m_schellens@users.sourceforge.net">Marc Schellens</a>
+<br/>
+Compiler, Interpreter, Library routines...
+</li></ul>
+
+<p>
+As of 2011 the core team consists additionally of:
+</p>
+
+<ul>
+<li>
+<a href="mailto:slayoo@users.sourceforge.net">Sylwester Arabas</a> 
+<br/>
+Library routines, testing, documentation, portability issues 
+</li>
+
+<li>
+<a href="mailto:alaingdl@users.sourceforge.net">Alain Coulais</a> 
+<br/>
+Library routines, testing, documentation, presentations 
+</li>
+
+<li>
+<a href="mailto:jomoga@users.sourceforge.net">Joel Gales</a>
+<br/>
+Library routines (TV, FFT, HISTOGRAM, HDF support, widgets)
+</li>
+</ul>
+
+<p>
+Among many good folks who provided patches and valuable feedback (in alphabetical order):
+</p>
+<p>
+<a>M&eacute;d&eacute;ric&nbsp;Bocquien</a>, 
+<a>Justin&nbsp;Bronn</a>,
+<a>Pierre&nbsp;Chanial</a>, 
+<a>Christoph&nbsp;Fuchs</a>, 
+<a>Nicolas&nbsp;Galmiche</a>, 
+<a>Greg&nbsp;Huey</a>, 
+<a>Gaurav&nbsp;Khanna</a>, 
+<a>Christopher&nbsp;Lee</a>., 
+<a>Maxime&nbsp;Lenoir</a>, 
+<a>Peter&nbsp;Messmer</a>, 
+<a>Gregory&nbsp;Marchal</a>, 
+<a>Thibaut&nbsp;Mermet</a>, 
+<a>Lea&nbsp;Noreskal</a>, 
+<a>Orion&nbsp;Poplawski</a>, 
+<a>Rene&nbsp;Preusker</a>,
+<a>Mateusz&nbsp;Turcza</a>, 
+<a>Joanna&nbsp;Woo</a>, 
+<a>H&nbsp;Xu</a>, 
+...
+</p>
+
+<p>
+GDL contains snippets of code borrowed from other free and open-source projects credited to:
+</p>
+
+<p>
+<a>Deepak&nbsp;Bandyopadhyay</a>,
+<a>Sergio&nbsp;Gelato</a>,
+<a>Lutz&nbsp;Kettner</a>,
+<a>Craig&nbsp;B.&nbsp;Markwardt</a>,
+<a>Paul&nbsp;Ricchiazzi</a>,
+<a>Danny&nbsp;Smith</a>,
+<a>J.D.&nbsp;Smith</a>,
+<a>Richard&nbsp;Schwartz</a>,
+<a>Paul&nbsp;Wessel</a>,
+<a>Bob&nbsp;Withers</a>,
+...
+</p>
+
+<p>Pre-compiled or pre-configured packages of GDL are available for numerous systems thanks to:</p>
+
+<p>
+<a>Juan&nbsp;A.&nbsp;A&ntilde;el</a>,
+<a>Axel&nbsp;Beckert</a>, 
+<a>Markus&nbsp;Dittrich</a>,
+<a>Takeshi&nbsp;Enomoto</a>, 
+<a>S&eacute;bastien&nbsp;Fabbro</a>, 
+<a>Orlando&nbsp;Garcia&nbsp;Feal</a>,
+<a>Gaurav&nbsp;Khanna</a>, 
+<a>Justin&nbsp;Lecher</a>, 
+<a>Sebastien&nbsp;Maret</a>,
+<a>Lea&nbsp;Noreskal</a>, 
+<a>Orion&nbsp;Poplawski</a>,
+<a>Marius&nbsp;Schamschula</a>,
+<a>G&uuml;rkan&nbsp;Seng&uuml;n</a>,
+<a>Thierry&nbsp;Thomas</a>,
+...
+</p>
+
+<p>
+GDL is written in C++ using the <a>Terence Parr's</a> ANTLR language-recognition framework.
+Most of the library routines are implemented as interfaces to open-source packages
+  such as <a>GNU Scientific Library</a>, <a>PLPlot</a>, <a>FFTW</a>, <a>ImageMagick</a>, and many many more.
+</p>
+
+<p>
+Last but not least, we would like to acknowledge the designers of <a>IDL</a> and <a>PV-WAVE</a>.
+</p>
+
+<p>
+  Please do report any missing name on the lists above in the same way
+    as any other bug in GDL (see <a href="support.php">support &amp; feedback</a>).
+  Please also let us know if you would not like to be listed.
+</p>
+ 
+<?php require('_footer.inc.php'); ?>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/documentation.php gdl/doc/www/documentation.php
--- gdl-0.9.2/doc/www/documentation.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/documentation.php	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,31 @@
+<?php require('_header.inc.php'); ?>
+
+<h2><a href="index.html">GDL Documentation</a></h2>
+			
+<p>
+There's an ongoing effort to write the GDL User's and Developer's guide.
+Currently the documentation covers an automatically-generated list of all available library routines 
+and their keywords, about 100 code examples, and a few drafts of library 
+routine descriptions and other chapters.
+</p>
+
+<p>
+The documentation is available as a single PDF file (only in English):
+<a href="http://gnudatalanguage.sf.net/gdl.pdf">http://gnudatalanguage.sf.net/gdl.pdf [PDF, 1.2 MiB]</a>
+</p>
+
+<p>
+While GDL itself reached a beta status of development, the documentation
+  is far from reaching an alpha status - help is very welcome!
+Please report any inconsistencies in the documentation as any other
+  bugs in GDL. Please submit new additions to the text (incl. code examples)
+  as patches to GDL (see <a href="support.php">support &amp; feedback</a>).
+</p>
+
+<p>
+As GDL is almost 100% compatible to IDL (although not complete as many subroutines 
+  are waiting to be implemented), documentation and tutorials for IDL can also be 
+  utilized for GDL (see <a href="resources.php">resources</a>).
+</p>
+
+<?php require('_footer.inc.php'); ?>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/download.html gdl/doc/www/download.html
--- gdl-0.9.2/doc/www/download.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/download.html	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>Download GDL</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/downloads.php"></HEAD>
+  </head>
+  <body>
+  </body>
+</html>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/downloads.php gdl/doc/www/downloads.php
--- gdl-0.9.2/doc/www/downloads.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/downloads.php	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,57 @@
+<?php require('_header.inc.php'); ?>
+
+<h2><a href="index.html">Obtaining GDL</a></h2>
+			
+<p>
+  GDL compiles "out of the box" on Linux, Mac OS X and several other UNIX systems
+  (see <a href="requirements.php">requirements</a> for details).
+</p>
+
+<p>
+  The source code distribution is available from
+  <a href="http://sourceforge.net/projects/gnudatalanguage/">SourceForge</a>.
+</p>
+
+<p>
+  The latest development version of GDL can be obtained via CVS - consult the
+  <a href="http://sourceforge.net/projects/gnudatalanguage/develop/">SF.net project development page</a>
+  for details. It is also possible to 
+  <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/">
+    browse the CVS repository using a web-based interface</a>.
+</p>
+
+<p>
+  There are numerous packaged versions of GDL available for various OSes:
+</p>
+  <ul>
+    <li>Linux
+      <ul>
+        <li><a href="http://koji.fedoraproject.org/koji/packageinfo?packageID=1830">Fedora</a></li>
+        <li><a href="http://packages.debian.org/search?keywords=gnudatalanguage">Debian GNU/Linux</a></li>
+        <li><a href="http://gentoo-portage.com/dev-lang/gdl">Gentoo</a></li>
+        <li><a href="http://aur.archlinux.org/packages.php?ID=2493">Arch Linux</a></li>
+        <li><a href="http://packages.ubuntu.com/gnudatalanguage">Ubuntu</a></li>
+      </ul>
+    </li>
+    <li>Mac OS X
+      <ul>
+        <li><a href="<?php echo(htmlspecialchars('http://www.macports.org/ports.php?by=name&substr=gnudatalanguage'));?>">Macports</a></li>
+<!--        <li><a href="http://hpc.sourceforge.net/">HPC page</a></li> -->
+        <li><a href="http://www.hmug.org/pub/MacOS_X/X/Applications/Science/gdl/">HMUG</a></li>
+        <li><a href="http://pdb.finkproject.org/pdb/package.php/gdl">Fink</a></li>
+      </ul>
+    </li>
+    <li>BSD
+      <ul>
+        <li><a href="http://www.freebsd.org/cgi/cvsweb.cgi/ports/science/gnudatalanguage/">FreeBSD</a></li>
+        <li><a href="http://packages.debian.org/search?keywords=gnudatalanguage">Debian GNU/kFreeBSD</a></li>
+      </ul>
+    </li>
+  </ul>
+
+<p>
+  Please note that several features of GDL depend on compile-time configuration, 
+    and might not be available in pre-built or pre-configured packages.
+</p>
+
+<?php require('_footer.inc.php'); ?>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/faq.php gdl/doc/www/faq.php
--- gdl-0.9.2/doc/www/faq.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/faq.php	2011-11-16 11:38:56.000000000 -0700
@@ -0,0 +1,56 @@
+<?php require('_header.inc.php'); ?>
+
+<h2><a href="index.html">Frequently Asked Questions</a></h2>
+
+<h3>Installation and portability issues</h3>
+  <ul>
+    <li>
+      <a>Is it possible to run GDL on Windows?</a>
+      <br />
+      Yes. 
+      It's possible to compile GDL under Cygwin or e.g. to run GDL under the coLinux platform.
+      Due to lack of Windows developer- or user-base there is virtually no
+      testing done on Windows, though. Help welcome!
+    </li>
+  </ul>
+
+<h3>Compatibility with IDL</h3>
+  <ul>
+    <li>
+      <a>Is there an equivalent of IDL Virtual Machine in GDL?</a>
+      <br />
+      No. 
+      GDL is free/libre/open-source software. 
+      The distinction between a developers' (costly) version and a users' (free) version is not applicable.
+      Any user if free to use the full power of GDL.
+    </li>
+    <li>
+      <a>Is there a way to save/distribute pre-compiled GDL routines (as&nbsp;.sav&nbsp;files in IDL)?</a>
+      <br />
+      No. GDL does not support saving/loading pre-compiled routines yet.
+      It does support saving/loading variables into IDL-compatible .sav files, though.
+      Since compatibility with IDL-saved routines is not going to be possible anyhow, 
+      and since the virtual-machine context is not applicable to GDL (see above),
+      implementing routine saving has a low priority.
+    </li>
+    <li>
+      <a>Does GDL support the so-called ''object graphics'', ''function graphics''/''new graphics''?</a>
+      <br />
+      No. GDL supports ''direct graphics'' only.
+    </li>
+    <li>
+      <a>Why does the CATCH statement not work properly in GDL?</a>
+      <br />
+      It's one of very few IDL syntax elements not implemented in GDL yet.
+    </li>
+  </ul>
+
+<h3>Mapping</h3>
+  <ul>
+    <li>
+      <a>Why the continent/country/shoreline boundaries have so poor resolution in comparison with IDL</a><br />
+      Try the HIRES keyword to MAP_CONTINENTS!
+      </li>
+  </ul>
+
+<?php require('_footer.inc.php'); ?>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/feedback.html gdl/doc/www/feedback.html
--- gdl-0.9.2/doc/www/feedback.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/feedback.html	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL Feedback</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/support.php"></HEAD>
+  </head>
+  <body>
+  </body>
+</html>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/_footer.inc.php gdl/doc/www/_footer.inc.php
--- gdl-0.9.2/doc/www/_footer.inc.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/_footer.inc.php	2011-08-10 03:35:34.000000000 -0600
@@ -0,0 +1,59 @@
+			<br />	
+
+		<!-- main ends -->	
+		</div>
+		
+		<!-- sidebar starts -->
+		<div id="sidebar">
+		
+			<h3>What's new</h3>
+<?php require('_news.inc.php'); ?>
+
+			<h3>Some stats (ohloh.net)</h3>
+<div class="ohloh" style="margin-top:10px">
+<script type="text/javascript" src="http://www.ohloh.net/p/28445/widgets/project_basic_stats.js"></script>
+</div>
+
+<!--
+			<h3>Search Box</h3>	
+			<form action="#" class="searchform">
+				<p>
+				<input name="search_query" class="textbox" type="text" />
+  				<input name="search" class="button" value="Search" type="submit" />
+				</p>			
+			</form>		
+-->
+			
+						
+		<!-- sidebar ends -->		
+		</div>
+		
+	<!-- content-wrap ends-->	
+	</div>
+		
+	<!-- footer starts here -->	
+	<div id="footer-wrap"><div id="footer-content">
+	
+		<p>
+			Website content is developed by <a href="credits.php">The GDL Team</a> and is released under the CC BY-SA license (i.e. Wikipedia compatible)<br />
+                        GDL documentation is a part of the GDL project and is released under the GNU General Public License<br />
+			Website layout based on the <strong>Colourise</strong> template by <a href="http://www.styleshout.com/">styleshout.com</a><br />
+                        Hosted by <a href="http://sf.net/">Sourceforge.net</a>
+          	</p>
+		
+<!--
+		<p class="float-right">
+              		<a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a> |
+               		<a href="http://validator.w3.org/check/referer">XHTML</a>
+		</p>
+-->
+			
+	</div></div>
+	<div class="clearer"></div>
+	<!-- footer ends here -->
+
+<!-- wrap ends here -->
+</div>
+
+</body>
+</html>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/_header.inc.php gdl/doc/www/_header.inc.php
--- gdl-0.9.2/doc/www/_header.inc.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/_header.inc.php	2011-12-27 10:28:24.000000000 -0700
@@ -0,0 +1,68 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
+
+<head>
+  <title>GDL - GNU Data Language</title>
+  <meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8" />
+  <link rel="stylesheet" href="images/Colourise.css" type="text/css" />
+</head>
+
+<body>
+
+<!-- wrap starts here -->
+<div id="wrap">
+
+	<!--header -->
+	<div id="header">			
+				
+		<h1 id="logo-text"><a>GDL - GNU Data Language</a></h1>		
+		<p id="intro">
+                  A free and open-source IDL<sup>&reg;*</sup>/PV-WAVE<sup>**</sup> compiler<br />
+                  <small>
+                    * IDL is a registered trademark of <a href="http://exelisvis.com/">Exelis Visual Information Solutions</a><br />
+                    ** PV-WAVE is a product of <a href="http://roguewave.com/">Rogue Wave Software</a>
+                  </small><br />
+		</p>	
+		
+		<div  id="nav">
+			<ul>
+<?php 
+  $menu = array(
+    'index.php' => 'Features',
+    'screenshots.php' => 'Screenshots',
+    'downloads.php' => 'Downloads',
+    'requirements.php' => 'Requirements',
+    'documentation.php' => 'Documentation',
+    'support.php' => 'Support &amp; Feedback',
+    'resources.php' => 'Resources',
+    'faq.php' => 'FAQ',
+    'credits.php' => 'Credits'
+  );
+  foreach ($menu as $file => $name) 
+  {
+    echo('<li');
+    if (basename($_SERVER['SCRIPT_FILENAME']) == $file) echo(' id="current"');
+    echo('><a href="' . $file . '">' . $name . '</a></li>');
+  }
+?>
+			</ul>		
+		</div>	
+		
+<!--
+		<form id="quick-search" action="index.html" method="get" >
+			<p>
+			<label for="qsearch">Search:</label>
+			<input class="tbox" id="qsearch" type="text" name="qsearch" value="Search..." title="Start typing and hit ENTER" />
+			<input class="btn" type="submit" value="Submit" />
+			</p>
+		</form>			
+-->
+				
+	<!--header ends-->					
+	</div>
+	
+	<!-- content-wrap starts -->
+	<div id="content-wrap">
+		<div id="main">
+			<a name="TemplateInfo"></a>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/home.html gdl/doc/www/home.html
--- gdl-0.9.2/doc/www/home.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/home.html	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL ::. Home</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/index.php"></HEAD>
+  </head>
+  <body>
+  </body>
+</html>
Binary files gdl-0.9.2/doc/www/images/bg.jpg and gdl/doc/www/images/bg.jpg differ
Binary files gdl-0.9.2/doc/www/images/bullet.gif and gdl/doc/www/images/bullet.gif differ
diff -ruN --exclude CVS gdl-0.9.2/doc/www/images/Colourise.css gdl/doc/www/images/Colourise.css
--- gdl-0.9.2/doc/www/images/Colourise.css	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/images/Colourise.css	2011-12-27 10:28:25.000000000 -0700
@@ -0,0 +1,526 @@
+/* ----------------------------------------------
+	Template Name : Colourise
+	Template Code : S-0022
+	Version : 1.1   
+	Author : Erwin Aligam
+	Author URI : http://www.styleshout.com/       
+	Last Date Modified :  January 17, 2010
+ ------------------------------------------------ */
+ 
+/* ----------------------------------------------
+   HTML ELEMENTS
+------------------------------------------------- */ 
+
+/* Top Elements */
+* { margin: 0; padding: 0; outline: 0 }
+
+body {
+	font: 11px/165% 'Lucida Grande', Geneva, Verdana, Arial, Helvetica, sans-serif;
+	color: #9B9B9B; 	
+	margin: 0; 	padding: 0; 
+	background: #070707 url(bg.jpg) no-repeat center top;
+	text-align: center;
+}
+
+/* Links */
+a, a:active, a:link {
+	text-decoration: none;
+	color: #006193;			
+}
+a:visited {
+	text-decoration: none;
+}
+a:hover {
+	color: #fff;
+	border-bottom: 1px dotted #438800;
+}
+
+/* headers */
+h1, h2, h3 {
+	font-family: 'Trebuchet MS', Tahoma, Arial, Sans-serif;
+	color: #ABABAB;
+}
+h1 {
+	font-size: 3.6em;
+	font-weight: normal;
+	letter-spacing: -2px;
+	padding: 15px 10px 5px 10px;	
+}
+h2 {
+	font-size: 2.2em;
+	color: #895F30;
+	padding: 20px 10px 5px 10px;	
+}
+h3 {
+	font-size: 1.8em;
+	font-weight: normal;
+	padding: 20px 10px 5px 10px;	
+}
+
+p, dl { padding: 10px; margin: 0; }
+
+ul, ol {
+	margin: 10px 20px;
+	padding: 0 20px;
+}
+ul { list-style: none; }
+
+dt {
+  font-weight: bold;
+  color: #fff;
+}
+dd {
+  padding-left: 25px; 
+}
+
+/* images */
+img {
+	background: #1B1B1B;
+    border: 1px solid #1B1B1B;
+	padding: 8px;
+}
+img.float-right {
+  	margin: 5px 0px 10px 10px;  
+}
+img.float-left {
+  	margin: 5px 10px 10px 0px;
+}
+
+code {
+  	margin: 5px 0;
+  	padding: 15px;
+  	text-align: left;
+  	display: block;
+  	overflow: auto;  
+  	font: 500 1em/1.5em 'Lucida Console', 'Courier New', Monospace ;
+  	/* white-space: pre; */
+  	background: #111;  
+}
+acronym {
+  	cursor: help;
+  	border-bottom: 1px dotted #5B5B5B;
+}
+blockquote {
+	margin: 15px 10px;
+ 	padding: 10px 10px 10px 35px;  
+   background: #111 url(quote.jpg) no-repeat 10px 10px;
+	font-weight: normal;
+	font-size: 18px;
+	line-height: 1.6em;
+	font-style: italic;
+	font-family: Georgia, 'Times New Roman', Times, serif;	
+	color: #808080;	
+}
+
+/* start - table */
+table {
+	margin: 15px 10px; 
+	border-collapse: collapse;			
+}
+th {
+	background: #000;
+	color: #fff;
+	height: 38px;
+	padding-left: 12px;
+	padding-right: 12px;	
+	text-align: left;
+	border-left: 1px solid #211E20;
+	border-right: 1px solid #211E20;
+	border-bottom: 1px solid #211E20; 
+	border-top: 1px solid #48780E;
+}
+tr {
+	color: #5b5b5b;
+	height: 34px;	
+}
+td {
+	padding-left: 12px;
+	padding-right: 12px;
+	border: 1px solid #111;	
+}
+/* end - table */
+
+/* form elements */
+form {
+	margin: 20px 10px; padding: 5px 10px 20px 10px;
+	border: 1px solid #111; 
+	background: #070707; 	
+}
+label {
+	display: block;
+	font-weight: bold;
+	margin: 8px 0;
+	color: #fff;
+}
+input, select, textarea {
+	padding: 5px 4px;
+	font: normal 1em Verdana, Tahoma, sans-serif;
+	color: #6A6969;
+	background: #0C0C0C;  
+	border: 1px solid #1C1C1C;
+}
+textarea {
+	width: 400px;
+	height: 100px;
+	display: block;	
+}
+input.button { 
+	font: bold 12px Arial, Sans-serif; 
+	height: 30px;
+	margin: 0;
+	padding: 2px 3px; 
+	color: #48780E;
+	background: #000;
+	
+	border-width: 1px;
+  	border-style: solid;
+  	border-color: #1c1c1c;
+}
+
+/* search form */
+.searchform {
+	background-color: transparent;
+	border: none;	
+	margin: 0; padding: 20px 0 15px 8px;	
+	width: 270px;	
+}
+.searchform p { margin: 0; padding: 0 0 10px 0; }
+.searchform input.textbox { 
+	width: 185px;
+	height: 18px;
+	padding: 2px;	
+	vertical-align: top;
+}
+.searchform input.button { 
+	width: 60px;
+	height: 24px;
+	padding: 2px 5px;
+	vertical-align: top;
+}
+
+/* ------------------------------------------
+   LAYOUT
+------------------------------------------- */ 
+#wrap {
+	position: relative;
+	width: 900px;	
+	margin: 0 auto;
+	text-align: left;		
+}
+#content-wrap {
+	position: relative;
+	clear: both;
+	width: 900px;	
+	padding: 0; 		
+	margin-left: 5px;	
+	background: transparent;
+	float: left;	
+	display: inline;	
+	border-top: 1px solid #1A1A1A;
+}
+#header {
+	position: relative;
+	width: 900px;	
+	height: 370px;	
+	margin: 0; padding: 0;		
+	background: transparent;
+}
+
+/* header search */
+#header form#quick-search {
+	position: absolute;
+	top: 38px; right: 0;
+	padding: 0; margin: 0;
+	border: none;
+	width: 262px; height: 30px;
+	background: url(header-search.jpg) no-repeat;	
+	z-index: 999999;
+}
+#header form#quick-search p {
+	margin: 0; padding: 0;		
+}
+#header form#quick-search .tbox {
+	margin: 2px 0 0 5px; 
+	width: 210px;
+	background: none;
+	border: none;
+}
+#header form#quick-search label,
+#header form#quick-search .btn {
+	display: none;	
+}
+
+/*  Navigation  */
+#nav {
+	position: absolute;
+	margin: 0; padding: 0;		
+	height: 40px;
+	width: 900px;	
+	left: 0;	top: 35px;	
+	border-bottom: 1px solid #1A1A1A;
+}
+#nav ul {
+	float: left;
+	list-style: none;
+	width: 880px;		
+	height: 40px;
+	margin: 0 0 0 5px; padding: 0;	
+	display: inline;
+}
+#nav ul li {
+	display: inline;
+	margin: 0; padding: 0;
+}
+#nav ul li a {
+	float: left;
+	margin: 0;	padding: 0 8px;
+	font: bold 15px/35px 'Trebuchet MS', Helvetica, Arial, Geneva, sans-serif;
+	text-decoration: none;	
+	color: #5c9a12;	
+}
+#nav ul li a:hover, 
+#nav ul li a:active {
+	color: #eee;
+	background: none;
+	border: none;
+}
+#nav ul li#current a {	
+	color: #0077B5;	
+}
+
+#header h1#logo-text a {
+	position: absolute;
+	margin: 0; padding: 0;
+	font: normal 60px Georgia, 'Times New Roman', Times, serif;
+	letter-spacing: -1.5px;
+	color: #fff;
+	text-decoration: none;
+	
+	/* change the values of top and left to adjust the position of the logo*/
+	top: 120px; left: 10px;	
+}
+#header h1#logo-text a:hover {
+	background: none;	border: none;
+}
+#header p#intro {
+	position: absolute;
+	margin: 0; padding: 0;
+	font-family: Georgia, 'Times New Roman', Times, serif;
+	font-weight: normal;
+	font-size: 18px;
+	line-height: 1.6em;
+	font-style: italic;
+	text-transform: none;
+	color: #cd9857;
+	width: 500px;
+	
+	/* change the values of top and left to adjust the position */
+	top: 195px; left: 15px;		
+}
+
+/* Main Column */
+#main {
+	float: left;
+	width: 545px;
+	padding: 0; margin: 0;
+	display: inline;		
+}
+#main h2 {
+	padding-bottom: 3px;
+	margin-top: 15px;
+	font: normal 3.5em 'Trebuchet MS', Tahoma, Helvetica, Arial, sans-serif;
+	color: #fff; 
+	letter-spacing: -2px;	
+	text-transform: none;	
+}
+#main h2 a {
+	color: #fff;
+	text-decoration: none;		
+	border: none;	
+}
+#main ul li {
+	list-style-image: url(bullet.gif);
+	font-size: 14px;
+}
+#main p {
+	font-size: 14px;
+}
+
+/* Sidebar */	
+#sidebar {
+	float: right;
+	width: 290px;
+	padding: 0; margin: 25px 0 0 0;		
+	display: inline;	
+}	
+#sidebar h3 {
+	margin-top: 10px;
+	padding: 15px 5px 10px 5px; 
+	font: bold 2em 'Trebuchet MS', Tahoma, Helvetica, Arial, sans-serif;
+	background: url(footer-top.jpg) no-repeat center bottom;
+	color: #fefefe;
+}
+#sidebar ul.sidemenu {
+	text-align: left;
+	margin: 7px 5px 8px 0px; padding: 0;				
+}
+#sidebar ul.sidemenu li {
+	list-style: none;
+	padding: 8px 10px;
+	margin: 0;		
+	border-bottom: 1px solid #111;
+}
+* html body #sidebar ul.sidemenu li {
+	height: 1%;
+}
+#sidebar ul.sidemenu li a {
+	text-decoration: none;	
+	border: none;
+	color: #5d5d5d; 	
+		
+	font-weight: bold;		
+	font-family: 'Trebuchet MS', Tahoma, Helvetica, Arial, Sans-serif;
+	font-size: 14px;	
+	/* letter-spacing: .5px;  */
+}
+#sidebar ul.sidemenu li a span {
+	color: #444;	
+	font-family: Georgia, 'Times New Roman', Times, serif;
+	font-style: italic;
+	font-weight: normal;	
+	font-size: 11px;
+}
+#sidebar ul.sidemenu li a:hover,
+#sidebar ul.sidemenu li a:hover span {	
+	color: #fff;	
+}
+#sidebar ul.sidemenu ul { margin: 0 0 0 5px; padding: 0; }
+#sidebar ul.sidemenu ul li { border: none; }
+
+/* footer */
+#footer-wrap {
+	position: relative;
+	clear: both;
+	padding: 1em 0 2.5em 0;
+	margin-top: 30px;
+	font: normal 1em 'Trebuchet MS', Tahoma, sans-serif;	
+	background: #070707 url(footer-top.jpg) no-repeat center top;
+	color: #555;
+	width: 900px;
+	float: left;	
+	display: inline;
+}
+#footer-wrap h3 {
+	font: bold 2em/1.6em 'Trebuchet MS', Tahoma, sans-serif;
+	color: #ABABAB;	
+}
+#footer-content {	
+	margin: 0 auto;		
+	width: 880px;
+	text-align: left;		
+}
+#footer-content ul.col-list {
+	border-top: 1px solid #111;
+	list-style: none;
+	margin: 5px 0 0 5px; padding: 0;	
+	width: 98%;
+}
+#footer-content ul.col-list li {
+	border-bottom: 1px solid #111;
+}
+#footer-content ul.col-list li a {
+	display: block;
+	line-height: 1.5em;
+	font-weight: bold;
+	padding: 7px 0 7px 8px;
+	width: 98%;	
+	color: #555;
+	border: none;
+}
+#footer-content ul.col-list li a span {
+	color: #444;
+	font-style: italic;
+	font-weight: normal;
+	font-family: Georgia, 'Times New Roman', Times, serif;
+}
+#footer-content ul.col-list li a:hover,
+#footer-content ul.col-list li a:hover span {
+	color: #fff;
+	text-decoration: none;
+}
+
+#footer-content .col {
+	width: 280px;
+	padding: 0 0 30px 0;			
+	display: inline;
+}
+#footer-content .col2 {
+	width: 285px;
+	padding: 0 0 30px 0;	
+	display: inline;	
+}
+#footer-content .space-sep {
+	margin-right: 12px;
+}
+
+/* postmeta */
+.postmeta {	
+	padding: 7px 5px; margin: 20px 10px 15px 10px;	
+	font-size: 1em;	
+	color: #545454;
+	border: 1px solid #111;
+	background: #111;
+}
+.postmeta .date{ margin: 0 10px 0 5px;	}
+.postmeta a.comments { margin: 0 10px 0 5px;	}
+.postmeta a.readmore { margin: 0 10px 0 5px;	}
+
+.post-info { font-size: .95em; padding-top: 3px; margin-left: 5px; color: #444;	}
+.post-info a { color: #BD4200; }
+
+/* alignment classes */
+.float-left  { float: left; }
+.float-right { float: right; }
+.align-left  { text-align: left; }
+.align-right { text-align: right; }
+
+/* display and additional classes */
+.clearer { clear: both; }
+
+.clear {
+	display:inline-block;
+}
+.clear:after {
+	display:block; 
+	visibility:hidden; 
+	clear:both; 
+	height:0; 
+	content: "."; 
+}
+
+div.ohloh div.gadget 
+{
+	border:0;
+}
+div.ohloh div.gadget div.main 
+{
+	width:140px;
+}
+div.ohloh div.gadget div.updated
+{
+	width:240px;
+}
+
+div.ohloh, div.ohloh div div p, div.ohloh div div h3, div.ohloh div div a 
+{ 
+	padding:1px;
+	font-size:10px;
+        color: black;
+        background-color: white;
+}
+
+div.ohloh img
+{
+  border-color: white;
+  padding:0;
+}
Binary files gdl-0.9.2/doc/www/images/footer-top.jpg and gdl/doc/www/images/footer-top.jpg differ
Binary files gdl-0.9.2/doc/www/images/header-search.jpg and gdl/doc/www/images/header-search.jpg differ
diff -ruN --exclude CVS gdl-0.9.2/doc/www/index.html gdl/doc/www/index.html
--- gdl-0.9.2/doc/www/index.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/index.html	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html>
+  <head>
+    <title>GDL - GNU Data Language</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/index.php"></HEAD>
+  </head>
+  <body>
+  </body>
+</html>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/index.php gdl/doc/www/index.php
--- gdl-0.9.2/doc/www/index.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/index.php	2011-08-12 10:20:48.000000000 -0600
@@ -0,0 +1,91 @@
+<?php require('_header.inc.php'); ?>
+			
+<h2>Introduction</h2>
+
+<p>
+GNU Data Language (GDL) is a free/libre/open source incremental compiler
+  compatible with IDL and to some extent with PV-WAVE.
+Together with its library routines it serves as a tool for data analysis 
+  and visualization in such disciplines as astronomy, geosciences and 
+  medical imaging. 
+GDL is free software licensed under the <a href="http://www.gnu.org/licenses/gpl.html">GPL</a>.
+GDL is developed by an international <a href="credits.php">team</a> of volunteers led by Marc Schellens - the project's founder
+</p>
+
+<p>
+GDL as a language is dynamically-typed, vectorized and has 
+  object-oriented programming capabilities. 
+GDL library routines handle numerical calculations, data visualisation, 
+  signal/image processing, interaction with host OS and data input/output. 
+GDL supports several data formats such as netCDF, HDF4, HDF5, GRIB, PNG, TIFF, 
+  DICOM, etc. 
+Graphical output is handled by X11, PostScript, SVG or z-buffer terminals, 
+  the last one allowing output graphics (plots) to be saved in a variety of  
+  raster graphics formats.
+GDL features integrated debugging facilities. 
+GDL has also a Python bridge (Python code can be called from GDL; GDL can be compiled 
+  as a Python module). 
+</p>
+
+<p>
+Packaged versions of GDL are available for several Linux and BSD flavours as well as Mac&nbsp;OS&nbsp;X. 
+The source code compiles as well on other UNIX systems, including Solaris.
+</p>
+
+<p>
+Other open-source numerical data analysis tools similar to GDL include
+<a href="http://www.gnu.org/software/octave/">GNU&nbsp;Octave</a>,
+<a href="http://www.ncl.ucar.edu/">NCL&nbsp;-&nbsp;NCAR&nbsp;Command&nbsp;Language</a>,
+<a href="http://pdl.perl.org/">PDL&nbsp;-&nbsp;Perl&nbsp;Data&nbsp;Language</a>,
+<a href="http://www.r-project.org/">R</a>,
+<a href="http://www.scilab.org/">Scilab</a>,
+<a href="http://www.scipy.org/">SciPy</a>,
+<a href="http://yorick.sourceforge.net/">Yorick</a> ...
+</p>
+
+<h2>Feature summary</h2>
+
+<p>Full syntax compatibility with IDL up to version 7.1 (for &gt;8.0 see below):</p>
+
+<ul>
+    <li>objects, pointers, structs and arrays,</li>
+    <li>system, common block and assoc variables,</li>
+    <li>all operators and datatypes,</li>
+    <li>_EXTRA, _STRICT_EXTRA and _REF_EXTRA keywords...</li>
+</ul>
+
+<p>Supported IDL 8.0 language elements:</p>
+
+<ul>
+    <li>FOREACH loop</li>
+    <li>negative array indices</li>
+    <li>garbage collection pointers and objects</li>
+    <li>call methods on an object using "." (e. g. object.aMemberProcedure,arg1)</li>
+</ul>
+
+<p>The file input output system is fully implemented<br/>
+(Exception: For formatted I/O the C() sub-codes are not supported yet)</p>
+
+<p>Supported file formats include:</p>
+<ul>
+  <li>netCDF 3 (read/write)</li>
+  <li>HDF4 (read/write)</li>
+  <li>HDF5 (read-only, limited support)</li>
+  <li>IDL SAVE files (supported using the Craig Markwardt's <a href="http://cow.physics.wisc.edu/~craigm/idl/down/cmsvlib.tar.gz">CMSVLIB</a>)</li>
+  <li>FITS files, when Astro Lib. is in the path (<a href="http://www.cv.nrao.edu/fits/data/tests/pg93/NRAO pg93"> test suite</a> OK)</li>
+  <li>various graphic formats (e.g. PNG if compiled with ImageMagick)</li>
+  <li>...</li>
+</ul>
+
+<p>
+Graphical output is partially implemented. The PLOT, OPLOT, PLOTS,
+ XYOUTS, CONTOUR, SURFACE, TVRD and TV commands
+(along with WINDOW, WDELETE, SET_PLOT, WSET, TVLCT) work 
+(important keywords, some !P
+system variable tags and multi-plots are supported) 
+for X windows, z-buffer and postscript output.
+</p>
+
+<p>GUI support (widgets) is officially provided since the 0.9 version (but it's not complete yet).</p>
+ 
+<?php require('_footer.inc.php'); ?>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/menu.html gdl/doc/www/menu.html
--- gdl-0.9.2/doc/www/menu.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/menu.html	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL ::. menu</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/index.php"></HEAD>
+  </head>
+  <body>
+  </body>
+</html>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/_news.inc.php gdl/doc/www/_news.inc.php
--- gdl-0.9.2/doc/www/_news.inc.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/_news.inc.php	2012-05-08 03:48:44.000000000 -0600
@@ -0,0 +1,37 @@
+<h2>GDL 0.9.2 released</h2>
+<p>
+  2012-02-20: Ubuntu package updated<br />
+  2011-12-27: Gentoo package updated<br />
+  2011-11-16: Fink package updated<br />
+  2011-11-15: Debian package updated<br />
+  2011-11-14: Macports port updated<br />
+  2011-11-13: HMUG package updated<br />
+  2011-11-13: FreeBSD port updated<br />
+  2011-11-12: ArchLinux package updated<br />
+  2011-11-11: Fedora package updated<br />
+  2011-11-09: GDL 0.9.2 source tarball released.<br />
+  <span class="align-right"><a href="http://sourceforge.net/projects/gnudatalanguage/files/gdl/0.9.2/README/download">release notes</a> | <a href="downloads.php">downloads</a></span>
+</p>
+
+<h2>GDL @ADASS XXI</h2>
+<p>2011-11-09: <a href="http://aramis.obspm.fr/~coulais/IDL_et_GDL/Adass2011/slides_ADASS2011_GDL_Coulais.pdf">GDL talk</a> and <a href="http://aramis.obspm.fr/~coulais/IDL_et_GDL/Adass2011/O11_ADASS2011_GDL_Coulais.pdf">GDL paper</a> at the <a href="http://www.eso.org/sci/meetings/2011/adass2011.html">ADASS XXI</a> in Paris</p>
+
+<h2>GDL @GHM2011</h2>
+<p>2011-08-27: <a href="http://www.igf.fuw.edu.pl/~slayoo/gdl-ghm2011paris.pdf">GDL talk</a> at the <a href="http://www.gnu.org/ghm/2011/paris/">GHM</a> in Paris</p>
+
+<h2>New website</h2>
+<p>2011-07-07: We have new website!</p>
+
+<h2>GDL 0.9.1 released</h2>
+<p>
+  2011-07-02: Macports port updated<br />
+  2011-04-19: Fink package updated<br />
+  2011-04-08: HMUG package updated<br />
+  2011-04-08: Gentoo package updated<br />
+  2011-04-06: FreeBSD port updated<br />
+  2011-04-02: ArchLinux package updated<br />
+  2011-03-31: Debian/Ubuntu package updated<br />
+  2011-03-30: Fedora package updated<br />
+  2011-03-29: GDL 0.9.1 source tarball released.
+  <span class="align-right"><a href="http://sourceforge.net/projects/gnudatalanguage/files/gdl/0.9.1/gdl-0.9.1.relnotes/download">release notes</a> | <a href="downloads.php">downloads</a></span>
+</p>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/require.html gdl/doc/www/require.html
--- gdl-0.9.2/doc/www/require.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/require.html	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL requirements</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/requirements.php"></HEAD>
+  </head>
+  <body>
+  </body>
+</html>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/requirements.php gdl/doc/www/requirements.php
--- gdl-0.9.2/doc/www/requirements.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/requirements.php	2011-09-19 06:06:11.000000000 -0600
@@ -0,0 +1,86 @@
+<?php require('_header.inc.php'); ?>
+			
+<h2>Requirements</h2>
+
+<p>Obligatory libraries:</p>
+<ul>
+    <li><a href="http://plplot.sourceforge.net/">plplot</a></li>      
+    <li><a href="http://www.gnu.org/software/gsl">gsl</a></li>         
+    <li><a href="http://tiswww.case.edu/php/chet/readline/rltop.html">readline</a></li>
+</ul>    
+
+<p>Optional libraries:</p>
+<ul>
+    <li>Xlib (part of any X11 distribution; needed for ploting on screens !)</li>
+    <li><a href="http://www.imagemagick.org/Magick++/">Magick++</a> (ImageMagick's C++ API; PNG and JPEG support)</li>   
+    <li><a href="http://www.fftw.org/">FFTW</a> (both float and double versions needed; faster than FFT code provide by the GSL for 2^N 3^M 5^O cases)</li>
+    <li><a href="http://www.unidata.ucar.edu/software/netcdf/">netCDF</a> (v3 or v4)</li>   
+    <li><a href="http://www.hdfgroup.org/products/hdf4/">HDF4</a></li>
+    <li><a href="http://www.hdfgroup.org/HDF5/">HDF5</a></li>
+    <li><a href="http://www.ecmwf.int/products/data/software/grib_api.html">GRIB API</a></li>
+    <li><a href="http://www.unidata.ucar.edu/software/udunits/">UDUNITS-2</a></li>
+    <li><a href="http://www.wxwidgets.org/">wxWidgets</a></li>
+    <li><a href="http://home.comcast.net/~gevenden56/proj/">libproject</a> (mapping on Earth)</li>
+    <li><a href="ftp://ftp.soest.hawaii.edu/pwessel/gshhs/">GSHHS</a> (see GDL's <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/MAP_INSTALL">MAP_INSTALL</a> file)</li>
+    <li><a href="http://pslib.sourceforge.net/">pslib</a> (fine-tuning PostScript output)</li>
+</ul>
+
+<p>The Python interface (see <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/PYTHON.txt">PYTHON.txt</a>) requires:</p>
+<ul>
+    <li><a href="http://www.python.org/">Python</a></li>   
+    <li><a href="http://numpy.scipy.org/">Numpy</a></li>
+</ul>
+
+<p>Useful IDL/GDL-written libraries:</p>
+<ul>
+    <li><a href="http://cow.physics.wisc.edu/~craigm/idl/cmsave.html">CMSVLIB</a> (for SAVE and RESTORE)</li>
+    <li><a href="http://cow.physics.wisc.edu/~craigm/idl/fitting.html">MPFIT</a> (fitting)</li>
+    <li><a href="http://idlastro.gsfc.nasa.gov/">Astron Lib</a> (FITS format I/O, astronomy-related procedures)</li>
+    <li><a href="http://physics.mnstate.edu/craig/textoidl/">TeXtoIDL</a> (Greek letters, special symbols, sub/superscripts via TeX commands)</li>
+</ul>
+
+<p>At least g++ 3.2 (or a similar C++ standard conforming
+compiler) is needed for compiling GDL. 
+<!--Note that problems were reported with following versions of g++:
+</p>
+<ul>
+  <li>g++ 3.3.1 (problems with static casts)</li>
+  <li>g++ 3.3.5 (buggy nested templates)</li>
+  <li>g++ 3.3 build 1671 shipped with OS X</li>
+</ul>
+<p>
+-->
+Succesfull compilations were reported with Intel C++ compiler and numerous versions
+of GCC including the 3.x and 4.x families, on various UNIX environments including
+Linux, Mac OS X, FreeBSD, OpenSolaris, Cygwin and OpenBSD. 
+GCC &gt;= 4.2 is needed for OpenMP.
+</p>
+
+<p>The <a href="http://ftp.gnu.org/pub/gnu/readline/readline-5.0.tar.gz">GNU readline</a>
+library 4.3 or later is needed (GDL should compile
+without it, but it's very inconvenient to use that way, furthermore,
+proper event handling for graphic windows requires readline).<br/>
+OS X 10.4: Note that the the readline library which comes with OS X is <b>
+not</b> GNU readline. You need to install GNU readline and set the --with-readlinedir=DIR option to configure.
+</p>
+
+<p>
+  GDL supports compilation using both the shipped autotools "configure" script as well as using CMake.
+  Consult the <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/README">README</a> 
+  and the <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/INSTALL">INSTALL</a> 
+  files in the GDL distribution for further details on GDL requirements and configuration.
+</p>
+
+<p>GDL was developed using <a href="http://www.antlr2.org">ANTLR v2</a> 
+but unless you want to change the grammar (*.g files) you don't need
+ANTLR. All relevant ANTLR files are included in the package.<br/>
+</p>
+
+<!--
+<p>GDL is currently developed using <a href="http://www.kdevelop.org">KDevelop</a> 
+3.5.1 under the GNU/Linux distribution Kubuntu. The KDevelop project file is included in the tarball, so if you
+have KDevelop you should be able to use it with GDL seamlessly.</p>
+-->
+
+ 
+<?php require('_footer.inc.php'); ?>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/resources.html gdl/doc/www/resources.html
--- gdl-0.9.2/doc/www/resources.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/resources.html	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL Resources</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/resources.php"></HEAD>
+  </head>
+  <body>
+  </body>
+</html>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/resources.php gdl/doc/www/resources.php
--- gdl-0.9.2/doc/www/resources.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/resources.php	2012-04-30 02:20:38.000000000 -0600
@@ -0,0 +1,117 @@
+<?php require('_header.inc.php'); ?>
+
+<h2><a href="index.html">GDL resources</a></h2>
+
+<p>
+  A <a href="documentation.php">draft of GDL documentation</a> is currently under development.
+</p>
+
+<p>
+  There were several talks and posters on GDL prepared by the project team:
+</p>
+<ul>
+  <li><a href="http://aramis.obspm.fr/~coulais/IDL_et_GDL/Adass2011/slides_ADASS2011_GDL_Coulais.pdf">talk @ ADASS 2011</a> by Alain Coulais</li> (no definitive version of the <a href="http://aramis.obspm.fr/~coulais/IDL_et_GDL/Adass2011/O11_ADASS2011_GDL_Coulais.pdf">corresponding paper</a>)
+  <li><a href="http://www.igf.fuw.edu.pl/~slayoo/gdl-ghm2011paris.pdf">talk @ GHM 2011</a> by Alain Coulais &amp; Sylwester Arabas</li>
+  <li><a href="http://www.igf.fuw.edu.pl/~slayoo/gdl-fosdem-2011-talk.pdf">talk @ FOSDEM 2011</a> by Sylwester Arabas</li>
+  <li><a href="http://www.igf.fuw.edu.pl/~slayoo/prezentacja-jamstec-20100820.pdf">talk/tutorial at The Earth Simulator Center</a> by Alain Coulais, Sylwester Arabas &amp; Takeshi Enomoto</li>
+  <li><a href="http://www.igf.fuw.edu.pl/~slayoo/gdl-poster-egu2010.pdf">poster @ EGU 2010</a> by Sylwester Arabas</li>
+  <li><a href="http://aramis.obspm.fr/~coulais/IDL_et_GDL/ADASS09_GDL_Coulais.pdf">talk @ ADASS 2009</a> by Alain Coulais</li>
+  <li><a href="http://2007.rmll.info/IMG/pdf/RMLL07Sc_GDL_ACoulais.pdf">talk @ RMLL 2007</a> by Alain Coulais</li>
+</ul>
+
+<p>
+  The ADASS talk has a corresponding paper in the ASP Conference Series (and&nbsp;in&nbsp;arXiv), and this is currently
+    the best way to cite GDL:
+</p>
+<ul>
+  <li><a href="http://www.aspbooks.org/a/volumes/article_details/?paper_id=32122">Coulais et al. 2010 @ ACP CS 434 (ISBN: 978-1-58381-748-3)</a></li>
+  <li><a href="http://arxiv.org/abs/1101.0679">Coulais et al. 2011 article @ arXiv</a></li>
+</ul>
+			
+<p>
+  Alain Coulais maintains:
+</p>
+  <ul>
+    <li><a href="https://sympa.obspm.fr/wws/info/gdl-announces">a mailing list with announces about GDL</a></li>
+    <li><a href="http://aramis.obspm.fr/~coulais/IDL_et_GDL/memo_GDL.html">a constantly updated memo about GDL (in French)</a></li>
+    <li><a href="http://aramis.obspm.fr/~coulais/IDL_et_GDL/Matrice_IDLvsGDL.html">a list of IDL routines versus GDL availability</a> (see also <a href="documentation.php">the docs</a>)</li>
+  </ul>
+
+<p>
+  Several people prepared scholarly materials using or mentioning GDL:
+</p>
+  <ul>
+    <li><a href="http://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2009/index.shtml">A series of lectures on numerical hydrodynamics including ''IDL / GDL Micro-manual and exercises''</a></li>
+    <li><a href="http://blog.redbranch.net/series/gdl-gnu-data-language/">A series of blog posts on GDL (installation, usage, code examples)</a></li>
+    <li><a href="http://www.sgeier.net/tools/GDL-intro.pdf">Getting started with GDL</a> by Sven Geier (2006)</li>
+    <li><a href="http://solar.physics.montana.edu/clowder/IDL/idlguide.pdf">Interactive Data Language Guide</a> by Chris Lowder (2010)</li>
+    <li><a href="http://www.igf.fuw.edu.pl/~slayoo/mpdm2009/">A course in meteo data processing in GDL</a> by Sylwester Arabas (2009, slides in Polish)</li>
+    <li><a href="http://www.igf.fuw.edu.pl/~slayoo/mpdm2008/">A course in meteo data processing in GDL</a> by Sylwester Arabas (2008, slides in Polish)</li>
+  </ul>
+
+<p>
+  Some uses of GDL were documented by the users:
+</p>
+  <ul>
+    <li>article ''<a href="http://arxiv.org/abs/1004.1507">Scalelength of disc galaxies</a>'' by Fathi et al. mentioning use of GDL</li>
+    <li>article ''<a href="http://arxiv.org/abs/0903.2056">Detection of VHE Gamma Radiation from the Pulsar Wind Nebula MSH 15-52 with H.E.S.S.</a>'' by Frank Breitling mentioning use of GDL</li>
+    <li>article ''<a href="http://arxiv.org/abs/0903.2979">ULySS: A Full Spectrum Fitting Package</a>'' by Koleva et al. mentioning GDL</li>
+    <li>article ''<a href="http://arxiv.org/abs/1004.4506v3">On the suspected timing error in WMAP map-making</a>'' by Boudewijn Roukema mentioning use of GDL</a> 
+    <li><a href="http://www.nvidia.com/content/GTC/posters/89_Cheung_GPU_Acceleration_of_the_Scientific_Data.pdf">GPU Acceleration of the Scientific Data Analysis Package GDL</a> by A. Jaffey, A. Kobashi and M. C. M. Cheung (AGU poster)</li>
+    <li><a href="http://esoads.eso.org/abs/2008AGUFMIN13A1062J">Online data analysis using Web GDL</a> by Jaffey, A., Cheung, M. &amp; Kobashi, A. (AGU abstract)</li>
+    <li><a href="http://healpix.jpl.nasa.gov/html/install.htm">HEALPix Facility Installation Guidelines</a>(including a section on GDL compatibility)</li>
+    <li><a href="http://www-astro.physics.ox.ac.uk/~mxc/idl/">Michele Cappellari IDL (and free GDL) Programs</a></li>
+    <li><a href="http://idlastro.gsfc.nasa.gov/idlfaq.html">The IDL Astronomy Library FAQ</a> (including a note on GDL)</li>
+    <li><a href="http://hesperia.gsfc.nasa.gov/colinux/">Using the GNU Data Language (GDL) on Windows in a Cooperative Linux (coLinux) Environment</a> by Merrick Berg (2006)</li>
+  </ul>
+
+<h2><a href="index.html">IDL resources</a></h2>
+
+<p>As GDL is almost 100% compatible to IDL (although not complete as many
+subroutines are waiting to be implemented), resources for IDL can also
+be utilized for GDL.</p>
+ 
+<p>
+Many IDL resources can be found on the pages run by IDL gurus: <a href="http://www.idlcoyote.com/">David Fanning</a>
+  and <a href="http://michaelgalloy.com/">Michael Galloy</a>,
+  and at the <a href="http://groups.google.com/group/comp.lang.idl-pvwave">comp.lang.idl-pvwave</a> usenet group.
+
+</p>
+<!--
+<p>
+Lots of routines written for IDL can be found with the
+<a href="http://www.astro.washington.edu/deutsch/idl/htmlhelp/"
+target="_self">IDL Libraries Browser</a> many of them should also
+work with GDL.
+</p>
+-->
+
+<p>
+IDL 6.4 documentation is published at the <a href="http://idlastro.gsfc.nasa.gov/idl_html_help/home.html">NASA website</a>.
+Documentation for the current version of IDL is available for download from the <a href="http://ittvis.com">ITTVIS website</a>.
+</p>
+
+<p>
+An IDL online tutorial is available at the Scientific Computing and
+Visualization <a href="http://www.bu.edu/tech/research/training/tutorials/idl/">website</a>.
+</p>
+
+<p>
+<a href="http://www.mpia.de/imprs-hd/documents/IDLGuide.pdf">A (very) quick guide to IDL</a> was written by Chris North.
+</p>
+
+<p>
+Robert da Silva maintains the <a href="http://slugidl.pbworks.com/w/page/28913065/A-Slug's-Guide-to-IDL">Slug's Guide to IDL</a>.
+</p>
+
+<p>
+Mark Piper maintains the <a href="http://idldatapoint.com/">The IDL Data Point</a>.
+</p>
+
+<p>
+For writing programs in GDL using <a href="http://www.gnu.org/software/emacs/">Emacs</a> the Emacs addon (mode) 
+<a href="http://www.idlwave.org/">IDLWAVE</a>, maintained
+by J.D. Smith is highly appreciated. <a href="http://www.vim.org/">Vim</a> support IDL/GDL syntax highlighting by default.
+</p>
+
+<?php require('_footer.inc.php'); ?>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/screenshot.html gdl/doc/www/screenshot.html
--- gdl-0.9.2/doc/www/screenshot.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/screenshot.html	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL ::. Screenshots</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/screenshots.php"></HEAD>
+  </head>
+  <body>
+  </body>
+</html>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/screenshots/make_thumbnails gdl/doc/www/screenshots/make_thumbnails
--- gdl-0.9.2/doc/www/screenshots/make_thumbnails	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/screenshots/make_thumbnails	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,4 @@
+rm *_thumb.png
+for i in *.png; do 
+  convert $i -thumbnail 250x400 -unsharp 0x.5 `basename $i .png`_thumb.png
+done
Binary files gdl-0.9.2/doc/www/screenshots/screenshot01.png and gdl/doc/www/screenshots/screenshot01.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot01_thumb.png and gdl/doc/www/screenshots/screenshot01_thumb.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot02.png and gdl/doc/www/screenshots/screenshot02.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot02_thumb.png and gdl/doc/www/screenshots/screenshot02_thumb.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot03.png and gdl/doc/www/screenshots/screenshot03.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot03_thumb.png and gdl/doc/www/screenshots/screenshot03_thumb.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot04.png and gdl/doc/www/screenshots/screenshot04.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot04_thumb.png and gdl/doc/www/screenshots/screenshot04_thumb.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot05.png and gdl/doc/www/screenshots/screenshot05.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot05_thumb.png and gdl/doc/www/screenshots/screenshot05_thumb.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot06.png and gdl/doc/www/screenshots/screenshot06.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot06_thumb.png and gdl/doc/www/screenshots/screenshot06_thumb.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot07.png and gdl/doc/www/screenshots/screenshot07.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot07_thumb.png and gdl/doc/www/screenshots/screenshot07_thumb.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot08.png and gdl/doc/www/screenshots/screenshot08.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot08_thumb.png and gdl/doc/www/screenshots/screenshot08_thumb.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot09.png and gdl/doc/www/screenshots/screenshot09.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot09_thumb.png and gdl/doc/www/screenshots/screenshot09_thumb.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot10.png and gdl/doc/www/screenshots/screenshot10.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot10_thumb.png and gdl/doc/www/screenshots/screenshot10_thumb.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot11.png and gdl/doc/www/screenshots/screenshot11.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot11_thumb.png and gdl/doc/www/screenshots/screenshot11_thumb.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot12.png and gdl/doc/www/screenshots/screenshot12.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot12_thumb.png and gdl/doc/www/screenshots/screenshot12_thumb.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot13.png and gdl/doc/www/screenshots/screenshot13.png differ
Binary files gdl-0.9.2/doc/www/screenshots/screenshot13_thumb.png and gdl/doc/www/screenshots/screenshot13_thumb.png differ
diff -ruN --exclude CVS gdl-0.9.2/doc/www/screenshots.php gdl/doc/www/screenshots.php
--- gdl-0.9.2/doc/www/screenshots.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/screenshots.php	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,125 @@
+<?php require('_header.inc.php'); ?>
+
+<h2><a href="index.html">Screenshots</a></h2>
+
+<table cellspacing="10">
+
+  <tr>
+    <td>
+      <a href="screenshots/screenshot01.png">
+        <img src="screenshots/screenshot01_thumb.png" alt="GDL drawing fractals" /> 
+      </a>
+      <br />
+      GDL rendering the Mandelbrot set. Screenshot generated using the APPLEMAN procedure
+      (included in GDL distribution, file: src/pro/appleman.pro)
+    </td>
+    <td>
+      <a href="screenshots/screenshot02.png">
+        <img src="screenshots/screenshot02_thumb.png" alt="GDL compressing weather-radar data using wavelet transform" /> 
+      </a>
+      <br />
+      GDL compressing weather-radar images using truncated wavelet approximation.
+    </td>
+  </tr>
+
+  <tr>
+    <td>
+      <a href="screenshots/screenshot03.png">
+        <img src="screenshots/screenshot03_thumb.png" alt="GDL run via a web interface" /> 
+      </a>
+      <br />
+      GDL used as a part of a web-interface for controlling 2D fluid flow simulation and 
+      visualizing the output (reading netCDF files and outputting SVG plots).
+    </td>
+    <td>
+      <a href="screenshots/screenshot04.png">
+        <img src="screenshots/screenshot04_thumb.png" alt="GDL plotting data from a MODIS HDF file" /> 
+      </a>
+      <br />
+      GDL plotting data from a HDF file with MODIS satellite image.
+    </td>
+  </tr>
+
+  <tr>
+    <td>
+      <a href="screenshots/screenshot05.png">
+        <img src="screenshots/screenshot05_thumb.png" alt="GDL used for demonstrating Kalman filtering" /> 
+      </a>
+      <br />
+      GDL used for demonstrating Kalman filtering.
+    </td>
+    <td>
+      <a href="screenshots/screenshot06.png">
+        <img src="screenshots/screenshot06_thumb.png" alt="GDL-generated PostScript plot of a Fourier tranform in a LaTeX-generated PDF file" /> 
+      </a>
+      GDL-generated PostScript plot of a Fourier spectrum in a LaTeX-generated PDF file.
+    </td>
+  </tr>
+
+  <tr>
+    <td>
+      <a href="screenshots/screenshot07.png">
+        <img src="screenshots/screenshot07_thumb.png" alt="GDL plotting weather-forecast map from a GRIB file with the GFS model output" /> 
+      </a>
+      <br />
+      GDL plotting weather-forecast map from a GRIB file with NOAA GFS model output.
+    </td>
+    <td>
+      <a href="screenshots/screenshot08.png">
+        <img src="screenshots/screenshot08_thumb.png" alt="GDL plotting Daubechies wavelet to an SVG file under OpenSolaris" /> 
+      </a>
+      <br />
+      GDL plotting Daubechies wavelet to an SVG file under OpenSolaris.
+    </td>
+  </tr>
+
+  <tr>
+    <td>
+      <a href="screenshots/screenshot09.png">
+        <img src="screenshots/screenshot09_thumb.png" alt="GDL writing a surface plot to a PNG file under Cygwin on Windows" /> 
+      </a>
+      <br />
+      GDL writing a surface plot to a PNG file under Cygwin on Windows (by Mateusz Turcza).
+    </td>
+    <td>
+      <a href="screenshots/screenshot10.png">
+        <img src="screenshots/screenshot10_thumb.png" alt="GDL rendering the Madnelbrot set in an X window under coLinux on Windows" /> 
+      </a>
+      <br />
+      GDL rendering the Mandelbrot set in an X window under coLinux on Windows (<a href="http://hesperia.gsfc.nasa.gov/colinux/" >by Merrick Berg</a>).
+    </td>
+  </tr>
+  <tr>
+    <td>
+      <a href="screenshots/screenshot11.png">
+        <img src="screenshots/screenshot11_thumb.png" alt="GDL rendering two HST images of Saturn (FITS files read with
+							   Astron Lib) on Mandriva Linux 2009" /> 
+      </a>
+      <br />
+      GDL rendering two HST images of <a href="http://fr.wikipedia.org/wiki/Aurore_polaire">Polar Aurorae</a> on Saturn in UV
+      taken with STIS camera (by <a href="http://www.lesia.obspm.fr/Sur-les-autres-planetes-du-systeme.html">Palier and Prange</a>, 1999) (FITS files read with
+      <a href="http://idlastro.gsfc.nasa.gov/">Astron Lib</a>) on <a href="http://mandriva.com/">Mandriva Linux 2009</a>.
+    </td>
+    <td>
+      <a href="screenshots/screenshot12.png">
+        <img src="screenshots/screenshot12_thumb.png" alt=""/>
+      </a>
+      <br />
+      GDL used for analyzing <a href="http://en.wikipedia.org/wiki/LIDAR">LIDAR</a> data (reading them from netCDF files, producing PostScript plots) on Linux, using <a href="http://idlwave.org/">the IDLWAVE mode for Emacs</a>. (by Micha&#322; Pi&#261;d&#322;owski)
+    </td>
+  </tr>
+  <tr>
+    <td>
+      <a href="screenshots/screenshot13.png">
+        <img src="screenshots/screenshot13_thumb.png" alt="" />
+      </a>
+      <br />
+      Calling GDL from Python and vice versa (using <a href="http://numpy.scipy.org/">Numpy</a> and <a href="http://matplotlib.sourceforge.net/">matplotlib</a>).
+    </td>
+    <td>&nbsp;
+    </td>
+  </tr>
+  
+</table>
+			
+<?php require('_footer.inc.php'); ?>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/support.html gdl/doc/www/support.html
--- gdl-0.9.2/doc/www/support.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/support.html	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL Support</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/support.php"></HEAD>
+  </head>
+  <body>
+  </body>
+</html>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/support.php gdl/doc/www/support.php
--- gdl-0.9.2/doc/www/support.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/support.php	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,59 @@
+<?php require('_header.inc.php'); ?>
+
+<h2><a href="index.html">How to get support?</a></h2>
+<p>
+  If you don't find an answer to your problem in:
+</p>
+  <ul>
+    <li><a href="documentation.php">GDL documentation draft</a></li>
+    <li><a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/">README/INSTALL files</a></li>
+    <li><a href="resources.php">other GDL- and IDL-related resources</a></li>
+  </ul>
+<p>
+  you might use one of these <a href="http://sourceforge.net/tracker/?group_id=97659">trackers</a>
+  or
+  <a href="http://sourceforge.net/projects/gnudatalanguage/forums">forums</a>. 
+</p>
+  
+			
+<h2><a href="index.html">How to provide feedback?</a></h2>
+<p>
+  Your comments are welcome! Let us know what you use GDL for. 
+  Or if you don't, why not. 
+  Which functionality are you missing/would appreciate most for comming versions.
+
+  Please send your bug reports, complaints, suggestions and comments using the
+  <a href="http://sourceforge.net/tracker/?group_id=97659">trackers</a>
+  or
+  <a href="http://sourceforge.net/projects/gnudatalanguage/forums">forums</a>.
+</p>
+
+<h2><a href="index.html">How to contribute?</a></h2>
+<p>
+  GDL is actively developed and has already a lot of functionality.
+  But it is still in beta state as of July 2011.
+  Even though it can already be used for many tasks, there are many
+  things left to be done.<br/>
+  Any contributions are very welcome. Currently contributions can be made in C/C++, GDL and python.
+  See the files 
+  <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/HACKING">HACKING</a>
+  and 
+  <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/PYTHON.txt">PYHTON.txt</a>
+  in the GDL root directory.
+</p>
+
+<p>Urgent things to do are:</p>
+<ul>
+  <li>Library functions and procedures</li>
+  <li>Documentation and code examples</li>
+  <li>Completing the graphical output system</li>
+  <li>Testing and test routines written in GDL</li>
+  <li>Enhancing the GUI (widget) functionality</li>
+  <li>Porting GDL to other platforms</li>
+</ul>
+
+<p>
+  Please send your contributions using the <a href="http://sourceforge.net/tracker/?group_id=97659">trackers</a>.
+</p>
+
+<?php require('_footer.inc.php'); ?>
diff -ruN --exclude CVS gdl-0.9.2/doc/www/tdl.html gdl/doc/www/tdl.html
--- gdl-0.9.2/doc/www/tdl.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/tdl.html	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL -TDL</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/index.php"></HEAD>
+  </head>
+  <body>
+  </body>
+</html>
diff -ruN --exclude CVS gdl-0.9.2/INSTALL gdl/INSTALL
--- gdl-0.9.2/INSTALL	2011-11-08 17:15:09.000000000 -0700
+++ gdl/INSTALL	2012-04-13 15:50:27.000000000 -0600
@@ -126,7 +126,7 @@
 initial values for variables by setting them in the environment.  Using
 a Bourne-compatible shell, you can do that on the command line like
 this:
-     CC=c89 CFLAGS=-O3 LIBS=-lposix ./configure
+     CC=c89 CFLAGS=-O2 LIBS=-lposix ./configure
 
 Or on systems that have the `env' program, you can do it like this:
      env CPPFLAGS=-I/usr/local/include LDFLAGS=-s ./configure
@@ -234,3 +234,16 @@
 
 `configure' also accepts some other, not widely useful, options.
 
+Libtool version mismatch
+========================
+
+On systems that use libtool, sometimes a mismatched version error arises at compile time, e.g.:
+libtool: Version mismatch error.  This is libtool 2.4 Debian-2.4-2ubuntu1, but the
+libtool: definition of this LT_INIT comes from libtool 2.2.6b.
+libtool: You should recreate aclocal.m4 with macros from libtool 2.4 Debian-2.4-2ubuntu1
+libtool: and run autoconf again.
+
+In that case it seems that the following set of commands solves the problem:
+> rm libtool aclocal.m4
+> autoreconf -vfi
+> make
diff -ruN --exclude CVS gdl-0.9.2/Makefile.in gdl/Makefile.in
--- gdl-0.9.2/Makefile.in	2011-11-01 17:46:36.000000000 -0600
+++ gdl/Makefile.in	2012-06-28 03:54:53.000000000 -0600
@@ -163,6 +163,7 @@
 FGREP = @FGREP@
 GDLDATADIR = @GDLDATADIR@
 GREP = @GREP@
+GraphicsMagickConfig = @GraphicsMagickConfig@
 HAVE_64BIT_OS = @HAVE_64BIT_OS@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff -ruN --exclude CVS gdl-0.9.2/NEWS gdl/NEWS
--- gdl-0.9.2/NEWS	2011-11-08 16:27:32.000000000 -0700
+++ gdl/NEWS	2012-07-13 16:39:45.000000000 -0600
@@ -535,5 +535,24 @@
            - memory leak fix (bug introduced in the previous version)
            - various testsuite & docs updates (incl. docs and examples for CALL_EXTERNAL)
 	   - fix in WordExp() when filename argument contain whitespaces (useful in various cases, including 
-	     OPENR/W, FILE_MKDIR, ...)
+	     OPENR/W, FILE_MKDIR, ...) [AC 2012/01/04: not finished :( 
 	   - !version.os now in lower case for Linux and Darwin
+
+0.9.3:
+	   - activities on speed improvements continuing
+	   - Initial import of STRMATCH()
+	   - Initial import of USERSYM
+	   - keyword /NaN for HISTOGRAM
+	   - Initial import of LUDC, LUSOL and DETERM, OK now only for DOUBLE
+	   - Initial import of CONGRID and BILINEAR
+	   - Initial import of TV for PS output
+	   - fix in RANDOMN/RANDOMU (Binomial OK, conflicting keywords detected ...)
+           - Initial import for QROMB(), QSIMP() (based on QROMB) and QROMO()
+           - Initial import for TRISOL()
+	   - fix in ERASE for background color (preparing Coyote lib. support)
+	   - Initial import of STANDARDIZE and HIST_EQUAL
+	   - improvment in MAGICK related codes, especially MAGICK_PING (pb with ImageMagick (IM) in Ubuntu 12.04; GraphicsMagick can also be used instead of IM)
+	   - FZ_ROOTS: initial import (same way than IMSL_ZEROPOLY using gsl_poly_complex_solve(), only real coefs. for input poly)
+	   - FX_ROOT: initial import. in c++
+           - keyword DIM in MOMENT(), MEAN(), STDDEV(), VARIANCE(), SKEWNESS(), KURTOSIS() (requested DIM and other improvments)
+           - keyword SIGN in FINITE
diff -ruN --exclude CVS gdl-0.9.2/src/antlr/Makefile.in gdl/src/antlr/Makefile.in
--- gdl-0.9.2/src/antlr/Makefile.in	2011-11-01 17:46:37.000000000 -0600
+++ gdl/src/antlr/Makefile.in	2012-06-28 03:54:54.000000000 -0600
@@ -209,6 +209,7 @@
 FGREP = @FGREP@
 GDLDATADIR = @GDLDATADIR@
 GREP = @GREP@
+GraphicsMagickConfig = @GraphicsMagickConfig@
 HAVE_64BIT_OS = @HAVE_64BIT_OS@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff -ruN --exclude CVS gdl-0.9.2/src/arrayindex.cpp gdl/src/arrayindex.cpp
--- gdl-0.9.2/src/arrayindex.cpp	2011-11-07 16:38:21.000000000 -0700
+++ gdl/src/arrayindex.cpp	2012-01-23 15:33:27.000000000 -0700
@@ -67,13 +67,13 @@
   
   if( s < 0)
     throw GDLException("Scalar subscript out of range [<].c");
-  if( s >= varDim)
+  if( s >= varDim && s > 0) // s == 0 is fine
     throw GDLException("Scalar subscript out of range [>].c");
   return 1;
 }
 SizeT ArrayIndexScalarVP::NIter( SizeT varDim) 
 {
-  s = varPtr->Data()->LoopIndex();
+  sInit = varPtr->Data()->LoopIndex();
   if( sInit < 0)
     s = sInit + varDim;
   else
@@ -81,7 +81,7 @@
   
   if( s < 0)
     throw GDLException("Scalar subscript out of range [<].d");
-  if( s >= varDim)
+  if( s >= varDim && s > 0) // s == 0 is fine
     throw GDLException("Scalar subscript out of range [>].d");
   return 1;
 }
@@ -89,6 +89,7 @@
 void ArrayIndexScalar::Init() 
 {
   sInit = GDLInterpreter::CallStackBack()->GetKW( varIx)->LoopIndex();
+  s = sInit;
 }
 
 
@@ -242,7 +243,11 @@
 void ArrayIndexListOneScalarT::SetVariable( BaseGDL* var) 
   {
     sInit = GDLInterpreter::CallStackBack()->GetKW( varIx)->LoopIndex();
-    if( var->IsAssoc()) return;
+    if( var->IsAssoc()) 
+    {
+      s = sInit;
+      return;
+    }
     if( sInit < 0)
       s = sInit + var->Size();
     else
@@ -259,6 +264,11 @@
 void ArrayIndexListOneScalarNoAssocT::SetVariable( BaseGDL* var) 
   {
     sInit = GDLInterpreter::CallStackBack()->GetKW( varIx)->LoopIndex();
+    if( var->IsAssoc()) 
+    {
+      s = sInit;
+      return;
+    }
 //     if( var->IsAssoc()) return;
     if( sInit < 0)
       s = sInit + var->Size();
@@ -395,8 +405,13 @@
     }
   if( nScalar == ixList->size())
   {
-	if( arrayIndexNoAssocOut != NULL)
-    *arrayIndexNoAssocOut = new ArrayIndexListScalarNoAssocT( ixList);
+    if( arrayIndexNoAssocOut != NULL)
+    {
+      if( ixList->size() == 2)
+	*arrayIndexNoAssocOut = new ArrayIndexListScalarNoAssoc2DT( ixList);
+      else
+	*arrayIndexNoAssocOut = new ArrayIndexListScalarNoAssocT( ixList);
+    }
     *arrayIndexOut = new ArrayIndexListScalarT( ixList);
     return;
   }	
@@ -405,20 +420,23 @@
   // ArrayIndexListMultiT
   if( nIndexed == 0)
   {
-	if( arrayIndexNoAssocOut != NULL)
-    *arrayIndexNoAssocOut = new ArrayIndexListMultiNoneIndexedNoAssocT( ixList);
+    if( arrayIndexNoAssocOut != NULL)
+      if( ixList->size() == 2)
+	*arrayIndexNoAssocOut = new ArrayIndexListMultiNoneIndexedNoAssoc2DT( ixList);
+      else
+	*arrayIndexNoAssocOut = new ArrayIndexListMultiNoneIndexedNoAssocT( ixList);
     *arrayIndexOut = new ArrayIndexListMultiNoneIndexedT( ixList);
     return;
   }	
   if( nIndexed == ixList->size())
   {
-	if( arrayIndexNoAssocOut != NULL)
-    *arrayIndexNoAssocOut = new ArrayIndexListMultiAllIndexedNoAssocT( ixList);
+    if( arrayIndexNoAssocOut != NULL)
+      *arrayIndexNoAssocOut = new ArrayIndexListMultiAllIndexedNoAssocT( ixList);
     *arrayIndexOut = new ArrayIndexListMultiAllIndexedT( ixList);
     return;
   }	
 
-	if( arrayIndexNoAssocOut != NULL)
-  *arrayIndexNoAssocOut = new ArrayIndexListMultiNoAssocT( ixList);
+  if( arrayIndexNoAssocOut != NULL)
+    *arrayIndexNoAssocOut = new ArrayIndexListMultiNoAssocT( ixList);
   *arrayIndexOut = new ArrayIndexListMultiT( ixList);
 }
diff -ruN --exclude CVS gdl-0.9.2/src/arrayindex.hpp gdl/src/arrayindex.hpp
--- gdl-0.9.2/src/arrayindex.hpp	2011-11-06 20:10:46.000000000 -0700
+++ gdl/src/arrayindex.hpp	2012-07-14 08:05:47.000000000 -0600
@@ -241,6 +241,7 @@
   void Init() 
   {
     sInit = varPtr->Data()->LoopIndex();
+    s = sInit;
   }
 
   void Clear()
@@ -493,11 +494,12 @@
 //     return res;
 //   }
 
-  void Init( BaseGDL* ix_)
+  void Init( BaseGDL* ix_)   
   {
     if( ix_->Rank() == 0) // type ONE
     {
       ix_->Scalar2RangeT(sInit);
+      s = sInit; // in case of assoc NIter is not called
       // int ret = ix_->Scalar2RangeT(s);
       // from GDL 0.9 on negative indices are fine
       // 	if( ret == -1) // index < 0
@@ -523,6 +525,7 @@
     //SizeT nElem = ix_->N_Elements();
     //    ix = new SizeT[ nElem]; // allocate array
 
+  //DEBUG if( ix != NULL)    
     assert( ix == NULL);
 
     //     ix = new AllIxMultiT( nElem);
@@ -547,7 +550,7 @@
 
       if( s < 0)
 	throw GDLException(NULL,"Subscript out of range [-i].",true,false);
-      if( s >= varDim)
+      if( s >= varDim && s > 0)
 	throw GDLException(NULL,"Subscript out of range [i].",true,false);
       return 1;
     }
@@ -674,7 +677,7 @@
 	  s = sInit;
 	if( s < 0)
 	  throw GDLException(NULL,"Subscript out of range [-i].",true,false);
-	if( s >= varDim)
+	if( s >= varDim && s > 0)
 	  throw GDLException(NULL,"Subscript out of range [i].",true,false);
 	return 1;
       }
@@ -824,7 +827,7 @@
 
   SizeT NIter( SizeT varDim)
   {
-    if( sInit >= varDim)
+    if( sInit >= varDim) // && s > 0)
       throw GDLException(NULL,"Subscript out of range [s:*].",true,false);
     if( sInit < 0)
     {
@@ -1023,7 +1026,7 @@
       throw 
 	GDLException(NULL,"Subscript range values of the form low:high "
 		"must be < size, with low <= high",true,false);
-    if( e >= varDim)
+    if( e >= varDim) // && e > 0)
 		throw GDLException(NULL,"Subscript out of range [s:e].",true,false);
     return (e - s + 1);
   }
@@ -1191,7 +1194,7 @@
     else
       s= sInit;
 
-    if( s >= varDim)
+    if( s >= varDim) // && s > 0)
       throw GDLException(NULL,"Subscript out of range [s:*:stride].",true,false);
     return (varDim - s + stride - 1)/stride;
   }
@@ -1402,7 +1405,7 @@
 			GDLException(NULL,"Subscript range values of the form low:high "
 				"must be < size, with low <= high",true,false);
     
-    if( e >= varDim)
+    if( e >= varDim) // && e > 0)
       {
 		throw GDLException(NULL,"Subscript out of range [s:E:st].",true,false);
       }
diff -ruN --exclude CVS gdl-0.9.2/src/arrayindexlistnoassoct.hpp gdl/src/arrayindexlistnoassoct.hpp
--- gdl-0.9.2/src/arrayindexlistnoassoct.hpp	2011-11-07 16:38:21.000000000 -0700
+++ gdl/src/arrayindexlistnoassoct.hpp	2012-07-10 11:47:17.000000000 -0600
@@ -121,15 +121,8 @@
 //   bool ToAssocIndex( SizeT& lastIx)
   bool ToAssocIndex( SizeT& lastIx)
   {
-    // cannot be ArrayIndexScalar[VP] ix->Init();
-    RangeT lastValIx;
-    if( !ix->Scalar( lastValIx))
-      throw GDLException( NULL,"Record number must be a scalar in this context.",true,false);
-
-    if( lastValIx < 0)
-      throw GDLException( NULL,"Record number must be a scalar > 0 in this context.",true,false);
-
-    lastIx = lastValIx;
+    assert( 0);
+    throw GDLException( NULL,"Internal error: ArrayIndexListOneNoAssocT::ToAssocIndex(...) called.",true,false);
     return true;
   }
 
@@ -173,6 +166,9 @@
   // returns 1-dim index for all elements
   AllIxBaseT* BuildIx()
   {
+    if( allIx != NULL) // can happen if called from DotAccessDescT::DoAssign()
+      return allIx;
+
     assert( allIx == NULL);
 //     if( allIx != NULL)
 // 		return allIx;
@@ -683,10 +679,10 @@
 	if( sInit < 0)
 	  s = sInit + var->Size();
 	if( s < 0)
-	  throw GDLException(NULL,"Scalar subscript out of range [<].2",true,false);
+	  throw GDLException(NULL,"Scalar subscript out of range [<].4",true,false);
 	if( s >= var->Size())
-	  throw GDLException(NULL,"Scalar subscript out of range [>].2",true,false);
-	var->AssignAtIx( s, right);
+	  throw GDLException(NULL,"Scalar subscript out of range [>].4",true,false);
+	var->AssignAtIx( s, right); // must use COPY_BYTE_AS_INT
 	return;
       }
     
@@ -713,11 +709,11 @@
 	if( sInit < 0)
 	  s = sInit + var->Size();
 	if( s < 0)
-		throw GDLException(NULL,"Scalar subscript out of range [<].3",true,false);
+		throw GDLException(NULL,"Scalar subscript out of range [<].5",true,false);
 	if( s >= var->Size())
 	{
 // 	    std::cout << s << " var->Size():" << var->Size() << std::endl;
-		throw GDLException(NULL,"Scalar subscript out of range [>].3",true,false);
+		throw GDLException(NULL,"Scalar subscript out of range [>].5",true,false);
 	}
 	
 	return var->NewIx( s);
@@ -761,16 +757,21 @@
   SizeT    acRank;               // rank upto which indexing is done
   const SizeT*    varStride; // variables stride
 //   SizeT    varStride[MAXRANK+1]; // variables stride
-  SizeT    nIx;                  // number of indexed elements
+//  SizeT    nIx;                  // number of indexed elements
 
   AllIxT allIx;
 //   AllIxT allIxInstance;
 
-  ArrayIndexT* ixListEnd; // for assoc index
+//   ArrayIndexT* ixListEnd; // for assoc index
+
+  // constructor
+  ArrayIndexListScalarNoAssocT():
+    acRank(0)
+  { nParam = 0;}
 
 public:    
   
-  ~ArrayIndexListScalarNoAssocT()
+  ~ArrayIndexListScalarNoAssocT() // cleanup done by related ArrayIndexListScalarT
   {
 //     delete allIx;
 // 	ixList.Destruct();
@@ -779,65 +780,56 @@
 //       {	delete *i;}
   }
 
-  // constructor
-  ArrayIndexListScalarNoAssocT():
-    acRank(0),
-//     allIx( NULL),
-    ixListEnd( NULL)
-  { nParam = 0;}
+//   // constructor
+//   ArrayIndexListScalarNoAssocT():
+//     acRank(0)
+// //     allIx( NULL),
+// //     ixListEnd( NULL)
+//   { nParam = 0;}
 
   ArrayIndexListScalarNoAssocT( const ArrayIndexListScalarNoAssocT& cp):
     ArrayIndexListT( cp),
 //     paramPresent( cp.paramPresent),
-    acRank(cp.acRank),
+    acRank(cp.acRank)
 //     allIx( NULL),
-    ixListEnd( NULL)
+//     ixListEnd( NULL)
   {
     //    ixList.reserve(MAXRANK); 
 //     assert( cp.allIx == NULL);
-    assert( cp.ixListEnd == NULL);
+//     assert( cp.ixListEnd == NULL);
 
     for( SizeT i=0; i<cp.ixList.size(); ++i)
       ixList.push_back( cp.ixList[i]->Dup());
   }
 
-  // called after structure is fixed
+  // called once after structure is fixed
   ArrayIndexListScalarNoAssocT( ArrayIndexVectorT* ix):
-    ixList( *ix),
+    ixList( *ix)
 //     allIx( NULL),
-    ixListEnd( NULL)
+//     ixListEnd( NULL)
   {
-    assert( ixList.size() > 1); // must be, from compiler
-    
     if( ix->size() > MAXRANK)
       throw GDLException(NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
 
+    assert( ixList.size() > 1); // must be, from compiler
+    
+    // set acRank
+    acRank = ixList.size();
+
     nParam = 0;
-    for( SizeT i=0; i<ixList.size(); ++i)
-      {
-		SizeT actNParam = ixList[i]->NParam();
-		if( actNParam == 1) 
-		{
-// 			paramPresent.push_back( i);
-			nParam++;
-		}
-      }
+//     for( SizeT i=0; i<ixList.size(); ++i)
+//       {
+// 		SizeT actNParam = ixList[i]->NParam();
+// 		if( actNParam == 1) 
+// 		{
+// // 			paramPresent.push_back( i);
+// 			nParam++;
+// 		}
+//       }
   }    
   
   void Clear()
   {
-//     delete allIx;
-//     allIx = NULL;
-    
-    if( ixListEnd != NULL) // revert assoc indexing
-      {
-		ixList.push_back( ixListEnd);
-		ixListEnd = NULL;
-      }
-//     // no clearing of scalar indices
-//     for( std::vector<ArrayIndexT*>::iterator i=ixList.begin(); 
-// 	 i != ixList.end(); ++i)
-//       {	(*i)->Clear();}
   }
 
 //   void Init( IxExprListT& ix)
@@ -856,42 +848,11 @@
   void Init()
   {}
   
-  // requires special handling
-  // used by Assoc_<> returns last index in lastIx, removes it
-  // and returns true if the list is empty
-  bool ToAssocIndex( SizeT& lastIx)
-  {
-    assert( ixListEnd == NULL);
-    
-    ixListEnd = ixList.pop_back_get();
-    
-    // init in case of ixListEnd->NParam == 0
-    ixListEnd->Init();
-
-    RangeT lastIxVal;
-    ixListEnd->Scalar( lastIxVal); // always scalar
-
-    if( lastIxVal < 0)
-      throw GDLException( NULL,"Record number must be a scalar > 0 in this context.",true,false);
-    
-    lastIx = lastIxVal;
-    return false; // multi dim
-  }
-
   // set the root variable which is indexed by this ArrayIndexListScalarT
   void SetVariable( BaseGDL* var) 
   {
-//     assert( allIx == NULL);
-    
-    // set acRank
-    acRank = ixList.size();
-    
-    // for assoc variables last index is the record
-//     if( var->IsAssoc()) 
-//       {
-// 	acRank--;
-// 	// if( acRank == 0) return; // multi dim
-//       }
+//     // set acRank
+//     acRank = ixList.size();
 
     // ArrayIndexScalar[VP] need this call to read their actual data
     // as their are not initalized (nParam == 0)
@@ -899,8 +860,6 @@
       ixList[i]->NIter( var->Dim(i)); // check boundary
 
     varStride = var->Dim().Stride();
-//     var->Dim().Stride( varStride, acRank); // copy variables stride into varStride
-    nIx = 1;
   }
 
   // structure of indexed expression
@@ -923,7 +882,7 @@
     SizeT s = ixList.FrontGetS(); //[0]->GetS();
     for( SizeT l=1; l < acRank; ++l)
       {
-			s += ixList[l]->GetS() * varStride[l]; 
+	s += ixList[l]->GetS() * varStride[l]; 
       }
 //     allIx = &allIxInstance; //new AllIxT(s);
 //     allIx->Set( s);
@@ -948,11 +907,12 @@
 
   void AssignAt( BaseGDL* var, BaseGDL* right)
   {
-    if( var->N_Elements() == 1)// && !var->IsAssoc())
+    // right, not var
+    if( right->N_Elements() == 1)// && !var->IsAssoc())
     {
       // SetVariable( var);
-      // set acRank
-      acRank = ixList.size();
+//       // set acRank
+//       acRank = ixList.size();
 
       varStride = var->Dim().Stride();
       // ArrayIndexScalar[VP] need this call to read their actual data
@@ -970,7 +930,7 @@
     }
     // var->N_Elements() > 1
     SetVariable( var);
-    assert( nIx == 1);    
+//     assert( nIx == 1);    
     if( var->EqType( right))
       {
 	var->AssignAt( right, this); // assigns inplace (not only scalar)
@@ -989,8 +949,8 @@
   {
     //    Init();
     // SetVariable( var);
-    // set acRank
-    acRank = ixList.size();
+//     // set acRank
+//     acRank = ixList.size();
     // for assoc variables last index is the record
 //     if( var->IsAssoc()) 
 //       {
@@ -1051,6 +1011,163 @@
 }; // class ArrayIndexListScalarT: public ArrayIndexListT
 
 
+// all scalar elements (multi-dim)
+const int acRank2D = 2;
+class ArrayIndexListScalarNoAssoc2DT: public ArrayIndexListT
+{
+private:
+  ArrayIndexVectorT ixList;
+//   std::vector<SizeT> paramPresent;
+
+//   enum AcRankEnum { acRank = 2; };
+  
+  SizeT    varStride; // variables stride
+//   SizeT    varStride[MAXRANK+1]; // variables stride
+//  SizeT    nIx;                  // number of indexed elements
+
+  AllIxT allIx;
+//   AllIxT allIxInstance;
+
+//   ArrayIndexT* ixListEnd; // for assoc index
+
+  // constructor
+  ArrayIndexListScalarNoAssoc2DT() { nParam = 0;}
+
+public:    
+  
+  ~ArrayIndexListScalarNoAssoc2DT() // cleanup done by related ArrayIndexListScalarT
+  {
+  }
+
+  ArrayIndexListScalarNoAssoc2DT( const ArrayIndexListScalarNoAssoc2DT& cp):
+    ArrayIndexListT( cp)
+  {
+    for( SizeT i=0; i<cp.ixList.size(); ++i)
+      ixList.push_back( cp.ixList[i]->Dup());
+
+    assert( ixList.size() == 2); // must be, from compiler
+  }
+
+  // called once after structure is fixed
+  ArrayIndexListScalarNoAssoc2DT( ArrayIndexVectorT* ix):
+    ixList( *ix)
+  {
+    if( ix->size() > MAXRANK)
+      throw GDLException(NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
+
+    assert( ixList.size() == 2); // must be, from compiler
+    nParam = 0;
+  }    
+  
+  void Clear()
+  {
+  }
+
+  ArrayIndexListT* Clone() { return new ArrayIndexListScalarNoAssoc2DT( *this);}
+
+  void Init()
+  {}
+  
+  // set the root variable which is indexed by this ArrayIndexListScalarT
+  void SetVariable( BaseGDL* var) 
+  {
+    varStride = var->Dim(0);
+    ixList[0]->NIter( varStride); // check boundary
+    ixList[1]->NIter( var->Dim(1)); // check boundary
+  }
+
+  // structure of indexed expression
+  const dimension GetDim()
+  {
+    return dimension(); // -> results in scalar
+  }
+
+  SizeT N_Elements()
+  {
+    return 1;
+  }
+
+  // returns 1-dim index for all elements
+  AllIxT* BuildIx()
+  {
+    SizeT s = ixList.FrontGetS() + ixList[1]->GetS() * varStride; 
+    allIx.Set( s);
+    return &allIx;
+  }
+
+  // returns one dim long ix in case of one element array index
+  // used by AssignAt functions
+  SizeT LongIx() const
+  {
+    SizeT s = ixList.FrontGetS() + ixList[1]->GetS() * varStride; 
+    return s;
+  }
+
+  void AssignAt( BaseGDL* var, BaseGDL* right)
+  {
+    // right, not var
+    if( right->N_Elements() == 1)// && !var->IsAssoc())
+    {
+      varStride = var->Dim(0);
+      // ArrayIndexScalar[VP] need this call to read their actual data
+      // as their are not initalized (nParam == 0)
+      ixList[0]->NIter( varStride); // check boundary
+      ixList[1]->NIter( var->Dim(1)); // check boundary
+      SizeT s = ixList.FrontGetS() + ixList[1]->GetS() * varStride;     
+      var->AssignAtIx( s, right); // assigns inplace
+      return;
+    }
+    // right->N_Elements() > 1
+    SetVariable( var);
+    if( var->EqType( right))
+      {
+	var->AssignAt( right, this); // assigns inplace (not only scalar)
+      }
+    else
+      {
+	BaseGDL* rConv = right->Convert2( var->Type(), BaseGDL::COPY);
+	std::auto_ptr<BaseGDL> conv_guard( rConv);
+	
+	var->AssignAt( rConv, this); // assigns inplace (not only scalar)
+      }
+  }
+
+  // optimized for one dimensional access
+  BaseGDL* Index( BaseGDL* var, IxExprListT& ix)
+  {
+    varStride = var->Dim(0);
+    // ArrayIndexScalar[VP] need this call to read their actual data
+    // as their are not initalized (nParam == 0)
+    ixList[0]->NIter( varStride); // check boundary
+    ixList[1]->NIter( var->Dim(1)); // check boundary
+    SizeT dStart = ixList.FrontGetS() + ixList[1]->GetS() * varStride; 
+    return var->NewIx( dStart); //this->LongIx());
+  }
+
+  // returns multi-dim index for 1st element
+  // used by InsAt functions
+  const dimension GetDimIx0( SizeT& destStart)
+  {
+    SizeT actIx[ MAXRANK];
+
+    actIx[ 0] = ixList[0]->GetS();
+    actIx[ 1] = ixList[1]->GetS();
+
+    SizeT dStart = actIx[ 0] + actIx[ 1] * varStride;
+
+    destStart = dStart;
+    return dimension( actIx, acRank2D);
+  }
+  
+  SizeT NDim()
+  { 
+    return acRank2D;
+  }
+}; // class ArrayIndexListScalar2DT: public ArrayIndexListT
+
+
+
+
 
 
 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@@ -1086,7 +1203,7 @@
   AllIxBaseT*      allIx;
   char allIxInstance[ AllIxMaxSize];
 
-  ArrayIndexT* ixListEnd; // for assoc index
+//   ArrayIndexT* ixListEnd; // for assoc index
 
   // for access with only a single variable index (column/row-extractor)
   SizeT nIterLimitGt1; // how many dimensions > 1
@@ -1110,8 +1227,8 @@
   ArrayIndexListMultiNoAssocT():
     accessType(NORMAL),
     acRank(0),
-    allIx( NULL),
-    ixListEnd( NULL)
+    allIx( NULL)
+//     ixListEnd( NULL)
   { nParam = 0;}
 	
   ArrayIndexListMultiNoAssocT( const ArrayIndexListMultiNoAssocT& cp):
@@ -1120,11 +1237,11 @@
     accessTypeInit(cp.accessTypeInit),
     accessTypeAssocInit(cp.accessTypeAssocInit),
     acRank(cp.acRank),
-    allIx( NULL),
-    ixListEnd( NULL)
+    allIx( NULL)
+//     ixListEnd( NULL)
   {
     assert( cp.allIx == NULL);
-    assert( cp.ixListEnd == NULL);
+//     assert( cp.ixListEnd == NULL);
 	assert( cp.cleanupIx.size() == 0);
 	
     for( SizeT i=0; i<cp.ixList.size(); ++i)
@@ -1134,8 +1251,8 @@
   // called once after structure is fixed at (GDL-)compile time
   ArrayIndexListMultiNoAssocT( ArrayIndexVectorT* ix):
     ixList( *ix),
-    allIx( NULL),
-    ixListEnd( NULL)
+    allIx( NULL)
+//     ixListEnd( NULL)
   {
     assert( ix->size() != 0); // must be, from compiler
 
@@ -1196,12 +1313,6 @@
 //     delete allIx;
     allIx = NULL;
     
-    if( ixListEnd != NULL) // revert assoc indexing
-      {
-	ixList.push_back( ixListEnd);
-	ixListEnd = NULL;
-      }
-
     ixList.Clear();
 //     for( ArrayIndexVectorT::iterator i=ixList.begin(); i != ixList.end(); ++i)
 //       {	(*i)->Clear();}
@@ -1386,7 +1497,9 @@
 
       // in this case, having more index dimensions does not matter
       // indices are used only upto variables rank
-      if( varRank < acRank) acRank = varRank;
+      // ok as we set acRank here
+      if( varRank < acRank) 
+	acRank = varRank;
 
       varStride = var->Dim().Stride();
 // 		varDim.Stride( varStride,acRank); // copy variables stride into varStride
@@ -1399,7 +1512,7 @@
     assert( varStride[0] == 1);
 
     nIterLimit[0]=ixList[0]->NIter( (0<varRank)?varDim[0]:1);
-    nIx = nIterLimit[0]; // calc number of assignments
+    //nIx = nIterLimit[0]; // calc number of assignments
     stride[0]=1;
 
     if( nIterLimit[0] > 1)
@@ -1432,7 +1545,7 @@
     for( SizeT i=1; i<acRank; ++i)
     {
 	    nIterLimit[i]=ixList[i]->NIter( (i<varRank)?varDim[i]:1);
-	    nIx *= nIterLimit[i]; // calc number of assignments
+	    //nIx *= nIterLimit[i]; // calc number of assignments
 	    stride[i]=stride[i-1]*nIterLimit[i-1]; // index stride
 
 	    if( nIterLimit[i] > 1)
@@ -1462,6 +1575,7 @@
 	    }
     }
     stride[acRank]=stride[acRank-1]*nIterLimit[acRank-1]; // index stride
+    nIx = stride[acRank];
   }
 
   // structure of indexed expression
@@ -1487,6 +1601,9 @@
   // returns 1-dim index for all elements
   AllIxBaseT* BuildIx() // ArrayIndexListMultiT
   {
+    if( allIx != NULL) // can happen if called from DotAccessDescT::DoAssign()
+      return allIx;
+
     assert( allIx == NULL);
 
     if( accessType == ALLINDEXED) //  nIterLimitGt1 is not properly set
@@ -1775,7 +1892,7 @@
   {
     ixList = *ix;
     allIx = NULL;
-    ixListEnd = NULL;
+//     ixListEnd = NULL;
 	  
     assert( ix->size() != 0); // must be, from compiler
 
@@ -1886,7 +2003,7 @@
 	//     varDim.Stride( varStride,acRank); // copy variables stride into varStride
 	
 	nIterLimit[0]=ixList[0]->NIter( (0<varRank)?varDim[0]:1);
-	nIx = nIterLimit[0]; // calc number of assignments
+// 	nIx = nIterLimit[0]; // calc number of assignments
 	stride[0]=1;
 
 	nIterLimitGt1 = (nIterLimit[0] > 1)? 1 : 0;
@@ -1897,7 +2014,7 @@
 	for( SizeT i=1; i<acRank; ++i)
       {
 		nIterLimit[i]=ixList[i]->NIter( (i<varRank)?varDim[i]:1);
-		nIx *= nIterLimit[i]; // calc number of assignments
+// 		nIx *= nIterLimit[i]; // calc number of assignments
 		stride[i]=stride[i-1]*nIterLimit[i-1]; // index stride
 		
 		if( nIterLimit[i] > 1)
@@ -1907,12 +2024,16 @@
 		}
 		baseIx += ixList[i]->GetS()  * varStride[i];
       }
-    stride[acRank]=stride[acRank-1]*nIterLimit[acRank-1]; // index stride 
+    stride[acRank]= stride[acRank-1]*nIterLimit[acRank-1]; // index stride 
+    nIx = stride[acRank];
   }
 
   // returns 1-dim index for all elements
   AllIxBaseT* BuildIx()
   {
+    if( allIx != NULL) // can happen if called from DotAccessDescT::DoAssign()
+      return allIx;
+
 	assert( allIx == NULL);  
 // 	if( allIx != NULL)
 // 		return allIx;
@@ -1990,6 +2111,110 @@
 
 
 
+class ArrayIndexListMultiNoneIndexedNoAssoc2DT: public ArrayIndexListMultiNoAssocT
+{
+public:	
+// called after structure is fixed
+  ArrayIndexListMultiNoneIndexedNoAssoc2DT( ArrayIndexVectorT* ix)
+  {
+    ixList = *ix;
+    allIx = NULL;
+	  
+    assert( ix->size() == 2); // must be, from compiler
+    assert( ixList.size() == 2);
+
+    acRank = acRank2D;
+
+    nParam = 0;
+    for( SizeT i=0; i<ix->size(); ++i)
+	nParam += (*ix)[i]->NParam();
+
+    // determine type of index
+//     SizeT nIndexed = 0;
+    SizeT nScalar  = 0;
+    for( SizeT i=0; i<ixList.size(); ++i)
+      {
+	// note: here we examine the actual type
+	if( ArrayIndexScalarID == ixList[i]->Type() ||
+		ArrayIndexScalarVPID == ixList[i]->Type() || // ? (from MakeArrayIndex)
+		CArrayIndexScalarID == ixList[i]->Type() ) nScalar++;
+      }
+    assert( nScalar < ixList.size()); // from MakeArrayIndex
+    accessTypeInit = NORMAL;
+  }
+  
+  ArrayIndexListT* Clone() { return new ArrayIndexListMultiNoneIndexedNoAssoc2DT( *this);}
+
+  // set the root variable which is indexed by this ArrayIndexListMultiT
+  void SetVariable( BaseGDL* var) 
+  {
+    // accessType must be at this point:
+    // NORMAL
+    // now the definite types here
+
+    // set varDim from variable
+    const dimension& varDim  = var->Dim();
+    SizeT            varRank = varDim.Rank();
+    
+    varStride = varDim.Stride();
+    //     varDim.Stride( varStride,acRank); // copy variables stride into varStride
+    
+    nIterLimit[0]=ixList[0]->NIter( (0<varRank)?varDim[0]:1);
+    stride[0]=1;
+
+    nIterLimitGt1 = (nIterLimit[0] > 1)? 1 : 0;
+    gt1Rank = 0;
+    assert( varStride[0] == 1);
+
+    nIterLimit[1]=ixList[1]->NIter( (1<varRank)?varDim[1]:1);
+    nIx = nIterLimit[0] * nIterLimit[1]; // calc number of assignments
+    stride[1]=nIterLimit[0]; // index stride
+		
+    if( nIterLimit[1] > 1)
+      {
+	++nIterLimitGt1;
+	gt1Rank = 1;
+      }
+    baseIx = ixList[0]->GetS() + ixList[1]->GetS() * varStride[1];
+
+    stride[2]=nIx; // index stride 
+  }
+
+  // returns 1-dim index for all elements
+  AllIxBaseT* BuildIx()
+  {
+    if( allIx != NULL) // can happen if called from DotAccessDescT::DoAssign()
+      return allIx;
+
+    assert( allIx == NULL);  
+    
+    // all nIterLimit == 1
+    if( nIterLimitGt1 == 0) // only one single index
+    {
+      allIx = new (allIxInstance) AllIxT( baseIx);
+      return allIx;
+    }	  
+    // NORMAL
+    // loop only over specified indices
+    // higher indices of variable are implicitely zero,
+    // therefore they are not checked in 'SetRoot'
+    if( nIterLimitGt1 == 1) // only one variable dimension
+    {
+	    allIx = new (allIxInstance) AllIxNewMultiOneVariableIndexNoIndexT( gt1Rank, baseIx, &ixList, acRank2D, nIx, varStride, nIterLimit, stride);
+	    return allIx;
+    }
+    
+    allIx = new (allIxInstance) AllIxNewMultiNoneIndexed2DT( &ixList, nIx, varStride, nIterLimit, stride);
+    return allIx;
+  }
+}; // ArrayIndexListMultiNoneIndexed2DT
+
+
+
+
+
+
+
 
 
 
@@ -2011,7 +2236,7 @@
   {
     ixList = *ix;
     allIx = NULL;
-    ixListEnd = NULL;
+//     ixListEnd = NULL;
 
     assert( ix->size() != 0); // must be, from compiler
 
@@ -2022,7 +2247,6 @@
     for( SizeT i=0; i<ix->size(); ++i)
 	nParam += (*ix)[i]->NParam();
 
-    accessTypeAssocInit = ALLINDEXED; // might be ALLONE as well
     accessTypeInit = ALLINDEXED; // might be ALLONE as well
   }
   
@@ -2111,7 +2335,9 @@
 
 		// in this case, having more index dimensions does not matter
 		// indices are used only upto variables rank
-		if( varRank < acRank) acRank = varRank;
+		// ok as we set acRank here
+		if( varRank < acRank) 
+		  acRank = varRank;
 
 		varStride = var->Dim().Stride();
 		return;
diff -ruN --exclude CVS gdl-0.9.2/src/arrayindexlistt.hpp gdl/src/arrayindexlistt.hpp
--- gdl-0.9.2/src/arrayindexlistt.hpp	2011-11-06 20:10:46.000000000 -0700
+++ gdl/src/arrayindexlistt.hpp	2012-02-19 22:06:07.000000000 -0700
@@ -43,10 +43,18 @@
 
   virtual ArrayIndexListT* Clone() { assert( 0); return NULL;}
 
-  virtual void Init( IxExprListT& ix, IxExprListT* cleanupIx) { assert( 0);}
+  virtual void Init( IxExprListT& ix, IxExprListT* cleanupIx) 
+  { 
+    assert( 0);
+    throw GDLException( NULL,"Internal error: ArrayIndexListT::Init( IxExprListT& ix, IxExprListT* cleanupIx) called.",true,false);    
+  }
   virtual void Init() {}
   
-   virtual bool ToAssocIndex( SizeT& lastIx) = 0;
+   virtual bool ToAssocIndex( SizeT& lastIx) 
+   { 
+    assert( 0);       
+    throw GDLException( NULL,"Internal error: ArrayIndexListT::ToAssocIndex( SizeT& lastIx) called.",true,false);
+   }
 //  virtual bool ToAssocIndex( RangeT& lastIx) = 0;
 
   // set the root variable which is indexed by this ArrayIndexListT
@@ -191,7 +199,8 @@
     assert( allIx == NULL);
 
     // for assoc variables last index is the record
-    if( var->IsAssoc()) return;
+    // we cannot return here as sInit is not yet copied to s
+    //if( var->IsAssoc()) return;
 
     // ArrayIndexScalar[VP] are not initialized
     // they need the NIter call, but
@@ -225,6 +234,8 @@
   // returns 1-dim index for all elements
   AllIxBaseT* BuildIx()
   {
+    if( allIx != NULL) // can happen if called from DotAccessDescT::DoAssign()
+      return allIx;
     assert( allIx == NULL);
 //     if( allIx != NULL)
 // 		return allIx;
@@ -1555,6 +1566,9 @@
   // returns 1-dim index for all elements
   AllIxBaseT* BuildIx() // ArrayIndexListMultiT
   {
+    if( allIx != NULL) // can happen if called from DotAccessDescT::DoAssign()
+      return allIx;
+
     assert( allIx == NULL);
 
     if( accessType == ALLINDEXED) //  nIterLimitGt1 is not properly set
@@ -1981,6 +1995,9 @@
   // returns 1-dim index for all elements
   AllIxBaseT* BuildIx()
   {
+    if( allIx != NULL) // can happen if called from DotAccessDescT::DoAssign()
+      return allIx;
+
 	assert( allIx == NULL);  
 // 	if( allIx != NULL)
 // 		return allIx;
diff -ruN --exclude CVS gdl-0.9.2/src/basegdl.cpp gdl/src/basegdl.cpp
--- gdl-0.9.2/src/basegdl.cpp	2011-11-05 10:56:43.000000000 -0600
+++ gdl/src/basegdl.cpp	2011-12-08 00:03:09.000000000 -0700
@@ -72,11 +72,11 @@
   throw GDLException("BaseGDL::Equal(SizeT,SizeT) called.");
 }
 
-BaseGDL* BaseGDL::CShift( DLong d)
+BaseGDL* BaseGDL::CShift( DLong d) const
 {
   throw GDLException("BaseGDL::CShift(...) called.");
 }
-BaseGDL* BaseGDL::CShift( DLong d[MAXRANK])
+BaseGDL* BaseGDL::CShift( DLong d[MAXRANK]) const
 {
   throw GDLException("BaseGDL::CShift( DLong d[MAXRANK]) called.");
 }
@@ -639,7 +639,7 @@
 { 
   throw GDLException("Operation not defined for UNDEF 27a.");
 }
-void BaseGDL::LogThis()              
+BaseGDL* BaseGDL::LogThis()              
 { 
   throw GDLException("Operation not defined for UNDEF 27b.");
 }
@@ -647,7 +647,7 @@
 { 
   throw GDLException("Operation not defined for UNDEF 27c.");
 }
-void BaseGDL::Log10This()              
+BaseGDL* BaseGDL::Log10This()              
 { 
   throw GDLException("Operation not defined for UNDEF 27d.");
 }
diff -ruN --exclude CVS gdl-0.9.2/src/basegdl.hpp gdl/src/basegdl.hpp
--- gdl-0.9.2/src/basegdl.hpp	2011-11-05 10:56:43.000000000 -0600
+++ gdl/src/basegdl.hpp	2011-12-08 00:03:09.000000000 -0700
@@ -416,8 +416,8 @@
   virtual bool Greater(SizeT i1, SizeT i2) const; // comp 2 elements
   virtual bool Equal(SizeT i1, SizeT i2) const; // comp 2 elements
 
-  virtual BaseGDL* CShift( DLong d); // circular shift
-  virtual BaseGDL* CShift( DLong d[MAXRANK]); // circular shift multi dim
+  virtual BaseGDL* CShift( DLong d) const; // circular shift
+  virtual BaseGDL* CShift( DLong d[MAXRANK]) const; // circular shift multi dim
 
   virtual bool Scalar() const;
   virtual bool StrictScalar() const;
@@ -482,9 +482,9 @@
   virtual void Assign( BaseGDL* src, SizeT nEl);
 
   virtual BaseGDL* Log();              
-  virtual void     LogThis();
+  virtual BaseGDL* LogThis();
   virtual BaseGDL* Log10();              
-  virtual void     Log10This();
+  virtual BaseGDL* Log10This();
 
   // defined in basic_op.cpp
   // used in r_expr
diff -ruN --exclude CVS gdl-0.9.2/src/basic_fun.cpp gdl/src/basic_fun.cpp
--- gdl-0.9.2/src/basic_fun.cpp	2011-11-06 16:43:21.000000000 -0700
+++ gdl/src/basic_fun.cpp	2012-06-28 03:54:54.000000000 -0600
@@ -828,18 +828,23 @@
       }
  */ }
 
+  // only called from CALL_FUNCTION 
+  // otherwise done directly in FCALL_LIB_N_ELEMENTSNode::Eval();
+  // (but must be defined anyway for LibInit() for correct parametrization)
+  // N_ELEMENTS is special because on error it just returns 0L
+  // (the error is just caught and dropped)
   BaseGDL* n_elements( EnvT* e)
   {
     SizeT nParam=e->NParam(1);
 
-//     if( nParam != 1)
-//       e->Throw( "Incorrect number of arguments.");
-
     BaseGDL* p0=e->GetPar( 0);
 
     if( p0 == NULL) return new DLongGDL( 0);
+    return new DLongGDL( p0->N_Elements()); 
     
-    return new DLongGDL( p0->N_Elements());
+//     assert( 0);
+//     e->Throw("Internal error: lib::n_elements called.");
+//     return NULL; // get rid of compiler warning
   }
 
   template< typename ComplexGDL, typename Complex, typename Float>
@@ -1204,11 +1209,17 @@
       {
         // SA: calling STRING() with correct parameters
         static int stringIx = LibFunIx("STRING");
+
+		assert( stringIx >= 0);
+		
         EnvT* newEnv= new EnvT(e, libFunList[stringIx], NULL);
-        newEnv->SetNextPar(&e->GetPar(0)); // pass as global
+
+		auto_ptr<EnvT> guard( newEnv);
+
+		newEnv->SetNextPar(&e->GetPar(0)); // pass as global
         if (e->KeywordSet(1) && e->GetPar(0)->Type() == BYTE)
           newEnv->SetKeyword("PRINT", new DIntGDL(1));
-        e->Interpreter()->CallStack().push_back( newEnv); 
+//         e->Interpreter()->CallStack().push_back( newEnv); 
         return static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
       }
       e->Throw( "Improper TYPE value.");
@@ -1218,8 +1229,6 @@
 
   BaseGDL* call_function( EnvT* e)
   {
-    StackGuard<EnvStackT> guard( e->Interpreter()->CallStack());
-
     int nParam=e->NParam();
     if( nParam == 0)
      e->Throw( "No function specified.");
@@ -1234,14 +1243,31 @@
     int funIx=LibFunIx( callF);
     if( funIx != -1)
       {
-	e->PushNewEnv( libFunList[ funIx], 1);
-	
+// 	e->PushNewEnv( libFunList[ funIx], 1);
 	// make the call
-	EnvT* newEnv = static_cast<EnvT*>(e->Interpreter()->CallStack().back());
+// 	EnvT* newEnv = static_cast<EnvT*>(e->Interpreter()->CallStack().back());
+
+	// handle direct call functions 
+	if( libFunList[ funIx]->DirectCall())
+	{
+	  BaseGDL* directCallParameter = e->GetParDefined(1);
+	  BaseGDL* res = 
+	  static_cast<DLibFunDirect*>(libFunList[ funIx])->FunDirect()(directCallParameter, true /*isReference*/);
+	  return res;
+	}
+	else
+	{
+	EnvT* newEnv = e->NewEnv( libFunList[ funIx], 1);
+	auto_ptr<EnvT> guard( newEnv);
 	return static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
+	}
       }
     else
       {
+	// no direct call here
+	
+	StackGuard<EnvStackT> guard( e->Interpreter()->CallStack());
+
 	funIx = GDLInterpreter::GetFunIx( callF);
 	
 	e->PushNewEnvUD( funList[ funIx], 1);
@@ -1274,8 +1300,8 @@
 
     if( method == NULL)
       e->Throw( "Method not found: "+callP);
-
-    e->PushNewEnv( method, 2, &e->GetPar( 1));
+// // // /**/
+    e->PushNewEnvUD( method, 2, &e->GetPar( 1));
     
     // make the call
     return e->Interpreter()->call_fun( method->GetTree());
@@ -1290,13 +1316,13 @@
     bool quietCompile = false;
     if( nParam == 2)
       {
-	BaseGDL* p1 = e->GetParDefined( 1);
-	
-	if( !p1->Scalar())
-	  e->Throw( "Expression must be scalar in this context: "+
-			      e->GetParString(1));
-	
-	quietCompile = p1->True();
+		BaseGDL* p1 = e->GetParDefined( 1);
+
+		if( !p1->Scalar())
+		  e->Throw( "Expression must be scalar in this context: "+
+				      e->GetParString(1));
+
+		quietCompile = p1->True();
       }
 
     if (e->GetParDefined(0)->Rank() != 0)
@@ -1308,8 +1334,10 @@
     // remove current environment (own one)
     assert( dynamic_cast<EnvUDT*>(e->Caller()) != NULL);
     EnvUDT* caller = static_cast<EnvUDT*>(e->Caller());
-    e->Interpreter()->CallStack().pop_back();
-    delete e;
+//     e->Interpreter()->CallStack().pop_back();
+
+// wrong: e is guarded, do not delete it here	
+//	delete e;
 
     istringstream istr(line+"\n");
 
@@ -1583,15 +1611,19 @@
     return res;
   }
 
-  BaseGDL* logical_true( EnvT* e)
+  BaseGDL* logical_true( BaseGDL* e1, bool isReference)//( EnvT* e);
   {
-    SizeT nParam=e->NParam();
-    if( nParam != 1)
-      e->Throw(
-			  "Incorrect number of arguments.");
-
-    BaseGDL* e1=e->GetParDefined( 0);//, "LOGICAL_TRUE");
+    assert( e1 != NULL);
+    assert( e1->N_Elements() > 0);
     
+
+//     SizeT nParam=e->NParam();
+//     if( nParam != 1)
+//       e->Throw(
+// 			  "Incorrect number of arguments.");
+// 
+//     BaseGDL* e1=e->GetParDefined( 0);//, "LOGICAL_TRUE");
+//     
     ULong nEl1 = e1->N_Elements();
 
     Data_<SpDByte>* res = new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
@@ -1876,53 +1908,139 @@
     return res;
   }
 
-  BaseGDL* strlowcase( EnvT* e)
+  BaseGDL* strlowcase( BaseGDL* p0, bool isReference)//( EnvT* e)
   {
-    e->NParam( 1);//, "STRLOWCASE");
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
 
-    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+//     e->NParam( 1);//, "STRLOWCASE");
 
-    DStringGDL* res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
+//     DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+    DStringGDL* p0S;
+    DStringGDL* res;
+// 	auto_ptr<DStringGDL> guard;
+
+	if( p0->Type() == STRING)
+	{
+		p0S = static_cast<DStringGDL*>( p0);
+		if( !isReference)
+			res = p0S;
+		else
+			res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
+	}
+	else
+	{
+		p0S = static_cast<DStringGDL*>( p0->Convert2( STRING, BaseGDL::COPY));
+		res = p0S;
+// 	    guard.reset( p0S);
+	}
+
+//     DStringGDL* res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
     
     SizeT nEl = p0S->N_Elements();
+
+	if( res == p0S)
+	{
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
 {
 #pragma omp for
     for( SizeT i=0; i<nEl; ++i)
       {
-	(*res)[ i] = StrLowCase((*p0S)[ i]);
+		StrLowCaseInplace((*p0S)[ i]);
       }
 }
+	}
+	else
+	{
+TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
+{
+#pragma omp for
+    for( SizeT i=0; i<nEl; ++i)
+      {
+		(*res)[ i] = StrLowCase((*p0S)[ i]);
+      }
+}
+	}
     return res;
   }
 
-  BaseGDL* strupcase( EnvT* e)
+  BaseGDL* strupcase( BaseGDL* p0, bool isReference)//( EnvT* e)
   {
-    e->NParam( 1);//, "STRUPCASE");
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
 
-    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+//     e->NParam( 1);//, "STRLOWCASE");
+
+//     DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+    DStringGDL* p0S;
+    DStringGDL* res;
+// 	auto_ptr<DStringGDL> guard;
+
+	if( p0->Type() == STRING)
+	{
+		p0S = static_cast<DStringGDL*>( p0);
+		if( !isReference)
+			res = p0S;
+		else
+			res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
+	}
+	else
+	{
+		p0S = static_cast<DStringGDL*>( p0->Convert2( STRING, BaseGDL::COPY));
+		res = p0S;
+// 	    guard.reset( p0S);
+	}
+
+//     DStringGDL* res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
 
-    DStringGDL* res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
-    
     SizeT nEl = p0S->N_Elements();
+
+	if( res == p0S)
+	{
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
 {
 #pragma omp for
     for( SizeT i=0; i<nEl; ++i)
       {
-	(*res)[ i] = StrUpCase((*p0S)[ i]);
+		StrUpCaseInplace((*p0S)[ i]);
       }
 }
+	}
+	else
+	{
+TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
+{
+#pragma omp for
+    for( SizeT i=0; i<nEl; ++i)
+      {
+		(*res)[ i] = StrUpCase((*p0S)[ i]);
+      }
+}
+	}
     return res;
   }
 
-  BaseGDL* strlen( EnvT* e)
+  BaseGDL* strlen( BaseGDL* p0, bool isReference)//( EnvT* e)
   {
-    e->NParam( 1);//, "STRLEN");
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
 
-    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+//     e->NParam( 1);//, "STRLEN");
+
+    DStringGDL* p0S;
+	auto_ptr<DStringGDL> guard;
+	
+	if( p0->Type() == STRING)
+		p0S = static_cast<DStringGDL*>( p0);
+	else
+	{
+		p0S = static_cast<DStringGDL*>( p0->Convert2( STRING, BaseGDL::COPY));
+	    guard.reset( p0S);
+	}
 
     DLongGDL* res = new DLongGDL( p0S->Dim(), BaseGDL::NOZERO);
 
@@ -1932,7 +2050,7 @@
 // #pragma omp for
     for( SizeT i=0; i<nEl; ++i)
       {
-	(*res)[ i] = (*p0S)[ i].length();
+		(*res)[ i] = (*p0S)[ i].length();
       }
 }
     return res;
@@ -3382,7 +3500,7 @@
 	for( SizeT i=0; i<rank; ++i) perm[i] = (*p1L)[ i];
 	delete p1L;
 
-	// check permutaion vector
+	// check permutation vector
 	for( SizeT i=0; i<rank; ++i) 
 	  {
 	    DUInt j;
@@ -4363,6 +4481,7 @@
 		DLong s1;
 		e->AssureLongScalarPar( 1, s1);
 
+		// IncRef[Obj] done for PTR and OBJECT
 		return p0->CShift( s1);
       }
     
@@ -4373,7 +4492,12 @@
     for( SizeT i=0; i< nShift; i++)
       e->AssureLongScalarPar( i+1, sIx[ i]);
 
-    return p0->CShift( sIx);
+	if( p0->Type() == OBJECT)
+		GDLInterpreter::IncRefObj( static_cast<DObjGDL*>(p0));
+	else if( p0->Type() == PTR)
+		GDLInterpreter::IncRef( static_cast<DPtrGDL*>(p0));
+
+	return p0->CShift( sIx);
   }
 
   BaseGDL* arg_present( EnvT* e)
@@ -5367,7 +5491,12 @@
 
   BaseGDL* get_kbrd( EnvT* e)
   {
-    SizeT nParam=e->NParam();
+#if defined(HAVE_LIBREADLINE)
+#include <readline/readline.h>
+      rl_prep_terminal (0);
+#endif
+      
+ SizeT nParam=e->NParam();
 
     bool doWait = true;
     if( nParam > 0)
@@ -5381,39 +5510,51 @@
 	  }
       }
 
-//     if( doWait)
-//       {
- 
-// 	char c = cin.get();
-// 	DStringGDL* res = new DStringGDL( DString( i2s( c)));
-// 	return res;
-//       }
-//     else
-//       {
-// 	char c = cin.get();
-// 	DStringGDL* res = new DStringGDL( DString( i2s( c)));
-// 	return res;
-//       }
-
     // https://sourceforge.net/forum/forum.php?thread_id=3292183&forum_id=338691
-    // TODO Implement proper SCALAR parameter handling (doWait variable?). 
- 
+    // DONE: Implement proper SCALAR parameter handling (doWait variable)
+    // which is/was not blocking in the original program. 
+    // note: multi-byte input is not supported here.
+    
+    char c='\0'; //initialize is never a bad idea...
+
+    int fd=fileno(stdin);
     struct termios orig, get; 
-    (void)tcgetattr(fileno(stdin), &orig); 
-    get = orig; 
- 
-    // Disable terminal echoing and set it to non-canonical mode. 
-    get.c_lflag &= ~(ECHO|ICANON); 
- 
-    (void)tcsetattr(fileno(stdin), TCSANOW, &get); 
- 
-    char c = cin.get(); 
- 
+    
+    // Get terminal setup to revert to it at end. 
+    (void)tcgetattr(fd, &orig); 
+    // New terminal setup, non-canonical.
+    get.c_lflag = ISIG; 
+    if (doWait)
+    {
+     // will wait for a character
+     get.c_cc[VTIME]=0;
+     get.c_cc[VMIN]=1;
+     (void)tcsetattr(fd, TCSANOW, &get); 
+     cin.get(c);
+    }
+    else 
+    {
+     // will not wait, but return EOF or next character in terminal buffer if present
+     get.c_cc[VTIME]=0;
+     get.c_cc[VMIN]=0;
+     (void)tcsetattr(fd, TCSANOW, &get); 
+     //the trick is *not to use C++ functions here. cin.get would wait.*
+     c=std::fgetc(stdin);
+     //and to convert EOF to null (otherwise GDL may exit if not compiled with
+     //[lib][n]curses)
+     if(c==EOF) c='\0';
+    }
+    
     // Restore original terminal settings. 
-    (void)tcsetattr(fileno(stdin), TCSANOW, &orig); 
- 
+    (void)tcsetattr(fd, TCSANOW, &orig); 
+#if defined(HAVE_LIBREADLINE)
+    rl_deprep_terminal ();
+#endif
+
     DStringGDL* res = new DStringGDL( DString( i2s( c))); 
-    return res; 
+
+    return res;
+ 
   }
 
 
diff -ruN --exclude CVS gdl-0.9.2/src/basic_fun.hpp gdl/src/basic_fun.hpp
--- gdl-0.9.2/src/basic_fun.hpp	2009-09-10 07:07:44.000000000 -0600
+++ gdl/src/basic_fun.hpp	2011-11-24 04:31:27.000000000 -0700
@@ -83,14 +83,14 @@
 
   BaseGDL* gdl_logical_and( EnvT* e);
   BaseGDL* gdl_logical_or( EnvT* e);
-  BaseGDL* logical_true( EnvT* e);
+  BaseGDL* logical_true( BaseGDL* p0, bool isReference);//( EnvT* e);
 
   BaseGDL* replicate( EnvT* e);
 
   BaseGDL* strcompress( EnvT* e);
-  BaseGDL* strlowcase( EnvT* e);
-  BaseGDL* strupcase( EnvT* e);
-  BaseGDL* strlen( EnvT* e);
+  BaseGDL* strlowcase( BaseGDL* p0, bool isReference);//( EnvT* e);
+  BaseGDL* strupcase( BaseGDL* p0, bool isReference);//( EnvT* e);
+  BaseGDL* strlen( BaseGDL* p0, bool isReference);//( EnvT* e);
   BaseGDL* strmid( EnvT* e);
   BaseGDL* strpos( EnvT* e);
   BaseGDL* strtrim( EnvT* e);
diff -ruN --exclude CVS gdl-0.9.2/src/basic_fun_jmg.cpp gdl/src/basic_fun_jmg.cpp
--- gdl-0.9.2/src/basic_fun_jmg.cpp	2011-10-11 01:37:36.000000000 -0600
+++ gdl/src/basic_fun_jmg.cpp	2012-06-28 03:54:54.000000000 -0600
@@ -120,10 +120,10 @@
       }
 
 
-      DLongGDL *dims_res = new DLongGDL(dimension(8), BaseGDL::ZERO);      
+      DLongGDL *dims_res = new DLongGDL(dimension(MAXRANK), BaseGDL::ZERO);      
 
       // Initialize dimension values to 0
-      for( SizeT i=Rank; i<8; ++i) (*dims_res)[ i] = 0;
+      for( SizeT i=Rank; i<MAXRANK; ++i) (*dims_res)[ i] = 0;
       for( SizeT i=0; i<Rank; ++i) {
 	(*dims_res)[ i] = p0->Dim(i);
       }
@@ -642,7 +642,9 @@
     SizeT nParam=e->NParam();
 
     EnvStackT& callStack = e->Interpreter()->CallStack();
-    DLong curlevnum = callStack.size()-1;
+//     DLong curlevnum = callStack.size()-1;
+	// 'e' is not on the stack
+	DLong curlevnum = callStack.size();
 
     if (e->KeywordSet( "S_FUNCTIONS")) {
       deque<DString> subList;
@@ -766,15 +768,21 @@
 	DStringGDL* res = new DStringGDL( dimension( nParam), BaseGDL::NOZERO);
 
 	//	cout << "nVar:" << nVar << endl;
-
-	SizeT nCall = callStack[desiredlevnum]->NParam();
-
+	EnvBaseT* desiredCallStack;
+	if( desiredlevnum >= callStack.size())
+		desiredCallStack = e;
+	else
+		desiredCallStack = callStack[ desiredlevnum];
+	
+// 	SizeT nCall = callStack[desiredlevnum]->NParam();
+	SizeT nCall = desiredCallStack->NParam();
+	
 	//	cout << "nCall:" << nCall << "curlevnum:" << curlevnum << endl;
 	for( SizeT i = 0; i<nParam; ++i) {
 	  for( SizeT j = 0; j<nCall; ++j) {
 
 	    if (e->GetParString(i) == 
-		callStack[desiredlevnum]->GetParString(j)) {
+		desiredCallStack->GetParString(j)) {
 	      //	      cout << "Calling param: " << j+1 << endl;
 	      BaseGDL*& p = e->GetPar( i);
 	      if (p == NULL) {
diff -ruN --exclude CVS gdl-0.9.2/src/basic_pro.cpp gdl/src/basic_pro.cpp
--- gdl-0.9.2/src/basic_pro.cpp	2011-11-06 20:07:18.000000000 -0700
+++ gdl/src/basic_pro.cpp	2011-12-03 06:10:46.000000000 -0700
@@ -817,8 +817,6 @@
   
   void call_procedure( EnvT* e)
   {
-    StackGuard<EnvStackT> guard( e->Interpreter()->CallStack());
-
     int nParam=e->NParam();
     if( nParam == 0)
       e->Throw( "No procedure specified.");
@@ -833,14 +831,17 @@
     int proIx=LibProIx( callP);
     if( proIx != -1)
       {
-	e->PushNewEnv( libProList[ proIx], 1);
-	
+// 	e->PushNewEnv( libProList[ proIx], 1);
 	// make the call
-	EnvT* newEnv = static_cast<EnvT*>(e->Interpreter()->CallStack().back());
+// 	EnvT* newEnv = static_cast<EnvT*>(e->Interpreter()->CallStack().back());
+	EnvT* newEnv = e->NewEnv( libProList[ proIx], 1);
+	auto_ptr<EnvT> guard( newEnv);
 	static_cast<DLibPro*>(newEnv->GetPro())->Pro()(newEnv);
       }
     else
       {
+    StackGuard<EnvStackT> guard( e->Interpreter()->CallStack());
+
 	proIx = DInterpreter::GetProIx( callP);
 	
 	e->PushNewEnvUD( proList[ proIx], 1);
diff -ruN --exclude CVS gdl-0.9.2/src/CMakeLists.txt gdl/src/CMakeLists.txt
--- gdl-0.9.2/src/CMakeLists.txt	2011-11-06 20:07:18.000000000 -0700
+++ gdl/src/CMakeLists.txt	2012-06-28 03:54:54.000000000 -0600
@@ -130,6 +130,8 @@
 gshhs.hpp
 gsl_fun.cpp
 gsl_fun.hpp
+gsl_matrix.cpp
+gsl_matrix.hpp
 gzstream.hpp
 hdf5_fun.cpp
 hdf5_fun.hpp
@@ -181,7 +183,6 @@
 objects.hpp
 ofmt.cpp
 ofmt.hpp
-plot3d_nr.cpp
 plotting_axis.cpp
 plotting_contour.cpp
 plotting_convert_coord.cpp
diff -ruN --exclude CVS gdl-0.9.2/src/convert2.cpp gdl/src/convert2.cpp
--- gdl-0.9.2/src/convert2.cpp	2011-10-17 04:01:43.000000000 -0600
+++ gdl/src/convert2.cpp	2012-07-10 11:47:17.000000000 -0600
@@ -234,13 +234,13 @@
 	if( mode == BaseGDL::COPY_BYTE_AS_INT)
 	  {
 	    Data_<SpDString>* dest=new Data_<SpDString>( dim, BaseGDL::NOZERO);
-TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
-#pragma omp for
+// TRACEOMP( __FILE__, __LINE__)
+// #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+// {
+// #pragma omp for
 	    for( SizeT i=0; i < nEl; ++i)
-	      (*dest)[i]=i2s((*this)[i],4);
-}
+	      (*dest)[i]=i2s(static_cast<int>((*this)[i]),4);
+// }
 	    if( (mode & BaseGDL::CONVERT) != 0) delete this;
 	    return dest;
 	  }
@@ -2257,12 +2257,13 @@
 	}
 #endif
 // #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
+//{
 // #pragma omp for
       	for( SizeT i=0; i < nEl; ++i)
-	  (*dest)[i] = DComplex( static_cast<float>((*this)[i].real()), 
-				 static_cast<float>((*this)[i].imag()) );
-}	//      	  (*dest)[i]=(*this)[i];
+// 	  (*dest)[i] = DComplex( static_cast<float>((*this)[i].real()), 
+// 				 static_cast<float>((*this)[i].imag()) );
+//}      	  
+	(*dest)[i]=(*this)[i];
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
       	return dest;
       }
diff -ruN --exclude CVS gdl-0.9.2/src/datatypes.cpp gdl/src/datatypes.cpp
--- gdl-0.9.2/src/datatypes.cpp	2011-11-05 10:56:43.000000000 -0600
+++ gdl/src/datatypes.cpp	2012-07-10 11:47:17.000000000 -0600
@@ -55,6 +55,9 @@
 // this (ugly) including of other sourcefiles has to be done, because
 // on Mac OS X a template instantiation request (see bottom of file)
 // can only be done once
+#define INCLUDE_GETAS_CPP 1
+#include "getas.cpp"
+
 #define INCLUDE_BASIC_OP_CPP 1
 #include "basic_op.cpp"
 #include "basic_op_new.cpp"
@@ -222,7 +225,6 @@
 
 
 
-
 template<class Sp> void* Data_<Sp>::operator new( size_t bytes)
 {
 	assert( bytes == sizeof( Data_));
@@ -477,13 +479,15 @@
 
 
 template<class Sp>
-Data_<Sp>* Data_<Sp>::Log()              
+BaseGDL* Data_<Sp>::Log()              
 { 
-  assert( 0);
-  return NULL;
+  DFloatGDL* res = static_cast<DFloatGDL*>
+    (this->Convert2( FLOAT, BaseGDL::COPY));
+  res->LogThis();
+  return res;
 }
 template<>
-Data_<SpDFloat>* Data_<SpDFloat>::Log()              
+BaseGDL* Data_<SpDFloat>::Log()              
 { 
   Data_* n = this->New( this->dim, BaseGDL::NOZERO);
   SizeT nEl = n->N_Elements();
@@ -502,7 +506,7 @@
   return n;
 }
 template<>
-Data_<SpDDouble>* Data_<SpDDouble>::Log()              
+BaseGDL* Data_<SpDDouble>::Log()              
 { 
   Data_* n = this->New( this->dim, BaseGDL::NOZERO);
   SizeT nEl = n->N_Elements();
@@ -518,7 +522,7 @@
   return n;
 }
 template<>
-Data_<SpDComplex>* Data_<SpDComplex>::Log()              
+BaseGDL* Data_<SpDComplex>::Log()              
 { 
   Data_* n = this->New( this->dim, BaseGDL::NOZERO);
   SizeT nEl = n->N_Elements();
@@ -534,7 +538,7 @@
   return n;
 }
 template<>
-Data_<SpDComplexDbl>* Data_<SpDComplexDbl>::Log()              
+BaseGDL* Data_<SpDComplexDbl>::Log()              
 { 
   Data_* n = this->New( this->dim, BaseGDL::NOZERO);
   SizeT nEl = n->N_Elements();
@@ -550,27 +554,35 @@
   return n;
 }
 
-template<class Sp>
-void Data_<Sp>::LogThis()              
-{ 
-  assert( 0);
+// this is actually not a "log" of "this",
+// but the behaviour is fine with the usage in the library function
+// the real LogThis is done in the specializations for floating and 
+// complex types
+template<class Sp>
+BaseGDL* Data_<Sp>::LogThis()              
+{ 
+  DFloatGDL* res = static_cast<DFloatGDL*>
+    (this->Convert2( FLOAT, BaseGDL::COPY));
+  res->LogThis(); // calls correct LogThis for float
+  return res;
 }
 template<>
-void Data_<SpDFloat>::LogThis()              
+BaseGDL* Data_<SpDFloat>::LogThis()              
 { 
   SizeT nEl = N_Elements();
   if( nEl == 1)
   {
     (*this)[ 0] = log( (*this)[ 0]);
-    return;
+return this;
   }
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel for if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
   for( SizeT i=0; i<nEl; ++i)
     (*this)[ i] = log( (*this)[ i]);
+return this;
 }
 template<>
-void Data_<SpDDouble>::LogThis()              
+BaseGDL* Data_<SpDDouble>::LogThis()              
 { 
 //#if (__GNUC__ == 3) && (__GNUC_MINOR__ == 2) //&& (__GNUC_PATCHLEVEL__ == 2)
 
@@ -578,7 +590,7 @@
   if( nEl == 1)
   {
     (*this)[ 0] = log( (*this)[ 0]);
-    return;
+return this;
   }
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel for if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
@@ -587,9 +599,10 @@
 /*#else
   dd = log(dd);
 #endif*/
+return this;
 }
 template<>
-void Data_<SpDComplex>::LogThis()              
+BaseGDL* Data_<SpDComplex>::LogThis()              
 { 
 //#if (__GNUC__ == 3) && (__GNUC_MINOR__ == 2) //&& (__GNUC_PATCHLEVEL__ == 2)
 
@@ -597,7 +610,7 @@
   if( nEl == 1)
   {
     (*this)[ 0] = log( (*this)[ 0]);
-    return;
+return this;
   }
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel for if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
@@ -606,9 +619,10 @@
 /*#else
   dd = log(dd);
 #endif*/
+return this;
 }
 template<>
-void Data_<SpDComplexDbl>::LogThis()              
+BaseGDL* Data_<SpDComplexDbl>::LogThis()              
 { 
 //#if (__GNUC__ == 3) && (__GNUC_MINOR__ == 2) //&& (__GNUC_PATCHLEVEL__ == 2)
 
@@ -616,7 +630,7 @@
   if( nEl == 1)
   {
     (*this)[ 0] = log( (*this)[ 0]);
-    return;
+return this;
   }
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel for if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
@@ -625,16 +639,19 @@
 /*#else
   dd = log(dd);
 #endif*/
+return this;
 }
 
 template<class Sp>
-Data_<Sp>* Data_<Sp>::Log10()              
+BaseGDL* Data_<Sp>::Log10()              
 { 
-  assert( 0);
-  return NULL;
+  DFloatGDL* res = static_cast<DFloatGDL*>
+    (this->Convert2( FLOAT, BaseGDL::COPY));
+  res->Log10This();
+  return res;
 }
 template<>
-Data_<SpDFloat>* Data_<SpDFloat>::Log10()              
+BaseGDL* Data_<SpDFloat>::Log10()              
 { 
 //#if (__GNUC__ == 3) && (__GNUC_MINOR__ == 2) //&& (__GNUC_PATCHLEVEL__ == 2)
 
@@ -655,7 +672,7 @@
 #endif*/
 }
 template<>
-Data_<SpDDouble>* Data_<SpDDouble>::Log10()              
+BaseGDL* Data_<SpDDouble>::Log10()              
 { 
 //#if (__GNUC__ == 3) && (__GNUC_MINOR__ == 2) //&& (__GNUC_PATCHLEVEL__ == 2)
 
@@ -676,7 +693,7 @@
 #endif*/
 }
 template<>
-Data_<SpDComplex>* Data_<SpDComplex>::Log10()              
+BaseGDL* Data_<SpDComplex>::Log10()              
 { 
 //#if (__GNUC__ == 3) && (__GNUC_MINOR__ == 2) //&& (__GNUC_PATCHLEVEL__ == 2)
 
@@ -697,7 +714,7 @@
 #endif*/
 }
 template<>
-Data_<SpDComplexDbl>* Data_<SpDComplexDbl>::Log10()              
+BaseGDL* Data_<SpDComplexDbl>::Log10()              
 { 
 //#if (__GNUC__ == 3) && (__GNUC_MINOR__ == 2) //&& (__GNUC_PATCHLEVEL__ == 2)
 
@@ -718,13 +735,17 @@
 #endif*/
 }
 
+// see comment at void Data_<Sp>::LogThis()              
 template<class Sp>
-void Data_<Sp>::Log10This()              
+BaseGDL* Data_<Sp>::Log10This()              
 { 
-  assert( 0);
+  DFloatGDL* res = static_cast<DFloatGDL*>
+    (this->Convert2( FLOAT, BaseGDL::COPY));
+  res->Log10This(); // calls correct Log10This for float
+  return res;
 }
 template<>
-void Data_<SpDFloat>::Log10This()              
+BaseGDL* Data_<SpDFloat>::Log10This()              
 { 
 #if 1 || (__GNUC__ == 3) && (__GNUC_MINOR__ == 2) //&& (__GNUC_PATCHLEVEL__ == 2)
 
@@ -732,7 +753,7 @@
   if( nEl == 1)
   {
     (*this)[ 0] = log10( (*this)[ 0]);
-    return;
+    return this;
   }
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel for if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
@@ -741,9 +762,10 @@
 #else
   dd = log10(dd);
 #endif
+    return this;
 }
 template<>
-void Data_<SpDDouble>::Log10This()              
+BaseGDL* Data_<SpDDouble>::Log10This()              
 { 
 #if 1 || (__GNUC__ == 3) && (__GNUC_MINOR__ == 2) //&& (__GNUC_PATCHLEVEL__ == 2)
 
@@ -751,7 +773,7 @@
   if( nEl == 1)
   {
     (*this)[ 0] = log10( (*this)[ 0]);
-    return;
+    return this;
   }
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel for if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
@@ -760,9 +782,10 @@
 #else
   dd = log10(dd);
 #endif
+    return this;
 }
 template<>
-void Data_<SpDComplex>::Log10This()              
+BaseGDL* Data_<SpDComplex>::Log10This()              
 { 
 #if 1 || (__GNUC__ == 3) && (__GNUC_MINOR__ == 2) //&& (__GNUC_PATCHLEVEL__ == 2)
 
@@ -770,7 +793,7 @@
   if( nEl == 1)
   {
     (*this)[ 0] = log10( (*this)[ 0]);
-    return;
+    return this;
   }
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel for if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
@@ -779,9 +802,10 @@
 #else
   dd = log10(dd);
 #endif
+    return this;
 }
 template<>
-void Data_<SpDComplexDbl>::Log10This()              
+BaseGDL* Data_<SpDComplexDbl>::Log10This()              
 { 
 #if 1 || (__GNUC__ == 3) && (__GNUC_MINOR__ == 2) //&& (__GNUC_PATCHLEVEL__ == 2)
 
@@ -789,7 +813,7 @@
   if( nEl == 1)
   {
     (*this)[ 0] = log10( (*this)[ 0]);
-    return;
+    return this;
   }
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel for if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
@@ -798,6 +822,7 @@
 #else
   dd = log10(dd);
 #endif
+    return this;
 }
 
 
@@ -840,32 +865,97 @@
 }
 
 template<class Sp>
-BaseGDL* Data_<Sp>::CShift( DLong d)
+BaseGDL* Data_<Sp>::CShift( DLong d) const
 {
-  Data_* sh = new Data_( this->dim, BaseGDL::NOZERO); 
+	SizeT nEl = dd.size();
+	SizeT shift = CShiftNormalize( d, nEl);
 
-  SizeT nEl = dd.size();
-  SizeT shift = CShiftNormalize( d, nEl);
+	if( shift == 0)
+	  return this->Dup();
 
-  SizeT firstChunk = nEl - shift;
+	Data_* sh = new Data_( this->dim, BaseGDL::NOZERO);
+
+	SizeT firstChunk = nEl - shift;
 
-  if( Sp::t != STRING) // strings are not POD all others are
-  {
 	memcpy( &sh->dd[ shift], &dd[0], firstChunk * sizeof(Ty));
 	memcpy( &sh->dd[ 0], &dd[firstChunk], shift * sizeof(Ty));
-  }
-  else // strings
-  {
+	
+	return sh;
+}
+
+template<>
+BaseGDL* Data_<SpDString>::CShift( DLong d) const
+{
+	SizeT nEl = dd.size();
+	SizeT shift = CShiftNormalize( d, nEl);
+
+	if( shift == 0)
+	  return this->Dup();
+
+	Data_* sh = new Data_( this->dim, BaseGDL::NOZERO);
+
+	SizeT firstChunk = nEl - shift;
+
 	SizeT i=0;
 	for( ; i<firstChunk; ++i)
-	sh->dd[shift++] = dd[ i];
+		sh->dd[shift++] = dd[ i];
 
 	shift = 0;
-	
+
 	for( ; i<nEl; ++i)
-	sh->dd[shift++] = dd[ i];
-   }
-   return sh;
+		sh->dd[shift++] = dd[ i];
+
+	return sh;
+}
+template<>
+BaseGDL* Data_<SpDPtr>::CShift( DLong d) const
+{
+	SizeT nEl = dd.size();
+	SizeT shift = CShiftNormalize( d, nEl);
+
+	if( shift == 0)
+	  return this->Dup(); // does IncRef
+
+	Data_* sh = new Data_( this->dim, BaseGDL::NOZERO);
+
+	SizeT firstChunk = nEl - shift;
+
+	SizeT i=0;
+	for( ; i<firstChunk; ++i)
+		sh->dd[shift++] = dd[ i];
+
+	shift = 0;
+
+	for( ; i<nEl; ++i)
+		sh->dd[shift++] = dd[ i];
+
+	GDLInterpreter::IncRef( sh);
+	return sh;
+}
+template<>
+BaseGDL* Data_<SpDObj>::CShift( DLong d) const
+{
+	SizeT nEl = dd.size();
+	SizeT shift = CShiftNormalize( d, nEl);
+
+	if( shift == 0)
+	  return this->Dup(); // does IncRefObj
+
+	Data_* sh = new Data_( this->dim, BaseGDL::NOZERO);
+
+	SizeT firstChunk = nEl - shift;
+
+	SizeT i=0;
+	for( ; i<firstChunk; ++i)
+		sh->dd[shift++] = dd[ i];
+
+	shift = 0;
+
+	for( ; i<nEl; ++i)
+		sh->dd[shift++] = dd[ i];
+
+	GDLInterpreter::IncRefObj( sh);
+	return sh;
 }
 
 template<typename Ty>
@@ -888,7 +978,7 @@
 #undef TEST_GOOD_OL_VERSION
 
 template<class Sp>
-BaseGDL* Data_<Sp>::CShift( DLong s[ MAXRANK])
+BaseGDL* Data_<Sp>::CShift( DLong s[ MAXRANK]) const
 {
   Data_* sh = new Data_( this->dim, BaseGDL::NOZERO); 
 
@@ -902,7 +992,7 @@
   long  dstIx[ MAXRANK+1];
   SizeT this_dim[ MAXRANK];
 
-  Ty* ddP = &(*this)[0];
+  const Ty* ddP = &(*this)[0];
   Ty* shP = &(*sh)[0];
 
   if( nDim == 2)
@@ -1548,7 +1638,7 @@
 // typename Data_<Sp>::Ty& Data_<Sp>::operator[] (const SizeT d1) 
 // { return (*this)[d1];}
 
-// only used from DStructGDL::DStructGDL(const DStructGDL& d_)
+// only used from DStructGDL
 template<class Sp> 
 Data_<Sp>&  Data_<Sp>::operator=(const BaseGDL& r)
 {
@@ -1560,7 +1650,7 @@
   dd = right.dd;
   return *this;
 }
-// only used from DStructGDL::DStructGDL(const DStructGDL& d_)
+// only used from DStructGDL
 template<>
 Data_<SpDPtr>& Data_<SpDPtr>::operator=(const BaseGDL& r)
 {
@@ -1574,7 +1664,7 @@
   GDLInterpreter::IncRef( this);
   return *this;
 }
-// only used from DStructGDL::DStructGDL(const DStructGDL& d_)
+// only used from DStructGDL
 template<>
 Data_<SpDObj>& Data_<SpDObj>::operator=(const BaseGDL& r)
 {
@@ -2572,7 +2662,8 @@
   
 	if( srcIn->Type() != this->Type())
     {
-      Data_* rConv = static_cast<Data_*>(srcIn->Convert2( this->Type(), BaseGDL::COPY));
+      Data_* rConv = static_cast<Data_*>(srcIn->Convert2( this->Type(), BaseGDL::COPY_BYTE_AS_INT));
+//      Data_* rConv = static_cast<Data_*>(srcIn->Convert2( this->Type(), BaseGDL::COPY));
       auto_ptr<Data_> conv_guard( rConv);
       (*this)[ix] = (*rConv)[0];
     }
@@ -2583,7 +2674,8 @@
 	} // ixR >= 0
   if( srcIn->Type() != this->Type())
     {
-      Data_* rConv = static_cast<Data_*>(srcIn->Convert2( this->Type(), BaseGDL::COPY));
+      Data_* rConv = static_cast<Data_*>(srcIn->Convert2( this->Type(), BaseGDL::COPY_BYTE_AS_INT));
+//       Data_* rConv = static_cast<Data_*>(srcIn->Convert2( this->Type(), BaseGDL::COPY));
       auto_ptr<Data_> conv_guard( rConv);
       (*this)[ixR] = (*rConv)[0];
     }
diff -ruN --exclude CVS gdl-0.9.2/src/datatypes.hpp gdl/src/datatypes.hpp
--- gdl-0.9.2/src/datatypes.hpp	2011-11-05 10:56:43.000000000 -0600
+++ gdl/src/datatypes.hpp	2011-12-08 00:03:09.000000000 -0700
@@ -113,8 +113,8 @@
   bool Greater(SizeT i1, SizeT i2) const; // comp 2 elements
   bool Equal(SizeT i1, SizeT i2) const; // comp 2 elements
 
-  BaseGDL* CShift( DLong d); 
-  BaseGDL* CShift( DLong d[MAXRANK]); 
+  BaseGDL* CShift( DLong d) const; 
+  BaseGDL* CShift( DLong d[MAXRANK]) const; 
 
   BaseGDL* Transpose( DUInt* perm);
   BaseGDL* Rotate( DLong dir);
@@ -237,11 +237,16 @@
 
   void Assign( BaseGDL* src, SizeT nEl);
 
-  Data_*   Log();
-  void     LogThis();
+  template< typename To> typename Data_<To>::Ty GetAs( SizeT i);
+//   {
+//     return dd[ i];
+//   }
+  
+  BaseGDL* Log();
+  BaseGDL* LogThis();
 
-  Data_*   Log10();
-  void     Log10This();
+  BaseGDL* Log10();
+  BaseGDL* Log10This();
 
   // operators
   BaseGDL* UMinus(); // UMinus for SpDString returns float
diff -ruN --exclude CVS gdl-0.9.2/src/deviceps.hpp gdl/src/deviceps.hpp
--- gdl-0.9.2/src/deviceps.hpp	2011-10-31 03:08:38.000000000 -0600
+++ gdl/src/deviceps.hpp	2012-01-03 03:31:38.000000000 -0700
@@ -19,6 +19,7 @@
 #  define DEVICEPS_HPP_
 
 #  include "gdlpsstream.hpp"
+#  include "plotting.hpp" // get_axis_crange for TV()
 #  include "initsysvar.hpp"
 #  include <gsl/gsl_const_mksa.h> // GSL_CONST_MKSA_INCH
 
@@ -190,7 +191,7 @@
         goto cleanup;
       }
       const size_t buflen=4096;
-      unsigned char buff[buflen];;
+      unsigned char buff[buflen];
       while (true)
       {
         size_t cnt = fread(&buff, 1, buflen, fp);
@@ -374,6 +375,124 @@
   {
     return decomposed;  
   }
+
+  // TODO: SA: this TV() should be merged with TV() in DeviceX and DeviceZ!
+  // TODO: SA: just a draft - a lot more needs to be done...
+  void TV( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 1); 
+
+    GDLGStream* actStream = GetStream();
+
+    // TODO: use it is XSIZE and YSIZE is not specified!
+    //DLong xsize = (*static_cast<DLongGDL*>( dStruct->GetTag( xSTag, 0)))[0];
+    //DLong ysize = (*static_cast<DLongGDL*>( dStruct->GetTag( ySTag, 0)))[0];
+
+    DLong pos=0; // TODO: handle it!
+    DDouble xmin, ymin;
+    {
+      DDouble null;
+      lib::get_axis_crange("X", xmin, null);
+      lib::get_axis_crange("Y", ymin, null);
+    }
+    if (nParam == 2) {
+      e->AssureLongScalarPar( 1, pos);
+    } else if (nParam >= 3) {
+      if (e->KeywordSet("NORMAL")) 
+      {
+        e->Throw("NORMAL keyword not supported yet");
+	//e->AssureDoubleScalarPar( 1, xmin);
+	//e->AssureDoubleScalarPar( 2, ymin);
+	//xLL = (DLong) rint(xLLf * xsize);
+	//yLL = (DLong) rint(yLLf * ysize);
+      } 
+      else if (e->KeywordSet("DEVICE")) 
+      {
+        e->Throw("DEVICE keyword not supported yet");
+      }
+      else // aka DATA
+      {
+	e->AssureDoubleScalarPar( 1, xmin);
+	e->AssureDoubleScalarPar( 2, ymin);
+      }
+    }
+
+    DByteGDL* p0B = e->GetParAs<DByteGDL>( 0);
+    SizeT rank = p0B->Rank();
+
+    int width, height;
+    DLong tru=0;
+    e->AssureLongScalarKWIfPresent( "TRUE", tru);
+    if (rank == 2) 
+      {
+	if (tru != 0)
+	  e->Throw( "Array must have 3 dimensions: "+
+		    e->GetParString(0));
+	width  = p0B->Dim(0);
+	height = p0B->Dim(1);
+      } 
+    else if( rank == 3) 
+      {
+	if (tru == 1) {
+	  width = p0B->Dim(1);
+	  height = p0B->Dim(2);
+	} else if (tru == 2) {
+	  width = p0B->Dim(0);
+	  height = p0B->Dim(2);
+	} else if (tru == 3) {
+	  width = p0B->Dim(0);
+	  height = p0B->Dim(1);
+	} else {
+	  e->Throw( "TRUE must be between 1 and 3");
+	}
+      } else {
+	e->Throw( "Image array must have rank 2 or 3");
+      }
+    if (tru != 0) e->Throw("Decomposed images not supported yet with PostScript + TV() (FIXME)"); // TODO!
+
+    /* TODO...
+    if( width + xLL > xsize || height + yLL > ysize)
+      e->Throw( "Value of image coordinates is out of allowed range.");
+    */
+
+    class grid2d {
+      public: PLFLT** data;
+      private: GDLGStream *pls;
+      private: int w, h;
+      public: grid2d(GDLGStream *actStream, int w, int h) 
+        : pls(actStream), w(w), h(h) { pls->Alloc2dGrid(&data, w, h); }
+      public: ~grid2d() { pls->Free2dGrid(data, w, h); }
+    } idata(actStream, width, height);
+    for (int x=0; x < width; ++x)
+      for (int y=0; y < height; ++y)
+        idata.data[x][y] = (*p0B)[x + y * width]; 
+
+    PLFLT xmax, ymax;
+    if (e->KeywordSet("XSIZE")) 
+    {
+      DDouble tmp;
+      e->AssureDoubleScalarKW("XSIZE", tmp);
+      xmax = xmin + tmp;
+    }
+    else e->Throw("Specification of XSIZE is mandatory for PostScript/TV() (FIXME!)"); // TODO!
+    if (e->KeywordSet("YSIZE")) 
+    {
+      DDouble tmp;
+      e->AssureDoubleScalarKW("YSIZE", tmp);
+      ymax = ymin + tmp;
+    }
+    else e->Throw("Specification of YSIZE is mandatory for PostScript/TV() (FIXME!)"); // TODO!
+
+    // TODO: map projection (via the last two arguments - same as was done in CONTOUR e.g.)
+    bool mapSet = false;
+#ifdef USE_LIBPROJ4
+    //get_mapset(mapSet);
+#endif
+    if (mapSet) e->Throw("PostScript + TV() + mapping cobination not available yet (FIXME!)");
+
+    actStream->imagefr(idata.data, width, height, xmin, xmax, ymin, ymax, 0., 255., 0., 255., NULL, NULL); 
+  }
+
 };
 
 #endif
diff -ruN --exclude CVS gdl-0.9.2/src/devicex.hpp gdl/src/devicex.hpp
--- gdl-0.9.2/src/devicex.hpp	2011-11-06 15:28:57.000000000 -0700
+++ gdl/src/devicex.hpp	2012-03-16 19:50:04.000000000 -0600
@@ -201,8 +201,8 @@
 	}
 
 	//std::cout << "XPutPixel: "<<kx<<"  "<< dev->height-ky-1 << std::endl;
-	//	if( ky < dev->height && kx < dev->width)
 	// TODO check if XPutPixel() and XGetPixel() are thread save
+	if( ky < dev->height && kx < dev->width)
 	XPutPixel(ximg, kx, dev->height-1-ky, curcolor.pixel);
       }
     }
@@ -417,10 +417,19 @@
     PLINT xoff; PLINT yoff;
     winList[ wIx]->gpage( xp, yp, xleng, yleng, xoff, yoff);
 
+    int debug=0;
+    if (debug) cout <<xp<<" "<<yp<<" "<<xleng<<" "<<yleng<<" "<<xoff<<" "<<yoff<<endl;
+
+    DLong xMaxSize, yMaxSize;
+    DeviceX::MaxXYSize(&xMaxSize, &yMaxSize);
+
     xleng = xSize;
     yleng = ySize;
     xoff  = xPos;
-    yoff  = yPos;
+    yoff  = yMaxSize-(yPos+ySize);
+    if (yoff <= 0) yoff=1;
+    
+    if (debug) cout <<xp<<" "<<yp<<" "<<xleng<<" "<<yleng<<" "<<xoff<<" "<<yoff<<endl;
 
     winList[ wIx]->spage( xp, yp, xleng, yleng, xoff, yoff);
 
@@ -567,7 +576,18 @@
     {
       Display* display = XOpenDisplay(NULL);
       if (display == NULL) ThrowGDLException("Cannot connect to X server");
-      decomposed = (DefaultDepth(display, DefaultScreen(display)) >= 15 ? true : false);
+
+      int Depth;
+      Depth=DefaultDepth(display, DefaultScreen(display));      
+      decomposed = (Depth >= 15 ? true : false);
+      DLong toto=16777216;
+      if (Depth == 24) 
+	(*static_cast<DLongGDL*>(dStruct->GetTag(n_colorsTag)))[0] = toto;
+      int debug=0;
+      if (debug) {
+	cout << "Display Depth " << Depth << endl;
+	cout << "n_colors " << toto << endl;
+      }
       XCloseDisplay(display);
     }
     if( decomposed) return 1;
@@ -579,7 +599,17 @@
 
   BaseGDL* TVRD( EnvT* e)
   {
+    // AC 17 march 2012: needed to catch the rigth current window (wset ...)
+    DLong wIx = -1;
     Graphics* actDevice = Graphics::GetDevice();
+    wIx = actDevice->ActWin();
+    bool success = actDevice->WSet( wIx);
+    cout << "wIx :" << wIx << " " << success << endl;
+
+    //everywhere we use XGetImage we need to set an error handler, since GTK crashes on every puny
+    //BadMatch error, and if you read the XGetImage doc you'll see that such errors are prone to happen
+    //as soon as part of the window is obscured.
+    int (*oldErrorHandler)(Display*, XErrorEvent*);
 
     XwDev *dev = (XwDev *) plsc->dev;
     if( dev == NULL || dev->xwd == NULL)
@@ -597,20 +627,20 @@
     if (e->KeywordSet("WORDS")) e->Throw( "WORDS keyword not yet supported.");
 
     /* this variable will contain the attributes of the window. */
-    //    XWindowAttributes win_attr;
+      XWindowAttributes win_attr;
 
     /* query the window's attributes. */
-    // Status rc = XGetWindowAttributes(xwd->display, dev->window, &win_attr);
-    // SizeT xSize = win_attr.width;
-    // SizeT ySize = win_attr.height;
-
-    int xSize, ySize, xPos, yPos;
+     Status rc = XGetWindowAttributes(xwd->display, dev->window, &win_attr);
+    unsigned int xSize = win_attr.width;
+    unsigned int ySize = win_attr.height;
+    //cout<<xSize<<" "<<ySize<<endl;
+    //int xPos, yPos;
     int actWin = /* actDevice-> */ ActWin();
-    bool success = /* actDevice-> */ WSize( actWin, &xSize, &ySize, &xPos, &yPos);
-
-    ximg = XGetImage( xwd->display, dev->window, 0, 0, 
+   // bool success = /* actDevice-> */ WSize( actWin, &xSize, &ySize, &xPos, &yPos);
+    oldErrorHandler = XSetErrorHandler(GetImageErrorHandler);
+    ximg = XGetImage( xwd->display, dev->window, (int) 0, (int) 0,
 		      xSize, ySize, AllPlanes, ZPixmap);
-
+    XSetErrorHandler(oldErrorHandler);
 
     SizeT dims[3];
     
@@ -623,57 +653,130 @@
     e->AssureLongScalarKWIfPresent( "CHANNEL", channel);
     if (channel > 3) e->Throw("Value of Channel is out of allowed range.");
 
+    unsigned int x0u=0;
+    unsigned int y0u=0;
+    unsigned int Nxu=xSize-1;
+    unsigned int Nyu=ySize-1;
+    unsigned int Channelu=0;
+
+    int nParam = e->NParam();
+    if (nParam >= 1) {
+      DLongGDL* x0 = e->GetParAs<DLongGDL>(0);
+      x0u=(*x0)[0];
+    }
+    if (nParam >= 2) {
+      DLongGDL* y0 = e->GetParAs<DLongGDL>(1);
+      y0u=(*y0)[0];
+    }
+    if (nParam >= 3) {
+      DLongGDL* Nx = e->GetParAs<DLongGDL>(2);
+      Nxu=(*Nx)[0];
+    }
+    if (nParam >= 4) {
+      DLongGDL* Ny = e->GetParAs<DLongGDL>(3);
+      Nyu=(*Ny)[0];
+    }
+    if (nParam == 5) {
+      DLongGDL* Channel = e->GetParAs<DLongGDL>(4);
+      Channelu=(*Channel)[0];
+    }
+
+    int debug =1;
+    if (debug) {
+      cout << "hello"<<endl;
+      //     cout << (*x0)[0] <<" "<< (*x1)[0] <<" "<< (*Nx)[0] <<" "<< (*Ny)[0] <<" "<< (*Channel)[0] <<endl;
+      cout << x0u <<" "<< y0u <<" "<< Nxu <<" "<< Nyu <<" "<< Channelu <<endl;
+    }
+
     if (tru == 0 || channel != -1) {
       dims[0] = xSize;
       dims[1] = ySize;
       dimension dim(dims, (SizeT) 2);
       res = new DByteGDL( dim, BaseGDL::ZERO);
 
-      if (channel <= 0) { 
-	DByte mx, mx1;
-	for( SizeT i=0; i<xSize*ySize; ++i) {
-	  mx = (DByte) ximg->data[4*i];
-	  for( SizeT j=1; j<=2; ++j) {
-	    mx1 = (DByte) ximg->data[4*i+j];
-	    if (mx1 > mx) mx = mx1;
-	  }
-	  (*res)[ xSize*ySize-1-i] = mx;
-	}
+      if (ximg == NULL) return res;
+
+      if (channel <= 0) {
+        DByte mx, mx1;
+        for (SizeT i = 0; i < xSize * ySize; ++i) {
+          mx = (DByte) ximg->data[4 * i];
+          for (SizeT j = 1; j <= 2; ++j) {
+            mx1 = (DByte) ximg->data[4 * i + j];
+            if (mx1 > mx) mx = mx1;
+          }
+          (*res)[ xSize * ySize - 1 - i] = mx;
+        }
       } else {
-	for( SizeT i=0; i<xSize*ySize; ++i) {
-	  (*res)[ xSize*ySize-1-i] = ximg->data[4*i+(3-channel)];
-	}
+        for (SizeT i = 0; i < xSize * ySize; ++i) {
+          (*res)[ xSize * ySize - 1 - i] = ximg->data[4 * i + (3 - channel)];
+        }
       }
 
       // Reflect about y-axis
-      for( SizeT i=0; i<ySize; ++i) {
-	for( SizeT j=0; j<xSize/2; ++j) {
-	  DByte c = (*res)[ i*xSize+(xSize-1-j)];
-	  (*res)[ i*xSize+(xSize-1-j)] = (*res)[ i*xSize+j];
-	  (*res)[ i*xSize+j] = c;
-	}
+      for (SizeT i = 0; i < ySize; ++i) {
+        for (SizeT j = 0; j < xSize / 2; ++j) {
+          DByte c = (*res)[ i * xSize + (xSize - 1 - j)];
+          (*res)[ i * xSize + (xSize - 1 - j)] = (*res)[ i * xSize + j];
+          (*res)[ i * xSize + j] = c;
+        }
       }
       return res;
 
     } else {
       if (tru > 3) e->Throw("Value of TRUE keyword is out of allowed range.");
 
-      dims[0] = 3;
-      dims[1] = xSize;
-      dims[2] = ySize;
-      dimension dim(dims, (SizeT) 3);
-      res = new DByteGDL( dim, BaseGDL::NOZERO);
-
-      for( SizeT i=0; i<ySize; ++i) {
-	for( SizeT j=0; j<xSize; ++j) {
-	  for( SizeT k=0; k<4; ++k) {
-	    if (k < 3) {
-	      (*res)[(ySize-i-1)*xSize*3 + j*3 + 2-k] = 
-		ximg->data[i*xSize*4 + j*4 + k];
+      // AC 17 march 2012
+      // below something is wrong
+      // window, 3,xsize=10, ysize=7
+      // plot, findgen(10), col='ff'x, back='ff'x ;; all in red
+      // uu=tvrd(/tru)
+      // plot, uu(0,*,*) ; should be at 255, but not all :(
+      // It seems to be related to refreshment of the screen !
+
+      if (nParam ==0)
+	{
+	  // AC 17 march 2012 : we may have a mirror effect here
+	  dims[0] = 3;
+	  dims[1] = xSize;
+	  dims[2] = ySize;
+	  dimension dim(dims, (SizeT) 3);
+	  res = new DByteGDL(dim, BaseGDL::NOZERO);
+	  if (ximg == NULL) return res;
+	  
+	  SizeT jj=0;
+	  for (SizeT i = 0; i < xSize; ++i) {
+	    for (SizeT j = 0; j < ySize; ++j) {
+	      for (SizeT k = 0; k < 4; ++k) {
+		if (k < 3) {
+		  (*res)[xSize*j * 3 + i * 3 + 2 - k] =
+		        ximg->data[j * xSize * 4 + i * 4 + k];
+		}
+	      }
+	    }
+	  }
+	}
+      else
+	{
+	  // AC 17 march 2012 : we may have a mirror effect here
+	  dims[0] = 3;
+	  dims[1] = Nxu;
+	  dims[2] = Nyu;
+	  cout << dims[1] << " " << dims[2] <<endl;
+	  dimension dim(dims, (SizeT) 3);
+	  res = new DByteGDL(dim, BaseGDL::NOZERO);
+	  if (ximg == NULL) return res;
+	  
+	  for (SizeT i = x0u; i < x0u+Nxu; ++i) {
+	    for (SizeT j = y0u; j < y0u+Nyu; ++j) {
+	      for (SizeT k = 0; k < 4; ++k) {
+		if (k < 3) {		  
+		  (*res)[dims[1]*(j-y0u) * 3 + (i-x0u) * 3 + 2 - k] =
+		    ximg->data[j * xSize * 4 + i * 4 + k];
+		}
+	      }
 	    }
 	  }
 	}
-      }
     }
 
     XDestroyImage(ximg);
@@ -703,8 +806,8 @@
     GDLGStream* actStream = GetStream();
     if( actStream == NULL)
       {
-	std::cerr << "TV: Internal error: plstream not set." << std::endl;
-	exit( EXIT_FAILURE);
+		std::cerr << "TV: Internal error: plstream not set." << std::endl;
+		exit( EXIT_FAILURE);
       }
 
     //    actStream->NextPlot( false);
@@ -730,7 +833,7 @@
     //DByteGDL* p0B = e->GetParAs<DByteGDL>( 0);
     DByteGDL* p0B;
     p0B =static_cast<DByteGDL*>(p0->Convert2(BYTE,BaseGDL::COPY));
-    //e->Guard( p0B);
+    e->Guard( p0B);
     
     int width, height;
     DLong tru=0;
@@ -884,6 +987,21 @@
     }   
 #endif
   }
+  
+  static void MaxXYSize(DLong *xSize, DLong *ySize)
+  {
+    *ySize = 640;
+    *ySize = 512;
+#ifdef HAVE_X
+    Display* display = XOpenDisplay(NULL);
+    if (display != NULL)
+    {
+      *xSize = DisplayWidth(display, DefaultScreen(display));
+      *ySize = DisplayHeight(display, DefaultScreen(display));
+      XCloseDisplay(display);
+    }
+#endif
+  }
 
 };
 
diff -ruN --exclude CVS gdl-0.9.2/src/devicez.hpp gdl/src/devicez.hpp
--- gdl-0.9.2/src/devicez.hpp	2011-08-22 14:41:46.000000000 -0600
+++ gdl/src/devicez.hpp	2011-12-28 16:14:09.000000000 -0700
@@ -277,7 +277,7 @@
     //    Graphics* actDevice = Graphics::GetDevice();
     SizeT nParam=e->NParam( 1); 
 
-    GDLGStream* actStream = /* actDevice-> */ GetStream();
+    GDLGStream* actStream = GetStream();
 
     //    actStream->NextPlot( false); // JMG
 
diff -ruN --exclude CVS gdl-0.9.2/src/dinterpreter.cpp gdl/src/dinterpreter.cpp
--- gdl-0.9.2/src/dinterpreter.cpp	2011-09-20 05:33:52.000000000 -0600
+++ gdl/src/dinterpreter.cpp	2012-07-11 09:59:42.000000000 -0600
@@ -949,7 +949,7 @@
     {
 	  env->ResizeForLoops( nForLoopsIn);
       
-      cerr << "Unhandled GDL exception: " <<  e.toString() << endl;;
+      cerr << "Unhandled GDL exception: " <<  e.toString() << endl;
       return CC_OK;
     }
   catch( ANTLRException& e)
@@ -1089,14 +1089,16 @@
 // inner loop (called via Control-C, STOP, error)
 RetCode DInterpreter::InnerInterpreterLoop(SizeT lineOffset)
 {
-
-  bool runCmd = false;
+  ProgNodeP retTreeSave = _retTree;
   for (;;) {
     feclearexcept(FE_ALL_EXCEPT);
 
 //     try
 //       {
 	DInterpreter::CommandCode ret=ExecuteLine(NULL, lineOffset);
+
+	_retTree = retTreeSave; // on return, _retTree should be kept
+
 	if( ret == CC_RETURN) return RC_RETURN;
 	if( ret == CC_CONTINUE) return RC_OK; 
 	if( ret == CC_STEP) return RC_OK;
diff -ruN --exclude CVS gdl-0.9.2/src/dpro.cpp gdl/src/dpro.cpp
--- gdl-0.9.2/src/dpro.cpp	2010-12-03 13:12:41.000000000 -0700
+++ gdl/src/dpro.cpp	2011-11-17 19:50:19.000000000 -0700
@@ -44,11 +44,12 @@
 // DLib ******************************************************
 DLib::DLib( const string& n, const string& o, const int nPar_, 
 	    const string keyNames[],
-	    const string warnKeyNames[]): 
+	    const string warnKeyNames[], const int nParMin_): 
   DSub(n,o)
 {
   nPar=nPar_;
-
+  nParMin = nParMin_;
+  
   // find out number of keywords and set them
   SizeT nKey_=0;
   if( keyNames != NULL)
@@ -121,41 +122,51 @@
   return s;
 }
 
+// const string DLibFunDirect::ToString()
+// {
+//   string s = "res=";
+//   s += name+"(";
+//   s += "["+i2s( nPar)+" Arg]";
+//   s += ")";
+//   return s;
+// }
+
 DLibPro::DLibPro( LibPro p, const string& n, const string& o, const int nPar_, 
-	 const string keyNames[], const string warnKeyNames[])
-  : DLib(n,o,nPar_,keyNames, warnKeyNames), pro(p)
+	 const string keyNames[], const string warnKeyNames[], const int nParMin_)
+  : DLib(n,o,nPar_,keyNames, warnKeyNames, nParMin_), pro(p)
 {
   libProList.push_back(this);
 }
 DLibPro::DLibPro( LibPro p, const string& n, const int nPar_, 
-	 const string keyNames[], const string warnKeyNames[])
-  : DLib(n,"",nPar_,keyNames, warnKeyNames), pro(p)
+	 const string keyNames[], const string warnKeyNames[], const int nParMin_)
+  : DLib(n,"",nPar_,keyNames, warnKeyNames, nParMin_), pro(p)
 {
   libProList.push_back(this);
 }
 
 DLibFun::DLibFun( LibFun f, const string& n, const string& o, const int nPar_, 
-	 const string keyNames[], const string warnKeyNames[])
-  : DLib(n,o,nPar_,keyNames, warnKeyNames), fun(f)
+	 const string keyNames[], const string warnKeyNames[], const int nParMin_)
+  : DLib(n,o,nPar_,keyNames, warnKeyNames, nParMin_), fun(f)
 {
   libFunList.push_back(this);
 }
 
 DLibFun::DLibFun( LibFun f, const string& n, const int nPar_, 
-	 const string keyNames[], const string warnKeyNames[])
-  : DLib(n,"",nPar_,keyNames, warnKeyNames), fun(f)
+	 const string keyNames[], const string warnKeyNames[], const int nParMin_)
+  : DLib(n,"",nPar_,keyNames, warnKeyNames, nParMin_), fun(f)
 {
   libFunList.push_back(this);
 }
 DLibFunRetNew::DLibFunRetNew( LibFun f, const string& n, 
 			const string& o, const int nPar_, 
-			const string keyNames[], const string warnKeyNames[])
-  : DLibFun(f,n,o,nPar_,keyNames, warnKeyNames)
+			const string keyNames[], const string warnKeyNames[], const int nParMin_)
+  : DLibFun(f,n,o,nPar_,keyNames, warnKeyNames, nParMin_)
 {}
 
 DLibFunRetNew::DLibFunRetNew( LibFun f, const string& n, const int nPar_, 
-			const string keyNames[], const string warnKeyNames[], bool rConstant)
-  : DLibFun(f,n,nPar_,keyNames, warnKeyNames), retConstant( rConstant)
+			const string keyNames[], const string warnKeyNames[], bool rConstant,
+			const int nParMin_)
+  : DLibFun(f,n,nPar_,keyNames, warnKeyNames, nParMin_), retConstant( rConstant)
 {}
 // DLibFunRetNew::DLibFunRetNew( LibFun f, const string& n, const int nPar_, 
 // 			bool rConstant)
@@ -164,6 +175,9 @@
 // DLibFunRetNew::DLibFunRetNew( LibFun f, const string& n, bool rConstant)
 //   : DLibFun(f,n), retConstant( rConstant)
 // {}
+DLibFunDirect::DLibFunDirect( LibFunDirect f, const std::string& n, bool rConstant)
+  : DLibFunRetNew(NULL,n,1,NULL,NULL,rConstant,1), funDirect(f)
+{}
 
 
 // DSubUD ****************************************************
diff -ruN --exclude CVS gdl-0.9.2/src/dpro.hpp gdl/src/dpro.hpp
--- gdl-0.9.2/src/dpro.hpp	2010-05-04 11:32:32.000000000 -0600
+++ gdl/src/dpro.hpp	2011-11-17 19:50:19.000000000 -0700
@@ -117,6 +117,7 @@
   IDList              key;    // keyword names (IDList: typedefs.hpp)
                               // (KEYWORD_NAME=keyword_value)
   int                 nPar;   // number of parameters (-1 = infinite)
+  int                 nParMin;  // minimum number of parameters (-1 = infinite)
 
   ExtraType           extra;
   int                 extraIx; // index of extra keyword
@@ -126,7 +127,7 @@
 
 public:
   DSub( const std::string& n, const std::string& o=""): 
-    name(n), object(o), nPar(0), extra(NONE), extraIx(-1) 
+    name(n), object(o), nPar(0), nParMin(0), extra(NONE), extraIx(-1) 
   {}
 
   virtual ~DSub(); // polymorphism
@@ -168,6 +169,7 @@
 
   int   NKey() const { return key.size();}
   int   NPar() const { return nPar;}
+  int   NParMin() const { return nParMin;}
 
   //  bool AKey() { return aKey;} // additional keywords allowed
 
@@ -181,6 +183,7 @@
 
 typedef void     (*LibPro)(EnvT*);
 typedef BaseGDL* (*LibFun)(EnvT*);
+typedef BaseGDL* (*LibFunDirect)(BaseGDL* param,bool canGrab);
 
 // library procedure/function (in cases both are handled the same way)
 class DLib: public DSub
@@ -188,7 +191,7 @@
 public:
   DLib( const std::string& n, const std::string& o, const int nPar_,
 	const std::string keyNames[],
-	const std::string warnKeyNames[]);
+	const std::string warnKeyNames[], const int nParMin_);
 
   virtual const std::string ToString() = 0;
 };
@@ -207,12 +210,12 @@
   // on which a value is returned.
   DLibPro( LibPro p, const std::string& n, const int nPar_=0, 
 	   const std::string keyNames[]=NULL,
-	   const std::string warnKeyNames[]=NULL);
+	   const std::string warnKeyNames[]=NULL, const int nParMin_=0);
 
   DLibPro( LibPro p, const std::string& n, const std::string& o, 
 	   const int nPar_=0, 
 	   const std::string keyNames[]=NULL,
-	   const std::string warnKeyNames[]=NULL);
+	   const std::string warnKeyNames[]=NULL, const int nParMin_=0);
 
   LibPro Pro() { return pro;}
 
@@ -226,40 +229,56 @@
 public:
   DLibFun( LibFun f, const std::string& n, const int nPar_=0, 
 	   const std::string keyNames[]=NULL,
-	   const std::string warnKeyNames[]=NULL);
+	   const std::string warnKeyNames[]=NULL, const int nParMin_=0);
 
   DLibFun( LibFun f, const std::string& n, const std::string& o, 
 	   const int nPar_=0, 
 	   const std::string keyNames[]=NULL,
-	   const std::string warnKeyNames[]=NULL);
+	   const std::string warnKeyNames[]=NULL, const int nParMin_=0);
 
   LibFun Fun() { return fun;}
 
   const std::string ToString();
 
   virtual bool RetNew() { return false;}
+  virtual bool DirectCall() { return false;}
 };
 
 // library function which ALWAYS return a new value
 // (as opposite to returning an input value)
 class DLibFunRetNew: public DLibFun
 {
-  bool   retConstant;
+  bool   retConstant; // means: can be pre-evaluated with constant input 
 public:
   DLibFunRetNew( LibFun f, const std::string& n, const int nPar_=0, 
 		 const std::string keyNames[]=NULL,
-		 const std::string warnKeyNames[]=NULL, bool rConstant=false);
+		 const std::string warnKeyNames[]=NULL, bool rConstant=false, const int nParMin_=0);
 
 
   DLibFunRetNew( LibFun f, const std::string& n, const std::string& o, 
 		 const int nPar_=0, 
 		 const std::string keyNames[]=NULL,
-		 const std::string warnKeyNames[]=NULL);
+		 const std::string warnKeyNames[]=NULL, const int nParMin_=0);
 
   bool RetNew() { return true;}
   bool RetConstant() { return this->retConstant;}
 };
 
+// direct call functions must have:
+// ony one parameter, no keywords
+// these functions are called "direct", no environment is created
+class DLibFunDirect: public DLibFunRetNew
+{
+  LibFunDirect funDirect;
+public:
+  DLibFunDirect( LibFunDirect f, const std::string& n, bool retConstant_=true);
+
+  LibFunDirect FunDirect() { return funDirect;}
+
+//   bool RetNew() { return true;}
+  bool DirectCall() { return true;}
+};
+
 // UD pro/fun ********************************************************
 // function/procedure (differ because they are in different lists)
 // User Defined
diff -ruN --exclude CVS gdl-0.9.2/src/dstructgdl.cpp gdl/src/dstructgdl.cpp
--- gdl-0.9.2/src/dstructgdl.cpp	2011-11-05 10:56:43.000000000 -0600
+++ gdl/src/dstructgdl.cpp	2011-12-08 00:03:09.000000000 -0700
@@ -202,9 +202,10 @@
 }
 
 
-DStructGDL* DStructGDL::CShift( DLong d)
+DStructGDL* DStructGDL::CShift( DLong d) const
 {
-  DStructGDL* sh = new DStructGDL( Desc(), dim, BaseGDL::NOZERO);
+  // must be nulled for correct reference counting
+  DStructGDL* sh = new DStructGDL( Desc(), dim);//, BaseGDL::NOZERO);
 
   SizeT nEl = N_Elements();
   SizeT nTag = NTags();
@@ -221,9 +222,10 @@
 }
 
 // TODO: Implement fast 2D version (see datatypes.cpp)
-DStructGDL* DStructGDL::CShift( DLong s[MAXRANK])
+DStructGDL* DStructGDL::CShift( DLong s[MAXRANK]) const
 {
-  DStructGDL* sh = new DStructGDL( Desc(), dim, BaseGDL::NOZERO);
+  // must be nulled for correct reference counting
+  DStructGDL* sh = new DStructGDL( Desc(), dim);//, BaseGDL::NOZERO);
 
   SizeT nDim = Rank();
   SizeT nEl = N_Elements();
diff -ruN --exclude CVS gdl-0.9.2/src/dstructgdl.hpp gdl/src/dstructgdl.hpp
--- gdl-0.9.2/src/dstructgdl.hpp	2011-11-05 10:56:43.000000000 -0600
+++ gdl/src/dstructgdl.hpp	2011-12-08 00:03:09.000000000 -0700
@@ -217,8 +217,8 @@
    DStructGDL* SetBuffer( const void* b);
   void SetBufferSize( SizeT s);
 
-  DStructGDL* CShift( DLong d);
-  DStructGDL* CShift( DLong d[MAXRANK]);
+  DStructGDL* CShift( DLong d) const;
+  DStructGDL* CShift( DLong d[MAXRANK]) const;
 
   // for use by MIN and MAX functions
   void MinMax( DLong* minE, DLong* maxE, 
@@ -487,6 +487,8 @@
 			const SizeT catRank, 
 			const SizeT rank);
 
+  template< typename To> typename Data_<To>::Ty GetAs( SizeT i);
+
   BaseGDL* Convert2( DType destTy, 
 		     BaseGDL::Convert2Mode mode = BaseGDL::CONVERT);
   
diff -ruN --exclude CVS gdl-0.9.2/src/envt.cpp gdl/src/envt.cpp
--- gdl-0.9.2/src/envt.cpp	2011-11-07 16:38:21.000000000 -0700
+++ gdl/src/envt.cpp	2012-07-16 07:21:15.000000000 -0600
@@ -907,23 +907,28 @@
 }
 
 // called after parameter definition
-void EnvBaseT::Extra()
+void EnvBaseT::ResolveExtra()
 {
-  if( extra != NULL) extra->Resolve();
+  if( extra != NULL) extra->ResolveExtra( NULL);
 }
 
 EnvBaseT* EnvBaseT::Caller()
 {
   EnvStackT& callStack=interpreter->CallStack();
 
-  if( callStack.size() <= 1) return NULL;
+  //if( callStack.size() <= 1) return NULL;
 
-  if( callStack.back() != this) 
-    return callStack.back();
-//     return static_cast< EnvUDT*>( callStack.back());
+  // library environments are no longer on the call stack
+  assert( callStack.back() != this);
 
-  return callStack[ callStack.size()-2];
-//   return static_cast< EnvUDT*>( callStack[ callStack.size()-2]);
+  return callStack.back();
+  
+//   if( callStack.back() != this) 
+//     return callStack.back();
+// //     return static_cast< EnvUDT*>( callStack.back());
+// 
+//   return callStack[ callStack.size()-2];
+// //   return static_cast< EnvUDT*>( callStack[ callStack.size()-2]);
 }
 
 // used by obj_new (basic_fun.cpp)
@@ -960,18 +965,20 @@
       newEnv->SetNextPar( &GetPar( p)); // pass as global
     }
 
-  interpreter->CallStack().push_back( newEnv); 
+  // interpreter->CallStack().push_back( newEnv); // problem with call_function if done here s. b.
 
   // _REF_EXTRA is set to the keyword string array
   newEnv->extra = new ExtraT( newEnv);
   newEnv->extra->Set( &env[0]);
-  newEnv->extra->Resolve();
+  newEnv->extra->ResolveExtra( this); // s. a. problem caused here due to a call to EnvBaseT::Caller() in Resolve()
+
+  interpreter->CallStack().push_back( newEnv); 
 }
 // used by obj_new (basic_fun.cpp)
 // and obj_destroy (basic_pro.cpp)
 // and call_function (basic_fun.cpp)
 // and call_procedure (basic_pro.cpp)
-void EnvT::PushNewEnv(  DSub* newPro, SizeT skipP, BaseGDL** newObj)
+EnvT* EnvT::NewEnv(  DSub* newPro, SizeT skipP, BaseGDL** newObj)
 {
   EnvT* newEnv= new EnvT( this, newPro, newObj);
 
@@ -982,12 +989,14 @@
       newEnv->SetNextPar( &GetPar( p)); // pass as global
     }
 
-  interpreter->CallStack().push_back( newEnv); 
+//   interpreter->CallStack().push_back( newEnv); 
 
   // _REF_EXTRA is set to the keyword string array
   newEnv->extra = new ExtraT( newEnv);
   newEnv->extra->Set( &env[0]);
-  newEnv->extra->Resolve();
+  newEnv->extra->ResolveExtra( this);
+
+  return newEnv;
 }
 
 void EnvT::AssureGlobalPar( SizeT pIx)
@@ -1354,6 +1363,11 @@
     }
   return env[ ix];
 }
+// BaseGDL*& EnvT::GetParUnchecked(SizeT i)
+// {
+//   SizeT ix= i + pro->key.size();
+//   return env[ ix];
+// }
 
 void EnvBaseT::AssureLongScalarPar( SizeT pIx, DLong64& scalar)
 {
diff -ruN --exclude CVS gdl-0.9.2/src/envt.hpp gdl/src/envt.hpp
--- gdl-0.9.2/src/envt.hpp	2011-11-05 10:56:43.000000000 -0600
+++ gdl/src/envt.hpp	2012-07-16 07:21:15.000000000 -0600
@@ -112,6 +112,7 @@
 
   // for CLEANUP calls due to reference counting
   void PushNewEmptyEnvUD(  DSub* newPro, BaseGDL** newObj = NULL);
+  void PushNewEmptyEnvUDWithExtra(  DSub* newPro, BaseGDL** newObj = NULL);
   
   void AddEnv( DPtrListT& ptrAccessible, DPtrListT& objAccessible);
   void AddToDestroy( DPtrListT& ptrAccessible, DPtrListT& objAccessible);
@@ -179,7 +180,7 @@
   void RemoveLoc( BaseGDL* p) { env.RemoveLoc( p);}
 
   // called after parameter definition
-  void Extra();
+  void ResolveExtra();
   friend class ExtraT;
 
   // used by compiler and from EnvT (for variable number of paramters)
@@ -478,7 +479,7 @@
   void ObjCleanup( DObj actID);
 
   // used by obj_new (basic_fun.cpp)
-  void PushNewEnv(  DSub* newPro, SizeT skipP, BaseGDL** newObj=NULL);
+  EnvT* NewEnv(  DSub* newPro, SizeT skipP, BaseGDL** newObj=NULL);
   void PushNewEnvUD(  DSub* newPro, SizeT skipP, BaseGDL** newObj=NULL);
   // for exclusive use by lib::on_error
   void OnError();
@@ -523,6 +524,10 @@
 
   // returns the ix'th parameter (NULL if not defined)
   BaseGDL*& GetPar(SizeT i);
+  
+  // it is now possible to define a niminum number of parameters for library subroutines
+  // if this is done the next function can be used
+//   BaseGDL*& GetParUnchecked(SizeT i);
 
   // get i'th parameter
   // throws if not defined (ie. never returns NULL)
@@ -572,9 +577,11 @@
   T* GetParAs( SizeT pIx)
   {
     BaseGDL* p = GetParDefined( pIx);
-    T* res = dynamic_cast<T*>( p);
-    if( res != NULL) return res;
-    res = static_cast<T*>( p->Convert2( T::t, BaseGDL::COPY));
+	if( p->Type() == T::t)
+		return static_cast<T*>( p);
+//     T* res = dynamic_cast<T*>( p);
+//     if( res != NULL) return res;
+    T* res = static_cast<T*>( p->Convert2( T::t, BaseGDL::COPY));
     Guard( res);
     return res;
   }
@@ -585,9 +592,11 @@
     BaseGDL* p = GetKW( ix);
     if( p == NULL)
       Throw( "Keyword is undefined: "+GetString( ix));
-    T* res = dynamic_cast<T*>( p);
-    if( res != NULL) return res;
-    res = static_cast<T*>( p->Convert2( T::t, BaseGDL::COPY));
+	if( p->Type() == T::t)
+		return static_cast<T*>( p);
+//     T* res = dynamic_cast<T*>( p);
+//     if( res != NULL) return res;
+    T* res = static_cast<T*>( p->Convert2( T::t, BaseGDL::COPY));
     Guard( res);
     return res;
   }
@@ -598,9 +607,11 @@
   {
     BaseGDL* p = GetPar( pIx);
     if( p == NULL) return NULL;
-    T* res = dynamic_cast<T*>( p);
-    if( res != NULL) return res;
-    res = static_cast<T*>( p->Convert2( T::t, BaseGDL::COPY));
+	if( p->Type() == T::t)
+		return static_cast<T*>( p);
+//     T* res = dynamic_cast<T*>( p);
+//     if( res != NULL) return res;
+    T* res = static_cast<T*>( p->Convert2( T::t, BaseGDL::COPY));
     Guard( res);
     return res;
   }
@@ -610,9 +621,11 @@
   {
     BaseGDL* p = GetKW( ix);
     if( p == NULL) return NULL;
-    T* res = dynamic_cast<T*>( p);
-    if( res != NULL) return res;
-    res = static_cast<T*>( p->Convert2( T::t, BaseGDL::COPY));
+	if( p->Type() == T::t)
+		return static_cast<T*>( p);
+//     T* res = dynamic_cast<T*>( p);
+//     if( res != NULL) return res;
+    T* res = static_cast<T*>( p->Convert2( T::t, BaseGDL::COPY));
     Guard( res);
     return res;
   }
@@ -771,7 +784,8 @@
 };
 
 
-typedef std::deque<EnvBaseT*> EnvStackT;
+// typedef std::deque<EnvBaseT*> EnvStackT;
+typedef std::deque<EnvUDT*> EnvStackT;
 
 #endif
 
diff -ruN --exclude CVS gdl-0.9.2/src/extrat.cpp gdl/src/extrat.cpp
--- gdl-0.9.2/src/extrat.cpp	2009-11-08 16:36:07.000000000 -0700
+++ gdl/src/extrat.cpp	2012-07-16 07:21:15.000000000 -0600
@@ -23,7 +23,7 @@
 
 using namespace std;
 
-void ExtraT::Resolve()
+void ExtraT::ResolveExtra(EnvBaseT* callerIn)
 {
   // if the subroutine has _REF_EXTRA, explicit keywords override
   // if the subroutine has _EXTRA, _EXTRA keywords override
@@ -36,6 +36,9 @@
 
   DSub::ExtraType extraType= pro->Extra();
 
+//   EnvBaseT* callerDebug=thisEnv->Caller();
+//   DSub::ExtraType extraTypeDebug= callerDebug->pro->Extra();
+
   DStructGDL* extraStruct= dynamic_cast<DStructGDL*>(thisExtra);
   if( extraStruct != NULL) // _EXTRA
     {
@@ -50,34 +53,46 @@
 	  IDList::iterator f=find_if(pro->key.begin(),
 				     pro->key.end(),
 				     String_abbref_eq( tName));
-	  if( f != pro->key.end())
-	    { // found, _EXTRA always overrides explicit keywords
-	      SizeT varIx=distance(pro->key.begin(),f);
-	      
-	      thisEnv->env.Reset( varIx, extraStruct->Get( t)); // local
-	    }
-	  else // not found -> add tag to extra data
-	    { 
-	      if( extraType != DSub::NONE)
-		{
-		  listName.push_back( tName);
-		  listEnv.push_back( extraStruct->Get( t)); // always local
-		}
-	      else if( strict)
-		{ // pro has no (_REF)_EXTRA) and _STRICT_EXTRA -> error
-		  thisEnv->Throw( "Keyword "+tName+
-				      " not allowed in call to: "+
-				      pro->ObjectName());
-		}
-	    }
-	}
+      if (f != pro->key.end())
+      { // found, _EXTRA always overrides explicit keywords
+        SizeT varIx = distance(pro->key.begin(), f);
+
+        thisEnv->env.Reset(varIx, extraStruct->Get(t)); // local
+      }
+      else // not found -> add tag to extra data
+      {
+        if (extraType != DSub::NONE)
+        {
+          listName.push_back(tName);
+          listEnv.push_back(extraStruct->Get(t)); // always local
+        }
+        else if (strict || callerIn == NULL) // always strict if callerIn is set
+        { // pro has no (_REF)_EXTRA and _STRICT_EXTRA -> error
+          // ... unless keyword is a warnkey!
+          // search warn keyword
+          IDList::iterator wf=find_if(pro->warnKey.begin(),
+				     pro->warnKey.end(),
+				     String_abbref_eq( tName));
+          if (wf == pro->warnKey.end())
+          {
+            thisEnv->Throw("Keyword " + tName +
+            " not allowed in call to: " +
+            pro->ObjectName());
+          }
+        }
+      }
+    }
     }
   else // _REF_EXTRA
     {
       DStringGDL* extraString= dynamic_cast<DStringGDL*>(thisExtra);
       if( extraString != NULL)
 	{
-	  EnvBaseT* caller=thisEnv->Caller();
+	  EnvBaseT* caller;
+	  if( callerIn == NULL)
+	    caller = thisEnv->Caller();
+	  else
+	    caller = callerIn;
 
 	  // STRING only works, if the *caller* has _REF_EXTRA
 	  if( caller->pro->Extra() == DSub::REFEXTRA)
diff -ruN --exclude CVS gdl-0.9.2/src/extrat.hpp gdl/src/extrat.hpp
--- gdl-0.9.2/src/extrat.hpp	2005-09-24 09:18:18.000000000 -0600
+++ gdl/src/extrat.hpp	2012-07-16 07:21:15.000000000 -0600
@@ -114,7 +114,7 @@
   // 2. if pro has (_REF)_EXTRA:
   // combine additional keywords and the (remaining) _EXTRA data to pro's 
   // (_REF)_EXTRA value
-  void Resolve();
+  void ResolveExtra(EnvBaseT* caller);
 };
 
 #endif
diff -ruN --exclude CVS gdl-0.9.2/src/fftw.cpp gdl/src/fftw.cpp
--- gdl-0.9.2/src/fftw.cpp	2011-09-29 12:54:30.000000000 -0600
+++ gdl/src/fftw.cpp	2012-06-28 03:54:54.000000000 -0600
@@ -42,7 +42,7 @@
   T* fftw_template(BaseGDL* p0,
 		   SizeT nEl, SizeT dbl, SizeT overwrite, double direct)
   {
-    int dim[8];
+    int dim[MAXRANK];
 
     T* res;
 
diff -ruN --exclude CVS gdl-0.9.2/src/gdlc.g gdl/src/gdlc.g
--- gdl-0.9.2/src/gdlc.g	2011-11-07 16:38:21.000000000 -0700
+++ gdl/src/gdlc.g	2011-11-15 16:19:00.000000000 -0700
@@ -105,7 +105,8 @@
     FOREACH_INDEX_LOOP;
 	FCALL;
 	FCALL_LIB; // library function call
-// 	FCALL_LIB_N_ELEMENTS; // N_ELEMENTS
+ 	FCALL_LIB_DIRECT; // direct call
+ 	FCALL_LIB_N_ELEMENTS; // N_ELEMENTS
 	FCALL_LIB_RETNEW; // library function call always return newly allocated data
     IF_ELSE;
 	KEYDECL;
diff -ruN --exclude CVS gdl-0.9.2/src/gdlc.i.g gdl/src/gdlc.i.g
--- gdl-0.9.2/src/gdlc.i.g	2011-11-07 16:38:21.000000000 -0700
+++ gdl/src/gdlc.i.g	2012-07-16 07:24:41.000000000 -0600
@@ -749,7 +749,8 @@
     }
 
     static EnvStackT& CallStack() { return callStack;} // the callstack
-    static EnvBaseT*  CallStackBack() { return callStack.back();} 
+//    static EnvBaseT*  CallStackBack() { return callStack.back();} 
+    static EnvUDT*  CallStackBack() { return callStack.back();} 
     
     std::string GetClearActualLine()
     {
@@ -1913,6 +1914,7 @@
                 aD->Root(structR); 
             }
 	}
+    return;
 //	_retTree = _t;
 }
     : #(ARRAYEXPR rP=l_indexable_expr aL=arrayindex_list)   
@@ -3353,11 +3355,13 @@
 // the environment is not on the callstack
 parameter_def [EnvBaseT* actEnv] 
 {
+    // as actEnv is not on the stack guard it here
     auto_ptr<EnvBaseT> guard(actEnv); 
 
     EnvBaseT* callerEnv = callStack.back();
     EnvBaseT* oldNewEnv = callerEnv->GetNewEnv();
-	callerEnv->SetNewEnv( actEnv);
+
+    callerEnv->SetNewEnv( actEnv);
 
     try{
 
@@ -3389,7 +3393,7 @@
                         while(_retTree != NULL) 
                             static_cast<ParameterNode*>(_retTree)->Parameter( actEnv);
                     }    
-                actEnv->Extra(); // expand _EXTRA        
+                actEnv->ResolveExtra(); // expand _EXTRA        
             }
     } 
     catch( GDLException& e)
@@ -3412,6 +3416,7 @@
             )
         )
 	;
+
 // the environment is not on the callstack
 // for library subroutines, their number of parameters is already checked in the compiler
 parameter_def_nocheck [EnvBaseT* actEnv] 
@@ -3420,7 +3425,8 @@
 
     EnvBaseT* callerEnv = callStack.back();
     EnvBaseT* oldNewEnv = callerEnv->GetNewEnv();
-	callerEnv->SetNewEnv( actEnv);
+
+    callerEnv->SetNewEnv( actEnv);
 
     try{
 
@@ -3433,7 +3439,7 @@
                 while(_retTree != NULL) 
                      static_cast<ParameterNode*>(_retTree)->Parameter( actEnv);
 
-                actEnv->Extra(); // expand _EXTRA        
+                actEnv->ResolveExtra(); // expand _EXTRA        
             }
     } 
     catch( GDLException& e)
diff -ruN --exclude CVS gdl-0.9.2/src/gdlc.tree.g gdl/src/gdlc.tree.g
--- gdl-0.9.2/src/gdlc.tree.g	2011-11-07 16:38:21.000000000 -0700
+++ gdl/src/gdlc.tree.g	2011-11-15 16:19:00.000000000 -0700
@@ -95,6 +95,7 @@
             lT == FCALL_LIB ||
 //            lT == FCALL_LIB_N_ELEMENTS ||
             lT == FCALL_LIB_RETNEW || 
+            lT == FCALL_LIB_DIRECT || 
             lT == MFCALL_LIB || 
             lT == MFCALL_LIB_RETNEW || 
             lT == MFCALL_PARENT_LIB ||
@@ -647,8 +648,11 @@
                         nParam = #para->GetNParam();
 
                     int libParam = libProList[i]->NPar();
+                    int libParamMin = libProList[i]->NParMin();
                     if( libParam != -1 && nParam > libParam)
                         throw GDLException(	p, libProList[i]->Name() + ": Too many arguments.");
+                    if( libParam != -1 && nParam < libParamMin)
+                        throw GDLException(	p, libProList[i]->Name() + ": Too few arguments.");
 
                     #p->setType(PCALL_LIB);
                     #p->setText("pcall_lib");
@@ -1316,13 +1320,21 @@
                             nParam = #el->GetNParam();
 
                         int libParam = libFunList[i]->NPar();
+                        int libParamMin = libFunList[i]->NParMin();
                         if( libParam != -1 && nParam > libParam)
                             throw GDLException(	aIn, libFunList[i]->Name() + ": Too many arguments.");
+                    if( libParam != -1 && nParam < libParamMin)
+                        throw GDLException(	aIn, libFunList[i]->Name() + ": Too few arguments.");
 
                         #id->SetLibFun( libFunList[i]);
                         if( libFunList[ i]->RetNew())
                             {
-                                #id->setType( FCALL_LIB_RETNEW);
+                                if( libFunList[ i]->Name() == "N_ELEMENTS")
+                                    #id->setType( FCALL_LIB_N_ELEMENTS);
+                                else if( libFunList[ i]->DirectCall())
+                                        #id->setType( FCALL_LIB_DIRECT);
+                                    else
+                                        #id->setType( FCALL_LIB_RETNEW);
                                 #arrayexpr_fn =
                                 #( id, el);
 //                              #([/*FCALL_LIB_RETNEW,"fcall_lib_retnew"],*/ id, el);
@@ -1460,12 +1472,19 @@
                         nParam = #p->GetNParam();
 
                     int libParam = libFunList[i]->NPar();
+                    int libParamMin = libFunList[i]->NParMin();
                     if( libParam != -1 && nParam > libParam)
                         throw GDLException(	f, libFunList[i]->Name() + ": Too many arguments.");
+                    if( libParam != -1 && nParam < libParamMin)
+                        throw GDLException(	f, libFunList[i]->Name() + ": Too few arguments.");
                     if( libFunList[ i]->RetNew())
                     {
-
-                        #f->setType(FCALL_LIB_RETNEW);
+                        if( libFunList[ i]->Name() == "N_ELEMENTS")
+                            #f->setType( FCALL_LIB_N_ELEMENTS);
+                        else if( libFunList[ i]->DirectCall())
+                                #f->setType( FCALL_LIB_DIRECT);
+                            else
+                                #f->setType(FCALL_LIB_RETNEW);
                         #f->setText(#id->getText());
                         #f->SetLibFun( libFunList[i]);
                         //                    #id->SetFunIx(i);
diff -ruN --exclude CVS gdl-0.9.2/src/gdlgstream.hpp gdl/src/gdlgstream.hpp
--- gdl-0.9.2/src/gdlgstream.hpp	2011-08-09 09:30:00.000000000 -0600
+++ gdl/src/gdlgstream.hpp	2012-01-02 14:20:38.000000000 -0700
@@ -36,26 +36,19 @@
 {
   void init(); // prevent plstream::init from being called directly
 	
-// 	static bool plstreamInitCalled;
-
 protected:
   bool valid;
 
 public:
-    GDLGStream( int nx, int ny, 
-		const char *driver, 
-		const char *file=NULL)
-	: plstream( nx, ny, driver, file)
-    , valid( true)
+  GDLGStream( int nx, int ny, const char *driver, const char *file=NULL)
+    : plstream( nx, ny, driver, file), valid( true)
   {
-//   std::cerr << "GDLGStream()" << std::endl;
     if (!checkPlplotDriver(driver))
       ThrowGDLException(std::string("PLplot installation lacks the requested driver: ") + driver);
   }
 
   virtual ~GDLGStream()
   {
-//   std::cerr << "~GDLGStream()" << std::endl;
 // 	plend();
   }
 
@@ -79,53 +72,38 @@
     const char **devnames = NULL;
 #endif
 
-	static vector<std::string> devNames;// = NULL;
+    static vector<std::string> devNames;
 
-// do only once
-if( devNames.empty())// == NULL)
-{
-    // acquireing a list of drivers from plPlot
-    for (int maxnumdevs = numdevs_plus_one;; numdevs_plus_one = maxnumdevs += 16)
+    // do only once
+    if( devNames.empty())
     {
+      // acquireing a list of drivers from plPlot
+      for (int maxnumdevs = numdevs_plus_one;; numdevs_plus_one = maxnumdevs += 16)
+      {
 #ifdef HAVE_OLDPLPLOT
-      devlongnames = static_cast<char**>(realloc(devlongnames, maxnumdevs * sizeof(char*)));
-      devnames = static_cast<char**>(realloc(devnames, maxnumdevs * sizeof(char*)));
+        devlongnames = static_cast<char**>(realloc(devlongnames, maxnumdevs * sizeof(char*)));
+        devnames = static_cast<char**>(realloc(devnames, maxnumdevs * sizeof(char*)));
 #else
-      devlongnames = static_cast<const char**>(realloc(devlongnames, maxnumdevs * sizeof(char*)));
-      devnames = static_cast<const char**>(realloc(devnames, maxnumdevs * sizeof(char*)));
+        devlongnames = static_cast<const char**>(realloc(devlongnames, maxnumdevs * sizeof(char*)));
+        devnames = static_cast<const char**>(realloc(devnames, maxnumdevs * sizeof(char*)));
 #endif
-      plgDevs(&devlongnames, &devnames, &numdevs_plus_one);
-      numdevs_plus_one++;
-      if (numdevs_plus_one < maxnumdevs) break;
-      else Message("The above PLPlot warning message, if any, can be ignored");
-    } 
-    free(devlongnames); // we do not need this information
-
-//     devNames = new std::vector<std::string>( numdevs_plus_one - 1);
-    for( int i = 0; i < numdevs_plus_one - 1; ++i)
-		devNames.push_back(std::string(devnames[ i]));
-    
-    free(devnames);
-}
+        plgDevs(&devlongnames, &devnames, &numdevs_plus_one);
+        numdevs_plus_one++;
+        if (numdevs_plus_one < maxnumdevs) break;
+        else Message("The above PLPlot warning message, if any, can be ignored");
+      } 
+      free(devlongnames); // we do not need this information
 
-// for debug
-std::vector<std::string> devnamesDbg = devNames;
+      for( int i = 0; i < numdevs_plus_one - 1; ++i)
+        devNames.push_back(std::string(devnames[ i]));
+    
+      free(devnames);
+    }
 
-return std::find( devNames.begin(), devNames.end(), std::string( driver)) != devNames.end();
+    // for debug
+    std::vector<std::string> devnamesDbg = devNames;
 
-//     checking if a given driver is in the list
-//     bool supported = false;
-//     for (int i = numdevs_plus_one - 1; i--;) 
-//     {
-// 		
-//       if (strcmp(driver, devnames[i]) == 0) 
-//       {
-//         supported = true;
-//         break;
-//       }
-//     }
-//    free(devnames);
-//     return supported;
+    return std::find( devNames.begin(), devNames.end(), std::string( driver)) != devNames.end();
   }
 
   static void SetErrorHandlers();
diff -ruN --exclude CVS gdl-0.9.2/src/GDLInterpreter.cpp gdl/src/GDLInterpreter.cpp
--- gdl-0.9.2/src/GDLInterpreter.cpp	2011-11-07 16:38:20.000000000 -0700
+++ gdl/src/GDLInterpreter.cpp	2012-07-16 07:21:15.000000000 -0600
@@ -2277,6 +2277,7 @@
 	aD->Root(structR); 
 	}
 		}
+	return;
 	//	_retTree = _t;
 	
 	
@@ -3843,11 +3844,13 @@
 ) {
 	ProgNodeP parameter_def_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	
+	// as actEnv is not on the stack guard it here
 	auto_ptr<EnvBaseT> guard(actEnv); 
 	
 	EnvBaseT* callerEnv = callStack.back();
 	EnvBaseT* oldNewEnv = callerEnv->GetNewEnv();
-		callerEnv->SetNewEnv( actEnv);
+	
+	callerEnv->SetNewEnv( actEnv);
 	
 	try{
 	
@@ -3879,7 +3882,7 @@
 	while(_retTree != NULL) 
 	static_cast<ParameterNode*>(_retTree)->Parameter( actEnv);
 	}    
-	actEnv->Extra(); // expand _EXTRA        
+	actEnv->ResolveExtra(); // expand _EXTRA        
 	}
 	} 
 	catch( GDLException& e)
@@ -5081,7 +5084,8 @@
 	
 	EnvBaseT* callerEnv = callStack.back();
 	EnvBaseT* oldNewEnv = callerEnv->GetNewEnv();
-		callerEnv->SetNewEnv( actEnv);
+	
+	callerEnv->SetNewEnv( actEnv);
 	
 	try{
 	
@@ -5094,7 +5098,7 @@
 	while(_retTree != NULL) 
 	static_cast<ParameterNode*>(_retTree)->Parameter( actEnv);
 	
-	actEnv->Extra(); // expand _EXTRA        
+	actEnv->ResolveExtra(); // expand _EXTRA        
 	}
 	} 
 	catch( GDLException& e)
@@ -5305,6 +5309,8 @@
 	"FOREACH_INDEX_LOOP",
 	"FCALL",
 	"FCALL_LIB",
+	"FCALL_LIB_DIRECT",
+	"FCALL_LIB_N_ELEMENTS",
 	"FCALL_LIB_RETNEW",
 	"IF_ELSE",
 	"KEYDECL",
@@ -5500,14 +5506,14 @@
 	0
 };
 
-const unsigned long GDLInterpreter::_tokenSet_0_data_[] = { 3232760224UL, 939754047UL, 35706880UL, 18884608UL, 6UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLInterpreter::_tokenSet_0_data_[] = { 3232760224UL, 3759015999UL, 142827520UL, 75538432UL, 24UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // ASSIGN ASSIGN_REPLACE ASSIGN_ARRAYEXPR_MFCALL BLOCK BREAK CONTINUE "for" 
 // FOR_STEP "foreach" FOREACH_INDEX FOR_LOOP FOR_STEP_LOOP FOREACH_LOOP 
 // FOREACH_INDEX_LOOP IF_ELSE LABEL MPCALL MPCALL_PARENT ON_IOERROR_NULL 
 // PCALL PCALL_LIB "repeat" REPEAT_LOOP RETF RETP "while" "case" "goto" 
 // "if" "on_ioerror" "switch" DEC INC 
 const antlr::BitSet GDLInterpreter::_tokenSet_0(_tokenSet_0_data_,12);
-const unsigned long GDLInterpreter::_tokenSet_1_data_[] = { 738853792UL, 103023040UL, 1769478UL, 0UL, 6UL, 0UL, 524416UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLInterpreter::_tokenSet_1_data_[] = { 738853792UL, 412091584UL, 7077912UL, 0UL, 24UL, 0UL, 2097664UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // ASSIGN ASSIGN_REPLACE ASSIGN_ARRAYEXPR_MFCALL ARRAYDEF ARRAYEXPR ARRAYEXPR_MFCALL 
 // CONSTANT DEREF EXPR FCALL FCALL_LIB FCALL_LIB_RETNEW MFCALL MFCALL_PARENT 
 // NSTRUC NSTRUC_REF POSTDEC POSTINC STRUC SYSVAR VAR VARPTR DEC INC DOT 
diff -ruN --exclude CVS gdl-0.9.2/src/GDLInterpreter.hpp gdl/src/GDLInterpreter.hpp
--- gdl-0.9.2/src/GDLInterpreter.hpp	2011-11-07 16:38:20.000000000 -0700
+++ gdl/src/GDLInterpreter.hpp	2011-12-03 07:28:36.000000000 -0700
@@ -696,7 +696,8 @@
     }
 
     static EnvStackT& CallStack() { return callStack;} // the callstack
-    static EnvBaseT*  CallStackBack() { return callStack.back();} 
+//    static EnvBaseT*  CallStackBack() { return callStack.back();} 
+    static EnvUDT*  CallStackBack() { return callStack.back();} 
     
     std::string GetClearActualLine()
     {
@@ -818,10 +819,10 @@
 private:
 	static const char* tokenNames[];
 #ifndef NO_STATIC_CONSTS
-	static const int NUM_TOKENS = 232;
+	static const int NUM_TOKENS = 234;
 #else
 	enum {
-		NUM_TOKENS = 232
+		NUM_TOKENS = 234
 	};
 #endif
 	
diff -ruN --exclude CVS gdl-0.9.2/src/GDLInterpreterTokenTypes.hpp gdl/src/GDLInterpreterTokenTypes.hpp
--- gdl-0.9.2/src/GDLInterpreterTokenTypes.hpp	2011-11-07 16:38:20.000000000 -0700
+++ gdl/src/GDLInterpreterTokenTypes.hpp	2011-11-15 16:19:00.000000000 -0700
@@ -48,198 +48,200 @@
 		FOREACH_INDEX_LOOP = 37,
 		FCALL = 38,
 		FCALL_LIB = 39,
-		FCALL_LIB_RETNEW = 40,
-		IF_ELSE = 41,
-		KEYDECL = 42,
-		KEYDEF = 43,
-		KEYDEF_REF = 44,
-		KEYDEF_REF_CHECK = 45,
-		KEYDEF_REF_EXPR = 46,
-		LABEL = 47,
-		MPCALL = 48,
-		MPCALL_PARENT = 49,
-		MFCALL = 50,
-		MFCALL_LIB = 51,
-		MFCALL_LIB_RETNEW = 52,
-		MFCALL_PARENT = 53,
-		MFCALL_PARENT_LIB = 54,
-		MFCALL_PARENT_LIB_RETNEW = 55,
-		NOP = 56,
-		NSTRUC = 57,
-		NSTRUC_REF = 58,
-		ON_IOERROR_NULL = 59,
-		PCALL = 60,
-		PCALL_LIB = 61,
-		PARADECL = 62,
-		PARAEXPR = 63,
-		PARAEXPR_VN = 64,
-		POSTDEC = 65,
-		POSTINC = 66,
-		DECSTATEMENT = 67,
-		INCSTATEMENT = 68,
-		REF = 69,
-		REF_VN = 70,
-		REF_CHECK = 71,
-		REF_CHECK_VN = 72,
-		REF_EXPR = 73,
-		REF_EXPR_VN = 74,
-		REPEAT = 75,
-		REPEAT_LOOP = 76,
-		RETURN = 77,
-		RETF = 78,
-		RETP = 79,
-		STRUC = 80,
-		SYSVAR = 81,
-		UMINUS = 82,
-		VAR = 83,
-		VARPTR = 84,
-		WHILE = 85,
-		IDENTIFIER = 86,
-		AND_OP = 87,
-		BEGIN = 88,
-		CASE = 89,
-		COMMON = 90,
-		COMPILE_OPT = 91,
-		DO = 92,
-		ELSE = 93,
-		END = 94,
-		ENDCASE = 95,
-		ENDELSE = 96,
-		ENDFOR = 97,
-		ENDFOREACH = 98,
-		ENDIF = 99,
-		ENDREP = 100,
-		ENDSWITCH = 101,
-		ENDWHILE = 102,
-		EQ_OP = 103,
-		FORWARD = 104,
-		FUNCTION = 105,
-		GE_OP = 106,
-		GOTO = 107,
-		GT_OP = 108,
-		IF = 109,
-		INHERITS = 110,
-		LE_OP = 111,
-		LT_OP = 112,
-		MOD_OP = 113,
-		NE_OP = 114,
-		NOT_OP = 115,
-		OF = 116,
-		ON_IOERROR = 117,
-		OR_OP = 118,
-		PRO = 119,
-		SWITCH = 120,
-		THEN = 121,
-		UNTIL = 122,
-		XOR_OP = 123,
-		METHOD = 124,
-		COMMA = 125,
-		COLON = 126,
-		END_U = 127,
-		EQUAL = 128,
-		DEC = 129,
-		INC = 130,
-		AND_OP_EQ = 131,
-		ASTERIX_EQ = 132,
-		EQ_OP_EQ = 133,
-		GE_OP_EQ = 134,
-		GTMARK_EQ = 135,
-		GT_OP_EQ = 136,
-		LE_OP_EQ = 137,
-		LTMARK_EQ = 138,
-		LT_OP_EQ = 139,
-		MATRIX_OP1_EQ = 140,
-		MATRIX_OP2_EQ = 141,
-		MINUS_EQ = 142,
-		MOD_OP_EQ = 143,
-		NE_OP_EQ = 144,
-		OR_OP_EQ = 145,
-		PLUS_EQ = 146,
-		POW_EQ = 147,
-		SLASH_EQ = 148,
-		XOR_OP_EQ = 149,
-		MEMBER = 150,
-		LBRACE = 151,
-		RBRACE = 152,
-		SLASH = 153,
-		LSQUARE = 154,
-		RSQUARE = 155,
-		SYSVARNAME = 156,
-		EXCLAMATION = 157,
-		LCURLY = 158,
-		RCURLY = 159,
-		CONSTANT_HEX_BYTE = 160,
-		CONSTANT_HEX_LONG = 161,
-		CONSTANT_HEX_LONG64 = 162,
-		CONSTANT_HEX_INT = 163,
-		CONSTANT_HEX_I = 164,
-		CONSTANT_HEX_ULONG = 165,
-		CONSTANT_HEX_ULONG64 = 166,
-		CONSTANT_HEX_UI = 167,
-		CONSTANT_HEX_UINT = 168,
-		CONSTANT_BYTE = 169,
-		CONSTANT_LONG = 170,
-		CONSTANT_LONG64 = 171,
-		CONSTANT_INT = 172,
-		CONSTANT_I = 173,
-		CONSTANT_ULONG = 174,
-		CONSTANT_ULONG64 = 175,
-		CONSTANT_UI = 176,
-		CONSTANT_UINT = 177,
-		CONSTANT_OCT_BYTE = 178,
-		CONSTANT_OCT_LONG = 179,
-		CONSTANT_OCT_LONG64 = 180,
-		CONSTANT_OCT_INT = 181,
-		CONSTANT_OCT_I = 182,
-		CONSTANT_OCT_ULONG = 183,
-		CONSTANT_OCT_ULONG64 = 184,
-		CONSTANT_OCT_UI = 185,
-		CONSTANT_OCT_UINT = 186,
-		CONSTANT_FLOAT = 187,
-		CONSTANT_DOUBLE = 188,
-		CONSTANT_BIN_BYTE = 189,
-		CONSTANT_BIN_LONG = 190,
-		CONSTANT_BIN_LONG64 = 191,
-		CONSTANT_BIN_INT = 192,
-		CONSTANT_BIN_I = 193,
-		CONSTANT_BIN_ULONG = 194,
-		CONSTANT_BIN_ULONG64 = 195,
-		CONSTANT_BIN_UI = 196,
-		CONSTANT_BIN_UINT = 197,
-		ASTERIX = 198,
-		DOT = 199,
-		STRING_LITERAL = 200,
-		POW = 201,
-		MATRIX_OP1 = 202,
-		MATRIX_OP2 = 203,
-		PLUS = 204,
-		MINUS = 205,
-		LTMARK = 206,
-		GTMARK = 207,
-		LOG_NEG = 208,
-		LOG_AND = 209,
-		LOG_OR = 210,
-		QUESTION = 211,
-		STRING = 212,
-		INCLUDE = 213,
-		EOL = 214,
-		W = 215,
-		D = 216,
-		L = 217,
-		H = 218,
-		O = 219,
-		B = 220,
-		EXP = 221,
-		DBL_E = 222,
-		DBL = 223,
-		CONSTANT_OR_STRING_LITERAL = 224,
-		COMMENT = 225,
-		END_MARKER = 226,
-		WHITESPACE = 227,
-		SKIP_LINES = 228,
-		CONT_STATEMENT = 229,
-		END_OF_LINE = 230,
-		MAX_TOKEN_NUMBER = 231,
+		FCALL_LIB_DIRECT = 40,
+		FCALL_LIB_N_ELEMENTS = 41,
+		FCALL_LIB_RETNEW = 42,
+		IF_ELSE = 43,
+		KEYDECL = 44,
+		KEYDEF = 45,
+		KEYDEF_REF = 46,
+		KEYDEF_REF_CHECK = 47,
+		KEYDEF_REF_EXPR = 48,
+		LABEL = 49,
+		MPCALL = 50,
+		MPCALL_PARENT = 51,
+		MFCALL = 52,
+		MFCALL_LIB = 53,
+		MFCALL_LIB_RETNEW = 54,
+		MFCALL_PARENT = 55,
+		MFCALL_PARENT_LIB = 56,
+		MFCALL_PARENT_LIB_RETNEW = 57,
+		NOP = 58,
+		NSTRUC = 59,
+		NSTRUC_REF = 60,
+		ON_IOERROR_NULL = 61,
+		PCALL = 62,
+		PCALL_LIB = 63,
+		PARADECL = 64,
+		PARAEXPR = 65,
+		PARAEXPR_VN = 66,
+		POSTDEC = 67,
+		POSTINC = 68,
+		DECSTATEMENT = 69,
+		INCSTATEMENT = 70,
+		REF = 71,
+		REF_VN = 72,
+		REF_CHECK = 73,
+		REF_CHECK_VN = 74,
+		REF_EXPR = 75,
+		REF_EXPR_VN = 76,
+		REPEAT = 77,
+		REPEAT_LOOP = 78,
+		RETURN = 79,
+		RETF = 80,
+		RETP = 81,
+		STRUC = 82,
+		SYSVAR = 83,
+		UMINUS = 84,
+		VAR = 85,
+		VARPTR = 86,
+		WHILE = 87,
+		IDENTIFIER = 88,
+		AND_OP = 89,
+		BEGIN = 90,
+		CASE = 91,
+		COMMON = 92,
+		COMPILE_OPT = 93,
+		DO = 94,
+		ELSE = 95,
+		END = 96,
+		ENDCASE = 97,
+		ENDELSE = 98,
+		ENDFOR = 99,
+		ENDFOREACH = 100,
+		ENDIF = 101,
+		ENDREP = 102,
+		ENDSWITCH = 103,
+		ENDWHILE = 104,
+		EQ_OP = 105,
+		FORWARD = 106,
+		FUNCTION = 107,
+		GE_OP = 108,
+		GOTO = 109,
+		GT_OP = 110,
+		IF = 111,
+		INHERITS = 112,
+		LE_OP = 113,
+		LT_OP = 114,
+		MOD_OP = 115,
+		NE_OP = 116,
+		NOT_OP = 117,
+		OF = 118,
+		ON_IOERROR = 119,
+		OR_OP = 120,
+		PRO = 121,
+		SWITCH = 122,
+		THEN = 123,
+		UNTIL = 124,
+		XOR_OP = 125,
+		METHOD = 126,
+		COMMA = 127,
+		COLON = 128,
+		END_U = 129,
+		EQUAL = 130,
+		DEC = 131,
+		INC = 132,
+		AND_OP_EQ = 133,
+		ASTERIX_EQ = 134,
+		EQ_OP_EQ = 135,
+		GE_OP_EQ = 136,
+		GTMARK_EQ = 137,
+		GT_OP_EQ = 138,
+		LE_OP_EQ = 139,
+		LTMARK_EQ = 140,
+		LT_OP_EQ = 141,
+		MATRIX_OP1_EQ = 142,
+		MATRIX_OP2_EQ = 143,
+		MINUS_EQ = 144,
+		MOD_OP_EQ = 145,
+		NE_OP_EQ = 146,
+		OR_OP_EQ = 147,
+		PLUS_EQ = 148,
+		POW_EQ = 149,
+		SLASH_EQ = 150,
+		XOR_OP_EQ = 151,
+		MEMBER = 152,
+		LBRACE = 153,
+		RBRACE = 154,
+		SLASH = 155,
+		LSQUARE = 156,
+		RSQUARE = 157,
+		SYSVARNAME = 158,
+		EXCLAMATION = 159,
+		LCURLY = 160,
+		RCURLY = 161,
+		CONSTANT_HEX_BYTE = 162,
+		CONSTANT_HEX_LONG = 163,
+		CONSTANT_HEX_LONG64 = 164,
+		CONSTANT_HEX_INT = 165,
+		CONSTANT_HEX_I = 166,
+		CONSTANT_HEX_ULONG = 167,
+		CONSTANT_HEX_ULONG64 = 168,
+		CONSTANT_HEX_UI = 169,
+		CONSTANT_HEX_UINT = 170,
+		CONSTANT_BYTE = 171,
+		CONSTANT_LONG = 172,
+		CONSTANT_LONG64 = 173,
+		CONSTANT_INT = 174,
+		CONSTANT_I = 175,
+		CONSTANT_ULONG = 176,
+		CONSTANT_ULONG64 = 177,
+		CONSTANT_UI = 178,
+		CONSTANT_UINT = 179,
+		CONSTANT_OCT_BYTE = 180,
+		CONSTANT_OCT_LONG = 181,
+		CONSTANT_OCT_LONG64 = 182,
+		CONSTANT_OCT_INT = 183,
+		CONSTANT_OCT_I = 184,
+		CONSTANT_OCT_ULONG = 185,
+		CONSTANT_OCT_ULONG64 = 186,
+		CONSTANT_OCT_UI = 187,
+		CONSTANT_OCT_UINT = 188,
+		CONSTANT_FLOAT = 189,
+		CONSTANT_DOUBLE = 190,
+		CONSTANT_BIN_BYTE = 191,
+		CONSTANT_BIN_LONG = 192,
+		CONSTANT_BIN_LONG64 = 193,
+		CONSTANT_BIN_INT = 194,
+		CONSTANT_BIN_I = 195,
+		CONSTANT_BIN_ULONG = 196,
+		CONSTANT_BIN_ULONG64 = 197,
+		CONSTANT_BIN_UI = 198,
+		CONSTANT_BIN_UINT = 199,
+		ASTERIX = 200,
+		DOT = 201,
+		STRING_LITERAL = 202,
+		POW = 203,
+		MATRIX_OP1 = 204,
+		MATRIX_OP2 = 205,
+		PLUS = 206,
+		MINUS = 207,
+		LTMARK = 208,
+		GTMARK = 209,
+		LOG_NEG = 210,
+		LOG_AND = 211,
+		LOG_OR = 212,
+		QUESTION = 213,
+		STRING = 214,
+		INCLUDE = 215,
+		EOL = 216,
+		W = 217,
+		D = 218,
+		L = 219,
+		H = 220,
+		O = 221,
+		B = 222,
+		EXP = 223,
+		DBL_E = 224,
+		DBL = 225,
+		CONSTANT_OR_STRING_LITERAL = 226,
+		COMMENT = 227,
+		END_MARKER = 228,
+		WHITESPACE = 229,
+		SKIP_LINES = 230,
+		CONT_STATEMENT = 231,
+		END_OF_LINE = 232,
+		MAX_TOKEN_NUMBER = 233,
 		NULL_TREE_LOOKAHEAD = 3
 	};
 #ifdef __cplusplus
diff -ruN --exclude CVS gdl-0.9.2/src/GDLInterpreterTokenTypes.txt gdl/src/GDLInterpreterTokenTypes.txt
--- gdl-0.9.2/src/GDLInterpreterTokenTypes.txt	2011-11-07 16:38:20.000000000 -0700
+++ gdl/src/GDLInterpreterTokenTypes.txt	2011-11-15 16:19:00.000000000 -0700
@@ -36,195 +36,197 @@
 FOREACH_INDEX_LOOP=37
 FCALL=38
 FCALL_LIB=39
-FCALL_LIB_RETNEW=40
-IF_ELSE=41
-KEYDECL=42
-KEYDEF=43
-KEYDEF_REF=44
-KEYDEF_REF_CHECK=45
-KEYDEF_REF_EXPR=46
-LABEL=47
-MPCALL=48
-MPCALL_PARENT=49
-MFCALL=50
-MFCALL_LIB=51
-MFCALL_LIB_RETNEW=52
-MFCALL_PARENT=53
-MFCALL_PARENT_LIB=54
-MFCALL_PARENT_LIB_RETNEW=55
-NOP=56
-NSTRUC=57
-NSTRUC_REF=58
-ON_IOERROR_NULL=59
-PCALL=60
-PCALL_LIB=61
-PARADECL=62
-PARAEXPR=63
-PARAEXPR_VN=64
-POSTDEC=65
-POSTINC=66
-DECSTATEMENT=67
-INCSTATEMENT=68
-REF=69
-REF_VN=70
-REF_CHECK=71
-REF_CHECK_VN=72
-REF_EXPR=73
-REF_EXPR_VN=74
-REPEAT="repeat"=75
-REPEAT_LOOP=76
-RETURN=77
-RETF=78
-RETP=79
-STRUC=80
-SYSVAR=81
-UMINUS=82
-VAR=83
-VARPTR=84
-WHILE="while"=85
-IDENTIFIER=86
-AND_OP="and"=87
-BEGIN="begin"=88
-CASE="case"=89
-COMMON="common"=90
-COMPILE_OPT="compile_opt"=91
-DO="do"=92
-ELSE="else"=93
-END="end"=94
-ENDCASE="endcase"=95
-ENDELSE="endelse"=96
-ENDFOR="endfor"=97
-ENDFOREACH="endforeach"=98
-ENDIF="endif"=99
-ENDREP="endrep"=100
-ENDSWITCH="endswitch"=101
-ENDWHILE="endwhile"=102
-EQ_OP="eq"=103
-FORWARD="forward_function"=104
-FUNCTION="function"=105
-GE_OP="ge"=106
-GOTO="goto"=107
-GT_OP="gt"=108
-IF="if"=109
-INHERITS="inherits"=110
-LE_OP="le"=111
-LT_OP="lt"=112
-MOD_OP="mod"=113
-NE_OP="ne"=114
-NOT_OP="not"=115
-OF="of"=116
-ON_IOERROR="on_ioerror"=117
-OR_OP="or"=118
-PRO="pro"=119
-SWITCH="switch"=120
-THEN="then"=121
-UNTIL="until"=122
-XOR_OP="xor"=123
-METHOD=124
-COMMA=125
-COLON=126
-END_U=127
-EQUAL=128
-DEC=129
-INC=130
-AND_OP_EQ=131
-ASTERIX_EQ=132
-EQ_OP_EQ=133
-GE_OP_EQ=134
-GTMARK_EQ=135
-GT_OP_EQ=136
-LE_OP_EQ=137
-LTMARK_EQ=138
-LT_OP_EQ=139
-MATRIX_OP1_EQ=140
-MATRIX_OP2_EQ=141
-MINUS_EQ=142
-MOD_OP_EQ=143
-NE_OP_EQ=144
-OR_OP_EQ=145
-PLUS_EQ=146
-POW_EQ=147
-SLASH_EQ=148
-XOR_OP_EQ=149
-MEMBER=150
-LBRACE=151
-RBRACE=152
-SLASH=153
-LSQUARE=154
-RSQUARE=155
-SYSVARNAME=156
-EXCLAMATION=157
-LCURLY=158
-RCURLY=159
-CONSTANT_HEX_BYTE=160
-CONSTANT_HEX_LONG=161
-CONSTANT_HEX_LONG64=162
-CONSTANT_HEX_INT=163
-CONSTANT_HEX_I=164
-CONSTANT_HEX_ULONG=165
-CONSTANT_HEX_ULONG64=166
-CONSTANT_HEX_UI=167
-CONSTANT_HEX_UINT=168
-CONSTANT_BYTE=169
-CONSTANT_LONG=170
-CONSTANT_LONG64=171
-CONSTANT_INT=172
-CONSTANT_I=173
-CONSTANT_ULONG=174
-CONSTANT_ULONG64=175
-CONSTANT_UI=176
-CONSTANT_UINT=177
-CONSTANT_OCT_BYTE=178
-CONSTANT_OCT_LONG=179
-CONSTANT_OCT_LONG64=180
-CONSTANT_OCT_INT=181
-CONSTANT_OCT_I=182
-CONSTANT_OCT_ULONG=183
-CONSTANT_OCT_ULONG64=184
-CONSTANT_OCT_UI=185
-CONSTANT_OCT_UINT=186
-CONSTANT_FLOAT=187
-CONSTANT_DOUBLE=188
-CONSTANT_BIN_BYTE=189
-CONSTANT_BIN_LONG=190
-CONSTANT_BIN_LONG64=191
-CONSTANT_BIN_INT=192
-CONSTANT_BIN_I=193
-CONSTANT_BIN_ULONG=194
-CONSTANT_BIN_ULONG64=195
-CONSTANT_BIN_UI=196
-CONSTANT_BIN_UINT=197
-ASTERIX=198
-DOT=199
-STRING_LITERAL=200
-POW=201
-MATRIX_OP1=202
-MATRIX_OP2=203
-PLUS=204
-MINUS=205
-LTMARK=206
-GTMARK=207
-LOG_NEG=208
-LOG_AND=209
-LOG_OR=210
-QUESTION=211
-STRING=212
-INCLUDE=213
-EOL=214
-W=215
-D=216
-L=217
-H=218
-O=219
-B=220
-EXP=221
-DBL_E=222
-DBL=223
-CONSTANT_OR_STRING_LITERAL=224
-COMMENT=225
-END_MARKER=226
-WHITESPACE=227
-SKIP_LINES=228
-CONT_STATEMENT=229
-END_OF_LINE=230
-MAX_TOKEN_NUMBER=231
+FCALL_LIB_DIRECT=40
+FCALL_LIB_N_ELEMENTS=41
+FCALL_LIB_RETNEW=42
+IF_ELSE=43
+KEYDECL=44
+KEYDEF=45
+KEYDEF_REF=46
+KEYDEF_REF_CHECK=47
+KEYDEF_REF_EXPR=48
+LABEL=49
+MPCALL=50
+MPCALL_PARENT=51
+MFCALL=52
+MFCALL_LIB=53
+MFCALL_LIB_RETNEW=54
+MFCALL_PARENT=55
+MFCALL_PARENT_LIB=56
+MFCALL_PARENT_LIB_RETNEW=57
+NOP=58
+NSTRUC=59
+NSTRUC_REF=60
+ON_IOERROR_NULL=61
+PCALL=62
+PCALL_LIB=63
+PARADECL=64
+PARAEXPR=65
+PARAEXPR_VN=66
+POSTDEC=67
+POSTINC=68
+DECSTATEMENT=69
+INCSTATEMENT=70
+REF=71
+REF_VN=72
+REF_CHECK=73
+REF_CHECK_VN=74
+REF_EXPR=75
+REF_EXPR_VN=76
+REPEAT="repeat"=77
+REPEAT_LOOP=78
+RETURN=79
+RETF=80
+RETP=81
+STRUC=82
+SYSVAR=83
+UMINUS=84
+VAR=85
+VARPTR=86
+WHILE="while"=87
+IDENTIFIER=88
+AND_OP="and"=89
+BEGIN="begin"=90
+CASE="case"=91
+COMMON="common"=92
+COMPILE_OPT="compile_opt"=93
+DO="do"=94
+ELSE="else"=95
+END="end"=96
+ENDCASE="endcase"=97
+ENDELSE="endelse"=98
+ENDFOR="endfor"=99
+ENDFOREACH="endforeach"=100
+ENDIF="endif"=101
+ENDREP="endrep"=102
+ENDSWITCH="endswitch"=103
+ENDWHILE="endwhile"=104
+EQ_OP="eq"=105
+FORWARD="forward_function"=106
+FUNCTION="function"=107
+GE_OP="ge"=108
+GOTO="goto"=109
+GT_OP="gt"=110
+IF="if"=111
+INHERITS="inherits"=112
+LE_OP="le"=113
+LT_OP="lt"=114
+MOD_OP="mod"=115
+NE_OP="ne"=116
+NOT_OP="not"=117
+OF="of"=118
+ON_IOERROR="on_ioerror"=119
+OR_OP="or"=120
+PRO="pro"=121
+SWITCH="switch"=122
+THEN="then"=123
+UNTIL="until"=124
+XOR_OP="xor"=125
+METHOD=126
+COMMA=127
+COLON=128
+END_U=129
+EQUAL=130
+DEC=131
+INC=132
+AND_OP_EQ=133
+ASTERIX_EQ=134
+EQ_OP_EQ=135
+GE_OP_EQ=136
+GTMARK_EQ=137
+GT_OP_EQ=138
+LE_OP_EQ=139
+LTMARK_EQ=140
+LT_OP_EQ=141
+MATRIX_OP1_EQ=142
+MATRIX_OP2_EQ=143
+MINUS_EQ=144
+MOD_OP_EQ=145
+NE_OP_EQ=146
+OR_OP_EQ=147
+PLUS_EQ=148
+POW_EQ=149
+SLASH_EQ=150
+XOR_OP_EQ=151
+MEMBER=152
+LBRACE=153
+RBRACE=154
+SLASH=155
+LSQUARE=156
+RSQUARE=157
+SYSVARNAME=158
+EXCLAMATION=159
+LCURLY=160
+RCURLY=161
+CONSTANT_HEX_BYTE=162
+CONSTANT_HEX_LONG=163
+CONSTANT_HEX_LONG64=164
+CONSTANT_HEX_INT=165
+CONSTANT_HEX_I=166
+CONSTANT_HEX_ULONG=167
+CONSTANT_HEX_ULONG64=168
+CONSTANT_HEX_UI=169
+CONSTANT_HEX_UINT=170
+CONSTANT_BYTE=171
+CONSTANT_LONG=172
+CONSTANT_LONG64=173
+CONSTANT_INT=174
+CONSTANT_I=175
+CONSTANT_ULONG=176
+CONSTANT_ULONG64=177
+CONSTANT_UI=178
+CONSTANT_UINT=179
+CONSTANT_OCT_BYTE=180
+CONSTANT_OCT_LONG=181
+CONSTANT_OCT_LONG64=182
+CONSTANT_OCT_INT=183
+CONSTANT_OCT_I=184
+CONSTANT_OCT_ULONG=185
+CONSTANT_OCT_ULONG64=186
+CONSTANT_OCT_UI=187
+CONSTANT_OCT_UINT=188
+CONSTANT_FLOAT=189
+CONSTANT_DOUBLE=190
+CONSTANT_BIN_BYTE=191
+CONSTANT_BIN_LONG=192
+CONSTANT_BIN_LONG64=193
+CONSTANT_BIN_INT=194
+CONSTANT_BIN_I=195
+CONSTANT_BIN_ULONG=196
+CONSTANT_BIN_ULONG64=197
+CONSTANT_BIN_UI=198
+CONSTANT_BIN_UINT=199
+ASTERIX=200
+DOT=201
+STRING_LITERAL=202
+POW=203
+MATRIX_OP1=204
+MATRIX_OP2=205
+PLUS=206
+MINUS=207
+LTMARK=208
+GTMARK=209
+LOG_NEG=210
+LOG_AND=211
+LOG_OR=212
+QUESTION=213
+STRING=214
+INCLUDE=215
+EOL=216
+W=217
+D=218
+L=219
+H=220
+O=221
+B=222
+EXP=223
+DBL_E=224
+DBL=225
+CONSTANT_OR_STRING_LITERAL=226
+COMMENT=227
+END_MARKER=228
+WHITESPACE=229
+SKIP_LINES=230
+CONT_STATEMENT=231
+END_OF_LINE=232
+MAX_TOKEN_NUMBER=233
diff -ruN --exclude CVS gdl-0.9.2/src/GDLLexer.cpp gdl/src/GDLLexer.cpp
--- gdl-0.9.2/src/GDLLexer.cpp	2011-11-07 16:38:20.000000000 -0700
+++ gdl/src/GDLLexer.cpp	2011-11-15 16:19:00.000000000 -0700
@@ -36,47 +36,47 @@
 
 void GDLLexer::initLiterals()
 {
-	literals["endcase"] = 95;
-	literals["case"] = 89;
-	literals["repeat"] = 75;
-	literals["endforeach"] = 98;
-	literals["ne"] = 114;
-	literals["end"] = 94;
-	literals["le"] = 111;
-	literals["then"] = 121;
-	literals["begin"] = 88;
-	literals["endswitch"] = 101;
-	literals["and"] = 87;
-	literals["endrep"] = 100;
-	literals["not"] = 115;
-	literals["on_ioerror"] = 117;
-	literals["mod"] = 113;
-	literals["do"] = 92;
-	literals["function"] = 105;
-	literals["endfor"] = 97;
-	literals["gt"] = 108;
-	literals["inherits"] = 110;
-	literals["of"] = 116;
-	literals["or"] = 118;
-	literals["if"] = 109;
-	literals["pro"] = 119;
-	literals["xor"] = 123;
-	literals["compile_opt"] = 91;
-	literals["ge"] = 106;
-	literals["goto"] = 107;
+	literals["endcase"] = 97;
+	literals["case"] = 91;
+	literals["repeat"] = 77;
+	literals["endforeach"] = 100;
+	literals["ne"] = 116;
+	literals["end"] = 96;
+	literals["le"] = 113;
+	literals["then"] = 123;
+	literals["begin"] = 90;
+	literals["endswitch"] = 103;
+	literals["and"] = 89;
+	literals["endrep"] = 102;
+	literals["not"] = 117;
+	literals["on_ioerror"] = 119;
+	literals["mod"] = 115;
+	literals["do"] = 94;
+	literals["function"] = 107;
+	literals["endfor"] = 99;
+	literals["gt"] = 110;
+	literals["inherits"] = 112;
+	literals["of"] = 118;
+	literals["or"] = 120;
+	literals["if"] = 111;
+	literals["pro"] = 121;
+	literals["xor"] = 125;
+	literals["compile_opt"] = 93;
+	literals["ge"] = 108;
+	literals["goto"] = 109;
 	literals["for"] = 30;
-	literals["eq"] = 103;
-	literals["forward_function"] = 104;
+	literals["eq"] = 105;
+	literals["forward_function"] = 106;
 	literals["foreach"] = 32;
-	literals["endelse"] = 96;
-	literals["until"] = 122;
-	literals["else"] = 93;
-	literals["lt"] = 112;
-	literals["endwhile"] = 102;
-	literals["switch"] = 120;
-	literals["common"] = 90;
-	literals["endif"] = 99;
-	literals["while"] = 85;
+	literals["endelse"] = 98;
+	literals["until"] = 124;
+	literals["else"] = 95;
+	literals["lt"] = 114;
+	literals["endwhile"] = 104;
+	literals["switch"] = 122;
+	literals["common"] = 92;
+	literals["endif"] = 101;
+	literals["while"] = 87;
 }
 
 antlr::RefToken GDLLexer::nextToken()
@@ -3618,7 +3618,7 @@
 // 0xbc 0xbd 0xbe 0xbf 0xc0 0xc1 0xc2 0xc3 0xc4 0xc5 0xc6 0xc7 0xc8 0xc9 
 // 0xca 0xcb 0xcc 0xcd 0xce 0xcf 0xd0 0xd1 0xd2 0xd3 0xd4 0xd5 0xd6 0xd7 
 // 0xd8 0xd9 0xda 0xdb 0xdc 0xdd 0xde 0xdf 0xe0 0xe1 0xe2 0xe3 0xe4 0xe5 
-// 0xe6 0xe7 
+// 0xe6 0xe7 0xe8 0xe9 
 const antlr::BitSet GDLLexer::_tokenSet_2(_tokenSet_2_data_,16);
 const unsigned long GDLLexer::_tokenSet_3_data_[] = { 0UL, 67053568UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // + - 0 1 2 3 4 5 6 7 8 9 
@@ -3654,7 +3654,7 @@
 // 0xbd 0xbe 0xbf 0xc0 0xc1 0xc2 0xc3 0xc4 0xc5 0xc6 0xc7 0xc8 0xc9 0xca 
 // 0xcb 0xcc 0xcd 0xce 0xcf 0xd0 0xd1 0xd2 0xd3 0xd4 0xd5 0xd6 0xd7 0xd8 
 // 0xd9 0xda 0xdb 0xdc 0xdd 0xde 0xdf 0xe0 0xe1 0xe2 0xe3 0xe4 0xe5 0xe6 
-// 0xe7 
+// 0xe7 0xe8 0xe9 
 const antlr::BitSet GDLLexer::_tokenSet_10(_tokenSet_10_data_,16);
 const unsigned long GDLLexer::_tokenSet_11_data_[] = { 4294958072UL, 4294967167UL, 4294967295UL, 4294967295UL, 4294967295UL, 4294967295UL, 4294967295UL, 4294967295UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // 0x3 0x4 0x5 0x6 0x7 0x8 0x9 0xb 0xc 0xe 0xf 0x10 0x11 0x12 0x13 0x14 
@@ -3669,6 +3669,6 @@
 // 0xbd 0xbe 0xbf 0xc0 0xc1 0xc2 0xc3 0xc4 0xc5 0xc6 0xc7 0xc8 0xc9 0xca 
 // 0xcb 0xcc 0xcd 0xce 0xcf 0xd0 0xd1 0xd2 0xd3 0xd4 0xd5 0xd6 0xd7 0xd8 
 // 0xd9 0xda 0xdb 0xdc 0xdd 0xde 0xdf 0xe0 0xe1 0xe2 0xe3 0xe4 0xe5 0xe6 
-// 0xe7 
+// 0xe7 0xe8 0xe9 
 const antlr::BitSet GDLLexer::_tokenSet_11(_tokenSet_11_data_,16);
 
diff -ruN --exclude CVS gdl-0.9.2/src/GDLParser.cpp gdl/src/GDLParser.cpp
--- gdl-0.9.2/src/GDLParser.cpp	2011-11-07 16:38:20.000000000 -0700
+++ gdl/src/GDLParser.cpp	2011-11-15 16:19:00.000000000 -0700
@@ -9302,7 +9302,7 @@
 
 void GDLParser::initializeASTFactory( antlr::ASTFactory& factory )
 {
-	factory.setMaxNodeType(231);
+	factory.setMaxNodeType(233);
 }
 const char* GDLParser::tokenNames[] = {
 	"<0>",
@@ -9345,6 +9345,8 @@
 	"FOREACH_INDEX_LOOP",
 	"FCALL",
 	"FCALL_LIB",
+	"FCALL_LIB_DIRECT",
+	"FCALL_LIB_N_ELEMENTS",
 	"FCALL_LIB_RETNEW",
 	"IF_ELSE",
 	"KEYDECL",
@@ -9540,12 +9542,12 @@
 	0
 };
 
-const unsigned long GDLParser::_tokenSet_0_data_[] = { 1073741826UL, 1UL, 257951744UL, 2174774016UL, 276824070UL, 0UL, 64UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_0_data_[] = { 1073741826UL, 1UL, 1031806976UL, 109161472UL, 1107296282UL, 0UL, 256UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // EOF "for" "foreach" "repeat" "while" IDENTIFIER "begin" "case" "common" 
 // "compile_opt" "forward_function" "function" "goto" "if" "inherits" "on_ioerror" 
 // "pro" "switch" END_U DEC INC LBRACE SYSVARNAME ASTERIX 
 const antlr::BitSet GDLParser::_tokenSet_0(_tokenSet_0_data_,16);
-const unsigned long GDLParser::_tokenSet_1_data_[] = { 1073741826UL, 1UL, 4016048128UL, 2175298431UL, 1417674758UL, 4294967295UL, 78207UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_1_data_[] = { 1073741826UL, 1UL, 3179290624UL, 111259135UL, 1375731738UL, 4294967293UL, 312831UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // EOF "for" "foreach" "repeat" "while" IDENTIFIER "begin" "case" "common" 
 // "compile_opt" "else" "end" "endcase" "endelse" "endfor" "endforeach" 
 // "endif" "endrep" "endswitch" "endwhile" "forward_function" "function" 
@@ -9562,12 +9564,12 @@
 // CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX STRING_LITERAL PLUS MINUS 
 // LOG_NEG 
 const antlr::BitSet GDLParser::_tokenSet_1(_tokenSet_1_data_,16);
-const unsigned long GDLParser::_tokenSet_2_data_[] = { 1073741824UL, 1UL, 257951744UL, 18901248UL, 276824070UL, 0UL, 64UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_2_data_[] = { 1073741824UL, 1UL, 1031806976UL, 75604992UL, 1107296280UL, 0UL, 256UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // "for" "foreach" "repeat" "while" IDENTIFIER "begin" "case" "common" 
 // "compile_opt" "forward_function" "goto" "if" "inherits" "on_ioerror" 
 // "switch" DEC INC LBRACE SYSVARNAME ASTERIX 
 const antlr::BitSet GDLParser::_tokenSet_2(_tokenSet_2_data_,16);
-const unsigned long GDLParser::_tokenSet_3_data_[] = { 1073741824UL, 1UL, 257951744UL, 2703780096UL, 1426063359UL, 4294967295UL, 78335UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_3_data_[] = { 1073741824UL, 1UL, 1031806976UL, 2225185792UL, 1409286142UL, 4294967293UL, 313343UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // "for" "foreach" "repeat" "while" IDENTIFIER "begin" "case" "common" 
 // "compile_opt" "forward_function" "goto" "if" "inherits" "not" "on_ioerror" 
 // "switch" COMMA END_U EQUAL DEC INC AND_OP_EQ ASTERIX_EQ EQ_OP_EQ GE_OP_EQ 
@@ -9585,10 +9587,10 @@
 // CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX DOT STRING_LITERAL PLUS MINUS 
 // LOG_NEG 
 const antlr::BitSet GDLParser::_tokenSet_3(_tokenSet_3_data_,16);
-const unsigned long GDLParser::_tokenSet_4_data_[] = { 0UL, 0UL, 4194304UL, 16384UL, 276824064UL, 0UL, 64UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_4_data_[] = { 0UL, 0UL, 16777216UL, 65536UL, 1107296256UL, 0UL, 256UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "inherits" LBRACE SYSVARNAME ASTERIX 
 const antlr::BitSet GDLParser::_tokenSet_4(_tokenSet_4_data_,16);
-const unsigned long GDLParser::_tokenSet_5_data_[] = { 0UL, 0UL, 4194304UL, 540672UL, 1417674758UL, 4294967295UL, 78335UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_5_data_[] = { 0UL, 0UL, 16777216UL, 2162688UL, 1375731736UL, 4294967293UL, 313343UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "inherits" "not" DEC INC LBRACE LSQUARE SYSVARNAME LCURLY 
 // CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 CONSTANT_HEX_INT 
 // CONSTANT_HEX_I CONSTANT_HEX_ULONG CONSTANT_HEX_ULONG64 CONSTANT_HEX_UI 
@@ -9601,7 +9603,7 @@
 // CONSTANT_BIN_ULONG64 CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX DOT STRING_LITERAL 
 // PLUS MINUS LOG_NEG 
 const antlr::BitSet GDLParser::_tokenSet_5(_tokenSet_5_data_,16);
-const unsigned long GDLParser::_tokenSet_6_data_[] = { 0UL, 0UL, 4194304UL, 540672UL, 1426063359UL, 4294967295UL, 78335UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_6_data_[] = { 0UL, 0UL, 16777216UL, 2162688UL, 1409286140UL, 4294967293UL, 313343UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "inherits" "not" EQUAL DEC INC AND_OP_EQ ASTERIX_EQ EQ_OP_EQ 
 // GE_OP_EQ GTMARK_EQ GT_OP_EQ LE_OP_EQ LTMARK_EQ LT_OP_EQ MATRIX_OP1_EQ 
 // MATRIX_OP2_EQ MINUS_EQ MOD_OP_EQ NE_OP_EQ OR_OP_EQ PLUS_EQ POW_EQ SLASH_EQ 
@@ -9617,10 +9619,10 @@
 // CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX DOT STRING_LITERAL PLUS MINUS 
 // LOG_NEG 
 const antlr::BitSet GDLParser::_tokenSet_6(_tokenSet_6_data_,16);
-const unsigned long GDLParser::_tokenSet_7_data_[] = { 0UL, 0UL, 536870912UL, 2751463424UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_7_data_[] = { 0UL, 0UL, 2147483648UL, 2415919104UL, 2UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // "else" "until" COMMA END_U 
-const antlr::BitSet GDLParser::_tokenSet_7(_tokenSet_7_data_,8);
-const unsigned long GDLParser::_tokenSet_8_data_[] = { 0UL, 0UL, 541065216UL, 540672UL, 1417674758UL, 4294967295UL, 78207UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const antlr::BitSet GDLParser::_tokenSet_7(_tokenSet_7_data_,12);
+const unsigned long GDLParser::_tokenSet_8_data_[] = { 0UL, 0UL, 2164260864UL, 2162688UL, 1375731736UL, 4294967293UL, 312831UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "else" "inherits" "not" DEC INC LBRACE LSQUARE SYSVARNAME 
 // LCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 CONSTANT_HEX_INT 
 // CONSTANT_HEX_I CONSTANT_HEX_ULONG CONSTANT_HEX_ULONG64 CONSTANT_HEX_UI 
@@ -9633,7 +9635,7 @@
 // CONSTANT_BIN_ULONG64 CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX STRING_LITERAL 
 // PLUS MINUS LOG_NEG 
 const antlr::BitSet GDLParser::_tokenSet_8(_tokenSet_8_data_,16);
-const unsigned long GDLParser::_tokenSet_9_data_[] = { 1073741826UL, 1UL, 4292872192UL, 2415919103UL, 1451229190UL, 4294967295UL, 78207UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_9_data_[] = { 1073741826UL, 1UL, 4286586880UL, 1073741823UL, 1509949466UL, 4294967293UL, 312831UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // EOF "for" "foreach" "repeat" "while" IDENTIFIER "and" "begin" "case" 
 // "common" "compile_opt" "do" "else" "end" "endcase" "endelse" "endfor" 
 // "endforeach" "endif" "endrep" "endswitch" "endwhile" "eq" "forward_function" 
@@ -9651,14 +9653,14 @@
 // CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX STRING_LITERAL PLUS MINUS 
 // LOG_NEG 
 const antlr::BitSet GDLParser::_tokenSet_9(_tokenSet_9_data_,16);
-const unsigned long GDLParser::_tokenSet_10_data_[] = { 1073741824UL, 1UL, 4292872192UL, 268435455UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_10_data_[] = { 1073741824UL, 1UL, 4286586880UL, 1073741823UL, 0UL, 0UL, 0UL, 0UL };
 // "for" "foreach" "repeat" "while" IDENTIFIER "and" "begin" "case" "common" 
 // "compile_opt" "do" "else" "end" "endcase" "endelse" "endfor" "endforeach" 
 // "endif" "endrep" "endswitch" "endwhile" "eq" "forward_function" "function" 
 // "ge" "goto" "gt" "if" "inherits" "le" "lt" "mod" "ne" "not" "of" "on_ioerror" 
 // "or" "pro" "switch" "then" "until" "xor" 
 const antlr::BitSet GDLParser::_tokenSet_10(_tokenSet_10_data_,8);
-const unsigned long GDLParser::_tokenSet_11_data_[] = { 0UL, 0UL, 4194304UL, 540672UL, 1417674758UL, 4294967295UL, 78207UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_11_data_[] = { 0UL, 0UL, 16777216UL, 2162688UL, 1375731736UL, 4294967293UL, 312831UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "inherits" "not" DEC INC LBRACE LSQUARE SYSVARNAME LCURLY 
 // CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 CONSTANT_HEX_INT 
 // CONSTANT_HEX_I CONSTANT_HEX_ULONG CONSTANT_HEX_ULONG64 CONSTANT_HEX_UI 
@@ -9671,7 +9673,7 @@
 // CONSTANT_BIN_ULONG64 CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX STRING_LITERAL 
 // PLUS MINUS LOG_NEG 
 const antlr::BitSet GDLParser::_tokenSet_11(_tokenSet_11_data_,16);
-const unsigned long GDLParser::_tokenSet_12_data_[] = { 0UL, 0UL, 549453824UL, 2890912896UL, 2009071622UL, 4294967295UL, 1048575UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_12_data_[] = { 0UL, 0UL, 2197815296UL, 2973716992UL, 3741319194UL, 4294967293UL, 4194303UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "and" "else" "eq" "ge" "gt" "inherits" "le" "lt" "mod" "ne" 
 // "not" "or" "until" "xor" COMMA END_U DEC INC MEMBER LBRACE RBRACE SLASH 
 // LSQUARE SYSVARNAME EXCLAMATION LCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG 
@@ -9686,10 +9688,10 @@
 // CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX DOT STRING_LITERAL POW MATRIX_OP1 
 // MATRIX_OP2 PLUS MINUS LTMARK GTMARK LOG_NEG LOG_AND LOG_OR QUESTION 
 const antlr::BitSet GDLParser::_tokenSet_12(_tokenSet_12_data_,16);
-const unsigned long GDLParser::_tokenSet_13_data_[] = { 0UL, 0UL, 4194304UL, 16384UL, 805306368UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_13_data_[] = { 0UL, 0UL, 16777216UL, 65536UL, 3221225472UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "inherits" SYSVARNAME EXCLAMATION 
 const antlr::BitSet GDLParser::_tokenSet_13(_tokenSet_13_data_,12);
-const unsigned long GDLParser::_tokenSet_14_data_[] = { 2UL, 0UL, 12582912UL, 676320384UL, 4139778054UL, 4294967295UL, 1048575UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_14_data_[] = { 2UL, 0UL, 50331648UL, 2705281536UL, 3674210328UL, 4294967295UL, 4194303UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // EOF IDENTIFIER "and" "eq" "ge" "gt" "inherits" "le" "lt" "mod" "ne" 
 // "not" "or" "xor" COMMA DEC INC MEMBER LBRACE SLASH LSQUARE SYSVARNAME 
 // EXCLAMATION LCURLY RCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 
@@ -9704,7 +9706,7 @@
 // ASTERIX DOT STRING_LITERAL POW MATRIX_OP1 MATRIX_OP2 PLUS MINUS LTMARK 
 // GTMARK LOG_NEG LOG_AND LOG_OR QUESTION 
 const antlr::BitSet GDLParser::_tokenSet_14(_tokenSet_14_data_,16);
-const unsigned long GDLParser::_tokenSet_15_data_[] = { 0UL, 0UL, 4194304UL, 540672UL, 1954545670UL, 4294967295UL, 78207UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_15_data_[] = { 0UL, 0UL, 16777216UL, 2162688UL, 3523215384UL, 4294967293UL, 312831UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "inherits" "not" DEC INC LBRACE LSQUARE SYSVARNAME EXCLAMATION 
 // LCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 CONSTANT_HEX_INT 
 // CONSTANT_HEX_I CONSTANT_HEX_ULONG CONSTANT_HEX_ULONG64 CONSTANT_HEX_UI 
@@ -9717,7 +9719,7 @@
 // CONSTANT_BIN_ULONG64 CONSTANT_BIN_UI CONSTANT_BIN_UINT ASTERIX STRING_LITERAL 
 // PLUS MINUS LOG_NEG 
 const antlr::BitSet GDLParser::_tokenSet_15(_tokenSet_15_data_,16);
-const unsigned long GDLParser::_tokenSet_16_data_[] = { 0UL, 0UL, 12582912UL, 1750062208UL, 4139778054UL, 4294967295UL, 1048575UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_16_data_[] = { 0UL, 0UL, 50331648UL, 2705281536UL, 3674210329UL, 4294967295UL, 4194303UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "and" "eq" "ge" "gt" "inherits" "le" "lt" "mod" "ne" "not" 
 // "or" "xor" COMMA COLON DEC INC MEMBER LBRACE SLASH LSQUARE SYSVARNAME 
 // EXCLAMATION LCURLY RCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 
@@ -9732,7 +9734,7 @@
 // ASTERIX DOT STRING_LITERAL POW MATRIX_OP1 MATRIX_OP2 PLUS MINUS LTMARK 
 // GTMARK LOG_NEG LOG_AND LOG_OR QUESTION 
 const antlr::BitSet GDLParser::_tokenSet_16(_tokenSet_16_data_,16);
-const unsigned long GDLParser::_tokenSet_17_data_[] = { 0UL, 0UL, 12582912UL, 1750062208UL, 2143289350UL, 4294967295UL, 1048575UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_17_data_[] = { 0UL, 0UL, 50331648UL, 2705281536UL, 4278190105UL, 4294967293UL, 4194303UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "and" "eq" "ge" "gt" "inherits" "le" "lt" "mod" "ne" "not" 
 // "or" "xor" COMMA COLON DEC INC MEMBER LBRACE RBRACE SLASH LSQUARE RSQUARE 
 // SYSVARNAME EXCLAMATION LCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 
@@ -9747,10 +9749,10 @@
 // ASTERIX DOT STRING_LITERAL POW MATRIX_OP1 MATRIX_OP2 PLUS MINUS LTMARK 
 // GTMARK LOG_NEG LOG_AND LOG_OR QUESTION 
 const antlr::BitSet GDLParser::_tokenSet_17(_tokenSet_17_data_,16);
-const unsigned long GDLParser::_tokenSet_18_data_[] = { 0UL, 0UL, 0UL, 1610612736UL, 150994944UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_18_data_[] = { 0UL, 0UL, 0UL, 2147483648UL, 603979777UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // COMMA COLON RBRACE RSQUARE 
 const antlr::BitSet GDLParser::_tokenSet_18(_tokenSet_18_data_,12);
-const unsigned long GDLParser::_tokenSet_19_data_[] = { 0UL, 0UL, 12582912UL, 676320384UL, 2143289350UL, 4294967295UL, 1048575UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_19_data_[] = { 0UL, 0UL, 50331648UL, 2705281536UL, 4278190104UL, 4294967293UL, 4194303UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER "and" "eq" "ge" "gt" "inherits" "le" "lt" "mod" "ne" "not" 
 // "or" "xor" COMMA DEC INC MEMBER LBRACE RBRACE SLASH LSQUARE RSQUARE 
 // SYSVARNAME EXCLAMATION LCURLY CONSTANT_HEX_BYTE CONSTANT_HEX_LONG CONSTANT_HEX_LONG64 
@@ -9765,13 +9767,13 @@
 // ASTERIX DOT STRING_LITERAL POW MATRIX_OP1 MATRIX_OP2 PLUS MINUS LTMARK 
 // GTMARK LOG_NEG LOG_AND LOG_OR QUESTION 
 const antlr::BitSet GDLParser::_tokenSet_19(_tokenSet_19_data_,16);
-const unsigned long GDLParser::_tokenSet_20_data_[] = { 0UL, 0UL, 4194304UL, 0UL, 813694976UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_20_data_[] = { 0UL, 0UL, 16777216UL, 0UL, 3254779904UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // IDENTIFIER LBRACE SYSVARNAME EXCLAMATION 
 const antlr::BitSet GDLParser::_tokenSet_20(_tokenSet_20_data_,12);
-const unsigned long GDLParser::_tokenSet_21_data_[] = { 0UL, 0UL, 536870912UL, 3019898880UL, 75497472UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_21_data_[] = { 0UL, 0UL, 2147483648UL, 3489660928UL, 301989890UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // "else" "until" METHOD COMMA END_U LBRACE LSQUARE 
 const antlr::BitSet GDLParser::_tokenSet_21(_tokenSet_21_data_,12);
-const unsigned long GDLParser::_tokenSet_22_data_[] = { 2UL, 0UL, 817889280UL, 3999257728UL, 3753902086UL, 4294967295UL, 1048575UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_22_data_[] = { 2UL, 0UL, 3271557120UL, 3112129024UL, 2130706459UL, 4294967295UL, 4194303UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // EOF IDENTIFIER "and" "do" "else" "eq" "ge" "gt" "inherits" "le" "lt" 
 // "mod" "ne" "not" "of" "or" "then" "until" "xor" COMMA COLON END_U DEC 
 // INC MEMBER LBRACE RBRACE SLASH LSQUARE RSQUARE SYSVARNAME LCURLY RCURLY 
@@ -9787,10 +9789,10 @@
 // POW MATRIX_OP1 MATRIX_OP2 PLUS MINUS LTMARK GTMARK LOG_NEG LOG_AND LOG_OR 
 // QUESTION 
 const antlr::BitSet GDLParser::_tokenSet_22(_tokenSet_22_data_,16);
-const unsigned long GDLParser::_tokenSet_23_data_[] = { 0UL, 0UL, 0UL, 131072UL, 33554432UL, 0UL, 3136UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_23_data_[] = { 0UL, 0UL, 0UL, 524288UL, 134217728UL, 0UL, 12544UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // "mod" SLASH ASTERIX MATRIX_OP1 MATRIX_OP2 
 const antlr::BitSet GDLParser::_tokenSet_23(_tokenSet_23_data_,16);
-const unsigned long GDLParser::_tokenSet_24_data_[] = { 0UL, 0UL, 0UL, 365696UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLParser::_tokenSet_24_data_[] = { 0UL, 0UL, 0UL, 1462784UL, 0UL, 0UL, 0UL, 0UL };
 // "eq" "ge" "gt" "le" "lt" "ne" 
 const antlr::BitSet GDLParser::_tokenSet_24(_tokenSet_24_data_,8);
 
diff -ruN --exclude CVS gdl-0.9.2/src/GDLParser.hpp gdl/src/GDLParser.hpp
--- gdl-0.9.2/src/GDLParser.hpp	2011-11-07 16:38:20.000000000 -0700
+++ gdl/src/GDLParser.hpp	2011-11-15 16:19:00.000000000 -0700
@@ -214,10 +214,10 @@
 private:
 	static const char* tokenNames[];
 #ifndef NO_STATIC_CONSTS
-	static const int NUM_TOKENS = 232;
+	static const int NUM_TOKENS = 234;
 #else
 	enum {
-		NUM_TOKENS = 232
+		NUM_TOKENS = 234
 	};
 #endif
 	
diff -ruN --exclude CVS gdl-0.9.2/src/gdlpsstream.hpp gdl/src/gdlpsstream.hpp
--- gdl-0.9.2/src/gdlpsstream.hpp	2011-09-19 06:06:11.000000000 -0600
+++ gdl/src/gdlpsstream.hpp	2011-12-28 06:25:24.000000000 -0700
@@ -28,7 +28,7 @@
   bool encapsulated;
 public:
   GDLPSStream( int nx, int ny, int pfont, bool encaps):
-    GDLGStream::GDLGStream( nx, ny, pfont == 1 ? "ps-ttf" : "ps")
+    GDLGStream::GDLGStream( nx, ny, pfont == 1 ? "psttf" : "ps")
   {
     encapsulated = encaps;
   }
diff -ruN --exclude CVS gdl-0.9.2/src/GDLTokenTypes.hpp gdl/src/GDLTokenTypes.hpp
--- gdl-0.9.2/src/GDLTokenTypes.hpp	2011-11-07 16:38:20.000000000 -0700
+++ gdl/src/GDLTokenTypes.hpp	2011-11-15 16:19:00.000000000 -0700
@@ -48,198 +48,200 @@
 		FOREACH_INDEX_LOOP = 37,
 		FCALL = 38,
 		FCALL_LIB = 39,
-		FCALL_LIB_RETNEW = 40,
-		IF_ELSE = 41,
-		KEYDECL = 42,
-		KEYDEF = 43,
-		KEYDEF_REF = 44,
-		KEYDEF_REF_CHECK = 45,
-		KEYDEF_REF_EXPR = 46,
-		LABEL = 47,
-		MPCALL = 48,
-		MPCALL_PARENT = 49,
-		MFCALL = 50,
-		MFCALL_LIB = 51,
-		MFCALL_LIB_RETNEW = 52,
-		MFCALL_PARENT = 53,
-		MFCALL_PARENT_LIB = 54,
-		MFCALL_PARENT_LIB_RETNEW = 55,
-		NOP = 56,
-		NSTRUC = 57,
-		NSTRUC_REF = 58,
-		ON_IOERROR_NULL = 59,
-		PCALL = 60,
-		PCALL_LIB = 61,
-		PARADECL = 62,
-		PARAEXPR = 63,
-		PARAEXPR_VN = 64,
-		POSTDEC = 65,
-		POSTINC = 66,
-		DECSTATEMENT = 67,
-		INCSTATEMENT = 68,
-		REF = 69,
-		REF_VN = 70,
-		REF_CHECK = 71,
-		REF_CHECK_VN = 72,
-		REF_EXPR = 73,
-		REF_EXPR_VN = 74,
-		REPEAT = 75,
-		REPEAT_LOOP = 76,
-		RETURN = 77,
-		RETF = 78,
-		RETP = 79,
-		STRUC = 80,
-		SYSVAR = 81,
-		UMINUS = 82,
-		VAR = 83,
-		VARPTR = 84,
-		WHILE = 85,
-		IDENTIFIER = 86,
-		AND_OP = 87,
-		BEGIN = 88,
-		CASE = 89,
-		COMMON = 90,
-		COMPILE_OPT = 91,
-		DO = 92,
-		ELSE = 93,
-		END = 94,
-		ENDCASE = 95,
-		ENDELSE = 96,
-		ENDFOR = 97,
-		ENDFOREACH = 98,
-		ENDIF = 99,
-		ENDREP = 100,
-		ENDSWITCH = 101,
-		ENDWHILE = 102,
-		EQ_OP = 103,
-		FORWARD = 104,
-		FUNCTION = 105,
-		GE_OP = 106,
-		GOTO = 107,
-		GT_OP = 108,
-		IF = 109,
-		INHERITS = 110,
-		LE_OP = 111,
-		LT_OP = 112,
-		MOD_OP = 113,
-		NE_OP = 114,
-		NOT_OP = 115,
-		OF = 116,
-		ON_IOERROR = 117,
-		OR_OP = 118,
-		PRO = 119,
-		SWITCH = 120,
-		THEN = 121,
-		UNTIL = 122,
-		XOR_OP = 123,
-		METHOD = 124,
-		COMMA = 125,
-		COLON = 126,
-		END_U = 127,
-		EQUAL = 128,
-		DEC = 129,
-		INC = 130,
-		AND_OP_EQ = 131,
-		ASTERIX_EQ = 132,
-		EQ_OP_EQ = 133,
-		GE_OP_EQ = 134,
-		GTMARK_EQ = 135,
-		GT_OP_EQ = 136,
-		LE_OP_EQ = 137,
-		LTMARK_EQ = 138,
-		LT_OP_EQ = 139,
-		MATRIX_OP1_EQ = 140,
-		MATRIX_OP2_EQ = 141,
-		MINUS_EQ = 142,
-		MOD_OP_EQ = 143,
-		NE_OP_EQ = 144,
-		OR_OP_EQ = 145,
-		PLUS_EQ = 146,
-		POW_EQ = 147,
-		SLASH_EQ = 148,
-		XOR_OP_EQ = 149,
-		MEMBER = 150,
-		LBRACE = 151,
-		RBRACE = 152,
-		SLASH = 153,
-		LSQUARE = 154,
-		RSQUARE = 155,
-		SYSVARNAME = 156,
-		EXCLAMATION = 157,
-		LCURLY = 158,
-		RCURLY = 159,
-		CONSTANT_HEX_BYTE = 160,
-		CONSTANT_HEX_LONG = 161,
-		CONSTANT_HEX_LONG64 = 162,
-		CONSTANT_HEX_INT = 163,
-		CONSTANT_HEX_I = 164,
-		CONSTANT_HEX_ULONG = 165,
-		CONSTANT_HEX_ULONG64 = 166,
-		CONSTANT_HEX_UI = 167,
-		CONSTANT_HEX_UINT = 168,
-		CONSTANT_BYTE = 169,
-		CONSTANT_LONG = 170,
-		CONSTANT_LONG64 = 171,
-		CONSTANT_INT = 172,
-		CONSTANT_I = 173,
-		CONSTANT_ULONG = 174,
-		CONSTANT_ULONG64 = 175,
-		CONSTANT_UI = 176,
-		CONSTANT_UINT = 177,
-		CONSTANT_OCT_BYTE = 178,
-		CONSTANT_OCT_LONG = 179,
-		CONSTANT_OCT_LONG64 = 180,
-		CONSTANT_OCT_INT = 181,
-		CONSTANT_OCT_I = 182,
-		CONSTANT_OCT_ULONG = 183,
-		CONSTANT_OCT_ULONG64 = 184,
-		CONSTANT_OCT_UI = 185,
-		CONSTANT_OCT_UINT = 186,
-		CONSTANT_FLOAT = 187,
-		CONSTANT_DOUBLE = 188,
-		CONSTANT_BIN_BYTE = 189,
-		CONSTANT_BIN_LONG = 190,
-		CONSTANT_BIN_LONG64 = 191,
-		CONSTANT_BIN_INT = 192,
-		CONSTANT_BIN_I = 193,
-		CONSTANT_BIN_ULONG = 194,
-		CONSTANT_BIN_ULONG64 = 195,
-		CONSTANT_BIN_UI = 196,
-		CONSTANT_BIN_UINT = 197,
-		ASTERIX = 198,
-		DOT = 199,
-		STRING_LITERAL = 200,
-		POW = 201,
-		MATRIX_OP1 = 202,
-		MATRIX_OP2 = 203,
-		PLUS = 204,
-		MINUS = 205,
-		LTMARK = 206,
-		GTMARK = 207,
-		LOG_NEG = 208,
-		LOG_AND = 209,
-		LOG_OR = 210,
-		QUESTION = 211,
-		STRING = 212,
-		INCLUDE = 213,
-		EOL = 214,
-		W = 215,
-		D = 216,
-		L = 217,
-		H = 218,
-		O = 219,
-		B = 220,
-		EXP = 221,
-		DBL_E = 222,
-		DBL = 223,
-		CONSTANT_OR_STRING_LITERAL = 224,
-		COMMENT = 225,
-		END_MARKER = 226,
-		WHITESPACE = 227,
-		SKIP_LINES = 228,
-		CONT_STATEMENT = 229,
-		END_OF_LINE = 230,
-		MAX_TOKEN_NUMBER = 231,
+		FCALL_LIB_DIRECT = 40,
+		FCALL_LIB_N_ELEMENTS = 41,
+		FCALL_LIB_RETNEW = 42,
+		IF_ELSE = 43,
+		KEYDECL = 44,
+		KEYDEF = 45,
+		KEYDEF_REF = 46,
+		KEYDEF_REF_CHECK = 47,
+		KEYDEF_REF_EXPR = 48,
+		LABEL = 49,
+		MPCALL = 50,
+		MPCALL_PARENT = 51,
+		MFCALL = 52,
+		MFCALL_LIB = 53,
+		MFCALL_LIB_RETNEW = 54,
+		MFCALL_PARENT = 55,
+		MFCALL_PARENT_LIB = 56,
+		MFCALL_PARENT_LIB_RETNEW = 57,
+		NOP = 58,
+		NSTRUC = 59,
+		NSTRUC_REF = 60,
+		ON_IOERROR_NULL = 61,
+		PCALL = 62,
+		PCALL_LIB = 63,
+		PARADECL = 64,
+		PARAEXPR = 65,
+		PARAEXPR_VN = 66,
+		POSTDEC = 67,
+		POSTINC = 68,
+		DECSTATEMENT = 69,
+		INCSTATEMENT = 70,
+		REF = 71,
+		REF_VN = 72,
+		REF_CHECK = 73,
+		REF_CHECK_VN = 74,
+		REF_EXPR = 75,
+		REF_EXPR_VN = 76,
+		REPEAT = 77,
+		REPEAT_LOOP = 78,
+		RETURN = 79,
+		RETF = 80,
+		RETP = 81,
+		STRUC = 82,
+		SYSVAR = 83,
+		UMINUS = 84,
+		VAR = 85,
+		VARPTR = 86,
+		WHILE = 87,
+		IDENTIFIER = 88,
+		AND_OP = 89,
+		BEGIN = 90,
+		CASE = 91,
+		COMMON = 92,
+		COMPILE_OPT = 93,
+		DO = 94,
+		ELSE = 95,
+		END = 96,
+		ENDCASE = 97,
+		ENDELSE = 98,
+		ENDFOR = 99,
+		ENDFOREACH = 100,
+		ENDIF = 101,
+		ENDREP = 102,
+		ENDSWITCH = 103,
+		ENDWHILE = 104,
+		EQ_OP = 105,
+		FORWARD = 106,
+		FUNCTION = 107,
+		GE_OP = 108,
+		GOTO = 109,
+		GT_OP = 110,
+		IF = 111,
+		INHERITS = 112,
+		LE_OP = 113,
+		LT_OP = 114,
+		MOD_OP = 115,
+		NE_OP = 116,
+		NOT_OP = 117,
+		OF = 118,
+		ON_IOERROR = 119,
+		OR_OP = 120,
+		PRO = 121,
+		SWITCH = 122,
+		THEN = 123,
+		UNTIL = 124,
+		XOR_OP = 125,
+		METHOD = 126,
+		COMMA = 127,
+		COLON = 128,
+		END_U = 129,
+		EQUAL = 130,
+		DEC = 131,
+		INC = 132,
+		AND_OP_EQ = 133,
+		ASTERIX_EQ = 134,
+		EQ_OP_EQ = 135,
+		GE_OP_EQ = 136,
+		GTMARK_EQ = 137,
+		GT_OP_EQ = 138,
+		LE_OP_EQ = 139,
+		LTMARK_EQ = 140,
+		LT_OP_EQ = 141,
+		MATRIX_OP1_EQ = 142,
+		MATRIX_OP2_EQ = 143,
+		MINUS_EQ = 144,
+		MOD_OP_EQ = 145,
+		NE_OP_EQ = 146,
+		OR_OP_EQ = 147,
+		PLUS_EQ = 148,
+		POW_EQ = 149,
+		SLASH_EQ = 150,
+		XOR_OP_EQ = 151,
+		MEMBER = 152,
+		LBRACE = 153,
+		RBRACE = 154,
+		SLASH = 155,
+		LSQUARE = 156,
+		RSQUARE = 157,
+		SYSVARNAME = 158,
+		EXCLAMATION = 159,
+		LCURLY = 160,
+		RCURLY = 161,
+		CONSTANT_HEX_BYTE = 162,
+		CONSTANT_HEX_LONG = 163,
+		CONSTANT_HEX_LONG64 = 164,
+		CONSTANT_HEX_INT = 165,
+		CONSTANT_HEX_I = 166,
+		CONSTANT_HEX_ULONG = 167,
+		CONSTANT_HEX_ULONG64 = 168,
+		CONSTANT_HEX_UI = 169,
+		CONSTANT_HEX_UINT = 170,
+		CONSTANT_BYTE = 171,
+		CONSTANT_LONG = 172,
+		CONSTANT_LONG64 = 173,
+		CONSTANT_INT = 174,
+		CONSTANT_I = 175,
+		CONSTANT_ULONG = 176,
+		CONSTANT_ULONG64 = 177,
+		CONSTANT_UI = 178,
+		CONSTANT_UINT = 179,
+		CONSTANT_OCT_BYTE = 180,
+		CONSTANT_OCT_LONG = 181,
+		CONSTANT_OCT_LONG64 = 182,
+		CONSTANT_OCT_INT = 183,
+		CONSTANT_OCT_I = 184,
+		CONSTANT_OCT_ULONG = 185,
+		CONSTANT_OCT_ULONG64 = 186,
+		CONSTANT_OCT_UI = 187,
+		CONSTANT_OCT_UINT = 188,
+		CONSTANT_FLOAT = 189,
+		CONSTANT_DOUBLE = 190,
+		CONSTANT_BIN_BYTE = 191,
+		CONSTANT_BIN_LONG = 192,
+		CONSTANT_BIN_LONG64 = 193,
+		CONSTANT_BIN_INT = 194,
+		CONSTANT_BIN_I = 195,
+		CONSTANT_BIN_ULONG = 196,
+		CONSTANT_BIN_ULONG64 = 197,
+		CONSTANT_BIN_UI = 198,
+		CONSTANT_BIN_UINT = 199,
+		ASTERIX = 200,
+		DOT = 201,
+		STRING_LITERAL = 202,
+		POW = 203,
+		MATRIX_OP1 = 204,
+		MATRIX_OP2 = 205,
+		PLUS = 206,
+		MINUS = 207,
+		LTMARK = 208,
+		GTMARK = 209,
+		LOG_NEG = 210,
+		LOG_AND = 211,
+		LOG_OR = 212,
+		QUESTION = 213,
+		STRING = 214,
+		INCLUDE = 215,
+		EOL = 216,
+		W = 217,
+		D = 218,
+		L = 219,
+		H = 220,
+		O = 221,
+		B = 222,
+		EXP = 223,
+		DBL_E = 224,
+		DBL = 225,
+		CONSTANT_OR_STRING_LITERAL = 226,
+		COMMENT = 227,
+		END_MARKER = 228,
+		WHITESPACE = 229,
+		SKIP_LINES = 230,
+		CONT_STATEMENT = 231,
+		END_OF_LINE = 232,
+		MAX_TOKEN_NUMBER = 233,
 		NULL_TREE_LOOKAHEAD = 3
 	};
 #ifdef __cplusplus
diff -ruN --exclude CVS gdl-0.9.2/src/GDLTokenTypes.txt gdl/src/GDLTokenTypes.txt
--- gdl-0.9.2/src/GDLTokenTypes.txt	2011-11-07 16:38:20.000000000 -0700
+++ gdl/src/GDLTokenTypes.txt	2011-11-15 16:19:00.000000000 -0700
@@ -36,195 +36,197 @@
 FOREACH_INDEX_LOOP=37
 FCALL=38
 FCALL_LIB=39
-FCALL_LIB_RETNEW=40
-IF_ELSE=41
-KEYDECL=42
-KEYDEF=43
-KEYDEF_REF=44
-KEYDEF_REF_CHECK=45
-KEYDEF_REF_EXPR=46
-LABEL=47
-MPCALL=48
-MPCALL_PARENT=49
-MFCALL=50
-MFCALL_LIB=51
-MFCALL_LIB_RETNEW=52
-MFCALL_PARENT=53
-MFCALL_PARENT_LIB=54
-MFCALL_PARENT_LIB_RETNEW=55
-NOP=56
-NSTRUC=57
-NSTRUC_REF=58
-ON_IOERROR_NULL=59
-PCALL=60
-PCALL_LIB=61
-PARADECL=62
-PARAEXPR=63
-PARAEXPR_VN=64
-POSTDEC=65
-POSTINC=66
-DECSTATEMENT=67
-INCSTATEMENT=68
-REF=69
-REF_VN=70
-REF_CHECK=71
-REF_CHECK_VN=72
-REF_EXPR=73
-REF_EXPR_VN=74
-REPEAT="repeat"=75
-REPEAT_LOOP=76
-RETURN=77
-RETF=78
-RETP=79
-STRUC=80
-SYSVAR=81
-UMINUS=82
-VAR=83
-VARPTR=84
-WHILE="while"=85
-IDENTIFIER=86
-AND_OP="and"=87
-BEGIN="begin"=88
-CASE="case"=89
-COMMON="common"=90
-COMPILE_OPT="compile_opt"=91
-DO="do"=92
-ELSE="else"=93
-END="end"=94
-ENDCASE="endcase"=95
-ENDELSE="endelse"=96
-ENDFOR="endfor"=97
-ENDFOREACH="endforeach"=98
-ENDIF="endif"=99
-ENDREP="endrep"=100
-ENDSWITCH="endswitch"=101
-ENDWHILE="endwhile"=102
-EQ_OP="eq"=103
-FORWARD="forward_function"=104
-FUNCTION="function"=105
-GE_OP="ge"=106
-GOTO="goto"=107
-GT_OP="gt"=108
-IF="if"=109
-INHERITS="inherits"=110
-LE_OP="le"=111
-LT_OP="lt"=112
-MOD_OP="mod"=113
-NE_OP="ne"=114
-NOT_OP="not"=115
-OF="of"=116
-ON_IOERROR="on_ioerror"=117
-OR_OP="or"=118
-PRO="pro"=119
-SWITCH="switch"=120
-THEN="then"=121
-UNTIL="until"=122
-XOR_OP="xor"=123
-METHOD=124
-COMMA=125
-COLON=126
-END_U=127
-EQUAL=128
-DEC=129
-INC=130
-AND_OP_EQ=131
-ASTERIX_EQ=132
-EQ_OP_EQ=133
-GE_OP_EQ=134
-GTMARK_EQ=135
-GT_OP_EQ=136
-LE_OP_EQ=137
-LTMARK_EQ=138
-LT_OP_EQ=139
-MATRIX_OP1_EQ=140
-MATRIX_OP2_EQ=141
-MINUS_EQ=142
-MOD_OP_EQ=143
-NE_OP_EQ=144
-OR_OP_EQ=145
-PLUS_EQ=146
-POW_EQ=147
-SLASH_EQ=148
-XOR_OP_EQ=149
-MEMBER=150
-LBRACE=151
-RBRACE=152
-SLASH=153
-LSQUARE=154
-RSQUARE=155
-SYSVARNAME=156
-EXCLAMATION=157
-LCURLY=158
-RCURLY=159
-CONSTANT_HEX_BYTE=160
-CONSTANT_HEX_LONG=161
-CONSTANT_HEX_LONG64=162
-CONSTANT_HEX_INT=163
-CONSTANT_HEX_I=164
-CONSTANT_HEX_ULONG=165
-CONSTANT_HEX_ULONG64=166
-CONSTANT_HEX_UI=167
-CONSTANT_HEX_UINT=168
-CONSTANT_BYTE=169
-CONSTANT_LONG=170
-CONSTANT_LONG64=171
-CONSTANT_INT=172
-CONSTANT_I=173
-CONSTANT_ULONG=174
-CONSTANT_ULONG64=175
-CONSTANT_UI=176
-CONSTANT_UINT=177
-CONSTANT_OCT_BYTE=178
-CONSTANT_OCT_LONG=179
-CONSTANT_OCT_LONG64=180
-CONSTANT_OCT_INT=181
-CONSTANT_OCT_I=182
-CONSTANT_OCT_ULONG=183
-CONSTANT_OCT_ULONG64=184
-CONSTANT_OCT_UI=185
-CONSTANT_OCT_UINT=186
-CONSTANT_FLOAT=187
-CONSTANT_DOUBLE=188
-CONSTANT_BIN_BYTE=189
-CONSTANT_BIN_LONG=190
-CONSTANT_BIN_LONG64=191
-CONSTANT_BIN_INT=192
-CONSTANT_BIN_I=193
-CONSTANT_BIN_ULONG=194
-CONSTANT_BIN_ULONG64=195
-CONSTANT_BIN_UI=196
-CONSTANT_BIN_UINT=197
-ASTERIX=198
-DOT=199
-STRING_LITERAL=200
-POW=201
-MATRIX_OP1=202
-MATRIX_OP2=203
-PLUS=204
-MINUS=205
-LTMARK=206
-GTMARK=207
-LOG_NEG=208
-LOG_AND=209
-LOG_OR=210
-QUESTION=211
-STRING=212
-INCLUDE=213
-EOL=214
-W=215
-D=216
-L=217
-H=218
-O=219
-B=220
-EXP=221
-DBL_E=222
-DBL=223
-CONSTANT_OR_STRING_LITERAL=224
-COMMENT=225
-END_MARKER=226
-WHITESPACE=227
-SKIP_LINES=228
-CONT_STATEMENT=229
-END_OF_LINE=230
-MAX_TOKEN_NUMBER=231
+FCALL_LIB_DIRECT=40
+FCALL_LIB_N_ELEMENTS=41
+FCALL_LIB_RETNEW=42
+IF_ELSE=43
+KEYDECL=44
+KEYDEF=45
+KEYDEF_REF=46
+KEYDEF_REF_CHECK=47
+KEYDEF_REF_EXPR=48
+LABEL=49
+MPCALL=50
+MPCALL_PARENT=51
+MFCALL=52
+MFCALL_LIB=53
+MFCALL_LIB_RETNEW=54
+MFCALL_PARENT=55
+MFCALL_PARENT_LIB=56
+MFCALL_PARENT_LIB_RETNEW=57
+NOP=58
+NSTRUC=59
+NSTRUC_REF=60
+ON_IOERROR_NULL=61
+PCALL=62
+PCALL_LIB=63
+PARADECL=64
+PARAEXPR=65
+PARAEXPR_VN=66
+POSTDEC=67
+POSTINC=68
+DECSTATEMENT=69
+INCSTATEMENT=70
+REF=71
+REF_VN=72
+REF_CHECK=73
+REF_CHECK_VN=74
+REF_EXPR=75
+REF_EXPR_VN=76
+REPEAT="repeat"=77
+REPEAT_LOOP=78
+RETURN=79
+RETF=80
+RETP=81
+STRUC=82
+SYSVAR=83
+UMINUS=84
+VAR=85
+VARPTR=86
+WHILE="while"=87
+IDENTIFIER=88
+AND_OP="and"=89
+BEGIN="begin"=90
+CASE="case"=91
+COMMON="common"=92
+COMPILE_OPT="compile_opt"=93
+DO="do"=94
+ELSE="else"=95
+END="end"=96
+ENDCASE="endcase"=97
+ENDELSE="endelse"=98
+ENDFOR="endfor"=99
+ENDFOREACH="endforeach"=100
+ENDIF="endif"=101
+ENDREP="endrep"=102
+ENDSWITCH="endswitch"=103
+ENDWHILE="endwhile"=104
+EQ_OP="eq"=105
+FORWARD="forward_function"=106
+FUNCTION="function"=107
+GE_OP="ge"=108
+GOTO="goto"=109
+GT_OP="gt"=110
+IF="if"=111
+INHERITS="inherits"=112
+LE_OP="le"=113
+LT_OP="lt"=114
+MOD_OP="mod"=115
+NE_OP="ne"=116
+NOT_OP="not"=117
+OF="of"=118
+ON_IOERROR="on_ioerror"=119
+OR_OP="or"=120
+PRO="pro"=121
+SWITCH="switch"=122
+THEN="then"=123
+UNTIL="until"=124
+XOR_OP="xor"=125
+METHOD=126
+COMMA=127
+COLON=128
+END_U=129
+EQUAL=130
+DEC=131
+INC=132
+AND_OP_EQ=133
+ASTERIX_EQ=134
+EQ_OP_EQ=135
+GE_OP_EQ=136
+GTMARK_EQ=137
+GT_OP_EQ=138
+LE_OP_EQ=139
+LTMARK_EQ=140
+LT_OP_EQ=141
+MATRIX_OP1_EQ=142
+MATRIX_OP2_EQ=143
+MINUS_EQ=144
+MOD_OP_EQ=145
+NE_OP_EQ=146
+OR_OP_EQ=147
+PLUS_EQ=148
+POW_EQ=149
+SLASH_EQ=150
+XOR_OP_EQ=151
+MEMBER=152
+LBRACE=153
+RBRACE=154
+SLASH=155
+LSQUARE=156
+RSQUARE=157
+SYSVARNAME=158
+EXCLAMATION=159
+LCURLY=160
+RCURLY=161
+CONSTANT_HEX_BYTE=162
+CONSTANT_HEX_LONG=163
+CONSTANT_HEX_LONG64=164
+CONSTANT_HEX_INT=165
+CONSTANT_HEX_I=166
+CONSTANT_HEX_ULONG=167
+CONSTANT_HEX_ULONG64=168
+CONSTANT_HEX_UI=169
+CONSTANT_HEX_UINT=170
+CONSTANT_BYTE=171
+CONSTANT_LONG=172
+CONSTANT_LONG64=173
+CONSTANT_INT=174
+CONSTANT_I=175
+CONSTANT_ULONG=176
+CONSTANT_ULONG64=177
+CONSTANT_UI=178
+CONSTANT_UINT=179
+CONSTANT_OCT_BYTE=180
+CONSTANT_OCT_LONG=181
+CONSTANT_OCT_LONG64=182
+CONSTANT_OCT_INT=183
+CONSTANT_OCT_I=184
+CONSTANT_OCT_ULONG=185
+CONSTANT_OCT_ULONG64=186
+CONSTANT_OCT_UI=187
+CONSTANT_OCT_UINT=188
+CONSTANT_FLOAT=189
+CONSTANT_DOUBLE=190
+CONSTANT_BIN_BYTE=191
+CONSTANT_BIN_LONG=192
+CONSTANT_BIN_LONG64=193
+CONSTANT_BIN_INT=194
+CONSTANT_BIN_I=195
+CONSTANT_BIN_ULONG=196
+CONSTANT_BIN_ULONG64=197
+CONSTANT_BIN_UI=198
+CONSTANT_BIN_UINT=199
+ASTERIX=200
+DOT=201
+STRING_LITERAL=202
+POW=203
+MATRIX_OP1=204
+MATRIX_OP2=205
+PLUS=206
+MINUS=207
+LTMARK=208
+GTMARK=209
+LOG_NEG=210
+LOG_AND=211
+LOG_OR=212
+QUESTION=213
+STRING=214
+INCLUDE=215
+EOL=216
+W=217
+D=218
+L=219
+H=220
+O=221
+B=222
+EXP=223
+DBL_E=224
+DBL=225
+CONSTANT_OR_STRING_LITERAL=226
+COMMENT=227
+END_MARKER=228
+WHITESPACE=229
+SKIP_LINES=230
+CONT_STATEMENT=231
+END_OF_LINE=232
+MAX_TOKEN_NUMBER=233
diff -ruN --exclude CVS gdl-0.9.2/src/GDLTreeParser.cpp gdl/src/GDLTreeParser.cpp
--- gdl-0.9.2/src/GDLTreeParser.cpp	2011-11-07 16:38:20.000000000 -0700
+++ gdl/src/GDLTreeParser.cpp	2011-11-15 16:19:00.000000000 -0700
@@ -3010,8 +3010,11 @@
 		nParam = para_AST->GetNParam();
 		
 		int libParam = libProList[i]->NPar();
+		int libParamMin = libProList[i]->NParMin();
 		if( libParam != -1 && nParam > libParam)
 		throw GDLException(	p, libProList[i]->Name() + ": Too many arguments.");
+		if( libParam != -1 && nParam < libParamMin)
+		throw GDLException(	p, libProList[i]->Name() + ": Too few arguments.");
 		
 		p_AST->setType(PCALL_LIB);
 		p_AST->setText("pcall_lib");
@@ -5465,12 +5468,20 @@
 	nParam = el_AST->GetNParam();
 	
 	int libParam = libFunList[i]->NPar();
+	int libParamMin = libFunList[i]->NParMin();
 	if( libParam != -1 && nParam > libParam)
 	throw GDLException(	aIn, libFunList[i]->Name() + ": Too many arguments.");
+	if( libParam != -1 && nParam < libParamMin)
+	throw GDLException(	aIn, libFunList[i]->Name() + ": Too few arguments.");
 	
 	id_AST->SetLibFun( libFunList[i]);
 	if( libFunList[ i]->RetNew())
 	{
+	if( libFunList[ i]->Name() == "N_ELEMENTS")
+	id_AST->setType( FCALL_LIB_N_ELEMENTS);
+	else if( libFunList[ i]->DirectCall())
+	id_AST->setType( FCALL_LIB_DIRECT);
+	else
 	id_AST->setType( FCALL_LIB_RETNEW);
 	arrayexpr_fn_AST =
 	RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(id_AST))->add(antlr::RefAST(el_AST))));
@@ -5810,11 +5821,18 @@
 		nParam = p_AST->GetNParam();
 		
 		int libParam = libFunList[i]->NPar();
+		int libParamMin = libFunList[i]->NParMin();
 		if( libParam != -1 && nParam > libParam)
 		throw GDLException(	f, libFunList[i]->Name() + ": Too many arguments.");
+		if( libParam != -1 && nParam < libParamMin)
+		throw GDLException(	f, libFunList[i]->Name() + ": Too few arguments.");
 		if( libFunList[ i]->RetNew())
 		{
-		
+		if( libFunList[ i]->Name() == "N_ELEMENTS")
+		f_AST->setType( FCALL_LIB_N_ELEMENTS);
+		else if( libFunList[ i]->DirectCall())
+		f_AST->setType( FCALL_LIB_DIRECT);
+		else
 		f_AST->setType(FCALL_LIB_RETNEW);
 		f_AST->setText(id_AST->getText());
 		f_AST->SetLibFun( libFunList[i]);
@@ -7060,7 +7078,7 @@
 
 void GDLTreeParser::initializeASTFactory( antlr::ASTFactory& factory )
 {
-	factory.setMaxNodeType(231);
+	factory.setMaxNodeType(233);
 }
 const char* GDLTreeParser::tokenNames[] = {
 	"<0>",
@@ -7103,6 +7121,8 @@
 	"FOREACH_INDEX_LOOP",
 	"FCALL",
 	"FCALL_LIB",
+	"FCALL_LIB_DIRECT",
+	"FCALL_LIB_N_ELEMENTS",
 	"FCALL_LIB_RETNEW",
 	"IF_ELSE",
 	"KEYDECL",
@@ -7298,7 +7318,7 @@
 	0
 };
 
-const unsigned long GDLTreeParser::_tokenSet_0_data_[] = { 1135607840UL, 268632065UL, 35661824UL, 18884864UL, 4194302UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLTreeParser::_tokenSet_0_data_[] = { 1135607840UL, 1074528257UL, 142647296UL, 75539456UL, 16777208UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // ASSIGN BLOCK BREAK CONTINUE COMMONDECL COMMONDEF "for" "foreach" MPCALL 
 // MPCALL_PARENT PCALL "repeat" RETURN "while" "case" "forward_function" 
 // "goto" "if" "on_ioerror" "switch" DEC INC AND_OP_EQ ASTERIX_EQ EQ_OP_EQ 
@@ -7306,7 +7326,7 @@
 // MATRIX_OP2_EQ MINUS_EQ MOD_OP_EQ NE_OP_EQ OR_OP_EQ PLUS_EQ POW_EQ SLASH_EQ 
 // XOR_OP_EQ 
 const antlr::BitSet GDLTreeParser::_tokenSet_0(_tokenSet_0_data_,12);
-const unsigned long GDLTreeParser::_tokenSet_1_data_[] = { 739116576UL, 69468224UL, 9371654UL, 139433088UL, 37748734UL, 0UL, 1048256UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
+const unsigned long GDLTreeParser::_tokenSet_1_data_[] = { 739116576UL, 277872704UL, 37486616UL, 557732352UL, 150994936UL, 0UL, 4193024UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL, 0UL };
 // ASSIGN ARRAYDEF ARRAYDEF_CONST ARRAYEXPR ARRAYEXPR_FN ARRAYEXPR_MFCALL 
 // CONSTANT DEREF EXPR FCALL MFCALL MFCALL_PARENT NSTRUC_REF POSTDEC POSTINC 
 // STRUC SYSVAR UMINUS VAR "and" "eq" "ge" "gt" "le" "lt" "mod" "ne" "not" 
diff -ruN --exclude CVS gdl-0.9.2/src/GDLTreeParser.hpp gdl/src/GDLTreeParser.hpp
--- gdl-0.9.2/src/GDLTreeParser.hpp	2011-11-07 16:38:21.000000000 -0700
+++ gdl/src/GDLTreeParser.hpp	2011-11-15 16:19:00.000000000 -0700
@@ -42,6 +42,7 @@
             lT == FCALL_LIB ||
 //            lT == FCALL_LIB_N_ELEMENTS ||
             lT == FCALL_LIB_RETNEW || 
+            lT == FCALL_LIB_DIRECT || 
             lT == MFCALL_LIB || 
             lT == MFCALL_LIB_RETNEW || 
             lT == MFCALL_PARENT_LIB ||
@@ -193,10 +194,10 @@
 private:
 	static const char* tokenNames[];
 #ifndef NO_STATIC_CONSTS
-	static const int NUM_TOKENS = 232;
+	static const int NUM_TOKENS = 234;
 #else
 	enum {
-		NUM_TOKENS = 232
+		NUM_TOKENS = 234
 	};
 #endif
 	
diff -ruN --exclude CVS gdl-0.9.2/src/GDLTreeParserTokenTypes.hpp gdl/src/GDLTreeParserTokenTypes.hpp
--- gdl-0.9.2/src/GDLTreeParserTokenTypes.hpp	2011-11-07 16:38:21.000000000 -0700
+++ gdl/src/GDLTreeParserTokenTypes.hpp	2011-11-15 16:19:00.000000000 -0700
@@ -48,198 +48,200 @@
 		FOREACH_INDEX_LOOP = 37,
 		FCALL = 38,
 		FCALL_LIB = 39,
-		FCALL_LIB_RETNEW = 40,
-		IF_ELSE = 41,
-		KEYDECL = 42,
-		KEYDEF = 43,
-		KEYDEF_REF = 44,
-		KEYDEF_REF_CHECK = 45,
-		KEYDEF_REF_EXPR = 46,
-		LABEL = 47,
-		MPCALL = 48,
-		MPCALL_PARENT = 49,
-		MFCALL = 50,
-		MFCALL_LIB = 51,
-		MFCALL_LIB_RETNEW = 52,
-		MFCALL_PARENT = 53,
-		MFCALL_PARENT_LIB = 54,
-		MFCALL_PARENT_LIB_RETNEW = 55,
-		NOP = 56,
-		NSTRUC = 57,
-		NSTRUC_REF = 58,
-		ON_IOERROR_NULL = 59,
-		PCALL = 60,
-		PCALL_LIB = 61,
-		PARADECL = 62,
-		PARAEXPR = 63,
-		PARAEXPR_VN = 64,
-		POSTDEC = 65,
-		POSTINC = 66,
-		DECSTATEMENT = 67,
-		INCSTATEMENT = 68,
-		REF = 69,
-		REF_VN = 70,
-		REF_CHECK = 71,
-		REF_CHECK_VN = 72,
-		REF_EXPR = 73,
-		REF_EXPR_VN = 74,
-		REPEAT = 75,
-		REPEAT_LOOP = 76,
-		RETURN = 77,
-		RETF = 78,
-		RETP = 79,
-		STRUC = 80,
-		SYSVAR = 81,
-		UMINUS = 82,
-		VAR = 83,
-		VARPTR = 84,
-		WHILE = 85,
-		IDENTIFIER = 86,
-		AND_OP = 87,
-		BEGIN = 88,
-		CASE = 89,
-		COMMON = 90,
-		COMPILE_OPT = 91,
-		DO = 92,
-		ELSE = 93,
-		END = 94,
-		ENDCASE = 95,
-		ENDELSE = 96,
-		ENDFOR = 97,
-		ENDFOREACH = 98,
-		ENDIF = 99,
-		ENDREP = 100,
-		ENDSWITCH = 101,
-		ENDWHILE = 102,
-		EQ_OP = 103,
-		FORWARD = 104,
-		FUNCTION = 105,
-		GE_OP = 106,
-		GOTO = 107,
-		GT_OP = 108,
-		IF = 109,
-		INHERITS = 110,
-		LE_OP = 111,
-		LT_OP = 112,
-		MOD_OP = 113,
-		NE_OP = 114,
-		NOT_OP = 115,
-		OF = 116,
-		ON_IOERROR = 117,
-		OR_OP = 118,
-		PRO = 119,
-		SWITCH = 120,
-		THEN = 121,
-		UNTIL = 122,
-		XOR_OP = 123,
-		METHOD = 124,
-		COMMA = 125,
-		COLON = 126,
-		END_U = 127,
-		EQUAL = 128,
-		DEC = 129,
-		INC = 130,
-		AND_OP_EQ = 131,
-		ASTERIX_EQ = 132,
-		EQ_OP_EQ = 133,
-		GE_OP_EQ = 134,
-		GTMARK_EQ = 135,
-		GT_OP_EQ = 136,
-		LE_OP_EQ = 137,
-		LTMARK_EQ = 138,
-		LT_OP_EQ = 139,
-		MATRIX_OP1_EQ = 140,
-		MATRIX_OP2_EQ = 141,
-		MINUS_EQ = 142,
-		MOD_OP_EQ = 143,
-		NE_OP_EQ = 144,
-		OR_OP_EQ = 145,
-		PLUS_EQ = 146,
-		POW_EQ = 147,
-		SLASH_EQ = 148,
-		XOR_OP_EQ = 149,
-		MEMBER = 150,
-		LBRACE = 151,
-		RBRACE = 152,
-		SLASH = 153,
-		LSQUARE = 154,
-		RSQUARE = 155,
-		SYSVARNAME = 156,
-		EXCLAMATION = 157,
-		LCURLY = 158,
-		RCURLY = 159,
-		CONSTANT_HEX_BYTE = 160,
-		CONSTANT_HEX_LONG = 161,
-		CONSTANT_HEX_LONG64 = 162,
-		CONSTANT_HEX_INT = 163,
-		CONSTANT_HEX_I = 164,
-		CONSTANT_HEX_ULONG = 165,
-		CONSTANT_HEX_ULONG64 = 166,
-		CONSTANT_HEX_UI = 167,
-		CONSTANT_HEX_UINT = 168,
-		CONSTANT_BYTE = 169,
-		CONSTANT_LONG = 170,
-		CONSTANT_LONG64 = 171,
-		CONSTANT_INT = 172,
-		CONSTANT_I = 173,
-		CONSTANT_ULONG = 174,
-		CONSTANT_ULONG64 = 175,
-		CONSTANT_UI = 176,
-		CONSTANT_UINT = 177,
-		CONSTANT_OCT_BYTE = 178,
-		CONSTANT_OCT_LONG = 179,
-		CONSTANT_OCT_LONG64 = 180,
-		CONSTANT_OCT_INT = 181,
-		CONSTANT_OCT_I = 182,
-		CONSTANT_OCT_ULONG = 183,
-		CONSTANT_OCT_ULONG64 = 184,
-		CONSTANT_OCT_UI = 185,
-		CONSTANT_OCT_UINT = 186,
-		CONSTANT_FLOAT = 187,
-		CONSTANT_DOUBLE = 188,
-		CONSTANT_BIN_BYTE = 189,
-		CONSTANT_BIN_LONG = 190,
-		CONSTANT_BIN_LONG64 = 191,
-		CONSTANT_BIN_INT = 192,
-		CONSTANT_BIN_I = 193,
-		CONSTANT_BIN_ULONG = 194,
-		CONSTANT_BIN_ULONG64 = 195,
-		CONSTANT_BIN_UI = 196,
-		CONSTANT_BIN_UINT = 197,
-		ASTERIX = 198,
-		DOT = 199,
-		STRING_LITERAL = 200,
-		POW = 201,
-		MATRIX_OP1 = 202,
-		MATRIX_OP2 = 203,
-		PLUS = 204,
-		MINUS = 205,
-		LTMARK = 206,
-		GTMARK = 207,
-		LOG_NEG = 208,
-		LOG_AND = 209,
-		LOG_OR = 210,
-		QUESTION = 211,
-		STRING = 212,
-		INCLUDE = 213,
-		EOL = 214,
-		W = 215,
-		D = 216,
-		L = 217,
-		H = 218,
-		O = 219,
-		B = 220,
-		EXP = 221,
-		DBL_E = 222,
-		DBL = 223,
-		CONSTANT_OR_STRING_LITERAL = 224,
-		COMMENT = 225,
-		END_MARKER = 226,
-		WHITESPACE = 227,
-		SKIP_LINES = 228,
-		CONT_STATEMENT = 229,
-		END_OF_LINE = 230,
-		MAX_TOKEN_NUMBER = 231,
+		FCALL_LIB_DIRECT = 40,
+		FCALL_LIB_N_ELEMENTS = 41,
+		FCALL_LIB_RETNEW = 42,
+		IF_ELSE = 43,
+		KEYDECL = 44,
+		KEYDEF = 45,
+		KEYDEF_REF = 46,
+		KEYDEF_REF_CHECK = 47,
+		KEYDEF_REF_EXPR = 48,
+		LABEL = 49,
+		MPCALL = 50,
+		MPCALL_PARENT = 51,
+		MFCALL = 52,
+		MFCALL_LIB = 53,
+		MFCALL_LIB_RETNEW = 54,
+		MFCALL_PARENT = 55,
+		MFCALL_PARENT_LIB = 56,
+		MFCALL_PARENT_LIB_RETNEW = 57,
+		NOP = 58,
+		NSTRUC = 59,
+		NSTRUC_REF = 60,
+		ON_IOERROR_NULL = 61,
+		PCALL = 62,
+		PCALL_LIB = 63,
+		PARADECL = 64,
+		PARAEXPR = 65,
+		PARAEXPR_VN = 66,
+		POSTDEC = 67,
+		POSTINC = 68,
+		DECSTATEMENT = 69,
+		INCSTATEMENT = 70,
+		REF = 71,
+		REF_VN = 72,
+		REF_CHECK = 73,
+		REF_CHECK_VN = 74,
+		REF_EXPR = 75,
+		REF_EXPR_VN = 76,
+		REPEAT = 77,
+		REPEAT_LOOP = 78,
+		RETURN = 79,
+		RETF = 80,
+		RETP = 81,
+		STRUC = 82,
+		SYSVAR = 83,
+		UMINUS = 84,
+		VAR = 85,
+		VARPTR = 86,
+		WHILE = 87,
+		IDENTIFIER = 88,
+		AND_OP = 89,
+		BEGIN = 90,
+		CASE = 91,
+		COMMON = 92,
+		COMPILE_OPT = 93,
+		DO = 94,
+		ELSE = 95,
+		END = 96,
+		ENDCASE = 97,
+		ENDELSE = 98,
+		ENDFOR = 99,
+		ENDFOREACH = 100,
+		ENDIF = 101,
+		ENDREP = 102,
+		ENDSWITCH = 103,
+		ENDWHILE = 104,
+		EQ_OP = 105,
+		FORWARD = 106,
+		FUNCTION = 107,
+		GE_OP = 108,
+		GOTO = 109,
+		GT_OP = 110,
+		IF = 111,
+		INHERITS = 112,
+		LE_OP = 113,
+		LT_OP = 114,
+		MOD_OP = 115,
+		NE_OP = 116,
+		NOT_OP = 117,
+		OF = 118,
+		ON_IOERROR = 119,
+		OR_OP = 120,
+		PRO = 121,
+		SWITCH = 122,
+		THEN = 123,
+		UNTIL = 124,
+		XOR_OP = 125,
+		METHOD = 126,
+		COMMA = 127,
+		COLON = 128,
+		END_U = 129,
+		EQUAL = 130,
+		DEC = 131,
+		INC = 132,
+		AND_OP_EQ = 133,
+		ASTERIX_EQ = 134,
+		EQ_OP_EQ = 135,
+		GE_OP_EQ = 136,
+		GTMARK_EQ = 137,
+		GT_OP_EQ = 138,
+		LE_OP_EQ = 139,
+		LTMARK_EQ = 140,
+		LT_OP_EQ = 141,
+		MATRIX_OP1_EQ = 142,
+		MATRIX_OP2_EQ = 143,
+		MINUS_EQ = 144,
+		MOD_OP_EQ = 145,
+		NE_OP_EQ = 146,
+		OR_OP_EQ = 147,
+		PLUS_EQ = 148,
+		POW_EQ = 149,
+		SLASH_EQ = 150,
+		XOR_OP_EQ = 151,
+		MEMBER = 152,
+		LBRACE = 153,
+		RBRACE = 154,
+		SLASH = 155,
+		LSQUARE = 156,
+		RSQUARE = 157,
+		SYSVARNAME = 158,
+		EXCLAMATION = 159,
+		LCURLY = 160,
+		RCURLY = 161,
+		CONSTANT_HEX_BYTE = 162,
+		CONSTANT_HEX_LONG = 163,
+		CONSTANT_HEX_LONG64 = 164,
+		CONSTANT_HEX_INT = 165,
+		CONSTANT_HEX_I = 166,
+		CONSTANT_HEX_ULONG = 167,
+		CONSTANT_HEX_ULONG64 = 168,
+		CONSTANT_HEX_UI = 169,
+		CONSTANT_HEX_UINT = 170,
+		CONSTANT_BYTE = 171,
+		CONSTANT_LONG = 172,
+		CONSTANT_LONG64 = 173,
+		CONSTANT_INT = 174,
+		CONSTANT_I = 175,
+		CONSTANT_ULONG = 176,
+		CONSTANT_ULONG64 = 177,
+		CONSTANT_UI = 178,
+		CONSTANT_UINT = 179,
+		CONSTANT_OCT_BYTE = 180,
+		CONSTANT_OCT_LONG = 181,
+		CONSTANT_OCT_LONG64 = 182,
+		CONSTANT_OCT_INT = 183,
+		CONSTANT_OCT_I = 184,
+		CONSTANT_OCT_ULONG = 185,
+		CONSTANT_OCT_ULONG64 = 186,
+		CONSTANT_OCT_UI = 187,
+		CONSTANT_OCT_UINT = 188,
+		CONSTANT_FLOAT = 189,
+		CONSTANT_DOUBLE = 190,
+		CONSTANT_BIN_BYTE = 191,
+		CONSTANT_BIN_LONG = 192,
+		CONSTANT_BIN_LONG64 = 193,
+		CONSTANT_BIN_INT = 194,
+		CONSTANT_BIN_I = 195,
+		CONSTANT_BIN_ULONG = 196,
+		CONSTANT_BIN_ULONG64 = 197,
+		CONSTANT_BIN_UI = 198,
+		CONSTANT_BIN_UINT = 199,
+		ASTERIX = 200,
+		DOT = 201,
+		STRING_LITERAL = 202,
+		POW = 203,
+		MATRIX_OP1 = 204,
+		MATRIX_OP2 = 205,
+		PLUS = 206,
+		MINUS = 207,
+		LTMARK = 208,
+		GTMARK = 209,
+		LOG_NEG = 210,
+		LOG_AND = 211,
+		LOG_OR = 212,
+		QUESTION = 213,
+		STRING = 214,
+		INCLUDE = 215,
+		EOL = 216,
+		W = 217,
+		D = 218,
+		L = 219,
+		H = 220,
+		O = 221,
+		B = 222,
+		EXP = 223,
+		DBL_E = 224,
+		DBL = 225,
+		CONSTANT_OR_STRING_LITERAL = 226,
+		COMMENT = 227,
+		END_MARKER = 228,
+		WHITESPACE = 229,
+		SKIP_LINES = 230,
+		CONT_STATEMENT = 231,
+		END_OF_LINE = 232,
+		MAX_TOKEN_NUMBER = 233,
 		NULL_TREE_LOOKAHEAD = 3
 	};
 #ifdef __cplusplus
diff -ruN --exclude CVS gdl-0.9.2/src/GDLTreeParserTokenTypes.txt gdl/src/GDLTreeParserTokenTypes.txt
--- gdl-0.9.2/src/GDLTreeParserTokenTypes.txt	2011-11-07 16:38:21.000000000 -0700
+++ gdl/src/GDLTreeParserTokenTypes.txt	2011-11-15 16:19:00.000000000 -0700
@@ -36,195 +36,197 @@
 FOREACH_INDEX_LOOP=37
 FCALL=38
 FCALL_LIB=39
-FCALL_LIB_RETNEW=40
-IF_ELSE=41
-KEYDECL=42
-KEYDEF=43
-KEYDEF_REF=44
-KEYDEF_REF_CHECK=45
-KEYDEF_REF_EXPR=46
-LABEL=47
-MPCALL=48
-MPCALL_PARENT=49
-MFCALL=50
-MFCALL_LIB=51
-MFCALL_LIB_RETNEW=52
-MFCALL_PARENT=53
-MFCALL_PARENT_LIB=54
-MFCALL_PARENT_LIB_RETNEW=55
-NOP=56
-NSTRUC=57
-NSTRUC_REF=58
-ON_IOERROR_NULL=59
-PCALL=60
-PCALL_LIB=61
-PARADECL=62
-PARAEXPR=63
-PARAEXPR_VN=64
-POSTDEC=65
-POSTINC=66
-DECSTATEMENT=67
-INCSTATEMENT=68
-REF=69
-REF_VN=70
-REF_CHECK=71
-REF_CHECK_VN=72
-REF_EXPR=73
-REF_EXPR_VN=74
-REPEAT="repeat"=75
-REPEAT_LOOP=76
-RETURN=77
-RETF=78
-RETP=79
-STRUC=80
-SYSVAR=81
-UMINUS=82
-VAR=83
-VARPTR=84
-WHILE="while"=85
-IDENTIFIER=86
-AND_OP="and"=87
-BEGIN="begin"=88
-CASE="case"=89
-COMMON="common"=90
-COMPILE_OPT="compile_opt"=91
-DO="do"=92
-ELSE="else"=93
-END="end"=94
-ENDCASE="endcase"=95
-ENDELSE="endelse"=96
-ENDFOR="endfor"=97
-ENDFOREACH="endforeach"=98
-ENDIF="endif"=99
-ENDREP="endrep"=100
-ENDSWITCH="endswitch"=101
-ENDWHILE="endwhile"=102
-EQ_OP="eq"=103
-FORWARD="forward_function"=104
-FUNCTION="function"=105
-GE_OP="ge"=106
-GOTO="goto"=107
-GT_OP="gt"=108
-IF="if"=109
-INHERITS="inherits"=110
-LE_OP="le"=111
-LT_OP="lt"=112
-MOD_OP="mod"=113
-NE_OP="ne"=114
-NOT_OP="not"=115
-OF="of"=116
-ON_IOERROR="on_ioerror"=117
-OR_OP="or"=118
-PRO="pro"=119
-SWITCH="switch"=120
-THEN="then"=121
-UNTIL="until"=122
-XOR_OP="xor"=123
-METHOD=124
-COMMA=125
-COLON=126
-END_U=127
-EQUAL=128
-DEC=129
-INC=130
-AND_OP_EQ=131
-ASTERIX_EQ=132
-EQ_OP_EQ=133
-GE_OP_EQ=134
-GTMARK_EQ=135
-GT_OP_EQ=136
-LE_OP_EQ=137
-LTMARK_EQ=138
-LT_OP_EQ=139
-MATRIX_OP1_EQ=140
-MATRIX_OP2_EQ=141
-MINUS_EQ=142
-MOD_OP_EQ=143
-NE_OP_EQ=144
-OR_OP_EQ=145
-PLUS_EQ=146
-POW_EQ=147
-SLASH_EQ=148
-XOR_OP_EQ=149
-MEMBER=150
-LBRACE=151
-RBRACE=152
-SLASH=153
-LSQUARE=154
-RSQUARE=155
-SYSVARNAME=156
-EXCLAMATION=157
-LCURLY=158
-RCURLY=159
-CONSTANT_HEX_BYTE=160
-CONSTANT_HEX_LONG=161
-CONSTANT_HEX_LONG64=162
-CONSTANT_HEX_INT=163
-CONSTANT_HEX_I=164
-CONSTANT_HEX_ULONG=165
-CONSTANT_HEX_ULONG64=166
-CONSTANT_HEX_UI=167
-CONSTANT_HEX_UINT=168
-CONSTANT_BYTE=169
-CONSTANT_LONG=170
-CONSTANT_LONG64=171
-CONSTANT_INT=172
-CONSTANT_I=173
-CONSTANT_ULONG=174
-CONSTANT_ULONG64=175
-CONSTANT_UI=176
-CONSTANT_UINT=177
-CONSTANT_OCT_BYTE=178
-CONSTANT_OCT_LONG=179
-CONSTANT_OCT_LONG64=180
-CONSTANT_OCT_INT=181
-CONSTANT_OCT_I=182
-CONSTANT_OCT_ULONG=183
-CONSTANT_OCT_ULONG64=184
-CONSTANT_OCT_UI=185
-CONSTANT_OCT_UINT=186
-CONSTANT_FLOAT=187
-CONSTANT_DOUBLE=188
-CONSTANT_BIN_BYTE=189
-CONSTANT_BIN_LONG=190
-CONSTANT_BIN_LONG64=191
-CONSTANT_BIN_INT=192
-CONSTANT_BIN_I=193
-CONSTANT_BIN_ULONG=194
-CONSTANT_BIN_ULONG64=195
-CONSTANT_BIN_UI=196
-CONSTANT_BIN_UINT=197
-ASTERIX=198
-DOT=199
-STRING_LITERAL=200
-POW=201
-MATRIX_OP1=202
-MATRIX_OP2=203
-PLUS=204
-MINUS=205
-LTMARK=206
-GTMARK=207
-LOG_NEG=208
-LOG_AND=209
-LOG_OR=210
-QUESTION=211
-STRING=212
-INCLUDE=213
-EOL=214
-W=215
-D=216
-L=217
-H=218
-O=219
-B=220
-EXP=221
-DBL_E=222
-DBL=223
-CONSTANT_OR_STRING_LITERAL=224
-COMMENT=225
-END_MARKER=226
-WHITESPACE=227
-SKIP_LINES=228
-CONT_STATEMENT=229
-END_OF_LINE=230
-MAX_TOKEN_NUMBER=231
+FCALL_LIB_DIRECT=40
+FCALL_LIB_N_ELEMENTS=41
+FCALL_LIB_RETNEW=42
+IF_ELSE=43
+KEYDECL=44
+KEYDEF=45
+KEYDEF_REF=46
+KEYDEF_REF_CHECK=47
+KEYDEF_REF_EXPR=48
+LABEL=49
+MPCALL=50
+MPCALL_PARENT=51
+MFCALL=52
+MFCALL_LIB=53
+MFCALL_LIB_RETNEW=54
+MFCALL_PARENT=55
+MFCALL_PARENT_LIB=56
+MFCALL_PARENT_LIB_RETNEW=57
+NOP=58
+NSTRUC=59
+NSTRUC_REF=60
+ON_IOERROR_NULL=61
+PCALL=62
+PCALL_LIB=63
+PARADECL=64
+PARAEXPR=65
+PARAEXPR_VN=66
+POSTDEC=67
+POSTINC=68
+DECSTATEMENT=69
+INCSTATEMENT=70
+REF=71
+REF_VN=72
+REF_CHECK=73
+REF_CHECK_VN=74
+REF_EXPR=75
+REF_EXPR_VN=76
+REPEAT="repeat"=77
+REPEAT_LOOP=78
+RETURN=79
+RETF=80
+RETP=81
+STRUC=82
+SYSVAR=83
+UMINUS=84
+VAR=85
+VARPTR=86
+WHILE="while"=87
+IDENTIFIER=88
+AND_OP="and"=89
+BEGIN="begin"=90
+CASE="case"=91
+COMMON="common"=92
+COMPILE_OPT="compile_opt"=93
+DO="do"=94
+ELSE="else"=95
+END="end"=96
+ENDCASE="endcase"=97
+ENDELSE="endelse"=98
+ENDFOR="endfor"=99
+ENDFOREACH="endforeach"=100
+ENDIF="endif"=101
+ENDREP="endrep"=102
+ENDSWITCH="endswitch"=103
+ENDWHILE="endwhile"=104
+EQ_OP="eq"=105
+FORWARD="forward_function"=106
+FUNCTION="function"=107
+GE_OP="ge"=108
+GOTO="goto"=109
+GT_OP="gt"=110
+IF="if"=111
+INHERITS="inherits"=112
+LE_OP="le"=113
+LT_OP="lt"=114
+MOD_OP="mod"=115
+NE_OP="ne"=116
+NOT_OP="not"=117
+OF="of"=118
+ON_IOERROR="on_ioerror"=119
+OR_OP="or"=120
+PRO="pro"=121
+SWITCH="switch"=122
+THEN="then"=123
+UNTIL="until"=124
+XOR_OP="xor"=125
+METHOD=126
+COMMA=127
+COLON=128
+END_U=129
+EQUAL=130
+DEC=131
+INC=132
+AND_OP_EQ=133
+ASTERIX_EQ=134
+EQ_OP_EQ=135
+GE_OP_EQ=136
+GTMARK_EQ=137
+GT_OP_EQ=138
+LE_OP_EQ=139
+LTMARK_EQ=140
+LT_OP_EQ=141
+MATRIX_OP1_EQ=142
+MATRIX_OP2_EQ=143
+MINUS_EQ=144
+MOD_OP_EQ=145
+NE_OP_EQ=146
+OR_OP_EQ=147
+PLUS_EQ=148
+POW_EQ=149
+SLASH_EQ=150
+XOR_OP_EQ=151
+MEMBER=152
+LBRACE=153
+RBRACE=154
+SLASH=155
+LSQUARE=156
+RSQUARE=157
+SYSVARNAME=158
+EXCLAMATION=159
+LCURLY=160
+RCURLY=161
+CONSTANT_HEX_BYTE=162
+CONSTANT_HEX_LONG=163
+CONSTANT_HEX_LONG64=164
+CONSTANT_HEX_INT=165
+CONSTANT_HEX_I=166
+CONSTANT_HEX_ULONG=167
+CONSTANT_HEX_ULONG64=168
+CONSTANT_HEX_UI=169
+CONSTANT_HEX_UINT=170
+CONSTANT_BYTE=171
+CONSTANT_LONG=172
+CONSTANT_LONG64=173
+CONSTANT_INT=174
+CONSTANT_I=175
+CONSTANT_ULONG=176
+CONSTANT_ULONG64=177
+CONSTANT_UI=178
+CONSTANT_UINT=179
+CONSTANT_OCT_BYTE=180
+CONSTANT_OCT_LONG=181
+CONSTANT_OCT_LONG64=182
+CONSTANT_OCT_INT=183
+CONSTANT_OCT_I=184
+CONSTANT_OCT_ULONG=185
+CONSTANT_OCT_ULONG64=186
+CONSTANT_OCT_UI=187
+CONSTANT_OCT_UINT=188
+CONSTANT_FLOAT=189
+CONSTANT_DOUBLE=190
+CONSTANT_BIN_BYTE=191
+CONSTANT_BIN_LONG=192
+CONSTANT_BIN_LONG64=193
+CONSTANT_BIN_INT=194
+CONSTANT_BIN_I=195
+CONSTANT_BIN_ULONG=196
+CONSTANT_BIN_ULONG64=197
+CONSTANT_BIN_UI=198
+CONSTANT_BIN_UINT=199
+ASTERIX=200
+DOT=201
+STRING_LITERAL=202
+POW=203
+MATRIX_OP1=204
+MATRIX_OP2=205
+PLUS=206
+MINUS=207
+LTMARK=208
+GTMARK=209
+LOG_NEG=210
+LOG_AND=211
+LOG_OR=212
+QUESTION=213
+STRING=214
+INCLUDE=215
+EOL=216
+W=217
+D=218
+L=219
+H=220
+O=221
+B=222
+EXP=223
+DBL_E=224
+DBL=225
+CONSTANT_OR_STRING_LITERAL=226
+COMMENT=227
+END_MARKER=228
+WHITESPACE=229
+SKIP_LINES=230
+CONT_STATEMENT=231
+END_OF_LINE=232
+MAX_TOKEN_NUMBER=233
diff -ruN --exclude CVS gdl-0.9.2/src/gdlwidget.cpp gdl/src/gdlwidget.cpp
--- gdl-0.9.2/src/gdlwidget.cpp	2010-11-15 16:06:48.000000000 -0700
+++ gdl/src/gdlwidget.cpp	2012-07-02 03:09:10.000000000 -0600
@@ -626,7 +626,7 @@
     wxString *choices = new wxString[n];
     for( SizeT i=0; i<n; ++i) choices[i] = wxString((*val)[i].c_str(), wxConvUTF8);
 
-    combo = new wxComboBox( panel, widgetID, wxString( choices[0].c_str(), wxConvUTF8),
+    combo = new wxComboBox( panel, widgetID, wxString( (const wchar_t*) choices[0].c_str(), wxConvUTF8),
 			    wxDefaultPosition, wxDefaultSize,
 			    n, choices, style);
 
@@ -769,15 +769,18 @@
 
     int proIx = ProIx( eventHandler); 
     DSub *sub =  proList[ proIx];
-    EnvBaseT* e;
-    e = new EnvUDT( NULL, sub);
-    std::auto_ptr< EnvBaseT> e_guard( e);
-    StackSizeGuard<EnvStackT> guard( GDLInterpreter::CallStack());
-    GDLInterpreter::CallStack().push_back( e);
-
-    EnvBaseT* caller;
-    caller = e->Caller();
-    e->Interpreter()->CallStack().pop_back();
+//     EnvUDT* e;
+//     e = new EnvUDT( NULL, sub);
+//     std::auto_ptr< EnvUDT> e_guard( e);
+//     StackSizeGuard<EnvStackT> guard( GDLInterpreter::CallStack());
+//     GDLInterpreter::CallStack().push_back( e);
+
+	// TODO: MS: if the only purpose of e is to get the caller:
+	// EnvBaseT* caller = GDLInterpreter::CallStack().back(); is sufficient
+// ms: commented out to comply with new stack handling
+    EnvBaseT* caller = GDLInterpreter::CallStackBack();
+//     caller = e->Caller();
+//     e->Interpreter()->CallStack().pop_back();
 
     DLong id, top, handler, select;
     id = (*static_cast<DLongGDL*>
diff -ruN --exclude CVS gdl-0.9.2/src/gdlxstream.cpp gdl/src/gdlxstream.cpp
--- gdl-0.9.2/src/gdlxstream.cpp	2010-06-11 09:09:51.000000000 -0600
+++ gdl/src/gdlxstream.cpp	2012-01-26 16:21:14.000000000 -0700
@@ -171,12 +171,13 @@
   r1 = (PLINT) rb;
   g1 = (PLINT) gb;
   b1 = (PLINT) bb;
-
+// this mimics better the *DL behaviour.
+  ::c_plbop();
   plscolbg (r1, g1, b1);
 
-  ::c_plclear();
-
-  plscolbg (r0, g0, b0);
+//  ::c_plclear();
+//
+//  plscolbg (r0, g0, b0);
 }
 
 void GDLXStream::Raise()
diff -ruN --exclude CVS gdl-0.9.2/src/getas.cpp gdl/src/getas.cpp
--- gdl-0.9.2/src/getas.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/getas.cpp	2011-11-14 05:03:49.000000000 -0700
@@ -0,0 +1,553 @@
+/***************************************************************************
+                          getas.cpp  -  get element as different type
+                             -------------------
+    begin                : July 22 2002
+    copyright            : (C) 2002 by Marc Schellens
+    email                : m_schellens@users.sf.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+// to be included from datatypes.cpp
+#ifdef INCLUDE_GETAS_CPP
+
+// #include "includefirst.hpp"
+// //#include "datatypes.hpp"
+// #include "dstructgdl.hpp"
+// #include "real2int.hpp"
+#include "ofmt.hpp" // OutAuto
+// 
+// #include "dinterpreter.hpp"
+
+using namespace std;
+
+// for double -> string
+inline string double2string( DDouble d)      
+{
+  std::ostringstream os;
+  OutAuto( os, d, 16, 8, ' ');
+  return os.str();
+}
+
+// for float -> string
+inline string float2string( DFloat f)      
+{
+  std::ostringstream os;
+  OutAuto( os, f, 13, 6, ' ');
+  return os.str();
+}
+
+
+
+// typedef Data_<SpDByte>       DByteGDL;
+// typedef Data_<SpDInt>        DIntGDL;
+// typedef Data_<SpDUInt>       DUIntGDL;
+// typedef Data_<SpDLong>       DLongGDL;
+// typedef Data_<SpDULong>      DULongGDL;
+// typedef Data_<SpDLong64>     DLong64GDL;
+// typedef Data_<SpDULong64>    DULong64GDL;
+// typedef Data_<SpDFloat>      DFloatGDL;
+// typedef Data_<SpDDouble>     DDoubleGDL;
+// typedef Data_<SpDString>     DStringGDL;
+// typedef Data_<SpDPtr>        DPtrGDL;
+// typedef Data_<SpDObj>        DObjGDL;
+// typedef Data_<SpDComplex>    DComplexGDL;
+// typedef Data_<SpDComplexDbl> DComplexDblGDL;
+
+
+// general case
+template<class Sp>
+template<class To> 
+typename Data_<To>::Ty Data_<Sp>::GetAs( SizeT i)
+  {
+    return this->dd[ i];
+  }
+
+// non convertable types
+// DPtrGDL specialization  
+template<>
+template<class To> 
+typename Data_<To>::Ty Data_<SpDPtr>::GetAs( SizeT i)
+  {
+  if(BaseGDL::interpreter!=NULL&&BaseGDL::interpreter->CallStack().size()>0) 
+      BaseGDL::interpreter->CallStack().back()->Throw("Ptr expression not allowed in this context: "+BaseGDL::interpreter->Name(this));
+  throw GDLException("Ptr expression not allowed in this context.");
+  }
+// DObjGDL specialization  
+template<>
+template<class To> 
+typename Data_<To>::Ty Data_<SpDObj>::GetAs( SizeT i)
+  {
+  if(BaseGDL::interpreter!=NULL&&BaseGDL::interpreter->CallStack().size()>0) 
+    BaseGDL::interpreter->CallStack().back()->Throw("Object expression not allowed in this context: "+BaseGDL::interpreter->Name(this));
+  throw GDLException("Object expression not allowed in this context.");
+  }
+// DStructGDL   
+template<class To> 
+typename Data_<To>::Ty DStructGDL::GetAs( SizeT i)
+  {
+  if(BaseGDL::interpreter!=NULL&&BaseGDL::interpreter->CallStack().size()>0)
+    BaseGDL::interpreter->CallStack().back()->Throw("Struct expression not allowed in this context: "+BaseGDL::interpreter->Name(this));
+  throw GDLException("Struct expression not allowed in this context.");
+  }
+
+// Ptr, Obj, Struct: GetAs throws
+// The operators are overloaded for these types, they throw
+// hence GetAs<SpDPtr>( SizeT i) is never called and does not need to be overloaded
+  
+// integer types  
+// DByteGDL full specializations  
+template<>
+template<> 
+/*typename*/ Data_<SpDString>::Ty Data_<SpDByte>::GetAs<SpDString>( SizeT i)
+  {
+    return i2s<>(this->dd[ i],4);
+  }
+// DIntGDL full specializations  
+template<>
+template<> 
+/*typename*/ Data_<SpDString>::Ty Data_<SpDInt>::GetAs<SpDString>( SizeT i)
+  {
+    return i2s<>(this->dd[ i],8);
+  }
+// DUIntGDL full specializations  
+template<>
+template<> 
+/*typename*/ Data_<SpDString>::Ty Data_<SpDUInt>::GetAs<SpDString>( SizeT i)
+  {
+    return i2s<>(this->dd[ i],8);
+  }
+// DLongGDL full specializations  
+template<>
+template<> 
+/*typename*/ Data_<SpDString>::Ty Data_<SpDLong>::GetAs<SpDString>( SizeT i)
+  {
+    return i2s<>(this->dd[ i],12);
+  }
+// DULongGDL full specializations  
+template<>
+template<> 
+/*typename*/ Data_<SpDString>::Ty Data_<SpDULong>::GetAs<SpDString>( SizeT i)
+  {
+    return i2s<>(this->dd[ i],12);
+  }
+// DLong64GDL full specializations  
+template<>
+template<> 
+/*typename*/ Data_<SpDString>::Ty Data_<SpDLong64>::GetAs<SpDString>( SizeT i)
+  {
+    return i2s<>(this->dd[ i],22);
+  }
+// DULong64GDL full specializations  
+template<>
+template<> 
+/*typename*/ Data_<SpDString>::Ty Data_<SpDULong64>::GetAs<SpDString>( SizeT i)
+  {
+    return i2s<>(this->dd[ i],22);
+  }
+
+  
+// DFloatGDL full specializations  
+template<>
+template<> 
+/*typename*/ Data_<SpDByte>::Ty Data_<SpDFloat>::GetAs<SpDByte>( SizeT i)
+  {
+    return Real2DByte<float>((*this)[i]);
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDInt>::Ty Data_<SpDFloat>::GetAs<SpDInt>( SizeT i)
+  {
+    return Real2Int<DInt,float>((*this)[i]);
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDUInt>::Ty Data_<SpDFloat>::GetAs<SpDUInt>( SizeT i)
+  {
+    return static_cast< DUInt>((*this)[i]);
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDLong>::Ty Data_<SpDFloat>::GetAs<SpDLong>( SizeT i)
+  {
+    return Real2Int<DLong,float>((*this)[i]);
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDLong64>::Ty Data_<SpDFloat>::GetAs<SpDLong64>( SizeT i)
+  {
+    return Real2Int<DLong64,float>((*this)[i]);
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDULong>::Ty Data_<SpDFloat>::GetAs<SpDULong>( SizeT i)
+  {
+    return static_cast< DULong>((*this)[i]);
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDULong64>::Ty Data_<SpDFloat>::GetAs<SpDULong64>( SizeT i)
+  {
+    return static_cast< DULong64>((*this)[i]);
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDString>::Ty Data_<SpDFloat>::GetAs<SpDString>( SizeT i)
+  {
+    return float2string((*this)[i]);
+  }
+  
+  
+  
+// DDoubleGDL full specializations  
+template<>
+template<> 
+/*typename*/ Data_<SpDByte>::Ty Data_<SpDDouble>::GetAs<SpDByte>( SizeT i)
+  {
+    return Real2DByte<double>((*this)[i]);
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDInt>::Ty Data_<SpDDouble>::GetAs<SpDInt>( SizeT i)
+  {
+    return Real2Int<DInt,double>((*this)[i]);
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDUInt>::Ty Data_<SpDDouble>::GetAs<SpDUInt>( SizeT i)
+  {
+    return static_cast< DUInt>((*this)[i]);
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDLong>::Ty Data_<SpDDouble>::GetAs<SpDLong>( SizeT i)
+  {
+    return Real2Int<DLong,double>((*this)[i]);
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDLong64>::Ty Data_<SpDDouble>::GetAs<SpDLong64>( SizeT i)
+  {
+    return Real2Int<DLong64,double>((*this)[i]);
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDULong>::Ty Data_<SpDDouble>::GetAs<SpDULong>( SizeT i)
+  {
+    return static_cast< DULong>((*this)[i]);
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDULong64>::Ty Data_<SpDDouble>::GetAs<SpDULong64>( SizeT i)
+  {
+    return static_cast< DULong64>((*this)[i]);
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDString>::Ty Data_<SpDDouble>::GetAs<SpDString>( SizeT i)
+  {
+    return double2string((*this)[i]);
+  }
+  
+
+// DStringGDL full specializations  
+inline void StringConversionErrorGetAs( const string& msg)
+{
+//   if( (mode & BaseGDL::THROWIOERROR) != 0)
+//   {
+//     errorFlag = true;
+//   }
+//   else
+    Warning( msg);
+}
+
+template<>
+template<> 
+/*typename*/ Data_<SpDByte>::Ty Data_<SpDString>::GetAs<SpDByte>( SizeT i)
+  {
+    const char* cStart=(*this)[i].c_str();
+    char* cEnd;
+    long int result =strtol(cStart,&cEnd,10);
+    if( cEnd == cStart && (*this)[i] != "")
+    {
+      StringConversionErrorGetAs( "Type conversion error: "
+      "Unable to convert given STRING: '"+(*this)[i]+"' to BYTE.");
+    }
+    return result;
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDInt>::Ty Data_<SpDString>::GetAs<SpDInt>( SizeT i)
+  {
+    const char* cStart=(*this)[i].c_str();
+    char* cEnd;
+    long int result =strtol(cStart,&cEnd,10);
+    if( cEnd == cStart && (*this)[i] != "")
+    {
+      StringConversionErrorGetAs( "Type conversion error: "
+      "Unable to convert given STRING: '"+(*this)[i]+"' to INT.");
+    }
+    return result;
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDUInt>::Ty Data_<SpDString>::GetAs<SpDUInt>( SizeT i)
+  {
+    const char* cStart=(*this)[i].c_str();
+    char* cEnd;
+    unsigned long int result =strtoul(cStart,&cEnd,10);
+    if( cEnd == cStart && (*this)[i] != "")
+    {
+      StringConversionErrorGetAs( "Type conversion error: "
+      "Unable to convert given STRING: '"+(*this)[i]+"' to UINT.");
+    }
+    return result;
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDLong>::Ty Data_<SpDString>::GetAs<SpDLong>( SizeT i)
+  {
+    const char* cStart=(*this)[i].c_str();
+    char* cEnd;
+    long int result =strtol(cStart,&cEnd,10);
+    if( cEnd == cStart && (*this)[i] != "")
+    {
+      StringConversionErrorGetAs( "Type conversion error: "
+      "Unable to convert given STRING: '"+(*this)[i]+"' to LONG.");
+    }
+    return result;
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDULong>::Ty Data_<SpDString>::GetAs<SpDULong>( SizeT i)
+  {
+    const char* cStart=(*this)[i].c_str();
+    char* cEnd;
+    unsigned long int result =strtoul(cStart,&cEnd,10);
+    if( cEnd == cStart && (*this)[i] != "")
+    {
+      StringConversionErrorGetAs( "Type conversion error: "
+      "Unable to convert given STRING: '"+(*this)[i]+"' to ULONG.");
+    }
+    return result;
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDLong64>::Ty Data_<SpDString>::GetAs<SpDLong64>( SizeT i)
+  {
+    const char* cStart=(*this)[i].c_str();
+    char* cEnd;
+    Data_<SpDLong64>::Ty result =strtol(cStart,&cEnd,10);
+    if( cEnd == cStart && (*this)[i] != "")
+    {
+      StringConversionErrorGetAs( "Type conversion error: "
+      "Unable to convert given STRING: '"+(*this)[i]+"' to LONG64.");
+    }
+    return result;
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDULong64>::Ty Data_<SpDString>::GetAs<SpDULong64>( SizeT i)
+  {
+    const char* cStart=(*this)[i].c_str();
+    char* cEnd;
+    Data_<SpDULong64>::Ty result =strtoul(cStart,&cEnd,10);
+    if( cEnd == cStart && (*this)[i] != "")
+    {
+      StringConversionErrorGetAs( "Type conversion error: "
+      "Unable to convert given STRING: '"+(*this)[i]+"' to ULONG64.");
+    }
+    return result;
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDFloat>::Ty Data_<SpDString>::GetAs<SpDFloat>( SizeT i)
+  {
+    const char* cStart=(*this)[i].c_str();
+    char* cEnd;
+    float result = strtod(cStart,&cEnd);
+    if( cEnd == cStart && (*this)[i] != "")
+    {
+      StringConversionErrorGetAs( "Type conversion error: "
+      "Unable to convert given STRING: '"+(*this)[i]+"' to FLOAT.");
+    }
+    return result;
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDDouble>::Ty Data_<SpDString>::GetAs<SpDDouble>( SizeT i)
+  {
+    const char* cStart=(*this)[i].c_str();
+    char* cEnd;
+    double result = strtod(cStart,&cEnd);
+    if( cEnd == cStart && (*this)[i] != "")
+    {
+      StringConversionErrorGetAs( "Type conversion error: "
+      "Unable to convert given STRING: '"+(*this)[i]+"' to DOUBLE.");
+    }
+    return result;
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDComplex>::Ty Data_<SpDString>::GetAs<SpDComplex>( SizeT i)
+  {
+    const char* cStart=(*this)[i].c_str();
+    char* cEnd;
+    float result = strtod(cStart,&cEnd);
+    if( cEnd == cStart && (*this)[i] != "")
+    {
+      StringConversionErrorGetAs( "Type conversion error: "
+      "Unable to convert given STRING: '"+(*this)[i]+"' to COMPLEX.");
+    }
+    return result;
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDComplexDbl>::Ty Data_<SpDString>::GetAs<SpDComplexDbl>( SizeT i)
+  {
+    const char* cStart=(*this)[i].c_str();
+    char* cEnd;
+    double result = strtod(cStart,&cEnd);
+    if( cEnd == cStart && (*this)[i] != "")
+    {
+      StringConversionErrorGetAs( "Type conversion error: "
+      "Unable to convert given STRING: '"+(*this)[i]+"' to DCOMPLEX.");
+    }
+    return result;
+  }
+  
+  
+// DComplexGDL full specializations  
+template<>
+template<> 
+/*typename*/ Data_<SpDByte>::Ty Data_<SpDComplex>::GetAs<SpDByte>( SizeT i)
+  {
+    return Real2DByte<float>(real((*this)[i])); 
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDInt>::Ty Data_<SpDComplex>::GetAs<SpDInt>( SizeT i)
+  {
+    return Real2Int<DInt,float>(real((*this)[i]));
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDUInt>::Ty Data_<SpDComplex>::GetAs<SpDUInt>( SizeT i)
+  {
+    return static_cast< DUInt>(real((*this)[i]));
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDLong>::Ty Data_<SpDComplex>::GetAs<SpDLong>( SizeT i)
+  {
+    return Real2Int<DLong,float>(real((*this)[i])); 
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDLong64>::Ty Data_<SpDComplex>::GetAs<SpDLong64>( SizeT i)
+  {
+    return Real2Int<DLong64,float>(real((*this)[i]));
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDULong>::Ty Data_<SpDComplex>::GetAs<SpDULong>( SizeT i)
+  {
+    return static_cast< DULong>(real((*this)[i]));
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDULong64>::Ty Data_<SpDComplex>::GetAs<SpDULong64>( SizeT i)
+  {
+    return static_cast< DULong64>(real((*this)[i]));
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDFloat>::Ty Data_<SpDComplex>::GetAs<SpDFloat>( SizeT i)
+  {
+    return real((*this)[i]); 
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDDouble>::Ty Data_<SpDComplex>::GetAs<SpDDouble>( SizeT i)
+  {
+    return real((*this)[i]); 
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDString>::Ty Data_<SpDComplex>::GetAs<SpDString>( SizeT i)
+  {
+    return "("+i2s(real((*this)[i]))+","+i2s(imag((*this)[i]))+")";
+  }
+  
+
+
+// DComplexDblGDL full specializations  
+template<>
+template<> 
+/*typename*/ Data_<SpDByte>::Ty Data_<SpDComplexDbl>::GetAs<SpDByte>( SizeT i)
+  {
+    return Real2DByte<double>(real((*this)[i])); 
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDInt>::Ty Data_<SpDComplexDbl>::GetAs<SpDInt>( SizeT i)
+  {
+    return Real2Int<DInt,double>(real((*this)[i]));
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDUInt>::Ty Data_<SpDComplexDbl>::GetAs<SpDUInt>( SizeT i)
+  {
+    return static_cast< DUInt>(real((*this)[i]));
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDLong>::Ty Data_<SpDComplexDbl>::GetAs<SpDLong>( SizeT i)
+  {
+    return Real2Int<DLong,double>(real((*this)[i])); 
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDLong64>::Ty Data_<SpDComplexDbl>::GetAs<SpDLong64>( SizeT i)
+  {
+    return Real2Int<DLong64,double>(real((*this)[i]));
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDULong>::Ty Data_<SpDComplexDbl>::GetAs<SpDULong>( SizeT i)
+  {
+    return static_cast< DULong>(real((*this)[i]));
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDULong64>::Ty Data_<SpDComplexDbl>::GetAs<SpDULong64>( SizeT i)
+  {
+    return static_cast< DULong64>(real((*this)[i]));
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDFloat>::Ty Data_<SpDComplexDbl>::GetAs<SpDFloat>( SizeT i)
+  {
+    return real((*this)[i]); 
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDDouble>::Ty Data_<SpDComplexDbl>::GetAs<SpDDouble>( SizeT i)
+  {
+    return real((*this)[i]); 
+  }
+template<>
+template<> 
+/*typename*/ Data_<SpDString>::Ty Data_<SpDComplexDbl>::GetAs<SpDString>( SizeT i)
+  {
+    return "("+i2s(real((*this)[i]))+","+i2s(imag((*this)[i]))+")";
+  }
+
+#endif
\ No newline at end of file
diff -ruN --exclude CVS gdl-0.9.2/src/graphics.cpp gdl/src/graphics.cpp
--- gdl-0.9.2/src/graphics.cpp	2010-06-11 09:09:51.000000000 -0600
+++ gdl/src/graphics.cpp	2011-12-28 16:14:09.000000000 -0700
@@ -232,6 +232,5 @@
 
 void Graphics::LoadCT( UInt iCT)
 {
-
   actCT = CT[iCT];
 }
diff -ruN --exclude CVS gdl-0.9.2/src/gshhs.cpp gdl/src/gshhs.cpp
--- gdl-0.9.2/src/gshhs.cpp	2011-07-08 06:39:43.000000000 -0600
+++ gdl/src/gshhs.cpp	2011-11-16 11:08:50.000000000 -0700
@@ -301,7 +301,7 @@
   void map_continents(EnvT* e)
   {
     map_continents_call map_continents;
-    map_continents.call(e, 1); 
+    map_continents.call(e, 0); 
   }
 
 } // namespace
diff -ruN --exclude CVS gdl-0.9.2/src/gsl_fun.cpp gdl/src/gsl_fun.cpp
--- gdl-0.9.2/src/gsl_fun.cpp	2011-10-20 02:08:53.000000000 -0600
+++ gdl/src/gsl_fun.cpp	2012-07-14 12:56:37.000000000 -0600
@@ -4,7 +4,7 @@
     begin                : Jan 20 2004
     copyright            : (C) 2004 by Joel Gales
     email                : jomoga@users.sourceforge.net
- ***************************************************************************/
+***************************************************************************/
 
 /***************************************************************************
  *                                                                         *
@@ -26,6 +26,9 @@
 #include "gsl_fun.hpp"
 #include "dinterpreter.hpp"
 
+// ms: must not be inlcuded here
+//#include "libinit_ac.cpp"
+
 #include <gsl/gsl_sys.h>
 #include <gsl/gsl_linalg.h>
 #include <gsl/gsl_fft_real.h>
@@ -44,6 +47,9 @@
 #include <gsl/gsl_multiroots.h>
 #include <gsl/gsl_vector.h>
 
+// numerical integration (alternative to Qromb)
+#include <gsl/gsl_integration.h>
+
 // constant
 #include <gsl/gsl_const_mksa.h>
 #include <gsl/gsl_const_num.h>
@@ -75,6 +81,15 @@
 // spher_harm
 #include <gsl/gsl_sf_legendre.h>
 
+//interpolate
+#include <gsl/gsl_errno.h>
+#include "interp_multid.h"
+
+//fx_root
+#include <stdio.h>
+#include <iostream>
+#include <complex>
+
 #define LOG10E 0.434294
 
 namespace lib {
@@ -93,8 +108,8 @@
     double det;
     long singular=0;
 
-//     if( nParam == 0)
-//       e->Throw( "Incorrect number of arguments.");
+    //     if( nParam == 0)
+    //       e->Throw( "Incorrect number of arguments.");
 
     BaseGDL* p0 = e->GetParDefined( 0);
 
@@ -111,8 +126,8 @@
     }
 
     // status 
-	// check here, if not done, res would be pending in case of SetPar() throws
-	// SetPar() only throws in AssureGlobalPar()
+    // check here, if not done, res would be pending in case of SetPar() throws
+    // SetPar() only throws in AssureGlobalPar()
     if (nParam == 2) e->AssureGlobalPar( 1);
 
     // only one element matrix
@@ -129,7 +144,7 @@
 	  singular=1;
 	  (*res)[0]= DComplexDbl(0., 0.);
 	} else {
-	(*res)[0]= DComplexDbl(a/deno, -b/deno);
+	  (*res)[0]= DComplexDbl(a/deno, -b/deno);
 	}
 	if (nParam == 2) e->SetPar(1,new DLongGDL( singular)); 
 	return res;
@@ -172,7 +187,7 @@
       } else {
 	(*res)[0]= 1.0 / ((*res)[0]);
       }
-	if (nParam == 2) e->SetPar(1,new DLongGDL( singular)); 
+      if (nParam == 2) e->SetPar(1,new DLongGDL( singular)); 
       return res;
     }
     
@@ -299,9 +314,9 @@
 	DByteGDL* p0B = static_cast<DByteGDL*>( p0);
 
 	//	if (p0->Type() == STRING) {
-	  DFloatGDL* p0SS = static_cast<DFloatGDL*>
-	    (p0->Convert2( FLOAT, BaseGDL::COPY));
-	  //}
+	DFloatGDL* p0SS = static_cast<DFloatGDL*>
+	  (p0->Convert2( FLOAT, BaseGDL::COPY));
+	//}
 
 	DFloatGDL* res = new DFloatGDL( p0->Dim(), BaseGDL::NOZERO);
 
@@ -369,7 +384,7 @@
 
   template< typename T>
   int cp2data_template( BaseGDL* p0, T* data, SizeT nEl, 
-			 SizeT offset, SizeT stride_in, SizeT stride_out)
+			SizeT offset, SizeT stride_in, SizeT stride_out)
   {
     switch ( p0->Type()) {
     case DOUBLE: 
@@ -537,74 +552,145 @@
     }
   }
 
-
   template < typename T>
   T* fft_template(BaseGDL* p0,
 		  SizeT nEl, SizeT dbl, SizeT overwrite, 
 		  double direct, DLong dimension)
   {
     SizeT offset;
-    SizeT stride;
-
+    SizeT stride=1;
+    
     T* res;
-
+    T* tabtemp=new T(p0->Dim());
+    
     if (overwrite == 0)
-      if (dimension == 0)
+      {
 	res = new T( p0->Dim(), BaseGDL::ZERO);
-      else
-	res = new T( p0->Dim(dimension-1), BaseGDL::ZERO);
+      } 
     else
       res = (T*) p0;
+    
+    DComplexGDL* tabfft = new DComplexGDL(p0->Dim()) ;
+    DComplexGDL* p0C = static_cast<DComplexGDL*>
+      (p0->Convert2( COMPLEX, BaseGDL::COPY));
+            
+    int dec=0;
+    int temp=0;
+    int flag=0;
+    int l=0;
+        
+    int tab[tabfft->Rank()];
+    for (int y=0;y<tabfft->Rank();y++)
+      tab[y]=0;
+    
+    // Debut demontage tab
 
-
-    if( p0->Rank() == 1 || dimension > 0) {
-	offset=0;
-	stride=1;
-
-	fft_1d( p0, &(*res)[0], nEl, offset, stride, 
-		direct, dbl, dimension);
-
-    } else if ( p0->Rank() == 2) {
-      stride=p0->Dim(0);
-      for( SizeT i=0; i<p0->Dim(0); ++i) {
-	fft_1d( p0, &(*res)[0], p0->Dim(1), i, stride, 
-		direct, dbl, dimension);
-      }
-      for( SizeT i=0; i<p0->Dim(1); ++i) {
-	fft_1d( res, &(*res)[0], 
-		p0->Dim(0), i*p0->Dim(0), 1, 
-		direct, dbl, dimension);
-      }
-    } else if( p0->Rank() >= 3) {
-      unsigned char *used = new unsigned char [nEl];
-
-      stride = nEl;
-      for( SizeT i=p0->Rank(); i<nEl; ++i) used[i] = 0;
-
-      for (SizeT k=p0->Rank(); k>0; --k) {
-	for( SizeT i=0; i<nEl; ++i) used[i] = 0;
-	stride /= p0->Dim(k-1);
-
-	SizeT cnt=1;
-	offset = 0;
-	while(cnt <= nEl/p0->Dim(k-1)) {
-	  if (used[offset] != 1) {
-	    cnt++;
-	    for( SizeT i=0; i<p0->Dim(k-1); ++i) 
-	      used[offset+i*stride] = 1;
-	    if (k == p0->Rank())
-	      fft_1d( p0, &(*res)[0], p0->Dim(k-1), offset, stride, 
-		      direct, dbl, dimension);
-	    else
-	      fft_1d( res, &(*res)[0], p0->Dim(k-1), offset, stride, 
-		      direct, dbl, dimension);
+    l=0;
+    for(int j=0;j<nEl/tabfft->Dim(dimension);j++)
+      {
+	dec=0;		  
+	flag=0;
+	for(int n=0;n<tabfft->Rank();n++)
+	  {
+	    if(tab[n]!=tabfft->Dim(n)-1 && flag==0 && n!=dimension && l!=0)
+	      {
+		tab[n]++;
+		//cout << "tab[" << n << "] = " << tab[n] << endl;
+		flag=1;
+	      }
+	    else if(tab[n]==tabfft->Dim(n)-1 && flag==0 && n!=dimension && l!=0)
+	      tab[n]=0;
+	    
+	    temp=1;
+	    if(n!=0)
+	      {
+		for(int m=n-1;m>=0;m--)
+		  {
+		    temp=temp*tabfft->Dim(m);
+		  }
+	      }
+	    //cout << "temp = " << temp << endl;
+	    dec=dec+tab[n]*temp;
+	    //cout << "dec = " << dec << endl;
+	  }
+	
+	temp=1;
+	for(int y=dimension-1;y>=0;y--)
+	  {
+	    temp=temp*tabfft->Dim(y);
+	  }
+	for(int i=0; i<tabfft->Dim(dimension);i++)
+	  {
+	    (*tabfft)[l]=(*p0C)[dec+i*temp];
+	    //cout << l << "=" << dec+i*temp << endl;
+	    l++;
 	  }
-	  offset++;
-	}
       }
-      delete used;
-    }
+    
+    // Fin demontage tab - Debut res
 
+    temp=1;
+    for(int y=0;y<tabfft->Rank();y++)
+      {
+	if(y!=dimension)
+	  temp=temp*tabfft->Dim(y);
+      }
+    
+    for(int i=0;i<temp;i++)
+      {
+	
+	offset=i*tabfft->Dim(dimension);
+	fft_1d(tabfft, &(*tabtemp)[0], tabfft->Dim(dimension), offset, stride, 
+	       direct, dbl,1);
+      }
+    
+    // Fin res - Debut remontage
+    
+    for (int y=0;y<tabfft->Rank();y++)
+      tab[y]=0;
+    
+    l=0;
+    for(int j=0;j<nEl/tabfft->Dim(dimension);j++)
+      {
+	dec=0;		  
+	flag=0;
+	for(int n=0;n<tabfft->Rank();n++)
+	  {
+	    if(tab[n]!=tabfft->Dim(n)-1 && flag==0 && n!=dimension && l!=0)
+	      {
+		tab[n]++;
+		//cout << "tab[" << n << "] = " << tab[n] << endl;
+		flag=1;
+	      }
+	    else if(tab[n]==tabfft->Dim(n)-1 && flag==0 && n!=dimension && l!=0)
+	      tab[n]=0;
+	    
+	    temp=1;
+	    if(n!=0)
+	      {
+		for(int m=n-1;m>=0;m--)
+		  {
+		    temp=temp*tabfft->Dim(m);
+		  }
+	      }
+	    //cout << "temp = " << temp << endl;
+	    dec=dec+tab[n]*temp;
+	    //cout << "dec = " << dec << endl;
+	  }
+	
+	temp=1;
+	for(int y=dimension-1;y>=0;y--)
+	  {
+	    temp=temp*tabfft->Dim(y);
+	  }
+	for(int i=0; i<tabfft->Dim(dimension);i++)
+	  {
+	    (*res)[dec+i*temp]=(*tabtemp)[l];
+	    //cout << l << "=" << dec+i*temp << endl;
+	    l++;
+	  }
+      }
+        
     return res;
   }
 
@@ -615,11 +701,11 @@
       Program Flow
       ------------
       fft_fun
-         fft_template
-	    fft_1d
-	       (real/complex)_fft_transform_template
-	          cp2data_template (real only)
-		     cp2data_2_template (real only)
+      fft_template
+      fft_1d
+      (real/complex)_fft_transform_template
+      cp2data_template (real only)
+      cp2data_2_template (real only)
     */
 
     SizeT nParam=e->NParam();
@@ -632,7 +718,7 @@
 
     if( nParam == 0)
       e->Throw( 
-			  "Incorrect number of arguments.");
+	       "Incorrect number of arguments.");
 
 
     //BaseGDL* p0 = e->GetNumericArrayParDefined( 0); 
@@ -641,15 +727,15 @@
     SizeT nEl = p0->N_Elements();
     if( nEl == 0)
       e->Throw( 
-			  "Variable is undefined: "+e->GetParString(0));
+	       "Variable is undefined: "+e->GetParString(0));
   
 
     if( nParam == 2) {
       BaseGDL* p1 = e->GetPar( 1);
       if (p1->N_Elements() > 1)
 	e->Throw( 
-			    "Expression must be a scalar or 1 element array: "
-			    +e->GetParString(1));
+		 "Expression must be a scalar or 1 element array: "
+		 +e->GetParString(1));
 
 
 
@@ -665,12 +751,10 @@
 
     // Check for dimension keyword
     DLong dimension=0;
-    if(e->KeywordSet(3)) {
+    if(e->KeywordSet(3)) 
       e->AssureLongScalarKW( 3, dimension);
-      for( SizeT i=0; i<p0->Rank(); ++i)
-	if (i != (dimension-1)) nEl /= p0->Dim(i);
-      overwrite = 0;  // Disable overwrite
-    }
+    dimension--;
+     
 
     if( p0->Type() == COMPLEXDBL || p0->Type() == DOUBLE || dbl) {
 
@@ -682,7 +766,7 @@
       return fft_template< DComplexDblGDL> (p0, nEl, dbl, overwrite,
 					    direct, dimension);
 
-    }
+    }  
     else if( p0->Type() == COMPLEX) {
 
 	//cout << "if 2" << endl;
@@ -871,35 +955,57 @@
       }
   }
 
-
   template< typename T1, typename T2>
   int random_template( EnvT* e, T1* res, gsl_rng *r, 
 		       dimension dim, 
 		       DDoubleGDL* binomialKey, DDoubleGDL* poissonKey)
   {
+    int debug=0;
+
+    // testing Exclusive Keywords ...
+    int exclusiveKW= e->KeywordPresent(e->KeywordIx("GAMMA"));
+    exclusiveKW=exclusiveKW+ e->KeywordPresent(e->KeywordIx("NORMAL"));
+    exclusiveKW=exclusiveKW+ e->KeywordPresent(e->KeywordIx("BINOMIAL"));
+    exclusiveKW=exclusiveKW+ e->KeywordPresent(e->KeywordIx("POISSON"));
+    exclusiveKW=exclusiveKW+ e->KeywordPresent(e->KeywordIx("UNIFORM"));
+
+    if (exclusiveKW > 1) e->Throw("Conflicting keywords.");
+
     SizeT nEl = res->N_Elements();
 
-    if( e->KeywordSet(1)) {// GAMMA
+    if (e->KeywordPresent(e->KeywordIx("GAMMA"))) {
       DLong n;
       e->AssureLongScalarKWIfPresent( "GAMMA", n);
+      if (debug) cout << "(Int) Gamma Value: "<< n << endl;
+      if (n == 0) {
+	DDouble test_n;
+	e->AssureDoubleScalarKWIfPresent( "GAMMA", test_n);
+	if (debug) cout << "(Double) Gamma Value: "<< test_n << endl;
+	if (test_n > 0.0) n=1;
+      }
+      if (n <= 0)
+	e->Throw("Value of (Int/Long) GAMMA is out of allowed range: Gamma = 1, 2, 3, ...");    
+      if (debug) cout << "(Effective) Gamma Value: "<< n << endl;
+
       for( SizeT i=0; i<nEl; ++i) (*res)[ i] = 
 				    (T2) gsl_ran_gamma_int (r,n);
-    } else if( e->KeywordSet(3)) { // NORMAL
-      SizeT nEl = res->N_Elements();
-      for( SizeT i=0; i<nEl; ++i) (*res)[ i] =
-				    (T2) gsl_ran_ugaussian (r);
-    } else if( e->KeywordSet(4)) { // BINOMIAL
+      return 0;
+    }
+
+    if (e->KeywordPresent(e->KeywordIx("BINOMIAL"))) {
       if (binomialKey != NULL) {
 	DULong  n = (DULong)  (*binomialKey)[0];
 	DDouble p = (DDouble) (*binomialKey)[1];
-	SizeT nEl = res->N_Elements();
+	if (debug) cout << "Binomial Values (n,p): "<< n << " " << p << endl;
 	for( SizeT i=0; i<nEl; ++i) (*res)[ i] =
 				      (T2) gsl_ran_binomial (r, p, n);
       }
-    } else if( e->KeywordSet(5)) { // POISSON
+      return 0;
+    } 
+
+    if( e->KeywordSet("POISSON")) { // POISSON
       if (poissonKey != NULL) {
 	DDouble mu = (DDouble) (*poissonKey)[0];
-	SizeT nEl = res->N_Elements();
 	if (mu < 100000) {
 	  for( SizeT i=0; i<nEl; ++i) (*res)[ i] =
 					(T2) gsl_ran_poisson (r, mu);
@@ -910,19 +1016,20 @@
 	  for( SizeT i=0; i<nEl; ++i) (*res)[ i] += mu;
 	}
       }
-    } else if( e->KeywordSet(6)) { // UNIFORM
-      SizeT nEl = res->N_Elements();
+      return 0;
+    }
+
+    if (e->KeywordSet("UNIFORM") || ((e->GetProName() == "RANDOMU") && !e->KeywordSet("NORMAL"))) {
       for( SizeT i=0; i<nEl; ++i) (*res)[ i] =
 				    (T2) gsl_rng_uniform (r);
-    } else if ( e->GetProName() == "RANDOMU") {
-      for( SizeT i=0; i<nEl; ++i) (*res)[ i] = 
-				    (T2) gsl_rng_uniform (r);
-    } else if ( e->GetProName() == "RANDOMN") {
+      return 0;
+    } 
+
+    if (e->KeywordSet("NORMAL") || ((e->GetProName() == "RANDOMN") && !e->KeywordSet("UNIFORM"))) {
       for( SizeT i=0; i<nEl; ++i) (*res)[ i] = 
 				    (T2) gsl_ran_ugaussian (r);
+      return 0;
     }
-
-    return 0;
   }
 
 
@@ -1001,6 +1108,16 @@
 
     DSub* pro=dynamic_cast<DSub*>(e->GetPro());
     DDoubleGDL* binomialKey = e->IfDefGetKWAs<DDoubleGDL>( 4);
+
+	if( binomialKey != NULL)
+	{
+	    SizeT nBinomialKey = binomialKey->N_Elements();
+	    if (nBinomialKey != 2)
+	      e->Throw("Keyword array parameter BINOMIAL must have 2 elements.");
+	    if (((*binomialKey)[1] < 0.0) || ((*binomialKey)[1] > 1.0))
+	      e->Throw(" Value of BINOMIAL[1] is out of allowed range: 0.0 <= p <= 1.0");
+	}
+	
     DDoubleGDL* poissonKey = e->IfDefGetKWAs<DDoubleGDL>( 5);
 
     if( e->KeywordSet(0)) { // DOUBLE
@@ -1014,7 +1131,7 @@
       return res;
     } else {
       DFloatGDL* res = new DFloatGDL(dim, BaseGDL::NOZERO);
-
+      
       random_template< DFloatGDL, float>( e, res, r, dim, 
 					  binomialKey, poissonKey);
 
@@ -1081,7 +1198,7 @@
       e->Throw( "Complex expression not allowed in this context: "
 		+e->GetParString(0));
     
-    BaseGDL* binsizeKW = e->GetKW( 0);
+    BaseGDL* binsizeKW = e->GetKW(e->KeywordIx("BINSIZE"));
     DDouble bsize = 1.0;
     if( binsizeKW != NULL)
       {
@@ -1090,14 +1207,14 @@
 	  e->Throw( "Illegal BINSIZE.");
       }
 
-    BaseGDL* maxKW = e->GetKW( 2);
-    BaseGDL* minKW = e->GetKW( 3);
+    BaseGDL* maxKW = e->GetKW(e->KeywordIx("MAX"));
+    BaseGDL* minKW = e->GetKW(e->KeywordIx("MIN"));
 
-    BaseGDL* nbinsKW = e->GetKW( 4);
+    BaseGDL* nbinsKW = e->GetKW(e->KeywordIx("NBINS"));
     DLong nbins;
     if( nbinsKW != NULL)
       {
-	e->AssureLongScalarKW( 4, nbins);
+	e->AssureLongScalarKW(e->KeywordIx("NBINS"), nbins);
 	if( nbins < 0)
 	  e->Throw( "Illegal NBINS (<0).");
 	if( nbins == 0) // NBINS=0 is ignored
@@ -1117,13 +1234,32 @@
 
     // get min max
     // use MinMax here when NAN will be supported
-    DDouble minVal = (*p0D)[0];
-    DDouble maxVal = minVal;
-    for( SizeT i=1; i<nEl; ++i)
-      if ((*p0D)[i] < minVal) 
-	minVal = (*p0D)[i];
-      else if ((*p0D)[i] > maxVal) 
-	maxVal = (*p0D)[i];
+
+    DDouble minVal, maxVal;
+
+    if( e->KeywordSet( "NAN")) {
+      DLong minEl, maxEl;
+      p0D->MinMax( &minEl, &maxEl, NULL, NULL, true);
+      minVal=(*p0D)[minEl];
+      maxVal=(*p0D)[maxEl];
+    } else {
+      minVal = (*p0D)[0];
+      maxVal = minVal;
+      for( SizeT i=1; i<nEl; ++i) {
+	if (!isfinite((*p0D)[i])) {
+	  if (!isnan((*p0D)[i])) {
+	    e->Throw("Array has too many elements (Infinite value encoutered).");
+	  };
+	}
+	if ((*p0D)[i] < minVal) 
+	  minVal = (*p0D)[i];
+	else if ((*p0D)[i] > maxVal) 
+	  maxVal = (*p0D)[i];
+      }
+    }
+
+    int debug=0;
+    if (debug) cout << "min/max : " << minVal << " " << maxVal << endl;
 
     // min
     if (minKW == NULL) 
@@ -1134,7 +1270,7 @@
 	  a = minVal;
       } 
     else 
-      e->AssureDoubleScalarKW( 3, a);
+      e->AssureDoubleScalarKW(e->KeywordIx("MIN"), a);
     // max
     if (maxKW == NULL) 
       {
@@ -1154,7 +1290,7 @@
       } 
     else
       {
-	e->AssureDoubleScalarKW( 2, b);
+	e->AssureDoubleScalarKW(e->KeywordIx("MAX"), b);
 
 	// MAX && !BINSIZE && NBINS -> determine BINSIZE
 	if( binsizeKW == NULL && nbinsKW != NULL)
@@ -1174,7 +1310,7 @@
       nbins = static_cast< DLong>( floor( (b - a) / bsize) + 1);
 
     // INPUT keyword
-    static int inputIx = e->KeywordIx( "INPUT"); 
+    static int inputIx = e->KeywordIx("INPUT"); 
     DLongGDL* input = e->IfDefGetKWAs<DLongGDL>( inputIx);
     if (input != NULL)
       if (input->N_Elements() < nbins)
@@ -1196,7 +1332,7 @@
     gsl_histogram_set_ranges_uniform( hh, a, b);
 
     // Set maxVal from keyword if present
-    if (maxKW != NULL) e->AssureDoubleScalarKW( 2, maxVal);
+    if (maxKW != NULL) e->AssureDoubleScalarKW(e->KeywordIx("MAX"), maxVal);
 
     // Generate histogram
     for( SizeT i=0; i<nEl; ++i) {
@@ -1218,18 +1354,18 @@
     // SA: using aOri/bOri instead of gsl_histogram_min(hh) (as in calculation of LOCATIONS) 
     //     otherwise, when converting e.g. to INT the conversion might give bad results
     // OMAX
-    if( e->KeywordPresent( 5)) {
+    if( e->KeywordPresent(e->KeywordIx("OMAX"))) {
       // e->SetKW( 5, (new DDoubleGDL( gsl_histogram_max(hh)))->Convert2(p0->Type(), BaseGDL::CONVERT));
-      e->SetKW( 5, (new DDoubleGDL( bOri))->Convert2(p0->Type(), BaseGDL::CONVERT));
+      e->SetKW(e->KeywordIx("OMAX"), (new DDoubleGDL( bOri))->Convert2(p0->Type(), BaseGDL::CONVERT));
     }
     // OMIN
-    if( e->KeywordPresent( 6)) {
+    if( e->KeywordPresent(e->KeywordIx("OMIN"))) {
       // e->SetKW( 6, (new DDoubleGDL( gsl_histogram_min(hh)))->Convert2(p0->Type(), BaseGDL::CONVERT));
-      e->SetKW( 6, (new DDoubleGDL( aOri))->Convert2(p0->Type(), BaseGDL::CONVERT));
+      e->SetKW(e->KeywordIx("OMIN"), (new DDoubleGDL( aOri))->Convert2(p0->Type(), BaseGDL::CONVERT));
     }
 
     // REVERSE_INDICES
-    if( e->KeywordPresent( 7)) {
+    if( e->KeywordPresent(e->KeywordIx("REVERSE_INDICES"))) {
 
       if (input != NULL)
 	e->Throw("Conflicting keywords.");
@@ -1299,12 +1435,12 @@
 	(*revindKW)[i] = k + nbins + 1;
       }
 
-      e->SetKW( 7, revindKW);
+      e->SetKW(e->KeywordIx("REVERSE_INDICES"), revindKW);
     }
     
     // LOCATIONS
-    if( e->KeywordPresent( 8)) {
-      BaseGDL** locationsKW = &e->GetKW( 8);
+    if( e->KeywordPresent(e->KeywordIx("LOCATIONS"))) {
+      BaseGDL** locationsKW = &e->GetKW(e->KeywordIx("LOCATIONS"));
       delete (*locationsKW);
 
       dimension dim( nbins);
@@ -1377,516 +1513,483 @@
 
     return(res);
   }
+ 
+DDoubleGDL* interpolate_1dim(EnvT* e, const gdl_interp1d_type* interp_type, DDoubleGDL* array, DDoubleGDL* x, bool use_missing, DDouble missing, DDouble gamma)
+{
 
+    SizeT nx = x->N_Elements();
 
-  void interpolate_linear(gsl_interp_accel *acc, gsl_interp *interp, 
-			  double *xa, SizeT nx, const double ya[], 
-			  double x[], double y[], bool use_missing, double missing)
-  {
-    for( SizeT i=0; i<nx; ++i)
-    {
-      int status = gsl_interp_eval_e (interp, xa, ya, x[i], acc, &y[i]);
-      if (status == GSL_EDOM && use_missing) y[i] = missing;
-    }
-  }
+    // Determine number and value of input points along x-axis and y-axis
+    SizeT rankLeft = array->Rank()-1;
+    if (rankLeft < 0) e->Throw("Number of parameters must agree with dimensions of argument.");
 
+    //initialize output array with correct dimensions
+    DLong dims[MAXRANK] = {0, 0, 0, 0, 0, 0, 0, 0};
+    SizeT resRank;
+    SizeT chunksize;
+    for (SizeT i = 0; i < rankLeft; ++i) dims[i] = array->Dim(i);
+    resRank = rankLeft;
 
-  void interpolate_cubic(gsl_interp_accel *acc, gsl_spline *spline, 
-			 double *xa, SizeT nx, const double ya[], 
-			 double x[], double y[], bool use_missing, double missing)
-  {
-    for( SizeT i=0; i<nx; ++i)
+    for (SizeT i = 0; i < x->Rank(); ++i)
     {
-      int status = gsl_spline_eval_e (spline, x[i], acc, &y[i]);
-      if (status == GSL_EDOM && use_missing) y[i] = missing;
+      dims[resRank++] = x->Dim(i); if (resRank>MAXRANK) e->Throw("Rank of resulting array is currently limited to 8.");
     }
-  }
-
-
-  void twoD_lin_interpolate(SizeT ninterp,
-			    double *xa, bool grid, 
-			    SizeT nx, SizeT ny, SizeT nxa, SizeT nya,
-			    double *p0, double *p1, double *p2, double *res, bool use_missing, double missing)  
-  {
-    gsl_interp_accel *acc = gsl_interp_accel_alloc ();
-    gsl_interp *interp;
+    chunksize=nx;
 
-    // Allocate and initialize interpolation arrays
-    interp = gsl_interp_alloc (gsl_interp_linear, nxa);
-    //    gsl_interp_init (interp, xa, &(*p0D)[0], nxa);
+    dimension dim((DLong *)dims, resRank);
+    DDoubleGDL *res;
+    res = new DDoubleGDL(dim, BaseGDL::NOZERO);
 
-    // Allocate "work" arrays
-    SizeT ny2 = (ny == 1) * 2 + (ny > 1) * ny;
-    double **work = new double*[ny2];
-    for( SizeT k=0; k<ny2; ++k) work[k] = new double[nx];
+    // Determine number of interpolations for remaining dimensions
+    SizeT ninterp = 1;
+    for (SizeT i = 0; i < rankLeft; ++i) ninterp *= array->Dim(i);
 
-    double **ya = new double*[nya];
-    for( SizeT k=0; k<nya; ++k) ya[k] = new double[nxa];
+    //need to PAD the intermediate work array to satisfy the IDL requirement that
+    //INTERPOLATE considers location points with values between zero and n,
+    //where n is the number of values in the input array, to be valid.
+    // Seems however to be the case only for 1D interpolation.
+    SizeT nxa = array->Dim(rankLeft)+1;
+    double *xa = new double[nxa];
+    for (SizeT i = 0; i < nxa; ++i) xa[i] = (double)i;
 
-    for( SizeT i=0; i<ninterp; ++i) {
+    // Setup interpolation arrays
+    gsl_interp_accel *accx = gsl_interp_accel_alloc();
+    gdl_interp1d* interpolant = gdl_interp1d_alloc(interp_type, nxa);
 
-      // Get input y-axis values
-      for( SizeT k=0; k<nya; ++k) {
-	for( SizeT j=0; j<nxa; ++j) {
-	  ya[k][j] = p0[i+(ninterp*j)+(ninterp*nxa)*k];
-	  //  cout << k << "  " << j << "  " << ya[k][j] << endl;
-	}
+    // output locations tables:
+    double *xval = new double[chunksize];
+    for (SizeT count = 0; count < chunksize; ++count)
+    {
+        xval[count] = (*x)[count]; 
+    }
+    //construct 1d intermediate array, subset of array with stride ninterp
+    double *temp = new double[nxa];
+    // Interpolate iteratively ninterp times:
+    // loop could be multihreaded easily
+    for (SizeT iterate = 0; iterate < ninterp; ++iterate)
+    {
+      //here we use a padded temp array (1D only):
+      for (SizeT k = 0; k < nxa-1; ++k) temp[k]=(*array)[k*ninterp+iterate]; temp[nxa-1]=temp[nxa-2]; //pad!
+      gdl_interp1d_init(interpolant, xa, temp, nxa, use_missing?missing_GIVEN:missing_NEAREST, missing, gamma);
+      for (SizeT i = 0; i < chunksize; ++i)
+      {
+        double x = xval[i];
+        (*res)[i*ninterp+iterate] = gdl_interp1d_eval(interpolant, xa, temp, x, accx);
       }
+    }
 
-      bool first = true;
-      DLong lastrow;
-      double *dptr;
-      for( SizeT k=0; k<ny; ++k) {
-	//	    printf("k: %d\n", k);
-	// Interpolate along rows
-	DLong row = (DLong) floor(p2[k]);
-	if (grid) dptr = &p1[0]; else dptr = &p1[k]; 
-
-	if (first || (row != lastrow) || !grid) {
-
-	  // Correct if row out of bounds
-	  if (row < 0) row = 0;
-	  if (row >= nya) row = nya - 1;
-
-	  interpolate_linear(acc, interp, xa, nx, 
-			     ya[row], dptr, &work[0][0], use_missing, missing);
-
-	  // Correct if row out of bounds
-	  if (row < -1) row = -1;
-	  if (row >= nya-1) row = nya - 2;
-
-	  interpolate_linear(acc, interp, xa, nx, 
-			     ya[(row+1)], dptr, &work[1][0], use_missing, missing);
-	}
-	first = false;
-	lastrow = row;
-
-	if (grid) {
-	  // Interpolate between rows
-	  for( SizeT j=0; j<nx; ++j) {
-	    res[i+ninterp*j+(ninterp*nx)*k] = 
-	      work[0][j] + (work[1][j]-work[0][j]) * (p2[k] - row); 
-	  } // column (j) loop
-	} else {
-	  res[i+ninterp*k] = 
-	    work[0][0] + (work[1][0]-work[0][0]) * (p2[k] - row); 
-	}
-
-      } // row (k) loop
-    } // interp loop 
-
-    // Free dynamic arrays
-    for( SizeT k=0; k<ny2; ++k) 
-      delete [] work[k];
-    delete [] work;
+    gsl_interp_accel_free(accx);
+    gdl_interp1d_free(interpolant);
+    return res;
+ }
 
-    for( SizeT k=0; k<nya; ++k) 
-      delete [] ya[k];
-    delete [] ya;
 
-    gsl_interp_accel_free (acc);
-    gsl_interp_free (interp);
-  }
+DDoubleGDL* interpolate_2dim(EnvT* e, const gdl_interp2d_type* interp_type, DDoubleGDL* array, DDoubleGDL* x, DDoubleGDL* y, bool grid, bool use_missing, DDouble missing, DDouble gamma)
+{
 
+    SizeT nx = x->N_Elements();
+    SizeT ny = y->N_Elements();
 
-  BaseGDL* interpolate_fun( EnvT* e)
-  {
-    SizeT nParam=e->NParam();
+    if (nx == 1 && ny == 1)  grid = false;
 
-    if( nParam < 2)
-      e->Throw("Incorrect number of arguments.");
+    // Determine number and value of input points along x-axis and y-axis
+    SizeT rankLeft = array->Rank()-2;
 
-    BaseGDL* p0 = e->GetParDefined( 0);
-    BaseGDL* p1 = e->GetParDefined( 1);
-    BaseGDL* p2=NULL;
-    BaseGDL* p3=NULL;
-    if ( nParam >= 3) p2 = e->GetParDefined( 2);
-    if ( nParam >= 4) p3 = e->GetParDefined( 3);
-
-    DDoubleGDL* p0D;
-    DDoubleGDL* p1D;
-    DDoubleGDL* p2D;
-    DDoubleGDL* p3D;
-    auto_ptr<BaseGDL> guard0;
-    auto_ptr<BaseGDL> guard1;
-    auto_ptr<BaseGDL> guard2;
-    auto_ptr<BaseGDL> guard3;
-
-    if( p0->Rank() < nParam-1)
-      e->Throw("Number of parameters must agree with dimensions of argument.");
-
-    static int cubicIx = e->KeywordIx("CUBIC");
-    bool cubic = e->KeywordSet(cubicIx);
-
-    static int gridIx = e->KeywordIx("GRID");
-    bool grid = e->KeywordSet(gridIx);
-
-    static int missingIx = e->KeywordIx("MISSING");
-    bool use_missing = e->KeywordSet(missingIx);
-    DDouble missing;
-    e->AssureDoubleScalarKWIfPresent(missingIx, missing);
-
-    if ( nParam == 3)
-      if (p1->N_Elements() == 1 && p2->N_Elements() == 1)
-	grid = false;
+    if (rankLeft < 0) e->Throw("Number of parameters must agree with dimensions of argument.");
 
     // If not GRID then check that rank and dims match
-    if ( nParam == 3 && !grid) {
-      if (p1->Rank() != p2->Rank())
-	e->Throw("Coordinate arrays must have same length if Grid not set.");
-      else {
-	for( SizeT i=0; i<p1->Rank(); ++i) {
-	  if (p1->Dim(i) != p2->Dim(i))
-	    e->Throw("Coordinate arrays must have same length if Grid not set.");
-	}
+    if  (!grid)
+    {
+      if (x->Rank() != y->Rank())
+        e->Throw("Coordinate arrays must have same rank if Grid not set.");
+      else
+      {
+        for (SizeT i = 0; i < x->Rank(); ++i)
+        {
+          if (x->Dim(i) != y->Dim(i))
+            e->Throw("Coordinate arrays must have same shape if Grid not set.");
+        }
       }
     }
 
-    if (p0->Type() == DOUBLE)
-	p0D = static_cast<DDoubleGDL*> ( p0);
-    else
-	{
-	p0D = static_cast<DDoubleGDL*>
-	  (p0->Convert2( DOUBLE, BaseGDL::COPY));
-	guard0.reset( p0D);
-	}
-
-    // Determine dimensions of output
-    DDoubleGDL* res;
-    DLong dims[8]={0,0,0,0,0,0,0,0};
+    //initialize output array with correct dimensions
+    DLong dims[MAXRANK] = {0, 0, 0, 0, 0, 0, 0, 0};
     SizeT resRank;
-    // Linear Interpolation or No GRID
-    if ( nParam == 2 || !grid) {
-      for( SizeT i=0; i<p0->Rank()-(nParam-1); ++i) 
-	dims[i] = p0->Dim(i);
-      for( SizeT i=0; i<p1->Rank(); ++i) 
-	dims[i+p0->Rank()-(nParam-1)] = p1->Dim(i);
-      resRank = p0->Rank()-(nParam-1)+p1->Rank();
-      if (p0->N_Elements() == 1 && 
-	  p1->N_Elements() == 1 && 
-	  !e->KeywordSet(1) && 
-	  nParam < 3) {
-	dims[0] = 0;
-	resRank = 0;
-      }
-    } else {
-      // GRID
-      for( SizeT i=0; i<p0->Rank()-(nParam-1); ++i) 
-	dims[i] = p0->Dim(i);
-
-      dims[p0->Rank()-(nParam-1)] = p1->Dim(0);
-      for( SizeT i=1; i<p1->Rank(); ++i) 
-	dims[p0->Rank()-(nParam-1)] *= p1->Dim(i);
-
-      dims[p0->Rank()-(nParam-1)+1] = p2->Dim(0);
-      for( SizeT i=1; i<p2->Rank(); ++i) 
-	dims[p0->Rank()-(nParam-1)+1] *= p2->Dim(i);
-
-      if (nParam == 4) {
-	dims[p0->Rank()-(nParam-1)+2] = p3->Dim(0);
-	for( SizeT i=1; i<p3->Rank(); ++i) 
-	  dims[p0->Rank()-(nParam-1)+2] *= p3->Dim(i);
-      }
-
-      resRank = 0;
-      for( SizeT i=0; i<8; ++i) { 
-	if (dims[i] != 0) resRank++;
+    SizeT chunksize;
+    for (SizeT i = 0; i < rankLeft; ++i) dims[i] = array->Dim(i);
+    resRank = rankLeft;
+    if (grid)
+    {
+      dims[resRank++] = nx;
+      if (resRank>MAXRANK-1) e->Throw("Rank of resulting array is currently limited to 8.");
+      dims[resRank++] = ny;
+      chunksize=nx*ny;
+    }
+    else
+    {
+      for (SizeT i = 0; i < x->Rank(); ++i)
+      {
+        dims[resRank++] = x->Dim(i); if (resRank>MAXRANK) e->Throw("Rank of resulting array is currently limited to 8.");
       }
+      chunksize=nx;
     }
-    dimension dim((DLong *) dims, resRank);
+    dimension dim((DLong *)dims, resRank);
+    DDoubleGDL *res;
     res = new DDoubleGDL(dim, BaseGDL::NOZERO);
 
-    // Determine number of interpolations
+    // Determine number of interpolations for remaining dimensions
     SizeT ninterp = 1;
-    for( SizeT i=0; i<p0->Rank()-(nParam-1); ++i) ninterp *= p0->Dim(i);
-
-    // 1D Interpolation
-    if( nParam == 2) {
+    for (SizeT i = 0; i < rankLeft; ++i) ninterp *= array->Dim(i);
 
-      // Setup interpolation arrays
-      gsl_interp_accel *acc = gsl_interp_accel_alloc ();
-      gsl_interp *interp;
-      gsl_spline *spline;
-
-      // Determine number and value of input points along x-axis
-      SizeT nxa = p0->Dim(p0->Rank()-nParam+1);
-      double *xa = new double[nxa];
-      for( SizeT i=0; i<nxa; ++i) xa[i] = (double) i;
-      
-      // Allocate and initialize interpolation arrays
-      if( cubic) {
-	spline = gsl_spline_alloc (gsl_interp_cspline, nxa);
-	gsl_spline_init (spline, xa, &(*p0D)[0], nxa);
-      } else {
-	interp = gsl_interp_alloc (gsl_interp_linear, nxa);
-	gsl_interp_init (interp, xa, &(*p0D)[0], nxa);
+    SizeT nxa = array->Dim(rankLeft);
+    double *xa = new double[nxa];
+    for (SizeT i = 0; i < nxa; ++i) xa[i] = (double)i;
+    SizeT nya = array->Dim(rankLeft+1);
+    double *ya = new double[nya];
+    for (SizeT i = 0; i < nya; ++i) ya[i] = (double)i;
+
+    // Setup interpolation arrays
+    gsl_interp_accel *accx = gsl_interp_accel_alloc();
+    gsl_interp_accel *accy = gsl_interp_accel_alloc();
+    gdl_interp2d* interpolant = gdl_interp2d_alloc(interp_type, nxa, nya);
+
+    // output locations tables:
+    double *xval = new double[chunksize];
+    double *yval = new double[chunksize];
+    if (grid)
+    {
+      for (SizeT i = 0, count = 0; i < nx; i++)
+      {
+        for (SizeT j = 0; j < ny; j++)
+        {
+          count = INDEX_2D(i, j, nx, ny);
+          xval[count] = (*x)[i];
+          yval[count] = (*y)[j];
+       }
       }
-
-      if ( p1->Type() == DOUBLE) 
-	p1D = static_cast<DDoubleGDL*> ( p1);
-      else
-	{
-	p1D = static_cast<DDoubleGDL*>
-	  (p1->Convert2( DOUBLE, BaseGDL::COPY));
-	guard1.reset( p1D);
-	}	
-
-      // Single Interpolation
-      if (ninterp == 1) {
-	if( cubic)
-	  // cubic interpolation
-	  interpolate_cubic(acc, spline, xa, p1D->N_Elements(), 
-			    &(*p0D)[0], &(*p1D)[0], &(*res)[0], use_missing, missing);
-	else
-	  // linear interpolation
-	  interpolate_linear(acc, interp, xa, p1D->N_Elements(), 
-			     &(*p0D)[0], &(*p1D)[0], &(*res)[0], use_missing, missing);
-      } else {
-	// Multiple Interpolation
-	for( SizeT i=0; i<ninterp; ++i) {
-
-	  double *ya = new double[nxa];
-	  for( SizeT j=0; j<nxa; ++j) ya[j] = (*p0D)[j*ninterp+i];
-
-	  double *y = new double[p1D->N_Elements()];
-
-	  if( cubic)
-	    // cubic interpolation
-	    interpolate_cubic(acc, spline, xa, p1D->N_Elements(), 
-			      ya, &(*p1D)[0], &(*res)[0], use_missing, missing);
-	  else
-	    // linear interpolation
-	    interpolate_linear(acc, interp, xa, p1D->N_Elements(), 
-			       ya, &(*p1D)[0], y, use_missing, missing);
-
-	  // Write to output array
-	  for( SizeT j=0; j<p1D->N_Elements(); ++j) (*res)[j*ninterp+i] = y[j];
-
-	  delete [] ya;
-	  delete [] y;
-	}
+    }
+    else
+    {
+      for (SizeT count=0; count < chunksize; ++count)
+      {
+          xval[count]=(*x)[count];
+          yval[count]=(*y)[count];
+      }
+    }
+    //construct 2d intermediate array, subset of array with stride ninterp
+    double *temp = new double[nxa*nya];
+    // Interpolate iteratively ninterp times:
+    // loop could be multihreaded easily
+    for (SizeT iterate = 0; iterate < ninterp; ++iterate)
+    {
+     
+     for (SizeT k = 0; k < nxa*nya; ++k) temp[k]=(*array)[k*ninterp+iterate];
+      gdl_interp2d_init(interpolant, xa, ya, temp, nxa, nya, use_missing?missing_GIVEN:missing_NEAREST, missing, gamma);
+      for (SizeT i = 0; i < chunksize; ++i)
+      {
+        double x = xval[i];
+        double y = yval[i];
+        (*res)[i*ninterp+iterate] = gdl_interp2d_eval(interpolant, xa, ya, temp, x, y, accx, accy);
       }
-
-      gsl_interp_accel_free (acc);
-
-      if (cubic)
-	gsl_spline_free (spline);
-      else
-	gsl_interp_free (interp);
     }
 
+    gsl_interp_accel_free(accx);
+    gsl_interp_accel_free(accy);
+    gdl_interp2d_free(interpolant);
+    return res;
+ }
 
-    // 2D Interpolation
-    if( nParam == 3) {
 
-      if( cubic)
-	e->Throw("Bicubic interpolation not yet supported.");
+DDoubleGDL* interpolate_3dim(EnvT* e, const gdl_interp3d_type* interp_type, DDoubleGDL* array, DDoubleGDL* x, DDoubleGDL* y, DDoubleGDL* z, bool grid, bool use_missing, DDouble missing)
+{
+    SizeT nx = x->N_Elements();
+    SizeT ny = y->N_Elements();
+    SizeT nz = z->N_Elements();
+
+    if (nx == 1 && ny == 1 && nz == 1)  grid = false;
+
+    // Determine number and value of input points along x-axis and y-axis
+    SizeT rankLeft = array->Rank()-3;
+    if (rankLeft < 0) e->Throw("Number of parameters must agree with dimensions of argument.");
 
-      if ( p1->Type() == DOUBLE) 
-	p1D = static_cast<DDoubleGDL*> ( p1);
-      else
-	{
-	p1D = static_cast<DDoubleGDL*>
-	  (p1->Convert2( DOUBLE, BaseGDL::COPY));
-	guard1.reset( p1D);
-	}	
-      if ( p2->Type() == DOUBLE) 
-	p2D = static_cast<DDoubleGDL*> ( p2);
+    // If not GRID then check that rank and dims match
+    if  (!grid)
+    {
+      if (x->Rank() != y->Rank() || x->Rank() != z->Rank() )
+        e->Throw("Coordinate arrays must have same rank if Grid not set.");
       else
-	{
-	p2D = static_cast<DDoubleGDL*>
-	  (p2->Convert2( DOUBLE, BaseGDL::COPY));
-	guard2.reset( p2D);
-	}	
-
-      // Compute nx,ny (number of interpolated points along each dimension
-      SizeT nx = 1;
-      if (grid) nx = res->Dim(resRank-2);
-      
-      SizeT ny = 1;
-      if (resRank != 0 && res->Dim(resRank-1) != 0) ny = res->Dim(resRank-1);
-      if (resRank == 1) ny = dims[0];
-      if (!grid) ny = p1->N_Elements();
-
-      // Determine number and value of input points along x-axis
-      SizeT nxa = p0->Dim(p0->Rank()-nParam+1);
-      double *xa = new double[nxa];
-      for( SizeT i=0; i<nxa; ++i) xa[i] = (double) i;
-
-      // Determine number and value of input points along y-axis
-      SizeT nya = p0->Dim(p0->Rank()-1);
-      
-      twoD_lin_interpolate(ninterp,
-			   xa, grid, 
-			   nx, ny, nxa, nya,
-			   &(*p0D)[0], &(*p1D)[0], &(*p2D)[0], &(*res)[0], use_missing, missing);
-      
-      delete [] xa;
+      {
+        for (SizeT i = 0; i < x->Rank(); ++i)
+        {
+          if (x->Dim(i) != y->Dim(i) || x->Dim(i) != z->Dim(i))
+            e->Throw("Coordinate arrays must have same shape if Grid not set.");
+        }
+      }
+    }
 
-    } // if( nParam == 3)
+    //initialize output array with correct dimensions
+    DLong dims[MAXRANK] = {0, 0, 0, 0, 0, 0, 0, 0};
+    SizeT resRank;
+    SizeT chunksize;
+    for (SizeT i = 0; i < rankLeft; ++i) dims[i] = array->Dim(i);
+    resRank = rankLeft;
+    if (grid)
+    {
+      dims[resRank++] = nx;
+      if (resRank>MAXRANK-2) e->Throw("Rank of resulting array is currently limited to 8.");
+      dims[resRank++] = ny;
+      dims[resRank++] = nz;
+      chunksize=nx*ny*nz;
+    }
+    else
+    {
+      for (SizeT i = 0; i < x->Rank(); ++i)
+      {
+        dims[resRank++] = x->Dim(i); if (resRank>MAXRANK) e->Throw("Rank of resulting array is currently limited to 8.");
+      }
+      chunksize=nx;
+    }
+    dimension dim((DLong *)dims, resRank);
+    DDoubleGDL *res;
+    res = new DDoubleGDL(dim, BaseGDL::NOZERO);
 
+    // Determine number of interpolations for remaining dimensions
+    SizeT ninterp = 1;
+    for (SizeT i = 0; i < rankLeft; ++i) ninterp *= array->Dim(i);
 
-    // 3D Interpolation
-    if( nParam == 4) {
+    SizeT nxa = array->Dim(rankLeft);
+    double *xa = new double[nxa];
+    for (SizeT i = 0; i < nxa; ++i) xa[i] = (double)i;
+
+    SizeT nya = array->Dim(rankLeft+1);
+    double *ya = new double[nya];
+    for (SizeT i = 0; i < nya; ++i) ya[i] = (double)i;
+
+    SizeT nza = array->Dim(rankLeft+2);
+    double *za = new double[nza];
+    for (SizeT i = 0; i < nza; ++i) za[i] = (double)i;
+
+// test if interp_type kernel trace is statisfied by nxa,nya,nza:
+    if (nxa<gdl_interp3d_type_min_size(interp_type)||nya<gdl_interp3d_type_min_size(interp_type)||nza<gdl_interp3d_type_min_size(interp_type)) e->Throw("Array(s) dimensions too small for this interpolation type.");
+    // Setup interpolation arrays
+    gsl_interp_accel *accx = gsl_interp_accel_alloc();
+    gsl_interp_accel *accy = gsl_interp_accel_alloc();
+    gsl_interp_accel *accz = gsl_interp_accel_alloc();
+    gdl_interp3d* interpolant = gdl_interp3d_alloc(interp_type, nxa, nya, nza);
+
+    // output locations tables:
+    double *xval = new double[chunksize];
+    double *yval = new double[chunksize];
+    double *zval = new double[chunksize];
+    if (grid)
+    {
+      for (SizeT i = 0, count = 0; i < nx; ++i)
+      {
+        for (SizeT j = 0; j < ny; ++j)
+        {
+          for (SizeT k = 0; k < nz; ++k)
+          {
+            count = INDEX_3D(i, j, k, nx, ny, nz);
+            xval[count] = (*x)[i];
+            yval[count] = (*y)[j];
+            zval[count] = (*z)[k];
+          }
+        }
+      }
+    }
+    else
+    {
+      for (SizeT count = 0; count < chunksize; ++count)
+      {
+          xval[count]=(*x)[count];
+          yval[count]=(*y)[count];
+          zval[count]=(*z)[count];
+      }
+    }
+    //construct 3d intermediate array, subset of array with stride ninterp
+    double *temp = new double[nxa*nya*nza];
 
-      if( cubic)
-	e->Throw("Bicubic interpolation not supported.");
+    // Interpolate iteratively ninterp times:
+    // this outer loop could be multihreaded easily
+    for (SizeT iterate = 0; iterate < ninterp; ++iterate)
+    {
+      for (SizeT k = 0; k < nxa*nya*nza; ++k) temp[k]=(*array)[k*ninterp+iterate];
+      gdl_interp3d_init(interpolant, xa, ya, za, temp, nxa, nya, nza, use_missing?missing_GIVEN:missing_NEAREST, missing);
+      for (SizeT i = 0; i < chunksize; ++i)
+      {
+        double x = xval[i];
+        double y = yval[i];
+        double z = zval[i];
+        (*res)[i*ninterp+iterate] = gdl_interp3d_eval(interpolant, xa, ya, za, temp, x, y, z, accx, accy, accz);
+      }
+    }
 
-      if ( p1->Type() == DOUBLE) 
-	p1D = static_cast<DDoubleGDL*> ( p1);
-      else
-	{
-	p1D = static_cast<DDoubleGDL*>
-	  (p1->Convert2( DOUBLE, BaseGDL::COPY));
-	guard1.reset( p1D);
-	}	
+    gsl_interp_accel_free(accx);
+    gsl_interp_accel_free(accy);
+    gsl_interp_accel_free(accz);
+    gdl_interp3d_free(interpolant);
+    return res;
+ }
 
-      if ( p2->Type() == DOUBLE) 
-	p2D = static_cast<DDoubleGDL*> ( p2);
-      else
-	{
-	p2D = static_cast<DDoubleGDL*>
-	  (p2->Convert2( DOUBLE, BaseGDL::COPY));
-	guard2.reset( p2D);
-	}	
 
-      if ( p3->Type() == DOUBLE) 
-	p3D = static_cast<DDoubleGDL*> ( p3);
-      else
-	{
-	p3D = static_cast<DDoubleGDL*>
-	  (p3->Convert2( DOUBLE, BaseGDL::COPY));
-	guard3.reset( p3D);
-	}	
+BaseGDL* interpolate_fun(EnvT* e){
+  SizeT nParam = e->NParam();
+  // options
+  static int cubicIx = e->KeywordIx("CUBIC");
+  bool cubic = e->KeywordSet(cubicIx);
+  DDouble gamma=-1.0;
+  e->AssureDoubleScalarKWIfPresent(cubicIx, gamma);
+
+  static int nnborIx = e->KeywordIx("NEAREST_NEIGHBOUR"); //usage restricted to GDL, undocumented, normally for CONGRID.
+  bool nnbor = e->KeywordSet(nnborIx);
+  if (nnbor && cubic) nnbor=false;  //undocumented nearest neighbour give way wrt. other options.
+
+  static int gridIx = e->KeywordIx("GRID");
+  bool grid = e->KeywordSet(gridIx);
+
+  static int missingIx = e->KeywordIx("MISSING");
+  bool use_missing = e->KeywordSet(missingIx);
+  DDouble missing;
+  e->AssureDoubleScalarKWIfPresent(missingIx, missing);
+
+  DDoubleGDL* p0D;
+  DDoubleGDL* p1D;
+  DDoubleGDL* p2D;
+  DDoubleGDL* p3D;
+  auto_ptr<BaseGDL> guard0;
+  auto_ptr<BaseGDL> guard1;
+  auto_ptr<BaseGDL> guard2;
+  auto_ptr<BaseGDL> guard3;
+
+  if (nParam < 2) e->Throw("Incorrect number of arguments.");
+
+  // convert to internal double arrays
+  BaseGDL* p0 = e->GetParDefined(0);
+  if (p0->Rank() < nParam - 1)
+    e->Throw("Number of parameters must agree with dimensions of argument.");
+  if (p0->Type() == DOUBLE) p0D = static_cast<DDoubleGDL*>(p0);
+  else
+  {
+    p0D = static_cast<DDoubleGDL*>(p0->Convert2(DOUBLE, BaseGDL::COPY));
+    guard0.reset(p0D);
+  }
+
+  BaseGDL* p1 = e->GetParDefined(1);
+  if (p1->Type() == DOUBLE) p1D = static_cast<DDoubleGDL*>(p1);
+  else
+  {
+    p1D = static_cast<DDoubleGDL*>(p1->Convert2(DOUBLE, BaseGDL::COPY));
+    guard1.reset(p1D);
+  }
+
+  BaseGDL* p2 = NULL;
+  if (nParam >= 3) {
+    p2 = e->GetParDefined(2);
+    if (p2->Type() == DOUBLE) p2D = static_cast<DDoubleGDL*>(p2);
+    else
+    {
+      p2D = static_cast<DDoubleGDL*>(p2->Convert2(DOUBLE, BaseGDL::COPY));
+      guard2.reset(p2D);
+    }
+  }
 
+  BaseGDL* p3 = NULL;
+  if (nParam >= 4) {
+    p3 = e->GetParDefined(3);
+    if (p3->Type() == DOUBLE) p3D = static_cast<DDoubleGDL*>(p3);
+    else
+    {
+      p3D = static_cast<DDoubleGDL*>(p3->Convert2(DOUBLE, BaseGDL::COPY));
+      guard3.reset(p3D);
+    }
+  }
 
-      // Compute nx,ny (number of interpolated points along each dimension
-      SizeT nx = 1;
-      if (grid) nx = res->Dim(resRank-3);
-      
-      SizeT ny = 1;
-      if (resRank != 0 && res->Dim(resRank-2) != 0) ny = res->Dim(resRank-2);
-      if (resRank == 1) ny = dims[0];
-      if (!grid) ny = p1->N_Elements();
-
-      // Determine number and value of input points along x-axis
-      SizeT nxa = p0->Dim(p0->Rank()-nParam+1);
-      double *xa = new double[nxa];
-      for( SizeT i=0; i<nxa; ++i) xa[i] = (double) i;
-
-      // Determine number and value of input points along y-axis
-      SizeT nya = p0->Dim(p0->Rank()-2);
-
-      // Determine number and value of input points along z-axis
-      SizeT nza = p0->Dim(p0->Rank()-1);
-
-      double *work_xy = new double [nza*nx*ny];
-      for( SizeT i=0; i<nza; ++i) {
-	twoD_lin_interpolate(ninterp,
-			     xa, grid, 
-			     nx, ny, nxa, nya,
-			     &(*p0D)[nxa*nya*i], &(*p1D)[0], &(*p2D)[0], 
-			     &work_xy[i*nx*ny], use_missing, missing);
-      }
-
-      double *za = new double[nza];
-      for( SizeT i=0; i<nza; ++i) za[i] = (double) i;
-      double *work_za  = new double [nza];
-
-      SizeT nz = p3D->N_Elements();
-      double *work_z   = new double [nz];
-
-      gsl_interp *interp_z;
-      gsl_interp_accel *acc = gsl_interp_accel_alloc ();
-      interp_z = gsl_interp_alloc (gsl_interp_linear, nza);
-      //      gsl_interp_init (interp_z, za, &(*p0D)[0], nza);
-
-      if (grid ) {
-	for( SizeT i=0; i<nx; ++i) {
-	  for( SizeT j=0; j<ny; ++j) {
-	    for( SizeT k=0; k<nza; ++k) 
-	      work_za[k] = work_xy[k*nx*ny + j*nx + i];
-	    interpolate_linear(acc, interp_z, za, nz, work_za, 
-			       &(*p3D)[0], work_z, use_missing, missing);
+  // Determine dimensions of output
+  DDoubleGDL* res;
+  // 1D Interpolation
+  if (nParam == 2) {
+ //   res=interpolate_1dim(e,p0D,p1D,cubic,use_missing,missing);
+    if (nnbor)   res=interpolate_1dim(e,gdl_interp1d_nearest,p0D,p1D,use_missing,missing,0.0);
+    else if (cubic)   res=interpolate_1dim(e,gdl_interp1d_cubic,p0D,p1D,use_missing,missing,gamma);
+    else         res=interpolate_1dim(e,gdl_interp1d_linear,p0D,p1D,use_missing,missing,0.0);
+  }
+ 
+  if (nParam == 3) {
+    if (nnbor)        res=interpolate_2dim(e,gdl_interp2d_binearest,p0D,p1D,p2D,grid,use_missing,missing,0.0);
+    else if (cubic)   res=interpolate_2dim(e,gdl_interp2d_bicubic,p0D,p1D,p2D,grid,use_missing,missing,gamma);
+    else              res=interpolate_2dim(e,gdl_interp2d_bilinear,p0D,p1D,p2D,grid,use_missing,missing,0.0);
+  }
+  if (nParam == 4) {
+    res=interpolate_3dim(e,gdl_interp3d_trilinear,p0D,p1D,p2D,p3D,grid,use_missing,missing);
+  }
 
-	    for( SizeT k=0; k<nz; ++k) (*res)[k*nx*ny + j*nx + i] = work_z[k];
-	  }
-	}
-      } else {
-	for( SizeT i=0; i<nz; ++i) {
-	  for( SizeT k=0; k<nza; ++k) work_za[k] = work_xy[k*ny + i];
-	  interpolate_linear(acc, interp_z, za, 1, work_za, 
-			     &(*p3D)[i], &(*res)[i], use_missing, missing);
-	}
-      }
-
-      gsl_interp_accel_free (acc);
-      gsl_interp_free (interp_z);
-
-      delete [] xa;
-      delete [] za;
-      delete [] work_xy;
-      delete [] work_z;
-      delete [] work_za;
-
-    } // if( nParam == 4)
-
-
-//    if (p0->Type() != DOUBLE) delete p0D;
-//    if (p1->Type() != DOUBLE) delete p1D;
-//    if (p2 != NULL)
-//      if (p2->Type() != DOUBLE) delete p2D;
-//    if (p3 != NULL)
-//      if (p3->Type() != DOUBLE) delete p3D;
-
-    if (p0->Type() == DOUBLE) {
-      return res;	
-    } else if (p0->Type() == FLOAT) {
-      DFloatGDL* res1 = static_cast<DFloatGDL*>
-	(res->Convert2( FLOAT, BaseGDL::COPY));
-      delete res;
-      return res1;
-    } else if (p0->Type() == INT) {
-      DIntGDL* res1 = static_cast<DIntGDL*>
-	(res->Convert2( INT, BaseGDL::COPY));
-      delete res;
-      return res1;
-    } else if (p0->Type() == UINT) {
-      DUIntGDL* res1 = static_cast<DUIntGDL*>
-	(res->Convert2( UINT, BaseGDL::COPY));
-      delete res;
-      return res1;
-    } else if (p0->Type() == LONG) {
-      DLongGDL* res1 = static_cast<DLongGDL*>
-	(res->Convert2( LONG, BaseGDL::COPY));
-      delete res;
-      return res1;
-    } else if (p0->Type() == ULONG) {
-      DULongGDL* res1 = static_cast<DULongGDL*>
-	(res->Convert2( ULONG, BaseGDL::COPY));
-      delete res;
-      return res1;
-    } else if (p0->Type() == LONG64) {
-      DLong64GDL* res1 = static_cast<DLong64GDL*>
-	(res->Convert2( LONG64, BaseGDL::COPY));
-      delete res;
-      return res1;
-    } else if (p0->Type() == ULONG64) {
-      DULong64GDL* res1 = static_cast<DULong64GDL*>
-	(res->Convert2( ULONG64, BaseGDL::COPY));
-      delete res;
-      return res1;
-    }  else if (p0->Type() == BYTE) {
-      DByteGDL* res1 = static_cast<DByteGDL*>
-	(res->Convert2( BYTE, BaseGDL::COPY));
-      delete res;
-      return res1;
-    } else {
-      return res;
-    }
-    
+  if (p0->Type() == DOUBLE)
+  {
+    return res;
+  }
+  else if (p0->Type() == FLOAT)
+  {
+    DFloatGDL* res1 = static_cast<DFloatGDL*>
+    (res->Convert2(FLOAT, BaseGDL::COPY));
+    delete res;
+    return res1;
+  }
+  else if (p0->Type() == INT)
+  {
+    DIntGDL* res1 = static_cast<DIntGDL*>
+    (res->Convert2(INT, BaseGDL::COPY));
+    delete res;
+    return res1;
+  }
+  else if (p0->Type() == UINT)
+  {
+    DUIntGDL* res1 = static_cast<DUIntGDL*>
+    (res->Convert2(UINT, BaseGDL::COPY));
+    delete res;
+    return res1;
+  }
+  else if (p0->Type() == LONG)
+  {
+    DLongGDL* res1 = static_cast<DLongGDL*>
+    (res->Convert2(LONG, BaseGDL::COPY));
+    delete res;
+    return res1;
+  }
+  else if (p0->Type() == ULONG)
+  {
+    DULongGDL* res1 = static_cast<DULongGDL*>
+    (res->Convert2(ULONG, BaseGDL::COPY));
+    delete res;
+    return res1;
+  }
+  else if (p0->Type() == LONG64)
+  {
+    DLong64GDL* res1 = static_cast<DLong64GDL*>
+    (res->Convert2(LONG64, BaseGDL::COPY));
+    delete res;
+    return res1;
+  }
+  else if (p0->Type() == ULONG64)
+  {
+    DULong64GDL* res1 = static_cast<DULong64GDL*>
+    (res->Convert2(ULONG64, BaseGDL::COPY));
+    delete res;
+    return res1;
+  }
+  else if (p0->Type() == BYTE)
+  {
+    DByteGDL* res1 = static_cast<DByteGDL*>
+    (res->Convert2(BYTE, BaseGDL::COPY));
+    delete res;
+    return res1;
+  }
+  else
+  {
+    return res;
   }
 
+}
+
 
   void la_trired_pro( EnvT* e)
   {
@@ -2155,6 +2258,7 @@
       }
   }
 
+
   // gsl_multiroot_function-compatible function serving as a wrapper to the 
   // user-defined function passed (by name) as the second arg. to NEWTON or BROYDEN
   class n_b_param 
@@ -2178,10 +2282,12 @@
     // TODO: no guarding if res is an optimized constant
     // NO!!! the return value of call_fun() is always owned by the caller (constants are Dup()ed)
    auto_ptr<BaseGDL> res_guard(res);
-    // sanity checks
-    if (res->Rank() != 1 || res->N_Elements() != x->size) 
-    {
-      p->errmsg = "user-defined function must evaluate to a vector of the size of its argument";
+   // sanity checks
+   //   if (res->Rank() != 1 || res->N_Elements() != x->size) 
+   //AC for iCosmo
+   if (res->N_Elements() != x->size) 
+     {
+       p->errmsg = "user-defined function must evaluate to a vector of the size of its argument";
       return GSL_EBADFUNC;
     }
     DDoubleGDL* dres;
@@ -2246,8 +2352,9 @@
     SizeT nParam = e->NParam();
 
     // 1-st argument : initial guess vector
-    BaseGDL* p0 = e->GetParDefined(0);   
-    if (p0->Rank() != 1) e->Throw("the first argument is expected to be a vector");
+    BaseGDL* p0 = e->GetParDefined(0);
+    //AC for iCosmo
+    //if (p0->Rank() != 1) e->Throw("the first argument is expected to be a vector");
     BaseGDL* par = p0->Convert2(DOUBLE, BaseGDL::COPY);
     auto_ptr<BaseGDL> par_guard(par);
 
@@ -2349,6 +2456,569 @@
     );
   }
 
+  // -------------------------------------------------------------------------
+  // GSL don't have implementations of QROMB and QROMO but alternatives
+
+  // AC, 10 Jan 2011, to have it for iCosmos
+
+  class qromb_param 
+  { 
+    public: 
+    EnvT* envt; 
+    EnvUDT* nenvt; 
+    DDoubleGDL* arg; 
+    string errmsg; 
+  };
+
+  double qromb_function(double x, void* params)
+  {
+    qromb_param *p = static_cast<qromb_param*>(params);
+    (*(p->arg))[0]=x;
+    BaseGDL* res;
+    res = p->envt->Interpreter()->call_fun(static_cast<DSubUD*>(p->nenvt->GetPro())->GetTree());
+
+    return (*static_cast<DDoubleGDL*>(res))[0]; 
+  }
+
+  // AC: the library routine is registered in libinit_ac.cpp
+  BaseGDL* qromb_fun(EnvT* e)
+  {
+    int debug=0;
+
+    // sanity check (for number of parameters)
+    SizeT nParam = e->NParam();
+
+    // 2-nd argument : initial bound
+    BaseGDL* p1 = e->GetParDefined(1);
+    BaseGDL* par1 = p1->Convert2(DOUBLE, BaseGDL::COPY);
+    auto_ptr<BaseGDL> par1_guard(par1);
+
+    // 3-th argument : final bound
+    BaseGDL* p2 = e->GetParDefined(2);
+    BaseGDL* par2 = p2->Convert2(DOUBLE, BaseGDL::COPY);
+    auto_ptr<BaseGDL> par2_guard(par2);
+
+    // 1-st argument : name of user function defining the system
+    DString fun;
+    e->AssureScalarPar<DStringGDL>(0, fun);
+    fun = StrUpCase(fun);
+    if (LibFunIx(fun) != -1)
+      e->Throw("only user-defined functions allowed (library-routine name given)");
+
+    // GDL magick
+    StackGuard<EnvStackT> guard(e->Interpreter()->CallStack());
+    EnvUDT* newEnv = new EnvUDT(e, funList[GDLInterpreter::GetFunIx(fun)], NULL);
+    newEnv->SetNextPar(&par1);
+    e->Interpreter()->CallStack().push_back(newEnv);
+
+    // GSL function parameter initialization  
+    qromb_param param;
+    param.envt = e;
+    param.nenvt = newEnv;
+    param.arg = static_cast<DDoubleGDL*>(par1); 
+    
+    // GSL function initialization
+    gsl_function F; 
+    F.function = &qromb_function;
+    F.params = &param;
+  
+    double result, error;
+    double first, last;
+
+    SizeT nEl1=par1->N_Elements();
+    SizeT nEl2=par2->N_Elements();
+    SizeT nEl=nEl1;
+    DDoubleGDL* res;
+
+    if (nEl1 == 1 || nEl2 == 1) {
+      if (nEl1 == 1) {
+	nEl=nEl2;
+	res=new DDoubleGDL(par2->Dim(), BaseGDL::NOZERO);
+      }
+      if (nEl2 == 1) {
+	res=new DDoubleGDL(par1->Dim(), BaseGDL::NOZERO);
+	nEl=nEl1;
+      }
+    } else {
+      if (nEl1 <= nEl2) {
+	res=new DDoubleGDL(par1->Dim(), BaseGDL::NOZERO);      
+      } else {
+	res=new DDoubleGDL(par2->Dim(), BaseGDL::NOZERO);
+	nEl=nEl2;
+      }
+    }  
+    
+    gsl_integration_workspace *w = gsl_integration_workspace_alloc (1000);
+
+    first=(*static_cast<DDoubleGDL*>(par1))[0];
+    last =(*static_cast<DDoubleGDL*>(par2))[0];
+    
+    for( SizeT i=0; i<nEl; i++) {
+      if (nEl1 > 1) {first=(*static_cast<DDoubleGDL*>(par1))[i];}
+      if (nEl2 > 1) {last =(*static_cast<DDoubleGDL*>(par2))[i];}
+
+      if (debug) cout << "Boundaries : "<< first << " " << last <<endl;
+
+      gsl_integration_qag (&F, first, last, 0, 1e-7, GSL_INTEG_GAUSS61,
+			   1000, w, &result, &error); 
+
+      if (debug) cout << "Result : " << result << endl;
+
+      (*res)[i]=result;
+    }
+
+    gsl_integration_workspace_free (w);
+ 
+    if (e->KeywordSet("DOUBLE") || p1->Type() == DOUBLE || p2->Type() == DOUBLE)
+      {
+	return res;
+      }
+    else
+      {
+	return res->Convert2(FLOAT, BaseGDL::CONVERT);
+      }
+  }
+
+
+  // AC: the library routine is registered in libinit_ac.cpp
+  BaseGDL* qromo_fun(EnvT* e)
+  {
+    int debug=0;
+
+    // sanity check (for number of parameters)
+    SizeT nParam = e->NParam();
+    if(e->KeywordSet("MIDEXP"))
+      {
+	if (nParam < 2) e->Throw("Incorrect number of arguments.");
+	if (nParam > 2) e->Throw("Too many arguments.");
+      }
+    else
+      {
+	if (nParam < 3) e->Throw("Incorrect number of arguments.");
+      }
+
+    // 2-nd argument : initial bound
+    BaseGDL* p1 = NULL;
+    BaseGDL* par1 = NULL;
+    p1 = e->GetParDefined(1);
+    par1 = p1->Convert2(DOUBLE, BaseGDL::COPY);
+    auto_ptr<BaseGDL> par1_guard(par1);
+
+    BaseGDL* p2 = NULL;
+    BaseGDL* par2 = NULL;
+    if (!e->KeywordSet("MIDEXP"))
+     {
+	// 3-th argument : final bound
+	p2 = e->GetParDefined(2);
+	par2 = p2->Convert2(DOUBLE, BaseGDL::COPY);
+	auto_ptr<BaseGDL> par2_guard(par2);
+     }
+
+    // 1-st argument : name of user function defining the system
+    DString fun;
+    e->AssureScalarPar<DStringGDL>(0, fun);
+    fun = StrUpCase(fun);
+    if (LibFunIx(fun) != -1)
+      e->Throw("only user-defined functions allowed (library-routine name given)");
+
+    gsl_error_handler_t* old_handler = gsl_set_error_handler(&n_b_gslerrhandler);
+    n_b_gslerrhandler(e->GetProName().c_str(), NULL, -1, -1);
+
+    // Check for impossible case
+    bool flag=0;
+    for(SizeT i=4;i<=8;i++) 
+      {
+	if(flag==1 && e->KeywordPresent(i))
+	  {
+	    e->Throw("Incorrect number of arguments.");
+	  }
+	else if (flag==0 && e->KeywordPresent(i)) flag=1;
+      }
+
+    // GDL magick
+    StackGuard<EnvStackT> guard(e->Interpreter()->CallStack());
+    EnvUDT* newEnv = new EnvUDT(e, funList[GDLInterpreter::GetFunIx(fun)], NULL);
+    newEnv->SetNextPar(&par1);
+    e->Interpreter()->CallStack().push_back(newEnv);
+
+    // GSL function parameter initialization  
+    qromb_param param;
+    param.envt = e;
+    param.nenvt = newEnv;
+    param.arg = static_cast<DDoubleGDL*>(par1); 
+    
+    // GSL function initialization
+    gsl_function F; 
+    F.function = &qromb_function;
+    F.params = &param;
+  
+    double result, error;
+    double first, last;
+
+    SizeT nEl1=par1->N_Elements();
+    SizeT nEl2=nEl1;
+    if (!e->KeywordSet("MIDEXP")) 
+      SizeT nEl2=par2->N_Elements();
+    SizeT nEl=nEl1;
+    DDoubleGDL* res;
+    if (!e->KeywordSet("MIDEXP")) {
+      if (nEl1 == 1 || nEl2 == 1) {
+	if (nEl1 == 1) {
+	  nEl=nEl2;
+	  res=new DDoubleGDL(par2->Dim(), BaseGDL::NOZERO);
+	}
+	if (nEl2 == 1) {
+	  res=new DDoubleGDL(par1->Dim(), BaseGDL::NOZERO);
+	  nEl=nEl1;
+	}
+      } else {
+	if (nEl1 <= nEl2) {
+	  res=new DDoubleGDL(par1->Dim(), BaseGDL::NOZERO);     
+	} else {
+	  res=new DDoubleGDL(par2->Dim(), BaseGDL::NOZERO);
+	  nEl=nEl2;
+	}
+      }
+    }
+    else res=new DDoubleGDL(par1->Dim(), BaseGDL::NOZERO);
+    
+    // eps value:
+    double eps;
+    int pos;
+    if(!e->KeywordSet("MIDEXP"))
+	{
+	  if (e->KeywordSet("EPS"))
+	    {
+	      pos = e->KeywordIx("EPS");
+	      e->AssureDoubleScalarKWIfPresent(pos, eps);
+	      if(!isfinite(eps)) eps=1e-6;
+	   }
+	  else if (e->KeywordSet("DOUBLE") || p1->Type() == DOUBLE || p2->Type() == DOUBLE) eps = 1e-12;
+	  else eps = 1e-6;
+	}
+      else if  (e->KeywordSet("EPS"))
+	{
+	  pos = e->KeywordIx("EPS");
+	  e->AssureDoubleScalarKWIfPresent(pos, eps);
+	  if(!isfinite(eps)) eps=1e-6;
+	}
+      else if ((e->KeywordSet("DOUBLE") && e->KeywordSet("MIDEXP")) || p1->Type() == DOUBLE) eps = 1e-12;
+      else eps = 1e-6;
+
+    // Definition of JMAX
+    DLong wsize =static_cast<DLong>(pow(2.0, (20-1)));
+    if(e->KeywordSet("JMAX"))
+      {
+	pos = e->KeywordIx("JMAX");
+	e->AssureLongScalarKWIfPresent(pos, wsize);
+	wsize=static_cast<DLong>(pow(2.0, (wsize-1)));
+      }
+    gsl_integration_workspace *w = gsl_integration_workspace_alloc (wsize);
+
+    first=(*static_cast<DDoubleGDL*>(par1))[0];
+    if (!e->KeywordSet("MIDEXP")) last =(*static_cast<DDoubleGDL*>(par2))[0];
+    
+    for( SizeT i=0; i<nEl; i++) {
+      if (nEl1 > 1) {first=(*static_cast<DDoubleGDL*>(par1))[i];}
+      if ((!e->KeywordSet("MIDEXP")) && (nEl2 > 1)) {last =(*static_cast<DDoubleGDL*>(par2))[i];}
+      
+      if (debug) cout << "Boundaries : "<< first << " " << last <<endl;
+      
+      // intregation on open range [first,+inf[
+      if (e->KeywordSet("MIDEXP"))
+	{	 
+	  gsl_integration_qagiu(&F, first, 0, eps, wsize, w, &result, &error);
+	} 
+      else if (e->KeywordSet("MIDINF") || e->KeywordSet("MIDPNT") || e->KeywordSet("MIDSQL") || e->KeywordSet("MIDSQU") || e->KeywordSet("JMAX") || e->KeywordSet("K"))
+	{
+	  gsl_integration_qag(&F, first, last, 0, eps, GSL_INTEG_GAUSS61, wsize, w, &result, &error);
+	} 
+       else
+	{		  
+	  // intregation on open range ]first,last[
+	  gsl_integration_qag (&F, first, last, 0, eps, GSL_INTEG_GAUSS61, wsize, w, &result, &error);
+	}
+   
+      if (debug) cout << "Result : " << result << endl;
+     
+      (*res)[i]=result;
+    }
+
+    gsl_integration_workspace_free (w);
+
+    if (!e->KeywordSet("MIDEXP"))
+      {
+         if (e->KeywordSet("DOUBLE") || p1->Type() == DOUBLE || p2->Type() == DOUBLE) return res;
+	 else return res->Convert2(FLOAT, BaseGDL::CONVERT);
+      }
+    else if (e->KeywordSet("DOUBLE")  || p1->Type() == DOUBLE) return res;
+    else return res->Convert2(FLOAT, BaseGDL::CONVERT);
+  }
+
+
+//FZ_ROOT:compute polynomial roots
+
+  BaseGDL* fz_roots_fun(EnvT* e)
+  {
+
+    static int doubleIx = e->KeywordIx("DOUBLE");
+   
+    // Ascending coefficient array
+    BaseGDL* p0 = e->GetNumericArrayParDefined(0);
+    DDoubleGDL* coef = e->GetParAs<DDoubleGDL>(0);
+    
+    // GSL function
+    
+    if (ComplexType(p0->Type()))
+      {
+	e->Throw("Polynomials with complex coefficients not supported yet (FIXME!)");
+      }
+    
+    if (coef->N_Elements() < 2)
+      {
+	e->Throw("Degree of the polynomial must be strictly greather than zero");
+      }
+    
+    for (int i = 0; i <coef->N_Elements();i++)
+      {
+	if (!isfinite((*coef)[i])) e->Throw("Not a number and infinity are not supported");
+      }
+    
+    gsl_poly_complex_workspace* w = gsl_poly_complex_workspace_alloc (coef->N_Elements()); 
+    
+    SizeT resultSize = coef->N_Elements()-1;
+    vector<double> tmp(2 * resultSize);
+	
+    gsl_poly_complex_solve (&(*coef)[0],coef->N_Elements(),w, &(tmp[0]));
+    
+    gsl_poly_complex_workspace_free (w);
+    
+    int debug =0;
+    if (debug) {
+      for (int i = 0; i < resultSize; i++)
+      {
+	printf ("z%d = %+.18f %+.18f\n", i, tmp[2*i], tmp[2*i+1]);
+      }
+    }
+    DComplexDblGDL* result = new DComplexDblGDL(dimension(resultSize), BaseGDL::NOZERO);
+    for (SizeT i = 0; i < resultSize; ++i) 
+      {
+	(*result)[i] = complex<double>(tmp[2 * i], tmp[2 * i + 1]);
+      }
+      
+    return result->Convert2(
+			    e->KeywordSet(doubleIx) || p0->Type() == DOUBLE
+			    ? COMPLEXDBL 
+			    : COMPLEX, 
+			    BaseGDL::CONVERT);
+  }
+
+//FX_ROOT
+
+class fx_root_param
+{ 
+public: 
+EnvT* envt; 
+EnvUDT* nenvt;
+DComplexDblGDL* arg;  
+};
+
+complex<double> fx_root_function(complex<double> x,void* params)
+{
+  fx_root_param *p = static_cast<fx_root_param*>(params);
+  (*(p->arg))[0] = x;
+  BaseGDL* res;
+  res = p->envt->Interpreter()->call_fun(static_cast<DSubUD*>(p->nenvt->GetPro())->GetTree());
+  return (*static_cast<DComplexDblGDL*>(res))[0]; 
+}
+ 
+BaseGDL* fx_root_fun(EnvT* e)
+{       
+  //Sanity check
+  //SizeT nParam = e->NParam();
+  //cout << nParam << endl;
+  
+  //1-st argument: a 2-element real or complex initial guess array
+  BaseGDL* p0 = e->GetNumericArrayParDefined(0);
+  DComplexDblGDL* init = e->GetParAs<DComplexDblGDL>(0);
+  BaseGDL* par0 = p0->Convert2(COMPLEXDBL, BaseGDL::COPY);
+  auto_ptr<BaseGDL> par0_guard(par0);
+
+  if (init->N_Elements() != 3)
+    {
+      e->Throw("Initial guess vector must be a 3-element vector");
+    }
+  
+  // 2-nd argument : function name 
+  DString fun;
+  e->AssureScalarPar<DStringGDL>(1, fun);
+  fun = StrUpCase(fun);
+  //cout<<fun<<endl;
+  if (LibFunIx(fun) != -1)
+    e->Throw("only user-defined functions allowed (library-routine name given)");
+  
+  // GDL magick
+  StackGuard<EnvStackT> guard(e->Interpreter()->CallStack());
+  EnvUDT* newEnv = new EnvUDT(e, funList[GDLInterpreter::GetFunIx(fun)], NULL);
+  newEnv->SetNextPar(&par0);
+  e->Interpreter()->CallStack().push_back(newEnv);
+  
+  // Function parameter initialization  
+  fx_root_param param;
+  param.envt = e;
+  param.nenvt = newEnv;
+  param.arg = static_cast<DComplexDblGDL*>(par0);
+  
+  //3-rd argument : number of iteration
+  DLong max_iter =100;
+  if (e->KeywordSet("ITMAX"))
+    { 
+      int pos = e->KeywordIx("ITMAX");
+      e->AssureLongScalarKWIfPresent(pos, max_iter);
+    }
+  
+  //4-th argument : stopping criterion
+  DLong stop = 0;
+  if (e->KeywordSet("STOP"))
+    {
+      int pos = e->KeywordIx("STOP");
+      e->AssureLongScalarKWIfPresent(pos, stop);
+    }
+  
+  if (stop != 0 || stop != 1 || isfinite(stop) == 0)
+    {
+      DLong stop = 0;
+    }
+  
+  //5-th argument : tolerance criterion
+  DDouble tol = 0.0001;
+  if (e->KeywordSet("TOL"))
+    {
+      int pos = e->KeywordIx("TOL");
+      e->AssureDoubleScalarKWIfPresent(pos, tol);
+    }
+  if (isfinite(tol) == 0)
+    {
+      DDouble tol = 0.0001;
+    }
+     
+  //Mller method
+  //Initialization and interpolation 
+  
+  complex<double> x0((*init)[0].real(),(*init)[0].imag());
+  complex<double> x1((*init)[1].real(),(*init)[1].imag());
+  complex<double> x2((*init)[2].real(),(*init)[2].imag());
+  
+  //Security tests
+  if ( (x0.real() == x1.real() && x0.imag() == x1.imag()) || (x0.real() == x2.real() && x0.imag() == x2.imag()) || (x1.real() == x2.real() && x1.imag() == x2.imag()) )
+    {
+      e->Throw("Initial parameters must be different");
+    }
+  
+  if ((isfinite(x0.real()) == 0 || isfinite(x0.imag()) == 0) || (isfinite(x1.real()) == 0 || isfinite(x1.imag()) == 0) || (isfinite(x2.real()) == 0 || isfinite(x2.imag()) == 0))
+    {
+      e->Throw("Not a number and Infinity are not supported");
+    }
+
+  complex<double> fx0 = fx_root_function(x0,&param);
+  complex<double> fx1 = fx_root_function(x1,&param);
+  complex<double> fx2 = fx_root_function(x2,&param);
+  complex<double> den = (x0-x2)*(x1-x2)*(x0-x1);
+  complex<double> a = ((x1-x2)*(fx0-fx2)-(x0-x2)*(fx1-fx2))/den;
+  complex<double> b = (pow(x0-x2,2)*(fx1-fx2)-pow(x1-x2,2)*(fx0-fx2))/den;
+  complex<double> c = fx2;
+  complex<double> op;
+  
+  int iter = 0;
+  double stopcri;
+  DComplexDblGDL* res;
+  res=new DComplexDblGDL(1, BaseGDL::NOZERO);
+
+  // before going further, we check whether the "x_i" are roots ?!
+
+  int done=0;
+  if (abs(fx0) < tol) {(*res)[0] = x0; done=1;}
+  if (abs(fx1) < tol) {(*res)[0] = x1; done=1;}
+  if (abs(fx2) < tol) {(*res)[0] = x2; done=1;}
+
+  if (done ==0) {
+    complex<double> tmpdisc;
+    complex<double> discm;
+    complex<double> discp;    
+    int debug=0;
+    
+    do
+      {
+	iter++;
+	
+	if (stop == 1) {
+	  stopcri =abs(fx_root_function(x2,&param));
+	} else {
+          stopcri = abs(x1-x2);
+	}
+	
+	tmpdisc=sqrt(pow(b,2)-4.*a*c);
+	
+	if (debug) {
+	  cout << "Iteration " << iter << endl;
+	  cout << "x0: " << setprecision(15) << x0 << endl;
+	  cout << "x1: " << setprecision(15) << x1 << endl;
+	  cout << "x2: " << setprecision(15) << x2 << endl;
+	  cout << "tmpdisc "<< tmpdisc << endl;
+	}
+
+	discm=b-tmpdisc;
+	discp=b+tmpdisc;
+	
+	if (abs(discm) < abs(discp)) {op = 2.*c/discp;} else {op = 2.*c/discm;}
+	
+	x0 = x1;
+	x1 = x2;
+	x2 = x2 - op;
+	fx0 = fx1;
+	fx1 = fx2;
+	fx2 = fx_root_function(x2,&param);
+	den = (x0-x2)*(x1-x2)*(x0-x1);
+	a = ((x1-x2)*(fx0-fx2)-(x0-x2)*(fx1-fx2))/den;
+	b = (pow(x0-x2,2)*(fx1-fx2)-pow(x1-x2,2)*(fx0-fx2))/den;
+	c = fx2;
+	(*res)[0] = x1;
+    }
+    while (stopcri >= tol &&
+	   (isfinite(x2.real()) == 1 &&
+	    isfinite(x2.imag()) == 1) &&
+	   iter < max_iter);
+  }
+    
+  if ((*res)[0].imag() == 0)
+    {
+      DDoubleGDL* resreal;
+      resreal = new DDoubleGDL(1, BaseGDL::NOZERO);
+      (*resreal)[0] = (*res)[0].real();
+      
+      if (e->KeywordSet("DOUBLE") || 
+	  p0->Type() == COMPLEXDBL ||
+	  p0->Type() == DOUBLE)
+	{
+	  return resreal->Convert2(DOUBLE, BaseGDL::CONVERT);
+	}
+      else
+	{
+	  return resreal->Convert2(FLOAT, BaseGDL::CONVERT);
+	}
+    }
+  
+  if (e->KeywordSet("DOUBLE") ||
+      p0->Type() == COMPLEXDBL)
+    {
+      return res->Convert2(COMPLEXDBL, BaseGDL::CONVERT);
+    }
+  else
+    {
+      return res->Convert2(COMPLEX, BaseGDL::CONVERT);
+    }
+}
+  
   /*
    * SA: TODO:
    * constants: Catalan
@@ -2819,7 +3489,7 @@
     for (SizeT i = 0; i < resultSize; ++i) 
       (*result)[i] = complex<double>(tmp[2 * i], tmp[2 * i + 1]);
     
-    return result->Convert2(
+   return result->Convert2(
       e->KeywordSet(doubleIx) || p0->Type() == DOUBLE
         ? COMPLEXDBL 
         : COMPLEX, 
diff -ruN --exclude CVS gdl-0.9.2/src/gsl_fun.hpp gdl/src/gsl_fun.hpp
--- gdl-0.9.2/src/gsl_fun.hpp	2010-05-31 04:59:30.000000000 -0600
+++ gdl/src/gsl_fun.hpp	2012-06-27 04:13:57.000000000 -0600
@@ -49,6 +49,12 @@
   void inplacemxradixfft(double a[], double b[], 
 			 int ntot, int n, int nspan, int isn);
 
+  // the following by AC
+  BaseGDL* qromb_fun(EnvT* e);
+  BaseGDL* qromo_fun(EnvT* e);
+  BaseGDL* fz_roots_fun(EnvT* e);
+  BaseGDL* fx_root_fun(EnvT* e);
+
   // the following by SA
   BaseGDL* newton_broyden(EnvT* e);
   BaseGDL* constant(EnvT* e);
diff -ruN --exclude CVS gdl-0.9.2/src/gsl_matrix.cpp gdl/src/gsl_matrix.cpp
--- gdl-0.9.2/src/gsl_matrix.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/gsl_matrix.cpp	2012-02-13 06:34:34.000000000 -0700
@@ -0,0 +1,380 @@
+/***************************************************************************
+                          gsl_matrix.cpp  -  GSL GDL library function
+                             -------------------
+    begin                : Dec 9 2011
+    copyright            : (C) 2011 by Alain Coulais
+    email                : alaingdl@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "includefirst.hpp"
+
+#include <map>
+#include <cmath>
+
+#include "datatypes.hpp"
+#include "envt.hpp"
+#include "basic_fun.hpp"
+#include "gsl_fun.hpp"
+#include "dinterpreter.hpp"
+
+#include <gsl/gsl_sys.h>
+#include <gsl/gsl_linalg.h>
+
+// constant
+#include <gsl/gsl_math.h>
+
+//#define LOG10E 0.434294
+
+namespace lib {
+
+  using namespace std;
+
+  const int szdbl=sizeof(double);
+  const int szflt=sizeof(float);
+  const int szlng=sizeof(long);
+
+  void ludc_pro( EnvT* e)
+  {
+    //  cout << szdbl << " " <<szflt << " " << szlng << endl;
+
+    SizeT nParam=e->NParam(1);
+    //     if( nParam == 0)
+    //       e->Throw( "Incorrect number of arguments.");
+
+    BaseGDL* p0 = e->GetParDefined( 0);
+    
+    SizeT nEl = p0->N_Elements();
+    if( nEl == 0)
+      e->Throw( "Variable is undefined: " + e->GetParString(0));
+  
+    if (p0->Rank() > 2)
+      e->Throw( "Input must be a square matrix:" + e->GetParString(0));
+    
+    if (p0->Rank() > 1) {
+      if (p0->Dim(0) != p0->Dim(1))
+        e->Throw( "Input must be a square matrix:" + e->GetParString(0));
+    }
+
+    // status 
+    // check here, if not done, res would be pending in case of SetPar() throws
+    // SetPar() only throws in AssureGlobalPar()
+    if (nParam == 2) e->AssureGlobalPar( 1);
+
+    // only one element matrix
+
+    if (p0->Type() == COMPLEXDBL || p0->Type() == COMPLEX){
+      e->Throw( "Input type cannot be COMPLEX, please use LA_LUDC (not ready)");
+    }
+    
+    //DDoubleGDL* p0D = static_cast<DDoubleGDL*>( p0);
+    DDoubleGDL *p0D = e->GetParAs<DDoubleGDL>(0);
+
+    gsl_matrix *mat = gsl_matrix_alloc(p0->Dim(0), p0->Dim(0));
+   
+    memcpy(mat->data, &(*p0D)[0], nEl*szdbl);
+
+    gsl_permutation * p = gsl_permutation_alloc (p0->Dim(0));
+    int s;
+    gsl_linalg_LU_decomp (mat, p, &s);
+
+    int debug=0;
+    if (debug) {
+      cout << "permutation order: " << s << endl;
+      cout << "permutation vector:"<< endl;
+      gsl_permutation_fprintf (stdout, p, " %u");
+      cout << endl;
+    }
+    
+    // copying over p0 the updated matrix	
+    DLong dims[2] = {p0->Dim(0), p0->Dim(0)};
+    dimension dim0(dims, (SizeT) 2);
+
+    BaseGDL** p0Do = &e->GetPar( 0);
+    delete (*p0Do);
+    *p0Do = new DDoubleGDL(dim0, BaseGDL::NOZERO);  
+    memcpy(&(*(DDoubleGDL*) *p0Do)[0], mat->data,
+	   p0->Dim(0)*p0->Dim(0)*szdbl);
+
+    int double_flag=0;
+    if (p0->Type() == DOUBLE) double_flag=1;
+    if (e->KeywordSet("DOUBLE")) double_flag=1;
+    
+    // this code will always return DOUBLE because I don't know how to do :(
+    // AC 13-Feb-2012 : this is not working and I don't know how to do :(
+    // if (double_flag == 0)
+    // { p0->Convert2(FLOAT, BaseGDL::CONVERT); }
+
+    // copying over p1 the permutation vector
+    DLong n = p0->Dim(0);
+    dimension dim1(&n, (SizeT) 1);
+    BaseGDL** p1D = &e->GetPar( 1);
+    delete (*p1D);
+    *p1D = new DLongGDL(dim1, BaseGDL::NOZERO);
+    memcpy(&(*(DLongGDL*) *p1D)[0], p->data, 
+	   p0->Dim(0)*szlng);
+    
+    gsl_matrix_free(mat);
+    gsl_permutation_free(p);
+  
+  }
+  
+  BaseGDL* lusol_fun( EnvT* e)
+  {
+    SizeT nParam=e->NParam(1);
+    int s;
+    
+    //     if( nParam == 0)
+    //       e->Throw( "Incorrect number of arguments.");
+
+    // managing first input: Square Matrix
+
+    BaseGDL* p0 = e->GetParDefined( 0);
+    
+    SizeT nEl = p0->N_Elements();
+    if( nEl == 0)
+      e->Throw( "Variable is undefined: " + e->GetParString(0));
+  
+    if (p0->Rank() > 2)
+      e->Throw( "Input must be a square matrix:" + e->GetParString(0));
+    
+    if (p0->Rank() > 1) {
+      if (p0->Dim(0) != p0->Dim(1))
+        e->Throw( "Input must be a square matrix:" + e->GetParString(0));
+    }
+
+    // status 
+    // check here, if not done, res would be pending in case of SetPar() throws
+    // SetPar() only throws in AssureGlobalPar()
+    if (nParam == 2) e->AssureGlobalPar( 1);
+
+
+    // managing seconf input: Vector
+    BaseGDL* p1 = e->GetParDefined(1);
+    
+    SizeT nEl1 = p1->N_Elements();
+    if( nEl1 == 0)
+      e->Throw( "Variable is undefined: " + e->GetParString(1));
+    
+    if (p1->Rank() > 2)
+      e->Throw( "Input must be a Vector:" + e->GetParString(1));
+    
+
+    // managing third input: Vector
+    BaseGDL* p2 = e->GetParDefined(2);
+    
+    SizeT nEl2 = p2->N_Elements();
+    if( nEl2 == 0)
+      e->Throw( "Variable is undefined: " + e->GetParString(2));
+    
+    if (p2->Rank() > 2)
+      e->Throw( "Input must be a Vector:" + e->GetParString(2));
+    
+    if (p0->Type() == COMPLEXDBL || p0->Type() == COMPLEX){
+      e->Throw( "Input type cannot be COMPLEX, please use LA_LUDC (not ready)");
+    }
+  
+    DDoubleGDL *p0D = e->GetParAs<DDoubleGDL>(0);
+    gsl_matrix *mat = gsl_matrix_alloc(p0->Dim(0), p0->Dim(0));
+    memcpy(mat->data, &(*p0D)[0], nEl*szdbl);
+
+    DLongGDL* p1L =e->GetParAs<DLongGDL>(1);
+    gsl_permutation *p = gsl_permutation_alloc (nEl1);
+    memcpy(p->data, &(*p1L)[0], nEl1*szlng);
+      
+    DDoubleGDL *p2D = e->GetParAs<DDoubleGDL>(2);
+    gsl_vector *b = gsl_vector_alloc(nEl2);
+    memcpy(b->data, &(*p2D)[0], nEl1*szdbl);
+    
+    gsl_vector *x = gsl_vector_alloc(nEl2);
+      
+    // computation by GSL
+    gsl_linalg_LU_solve (mat, p, b, x);
+    
+    int debug=0;
+    if (debug) {
+      cout << "permutation order: " << s << endl;
+      cout << "permutation vector:";
+      gsl_permutation_fprintf (stdout, p, " %u");
+      cout << endl;
+      cout << "input vector:";
+      gsl_vector_fprintf (stdout, b, " %g");
+      cout << endl;
+      cout << "result vector:";
+      gsl_vector_fprintf (stdout, x, " %g");
+      cout << endl;
+    }
+      
+    DDoubleGDL* res = new DDoubleGDL( p2->Dim(), BaseGDL::NOZERO);
+    memcpy(&(*res)[0], x->data, nEl1*szdbl);
+	
+    gsl_matrix_free(mat);
+    gsl_vector_free(x);
+    gsl_permutation_free(p);
+
+    int double_flag=0;
+    if (p0->Type() == DOUBLE || p2->Type() == DOUBLE) double_flag=1;
+    if (e->KeywordSet("DOUBLE")) double_flag=1;
+
+    if (double_flag)
+      {	return res; }
+    else
+      { return res->Convert2(FLOAT, BaseGDL::CONVERT); }
+  }
+
+  BaseGDL* determ_fun( EnvT* e) {
+    SizeT nParam=e->NParam(1);
+    
+    // managing first input: Square Matrix
+    
+    BaseGDL* p0 = e->GetParDefined( 0);
+    
+    SizeT nEl = p0->N_Elements();
+    if( nEl == 0)
+      e->Throw( "Variable is undefined: " + e->GetParString(0));
+  
+    if (p0->Rank() > 2)
+      e->Throw( "Input must be a square matrix:" + e->GetParString(0));
+
+    if (p0->Rank() > 1) {
+      if (p0->Dim(0) != p0->Dim(1))
+        e->Throw( "Input must be a square matrix:" + e->GetParString(0));
+    }
+    
+    if (p0->Type() == COMPLEXDBL || p0->Type() == COMPLEX){
+      e->Throw( "Input type cannot be COMPLEX, please use LA_DETERM (not ready)");
+    }
+    
+    DDoubleGDL *p0D = e->GetParAs<DDoubleGDL>(0);
+    gsl_matrix *mat = gsl_matrix_alloc(p0->Dim(0), p0->Dim(0));
+    memcpy(mat->data, &(*p0D)[0], nEl*szdbl);
+      
+    gsl_permutation *p = gsl_permutation_alloc(p0->Dim(0));
+
+    int sign;
+    double determ=0.0;
+   
+    // computation by GSL
+    gsl_linalg_LU_decomp (mat, p, &sign);
+    determ=gsl_linalg_LU_det (mat, sign);
+
+    int debug=0;
+    if (debug) {
+      cout << "Determ : " << determ << endl;
+    }
+
+    gsl_matrix_free(mat);
+    gsl_permutation_free(p);
+
+    DDoubleGDL* res = new DDoubleGDL(1, BaseGDL::NOZERO);
+    (*res)[0]=determ;
+
+    int double_flag=0;
+    if (p0->Type() == DOUBLE) double_flag=1;
+    if (e->KeywordSet("DOUBLE")) double_flag=1;
+
+    if (double_flag)
+      {	return res; }
+    else
+      { return res->Convert2(FLOAT, BaseGDL::CONVERT); }
+  }
+  
+  BaseGDL* trisol_fun( EnvT* e) {
+    //    SizeT nParam=e->NParam(1);
+    
+    // managing first input: Square Matrix
+    
+    BaseGDL* p0 = e->GetParDefined(0); // sub-diag elements
+    BaseGDL* p1 = e->GetParDefined(1); // diagonal elements
+    BaseGDL* p2 = e->GetParDefined(2); // sup-diag elements
+    BaseGDL* p3 = e->GetParDefined(3); // right-hand side vector
+
+    SizeT nEl0 = p0->N_Elements();
+    if( nEl0 == 0) e->Throw( "Variable is undefined: " + e->GetParString(0));
+    SizeT nEl1 = p1->N_Elements();
+    if( nEl1 == 0) e->Throw( "Variable is undefined: " + e->GetParString(1));
+    SizeT nEl2 = p2->N_Elements();
+    if( nEl2 == 0) e->Throw( "Variable is undefined: " + e->GetParString(2));
+    SizeT nEl3 = p3->N_Elements();
+    if( nEl3 == 0) e->Throw( "Variable is undefined: " + e->GetParString(3));
+
+    //    cout << nEl0 << " " << nEl1 << " " << nEl2 << " " << nEl3 << " " << endl;
+
+    SizeT nEl = nEl0;
+    if (nEl1 != nEl) e->Throw( "Argument: " + e->GetParString(1)+" does not have correct size");
+    if (nEl2 != nEl) e->Throw( "Argument: " + e->GetParString(2)+" does not have correct size");
+    if (nEl3 != nEl) e->Throw( "Argument: " + e->GetParString(3)+" does not have correct size");
+    
+    int complex_flag=0;
+    if (p0->Type() == COMPLEXDBL || p0->Type() == COMPLEX) complex_flag=1;
+    if (p1->Type() == COMPLEXDBL || p1->Type() == COMPLEX) complex_flag=1;
+    if (p2->Type() == COMPLEXDBL || p2->Type() == COMPLEX) complex_flag=1;
+    if (p3->Type() == COMPLEXDBL || p3->Type() == COMPLEX) complex_flag=1;
+    if (complex_flag) {
+      e->Throw( "Input type cannot be COMPLEX, please use LA_TRISOL (not ready)");
+    }
+
+    // computations are done in Double type, conversion at the end
+    
+    DDoubleGDL *p0D = e->GetParAs<DDoubleGDL>(0);
+    gsl_vector *subd = gsl_vector_alloc(nEl-1);
+    memcpy(subd->data, &(*p0D)[1], (nEl-1)*szdbl);
+    
+    DDoubleGDL *p1D= e->GetParAs<DDoubleGDL>(1);// = static_cast<DDoubleGDL*>(p1);
+    gsl_vector *diag = gsl_vector_alloc(nEl);
+    memcpy(diag->data, &(*p1D)[0], nEl*szdbl);
+    
+    DDoubleGDL *p2D= e->GetParAs<DDoubleGDL>(2); // = static_cast<DDoubleGDL*>(p2);
+    gsl_vector *supd = gsl_vector_alloc(nEl-1);
+    memcpy(supd->data, &(*p2D)[0], (nEl-1)*szdbl);
+    
+    DDoubleGDL *p3D= e->GetParAs<DDoubleGDL>(3);// = static_cast<DDoubleGDL*>(p3);
+    gsl_vector *rhs = gsl_vector_alloc(nEl);
+    memcpy(rhs->data, &(*p3D)[0], nEl*szdbl);
+    
+    gsl_vector *x = gsl_vector_alloc(nEl);
+    
+    // computation by GSL  
+    int error_code=-1;
+    error_code=gsl_linalg_solve_tridiag (diag, supd, subd, rhs, x);
+
+    if (error_code > 0)
+      Message( e->GetProName() + ": GSL did return an error. Is realy the matrix Pos. Define ?");
+  
+    int debug=0;
+    if (debug) {
+      gsl_vector_fprintf (stdout, diag, "diag: %g");
+      gsl_vector_fprintf (stdout, subd, "subd: %g");
+      gsl_vector_fprintf (stdout, supd, "supd: %g");
+      gsl_vector_fprintf (stdout, rhs, "rhs: %g");
+      gsl_vector_fprintf (stdout, x, "res: %g");
+    }
+    
+    gsl_vector_free(diag);
+    gsl_vector_free(subd);
+    gsl_vector_free(supd);
+    gsl_vector_free(rhs);
+    
+    int double_flag=0;
+    if (p0->Type() == DOUBLE || p1->Type() == DOUBLE) double_flag=1;
+    if (p2->Type() == DOUBLE || p2->Type() == DOUBLE) double_flag=1;
+    if (e->KeywordSet("DOUBLE")) double_flag=1;
+    
+    DDoubleGDL* res = new DDoubleGDL(nEl, BaseGDL::NOZERO);
+    memcpy(&(*res)[0], x->data, nEl*szdbl);
+    
+    if (double_flag)
+      {	return res; }
+    else
+      { return res->Convert2(FLOAT, BaseGDL::CONVERT); }
+  }
+}
+
diff -ruN --exclude CVS gdl-0.9.2/src/gsl_matrix.hpp gdl/src/gsl_matrix.hpp
--- gdl-0.9.2/src/gsl_matrix.hpp	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/gsl_matrix.hpp	2012-02-02 10:13:24.000000000 -0700
@@ -0,0 +1,29 @@
+/***************************************************************************
+                          gsl_matrix.hpp  -  GSL GDL library function
+                             -------------------
+    begin                : Dec 9 2011
+    copyright            : (C) 2011 by Alain Coulais
+    email                : alaingdl@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "datatypes.hpp"
+#include "envt.hpp"
+
+namespace lib {
+
+  void ludc_pro( EnvT* e);
+  BaseGDL* lusol_fun( EnvT* e);
+  BaseGDL* determ_fun( EnvT* e);
+  BaseGDL* trisol_fun( EnvT* e);
+
+} // namespace
+
diff -ruN --exclude CVS gdl-0.9.2/src/initsysvar.cpp gdl/src/initsysvar.cpp
--- gdl-0.9.2/src/initsysvar.cpp	2011-11-08 14:52:06.000000000 -0700
+++ gdl/src/initsysvar.cpp	2011-11-22 15:29:19.000000000 -0700
@@ -42,7 +42,7 @@
   UInt pathIx, promptIx, edit_inputIx, quietIx, 
     dIx, pIx, xIx, yIx, zIx, vIx, gdlIx, cIx, MouseIx,
     errorStateIx, errorIx, errIx, err_stringIx, valuesIx,
-    journalIx, exceptIx, mapIx, cpuIx, dirIx, stimeIx, warnIx;
+    journalIx, exceptIx, mapIx, cpuIx, dirIx, stimeIx, warnIx, usersymIx;
 
   // !D structs
   const int nDevices = 4;
@@ -271,7 +271,13 @@
     DVar& jSysVar=*sysVarList[journalIx];
     static_cast<DLongGDL&>(*jSysVar.Data())[0] = jLUN;
   }
-
+  
+  DStructGDL* USYM()
+  {
+    DVar& pSysVar = *sysVarList[ usersymIx];
+    return static_cast<DStructGDL*>(pSysVar.Data());
+  }
+    
   // call only once in main
   void InitSysVar()
   { 
@@ -689,6 +695,24 @@
     warnIx     = sysVarList.size();
     sysVarList.push_back(warn);
 
+    // !USERSYM (sorry if this is not how to do the job!)
+    
+    DStructGDL* usersymData = new DStructGDL( "!USERSYM");
+    usersymData->NewTag("DIM", new DLongGDL(0));
+    usersymData->NewTag("FILL", new DIntGDL(0));
+    SizeT usersymDim = 1024;
+    {
+      DFloatGDL* tmp = new DFloatGDL( dimension( &usersymDim, one));
+      usersymData->NewTag("X", tmp); 
+    }
+    {
+      DFloatGDL* tmp = new DFloatGDL( dimension( &usersymDim, one));
+      usersymData->NewTag("Y", tmp); 
+    }
+    DVar *usym = new DVar ("USERSYM", usersymData);
+    usersymIx  = sysVarList.size();
+    sysVarList.push_back( usym);
+ 
   }
 
 }
diff -ruN --exclude CVS gdl-0.9.2/src/initsysvar.hpp gdl/src/initsysvar.hpp
--- gdl-0.9.2/src/initsysvar.hpp	2011-09-19 06:06:11.000000000 -0600
+++ gdl/src/initsysvar.hpp	2011-11-22 15:29:19.000000000 -0700
@@ -82,7 +82,10 @@
   DLong JournalLUN();
   void JournalLUN( DLong jLUN);
 
-  // initialize the predefined system variabes (!IDNAME)
+  // get and set USERSYM
+  DStructGDL* USYM();
+  
+  // initialize the predefined system variables (!IDNAME)
   void InitSysVar();
 }
 
diff -ruN --exclude CVS gdl-0.9.2/src/interp_multid.h gdl/src/interp_multid.h
--- gdl-0.9.2/src/interp_multid.h	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/interp_multid.h	2012-04-13 06:56:33.000000000 -0600
@@ -0,0 +1,801 @@
+#ifndef __INTERP_MULTID_H__
+#define __INTERP_MULTID_H__
+
+#include <gsl/gsl_interp.h>
+#include <gsl/gsl_errno.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+  enum missing_mode {
+    missing_NONE = 0,
+    missing_NEAREST,
+    missing_GIVEN
+  };
+ /* Gamma value for cubic interpolation and means to change it*/
+  static double gdl_cubic_gamma=-1.0;
+  void gdl_update_cubic_interpolation_coeff(double gammaValue)
+  {
+    gdl_cubic_gamma=-1;
+    if (gammaValue <=0 && gammaValue >= -1.0) gdl_cubic_gamma=gammaValue;
+  }
+
+  /* convolutions available */
+  double linConv(double d, double x0, double x1) {
+    return (1. - d)*x0 + d*x1;
+  }
+//idem cubConvParam but with param=-1.0 - replaced by cubConv Below
+//  double cubConv(double d, double x0, double x1, double x2, double x3) {
+//    return (-x0 + x1 - x2 + x3)*pow(d, 3) +(2 * x0 - 2 * x1 + x2 - x3) * pow(d, 2) + (-x0 + x2) * d + x1;
+//  }
+
+  double cubConv(double d, double x0, double x1, double x2, double x3) {
+    double g=gdl_cubic_gamma;
+    return ((g + 2) * pow(d, 3) - (g + 3) * pow(d, 2) + 1)*x1 +
+        ((g + 2) * pow((1 - d), 3) - (g + 3) * pow((1 - d), 2) + 1) * x2 +
+        (g * pow((1 + d), 3) -5 * g * pow((1 + d), 2) + 8 * g * (1 + d) - 4 * g) * x0 +
+        (g * pow((2 - d), 3) -5 * g * pow((2 - d), 2) + 8 * g * (2 - d) - 4 * g) * x3;
+  }
+
+  /* 1D */
+
+  typedef struct {
+    const char* name;
+    unsigned int min_size;
+    void* (*alloc)(size_t size);
+    int (*init)(void*, const double xa[], const double ta[], size_t xsize);
+    int (*eval)(const void*, const double xa[], const double ta[], size_t xsize, double x, gsl_interp_accel*, double* t);
+    void (*free)(void*);
+  } gdl_interp1d_type;
+
+  typedef struct {
+    const gdl_interp1d_type* type;
+    double xmin;
+    double xmax;
+    size_t xsize;
+    missing_mode mode;
+    double missing;
+    void* state;
+  } gdl_interp1d;
+
+  size_t gdl_interp1d_type_min_size(const gdl_interp1d_type* T) {
+    return T->min_size;
+  }
+
+  size_t gdl_interp1d_min_size(const gdl_interp1d* interp) {
+    return interp->type->min_size;
+  }
+
+  const char* gdl_interp1d_name(const gdl_interp1d* interp) {
+    return interp->type->name;
+  }
+
+  GSL_VAR const gdl_interp1d_type* gdl_interp1d_linear;
+  GSL_VAR const gdl_interp1d_type* gdl_interp1d_nearest;
+  GSL_VAR const gdl_interp1d_type* gdl_interp1d_cubic;
+
+  double gdl_interp1d_eval(const gdl_interp1d* interp, const double xarr[], const double tarr[], const double x, gsl_interp_accel* xa);
+
+  gdl_interp1d* gdl_interp1d_alloc(const gdl_interp1d_type* T, size_t xsize) {
+    gdl_interp1d* interp;
+    //    protection removed since interpolators are protected against index overflow. Mimics IDL.
+    //    if (xsize < T->min_size) {
+    //        GSL_ERROR_NULL("insufficient number of points for interpolation type", GSL_EINVAL);
+    //    }
+    interp = (gdl_interp1d*) malloc(sizeof (gdl_interp1d));
+    if (interp == NULL) {
+      GSL_ERROR_NULL("failed to allocate space for gdl_interp1d struct", GSL_ENOMEM);
+    }
+    interp->type = T;
+    interp->xsize = xsize;
+    if (interp->type->alloc == NULL) {
+      interp->state = NULL;
+      return interp;
+    }
+    interp->state = interp->type->alloc(xsize);
+    if (interp->state == NULL) {
+      free(interp);
+      GSL_ERROR_NULL("failed to allocate space for gdl_interp1d state", GSL_ENOMEM);
+    }
+    return interp;
+  }
+
+  int gdl_interp1d_init(gdl_interp1d* interp, const double xarr[], const double tarr[], size_t xsize, missing_mode mode, double missing, double gammaValue) {
+    size_t i;
+    if (xsize != interp->xsize) {
+      GSL_ERROR("data must match size of interpolation object", GSL_EINVAL);
+    }
+    for (i = 1; i < xsize; i++) {
+      if (xarr[i - 1] >= xarr[i]) {
+        GSL_ERROR("x values must be strictly increasing", GSL_EINVAL);
+      }
+    }
+    interp->xmin = xarr[0];
+    interp->xmax = xarr[xsize - 1];
+    interp->mode = mode;
+    interp->missing = missing;
+    gdl_update_cubic_interpolation_coeff(gammaValue);
+    {
+      int status = interp->type->init(interp->state, xarr, tarr, xsize);
+      return status;
+    }
+  }
+
+  void gdl_interp1d_free(gdl_interp1d* interp) {
+    if (!interp) {
+      return;
+    }
+    if (interp->type->free) {
+      interp->type->free(interp->state);
+    }
+    free(interp);
+  }
+
+  double gdl_interp1d_eval(const gdl_interp1d* interp, const double xarr[], const double tarr[], const double x, gsl_interp_accel* xa) {
+    double xx, t;
+    xx = x;
+    int status;
+    switch (interp->mode) {
+      case missing_NONE:
+        if (xx < interp->xmin || xx > interp->xmax) {
+          GSL_ERROR_VAL("interpolation error", GSL_EDOM, GSL_NAN);
+        }
+        break;
+      case missing_NEAREST:
+        if (xx < interp->xmin) xx = interp->xmin;
+        if (xx > interp->xmax) xx = interp->xmax;
+        break;
+      case missing_GIVEN:
+        if ((xx < interp->xmin) || (xx > interp->xmax)) {
+          return interp->missing;
+        }
+        break;
+    }
+    status = interp->type->eval(interp->state, xarr, tarr, interp->xsize, xx, xa, &t);
+    if ((status) != GSL_SUCCESS) GSL_ERROR_VAL("interpolation error", (status), GSL_NAN);
+
+    return t;
+  }
+
+  static int linear_init(void* state, const double xa[], const double ta[], size_t xsize) {
+    return GSL_SUCCESS;
+  }
+
+  static int nearest_init(void* state, const double xa[], const double ta[], size_t xsize) {
+    return GSL_SUCCESS;
+  }
+
+  static int cubic_init(void* state, const double xa[], const double ta[], size_t xsize) {
+  return GSL_SUCCESS;
+  }
+
+  static int cubic_eval(const void* state, const double xarr[], const double tarr[], size_t xsize, double x, gsl_interp_accel* xa, double* t) {
+    double xmin, xmax;
+    double dx;
+    double u;
+    size_t xm, xi, xp, xp2;
+    double kern[4];
+
+    if (xa != NULL) {
+      xi = gsl_interp_accel_find(xa, xarr, xsize, x);
+    } else {
+      xi = gsl_interp_bsearch(xarr, x, 0, xsize - 1);
+    }
+    xm = (xi > 0) ? xi - 1 : xi;
+    xp = (xi + 1 < xsize) ? xi + 1 : xi;
+    xp2 = (xp + 1 < xsize) ? xp + 1 : xp;
+
+    kern[0] = tarr[xm];
+    kern[1] = tarr[xi];
+    kern[2] = tarr[xp];
+    kern[3] = tarr[xp2];
+
+    xmin = xarr[xi];
+    xmax = xarr[xp];
+    dx = xmax - xmin;
+    u = (dx > 0.0) ? (x - xmin) / dx : 0.0;
+    *t = cubConv(u, kern[0], kern[1], kern[2], kern[3]);
+
+    return GSL_SUCCESS;
+  }
+
+  static int linear_eval(const void* state, const double xarr[], const double tarr[], size_t xsize, double x, gsl_interp_accel* xa, double* t) {
+    double xmin, xmax;
+    double dx;
+    double u;
+    size_t xi, xp;
+    double kern[2];
+    if (xa != NULL) {
+      xi = gsl_interp_accel_find(xa, xarr, xsize, x);
+    } else {
+      xi = gsl_interp_bsearch(xarr, x, 0, xsize - 1);
+    }
+    xp = (xi + 1 < xsize) ? xi + 1 : xi;
+
+    kern[0] = tarr[xi];
+    kern[1] = tarr[xp];
+
+    xmin = xarr[xi];
+    xmax = xarr[xp];
+    dx = xmax - xmin;
+    u = (dx > 0.0) ? (x - xmin) / dx : 0.0;
+
+    *t = linConv(u, kern[0], kern[1]);
+
+    return GSL_SUCCESS;
+  }
+
+  static int nearest_eval(const void* state, const double xarr[], const double tarr[], size_t xsize, double x, gsl_interp_accel* xa, double* t) {
+    size_t xmin;
+    xmin = (x < 0) ? 0 : x;
+    xmin = (xmin > xsize - 1) ? xsize - 1 : xmin;
+    *t = tarr[xmin];
+    return GSL_SUCCESS;
+  }
+
+  static const gdl_interp1d_type cubic_type = {
+    "cubic",
+    4,
+    NULL,
+    &cubic_init,
+    &cubic_eval
+  };
+
+  static const gdl_interp1d_type linear_type = {
+    "linear",
+    2,
+    NULL,
+    &linear_init,
+    &linear_eval
+  };
+
+  static const gdl_interp1d_type nearest_type = {
+    "nearest",
+    1,
+    NULL,
+    &nearest_init,
+    &nearest_eval
+  };
+
+  const gdl_interp1d_type* gdl_interp1d_linear = &linear_type;
+  const gdl_interp1d_type* gdl_interp1d_nearest = &nearest_type;
+  const gdl_interp1d_type* gdl_interp1d_cubic = &cubic_type;
+
+  /* 2D */
+
+  /* column-major index (FORTRAN, IDL) */
+#define INDEX_2D(xi, yi, xsize, ysize) (yi) * (xsize) + (xi)
+  /* row-major index (C, C++) */
+
+  /* #define INDEX_2D(xi, yi, xsize, ysize) (xi) * (ysize) + (yi)  */
+
+  typedef struct {
+    const char* name;
+    unsigned int min_size;
+    void* (*alloc)(size_t size);
+    int (*init)(void*, const double xa[], const double ya[], const double ta[], size_t xsize, size_t ysize);
+    int (*eval)(const void*, const double xa[], const double ya[], const double ta[], size_t xsize, size_t ysize, double x, double y, gsl_interp_accel*, gsl_interp_accel*, double* z);
+    void (*free)(void*);
+  } gdl_interp2d_type;
+
+  typedef struct {
+    const gdl_interp2d_type* type;
+    double xmin;
+    double xmax;
+    double ymin;
+    double ymax;
+    size_t xsize;
+    size_t ysize;
+    missing_mode mode;
+    double missing;
+    void* state;
+  } gdl_interp2d;
+
+  size_t gdl_interp2d_type_min_size(const gdl_interp2d_type* T) {
+    return T->min_size;
+  }
+
+  size_t gdl_interp2d_min_size(const gdl_interp2d* interp) {
+    return interp->type->min_size;
+  }
+
+  const char* gdl_interp2d_name(const gdl_interp2d* interp) {
+    return interp->type->name;
+  }
+  GSL_VAR const gdl_interp2d_type* gdl_interp2d_bilinear;
+  GSL_VAR const gdl_interp2d_type* gdl_interp2d_binearest;
+  GSL_VAR const gdl_interp2d_type* gdl_interp2d_bicubic;
+
+  double gdl_interp2d_eval(const gdl_interp2d* interp, const double xarr[], const double yarr[], const double tarr[], const double x, const double y, gsl_interp_accel* xa, gsl_interp_accel* ya);
+
+  gdl_interp2d* gdl_interp2d_alloc(const gdl_interp2d_type* T, size_t xsize, size_t ysize) {
+    gdl_interp2d* interp;
+    //    protection removed since interpolators are protected against index overflow. Mimics IDL.
+    //    if (xsize < T->min_size || ysize < T->min_size) {
+    //        GSL_ERROR_NULL("insufficient number of points for interpolation type", GSL_EINVAL);
+    //    }
+    interp = (gdl_interp2d*) malloc(sizeof (gdl_interp2d));
+    if (interp == NULL) {
+      GSL_ERROR_NULL("failed to allocate space for gdl_interp2d struct", GSL_ENOMEM);
+    }
+    interp->type = T;
+    interp->xsize = xsize;
+    interp->ysize = ysize;
+    if (interp->type->alloc == NULL) {
+      interp->state = NULL;
+      return interp;
+    }
+    interp->state = interp->type->alloc(xsize);
+    if (interp->state == NULL) {
+      free(interp);
+      GSL_ERROR_NULL("failed to allocate space for gdl_interp2d state", GSL_ENOMEM);
+    }
+    return interp;
+  }
+
+  int gdl_interp2d_init(gdl_interp2d* interp, const double xarr[], const double yarr[], const double tarr[], size_t xsize, size_t ysize, missing_mode mode, double missing, double gammaValue) {
+    size_t i;
+    if (xsize != interp->xsize || ysize != interp->ysize) {
+      GSL_ERROR("data must match size of interpolation object", GSL_EINVAL);
+    }
+    for (i = 1; i < xsize; i++) {
+      if (xarr[i - 1] >= xarr[i]) {
+        GSL_ERROR("x values must be strictly increasing", GSL_EINVAL);
+      }
+    }
+    for (i = 1; i < ysize; i++) {
+      if (yarr[i - 1] >= yarr[i]) {
+        GSL_ERROR("y values must be strictly increasing", GSL_EINVAL);
+      }
+    }
+    interp->xmin = xarr[0];
+    interp->xmax = xarr[xsize - 1];
+    interp->ymin = yarr[0];
+    interp->ymax = yarr[ysize - 1];
+    interp->mode = mode;
+    interp->missing = missing;
+    gdl_update_cubic_interpolation_coeff(gammaValue);
+   {
+      int status = interp->type->init(interp->state, xarr, yarr, tarr, xsize, ysize);
+      return status;
+    }
+  }
+
+  void gdl_interp2d_free(gdl_interp2d* interp) {
+    if (!interp) {
+      return;
+    }
+    if (interp->type->free) {
+      interp->type->free(interp->state);
+    }
+    free(interp);
+  }
+
+  double gdl_interp2d_eval(const gdl_interp2d* interp, const double xarr[], const double yarr[], const double tarr[], const double x, const double y, gsl_interp_accel* xa, gsl_interp_accel* ya) {
+    double xx, yy, t;
+    xx = x;
+    yy = y;
+    int status;
+    switch (interp->mode) {
+      case missing_NONE:
+        if (xx < interp->xmin || xx > interp->xmax) {
+          GSL_ERROR_VAL("interpolation error", GSL_EDOM, GSL_NAN);
+        }
+        if (yy < interp->ymin || yy > interp->ymax) {
+          GSL_ERROR_VAL("interpolation error", GSL_EDOM, GSL_NAN);
+        }
+        break;
+      case missing_NEAREST:
+        if (xx < interp->xmin) xx = interp->xmin;
+        if (xx > interp->xmax) xx = interp->xmax;
+        if (yy < interp->ymin) yy = interp->ymin;
+        if (yy > interp->ymax) yy = interp->ymax;
+        break;
+      case missing_GIVEN:
+        if ((xx < interp->xmin) || (xx > interp->xmax) || (yy < interp->ymin) || (yy > interp->ymax)) {
+          return interp->missing;
+        }
+    }
+    status = interp->type->eval(interp->state, xarr, yarr, tarr, interp->xsize, interp->ysize, xx, yy, xa, ya, &t);
+    if ((status) != GSL_SUCCESS) GSL_ERROR_VAL("interpolation error", (status), GSL_NAN);
+
+    return t;
+  }
+
+  static int bilinear_init(void* state, const double xa[], const double ya[], const double ta[], size_t xsize, size_t ysize) {
+    return GSL_SUCCESS;
+  }
+
+  static int binearest_init(void* state, const double xa[], const double ya[], const double ta[], size_t xsize, size_t ysize) {
+    return GSL_SUCCESS;
+  }
+
+  static int bicubic_init(void* state, const double xa[], const double ya[], const double ta[], size_t xsize, size_t ysize) {
+    return GSL_SUCCESS;
+  }
+
+  static int bicubic_eval(const void* state, const double xarr[], const double yarr[], const double tarr[], size_t xsize, size_t ysize, double x, double y, gsl_interp_accel* xa, gsl_interp_accel* ya, double* t) {
+    double xmin, xmax, ymin, ymax;
+    double dx, dy;
+    double v, u;
+    size_t xm, ym, xi, yi, xp, yp, xp2, yp2;
+    double kern[4][4];
+    double t1, t2, t3, t4;
+
+    if (xa != NULL) {
+      xi = gsl_interp_accel_find(xa, xarr, xsize, x);
+    } else {
+      xi = gsl_interp_bsearch(xarr, x, 0, xsize - 1);
+    }
+    xm = (xi > 0) ? xi - 1 : xi;
+    xp = (xi + 1 < xsize) ? xi + 1 : xi;
+    xp2 = (xp + 1 < xsize) ? xp + 1 : xp;
+    if (ya != NULL) {
+      yi = gsl_interp_accel_find(ya, yarr, ysize, y);
+    } else {
+      yi = gsl_interp_bsearch(yarr, y, 0, ysize - 1);
+    }
+    ym = (yi > 0) ? yi - 1 : yi;
+    yp = (yi + 1 < ysize) ? yi + 1 : yi;
+    yp2 = (yp + 1 < ysize) ? yp + 1 : yp;
+
+    kern[0][0] = tarr[INDEX_2D(xm, ym, xsize, ysize)];
+    kern[0][1] = tarr[INDEX_2D(xm, yi, xsize, ysize)];
+    kern[0][2] = tarr[INDEX_2D(xm, yp, xsize, ysize)];
+    kern[0][3] = tarr[INDEX_2D(xm, yp2, xsize, ysize)];
+
+    kern[1][0] = tarr[INDEX_2D(xi, ym, xsize, ysize)];
+    kern[1][1] = tarr[INDEX_2D(xi, yi, xsize, ysize)];
+    kern[1][2] = tarr[INDEX_2D(xi, yp, xsize, ysize)];
+    kern[1][3] = tarr[INDEX_2D(xi, yp2, xsize, ysize)];
+
+    kern[2][0] = tarr[INDEX_2D(xp, ym, xsize, ysize)];
+    kern[2][1] = tarr[INDEX_2D(xp, yi, xsize, ysize)];
+    kern[2][2] = tarr[INDEX_2D(xp, yp, xsize, ysize)];
+    kern[2][3] = tarr[INDEX_2D(xp, yp2, xsize, ysize)];
+
+    kern[3][0] = tarr[INDEX_2D(xp2, ym, xsize, ysize)];
+    kern[3][1] = tarr[INDEX_2D(xp2, yi, xsize, ysize)];
+    kern[3][2] = tarr[INDEX_2D(xp2, yp, xsize, ysize)];
+    kern[3][3] = tarr[INDEX_2D(xp2, yp2, xsize, ysize)];
+
+    xmin = xarr[xi];
+    xmax = xarr[xp];
+    ymin = yarr[yi];
+    ymax = yarr[yp];
+    dx = xmax - xmin;
+    dy = ymax - ymin;
+    u = (dx > 0.0) ? (x - xmin) / dx : 0.0;
+    v = (dy > 0.0) ? (y - ymin) / dy : 0.0;
+    t1 = cubConv(u, kern[0][0], kern[1][0], kern[2][0], kern[3][0]);
+    t2 = cubConv(u, kern[0][1], kern[1][1], kern[2][1], kern[3][1]);
+    t3 = cubConv(u, kern[0][2], kern[1][2], kern[2][2], kern[3][2]);
+    t4 = cubConv(u, kern[0][3], kern[1][3], kern[2][3], kern[3][3]);
+
+    *t = cubConv(v, t1, t2, t3, t4);
+
+    return GSL_SUCCESS;
+  }
+
+  static int bilinear_eval(const void* state, const double xarr[], const double yarr[], const double tarr[], size_t xsize, size_t ysize, double x, double y, gsl_interp_accel* xa, gsl_interp_accel* ya, double* t) {
+    double xmin, xmax, ymin, ymax;
+    double dx, dy;
+    double v, u;
+    size_t xi, yi, xp, yp;
+    double kern[2][2];
+    double t1, t2;
+
+    if (xa != NULL) {
+      xi = gsl_interp_accel_find(xa, xarr, xsize, x);
+    } else {
+      xi = gsl_interp_bsearch(xarr, x, 0, xsize - 1);
+    }
+    xp = (xi + 1 < xsize) ? xi + 1 : xi;
+
+    if (ya != NULL) {
+      yi = gsl_interp_accel_find(ya, yarr, ysize, y);
+    } else {
+      yi = gsl_interp_bsearch(yarr, y, 0, ysize - 1);
+    }
+    yp = (yi + 1 < ysize) ? yi + 1 : yi;
+
+    kern[0][0] = tarr[INDEX_2D(xi, yi, xsize, ysize)];
+    kern[0][1] = tarr[INDEX_2D(xi, yp, xsize, ysize)];
+
+    kern[1][0] = tarr[INDEX_2D(xp, yi, xsize, ysize)];
+    kern[1][1] = tarr[INDEX_2D(xp, yp, xsize, ysize)];
+
+    xmin = xarr[xi];
+    xmax = xarr[xp];
+    ymin = yarr[yi];
+    ymax = yarr[yp];
+    dx = xmax - xmin;
+    dy = ymax - ymin;
+    u = (dx > 0.0) ? (x - xmin) / dx : 0.0;
+    v = (dy > 0.0) ? (y - ymin) / dy : 0.0;
+    t1 = linConv(u, kern[0][0], kern[1][0]);
+    t2 = linConv(u, kern[0][1], kern[1][1]);
+
+    *t = linConv(v, t1, t2);
+
+    return GSL_SUCCESS;
+  }
+
+  static int binearest_eval(const void* state, const double xarr[], const double yarr[], const double tarr[], size_t xsize, size_t ysize, double x, double y, gsl_interp_accel* xa, gsl_interp_accel* ya, double* t) {
+    size_t xmin, ymin;
+    xmin = (x < 0) ? 0 : x;
+    xmin = (xmin > xsize - 1) ? xsize - 1 : xmin;
+    ymin = (y < 0) ? 0 : y;
+    ymin = (ymin > ysize - 1) ? ysize - 1 : ymin;
+    *t = tarr[INDEX_2D(xmin, ymin, xsize, ysize)];
+    return GSL_SUCCESS;
+  }
+
+  static const gdl_interp2d_type bicubic_type = {
+    "cubic",
+    4,
+    NULL,
+    &bicubic_init,
+    &bicubic_eval
+  };
+
+  static const gdl_interp2d_type bilinear_type = {
+    "linear",
+    2,
+    NULL,
+    &bilinear_init,
+    &bilinear_eval
+  };
+
+  static const gdl_interp2d_type binearest_type = {
+    "nearest",
+    1,
+    NULL,
+    &binearest_init,
+    &binearest_eval
+  };
+
+  const gdl_interp2d_type* gdl_interp2d_bilinear = &bilinear_type;
+  const gdl_interp2d_type* gdl_interp2d_binearest = &binearest_type;
+  const gdl_interp2d_type* gdl_interp2d_bicubic = &bicubic_type;
+
+  /* 3D */
+
+  /*column-major index (idl, fortran). Beware to keep all the parenthesis!*/
+#define INDEX_3D(xi, yi, zi, xsize, ysize, zsize) ((zi) * (ysize) + (yi)) * (xsize) + (xi)
+  /* row-major index (C, C++) */
+
+  /* #define INDEX_3D(xi, yi, zi, xsize, ysize, zsize) ((xi) * (ysize) + (yi) ) * (zsize) + (zi) */
+
+  typedef struct {
+    const char* name;
+    unsigned int min_size;
+    void* (*alloc)(size_t size);
+    int (*init)(void*, const double xa[], const double ya[], const double za[], const double ta[], size_t xsize, size_t ysize, size_t zsize);
+    int (*eval)(const void*, const double xa[], const double ya[], const double za[], const double ta[], size_t xsize, size_t ysize, size_t zsize, double x, double y, double z, gsl_interp_accel*, gsl_interp_accel*, gsl_interp_accel*, double* t);
+    void (*free)(void*);
+  } gdl_interp3d_type;
+
+  typedef struct {
+    const gdl_interp3d_type* type;
+    double xmin;
+    double xmax;
+    double ymin;
+    double ymax;
+    double zmin;
+    double zmax;
+    size_t xsize;
+    size_t ysize;
+    size_t zsize;
+    missing_mode mode;
+    double missing;
+    void* state;
+  } gdl_interp3d;
+
+  size_t gdl_interp3d_type_min_size(const gdl_interp3d_type* T) {
+    return T->min_size;
+  }
+
+  size_t gdl_interp3d_min_size(const gdl_interp3d* interp) {
+    return interp->type->min_size;
+  }
+
+  const char* gdl_interp3d_name(const gdl_interp3d* interp) {
+    return interp->type->name;
+  }
+
+  GSL_VAR const gdl_interp3d_type* gdl_interp3d_trilinear;
+
+  double gdl_interp3d_eval(const gdl_interp3d* interp, const double xarr[], const double yarr[], const double zarr[], const double tarr[], const double x, const double y, const double z, gsl_interp_accel* xa, gsl_interp_accel* ya, gsl_interp_accel* za);
+
+  gdl_interp3d* gdl_interp3d_alloc(const gdl_interp3d_type* T, size_t xsize, size_t ysize, size_t zsize) {
+    gdl_interp3d* interp;
+    //    if (xsize < T->min_size || ysize < T->min_size || zsize < T->min_size) {
+    //        GSL_ERROR_NULL("insufficient number of points for interpolation type", GSL_EINVAL);
+    //    }
+    interp = (gdl_interp3d*) malloc(sizeof (gdl_interp3d));
+    if (interp == NULL) {
+      GSL_ERROR_NULL("failed to allocate space for gdl_interp3d struct", GSL_ENOMEM);
+    }
+    interp->type = T;
+    interp->xsize = xsize;
+    interp->ysize = ysize;
+    interp->zsize = zsize;
+    if (interp->type->alloc == NULL) {
+      interp->state = NULL;
+      return interp;
+    }
+    interp->state = interp->type->alloc(xsize);
+    if (interp->state == NULL) {
+      free(interp);
+      GSL_ERROR_NULL("failed to allocate space for gdl_interp3d state", GSL_ENOMEM);
+    }
+    return interp;
+  }
+
+  int gdl_interp3d_init(gdl_interp3d* interp, const double xarr[], const double yarr[], const double zarr[], const double tarr[], size_t xsize, size_t ysize, size_t zsize, missing_mode mode, double missing) {
+    size_t i;
+    if (xsize != interp->xsize || ysize != interp->ysize || zsize != interp->zsize) {
+      GSL_ERROR("data must match size of interpolation object", GSL_EINVAL);
+    }
+    for (i = 1; i < xsize; i++) {
+      if (xarr[i - 1] >= xarr[i]) {
+        GSL_ERROR("x values must be strictly increasing", GSL_EINVAL);
+      }
+    }
+    for (i = 1; i < ysize; i++) {
+      if (yarr[i - 1] >= yarr[i]) {
+        GSL_ERROR("y values must be strictly increasing", GSL_EINVAL);
+      }
+    }
+    for (i = 1; i < zsize; i++) {
+      if (zarr[i - 1] >= zarr[i]) {
+        GSL_ERROR("z values must be strictly increasing", GSL_EINVAL);
+      }
+    }
+    interp->xmin = xarr[0 ];
+    interp->xmax = xarr[xsize - 1];
+    interp->ymin = yarr[0];
+    interp->ymax = yarr[ysize - 1];
+    interp->zmin = zarr[0];
+    interp->zmax = zarr[zsize - 1];
+    interp->mode = mode;
+    interp->missing = missing;
+    {
+      int status = interp->type->init(interp->state, xarr, yarr, zarr, tarr, xsize, ysize, zsize);
+      return status;
+    }
+  }
+
+  void gdl_interp3d_free(gdl_interp3d* interp) {
+    if (!interp) {
+      return;
+    }
+    if (interp->type->free) {
+      interp->type->free(interp->state);
+    }
+    free(interp);
+  }
+
+  double gdl_interp3d_eval(const gdl_interp3d* interp, const double xarr[], const double yarr[], const double zarr[], const double tarr[], const double x, const double y, const double z, gsl_interp_accel* xa, gsl_interp_accel* ya, gsl_interp_accel* za) {
+    double xx, yy, zz, t;
+    xx = x;
+    yy = y;
+    zz = z;
+    int status;
+    switch (interp->mode) {
+      case missing_NONE:
+        if (xx < interp->xmin || xx > interp->xmax) {
+          GSL_ERROR_VAL("interpolation error", GSL_EDOM, GSL_NAN);
+        }
+        if (yy < interp->ymin || yy > interp->ymax) {
+          GSL_ERROR_VAL("interpolation error", GSL_EDOM, GSL_NAN);
+        }
+        if (zz < interp->zmin || zz > interp->zmax) {
+          GSL_ERROR_VAL("interpolation error", GSL_EDOM, GSL_NAN);
+        }
+        break;
+      case missing_NEAREST:
+        if (xx < interp->xmin) xx = interp->xmin;
+        if (xx > interp->xmax) xx = interp->xmax;
+        if (yy < interp->ymin) yy = interp->ymin;
+        if (yy > interp->ymax) yy = interp->ymax;
+        if (zz < interp->zmin) zz = interp->zmin;
+        if (zz > interp->zmax) zz = interp->zmax;
+        break;
+      case missing_GIVEN:
+        if ((xx < interp->xmin) || (xx > interp->xmax) || (yy < interp->ymin) || (yy > interp->ymax) || (zz < interp->zmin) || (zz > interp->zmax)) {
+          t = interp->missing;
+          return t;
+        }
+    }
+    status = interp->type->eval(interp->state, xarr, yarr, zarr, tarr, interp->xsize,
+        interp->ysize, interp->zsize, xx, yy, zz, xa, ya, za, &t);
+    if ((status) != GSL_SUCCESS) GSL_ERROR_VAL("interpolation error", (status), GSL_NAN);
+    return t;
+  }
+
+  static int trilinear_init(void* state, const double xa[], const double ya[], const double za[], const double ta[], size_t xsize, size_t ysize, size_t zsize) {
+    return GSL_SUCCESS;
+  }
+
+  static int trilinear_eval(const void* state, const double xarr[], const double yarr[], const double zarr[], const double tarr[], size_t xsize, size_t ysize, size_t zsize, double x, double y, double z, gsl_interp_accel* xa, gsl_interp_accel* ya, gsl_interp_accel* za, double* t) {
+    double xmin, xmax, ymin, ymax, zmin, zmax;
+    double dx, dy, dz;
+    double u, v, w;
+    size_t xi, xp, yi, yp, zi, zp;
+    double kern[2][2];
+    double t1, t2, t12, t21;
+    if (xa != NULL) {
+      xi = gsl_interp_accel_find(xa, xarr, xsize, x);
+    } else {
+      xi = gsl_interp_bsearch(xarr, x, 0, xsize - 1);
+    }
+    xp = (xi + 1 < xsize) ? xi + 1 : xi;
+
+    if (ya != NULL) {
+      yi = gsl_interp_accel_find(ya, yarr, ysize, y);
+    } else {
+      yi = gsl_interp_bsearch(yarr, y, 0, ysize - 1);
+    }
+    yp = (yi + 1 < ysize) ? yi + 1 : yi;
+    if (za != NULL) {
+      zi = gsl_interp_accel_find(za, zarr, zsize, z);
+    } else {
+      zi = gsl_interp_bsearch(zarr, z, 0, zsize - 1);
+    }
+    zp = (zi + 1 < zsize) ? zi + 1 : zi;
+
+    xmin = xarr[xi];
+    xmax = xarr[xp];
+    ymin = yarr[yi];
+    ymax = yarr[yp];
+    zmin = zarr[zi];
+    zmax = zarr[zp];
+    dx = xmax - xmin;
+    dy = ymax - ymin;
+    dz = zmax - zmin;
+    u = (dx > 0.0) ? (x - xmin) / dx : 0.0;
+    v = (dy > 0.0) ? (y - ymin) / dy : 0.0;
+    w = (dz > 0.0) ? (z - zmin) / dz : 0.0;
+
+    kern[0][0] = tarr[INDEX_3D(xi, yi, zi, xsize, ysize, zsize)];
+    kern[1][0] = tarr[INDEX_3D(xp, yi, zi, xsize, ysize, zsize)];
+    kern[0][1] = tarr[INDEX_3D(xi, yp, zi, xsize, ysize, zsize)];
+    kern[1][1] = tarr[INDEX_3D(xp, yp, zi, xsize, ysize, zsize)];
+
+    t1 = linConv(u, kern[0][0], kern[1][0]);
+    t2 = linConv(u, kern[0][1], kern[1][1]);
+    t12 = linConv(v, t1, t2);
+
+    kern[0][0] = tarr[INDEX_3D(xi, yi, zp, xsize, ysize, zsize)];
+    kern[1][0] = tarr[INDEX_3D(xp, yi, zp, xsize, ysize, zsize)];
+    kern[0][1] = tarr[INDEX_3D(xi, yp, zp, xsize, ysize, zsize)];
+    kern[1][1] = tarr[INDEX_3D(xp, yp, zp, xsize, ysize, zsize)];
+
+    t1 = linConv(u, kern[0][0], kern[1][0]);
+    t2 = linConv(u, kern[0][1], kern[1][1]);
+    t21 = linConv(v, t1, t2);
+
+    *t = linConv(w, t12, t21);
+
+    return GSL_SUCCESS;
+  }
+
+  static const gdl_interp3d_type trilinear_type = {
+    "linear",
+    2,
+    NULL,
+    &trilinear_init,
+    &trilinear_eval
+  };
+
+  const gdl_interp3d_type* gdl_interp3d_trilinear = &trilinear_type;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -ruN --exclude CVS gdl-0.9.2/src/libinit_ac.cpp gdl/src/libinit_ac.cpp
--- gdl-0.9.2/src/libinit_ac.cpp	2010-09-21 16:48:41.000000000 -0600
+++ gdl/src/libinit_ac.cpp	2012-06-27 04:13:57.000000000 -0600
@@ -23,6 +23,8 @@
 #endif
 
 #include "math_fun_ac.hpp"
+#include "gsl_matrix.hpp"
+#include "gsl_fun.hpp"
 
 using namespace std;
 
@@ -31,6 +33,8 @@
   const char KLISTEND[] = "";
 
 #if defined(HAVE_LIBGSL)
+
+  // Besel functions family
   const string beseliKey[]={"DOUBLE","ITER","HELP",KLISTEND};
   new DLibFun(lib::beseli_fun,string("BESELI"),2,beseliKey);
   const string beseljKey[]={"DOUBLE","ITER","HELP",KLISTEND};
@@ -39,6 +43,33 @@
   new DLibFun(lib::beselk_fun,string("BESELK"),2,beselkKey);
   const string beselyKey[]={"DOUBLE","ITER","HELP",KLISTEND};
   new DLibFun(lib::besely_fun,string("BESELY"),2,beselyKey);
+
+  // Matrix functions family
+  const string ludcKey[]={"COLUMN","DOUBLE","INTERCHANGES",KLISTEND};
+  new DLibPro(lib::ludc_pro,string("LUDC"),2,ludcKey);
+  const string lusolKey[]={"COLUMN","DOUBLE",KLISTEND};
+  new DLibFun(lib::lusol_fun,string("LUSOL"),3,lusolKey);
+  const string determKey[]={"DOUBLE","CHECK","ZERO",KLISTEND};
+  new DLibFun(lib::determ_fun,string("DETERM"),1,determKey);
+
+  const string trisolKey[]={"DOUBLE",KLISTEND};
+  new DLibFun(lib::trisol_fun,string("TRISOL"),4,trisolKey);
+
+  // QSIMP/QROMB/QROMO (we used same code for QSIMP and QROMB)
+  const string qsimpKey[]={"DOUBLE","EPS","JMAX",KLISTEND};
+  new DLibFun(lib::qromb_fun,string("QSIMP"),3,qsimpKey);
+  const string qrombKey[]={"DOUBLE","EPS","JMAX","K",KLISTEND};
+  new DLibFun(lib::qromb_fun,string("QROMB"),3,qrombKey);
+  const string qromoKey[]={"DOUBLE","EPS","JMAX","K","MIDEXP",
+			   "MIDINF","MIDPNT","MIDSQL","MIDSQU",KLISTEND};
+  new DLibFun(lib::qromo_fun,string("QROMO"),3,qromoKey);
+  const string fz_rootsKey[]={"DOUBLE","EPS","NO_POLISH",KLISTEND};
+  new DLibFun(lib::fz_roots_fun,string("FZ_ROOTS"),3,fz_rootsKey);
+  const string fx_rootKey[]={"DOUBLE","ITMAX","STOP","TOL",KLISTEND};
+  new DLibFun(lib::fx_root_fun,string("FX_ROOT"),2,fx_rootKey);
+  
+
+
 #endif
   
   const string spl1Key[]={"YP0","YPN_1","DOUBLE","HELP",KLISTEND};
diff -ruN --exclude CVS gdl-0.9.2/src/libinit.cpp gdl/src/libinit.cpp
--- gdl-0.9.2/src/libinit.cpp	2011-09-19 06:06:11.000000000 -0600
+++ gdl/src/libinit.cpp	2012-05-25 04:47:14.000000000 -0600
@@ -282,7 +282,7 @@
   new DLibFunRetNew(lib::cindgen,string("CINDGEN"),MAXRANK,NULL,NULL,true);
   new DLibFunRetNew(lib::dcindgen,string("DCINDGEN"),MAXRANK,NULL,NULL,true);
 
-  new DLibFunRetNew(lib::n_elements,string("N_ELEMENTS"),1,NULL,NULL,true);
+  new DLibFunRetNew(lib::n_elements,string("N_ELEMENTS"),1,NULL,NULL,true,1);
 
   new DLibFun(lib::execute,string("EXECUTE"),2);
 
@@ -320,7 +320,7 @@
   new DLibPro(lib::writeu,string("WRITEU"),-1,writeuKey);
   new DLibPro(lib::readu,string("READU"),-1,writeuKey);
 
-  const string resolve_routineWarnKey[]={"EITHER","IS_FUNCTION","NO_RECOMPILE",KLISTEND};
+  const string resolve_routineWarnKey[]={"EITHER","IS_FUNCTION","NO_RECOMPILE","COMPILE_FULL_FILE",KLISTEND};
   const string resolve_routineKey[]={KLISTEND};
   new DLibPro(lib::resolve_routine,string("RESOLVE_ROUTINE"),1,
 	      NULL, resolve_routineWarnKey);
@@ -363,31 +363,33 @@
 
   new DLibFunRetNew(lib::gdl_logical_and,string("LOGICAL_AND"),2,NULL,NULL,true);
   new DLibFunRetNew(lib::gdl_logical_or,string("LOGICAL_OR"),2,NULL,NULL,true);
-  new DLibFunRetNew(lib::logical_true,string("LOGICAL_TRUE"),1,NULL,NULL,true);
+  new DLibFunDirect(lib::logical_true,string("LOGICAL_TRUE"));
 
   new DLibFunRetNew(lib::replicate,string("REPLICATE"),9,NULL,NULL,true);
   new DLibPro(lib::replicate_inplace_pro,string("REPLICATE_INPLACE"),6);
 
-  new DLibFunRetNew(lib::sin_fun,string("SIN"),1,NULL,NULL,true);
-  new DLibFunRetNew(lib::cos_fun,string("COS"),1,NULL,NULL,true);
-  new DLibFunRetNew(lib::tan_fun,string("TAN"),1,NULL,NULL,true);
-
-  new DLibFunRetNew(lib::sinh_fun,string("SINH"),1,NULL,NULL,true);
-  new DLibFunRetNew(lib::cosh_fun,string("COSH"),1,NULL,NULL,true);
-  new DLibFunRetNew(lib::tanh_fun,string("TANH"),1,NULL,NULL,true);
+  new DLibFunDirect(lib::sin_fun,string("SIN"));
+  new DLibFunDirect(lib::cos_fun,string("COS"));
+  new DLibFunDirect(lib::tan_fun,string("TAN"));//,1,NULL,NULL,true);
+
+  new DLibFunDirect(lib::sinh_fun,string("SINH"));//,1,NULL,NULL,true);
+  new DLibFunDirect(lib::cosh_fun,string("COSH"));//,1,NULL,NULL,true);
+  new DLibFunDirect(lib::tanh_fun,string("TANH"));//,1,NULL,NULL,true);
 
-  new DLibFunRetNew(lib::asin_fun,string("ASIN"),1,NULL,NULL,true);
-  new DLibFunRetNew(lib::acos_fun,string("ACOS"),1,NULL,NULL,true);
+  new DLibFunDirect(lib::asin_fun,string("ASIN"));
+  new DLibFunDirect(lib::acos_fun,string("ACOS"));
   const string atanKey[] = {"PHASE", KLISTEND};
   new DLibFunRetNew(lib::atan_fun,string("ATAN"),2,atanKey,NULL,true);
 
-  new DLibFunRetNew(lib::alog_fun,string("ALOG"),1,NULL,NULL,true);
-  new DLibFunRetNew(lib::alog10_fun,string("ALOG10"),1,NULL,NULL,true);
+  new DLibFunDirect(lib::alog_fun,string("ALOG"));
+  new DLibFunDirect(lib::alog10_fun,string("ALOG10"));
+//   new DLibFunRetNew(lib::alog_fun,string("ALOG"),1,NULL,NULL,true,1);
+//   new DLibFunRetNew(lib::alog10_fun,string("ALOG10"),1,NULL,NULL,true,1);
 
-  new DLibFunRetNew(lib::sqrt_fun,string("SQRT"),1,NULL,NULL,true);
-  new DLibFunRetNew(lib::abs_fun,string("ABS"),1,NULL,NULL,true);
+  new DLibFunDirect(lib::sqrt_fun,string("SQRT"));
+  new DLibFunDirect(lib::abs_fun,string("ABS"));
 
-  new DLibFunRetNew(lib::exp_fun,string("EXP"),1,NULL,NULL,true);
+  new DLibFunDirect(lib::exp_fun,string("EXP"));
 
   const string roundKey[]={"L64",KLISTEND};
   // retConstant: check definition of the rounding functions if they depend 
@@ -398,14 +400,16 @@
   new DLibFunRetNew(lib::ceil_fun,string("CEIL"),1,ceilfloorKey);
   new DLibFunRetNew(lib::floor_fun,string("FLOOR"),1,ceilfloorKey);
 
-  new DLibFunRetNew(lib::conj_fun,string("CONJ"),1);
-  new DLibFunRetNew(lib::imaginary_fun,string("IMAGINARY"),1);
+  new DLibFunDirect(lib::conj_fun,string("CONJ"));
+  new DLibFunDirect(lib::imaginary_fun,string("IMAGINARY"));
 
   const string strcompressKey[]={"REMOVE_ALL",KLISTEND};
   new DLibFunRetNew(lib::strcompress,string("STRCOMPRESS"),1,strcompressKey,NULL,true);
-  new DLibFunRetNew(lib::strlowcase,string("STRLOWCASE"),1,NULL,NULL,true);
-  new DLibFunRetNew(lib::strupcase,string("STRUPCASE"),1,NULL,NULL,true);
-  new DLibFunRetNew(lib::strlen,string("STRLEN"),1,NULL,NULL,true);
+  
+  new DLibFunDirect(lib::strlowcase,string("STRLOWCASE"));
+  new DLibFunDirect(lib::strupcase,string("STRUPCASE"));
+  new DLibFunDirect(lib::strlen,string("STRLEN"));
+
   const string strmidKey[]={"REVERSE_OFFSET",KLISTEND};
   new DLibFunRetNew(lib::strmid,string("STRMID"),3,strmidKey,NULL,true);
   new DLibFunRetNew(lib::strtrim,string("STRTRIM"),2,NULL,NULL,true);
@@ -493,6 +497,13 @@
     "ITALIC", "BOLD", KLISTEND};
   new DLibPro(lib::device,string("DEVICE"),0, deviceKey, deviceWarnKey);
 
+  const string usersymKey[]= 
+  {
+    "COLOR","FILL","THICK",
+    KLISTEND
+   };
+  new DLibPro(lib::usersym,string("USERSYM"),2, usersymKey);
+
   const string plotKey[]=
     {
      "BACKGROUND","CHARSIZE","CHARTHICK","CLIP",
@@ -508,12 +519,12 @@
      "YTICKS",    "YTITLE", "ZCHARSIZE",    "ZGRIDSTYLE", "ZMARGIN", "ZMINOR",
      "ZRANGE",    "ZSTYLE",     "ZTHICK",  "ZTICKFORMAT",
      "ZTICKLEN",  "ZTICKS",    "ZTITLE", "ZVALUE", "MAX_VALUE", "MIN_VALUE",
-     "XLOG",      "YLOG",     "YNOZERO", "XTYPE", "YTYPE", 
+     "XLOG",      "YLOG",     "YNOZERO", "XTYPE", "YTYPE", "POLAR", "NSUM",
      KLISTEND
     };
-  //"POLAR",
+  //
   const string plotWarnKey[]= {
-    "ISOTROPIC", "FONT", "T3D", "YTICKUNITS", "NSUM", "XTICKLAYOUT", "YTICKLAYOUT", 
+    "ISOTROPIC", "FONT", "T3D", "YTICKUNITS", "XTICKLAYOUT", "YTICKLAYOUT", 
     "ZTICKLAYOUT", "XGRIDSTYLE", "YGRIDSTYLE", "XTICKUNITS", "XTICKV", "XTICK_GET", "YTICKV",
     "YTICK_GET", "XTICKNAME", "ZTICKNAME", "ZTICKUNITS", "ZTICKV",  "ZTICK_GET",
     "XTICKINTERVAL", "YTICKINTERVAL", "YTICKNAME", "ZTICKINTERVAL", 
@@ -546,10 +557,19 @@
      "ZVALUE", 
 
      "SAVE", "XAXIS", "YAXIS", "XLOG", "YLOG", "XTYPE", "YTYPE", "YNOZERO", "THICK",
-     "XTICKINTERVAL", "YTICKINTERVAL",
-     KLISTEND
-    };
-  new DLibPro(lib::axis,string("AXIS"),3,axisKey);
+      KLISTEND
+     };
+   const string axisWarnKey[]=
+   {
+   "ZAXIS","ZLOG", 
+   "XTICKINTERVAL", "YTICKINTERVAL", "ZTICKINTERVAL",
+   "XTICKLAYOUT", "YTICKLAYOUT", "ZTICKLAYOUT",
+   "XTICKUNITS", "YTICKUNITS", "ZTICKUNITS",
+   "XTICKV", "YTICKV", "ZTICKV",
+   "XTICK_GET", "YTICK_GET", "ZTICK_GET",
+   KLISTEND
+  };
+  new DLibPro(lib::axis,string("AXIS"),3,axisKey,axisWarnKey);
 
   const string oplotKey[]=
     {
@@ -559,7 +579,7 @@
       // 4
       "PSYM", "SYMSIZE",  "T3D",  "THICK",
       // 8
-      "MAX_VALUE", "MIN_VALUE","NSUM",  "POLAR",
+      "MAX_VALUE", "MIN_VALUE", "NSUM", "POLAR",
       KLISTEND
     };
   new DLibPro(lib::oplot, string("OPLOT"),2,oplotKey);
@@ -627,13 +647,12 @@
 
      // SURFACE keywords
      // 73
-     "MAX_VALUE", "MIN_VALUE","AX", "AZ",
-     "XLOG", "XTYPE", "YLOG", "YTYPE", "ZLOG", "ZTYPE",
-     KLISTEND
+     "MAX_VALUE",  "MIN_VALUE", "AX", "AZ", "XLOG", "YLOG", "ZLOG", KLISTEND
     };
   const string surfaceWarnKey[]=
   {
-    "SAVE", KLISTEND 
+    "SAVE", "BOTTOM", "HORIZONTAL", "LOWER_ONLY", "UPPER_ONLY",
+    "SHADES", "SKIRT", "ZAXIS", "LEGO", KLISTEND
   };
   new DLibPro(lib::surface,string("SURFACE"),3,surfaceKey, surfaceWarnKey);
 
@@ -663,21 +682,31 @@
      "ZVALUE", 
      "LEVELS", "NLEVELS",
      "MAX_VALUE", "MIN_VALUE",
-     "XLOG", "XTYPE", "YLOG", "YTYPE", "ZLOG", "ZTYPE", "FILL",  "ISOTROPIC",
+     "XLOG", "XTYPE", "YLOG", "YTYPE", "ZLOG", "ZTYPE", "FILL", "ISOTROPIC",
      "FOLLOW", "C_CHARSIZE","OVERPLOT","C_COLORS","C_LINESTYLE",
      KLISTEND
     };
-  new DLibPro(lib::contour,string("CONTOUR"),3,contourKey);
+   const string contourWarnKey[]=
+    {
+        "CELL_FILL","C_LABELS","C_ANNOTATIONS", "C_CHARTHICK","C_ORIENTATION","C_SPACING","C_THICK",KLISTEND 
+    };
+   new DLibPro(lib::contour,string("CONTOUR"),3,contourKey,contourWarnKey);
 
+  // note that although  SIZE is not in IDL6+ documentation, it is widely used
+  // in place of CHARSIZE....
   const string xyoutsKey[]=
     {
       "COLOR","DATA","NORMAL","DEVICE","CLIP",
-      "ORIENTATION","ALIGNMENT","CHARSIZE","CHARTHICK",
-      "NOCLIP","Z","WIDTH",KLISTEND
+      "ORIENTATION","ALIGNMENT","CHARSIZE","SIZE","CHARTHICK",
+      "NOCLIP","Z","WIDTH","FONT",KLISTEND
     };
-  new DLibPro(lib::xyouts, string("XYOUTS"), 3, xyoutsKey);
-
-  const string polyfillKey[]=
+   const string xyoutsWarnKey[]=
+    {
+      "TEXT_AXES","T3D", KLISTEND 
+    };  
+   new DLibPro(lib::xyouts, string("XYOUTS"), 3, xyoutsKey, xyoutsWarnKey);
+   
+   const string polyfillKey[]=
     {
       "COLOR","DATA","NORMAL","DEVICE","CLIP","NOCLIP",
       "LINE_FILL","SPACING","LINESTYLE","ORIENTATION","THICK",
@@ -685,7 +714,8 @@
     };
   new DLibPro(lib::polyfill, string("POLYFILL"), 3, polyfillKey);
 
-  new DLibPro(lib::erase,string("ERASE"),1);
+  const string eraseKey[]= {"CHANNEL","COLOR",KLISTEND};
+  new DLibPro(lib::erase,string("ERASE"),1, eraseKey);
   
   const string laguerreKey[]={"DOUBLE","COEFFICIENTS",KLISTEND};
   new DLibFun(lib::laguerre,string("LAGUERRE"),3,laguerreKey);
diff -ruN --exclude CVS gdl-0.9.2/src/libinit_jmg.cpp gdl/src/libinit_jmg.cpp
--- gdl-0.9.2/src/libinit_jmg.cpp	2011-08-17 04:55:32.000000000 -0600
+++ gdl/src/libinit_jmg.cpp	2012-06-20 09:36:55.000000000 -0600
@@ -89,10 +89,10 @@
 
   const string histogramKey[]={"BINSIZE","INPUT","MAX","MIN","NBINS",
 			       "OMAX","OMIN","REVERSE_INDICES",
-			       "LOCATIONS",KLISTEND};
+			       "LOCATIONS","NAN",KLISTEND};
   new DLibFun(lib::histogram_fun,string("HISTOGRAM"),1,histogramKey);
 
-  const string interpolateKey[]={"CUBIC","GRID","MISSING",KLISTEND};
+  const string interpolateKey[]={"CUBIC","GRID","MISSING","NEAREST_NEIGHBOUR",KLISTEND};
   new DLibFun(lib::interpolate_fun,string("INTERPOLATE"),4,interpolateKey);
 
   const string la_triredKey[]={"DOUBLE","UPPER",KLISTEND};
@@ -123,7 +123,7 @@
   //       MAP_STRUCTURE, MLINESTYLE, MLINETHICK, SPACING, T3D, ZVALUE
   const string map_continentsKey[] = {"COLOR", "RIVERS", "COUNTRIES", 
     "HIRES", "FILL_CONTINENTS", KLISTEND};
-  const string map_continentsWarnKey[] = {"USA", KLISTEND};
+  const string map_continentsWarnKey[] = {"USA", "COASTS", KLISTEND};
   new DLibPro(lib::map_continents, string("MAP_CONTINENTS"), 0, 
     map_continentsKey, map_continentsWarnKey);
 
@@ -133,7 +133,7 @@
   new DLibFun(lib::convert_coord,string("CONVERT_COORD"),3,convert_coordKey);
 
 
-  const string finiteKey[]={"INFINITY","NAN",KLISTEND};
+  const string finiteKey[]={"INFINITY","NAN","SIGN",KLISTEND};
   new DLibFun(lib::finite_fun,string("FINITE"),1,finiteKey);
 
   const string radonKey[]={"BACKPROJECT","DOUBLE","DRHO","DX","DY",
@@ -249,7 +249,7 @@
  
 #endif
 
-  const string tvKey[]={"TRUE","NORMAL","CHANNEL","XSIZE","YSIZE","ORDER","DEVICE",KLISTEND};
+  const string tvKey[]={"TRUE","NORMAL","CHANNEL","XSIZE","YSIZE","ORDER","DEVICE","DATA",KLISTEND};
   new DLibPro(lib::tv,string("TV"),4,tvKey);
 
   const string tvrdKey[]={"CHANNEL","ORDER","TRUE","WORDS",KLISTEND};
diff -ruN --exclude CVS gdl-0.9.2/src/magick_cl.cpp gdl/src/magick_cl.cpp
--- gdl-0.9.2/src/magick_cl.cpp	2011-10-31 06:00:24.000000000 -0600
+++ gdl/src/magick_cl.cpp	2012-05-10 02:50:10.000000000 -0600
@@ -168,7 +168,8 @@
       Image a;
       try 
       {
-        a.ping(filename);
+	a.ping(filename);
+	//a.read(filename);
       }
       catch (WarningCoder &warning_ )
       {
@@ -182,12 +183,30 @@
         if (a.magick() != magick) return new DLongGDL(0); 
       }
   
-      DInt has_palette, pixel_type;
-      DLong channels, num_images, image_index;
-      DString type;
-     
+      int debug=0;
+      if (debug == 1) {
+	cout << "a.type()      :" << a.type() << endl;
+	cout << "a.classType() :" << a.classType() << endl;
+	cout << "a.matte()     :" << a.matte() << endl;
+	// no useful info here:cout << "a.colorSpace()     :" << a.colorSpace() << endl;
+	// Always 8:cout << "a.depth()     :" << a.depth() << endl;
+	// Always 1: cout << "a.colorSpace() :" << a.colorSpace() << endl;
+      }
+      
+      // AC 2012-May-10
+      // http://www.graphicsmagick.org/Magick++/Image.html#type
       // relevant information that, in some cases, is provided after pinging:
-      // a.type(), a.matte(), a.classType(), a.colorSpace()
+      // a.matte(), a.classType() [and a.type() for Palette info only]
+      DLong channels=0;
+      if (a.classType() == 1) channels=3; // DirectColor
+      if (a.classType() == 2) channels=1; // PseudoColor
+      if (channels ==0) cout << "no ClassType found for current Image" << endl;
+
+      // AC 2012-May-10 this is NOT working with only a a.ping()
+      // a.type() is FULLY reliable if and only if a.read() was done before !!! 
+      //http://www.graphicsmagick.org/Magick++/Image.html#type
+      // (should be OK with a a.read())
+      /*
       channels = a.classType() == PseudoClass 
         ? 1      // color palette
         : a.type() == GrayscaleType 
@@ -195,22 +214,34 @@
           : a.type() == ColorSeparationType 
             ? 4  // CMYK
             : 3; // RGB
+      */
+
+      // AC 2012-May-10 this is OK (reliable), see exemple "589 Lavandula mono"
       if (a.matte()) channels += 1;
 
       // TODO! multiple images (using the Magick++ STL interface)
+      DLong image_index, num_images;
       image_index = 0; 
       num_images = 1;
 
+      DInt pixel_type;
       pixel_type = a.depth() == 16 ? 2 : 1;
 
-      has_palette = a.classType() == PseudoClass ? 1 : 0;
+      // AC 2012-May-10 Palette only if type == 4 OR 5
+      // Despite Type is NOT useful without a a.read(), it is OK for Palette !
+      // This should be reliable (OK with ImageMagick AND GraphicsMagick)
+      DInt has_palette=0;
+      if (a.type() == 4 | a.type() == 5) has_palette=1;
 
       // TODO: 
-      // - JP2->JPEG2000 ?
+      // - JP2->JPEG2000 ?      
+      DString type;
       type = a.magick() == "PNM" ? "PPM" : 
              a.magick() == "DCM" ? "DICOM" :
              a.magick();
 
+      if (debug ==1) cout << "Type (via a.magick()) : " << type <<endl;
+
       static int infoIx = e->KeywordIx("INFO");
       if (e->KeywordPresent(infoIx))
       {
@@ -378,23 +409,40 @@
 
 	columns=image.columns();
 	rows=image.rows();
-	SizeT c[2];
-	c[0]=columns;
-	c[1]=rows;
-	dimension dim(c,2);
-	DByteGDL *bImage=new DByteGDL(dim,BaseGDL::NOZERO);
-
-	PixelPacket* pixel;
-	IndexPacket* index;
-	pixel=image.getPixels(0,0,columns,rows);
-	index=image.getIndexes();
-        if (index == NULL) e->Throw("(FIXME!) Magick's getIndexes() returned NULL for: " +e->GetParString(0));
-	unsigned int cx, cy;
-	for (cy=0;cy<rows;++cy)
-	  for (cx=0;cx<columns;++cx)
-	    (*bImage)[cx+(rows-cy-1)*columns]= index[cx+(cy)*columns];
-	
-	return bImage;
+
+	if (image.matte() == 0){
+	  
+	  SizeT c[2];
+	  c[0]=columns;
+	  c[1]=rows;
+	  dimension dim(c,2);
+	  DByteGDL *bImage=new DByteGDL(dim,BaseGDL::NOZERO);
+	  
+	  PixelPacket* pixel;
+	  IndexPacket* index;
+	  pixel=image.getPixels(0,0,columns,rows);
+	  index=image.getIndexes();
+	  string txt="(FIXME!) Magick's getIndexes() returned NULL for: ";
+	  if (index == NULL) e->Throw(txt + e->GetParString(0));
+	  unsigned int cx, cy;
+	  for (cy=0;cy<rows;++cy)
+	    for (cx=0;cx<columns;++cx)
+	      // note by AC, 07Feb2012: why this transpose here ??
+	      // (*bImage)[cx+(rows-cy-1)*columns]= index[cx+(cy)*columns];
+	      (*bImage)[cx+cy*columns]= index[cx+cy*columns];
+	  return bImage;
+	} else {
+	  // we do have to manage an extra channel for transparency
+	  string map="RA";
+	  SizeT c[3];
+	  c[0] = map.length(); // see code "magick_read" below
+	  c[1] = columns;
+	  c[2] = rows;
+	  dimension dim(c,3);
+	  DByteGDL *bImage=new DByteGDL(dim,BaseGDL::NOZERO);
+	  image.write(0,0,columns,rows,map, CharPixel,&(*bImage)[0]);
+	  return bImage;
+	} 
       }
     catch (Exception &error_ )
       {
@@ -402,7 +450,6 @@
       }
   }
 
-
   void magick_readcolormapRGB(EnvT* e)
   {
     try{
@@ -412,7 +459,6 @@
       Image image=magick_image(e,mid);
       if(image.classType()==DirectClass)
 	e->Throw("Not an indexed image: " +e->GetParString(0));
-      
 
       if(image.classType()==PseudoClass)
 	{
@@ -469,14 +515,13 @@
 		  (*B)[i]=(col.blueQuantum())*scale/Quant;
 		}
 	      if(nParam > 1) e->SetPar(1,R);
-		if(nParam > 2) e->SetPar(2,G);
-		if(nParam > 3) e->SetPar(3,B);
+	      if(nParam > 2) e->SetPar(2,G);
+	      if(nParam > 3) e->SetPar(3,B);
 	    }
-	    else
-	      {
-		e->Throw("Uknown Image type, too many colors");
-	      }
-	  
+	  else
+	    {
+	      e->Throw("Uknown Image type, too many colors");
+	    }	  
 	}
       else
 	{
@@ -522,6 +567,7 @@
 		map="BGR";
 	      }
 	  }
+
 	if(image.matte()) map=map+"A";
 
 	if(e->KeywordSet(2)) //MAP
@@ -914,50 +960,40 @@
   void magick_quantize(EnvT* e)
   {
     try{
-      size_t nParam=e->NParam(2);
+      size_t nParam=e->NParam();
+
       DUInt mid;
       e->AssureScalarPar<DUIntGDL>(0,mid);    
       Image image=magick_image(e,mid);
-      DLong ncol;      
+
       //set the number of colors;
-      if(!e->KeywordSet(0)) 
-	{
-	  if(nParam>1)
-	    e->AssureLongScalarPar(1,ncol);
-	  else
-	      ncol=256;
+      DLong ncol=256;
+      if(nParam>1) e->AssureLongScalarPar(1,ncol);
+      image.quantizeColors(ncol);
 
-	  image.quantizeColors(ncol);
-	  if(e->KeywordSet(1))//YUV
-	    image.quantizeColorSpace(YUVColorspace);
-	  else if(e->KeywordSet(2))//Grayscale
-	    image.quantizeColorSpace(GRAYColorspace);
-	  else
-	    image.quantizeColorSpace(RGBColorspace);
-	  if(e->KeywordSet(3)) 
+      if(e->KeywordSet("TRUECOLOR")) 
+	{
+	  image.quantizeColorSpace(RGBColorspace);
+	  image.quantizeColors((long)256*(long)256*(long)256-1);
+	  if(e->KeywordSet("DITHER")) 
 	    image.quantizeDither(true);
 	  image.quantize();
-	  image.classType(PseudoClass);
+	  image.classType(DirectClass);
 	}
       else
 	{
-	  //truecolor
-	  if(nParam>1)
-	    e->AssureLongScalarPar(1,ncol);
+	  if(e->KeywordSet("YUV"))//YUV
+	    image.quantizeColorSpace(YUVColorspace);
+	  else if(e->KeywordSet("GRAYSCALE"))//Grayscale
+	    image.quantizeColorSpace(GRAYColorspace);
 	  else
-	    ncol=256;
-
-	  image.quantizeColors(ncol);
-	  image.quantizeColorSpace(RGBColorspace);
-	  image.quantizeColors((long)256*(long)256*(long)256-1);
-	  if(e->KeywordSet(3)) 
+	    image.quantizeColorSpace(RGBColorspace);
+	  if(e->KeywordSet("DITHER")) 
 	    image.quantizeDither(true);
 	  image.quantize();
-	  image.classType(DirectClass);
-	  
+	  image.classType(PseudoClass);
 	}
       
-      
       magick_replace(e,mid,image);      
     }
     catch (Exception &error_ )
diff -ruN --exclude CVS gdl-0.9.2/src/Makefile.am gdl/src/Makefile.am
--- gdl-0.9.2/src/Makefile.am	2011-11-06 20:07:18.000000000 -0700
+++ gdl/src/Makefile.am	2012-06-27 16:36:53.000000000 -0600
@@ -24,7 +24,8 @@
 		gdlsvgstream.cpp gdlsvgstream.hpp gdlpython.cpp gdlpython.hpp \
 		GDLTokenTypes.hpp GDLTreeParser.cpp GDLTreeParser.hpp GDLTreeParserTokenTypes.hpp \
 		gdlwinstream.cpp gdlwinstream.hpp gdlxstream.cpp gdlxstream.hpp getfmtast.cpp \
-		getfmtast.hpp graphics.cpp graphics.hpp gsl_fun.cpp gsl_fun.hpp \
+		getfmtast.hpp graphics.cpp graphics.hpp \
+		gsl_fun.cpp gsl_fun.hpp gsl_matrix.cpp gsl_matrix.hpp \
 		gstream.hpp ifmt.cpp \
 		initct.cpp initsysvar.cpp initsysvar.hpp io.cpp io.hpp libinit_cl.cpp libinit.cpp \
 		libinit_jmg.cpp \
@@ -43,7 +44,7 @@
 		convol_inc1.cpp convol_inc2.cpp sigfpehandler.cpp sigfpehandler.hpp devicez.hpp \
 		gdlzstream.cpp gdlzstream.hpp gdlwidget.hpp arrayindexlistt.hpp arrayindexlistnoassoct.hpp \
 		arrayindex.cpp \
-		fftw.cpp fftw.hpp mpi.cpp mpi.hpp plot3d_nr.cpp grib.cpp grib.hpp \
+		fftw.cpp fftw.hpp mpi.cpp mpi.hpp grib.cpp grib.hpp \
                 prognode.cpp prognode_lexpr.cpp prognodeexpr.cpp strassenmatrix.hpp datatypesref.cpp lapack.cpp \
                 gshhs.cpp gshhs.hpp newprognode.cpp plotting_plot.cpp plotting_oplot.cpp \
                 plotting_device.cpp plotting_cursor.cpp plotting_contour.cpp plotting_surface.cpp \
diff -ruN --exclude CVS gdl-0.9.2/src/Makefile.in gdl/src/Makefile.in
--- gdl-0.9.2/src/Makefile.in	2011-11-06 20:07:18.000000000 -0700
+++ gdl/src/Makefile.in	2012-06-28 03:54:54.000000000 -0600
@@ -76,28 +76,28 @@
 	GDLTokenTypes.hpp GDLTreeParser.cpp GDLTreeParser.hpp \
 	GDLTreeParserTokenTypes.hpp gdlwinstream.cpp gdlwinstream.hpp \
 	gdlxstream.cpp gdlxstream.hpp getfmtast.cpp getfmtast.hpp \
-	graphics.cpp graphics.hpp gsl_fun.cpp gsl_fun.hpp gstream.hpp \
-	ifmt.cpp initct.cpp initsysvar.cpp initsysvar.hpp io.cpp \
-	io.hpp libinit_cl.cpp libinit.cpp libinit_jmg.cpp math_fun.cpp \
-	math_fun.hpp math_fun_jmg.cpp math_fun_jmg.hpp math_utl.cpp \
-	math_utl.hpp ncdf_att_cl.cpp ncdf_cl.cpp ncdf_cl.hpp \
-	ncdf_dim_cl.cpp ncdf_var_cl.cpp new.cpp new.hpp objects.cpp \
-	objects.hpp ofmt.cpp math_fun_ac.hpp math_fun_ac.cpp \
-	libinit_ac.cpp math_fun_gm.hpp math_fun_gm.cpp libinit_gm.cpp \
-	math_fun_ng.hpp math_fun_ng.cpp libinit_ng.cpp ofmt.hpp \
-	plotting.cpp plotting.hpp print.cpp print_tree.cpp \
-	print_tree.hpp read.cpp real2int.hpp str.cpp str.hpp \
-	terminfo.cpp terminfo.hpp topython.cpp typedefs.hpp \
-	typetraits.cpp typetraits.hpp hdf_fun.cpp hdf_fun.hpp \
-	hdf_pro.cpp hdf_pro.hpp magick_cl.cpp magick_cl.hpp \
-	specializations.hpp gdlwidget.cpp widget.cpp basegdl.cpp \
-	hdf5_fun.cpp hdf5_fun.hpp libinit_mes.cpp file.cpp file.hpp \
-	image.cpp image.hpp gdljournal.cpp gdljournal.hpp convol.cpp \
-	convol_inc0.cpp convol_inc1.cpp convol_inc2.cpp \
+	graphics.cpp graphics.hpp gsl_fun.cpp gsl_fun.hpp \
+	gsl_matrix.cpp gsl_matrix.hpp gstream.hpp ifmt.cpp initct.cpp \
+	initsysvar.cpp initsysvar.hpp io.cpp io.hpp libinit_cl.cpp \
+	libinit.cpp libinit_jmg.cpp math_fun.cpp math_fun.hpp \
+	math_fun_jmg.cpp math_fun_jmg.hpp math_utl.cpp math_utl.hpp \
+	ncdf_att_cl.cpp ncdf_cl.cpp ncdf_cl.hpp ncdf_dim_cl.cpp \
+	ncdf_var_cl.cpp new.cpp new.hpp objects.cpp objects.hpp \
+	ofmt.cpp math_fun_ac.hpp math_fun_ac.cpp libinit_ac.cpp \
+	math_fun_gm.hpp math_fun_gm.cpp libinit_gm.cpp math_fun_ng.hpp \
+	math_fun_ng.cpp libinit_ng.cpp ofmt.hpp plotting.cpp \
+	plotting.hpp print.cpp print_tree.cpp print_tree.hpp read.cpp \
+	real2int.hpp str.cpp str.hpp terminfo.cpp terminfo.hpp \
+	topython.cpp typedefs.hpp typetraits.cpp typetraits.hpp \
+	hdf_fun.cpp hdf_fun.hpp hdf_pro.cpp hdf_pro.hpp magick_cl.cpp \
+	magick_cl.hpp specializations.hpp gdlwidget.cpp widget.cpp \
+	basegdl.cpp hdf5_fun.cpp hdf5_fun.hpp libinit_mes.cpp file.cpp \
+	file.hpp image.cpp image.hpp gdljournal.cpp gdljournal.hpp \
+	convol.cpp convol_inc0.cpp convol_inc1.cpp convol_inc2.cpp \
 	sigfpehandler.cpp sigfpehandler.hpp devicez.hpp gdlzstream.cpp \
 	gdlzstream.hpp gdlwidget.hpp arrayindexlistt.hpp \
 	arrayindexlistnoassoct.hpp arrayindex.cpp fftw.cpp fftw.hpp \
-	mpi.cpp mpi.hpp plot3d_nr.cpp grib.cpp grib.hpp prognode.cpp \
+	mpi.cpp mpi.hpp grib.cpp grib.hpp prognode.cpp \
 	prognode_lexpr.cpp prognodeexpr.cpp strassenmatrix.hpp \
 	datatypesref.cpp lapack.cpp gshhs.cpp gshhs.hpp \
 	newprognode.cpp plotting_plot.cpp plotting_oplot.cpp \
@@ -116,18 +116,18 @@
 	gdlgstream.lo GDLInterpreter.lo GDLLexer.lo GDLParser.lo \
 	gdlpsstream.lo gdlsvgstream.lo gdlpython.lo GDLTreeParser.lo \
 	gdlwinstream.lo gdlxstream.lo getfmtast.lo graphics.lo \
-	gsl_fun.lo ifmt.lo initct.lo initsysvar.lo io.lo libinit_cl.lo \
-	libinit.lo libinit_jmg.lo math_fun.lo math_fun_jmg.lo \
-	math_utl.lo ncdf_att_cl.lo ncdf_cl.lo ncdf_dim_cl.lo \
-	ncdf_var_cl.lo new.lo objects.lo ofmt.lo math_fun_ac.lo \
-	libinit_ac.lo math_fun_gm.lo libinit_gm.lo math_fun_ng.lo \
-	libinit_ng.lo plotting.lo print.lo print_tree.lo read.lo \
-	str.lo terminfo.lo topython.lo typetraits.lo hdf_fun.lo \
-	hdf_pro.lo magick_cl.lo gdlwidget.lo widget.lo basegdl.lo \
-	hdf5_fun.lo libinit_mes.lo file.lo image.lo gdljournal.lo \
-	convol.lo convol_inc0.lo convol_inc1.lo convol_inc2.lo \
-	sigfpehandler.lo gdlzstream.lo arrayindex.lo fftw.lo mpi.lo \
-	plot3d_nr.lo grib.lo prognode.lo prognode_lexpr.lo \
+	gsl_fun.lo gsl_matrix.lo ifmt.lo initct.lo initsysvar.lo io.lo \
+	libinit_cl.lo libinit.lo libinit_jmg.lo math_fun.lo \
+	math_fun_jmg.lo math_utl.lo ncdf_att_cl.lo ncdf_cl.lo \
+	ncdf_dim_cl.lo ncdf_var_cl.lo new.lo objects.lo ofmt.lo \
+	math_fun_ac.lo libinit_ac.lo math_fun_gm.lo libinit_gm.lo \
+	math_fun_ng.lo libinit_ng.lo plotting.lo print.lo \
+	print_tree.lo read.lo str.lo terminfo.lo topython.lo \
+	typetraits.lo hdf_fun.lo hdf_pro.lo magick_cl.lo gdlwidget.lo \
+	widget.lo basegdl.lo hdf5_fun.lo libinit_mes.lo file.lo \
+	image.lo gdljournal.lo convol.lo convol_inc0.lo convol_inc1.lo \
+	convol_inc2.lo sigfpehandler.lo gdlzstream.lo arrayindex.lo \
+	fftw.lo mpi.lo grib.lo prognode.lo prognode_lexpr.lo \
 	prognodeexpr.lo datatypesref.lo lapack.lo gshhs.lo \
 	newprognode.lo plotting_plot.lo plotting_oplot.lo \
 	plotting_device.lo plotting_cursor.lo plotting_contour.lo \
@@ -171,28 +171,28 @@
 	GDLTokenTypes.hpp GDLTreeParser.cpp GDLTreeParser.hpp \
 	GDLTreeParserTokenTypes.hpp gdlwinstream.cpp gdlwinstream.hpp \
 	gdlxstream.cpp gdlxstream.hpp getfmtast.cpp getfmtast.hpp \
-	graphics.cpp graphics.hpp gsl_fun.cpp gsl_fun.hpp gstream.hpp \
-	ifmt.cpp initct.cpp initsysvar.cpp initsysvar.hpp io.cpp \
-	io.hpp libinit_cl.cpp libinit.cpp libinit_jmg.cpp math_fun.cpp \
-	math_fun.hpp math_fun_jmg.cpp math_fun_jmg.hpp math_utl.cpp \
-	math_utl.hpp ncdf_att_cl.cpp ncdf_cl.cpp ncdf_cl.hpp \
-	ncdf_dim_cl.cpp ncdf_var_cl.cpp new.cpp new.hpp objects.cpp \
-	objects.hpp ofmt.cpp math_fun_ac.hpp math_fun_ac.cpp \
-	libinit_ac.cpp math_fun_gm.hpp math_fun_gm.cpp libinit_gm.cpp \
-	math_fun_ng.hpp math_fun_ng.cpp libinit_ng.cpp ofmt.hpp \
-	plotting.cpp plotting.hpp print.cpp print_tree.cpp \
-	print_tree.hpp read.cpp real2int.hpp str.cpp str.hpp \
-	terminfo.cpp terminfo.hpp topython.cpp typedefs.hpp \
-	typetraits.cpp typetraits.hpp hdf_fun.cpp hdf_fun.hpp \
-	hdf_pro.cpp hdf_pro.hpp magick_cl.cpp magick_cl.hpp \
-	specializations.hpp gdlwidget.cpp widget.cpp basegdl.cpp \
-	hdf5_fun.cpp hdf5_fun.hpp libinit_mes.cpp file.cpp file.hpp \
-	image.cpp image.hpp gdljournal.cpp gdljournal.hpp convol.cpp \
-	convol_inc0.cpp convol_inc1.cpp convol_inc2.cpp \
+	graphics.cpp graphics.hpp gsl_fun.cpp gsl_fun.hpp \
+	gsl_matrix.cpp gsl_matrix.hpp gstream.hpp ifmt.cpp initct.cpp \
+	initsysvar.cpp initsysvar.hpp io.cpp io.hpp libinit_cl.cpp \
+	libinit.cpp libinit_jmg.cpp math_fun.cpp math_fun.hpp \
+	math_fun_jmg.cpp math_fun_jmg.hpp math_utl.cpp math_utl.hpp \
+	ncdf_att_cl.cpp ncdf_cl.cpp ncdf_cl.hpp ncdf_dim_cl.cpp \
+	ncdf_var_cl.cpp new.cpp new.hpp objects.cpp objects.hpp \
+	ofmt.cpp math_fun_ac.hpp math_fun_ac.cpp libinit_ac.cpp \
+	math_fun_gm.hpp math_fun_gm.cpp libinit_gm.cpp math_fun_ng.hpp \
+	math_fun_ng.cpp libinit_ng.cpp ofmt.hpp plotting.cpp \
+	plotting.hpp print.cpp print_tree.cpp print_tree.hpp read.cpp \
+	real2int.hpp str.cpp str.hpp terminfo.cpp terminfo.hpp \
+	topython.cpp typedefs.hpp typetraits.cpp typetraits.hpp \
+	hdf_fun.cpp hdf_fun.hpp hdf_pro.cpp hdf_pro.hpp magick_cl.cpp \
+	magick_cl.hpp specializations.hpp gdlwidget.cpp widget.cpp \
+	basegdl.cpp hdf5_fun.cpp hdf5_fun.hpp libinit_mes.cpp file.cpp \
+	file.hpp image.cpp image.hpp gdljournal.cpp gdljournal.hpp \
+	convol.cpp convol_inc0.cpp convol_inc1.cpp convol_inc2.cpp \
 	sigfpehandler.cpp sigfpehandler.hpp devicez.hpp gdlzstream.cpp \
 	gdlzstream.hpp gdlwidget.hpp arrayindexlistt.hpp \
 	arrayindexlistnoassoct.hpp arrayindex.cpp fftw.cpp fftw.hpp \
-	mpi.cpp mpi.hpp plot3d_nr.cpp grib.cpp grib.hpp prognode.cpp \
+	mpi.cpp mpi.hpp grib.cpp grib.hpp prognode.cpp \
 	prognode_lexpr.cpp prognodeexpr.cpp strassenmatrix.hpp \
 	datatypesref.cpp lapack.cpp gshhs.cpp gshhs.hpp \
 	newprognode.cpp plotting_plot.cpp plotting_oplot.cpp \
@@ -222,7 +222,8 @@
 	gdl-gdlpython.$(OBJEXT) gdl-GDLTreeParser.$(OBJEXT) \
 	gdl-gdlwinstream.$(OBJEXT) gdl-gdlxstream.$(OBJEXT) \
 	gdl-getfmtast.$(OBJEXT) gdl-graphics.$(OBJEXT) \
-	gdl-gsl_fun.$(OBJEXT) gdl-ifmt.$(OBJEXT) gdl-initct.$(OBJEXT) \
+	gdl-gsl_fun.$(OBJEXT) gdl-gsl_matrix.$(OBJEXT) \
+	gdl-ifmt.$(OBJEXT) gdl-initct.$(OBJEXT) \
 	gdl-initsysvar.$(OBJEXT) gdl-io.$(OBJEXT) \
 	gdl-libinit_cl.$(OBJEXT) gdl-libinit.$(OBJEXT) \
 	gdl-libinit_jmg.$(OBJEXT) gdl-math_fun.$(OBJEXT) \
@@ -246,16 +247,16 @@
 	gdl-convol_inc1.$(OBJEXT) gdl-convol_inc2.$(OBJEXT) \
 	gdl-sigfpehandler.$(OBJEXT) gdl-gdlzstream.$(OBJEXT) \
 	gdl-arrayindex.$(OBJEXT) gdl-fftw.$(OBJEXT) gdl-mpi.$(OBJEXT) \
-	gdl-plot3d_nr.$(OBJEXT) gdl-grib.$(OBJEXT) \
-	gdl-prognode.$(OBJEXT) gdl-prognode_lexpr.$(OBJEXT) \
-	gdl-prognodeexpr.$(OBJEXT) gdl-datatypesref.$(OBJEXT) \
-	gdl-lapack.$(OBJEXT) gdl-gshhs.$(OBJEXT) \
-	gdl-newprognode.$(OBJEXT) gdl-plotting_plot.$(OBJEXT) \
-	gdl-plotting_oplot.$(OBJEXT) gdl-plotting_device.$(OBJEXT) \
-	gdl-plotting_cursor.$(OBJEXT) gdl-plotting_contour.$(OBJEXT) \
-	gdl-plotting_surface.$(OBJEXT) gdl-plotting_axis.$(OBJEXT) \
-	gdl-plotting_plots.$(OBJEXT) gdl-plotting_xyouts.$(OBJEXT) \
-	gdl-plotting_polyfill.$(OBJEXT) gdl-plotting_windows.$(OBJEXT) \
+	gdl-grib.$(OBJEXT) gdl-prognode.$(OBJEXT) \
+	gdl-prognode_lexpr.$(OBJEXT) gdl-prognodeexpr.$(OBJEXT) \
+	gdl-datatypesref.$(OBJEXT) gdl-lapack.$(OBJEXT) \
+	gdl-gshhs.$(OBJEXT) gdl-newprognode.$(OBJEXT) \
+	gdl-plotting_plot.$(OBJEXT) gdl-plotting_oplot.$(OBJEXT) \
+	gdl-plotting_device.$(OBJEXT) gdl-plotting_cursor.$(OBJEXT) \
+	gdl-plotting_contour.$(OBJEXT) gdl-plotting_surface.$(OBJEXT) \
+	gdl-plotting_axis.$(OBJEXT) gdl-plotting_plots.$(OBJEXT) \
+	gdl-plotting_xyouts.$(OBJEXT) gdl-plotting_polyfill.$(OBJEXT) \
+	gdl-plotting_windows.$(OBJEXT) \
 	gdl-plotting_convert_coord.$(OBJEXT) \
 	gdl-plotting_map_proj.$(OBJEXT) gdl-plotting_misc.$(OBJEXT) \
 	gdl-plotting_erase.$(OBJEXT) gdl-semshm.$(OBJEXT)
@@ -365,6 +366,7 @@
 FGREP = @FGREP@
 GDLDATADIR = @GDLDATADIR@
 GREP = @GREP@
+GraphicsMagickConfig = @GraphicsMagickConfig@
 HAVE_64BIT_OS = @HAVE_64BIT_OS@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -494,7 +496,8 @@
 		gdlsvgstream.cpp gdlsvgstream.hpp gdlpython.cpp gdlpython.hpp \
 		GDLTokenTypes.hpp GDLTreeParser.cpp GDLTreeParser.hpp GDLTreeParserTokenTypes.hpp \
 		gdlwinstream.cpp gdlwinstream.hpp gdlxstream.cpp gdlxstream.hpp getfmtast.cpp \
-		getfmtast.hpp graphics.cpp graphics.hpp gsl_fun.cpp gsl_fun.hpp \
+		getfmtast.hpp graphics.cpp graphics.hpp \
+		gsl_fun.cpp gsl_fun.hpp gsl_matrix.cpp gsl_matrix.hpp \
 		gstream.hpp ifmt.cpp \
 		initct.cpp initsysvar.cpp initsysvar.hpp io.cpp io.hpp libinit_cl.cpp libinit.cpp \
 		libinit_jmg.cpp \
@@ -513,7 +516,7 @@
 		convol_inc1.cpp convol_inc2.cpp sigfpehandler.cpp sigfpehandler.hpp devicez.hpp \
 		gdlzstream.cpp gdlzstream.hpp gdlwidget.hpp arrayindexlistt.hpp arrayindexlistnoassoct.hpp \
 		arrayindex.cpp \
-		fftw.cpp fftw.hpp mpi.cpp mpi.hpp plot3d_nr.cpp grib.cpp grib.hpp \
+		fftw.cpp fftw.hpp mpi.cpp mpi.hpp grib.cpp grib.hpp \
                 prognode.cpp prognode_lexpr.cpp prognodeexpr.cpp strassenmatrix.hpp datatypesref.cpp lapack.cpp \
                 gshhs.cpp gshhs.hpp newprognode.cpp plotting_plot.cpp plotting_oplot.cpp \
                 plotting_device.cpp plotting_cursor.cpp plotting_contour.cpp plotting_surface.cpp \
@@ -736,6 +739,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-grib.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-gshhs.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-gsl_fun.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-gsl_matrix.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-hdf5_fun.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-hdf_fun.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-hdf_pro.Po@am__quote@
@@ -768,7 +772,6 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-newprognode.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-objects.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-ofmt.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-plot3d_nr.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-plotting.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-plotting_axis.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gdl-plotting_contour.Po@am__quote@
@@ -814,6 +817,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/grib.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gshhs.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gsl_fun.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gsl_matrix.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hdf5_fun.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hdf_fun.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hdf_pro.Plo@am__quote@
@@ -846,7 +850,6 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/newprognode.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/objects.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ofmt.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/plot3d_nr.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/plotting.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/plotting_axis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/plotting_contour.Plo@am__quote@
@@ -1515,6 +1518,20 @@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -c -o gdl-gsl_fun.obj `if test -f 'gsl_fun.cpp'; then $(CYGPATH_W) 'gsl_fun.cpp'; else $(CYGPATH_W) '$(srcdir)/gsl_fun.cpp'; fi`
 
+gdl-gsl_matrix.o: gsl_matrix.cpp
+@am__fastdepCXX_TRUE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -MT gdl-gsl_matrix.o -MD -MP -MF $(DEPDIR)/gdl-gsl_matrix.Tpo -c -o gdl-gsl_matrix.o `test -f 'gsl_matrix.cpp' || echo '$(srcdir)/'`gsl_matrix.cpp
+@am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/gdl-gsl_matrix.Tpo $(DEPDIR)/gdl-gsl_matrix.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='gsl_matrix.cpp' object='gdl-gsl_matrix.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -c -o gdl-gsl_matrix.o `test -f 'gsl_matrix.cpp' || echo '$(srcdir)/'`gsl_matrix.cpp
+
+gdl-gsl_matrix.obj: gsl_matrix.cpp
+@am__fastdepCXX_TRUE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -MT gdl-gsl_matrix.obj -MD -MP -MF $(DEPDIR)/gdl-gsl_matrix.Tpo -c -o gdl-gsl_matrix.obj `if test -f 'gsl_matrix.cpp'; then $(CYGPATH_W) 'gsl_matrix.cpp'; else $(CYGPATH_W) '$(srcdir)/gsl_matrix.cpp'; fi`
+@am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/gdl-gsl_matrix.Tpo $(DEPDIR)/gdl-gsl_matrix.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='gsl_matrix.cpp' object='gdl-gsl_matrix.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -c -o gdl-gsl_matrix.obj `if test -f 'gsl_matrix.cpp'; then $(CYGPATH_W) 'gsl_matrix.cpp'; else $(CYGPATH_W) '$(srcdir)/gsl_matrix.cpp'; fi`
+
 gdl-ifmt.o: ifmt.cpp
 @am__fastdepCXX_TRUE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -MT gdl-ifmt.o -MD -MP -MF $(DEPDIR)/gdl-ifmt.Tpo -c -o gdl-ifmt.o `test -f 'ifmt.cpp' || echo '$(srcdir)/'`ifmt.cpp
 @am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/gdl-ifmt.Tpo $(DEPDIR)/gdl-ifmt.Po
@@ -2229,20 +2246,6 @@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -c -o gdl-mpi.obj `if test -f 'mpi.cpp'; then $(CYGPATH_W) 'mpi.cpp'; else $(CYGPATH_W) '$(srcdir)/mpi.cpp'; fi`
 
-gdl-plot3d_nr.o: plot3d_nr.cpp
-@am__fastdepCXX_TRUE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -MT gdl-plot3d_nr.o -MD -MP -MF $(DEPDIR)/gdl-plot3d_nr.Tpo -c -o gdl-plot3d_nr.o `test -f 'plot3d_nr.cpp' || echo '$(srcdir)/'`plot3d_nr.cpp
-@am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/gdl-plot3d_nr.Tpo $(DEPDIR)/gdl-plot3d_nr.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='plot3d_nr.cpp' object='gdl-plot3d_nr.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -c -o gdl-plot3d_nr.o `test -f 'plot3d_nr.cpp' || echo '$(srcdir)/'`plot3d_nr.cpp
-
-gdl-plot3d_nr.obj: plot3d_nr.cpp
-@am__fastdepCXX_TRUE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -MT gdl-plot3d_nr.obj -MD -MP -MF $(DEPDIR)/gdl-plot3d_nr.Tpo -c -o gdl-plot3d_nr.obj `if test -f 'plot3d_nr.cpp'; then $(CYGPATH_W) 'plot3d_nr.cpp'; else $(CYGPATH_W) '$(srcdir)/plot3d_nr.cpp'; fi`
-@am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/gdl-plot3d_nr.Tpo $(DEPDIR)/gdl-plot3d_nr.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='plot3d_nr.cpp' object='gdl-plot3d_nr.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -c -o gdl-plot3d_nr.obj `if test -f 'plot3d_nr.cpp'; then $(CYGPATH_W) 'plot3d_nr.cpp'; else $(CYGPATH_W) '$(srcdir)/plot3d_nr.cpp'; fi`
-
 gdl-grib.o: grib.cpp
 @am__fastdepCXX_TRUE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gdl_CXXFLAGS) $(CXXFLAGS) -MT gdl-grib.o -MD -MP -MF $(DEPDIR)/gdl-grib.Tpo -c -o gdl-grib.o `test -f 'grib.cpp' || echo '$(srcdir)/'`grib.cpp
 @am__fastdepCXX_TRUE@	$(am__mv) $(DEPDIR)/gdl-grib.Tpo $(DEPDIR)/gdl-grib.Po
diff -ruN --exclude CVS gdl-0.9.2/src/math_fun.cpp gdl/src/math_fun.cpp
--- gdl-0.9.2/src/math_fun.cpp	2011-09-29 12:54:30.000000000 -0600
+++ gdl/src/math_fun.cpp	2011-11-24 04:43:23.000000000 -0700
@@ -223,16 +223,19 @@
     return res;
   }
 
-  BaseGDL* sin_fun( EnvT* e)
+  BaseGDL* sin_fun( BaseGDL* p0, bool isReference)
   {
-    e->NParam( 1);//, "SIN");
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
 
-    BaseGDL* p0 = e->GetParDefined( 0);//, "SIN");
-
-    SizeT nEl = p0->N_Elements();
-    if( nEl == 0)
-      e->Throw( 
-	       "Variable is undefined: "+e->GetParString(0));
+//     e->NParam( 1);//, "SIN");
+// 
+//     BaseGDL* p0 = e->GetParDefined( 0);//, "SIN");
+// 
+    SizeT nEl = p0->N_Elements();
+//     if( nEl == 0)
+//       e->Throw( 
+// 	       "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX)
       return sin_fun_template< DComplexGDL>( p0);
@@ -277,20 +280,23 @@
     return res;
   }
 
-  BaseGDL* cos_fun( EnvT* e)
+  BaseGDL* cos_fun( BaseGDL* p0, bool isReference)
   {
-    SizeT nParam=e->NParam();
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
 
-    if( nParam == 0)
-      e->Throw( 
-	       "Incorrect number of arguments.");
-
-    BaseGDL* p0 = e->GetParDefined( 0);//, "COS");
-
-    SizeT nEl = p0->N_Elements();
-    if( nEl == 0)
-      e->Throw( 
-	       "Variable is undefined: "+e->GetParString(0));
+//     SizeT nParam=e->NParam();
+// 
+//     if( nParam == 0)
+//       e->Throw( 
+// 	       "Incorrect number of arguments.");
+// 
+//     BaseGDL* p0 = e->GetParDefined( 0);//, "COS");
+// 
+    SizeT nEl = p0->N_Elements();
+//     if( nEl == 0)
+//       e->Throw( 
+// 	       "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX)
       return cos_fun_template< DComplexGDL>( p0);
@@ -354,20 +360,23 @@
     return res;
   }
 
-  BaseGDL* tan_fun( EnvT* e)
+  BaseGDL* tan_fun( BaseGDL* p0, bool isReference)
   {
-    SizeT nParam=e->NParam();
-
-    if( nParam == 0)
-      e->Throw( 
-	       "Incorrect number of arguments.");
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
 
-    BaseGDL* p0 = e->GetParDefined( 0);//, "TAN");
-
-    SizeT nEl = p0->N_Elements();
-    if( nEl == 0)
-      e->Throw( 
-	       "Variable is undefined: "+e->GetParString(0));
+//     SizeT nParam=e->NParam();
+// 
+//     if( nParam == 0)
+//       e->Throw( 
+// 	       "Incorrect number of arguments.");
+// 
+//     BaseGDL* p0 = e->GetParDefined( 0);//, "TAN");
+// 
+    SizeT nEl = p0->N_Elements();
+//     if( nEl == 0)
+//       e->Throw( 
+// 	       "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX)
       return tan_fun_template< DComplexGDL>( p0);
@@ -412,20 +421,23 @@
     return res;
   }
 
-  BaseGDL* sinh_fun( EnvT* e)
+  BaseGDL* sinh_fun( BaseGDL* p0, bool isReference)
   {
-    SizeT nParam=e->NParam();
-
-    if( nParam == 0)
-      e->Throw( 
-	       "Incorrect number of arguments.");
-
-    BaseGDL* p0 = e->GetParDefined( 0);//, "SINH");
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
 
-    SizeT nEl = p0->N_Elements();
-    if( nEl == 0)
-      e->Throw( 
-	       "Variable is undefined: "+e->GetParString(0));
+//     SizeT nParam=e->NParam();
+// 
+//     if( nParam == 0)
+//       e->Throw( 
+// 	       "Incorrect number of arguments.");
+// 
+//     BaseGDL* p0 = e->GetParDefined( 0);//, "SINH");
+// 
+    SizeT nEl = p0->N_Elements();
+//     if( nEl == 0)
+//       e->Throw( 
+// 	       "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX)
       return sinh_fun_template< DComplexGDL>( p0);
@@ -470,20 +482,23 @@
     return res;
   }
 
-  BaseGDL* cosh_fun( EnvT* e)
+  BaseGDL* cosh_fun( BaseGDL* p0, bool isReference)
   {
-    SizeT nParam=e->NParam();
-
-    if( nParam == 0)
-      e->Throw( 
-	       "Incorrect number of arguments.");
-
-    BaseGDL* p0 = e->GetParDefined( 0);//, "COSH");
-
-    SizeT nEl = p0->N_Elements();
-    if( nEl == 0)
-      e->Throw( 
-	       "Variable is undefined: "+e->GetParString(0));
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
+    
+//     SizeT nParam=e->NParam();
+// 
+//     if( nParam == 0)
+//       e->Throw( 
+// 	       "Incorrect number of arguments.");
+// 
+//     BaseGDL* p0 = e->GetParDefined( 0);//, "COSH");
+// 
+    SizeT nEl = p0->N_Elements();
+//     if( nEl == 0)
+//       e->Throw( 
+// 	       "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX)
       return cosh_fun_template< DComplexGDL>( p0);
@@ -528,20 +543,22 @@
     return res;
   }
 
-  BaseGDL* tanh_fun( EnvT* e)
+  BaseGDL* tanh_fun( BaseGDL* p0, bool isReference)
   {
-    SizeT nParam=e->NParam();
-
-    if( nParam == 0)
-      e->Throw( 
-	       "Incorrect number of arguments.");
-
-    BaseGDL* p0 = e->GetParDefined( 0);//, "TANH");
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
 
-    SizeT nEl = p0->N_Elements();
-    if( nEl == 0)
-      e->Throw( 
-	       "Variable is undefined: "+e->GetParString(0));
+//     SizeT nParam=e->NParam();
+// 
+//     if( nParam == 0)
+//       e->Throw( 
+// 	       "Incorrect number of arguments.");
+// 
+//     BaseGDL* p0 = e->GetParDefined( 0);//, "TANH");
+// 
+//     if( nEl == 0)
+//       e->Throw( 
+// 	       "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX)
       return tanh_fun_template< DComplexGDL>( p0);
@@ -555,6 +572,7 @@
       {
 	DFloatGDL* res = static_cast<DFloatGDL*>
 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
+	SizeT nEl = p0->N_Elements();
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
@@ -568,21 +586,22 @@
       }
   }
 
-  BaseGDL* asin_fun( EnvT* e)
+  BaseGDL* asin_fun( BaseGDL* p0, bool isReference)
   {
-    e->NParam( 1);//, "ASIN");
-
-    BaseGDL* p0 = e->GetParDefined( 0);//, "ASIN");
-
-    SizeT nEl = p0->N_Elements();
-    if( nEl == 0)
-      e->Throw( 
-	       "Variable is undefined: "+e->GetParString(0));
-    
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
+//     e->NParam( 1);//, "ASIN");
+// 
+//     BaseGDL* p0 = e->GetParDefined( 0);//, "ASIN");
+// 
+    SizeT nEl = p0->N_Elements();
+//     if( nEl == 0)
+//       e->Throw( 
+// 	       "Variable is undefined: "+e->GetParString(0));
+ 
     if( p0->Type() == COMPLEX || p0->Type() == COMPLEXDBL)
       {
-	e->Throw( 
-		 "Operation illegal with complex type.");
+	throw GDLException( "Operation illegal with complex type.");
       }
     else if( p0->Type() == DOUBLE)
       {
@@ -631,21 +650,22 @@
       }
   }
 
-  BaseGDL* acos_fun( EnvT* e)
+  BaseGDL* acos_fun( BaseGDL* p0, bool isReference)
   {
-    e->NParam( 1);//, "ACOS");
-
-    BaseGDL* p0 = e->GetParDefined( 0);//, "ACOS");
-
-    SizeT nEl = p0->N_Elements();
-    if( nEl == 0)
-      e->Throw( 
-	       "Variable is undefined: "+e->GetParString(0));
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
+//     e->NParam( 1);//, "ACOS");
+// 
+//     BaseGDL* p0 = e->GetParDefined( 0);//, "ACOS");
+// 
+    SizeT nEl = p0->N_Elements();
+//     if( nEl == 0)
+//       e->Throw( 
+// 	       "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX || p0->Type() == COMPLEXDBL)
       {
-	e->Throw( 
-		 "Operation illegal with complex type.");
+	throw GDLException( "Operation illegal with complex type.");
       }
     else if( p0->Type() == DOUBLE)
       {
@@ -980,115 +1000,66 @@
   //     return res;
   //   }
 
-  BaseGDL* alog_fun( EnvT* e)
+//   BaseGDL* alog_fun( EnvT* e)
+  BaseGDL* alog_fun( BaseGDL* p0, bool isReference)
   {
-    e->NParam( 1);//,"ALOG");
-
-    BaseGDL* p0 = e->GetParDefined( 0);//, "ALOG");
-
-    SizeT nEl = p0->N_Elements();
-    if( nEl == 0)
-      e->Throw( "Variable is undefined: "+e->GetParString(0));
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
     
-    if( FloatType( p0->Type()) || ComplexType( p0->Type()))
-      if( e->StealLocalPar( 0))
-	{
-	  p0->LogThis();
-	  return p0;
-	}
-      else
-	return p0->Log(); //alog_fun_template< DComplexGDL>( p0);
-    //     else if( p0->Type() == COMPLEXDBL)
-    //       return p0->Log(); //alog_fun_template< DComplexDblGDL>( p0);
-    //     else if( p0->Type() == DOUBLE)
-    //       return p0->Log(); //alog_fun_template< DDoubleGDL>( p0);
-    //     else if( p0->Type() == FLOAT)
-    //       return p0->Log(); //alog_fun_template< DFloatGDL>( p0);
-    else 
+    if( !isReference) //e->StealLocalPar( 0))
       {
-	DFloatGDL* res = static_cast<DFloatGDL*>
-	  (p0->Convert2( FLOAT, BaseGDL::COPY));
-	res->LogThis();
-	// 	for( SizeT i=0; i<nEl; ++i)
-	// 	  {
-	// 	    (*res)[ i] = log((*res)[ i]); 
-	// 	  }
-	return res;
+	return p0->LogThis();
       }
-  }
+    return p0->Log();
 
-  //   template< typename T>
-  //   BaseGDL* alog10_fun_template( BaseGDL* p0)
-  //   {
-  //     T* p0C = static_cast<T*>( p0);
-  //     T* res = new T( p0C->Dim(), BaseGDL::NOZERO);
-  //     SizeT nEl = p0->N_Elements();
-  //     for( SizeT i=0; i<nEl; ++i)
-  //       {
-  // 	(*res)[ i] = log10((*p0C)[ i]); 
-  //       }
-  //     return res;
-  //   }
-
-  //   BaseGDL* alog10_fun( EnvT* e)
-  //   {
-  //     e->NParam( 1);//, "ALOG10");
-
-  //     BaseGDL* p0 = e->GetParDefined( 0);//, "ALOG10");
+//       if( FloatType( p0->Type()) || ComplexType( p0->Type()))
+//       if( !isReference) //e->StealLocalPar( 0))
+// 	{
+// 	  p0->LogThis();
+// 	  return p0;
+// 	}
+//       else
+// 	return p0->Log();
+//     else 
+//       {
+// 	DFloatGDL* res = static_cast<DFloatGDL*>
+// 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
+// 	res->LogThis();
+// 	return res;
+//       }
+  }
 
-  //     SizeT nEl = p0->N_Elements();
-  //     if( nEl == 0)
-  //       e->Throw( 
-  // 			  "ALOG10: Variable is undefined: "+e->GetParString(0));
-    
-  //     if( p0->Type() == COMPLEX)
-  // 	return alog10_fun_template< DComplexGDL>( p0);
-  //     else if( p0->Type() == COMPLEXDBL)
-  // 	return alog10_fun_template< DComplexDblGDL>( p0);
-  //     else if( p0->Type() == DOUBLE)
-  // 	return alog10_fun_template< DDoubleGDL>( p0);
-  //     else if( p0->Type() == FLOAT)
-  // 	return alog10_fun_template< DFloatGDL>( p0);
-  //     else 
-  //       {
-  // 	DFloatGDL* res = static_cast<DFloatGDL*>
-  // 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
-  // 	for( SizeT i=0; i<nEl; ++i)
-  // 	  {
-  // 	    (*res)[ i] = log10((*res)[ i]); 
-  // 	  }
-  // 	return res;
-  //       }
-  //   }
 
-  BaseGDL* alog10_fun( EnvT* e)
+//   BaseGDL* alog10_fun( EnvT* e)
+BaseGDL* alog10_fun( BaseGDL* p0, bool isReference)
   {
-    e->NParam( 1);
-
-    BaseGDL* p0 = e->GetParDefined( 0);
-
-    SizeT nEl = p0->N_Elements();
-    if( nEl == 0)
-      e->Throw( "Variable is undefined: "+e->GetParString(0));
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
     
-    if( FloatType( p0->Type()) || ComplexType( p0->Type()))
-      if( e->StealLocalPar( 0))
-	{
-	  p0->Log10This();
-	  return p0;
-	}
-      else
-	return p0->Log10();
-    else 
+    if( !isReference) //e->StealLocalPar( 0))
       {
-	DFloatGDL* res = static_cast<DFloatGDL*>
-	  (p0->Convert2( FLOAT, BaseGDL::COPY));
-	res->Log10This();
-	return res;
+	return p0->Log10This();
       }
+    return p0->Log10();
+
+//     if( FloatType( p0->Type()) || ComplexType( p0->Type()))
+//       if( !isReference) //e->StealLocalPar( 0))
+// 	{
+// 	  p0->Log10This();
+// 	  return p0;
+// 	}
+//       else
+// 	return p0->Log10();
+//     else 
+//       {
+// 	DFloatGDL* res = static_cast<DFloatGDL*>
+// 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
+// 	res->Log10This();
+// 	return res;
+//       }
   }
 
-  // by joel gales
+  // original by joel gales
   template< typename T>
   BaseGDL* sqrt_fun_template( BaseGDL* p0)
   {
@@ -1098,7 +1069,7 @@
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
-#pragma omp for
+#pragma omp forthis
       for( SizeT i=0; i<nEl; ++i)
 	{
 	  (*res)[ i] = sqrt((*p0C)[ i]); 
@@ -1107,17 +1078,30 @@
     return res;
   }
 
-  BaseGDL* sqrt_fun( EnvT* e)
+  template< typename T>
+  BaseGDL* sqrt_fun_template_grab( BaseGDL* p0)
   {
-    e->NParam( 1);//, "SQRT");
-
-    BaseGDL* p0 = e->GetParDefined( 0);//, "SQRT");
-
+    T* p0C = static_cast<T*>( p0);
     SizeT nEl = p0->N_Elements();
-    if( nEl == 0)
-      e->Throw( 
-	       "SQRT: Variable is undefined: "+e->GetParString(0));
+TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+    {
+#pragma omp for
+      for( SizeT i=0; i<nEl; ++i)
+	{
+	  (*p0C)[ i] = sqrt((*p0C)[ i]); 
+	}
+    }
+    return p0C;
+  }
+
+  BaseGDL* sqrt_fun( BaseGDL* p0, bool isReference)//( EnvT* e)
+  {
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
     
+    if( isReference)
+    {
     if( p0->Type() == COMPLEX)
       return sqrt_fun_template< DComplexGDL>( p0);
     else if( p0->Type() == COMPLEXDBL)
@@ -1126,10 +1110,22 @@
       return sqrt_fun_template< DDoubleGDL>( p0);
     else if( p0->Type() == FLOAT)
       return sqrt_fun_template< DFloatGDL>( p0);
-    else 
+    }
+    else
+    {
+    if( p0->Type() == COMPLEX)
+      return sqrt_fun_template_grab< DComplexGDL>( p0);
+    else if( p0->Type() == COMPLEXDBL)
+      return sqrt_fun_template_grab< DComplexDblGDL>( p0);
+    else if( p0->Type() == DOUBLE)
+      return sqrt_fun_template_grab< DDoubleGDL>( p0);
+    else if( p0->Type() == FLOAT)
+      return sqrt_fun_template_grab< DFloatGDL>( p0);
+    } 
       {
 	DFloatGDL* res = static_cast<DFloatGDL*>
 	  (p0->Convert2( FLOAT, BaseGDL::COPY));
+	SizeT nEl = p0->N_Elements();
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
@@ -1162,15 +1158,17 @@
     return res;
   }
 
-  BaseGDL* abs_fun( EnvT* e)
+  BaseGDL* abs_fun( BaseGDL* p0, bool isReference)
   {
-    e->NParam( 1);
-
-    BaseGDL* p0 = e->GetParDefined( 0);
-
-    SizeT nEl = p0->N_Elements();
-    if( nEl == 0)
-      e->Throw( "Variable is undefined: "+e->GetParString(0));
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
+//     e->NParam( 1);
+// 
+//     BaseGDL* p0 = e->GetParDefined( 0);
+// 
+//     SizeT nEl = p0->N_Elements();
+//     if( nEl == 0)
+//       e->Throw( "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX) 
       {
@@ -1220,7 +1218,9 @@
       return abs_fun_template< DLongGDL>( p0);
     else if( p0->Type() == INT)
       return abs_fun_template< DIntGDL>( p0);
-    else if( p0->Type() == ULONG64)
+    else if( isReference)
+    {
+    if( p0->Type() == ULONG64)
       return p0->Dup();
     else if( p0->Type() == ULONG)
       return p0->Dup();
@@ -1228,21 +1228,31 @@
       return p0->Dup();
     else if( p0->Type() == BYTE)
       return p0->Dup();
-    else 
-      {
-	DFloatGDL* res = static_cast<DFloatGDL*>
-	  (p0->Convert2( FLOAT, BaseGDL::COPY));
+    }
+    else
+    {
+    if( p0->Type() == ULONG64)
+      return p0;
+    else if( p0->Type() == ULONG)
+      return p0;
+    else if( p0->Type() == UINT)
+      return p0;
+    else if( p0->Type() == BYTE)
+      return p0;     
+    }
+    DFloatGDL* res = static_cast<DFloatGDL*>
+      (p0->Convert2( FLOAT, BaseGDL::COPY));
+    SizeT nEl = p0->N_Elements();
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-	{
+    {
 #pragma omp for
-	  for( SizeT i=0; i<nEl; ++i)
-	    {
-	      (*res)[ i] = abs( (*res)[ i]); 
-	    }
+      for( SizeT i=0; i<nEl; ++i)
+	{
+	  (*res)[ i] = abs( (*res)[ i]); 
 	}
-	return res;
-      }
+    }
+    return res;
   }
 
 
@@ -1700,38 +1710,43 @@
       }
   }
 
-  BaseGDL* conj_fun( EnvT* e)
+  BaseGDL* conj_fun( BaseGDL* p0, bool isReference)//( EnvT* e)
   {
-    e->NParam( 1);
-    BaseGDL* p0 = e->GetParDefined( 0);
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
+
+//     e->NParam( 1);
+//     BaseGDL* p0 = e->GetParDefined( 0);
     SizeT nEl = p0->N_Elements();
     //    if( nEl == 0)
     //      e->Throw( "Variable is undefined: "+e->GetParString(0));
     
     if( p0->Type() == COMPLEX)
       {
-	DComplexGDL* res = static_cast<DComplexGDL*>(p0->Dup());
+	DComplexGDL* res = static_cast<DComplexGDL*>(p0)->NewResult();// static_cast<DComplexGDL*>(p0->Dup());
+	DComplexGDL* p0C = static_cast<DComplexGDL*>(p0);
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
 	  for( SizeT i=0; i<nEl; ++i)
 	    {
-	      (*res)[i] = DComplex( (*res)[i].real(), -(*res)[i].imag());
+	      (*res)[i] = DComplex( (*p0C)[i].real(), -(*p0C)[i].imag());
 	    }
 	}
 	return res;
       }
     if( p0->Type() == COMPLEXDBL)
       {
-	DComplexDblGDL* res = static_cast<DComplexDblGDL*>(p0->Dup());
+	DComplexDblGDL* res = static_cast<DComplexDblGDL*>(p0)->NewResult();//static_cast<DComplexDblGDL*>(p0->Dup());
+	DComplexDblGDL* p0C = static_cast<DComplexDblGDL*>(p0);
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
 	  for( SizeT i=0; i<nEl; ++i)
 	    {
-	      (*res)[i] = DComplexDbl( (*res)[i].real(), -(*res)[i].imag());
+	      (*res)[i] = DComplexDbl( (*p0C)[i].real(), -(*p0C)[i].imag());
 	    }
 	}
 	return res;
@@ -1751,10 +1766,13 @@
     return res;
   }
 
-  BaseGDL* imaginary_fun( EnvT* e)
+  BaseGDL* imaginary_fun( BaseGDL* p0, bool isReference)//( EnvT* e)
   {
-    e->NParam( 1);
-    BaseGDL* p0 = e->GetParDefined( 0);
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
+
+//     e->NParam( 1);
+//     BaseGDL* p0 = e->GetParDefined( 0);
     SizeT nEl = p0->N_Elements();
 
     //    if( nEl == 0) 
@@ -1791,40 +1809,33 @@
       }
 
     // forbidden types
-    if( p0->Type() == STRING)
-      e->Throw( "String expression not allowed in this context: "+
-		e->GetParString(0));
-    if( p0->Type() == STRUCT)
-      e->Throw( "Struct expression not allowed in this context: "+
-		e->GetParString(0));
-    if( p0->Type() == PTR)
-      e->Throw( "Pointer expression not allowed in this context: "+
-		e->GetParString(0));
-    if( p0->Type() == OBJECT)
-      e->Throw( "Object reference not allowed in this context: "+
-		e->GetParString(0));
+    DType t = p0->Type();
+    if( t == STRING)
+      throw GDLException( "String expression not allowed in this context.");
+    if( t == STRUCT)
+      throw GDLException( "Struct expression not allowed in this context.");
+    if( t == PTR)
+      throw GDLException( "Pointer expression not allowed in this context.");
+    if( t == OBJECT)
+      throw GDLException( "Object reference not allowed in this context.");
     
     // all other types (return array of zeros)
     DFloatGDL* res = new DFloatGDL( p0->Dim()); // ZERO
     return res;
   }
 
-  BaseGDL* exp_fun( EnvT* e)
+  BaseGDL* exp_fun( BaseGDL* p0, bool isReference)
   {
-    e->NParam( 1);
-    BaseGDL* p0 = e->GetParDefined( 0);
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
+	
+//     e->NParam( 1);
+//     BaseGDL* p0 = e->GetParDefined( 0);
 
-    SizeT nEl = p0->N_Elements();
+	SizeT nEl = p0->N_Elements();
 
     DType t = p0->Type();
-
-    if( t == PTR)
-      e->Throw( "Pointer not allowed in this context.");
-    else if( t == OBJECT)
-      e->Throw( "Object references not allowed in this context.");
-    else if( t == STRUCT)
-      e->Throw( "Struct expression not allowed in this context.");
-    else if( t == COMPLEXDBL)
+	if( t == COMPLEXDBL)
       {
 	DComplexDblGDL *c0 = static_cast< DComplexDblGDL*>( p0);
 	DComplexDblGDL *res = c0->New( c0->Dim(), BaseGDL::NOZERO);
@@ -1876,7 +1887,13 @@
 	}
 	return res;
       }
-    else
+    else if( t == PTR)
+      throw GDLException( "Pointer not allowed in this context.");
+    else if( t == OBJECT)
+      throw GDLException( "Object references not allowed in this context.");
+    else if( t == STRUCT)
+      throw GDLException( "Struct expression not allowed in this context.");
+    else 
       {
 	DFloatGDL *res = 
 	  static_cast< DFloatGDL*>( p0->Convert2( FLOAT, BaseGDL::COPY));
diff -ruN --exclude CVS gdl-0.9.2/src/math_fun.hpp gdl/src/math_fun.hpp
--- gdl-0.9.2/src/math_fun.hpp	2010-06-08 06:08:18.000000000 -0600
+++ gdl/src/math_fun.hpp	2011-11-24 04:31:27.000000000 -0700
@@ -25,32 +25,32 @@
 
   void svdc( EnvT* e);
 
-  BaseGDL* sin_fun( EnvT* e);
-  BaseGDL* cos_fun( EnvT* e);
-  BaseGDL* tan_fun( EnvT* e);
-
-  BaseGDL* sinh_fun( EnvT* e);
-  BaseGDL* cosh_fun( EnvT* e);
-  BaseGDL* tanh_fun( EnvT* e);
+  BaseGDL* sin_fun( BaseGDL* p0, bool isReference);//( EnvT* e);
+  BaseGDL* cos_fun( BaseGDL* p0, bool isReference);//( EnvT* e);
+  BaseGDL* tan_fun( BaseGDL* p0, bool isReference);//( EnvT* e);
+
+  BaseGDL* sinh_fun( BaseGDL* p0, bool isReference);//( EnvT* e);
+  BaseGDL* cosh_fun( BaseGDL* p0, bool isReference);//( EnvT* e);
+  BaseGDL* tanh_fun( BaseGDL* p0, bool isReference);//( EnvT* e);
 
-  BaseGDL* asin_fun( EnvT* e);
-  BaseGDL* acos_fun( EnvT* e);
+  BaseGDL* asin_fun( BaseGDL* p0, bool isReference);//( EnvT* e);
+  BaseGDL* acos_fun( BaseGDL* p0, bool isReference);//( EnvT* e);
   BaseGDL* atan_fun( EnvT* e);
 
-  BaseGDL* alog_fun( EnvT* e);
-  BaseGDL* alog10_fun( EnvT* e);
+  BaseGDL* alog_fun( BaseGDL* p0, bool isReference);//( EnvT* e);
+  BaseGDL* alog10_fun( BaseGDL* p0, bool isReference);//( EnvT* e);
 
-  BaseGDL* sqrt_fun( EnvT* e);
-  BaseGDL* abs_fun( EnvT* e);
+  BaseGDL* sqrt_fun( BaseGDL* p0, bool isReference);//( EnvT* e);
+  BaseGDL* abs_fun( BaseGDL* p0, bool isReference);//( EnvT* e);
 
   BaseGDL* round_fun( EnvT* e);
   BaseGDL* floor_fun( EnvT* e);
   BaseGDL* ceil_fun( EnvT* e);
 
-  BaseGDL* conj_fun( EnvT* e);
-  BaseGDL* imaginary_fun( EnvT* e);
+  BaseGDL* conj_fun( BaseGDL* p0, bool isReference);//( EnvT* e);
+  BaseGDL* imaginary_fun( BaseGDL* p0, bool isReference);//( EnvT* e);
 
-  BaseGDL* exp_fun( EnvT* e);
+  BaseGDL* exp_fun( BaseGDL* p0, bool isReference);//( EnvT* e);
 
   // by medericboquien@users.sourceforge.net
   BaseGDL* gauss_pdf(EnvT* e);
diff -ruN --exclude CVS gdl-0.9.2/src/math_fun_jmg.cpp gdl/src/math_fun_jmg.cpp
--- gdl-0.9.2/src/math_fun_jmg.cpp	2011-10-11 01:37:36.000000000 -0600
+++ gdl/src/math_fun_jmg.cpp	2012-06-28 07:59:01.000000000 -0600
@@ -220,6 +220,76 @@
        do_it(static_cast<T*>(src), kwNaN, kwInfinity);
    };
 
+   template< typename T, bool> struct finite_helper_sign
+   {
+     inline static BaseGDL* do_it(T* src, bool kwNaN, bool kwInfinity, DLong kwSign)
+     {
+
+// #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+
+       DByteGDL* res = new DByteGDL( src->Dim(), BaseGDL::NOZERO); // ::ZERO is not working
+       SizeT nEl = src->N_Elements();
+
+       //       for ( SizeT i=0; i<nEl; ++i) (*res)[i]=0;
+
+       if (kwInfinity) {
+	 if (kwSign > 0) {
+// #pragma omp for
+	   for ( SizeT i=0; i<nEl; ++i) {
+	     if (isinf((*src)[ i]) && (signbit((*src)[ i]) == 0)) (*res)[i]=1; else (*res)[i]=0;
+	   }
+	 } else {
+// #pragma omp for
+	   for ( SizeT i=0; i<nEl; ++i) {
+	     if (isinf((*src)[ i]) && (signbit((*src)[ i]) != 0)) (*res)[i]=1; else (*res)[i]=0;
+	   }
+	 }
+	 return res;	 
+       }
+       if (kwNaN) {
+	 if (kwSign > 0) {
+// #pragma omp for
+	   for ( SizeT i=0; i<nEl; ++i) {
+	     if (isnan((*src)[ i]) && (signbit((*src)[ i]) == 0)) (*res)[i]=1; else (*res)[i]=0;
+	   }
+	 } else {
+// #pragma omp for
+	   for ( SizeT i=0; i<nEl; ++i) {
+	     if (isnan((*src)[ i]) && (signbit((*src)[ i]) != 0)) (*res)[i]=1; else (*res)[i]=0;
+	   }
+	 }
+	 return res;
+       }
+     }
+   };
+
+   // partial specialization for COMPLEX, DCOMPLEX
+   template< typename T> struct finite_helper_sign<T, true>
+   {
+     inline static BaseGDL* do_it(T* src, bool kwNaN, bool kwInfinity, DLong kwSign)
+     {
+       DByteGDL* res = new DByteGDL( src->Dim(), BaseGDL::NOZERO);
+       SizeT nEl = src->N_Elements();
+       
+       for ( SizeT i=0; i<nEl; ++i)
+	 {
+	   (*res)[i]=0;
+	   if      ((kwInfinity && isinf((*src)[ i].real()) || kwNaN && isnan((*src)[ i].real())) && signbit((*src)[ i].real())==0 && kwSign > 0) (*res)[i]=1;
+	   else if ((kwInfinity && isinf((*src)[ i].imag()) || kwNaN && isnan((*src)[ i].imag())) && signbit((*src)[ i].imag())==0 && kwSign > 0) (*res)[i]=1;
+	   else if ((kwInfinity && isinf((*src)[ i].real()) || kwNaN && isnan((*src)[ i].real())) && signbit((*src)[ i].real())==1 && kwSign < 0) (*res)[i]=1;
+	   else if ((kwInfinity && isinf((*src)[ i].imag()) || kwNaN && isnan((*src)[ i].imag())) && signbit((*src)[ i].imag())==1 && kwSign < 0) (*res)[i]=1;	 
+	 }
+       return res;
+     }
+   };
+
+   template< typename T, bool IS_COMPLEX>
+   inline BaseGDL* finite_template( BaseGDL* src, bool kwNaN, bool kwInfinity, DLong kwSign)
+   {
+     return finite_helper_sign<T, IS_COMPLEX>::
+       do_it(static_cast<T*>(src), kwNaN, kwInfinity, kwSign);
+   };
+
    BaseGDL* finite_fun( EnvT* e)
    {
      e->NParam( 1);
@@ -233,52 +303,107 @@
      static int infinityIx = e->KeywordIx( "INFINITY");
      bool kwInfinity = e->KeywordSet( infinityIx);
 
+     static int signIx = e->KeywordIx( "SIGN");
+     DLong kwSign = 0;
+     e->AssureLongScalarKWIfPresent( signIx, kwSign); 
+
      if( kwNaN && kwInfinity)
        e->Throw("Conflicting keywords.");
-
-     switch (p0->Type()) 
+     
+     if(kwSign==0 || (kwInfinity==0 && kwNaN==0))
        {
-       case FLOAT: 
-	 {
-	   return finite_template<DFloatGDL, false>(p0, kwNaN, kwInfinity);
-	 }
-       case DOUBLE:
-	 {
-	   return finite_template<DDoubleGDL, false>(p0, kwNaN, kwInfinity);
-	 }
-       case COMPLEX:
-	 {
-	   return finite_template<DComplexGDL, true>(p0, kwNaN, kwInfinity);
-	 }
-       case COMPLEXDBL:
-	 {
-	   return finite_template<DComplexDblGDL, true>(p0, kwNaN, kwInfinity);
-	 }
-       case STRING:
-	 {
-	   DFloatGDL* p0F = 
-	     static_cast<DFloatGDL*>(p0->Convert2(FLOAT,BaseGDL::COPY));
-	   guard.reset( p0F);
-	   return finite_template<DFloatGDL, false>(p0F, kwNaN, kwInfinity);
-	 }
-       case STRUCT:
-       case PTR:
-       case OBJECT:
-	 {
-	   e->Throw( p0->TypeStr() + " not allowed in this context: " +
-		     e->GetParString( 0));
-	 }
-       default: // integer types
-	 {
-	   if( kwNaN || kwInfinity)
-	     return new DByteGDL( p0->Dim()); // zero
-
+	 switch (p0->Type()) 
+	   {
+	   case FLOAT: 
+	     {
+	       return finite_template<DFloatGDL, false>(p0, kwNaN, kwInfinity);
+	     }
+	   case DOUBLE:
+	     {
+	       return finite_template<DDoubleGDL, false>(p0, kwNaN, kwInfinity);
+	     }
+	   case COMPLEX:
+	     {
+	       return finite_template<DComplexGDL, true>(p0, kwNaN, kwInfinity);
+	     }
+	   case COMPLEXDBL:
+	     {
+	       return finite_template<DComplexDblGDL, true>(p0, kwNaN, kwInfinity);
+	     }
+	   case STRING:
+	     {
+	       DFloatGDL* p0F = 
+		 static_cast<DFloatGDL*>(p0->Convert2(FLOAT,BaseGDL::COPY));
+	       guard.reset( p0F);
+	       return finite_template<DFloatGDL, false>(p0F, kwNaN, kwInfinity);
+	     }
+	   case STRUCT:
+	   case PTR:
+	   case OBJECT:
+	     {
+	       e->Throw( p0->TypeStr() + " not allowed in this context: " +
+			 e->GetParString( 0));
+	     }
+	   default: // integer types
+	     {
+	       if( kwNaN || kwInfinity)
+		 return new DByteGDL( p0->Dim()); // zero
+	       
 	   DByteGDL* res = new DByteGDL( p0->Dim(), BaseGDL::NOZERO); 
 	   SizeT nEl = p0->N_Elements();
 	   for (SizeT i=0; i<nEl; i++)
 	     (*res)[i] = 1;
 	   return res;
-	 }
+	     }
+	   }
+       }
+     // Sign
+     else
+       {
+	 switch (p0->Type()) 
+	   {
+	   case FLOAT: 
+	     {
+	       return finite_template<DFloatGDL, false>(p0, kwNaN, kwInfinity, kwSign);
+	     }
+	   case DOUBLE:
+	     {
+	       return finite_template<DDoubleGDL, false>(p0, kwNaN, kwInfinity, kwSign);
+	     }
+	   case COMPLEX:
+	     {
+	       return finite_template<DComplexGDL, true>(p0, kwNaN, kwInfinity, kwSign);
+	     }
+	   case COMPLEXDBL:
+	     {
+	       return finite_template<DComplexDblGDL, true>(p0, kwNaN, kwInfinity, kwSign);
+	     }
+	   case STRING:
+	     {
+	       DFloatGDL* p0F = 
+		 static_cast<DFloatGDL*>(p0->Convert2(FLOAT,BaseGDL::COPY));
+	       guard.reset( p0F);
+	       return finite_template<DFloatGDL, false>(p0F, kwNaN, kwInfinity, kwSign);
+	     }
+	   case STRUCT:
+	   case PTR:
+	   case OBJECT:
+	     {
+	       e->Throw( p0->TypeStr() + " not allowed in this context: " +
+			 e->GetParString( 0));
+	     }
+	   default: // integer types
+	     {
+	       if( kwNaN || kwInfinity)
+		 return new DByteGDL( p0->Dim()); // zero
+	       
+	       DByteGDL* res = new DByteGDL( p0->Dim(), BaseGDL::NOZERO);
+	       SizeT nEl = p0->N_Elements();
+	       for (SizeT i=0; i<nEl; i++)
+	       (*res)[i] = 0;
+	       return res;
+	     }
+	   }
        }
    }
 
@@ -967,19 +1092,25 @@
 
   template< typename T1, typename T2>
   BaseGDL* poly_2d_shift_template( BaseGDL* p0, DLong nCol, DLong nRow, 
-				   int shift_y, int shift_x)
+				   int shift_y, int shift_x, DDouble missing)
   {
     dimension dim(nCol,nRow);  
 //     dim.Set(0, nCol);
 //     dim.Set(1, nRow);
+//    cout<<"shifting"<<endl;
     T1* res = new T1( dim, BaseGDL::NOZERO);
-
+    T2 missed=missing;
+    
     int lx = (int) p0->Dim(0);
     int ly = (int) p0->Dim(1);
     int lx_out = (int) nCol;
     int ly_out = (int) nRow;
 
     char *p_out = (char *) res->DataAddr();
+    T2 *resAddr = (T2 *) res->DataAddr();
+    for ( SizeT i=0; i<nCol*nRow; i++) {
+      resAddr[i] = missed;
+    }
     char *p_in  = (char *) p0->DataAddr();
 
     SizeT sz = sizeof(T2);
@@ -1095,39 +1226,39 @@
 	  if (p0->Type() == BYTE) {
 	    return poly_2d_shift_template< DByteGDL, DByte>( p0, nCol, nRow,  
 							     (int) (*Q)[0], 
-							     (int) (*P)[0]);
+							     (int) (*P)[0],missing);
 	  } else if (p0->Type() == INT) {
 	    return poly_2d_shift_template< DIntGDL, DInt>( p0, nCol, nRow,  
 							    (int) (*Q)[0], 
-							    (int) (*P)[0]);
+							    (int) (*P)[0],missing);
 	  } else if (p0->Type() == UINT) {
 	    return poly_2d_shift_template< DUIntGDL, DUInt>( p0, nCol, nRow,  
 							     (int) (*Q)[0], 
-							     (int) (*P)[0]);
+							     (int) (*P)[0],missing);
 	  } else if (p0->Type() == LONG) {
 	    return poly_2d_shift_template< DLongGDL, DLong>( p0, nCol, nRow,  
 							     (int) (*Q)[0], 
-							     (int) (*P)[0]);
+							     (int) (*P)[0],missing);
 	  } else if (p0->Type() == ULONG) {
 	    return poly_2d_shift_template< DULongGDL, DULong>( p0, nCol, nRow,  
 							       (int) (*Q)[0], 
-							       (int) (*P)[0]);
+							       (int) (*P)[0],missing);
 	  } else if (p0->Type() == LONG64) {
 	    return poly_2d_shift_template< DLong64GDL, DLong64>( p0, nCol, nRow,  
 								 (int) (*Q)[0], 
-								 (int) (*P)[0]);
+								 (int) (*P)[0],missing);
 	  } else if (p0->Type() == ULONG64) {
 	    return poly_2d_shift_template< DULong64GDL, DULong64>( p0, nCol, nRow,  
 								   (int) (*Q)[0], 
-								   (int) (*P)[0]);
+								   (int) (*P)[0],missing);
 	  } else if (p0->Type() == FLOAT) {
 	    return poly_2d_shift_template< DFloatGDL, DFloat>( p0, nCol, nRow,  
 							       (int) (*Q)[0], 
-							       (int) (*P)[0]);
+							       (int) (*P)[0],missing);
 	  } else if (p0->Type() == DOUBLE) {
 	    return poly_2d_shift_template< DDoubleGDL, DDouble>( p0, nCol, nRow,  
 								 (int) (*Q)[0], 
-								 (int) (*P)[0]);
+								 (int) (*P)[0],missing);
 	  }
 	}
       } else {
@@ -1141,7 +1272,7 @@
 	warped = image_warp(p0->Dim(1), p0->Dim(0), nRow, nCol, p0->Type(), 
 			    p0->DataAddr(), kernel_name,
 			    lineartrans, poly_v, poly_u,
-			    interp, cubic, LINEAR);
+			    interp, cubic, LINEAR, missing);
       }
     } else {
       // Polynomial
@@ -1172,7 +1303,7 @@
       warped = image_warp(p0->Dim(1), p0->Dim(0), nRow, nCol, p0->Type(), 
 			  p0->DataAddr(), kernel_name, 
 			  lineartrans, poly_v, poly_u, 
-			  interp, cubic, GENERIC);
+			  interp, cubic, GENERIC, missing);
 
       if (poly_u->px != NULL) free(poly_u->px);
       if (poly_u->py != NULL) free(poly_u->py);
@@ -1427,7 +1558,7 @@
  */
 /*--------------------------------------------------------------------------*/
 
-image_t * image_warp(
+image_t * image_warp (
 		     SizeT  lx,		     
 		     SizeT  ly,		     
 		     SizeT  lx_out,		     
@@ -1440,7 +1571,8 @@
 		     poly2d		*	poly_v,
 		     DLong interp,
 		     DDouble cubic,
-		     DLong warpType)
+		     DLong warpType,
+                     DDouble initvalue)
 {
     image_t    *	image_out ;
     int         	i, j, k ;
@@ -1484,7 +1616,7 @@
       }
     }
 
-    image_out = image_new(lx_out, ly_out) ;
+    image_out = image_new(lx_out, ly_out, initvalue) ;
 
     /* Pre compute leaps for 16 closest neighbors positions */
 
@@ -1531,7 +1663,10 @@
 	      (px > (lx-1)) ||
 	      (py < 1) ||
 	      (py > (ly-1)))
-	    image_out->data[i+j*lx_out] = (pixelvalue)0.0 ;
+          {
+          //already initialised to 'missing' value. No need to put zero here.
+          //	    image_out->data[i+j*lx_out] = (pixelvalue)0.0 ;
+          }
 	  else {
 	    /* Now feed the positions for the closest 16 neighbors  */
 	    pos = px + py * lx ;
@@ -1700,7 +1835,8 @@
 /*--------------------------------------------------------------------------*/
 image_t * image_new(
 		int 	size_x, 
-		int 	size_y)
+		int 	size_y,
+                DDouble  initvalue)
 {
     image_t    *	image_new ;
 
@@ -1717,6 +1853,9 @@
     image_new->lx = size_x ;
     image_new->ly = size_y ;
     image_new->data = (pixelvalue *) calloc(size_x * size_y, sizeof(pixelvalue));
+ 
+    for (SizeT i=0; i < size_x * size_y; i++) (image_new->data)[i]=initvalue;
+    
     return image_new ;
 }
 
@@ -1921,7 +2060,8 @@
     // Execute command string
     EnvBaseT* caller;
     caller = e->Caller();
-    e->Interpreter()->CallStack().pop_back();
+// ms: commented out to comply with new stack handling
+//     e->Interpreter()->CallStack().pop_back();
 
     executeString( caller, &istr);
 
diff -ruN --exclude CVS gdl-0.9.2/src/math_fun_jmg.hpp gdl/src/math_fun_jmg.hpp
--- gdl-0.9.2/src/math_fun_jmg.hpp	2010-06-11 09:09:51.000000000 -0600
+++ gdl/src/math_fun_jmg.hpp	2011-12-29 19:25:12.000000000 -0700
@@ -68,9 +68,9 @@
   image_t * image_warp(SizeT, SizeT, SizeT, SizeT, DType, void*, 
 		       char *kernel_type,
 		       DDouble *param, poly2d *poly_u, poly2d *poly_v, 
-		       DLong interp, DDouble cubic, DLong warpType);
+		       DLong interp, DDouble cubic, DLong warpType, DDouble initvalue);
 
-  image_t * image_new(int size_x, int size_y);
+  image_t * image_new(int size_x, int size_y, DDouble initvalue);
   void image_del(image_t *d);
 
 } // namespace
diff -ruN --exclude CVS gdl-0.9.2/src/newprognode.cpp gdl/src/newprognode.cpp
--- gdl-0.9.2/src/newprognode.cpp	2011-11-07 16:38:21.000000000 -0700
+++ gdl/src/newprognode.cpp	2011-11-15 16:19:00.000000000 -0700
@@ -103,13 +103,19 @@
   if( refNode == RefDNode(antlr::nullAST)) return NULL;
 
   bool nonCopy = false;
+  bool nonCopy12 = false;
   if( refNode->GetFirstChild() != RefDNode(antlr::nullAST))
     {
       if( NonCopyNode( refNode->GetFirstChild()->getType()))
 	nonCopy = true;
       if( refNode->GetFirstChild()->GetNextSibling() != RefDNode(antlr::nullAST))
 		if( NonCopyNode( refNode->GetFirstChild()->GetNextSibling()->getType()))
-			nonCopy = true;
+		{
+		  if( nonCopy)
+		    nonCopy12 = true;
+		  else  
+		    nonCopy = true;
+		}
     }
   
   // note: constant expressions are always nonCopy
@@ -154,106 +160,169 @@
 	  // binary
 	case GDLTokenTypes::AND_OP:
 	  {
-	    newNode = new AND_OPNCNode( refNode);
+	    if( nonCopy12)
+	      newNode = new AND_OPNCNode( refNode);
+	    else
+	      newNode = new AND_OPNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::OR_OP:
 	  {
+	    if( nonCopy12)
+	    newNode = new OR_OPNCNode( refNode);
+	    else
 	    newNode = new OR_OPNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::XOR_OP:
 	  {
+	    if( nonCopy12)
+	    newNode = new XOR_OPNCNode( refNode);
+	    else
 	    newNode = new XOR_OPNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::LOG_AND:
 	  {
+	    if( nonCopy12)
+	    newNode = new LOG_ANDNCNode( refNode);
+	    else
 	    newNode = new LOG_ANDNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::LOG_OR:
 	  {
+	    if( nonCopy12)
+	    newNode = new LOG_ORNCNode( refNode);
+	    else
 	    newNode = new LOG_ORNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::EQ_OP:
 	  {
+	    if( nonCopy12)
+	    newNode = new EQ_OPNCNode( refNode);
+	    else
 	    newNode = new EQ_OPNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::NE_OP:
 	  {
+	    if( nonCopy12)
+	    newNode = new NE_OPNCNode( refNode);
+	    else
 	    newNode = new NE_OPNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::LE_OP:
 	  {
+	    if( nonCopy12)
+	    newNode = new LE_OPNCNode( refNode);
+	    else
 	    newNode = new LE_OPNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::LT_OP:
 	  {
+	    if( nonCopy12)
+	    newNode = new LT_OPNCNode( refNode);
+	    else
 	    newNode = new LT_OPNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::GE_OP:
 	  {
+	    if( nonCopy12)
+	    newNode = new GE_OPNCNode( refNode);
+	    else
 	    newNode = new GE_OPNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::GT_OP:
 	  {
+	    if( nonCopy12)
+	    newNode = new GT_OPNCNode( refNode);
+	    else
 	    newNode = new GT_OPNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::PLUS:
 	  {
+	    if( nonCopy12)
+	    newNode = new PLUSNC12Node( refNode);
+	    else
 	    newNode = new PLUSNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::MINUS:
 	  {
+	    if( nonCopy12)
+	    newNode = new MINUSNC12Node( refNode);
+	    else
 	    newNode = new MINUSNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::LTMARK:
 	  {
+	    if( nonCopy12)
+	    newNode = new LTMARKNCNode( refNode);
+	    else
 	    newNode = new LTMARKNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::GTMARK:
 	  {
+	    if( nonCopy12)
+	    newNode = new GTMARKNCNode( refNode);
+	    else
 	    newNode = new GTMARKNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::ASTERIX:
 	  {
+	    if( nonCopy12)
+	    newNode = new ASTERIXNC12Node( refNode);
+	    else
 	    newNode = new ASTERIXNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::MATRIX_OP1:
 	  {
+	    if( nonCopy12)
+	    newNode = new MATRIX_OP1NCNode( refNode);
+	    else
 	    newNode = new MATRIX_OP1NCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::MATRIX_OP2:
 	  {
+	    if( nonCopy12)
+	    newNode = new MATRIX_OP2NCNode( refNode);
+	    else
 	    newNode = new MATRIX_OP2NCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::SLASH:
 	  {
+	    if( nonCopy12)
+	    newNode = new SLASHNC12Node( refNode);
+	    else
 	    newNode = new SLASHNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::MOD_OP:
 	  {
+	    if( nonCopy12)
+	    newNode = new MOD_OPNCNode( refNode);
+	    else
 	    newNode = new MOD_OPNCNode( refNode);
 	    break;
 	  }
 	case GDLTokenTypes::POW:
 	  {
+	    if( nonCopy12)
+	    newNode = new POWNCNode( refNode);
+	    else
 	    newNode = new POWNCNode( refNode);
 	    break;
 	  }
@@ -497,15 +566,49 @@
 
 	if( !static_cast<DLibFunRetNew*>(c->libFun)->RetConstant()
 	    || !ConstantPar( c->getFirstChild())) return c;
-	
+
 	auto_ptr< ProgNode> guard( c);
-	
+
 	BaseGDL* cData = c->Eval();
-	
+
 	ProgNodeP cN = new CONSTANTNode( c->StealNextSibling(), cData);
 	cN->lineNumber = refNode->getLine();
 	cN->setText( "C()");
-	
+
+	return cN;
+      }
+    case GDLTokenTypes::FCALL_LIB_DIRECT:
+      {
+	ProgNodeP c = new FCALL_LIB_DIRECTNode( refNode);
+
+	if( !static_cast<DLibFunDirect*>(c->libFun)->RetConstant()
+	    || !ConstantPar( c->getFirstChild())) return c;
+
+	auto_ptr< ProgNode> guard( c);
+
+	BaseGDL* cData = c->Eval();
+
+	ProgNodeP cN = new CONSTANTNode( c->StealNextSibling(), cData);
+	cN->lineNumber = refNode->getLine();
+	cN->setText( "C()");
+
+	return cN;
+      }
+    case GDLTokenTypes::FCALL_LIB_N_ELEMENTS:
+      {
+	ProgNodeP c = new FCALL_LIB_N_ELEMENTSNode( refNode);
+
+	if( !static_cast<DLibFunRetNew*>(c->libFun)->RetConstant()
+	    || !ConstantPar( c->getFirstChild())) return c;
+
+	auto_ptr< ProgNode> guard( c);
+
+	BaseGDL* cData = c->Eval();
+
+	ProgNodeP cN = new CONSTANTNode( c->StealNextSibling(), cData);
+	cN->lineNumber = refNode->getLine();
+	cN->setText( "C()");
+
 	return cN;
       }
 
diff -ruN --exclude CVS gdl-0.9.2/src/objects.cpp gdl/src/objects.cpp
--- gdl-0.9.2/src/objects.cpp	2010-12-30 17:37:52.000000000 -0700
+++ gdl/src/objects.cpp	2011-11-18 11:42:17.000000000 -0700
@@ -17,6 +17,7 @@
 
 #include "includefirst.hpp"
 
+#include <limits>
 #include <ios>
 
 #include "str.hpp"
@@ -65,6 +66,7 @@
 DLong CpuTPOOL_NTHREADS;
 DLong CpuTPOOL_MIN_ELTS;
 DLong CpuTPOOL_MAX_ELTS;
+const DLong CpuTPOOL_MAX_ELTS_max = numeric_limits<DLong>::max();
 
 // instantiate own AST factory
 //_DNodeFactory DNodeFactory;
diff -ruN --exclude CVS gdl-0.9.2/src/plot3d_nr.cpp gdl/src/plot3d_nr.cpp
--- gdl-0.9.2/src/plot3d_nr.cpp	2010-11-17 00:24:55.000000000 -0700
+++ gdl/src/plot3d_nr.cpp	1969-12-31 17:00:00.000000000 -0700
@@ -1,1367 +0,0 @@
-/* $Id: plot3d_nr.cpp,v 1.7 2010/11/17 07:24:55 slayoo Exp $
-
-	3d plot routines.
-
-   Copyright (C) 2004  Alan W. Irwin
-   Copyright (C) 2004  Joao Cardoso
-   Copyright (C) 2004  Andrew Ross
-
-   This file is part of PLplot.
-
-   PLplot is free software; you can redistribute it and/or modify
-   it under the terms of the GNU Library General Public License as published
-   by the Free Software Foundation; either version 2 of the License, or
-   (at your option) any later version.
-
-   PLplot is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU Library General Public License for more details.
-
-   You should have received a copy of the GNU Library General Public License
-   along with PLplot; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#include <plplot/plplotP.h>
-
-namespace lib {
-
-  /* Internal constants */
-
-#define  BINC      50		/* Block size for memory allocation */
-
-  static PLINT pl3mode = 0;	/* 0 3d solid; 1 mesh plot */
-  static PLINT pl3upv = 1;	/* 1 update view; 0 no update */
-  
-  static PLINT zbflg = 0, zbcol, zbwidth;
-  static PLFLT zbtck;
-
-  static PLINT *oldhiview = NULL;
-  static PLINT *oldloview = NULL;
-  static PLINT *newhiview = NULL;
-  static PLINT *newloview = NULL;
-  static PLINT *utmp = NULL;
-  static PLINT *vtmp = NULL;
-  static PLFLT *ctmp = NULL;
-
-  static PLINT mhi, xxhi, newhisize;
-  static PLINT mlo, xxlo, newlosize;
-
-  /* Light source for shading */
-  static PLFLT xlight, ylight, zlight;
-  static PLINT falsecolor=0;
-  static PLFLT fc_minz, fc_maxz;
-
-  /* Prototypes for static functions */
-
-  static void plgrid3	(PLFLT);
-  static void plnxtv (PLINT *, PLINT *, PLFLT*, PLINT, PLINT);
-  static void plside3	(PLFLT *, PLFLT *, PLFLT **, PLINT, PLINT, PLINT);
-  static void plt3zz	(PLINT, PLINT, PLINT, PLINT,
-			 PLINT, PLINT *, PLFLT *, PLFLT *, PLFLT **,
-			 PLINT, PLINT, PLINT *, PLINT *, PLFLT*);
-  static void plnxtvhi (PLINT *, PLINT *, PLFLT*, PLINT, PLINT);
-  static void plnxtvlo (PLINT *, PLINT *, PLFLT*, PLINT, PLINT);
-  static void plnxtvhi_draw(PLINT *u, PLINT *v, PLFLT* c, PLINT n);
-
-  static void savehipoint	(PLINT, PLINT);
-  static void savelopoint	(PLINT, PLINT);
-  static void swaphiview	(void);
-  static void swaploview	(void);
-  static void myexit	(char *);
-  static void myabort	(char *);
-  static void freework	(void);
-  static int  plabv	(PLINT, PLINT, PLINT, PLINT, PLINT, PLINT);
-  static void pl3cut	(PLINT, PLINT, PLINT, PLINT, PLINT,
-			 PLINT, PLINT, PLINT, PLINT *, PLINT *);
-  static void plP_draw3d(PLINT x, PLINT y, PLFLT *c, PLINT j, PLINT move);
-
-  static void plt3zz_nr (PLINT, PLINT, PLINT, PLINT,
-			 PLINT, PLINT *, PLFLT *, PLFLT *, PLFLT **,
-			 PLINT, PLINT, PLINT *, PLINT *, PLFLT*);
-
-  void mesh_nr(PLFLT *, PLFLT *, PLFLT **, PLINT, PLINT, PLINT);
-
-  void c_plot3dc_nr(PLFLT *, PLFLT *, PLFLT **,
-		    PLINT, PLINT, PLINT,
-		    PLFLT *, PLINT);
-
-  void c_plot3dcl_nr(PLFLT *, PLFLT *, PLFLT **,
-		     PLINT, PLINT, PLINT, 
-		     PLFLT *, PLINT,
-		     PLINT, PLINT, PLINT *, PLINT *);
-
-/*--------------------------------------------------------------------------*\
- * void plside3()
- *
- * This routine draws sides around the front of the 3d plot so that
- * it does not appear to float.
-\*--------------------------------------------------------------------------*/
-
-static void
-plside3(PLFLT *x, PLFLT *y, PLFLT **z, PLINT nx, PLINT ny, PLINT opt)
-{
-    PLINT i;
-    PLFLT cxx, cxy, cyx, cyy, cyz;
-    PLFLT xmin, ymin, zmin, xmax, ymax, zmax, zscale;
-    PLFLT tx, ty, ux, uy;
-
-    plP_gw3wc(&cxx, &cxy, &cyx, &cyy, &cyz);
-    plP_gdom(&xmin, &xmax, &ymin, &ymax);
-    plP_grange(&zscale, &zmin, &zmax);
-
-/* Get x, y coordinates of legs and plot */
-
-    if (cxx >= 0.0 && cxy <= 0.0) {
-	if (opt != 1) {
-	    for (i = 0; i < nx; i++) {
-		tx = plP_w3wcx(x[i], y[0], zmin);
-		ty = plP_w3wcy(x[i], y[0], zmin);
-		ux = plP_w3wcx(x[i], y[0], z[i][0]);
-		uy = plP_w3wcy(x[i], y[0], z[i][0]);
-		pljoin(tx, ty, ux, uy);
-	    }
-	}
-	if (opt != 2) {
-	    for (i = 0; i < ny; i++) {
-		tx = plP_w3wcx(x[0], y[i], zmin);
-		ty = plP_w3wcy(x[0], y[i], zmin);
-		ux = plP_w3wcx(x[0], y[i], z[0][i]);
-		uy = plP_w3wcy(x[0], y[i], z[0][i]);
-		pljoin(tx, ty, ux, uy);
-	    }
-	}
-    }
-    else if (cxx <= 0.0 && cxy <= 0.0) {
-	if (opt != 1) {
-	    for (i = 0; i < nx; i++) {
-		tx = plP_w3wcx(x[i], y[ny - 1], zmin);
-		ty = plP_w3wcy(x[i], y[ny - 1], zmin);
-		ux = plP_w3wcx(x[i], y[ny - 1], z[i][ny - 1]);
-		uy = plP_w3wcy(x[i], y[ny - 1], z[i][ny - 1]);
-		pljoin(tx, ty, ux, uy);
-	    }
-	}
-	if (opt != 2) {
-	    for (i = 0; i < ny; i++) {
-		tx = plP_w3wcx(x[0], y[i], zmin);
-		ty = plP_w3wcy(x[0], y[i], zmin);
-		ux = plP_w3wcx(x[0], y[i], z[0][i]);
-		uy = plP_w3wcy(x[0], y[i], z[0][i]);
-		pljoin(tx, ty, ux, uy);
-	    }
-	}
-    }
-    else if (cxx <= 0.0 && cxy >= 0.0) {
-	if (opt != 1) {
-	    for (i = 0; i < nx; i++) {
-		tx = plP_w3wcx(x[i], y[ny - 1], zmin);
-		ty = plP_w3wcy(x[i], y[ny - 1], zmin);
-		ux = plP_w3wcx(x[i], y[ny - 1], z[i][ny - 1]);
-		uy = plP_w3wcy(x[i], y[ny - 1], z[i][ny - 1]);
-		pljoin(tx, ty, ux, uy);
-	    }
-	}
-	if (opt != 2) {
-	    for (i = 0; i < ny; i++) {
-		tx = plP_w3wcx(x[nx - 1], y[i], zmin);
-		ty = plP_w3wcy(x[nx - 1], y[i], zmin);
-		ux = plP_w3wcx(x[nx - 1], y[i], z[nx - 1][i]);
-		uy = plP_w3wcy(x[nx - 1], y[i], z[nx - 1][i]);
-		pljoin(tx, ty, ux, uy);
-	    }
-	}
-    }
-    else if (cxx >= 0.0 && cxy >= 0.0) {
-	if (opt != 1) {
-	    for (i = 0; i < nx; i++) {
-		tx = plP_w3wcx(x[i], y[0], zmin);
-		ty = plP_w3wcy(x[i], y[0], zmin);
-		ux = plP_w3wcx(x[i], y[0], z[i][0]);
-		uy = plP_w3wcy(x[i], y[0], z[i][0]);
-		pljoin(tx, ty, ux, uy);
-	    }
-	}
-	if (opt != 2) {
-	    for (i = 0; i < ny; i++) {
-		tx = plP_w3wcx(x[nx - 1], y[i], zmin);
-		ty = plP_w3wcy(x[nx - 1], y[i], zmin);
-		ux = plP_w3wcx(x[nx - 1], y[i], z[nx - 1][i]);
-		uy = plP_w3wcy(x[nx - 1], y[i], z[nx - 1][i]);
-		pljoin(tx, ty, ux, uy);
-	    }
-	}
-    }
-}
-
-/*--------------------------------------------------------------------------*\
- * void plgrid3()
- *
- * This routine draws a grid around the back side of the 3d plot with
- * hidden line removal.
-\*--------------------------------------------------------------------------*/
-
-static void
-plgrid3(PLFLT tick)
-{
-    PLFLT xmin, ymin, zmin, xmax, ymax, zmax, zscale;
-    PLFLT cxx, cxy, cyx, cyy, cyz, zmin_in, zmax_in;
-    PLINT u[3], v[3];
-    PLINT nsub = 0;
-    PLFLT tp;
-
-    plP_gw3wc(&cxx, &cxy, &cyx, &cyy, &cyz);
-    plP_gdom(&xmin, &xmax, &ymin, &ymax);
-    plP_grange(&zscale, &zmin_in, &zmax_in);
-    zmin = (zmax_in > zmin_in) ? zmin_in: zmax_in;
-    zmax = (zmax_in > zmin_in) ? zmax_in: zmin_in;
-
-#ifdef HAVE_OLDPLPLOT
-    pldtik(zmin, zmax, &tick, &nsub);
-#else
-    pldtik(zmin, zmax, &tick, &nsub, FALSE);
-#endif
-    tp = tick * floor(zmin / tick) + tick;
-    pl3upv = 0;
-
-    if (cxx >= 0.0 && cxy <= 0.0) {
-	while (tp <= zmax) {
-	    u[0] = plP_wcpcx(plP_w3wcx(xmin, ymax, tp));
-	    v[0] = plP_wcpcy(plP_w3wcy(xmin, ymax, tp));
-	    u[1] = plP_wcpcx(plP_w3wcx(xmax, ymax, tp));
-	    v[1] = plP_wcpcy(plP_w3wcy(xmax, ymax, tp));
-	    u[2] = plP_wcpcx(plP_w3wcx(xmax, ymin, tp));
-	    v[2] = plP_wcpcy(plP_w3wcy(xmax, ymin, tp));
-	    plnxtv(u, v, 0, 3, 0);
-
-	    tp += tick;
-	}
-	u[0] = plP_wcpcx(plP_w3wcx(xmax, ymax, zmin));
-	v[0] = plP_wcpcy(plP_w3wcy(xmax, ymax, zmin));
-	u[1] = plP_wcpcx(plP_w3wcx(xmax, ymax, zmax));
-	v[1] = plP_wcpcy(plP_w3wcy(xmax, ymax, zmax));
-	plnxtv(u, v, 0, 2, 0);
-    }
-    else if (cxx <= 0.0 && cxy <= 0.0) {
-	while (tp <= zmax) {
-	    u[0] = plP_wcpcx(plP_w3wcx(xmax, ymax, tp));
-	    v[0] = plP_wcpcy(plP_w3wcy(xmax, ymax, tp));
-	    u[1] = plP_wcpcx(plP_w3wcx(xmax, ymin, tp));
-	    v[1] = plP_wcpcy(plP_w3wcy(xmax, ymin, tp));
-	    u[2] = plP_wcpcx(plP_w3wcx(xmin, ymin, tp));
-	    v[2] = plP_wcpcy(plP_w3wcy(xmin, ymin, tp));
-	    plnxtv(u, v, 0,3, 0);
-
-	    tp += tick;
-	}
-	u[0] = plP_wcpcx(plP_w3wcx(xmax, ymin, zmin));
-	v[0] = plP_wcpcy(plP_w3wcy(xmax, ymin, zmin));
-	u[1] = plP_wcpcx(plP_w3wcx(xmax, ymin, zmax));
-	v[1] = plP_wcpcy(plP_w3wcy(xmax, ymin, zmax));
-	plnxtv(u, v, 0,2, 0);
-    }
-    else if (cxx <= 0.0 && cxy >= 0.0) {
-	while (tp <= zmax) {
-	    u[0] = plP_wcpcx(plP_w3wcx(xmax, ymin, tp));
-	    v[0] = plP_wcpcy(plP_w3wcy(xmax, ymin, tp));
-	    u[1] = plP_wcpcx(plP_w3wcx(xmin, ymin, tp));
-	    v[1] = plP_wcpcy(plP_w3wcy(xmin, ymin, tp));
-	    u[2] = plP_wcpcx(plP_w3wcx(xmin, ymax, tp));
-	    v[2] = plP_wcpcy(plP_w3wcy(xmin, ymax, tp));
-	    plnxtv(u, v, 0,3, 0);
-
-	    tp += tick;
-	}
-	u[0] = plP_wcpcx(plP_w3wcx(xmin, ymin, zmin));
-	v[0] = plP_wcpcy(plP_w3wcy(xmin, ymin, zmin));
-	u[1] = plP_wcpcx(plP_w3wcx(xmin, ymin, zmax));
-	v[1] = plP_wcpcy(plP_w3wcy(xmin, ymin, zmax));
-	plnxtv(u, v, 0,2, 0);
-    }
-    else if (cxx >= 0.0 && cxy >= 0.0) {
-	while (tp <= zmax) {
-	    u[0] = plP_wcpcx(plP_w3wcx(xmin, ymin, tp));
-	    v[0] = plP_wcpcy(plP_w3wcy(xmin, ymin, tp));
-	    u[1] = plP_wcpcx(plP_w3wcx(xmin, ymax, tp));
-	    v[1] = plP_wcpcy(plP_w3wcy(xmin, ymax, tp));
-	    u[2] = plP_wcpcx(plP_w3wcx(xmax, ymax, tp));
-	    v[2] = plP_wcpcy(plP_w3wcy(xmax, ymax, tp));
-	    plnxtv(u, v, 0,3, 0);
-
-	    tp += tick;
-	}
-	u[0] = plP_wcpcx(plP_w3wcx(xmin, ymax, zmin));
-	v[0] = plP_wcpcy(plP_w3wcy(xmin, ymax, zmin));
-	u[1] = plP_wcpcx(plP_w3wcx(xmin, ymax, zmax));
-	v[1] = plP_wcpcy(plP_w3wcy(xmin, ymax, zmax));
-	plnxtv(u, v, 0,2, 0);
-    }
-    pl3upv = 1;
-}
-
-/*--------------------------------------------------------------------------*\
- * void plnxtv()
- *
- * Draw the next view of a 3-d plot. The physical coordinates of the
- * points for the next view are placed in the n points of arrays u and
- * v. The silhouette found so far is stored in the heap as a set of m peak
- * points.
- *
- * These routines dynamically allocate memory for hidden line removal.
- * Memory is allocated in blocks of 2*BINC*sizeof(PLINT) bytes.  Large
- * values of BINC give better performance but also allocate more memory
- * than is needed. If your 3D plots are very "spiky" or you are working
- * with very large matrices then you will probably want to increase BINC.
-\*--------------------------------------------------------------------------*/
-
-static void
-plnxtv(PLINT *u, PLINT *v, PLFLT* c, PLINT n, PLINT init)
-{
-    plnxtvhi(u, v, c, n, init);
-
-    if (pl3mode)
-	plnxtvlo(u, v, c, n, init);
-}
-
-/*--------------------------------------------------------------------------*\
- * void plnxtvhi()
- *
- * Draw the top side of the 3-d plot.
-\*--------------------------------------------------------------------------*/
-
-static void
-plnxtvhi(PLINT *u, PLINT *v, PLFLT* c, PLINT n, PLINT init)
-{
-  /*
-   * For the initial set of points, just display them and store them as the
-   * peak points.
-   */
-  if (init == 1) {
-    int i;
-    oldhiview = (PLINT *) malloc((size_t) (2 * n * sizeof(PLINT)));
-    if ( ! oldhiview)
-      myexit((char*)"plnxtvhi: Out of memory.");
-
-    oldhiview[0] = u[0];
-    oldhiview[1] = v[0];
-    plP_draw3d(u[0], v[0], c, 0, 1);
-    for (i = 1; i < n; i++) {
-      oldhiview[2 * i] = u[i];
-      oldhiview[2 * i + 1] = v[i];
-      plP_draw3d(u[i], v[i], c, i, 0);
-    }
-    mhi = n;
-    return;
-  }
-
-  /*
-   * Otherwise, we need to consider hidden-line removal problem. We scan
-   * over the points in both the old (i.e. oldhiview[]) and new (i.e. u[]
-   * and v[]) arrays in order of increasing x coordinate.  At each stage, we
-   * find the line segment in the other array (if one exists) that straddles
-   * the x coordinate of the point. We have to determine if the point lies
-   * above or below the line segment, and to check if the below/above status
-   * has changed since the last point.
-   *
-   * If pl3upv = 0 we do not update the view, this is useful for drawing
-   * lines on the graph after we are done plotting points.  Hidden line
-   * removal is still done, but the view is not updated.
-   */
-  xxhi = 0;
-  if (pl3upv != 0) {
-    newhisize = 2 * (mhi + BINC);
-    if (newhiview != NULL) {
-      newhiview =
-	(PLINT *) realloc((void *) newhiview,
-			  (size_t) (newhisize * sizeof(PLINT)));
-    }
-    else {
-      newhiview =
-	(PLINT *) malloc((size_t) (newhisize * sizeof(PLINT)));
-    }
-    if ( ! newhiview)
-      myexit((char*)"plnxtvhi: Out of memory.");
-  }
-
-  /* Do the draw or shading with hidden line removal */
-
-  plnxtvhi_draw(u, v, c, n);
-
-  /* Set oldhiview */
-
-  swaphiview();
-}
-
-/*--------------------------------------------------------------------------*\
- * void plnxtvhi_draw()
- *
- * Draw the top side of the 3-d plot.
-\*--------------------------------------------------------------------------*/
-
-static void
-plnxtvhi_draw(PLINT *u, PLINT *v, PLFLT* c, PLINT n)
-{
-    PLINT i = 0, j = 0, first = 1;
-    PLINT sx1 = 0, sx2 = 0, sy1 = 0, sy2 = 0;
-    PLINT su1, su2, sv1, sv2;
-    PLINT cx, cy, px, py;
-    PLINT seg, ptold, lstold = 0, pthi, pnewhi = 0, newhi, change, ochange = 0;
-
-/*
- * (oldhiview[2*i], oldhiview[2*i]) is the i'th point in the old array
- * (u[j], v[j]) is the j'th point in the new array
- */
-
-/*
- * First attempt at 3d shading.  It works ok for simple plots, but
- * will just not draw faces, or draw them overlapping for very
- * jagged plots
- */
-
-    while (i < mhi || j < n) {
-
-    /*
-     * The coordinates of the point under consideration are (px,py).  The
-     * line segment joins (sx1,sy1) to (sx2,sy2).  "ptold" is true if the
-     * point lies in the old array. We set it by comparing the x coordinates
-     * of the i'th old point and the j'th new point, being careful if we
-     * have fallen past the edges. Having found the point, load up the point
-     * and segment coordinates appropriately.
-     */
-
-    ptold = (j >= n || (i < mhi && oldhiview[2 * i] < u[j]));
-    if (ptold) {
-      px = oldhiview[2 * i];
-      py = oldhiview[2 * i + 1];
-      seg = j > 0 && j < n;
-      if (seg) {
-	sx1 = u[j - 1];
-	sy1 = v[j - 1];
-	sx2 = u[j];
-	sy2 = v[j];
-      }
-    } else {
-      px = u[j];
-      py = v[j];
-      seg = i > 0 && i < mhi;
-      if (seg) {
-	sx1 = oldhiview[2 * (i - 1)];
-	sy1 = oldhiview[2 * (i - 1) + 1];
-	sx2 = oldhiview[2 * i];
-	sy2 = oldhiview[2 * i + 1];
-      }
-    }
-
-    /*
-     * Now determine if the point is higher than the segment, using the
-     * logical function "above". We also need to know if it is the old view
-     * or the new view that is higher. "newhi" is set true if the new view
-     * is higher than the old.
-     */
-    if (seg)
-      pthi = plabv(px, py, sx1, sy1, sx2, sy2);
-    else
-      pthi = 1;
-
-    newhi = (ptold && !pthi) || (!ptold && pthi);
-    /*
-     * The last point and this point lie on different sides of
-     * the current silouette
-     */
-    change = (newhi && !pnewhi) || (!newhi && pnewhi);
-
-    /*
-     * There is a new intersection point to put in the peak array if the
-     * state of "newhi" changes.
-     */
-    if (first) {
-      plP_draw3d(px, py, c, j, 1);
-      first = 0;
-      lstold = ptold;
-      savehipoint(px, py);
-      pthi = 0;
-      ochange = 0;
-    } else if (change) {
-
-      /*
-       * Take care of special cases at end of arrays.  If pl3upv is 0 the
-       * endpoints are not connected to the old view.
-       */
-      if (pl3upv == 0 && ((!ptold && j == 0) || (ptold && i == 0))) {
-	plP_draw3d(px, py, c, j, 1);
-	lstold = ptold;
-	pthi = 0;
-	ochange = 0;
-      } else if (pl3upv == 0 &&
-		 (( ! ptold && i >= mhi) || (ptold && j >= n))) {
-	plP_draw3d(px, py, c, j, 1);
-	lstold = ptold;
-	pthi = 0;
-	ochange = 0;
-      } else {
-
-	/*
-	 * If pl3upv is not 0 then we do want to connect the current line
-	 * with the previous view at the endpoints.  Also find intersection
-	 * point with old view.
-	 */
-	if (i == 0) {
-	  sx1 = oldhiview[0];
-	  sy1 = -1;
-	  sx2 = oldhiview[0];
-	  sy2 = oldhiview[1];
-	} else if (i >= mhi) {
-	  sx1 = oldhiview[2 * (mhi - 1)];
-	  sy1 = oldhiview[2 * (mhi - 1) + 1];
-	  sx2 = oldhiview[2 * (mhi - 1)];
-	  sy2 = -1;
-	} else {
-	  sx1 = oldhiview[2 * (i - 1)];
-	  sy1 = oldhiview[2 * (i - 1) + 1];
-	  sx2 = oldhiview[2 * i];
-	  sy2 = oldhiview[2 * i + 1];
-	}
-
-	if (j == 0) {
-	  su1 = u[0];
-	  sv1 = -1;
-	  su2 = u[0];
-	  sv2 = v[0];
-	} else if (j >= n) {
-	  su1 = u[n - 1];
-	  sv1 = v[n - 1];
-	  su2 = u[n - 1];
-	  sv2 = -1;
-	} else {
-	  su1 = u[j - 1];
-	  sv1 = v[j - 1];
-	  su2 = u[j];
-	  sv2 = v[j];
-	}
-
-	/* Determine the intersection */
-
-	pl3cut(sx1, sy1, sx2, sy2, su1, sv1, su2, sv2, &cx, &cy);
-	if (cx == px && cy == py) {
-	  if (lstold && !ochange)
-	    plP_draw3d(px, py, c, j, 1);
-	  else
-	    plP_draw3d(px, py, c, j, 0);
-
-	  savehipoint(px, py);
-	  lstold = 1;
-	  pthi = 0;
-	} else {
-	  if (lstold && !ochange)
-	    plP_draw3d(cx, cy, c, j, 1);
-	  else
-	    plP_draw3d(cx, cy, c, j, 0);
-
-	  lstold = 1;
-	  savehipoint(cx, cy);
-	}
-	ochange = 1;
-      }
-    }
-
-    /* If point is high then draw plot to point and update view. */
-
-    if (pthi) {
-      if (lstold && ptold)
-	plP_draw3d(px, py, c, j, 1);
-      else
-	plP_draw3d(px, py, c, j, 0);
-
-      savehipoint(px, py);
-      lstold = ptold;
-      ochange = 0;
-    }
-    pnewhi = newhi;
-
-    if (ptold)
-      i++;
-    else
-      j++;
-  }
-}
-
-/*--------------------------------------------------------------------------*\
- * void  plP_draw3d()
- *
- * Does a simple move or line draw.
-\*--------------------------------------------------------------------------*/
-
-static void
-plP_draw3d(PLINT x, PLINT y, PLFLT *c, PLINT j, PLINT move)
-{
-    if (move)
-      plP_movphy(x, y);
-    else {
-      if (c != NULL)
-	plcol1(c[j-1]);
-      plP_draphy(x, y);
-    }
-}
-
-/*--------------------------------------------------------------------------*\
- * void plnxtvlo()
- *
- * Draw the bottom side of the 3-d plot.
-\*--------------------------------------------------------------------------*/
-
-static void
-plnxtvlo(PLINT *u, PLINT *v, PLFLT*c, PLINT n, PLINT init)
-{
-  PLINT i, j, first;
-  PLINT sx1 = 0, sx2 = 0, sy1 = 0, sy2 = 0;
-  PLINT su1, su2, sv1, sv2;
-  PLINT cx, cy, px, py;
-  PLINT seg, ptold, lstold = 0, ptlo, pnewlo, newlo, change, ochange = 0;
-
-  first = 1;
-  pnewlo = 0;
-
-  /*
-   * For the initial set of points, just display them and store them as the
-   * peak points.
-   */
-  if (init == 1) {
-
-    oldloview = (PLINT *) malloc((size_t) (2 * n * sizeof(PLINT)));
-    if ( ! oldloview)
-      myexit((char*)"\nplnxtvlo: Out of memory.");
-
-    plP_draw3d(u[0], v[0], c, 0, 1);
-    oldloview[0] = u[0];
-    oldloview[1] = v[0];
-    for (i = 1; i < n; i++) {
-      plP_draw3d(u[i], v[i], c, i, 0);
-      oldloview[2 * i] = u[i];
-      oldloview[2 * i + 1] = v[i];
-    }
-    mlo = n;
-    return;
-  }
-
-  /*
-   * Otherwise, we need to consider hidden-line removal problem. We scan
-   * over the points in both the old (i.e. oldloview[]) and new (i.e. u[]
-   * and v[]) arrays in order of increasing x coordinate.  At each stage, we
-   * find the line segment in the other array (if one exists) that straddles
-   * the x coordinate of the point. We have to determine if the point lies
-   * above or below the line segment, and to check if the below/above status
-   * has changed since the last point.
-   *
-   * If pl3upv = 0 we do not update the view, this is useful for drawing
-   * lines on the graph after we are done plotting points.  Hidden line
-   * removal is still done, but the view is not updated.
-   */
-  xxlo = 0;
-  i = 0;
-  j = 0;
-  if (pl3upv != 0) {
-    newlosize = 2 * (mlo + BINC);
-    if (newloview != NULL) {
-      newloview =
-	(PLINT *) realloc((void *) newloview,
-			  (size_t) (newlosize * sizeof(PLINT)));
-    }
-    else {
-      newloview =
-	(PLINT *) malloc((size_t) (newlosize * sizeof(PLINT)));
-    }
-    if ( ! newloview)
-      myexit((char*)"plnxtvlo: Out of memory.");
-  }
-
-  /*
-   * (oldloview[2*i], oldloview[2*i]) is the i'th point in the old array
-   * (u[j], v[j]) is the j'th point in the new array.
-   */
-  while (i < mlo || j < n) {
-
-    /*
-     * The coordinates of the point under consideration are (px,py).  The
-     * line segment joins (sx1,sy1) to (sx2,sy2).  "ptold" is true if the
-     * point lies in the old array. We set it by comparing the x coordinates
-     * of the i'th old point and the j'th new point, being careful if we
-     * have fallen past the edges. Having found the point, load up the point
-     * and segment coordinates appropriately.
-     */
-    ptold = (j >= n || (i < mlo && oldloview[2 * i] < u[j]));
-    if (ptold) {
-      px = oldloview[2 * i];
-      py = oldloview[2 * i + 1];
-      seg = j > 0 && j < n;
-      if (seg) {
-	sx1 = u[j - 1];
-	sy1 = v[j - 1];
-	sx2 = u[j];
-	sy2 = v[j];
-      }
-    }
-    else {
-      px = u[j];
-      py = v[j];
-      seg = i > 0 && i < mlo;
-      if (seg) {
-	sx1 = oldloview[2 * (i - 1)];
-	sy1 = oldloview[2 * (i - 1) + 1];
-	sx2 = oldloview[2 * i];
-	sy2 = oldloview[2 * i + 1];
-      }
-    }
-
-    /*
-     * Now determine if the point is lower than the segment, using the
-     * logical function "above". We also need to know if it is the old view
-     * or the new view that is lower. "newlo" is set true if the new view is
-     * lower than the old.
-     */
-    if (seg)
-      ptlo = !plabv(px, py, sx1, sy1, sx2, sy2);
-    else
-      ptlo = 1;
-
-    newlo = (ptold && !ptlo) || (!ptold && ptlo);
-    change = (newlo && !pnewlo) || (!newlo && pnewlo);
-
-    /*
-     * There is a new intersection point to put in the peak array if the
-     * state of "newlo" changes.
-     */
-    if (first) {
-      plP_draw3d(px, py, c, j, 1);
-      first = 0;
-      lstold = ptold;
-      savelopoint(px, py);
-      ptlo = 0;
-      ochange = 0;
-    }
-    else if (change) {
-
-      /*
-       * Take care of special cases at end of arrays.  If pl3upv is 0 the
-       * endpoints are not connected to the old view.
-       */
-      if (pl3upv == 0 && ((!ptold && j == 0) || (ptold && i == 0))) {
-	plP_draw3d(px, py, c, j, 1);
-	lstold = ptold;
-	ptlo = 0;
-	ochange = 0;
-      }
-      else if (pl3upv == 0 &&
-	       (( ! ptold && i >= mlo) || (ptold && j >= n))) {
-	plP_draw3d(px, py, c, j, 1);
-	lstold = ptold;
-	ptlo = 0;
-	ochange = 0;
-      }
-
-      /*
-       * If pl3upv is not 0 then we do want to connect the current line
-       * with the previous view at the endpoints.  Also find intersection
-       * point with old view.
-       */
-      else {
-	if (i == 0) {
-	  sx1 = oldloview[0];
-	  sy1 = 100000;
-	  sx2 = oldloview[0];
-	  sy2 = oldloview[1];
-	}
-	else if (i >= mlo) {
-	  sx1 = oldloview[2 * (mlo - 1)];
-	  sy1 = oldloview[2 * (mlo - 1) + 1];
-	  sx2 = oldloview[2 * (mlo - 1)];
-	  sy2 = 100000;
-	}
-	else {
-	  sx1 = oldloview[2 * (i - 1)];
-	  sy1 = oldloview[2 * (i - 1) + 1];
-	  sx2 = oldloview[2 * i];
-	  sy2 = oldloview[2 * i + 1];
-	}
-
-	if (j == 0) {
-	  su1 = u[0];
-	  sv1 = 100000;
-	  su2 = u[0];
-	  sv2 = v[0];
-	}
-	else if (j >= n) {
-	  su1 = u[n - 1];
-	  sv1 = v[n - 1];
-	  su2 = u[n];
-	  sv2 = 100000;
-	}
-	else {
-	  su1 = u[j - 1];
-	  sv1 = v[j - 1];
-	  su2 = u[j];
-	  sv2 = v[j];
-	}
-
-	/* Determine the intersection */
-
-	pl3cut(sx1, sy1, sx2, sy2, su1, sv1, su2, sv2, &cx, &cy);
-	if (cx == px && cy == py) {
-	  if (lstold && !ochange)
-	    plP_draw3d(px, py, c, j, 1);
-	  else
-	    plP_draw3d(px, py, c, j, 0);
-
-	  savelopoint(px, py);
-	  lstold = 1;
-	  ptlo = 0;
-	}
-	else {
-	  if (lstold && !ochange)
-	    plP_draw3d(cx, cy, c, j, 1);
-	  else
-	    plP_draw3d(cx, cy, c, j, 0);
-
-	  lstold = 1;
-	  savelopoint(cx, cy);
-	}
-	ochange = 1;
-      }
-    }
-
-    /* If point is low then draw plot to point and update view. */
-
-    if (ptlo) {
-      if (lstold && ptold)
-	plP_draw3d(px, py, c, j, 1);
-      else
-	plP_draw3d(px, py, c, j, 0);
-
-      savelopoint(px, py);
-      lstold = ptold;
-      ochange = 0;
-    }
-
-    pnewlo = newlo;
-
-    if (ptold)
-      i = i + 1;
-    else
-      j = j + 1;
-  }
-
-  /* Set oldloview */
-
-  swaploview();
-}
-
-/*--------------------------------------------------------------------------*\
- * savehipoint
- * savelopoint
- *
- * Add a point to the list of currently visible peaks/valleys, when
- * drawing the top/bottom surface, respectively.
-\*--------------------------------------------------------------------------*/
-
-static void
-savehipoint(PLINT px, PLINT py)
-{
-    if (pl3upv == 0)
-	return;
-
-    if (xxhi >= newhisize) {	/* allocate additional space */
-	newhisize += 2 * BINC;
-	newhiview = (PLINT *) realloc((void *) newhiview,
-				      (size_t) (newhisize * sizeof(PLINT)));
-	if ( ! newhiview)
-	    myexit((char*)"savehipoint: Out of memory.");
-    }
-
-    newhiview[xxhi] = px;
-    xxhi++;
-    newhiview[xxhi] = py;
-    xxhi++;
-}
-
-static void
-savelopoint(PLINT px, PLINT py)
-{
-    if (pl3upv == 0)
-	return;
-
-    if (xxlo >= newlosize) {	/* allocate additional space */
-	newlosize += 2 * BINC;
-	newloview = (PLINT *) realloc((void *) newloview,
-				      (size_t) (newlosize * sizeof(PLINT)));
-	if ( ! newloview)
-	    myexit((char*)"savelopoint: Out of memory.");
-    }
-
-    newloview[xxlo] = px;
-    xxlo++;
-    newloview[xxlo] = py;
-    xxlo++;
-}
-
-/*--------------------------------------------------------------------------*\
- * swaphiview
- * swaploview
- *
- * Swaps the top/bottom views.  Need to do a real swap so that the
- * memory cleanup routine really frees everything (and only once).
-\*--------------------------------------------------------------------------*/
-
-static void
-swaphiview(void)
-{
-    PLINT *tmp;
-
-    if (pl3upv != 0) {
-	mhi = xxhi / 2;
-	tmp = oldhiview;
-	oldhiview = newhiview;
-	newhiview = tmp;
-    }
-}
-
-static void
-swaploview(void)
-{
-    PLINT *tmp;
-
-    if (pl3upv != 0) {
-	mlo = xxlo / 2;
-	tmp = oldloview;
-	oldloview = newloview;
-	newloview = tmp;
-    }
-}
-
-/*--------------------------------------------------------------------------*\
- * freework
- *
- * Frees memory associated with work arrays
-\*--------------------------------------------------------------------------*/
-
-static void
-freework(void)
-{
-    free_mem(oldhiview);
-    free_mem(oldloview);
-    free_mem(newhiview);
-    free_mem(newloview);
-    free_mem(vtmp);
-    free_mem(utmp);
-    free_mem(ctmp);
-}
-
-/*--------------------------------------------------------------------------*\
- * myexit
- *
- * Calls plexit, cleaning up first.
-\*--------------------------------------------------------------------------*/
-
-static void
-myexit(char *msg)
-{
-    freework();
-    plexit(msg);
-}
-
-/*--------------------------------------------------------------------------*\
- * myabort
- *
- * Calls plabort, cleaning up first.
- * Caller should return to the user program.
-\*--------------------------------------------------------------------------*/
-
-static void
-myabort(char *msg)
-{
-    freework();
-    plabort(msg);
-}
-
-/*--------------------------------------------------------------------------*\
- * int plabv()
- *
- * Determines if point (px,py) lies above the line joining (sx1,sy1) to
- * (sx2,sy2). It only works correctly if sx1 <= px <= sx2.
-\*--------------------------------------------------------------------------*/
-
-static int
-plabv(PLINT px, PLINT py, PLINT sx1, PLINT sy1, PLINT sx2, PLINT sy2)
-{
-    int above;
-
-    if (py >= sy1 && py >= sy2)
-	above = 1;
-    else if (py < sy1 && py < sy2)
-	above = 0;
-    else if ((double) (sx2 - sx1) * (py - sy1) >=
-	     (double) (px - sx1) * (sy2 - sy1))
-	above = 1;
-    else
-	above = 0;
-
-    return above;
-}
-
-/*--------------------------------------------------------------------------*\
- * void pl3cut()
- *
- * Determines the point of intersection (cx,cy) between the line joining
- * (sx1,sy1) to (sx2,sy2) and the line joining (su1,sv1) to (su2,sv2).
-\*--------------------------------------------------------------------------*/
-
-static void
-pl3cut(PLINT sx1, PLINT sy1, PLINT sx2, PLINT sy2,
-       PLINT su1, PLINT sv1, PLINT su2, PLINT sv2, PLINT *cx, PLINT *cy)
-{
-    PLINT x21, y21, u21, v21, yv1, xu1, a, b;
-    double fa, fb;
-
-    x21 = sx2 - sx1;
-    y21 = sy2 - sy1;
-    u21 = su2 - su1;
-    v21 = sv2 - sv1;
-    yv1 = sy1 - sv1;
-    xu1 = sx1 - su1;
-
-    a = x21 * v21 - y21 * u21;
-    fa = (double) a;
-    if (a == 0) {
-	if (sx2 < su2) {
-	    *cx = sx2;
-	    *cy = sy2;
-	}
-	else {
-	    *cx = su2;
-	    *cy = sv2;
-	}
-	return;
-    }
-    else {
-	b = yv1 * u21 - xu1 * v21;
-	fb = (double) b;
-	*cx = (PLINT) (sx1 + (fb * x21) / fa + .5);
-	*cy = (PLINT) (sy1 + (fb * y21) / fa + .5);
-    }
-}
-
-
-void
-mesh_nr(PLFLT *x, PLFLT *y, PLFLT **z, PLINT nx, PLINT ny, PLINT opt)
-{
-  c_plot3dc_nr(x, y, z, nx, ny, opt | MESH, NULL, 0);
-}
-
-
-/*--------------------------------------------------------------------------*\
- * void plot3dc_nr(x, y, z, nx, ny, opt, clevel, nlevel)
- *
- * Plots a 3-d representation of the function z[x][y]. The x values
- * are stored as x[0..nx-1], the y values as y[0..ny-1], and the z
- * values are in the 2-d array z[][]. The integer "opt" specifies:
- * see plot3dcl() below
-\*--------------------------------------------------------------------------*/
-
-void
-c_plot3dc_nr(PLFLT *x, PLFLT *y, PLFLT **z,
-	     PLINT nx, PLINT ny, PLINT opt,
-	     PLFLT *clevel, PLINT nlevel)
-{
-  c_plot3dcl_nr( x, y, z, nx, ny, opt, clevel, nlevel, 0, 0, NULL, NULL);
-}
-
-
-/*--------------------------------------------------------------------------*\
- * void plot3dcl_nr(x, y, z, nx, ny, opt, clevel, nlevel,
- *       ixstart, ixn, indexymin, indexymax)
- *
- * Plots a 3-d representation of the function z[x][y]. The x values
- * are stored as x[0..nx-1], the y values as y[0..ny-1], and the z
- * values are in the 2-d array z[][]. The integer "opt" specifies:
- *
- *  DRAW_LINEX :  Draw lines parallel to x-axis
- *  DRAW_LINEY :  Draw lines parallel to y-axis
- *  DRAW_LINEXY:  Draw lines parallel to both axes
- *  MAG_COLOR:    Magnitude coloring of wire frame
- *  BASE_CONT:    Draw contour at bottom xy plane
- *  TOP_CONT:     Draw contour at top xy plane (not yet)
- *  DRAW_SIDES:   Draw sides around the plot
- *  MESH:       Draw the "under" side of the plot
- *
- * or any bitwise combination, e.g. "MAG_COLOR | DRAW_LINEX"
- * indexymin and indexymax are arrays which specify the y index limits
- * (following the convention that the upper range limit is one more than
- * actual index limit) for an x index range of ixstart, ixn.
-\*--------------------------------------------------------------------------*/
-
-void
-c_plot3dcl_nr(PLFLT *x, PLFLT *y, PLFLT **z,
-	      PLINT nx, PLINT ny, PLINT opt,
-	      PLFLT *clevel, PLINT nlevel,
-	      PLINT ixstart, PLINT ixn, PLINT *indexymin, PLINT *indexymax)
-{
-    PLFLT cxx, cxy, cyx, cyy, cyz;
-    PLINT init, i, ix, iy, color, width;
-    PLFLT xmin, xmax, ymin, ymax, zmin, zmax, zscale;
-    PLINT clipped = 0, base_cont = 0, side = 0;
-
-    pl3mode = 0;
-
-    if (plsc->level < 3) {
-	myabort((char*)"plot3dcl: Please set up window first");
-	return;
-    }
-
-    if (opt < 1) {
-	myabort((char*)"plot3dcl: Bad option");
-	return;
-    }
-
-    if (nx <= 0 || ny <= 0) {
-	myabort((char*)"plot3dcl: Bad array dimensions.");
-	return;
-    }
-
-    plP_gdom(&xmin, &xmax, &ymin, &ymax);
-    plP_grange(&zscale, &zmin, &zmax);
-    if(zmin > zmax) {
-      PLFLT t = zmin;
-      zmin = zmax;
-      zmax = t;
-    }
-
-    if (opt & MESH)
-      pl3mode = 1;
-
-    if (opt & DRAW_SIDES)
-      side = 1;
-
-    if ((opt & BASE_CONT) || (opt & TOP_CONT) || (opt && MAG_COLOR)) {
-     /*
-      * Don't use the data z value to scale the color, use the z axis
-      * values set by plw3d()
-      *
-      * plMinMax2dGrid(z, nx, ny, &fc_maxz, &fc_minz);
-      */
-
-     fc_minz = plsc->ranmi;
-     fc_maxz = plsc->ranma;
-
-     if (fc_maxz == fc_minz) {
-       plwarn("plot3dcl: Maximum and minimum Z values are equal! \"fixing\"...");
-       fc_maxz = fc_minz + 1e-6;
-     }
-    }
-
-    if (opt & BASE_CONT) {     /* If enabled, draw the contour at the base.  */
-      if (clevel != NULL && nlevel != 0) {
-	base_cont = 1;
-	/* even if MESH is not set, "set it",
-	   as the base contour can only be done in this case */
-	pl3mode = 1;
-      }
-    }
-
-    if (opt & MAG_COLOR) {     /* If enabled, use magnitude colored wireframe  */
-      //      ctmp = (PLFLT *) malloc((size_t) (2 * MAX(nx, ny) * sizeof(PLFLT)));
-    } else
-      ctmp = NULL;
-    
-    /* next logic only knows opt = 1 | 2 | 3, make sure that it only gets that */
-    opt &= DRAW_LINEXY;
-
-    /* Allocate work arrays */
-
-    utmp = (PLINT *) malloc((size_t) (2 * MAX(nx, ny) * sizeof(PLINT)));
-    vtmp = (PLINT *) malloc((size_t) (2 * MAX(nx, ny) * sizeof(PLINT)));
-
-    if ( ! utmp || ! vtmp)
-	myexit((char*)"plot3dcl: Out of memory.");
-
-    plP_gw3wc(&cxx, &cxy, &cyx, &cyy, &cyz);
-    init = 1;
-    /* Call 3d line plotter.  Each viewing quadrant
-       (perpendicular to x-y plane) must be handled separately. */
-
-    if (cxx >= 0.0 && cxy <= 0.0) {
-      if (opt == DRAW_LINEY)
-	plt3zz_nr(1, ny, 1, -1, -opt, &init, x, y, z, nx, ny, utmp, vtmp,ctmp);
-      else {
-	    for (iy = 2; iy <= ny; iy++)
-		plt3zz_nr(1, iy, 1, -1, -opt, &init, x, y, z, nx, ny, utmp, vtmp,ctmp);
-	}
-	if (opt == DRAW_LINEX)
-	    plt3zz_nr(1, ny, 1, -1, opt, &init, x, y, z, nx, ny, utmp, vtmp, ctmp);
-	else {
-	    for (ix = 1; ix <= nx - 1; ix++)
-		plt3zz_nr(ix, ny, 1, -1, opt, &init, x, y, z, nx, ny, utmp, vtmp, ctmp);
-	}
-    }
-
-    else if (cxx <= 0.0 && cxy <= 0.0) {
-        if (opt == DRAW_LINEX)
-	    plt3zz_nr(nx, ny, -1, -1, opt, &init, x, y, z, nx, ny, utmp, vtmp, ctmp);
-	else {
-	    for (ix = 2; ix <= nx; ix++)
-		plt3zz_nr(ix, ny, -1, -1, opt, &init, x, y, z, nx, ny, utmp, vtmp, ctmp);
-	}
-	if (opt == DRAW_LINEY)
-	    plt3zz_nr(nx, ny, -1, -1, -opt, &init, x, y, z, nx, ny, utmp, vtmp, ctmp);
-	else {
-	    for (iy = ny; iy >= 2; iy--)
-	      plt3zz_nr(nx, iy, -1, -1, -opt, &init, x, y, z, nx, ny, utmp, vtmp, ctmp);
-	}
-    }
-
-    else if (cxx <= 0.0 && cxy >= 0.0) {
-	if (opt == DRAW_LINEY)
-	    plt3zz_nr(nx, 1, -1, 1, -opt, &init, x, y, z, nx, ny, utmp, vtmp, ctmp);
-	else {
-	    for (iy = ny - 1; iy >= 1; iy--)
-		plt3zz_nr(nx, iy, -1, 1, -opt, &init, x, y, z, nx, ny, utmp, vtmp, ctmp);
-	}
-	if (opt == DRAW_LINEX)
-	    plt3zz_nr(nx, 1, -1, 1, opt, &init, x, y, z, nx, ny, utmp, vtmp, ctmp);
-	else {
-	    for (ix = nx; ix >= 2; ix--)
-		plt3zz_nr(ix, 1, -1, 1, opt, &init, x, y, z, nx, ny, utmp, vtmp, ctmp);
-	}
-    }
-
-    else if (cxx >= 0.0 && cxy >= 0.0) {
-	if (opt == DRAW_LINEX)
-	    plt3zz_nr(1, 1, 1, 1, opt, &init, x, y, z, nx, ny, utmp, vtmp, ctmp);
-	else {
-	    for (ix = nx - 1; ix >= 1; ix--)
-		plt3zz_nr(ix, 1, 1, 1, opt, &init, x, y, z, nx, ny, utmp, vtmp, ctmp);
-	}
-	if (opt == DRAW_LINEY)
-	    plt3zz_nr(1, 1, 1, 1, -opt, &init, x, y, z, nx, ny, utmp, vtmp, ctmp);
-	else {
-	    for (iy = 1; iy <= ny - 1; iy++)
-		plt3zz_nr(1, iy, 1, 1, -opt, &init, x, y, z, nx, ny, utmp, vtmp, ctmp);
-	}
-    }
-
-    /* Finish up by drawing sides, background grid (both are optional) */
-
-    if (side)
-	plside3(x, y, z, nx, ny, opt);
-
-    if (zbflg) {
-	color = plsc->icol0;
-        width = plsc->width;
-	plwid(zbwidth);
-	plcol0(zbcol);
-	plgrid3(zbtck);
-	plwid(width);
-	plcol0(color);
-    }
-
-    freework();
-}
-
-
-/*--------------------------------------------------------------------------*\
- * void plt3zz_nr()
- *
- * Draws the next zig-zag line for a 3-d plot.  The data is stored in array
- * z[][] as a function of x[] and y[], and is plotted out starting at index
- * (x0,y0).
- *
- * Depending on the state of "flag", the sequence of data points sent to
- * plnxtv is altered so as to allow cross-hatch plotting, or plotting
- * parallel to either the x-axis or the y-axis.
-\*--------------------------------------------------------------------------*/
-
-static void
-plt3zz_nr(PLINT x0, PLINT y0, PLINT dx, PLINT dy, PLINT flag, PLINT *init,
-       PLFLT *x, PLFLT *y, PLFLT **z, PLINT nx, PLINT ny,
-       PLINT *u, PLINT *v, PLFLT* c)
-{
-    PLINT n = 0;
-    PLFLT x2d, y2d;
-
-    while (1 <= x0 && x0 <= nx && 1 <= y0 && y0 <= ny) {
-
-      if (ny == 1) {
-	x2d = plP_w3wcx(x[x0 - 1], y[x0 - 1], z[x0 - 1][y0 - 1]);
-	y2d = plP_w3wcy(x[x0 - 1], y[x0 - 1], z[x0 - 1][y0 - 1]);
-      }
-
-      if (nx == 1) {
-	x2d = plP_w3wcx(x[y0 - 1], y[y0 - 1], z[x0 - 1][y0 - 1]);
-	y2d = plP_w3wcy(x[y0 - 1], y[y0 - 1], z[x0 - 1][y0 - 1]);
-      }
-
-	u[n] = plP_wcpcx(x2d);
-	v[n] = plP_wcpcy(y2d);
-	if (c != NULL)
-	  c[n] = (z[x0 - 1][y0 - 1] - fc_minz)/(fc_maxz-fc_minz);
-
-	switch (flag) {
-	case -3:
-	    y0 += dy;
-	    flag = -flag;
-	    break;
-	case -2:
-	    y0 += dy;
-	    break;
-	case -1:
-	    y0 += dy;
-	    flag = -flag;
-	    break;
-	case 1:
-	    x0 += dx;
-	    break;
-	case 2:
-	    x0 += dx;
-	    flag = -flag;
-	    break;
-	case 3:
-	    x0 += dx;
-	    flag = -flag;
-	    break;
-	}
-	n++;
-    }
-
-    if (flag == 1 || flag == -2) {
-	if (flag == 1) {
-	    x0 -= dx;
-	    y0 += dy;
-	}
-	else if (flag == -2) {
-	    y0 -= dy;
-	    x0 += dx;
-	}
-	if (1 <= x0 && x0 <= nx && 1 <= y0 && y0 <= ny) {
-	  if (ny == 1) {
-	    x2d = plP_w3wcx(x[x0 - 1], y[x0 - 1], z[x0 - 1][y0 - 1]);
-	    y2d = plP_w3wcy(x[x0 - 1], y[x0 - 1], z[x0 - 1][y0 - 1]);
-	  }
-
-	  if (nx == 1) {
-	    x2d = plP_w3wcx(x[y0 - 1], y[y0 - 1], z[x0 - 1][y0 - 1]);
-	    y2d = plP_w3wcy(x[y0 - 1], y[y0 - 1], z[x0 - 1][y0 - 1]);
-	  }
-
-	    u[n] = plP_wcpcx(x2d);
-	    v[n] = plP_wcpcy(y2d);
-	    if (c != NULL)
-	      c[n] = (z[x0 - 1][y0 - 1] - fc_minz)/(fc_maxz-fc_minz);
-	    n++;
-	}
-    }
-
-/* All the setup is done.  Time to do the work. */
-
-    plnxtv(u, v, c, n, *init);
-    *init = 0;
-}
-}
-
diff -ruN --exclude CVS gdl-0.9.2/src/plotting_axis.cpp gdl/src/plotting_axis.cpp
--- gdl-0.9.2/src/plotting_axis.cpp	2011-07-08 06:37:54.000000000 -0600
+++ gdl/src/plotting_axis.cpp	2012-01-26 17:02:50.000000000 -0700
@@ -279,7 +279,7 @@
       if (e->KeywordSet("SAVE"))
       {
         // X.CRANGE
-        set_axis_crange("X", xStart, xEnd);
+        set_axis_crange("X", xStart, xEnd, xLog);
 
         // X.TYPE
         set_axis_type("X",xLog);
@@ -319,7 +319,7 @@
       if (e->KeywordSet("SAVE"))
       {
         // Y.CRANGE
-        set_axis_crange("Y", yStart, yEnd);
+        set_axis_crange("Y", yStart, yEnd, yLog);
 
         // Y.TYPE
         set_axis_type("Y",yLog);
diff -ruN --exclude CVS gdl-0.9.2/src/plotting_contour.cpp gdl/src/plotting_contour.cpp
--- gdl-0.9.2/src/plotting_contour.cpp	2011-09-19 06:06:11.000000000 -0600
+++ gdl/src/plotting_contour.cpp	2012-01-26 17:01:33.000000000 -0700
@@ -849,15 +849,15 @@
 
     private: virtual void post_call(EnvT*, GDLGStream* actStream) // {{{
     {
-      UpdateSWPlotStructs(actStream, xStart, xEnd, yStart, yEnd);
+      UpdateSWPlotStructs(actStream, xStart, xEnd, yStart, yEnd, xLog, yLog);
 
       actStream->lsty(1);//reset linestyle
 
       if (!overplot)
       {
         // set ![XY].CRANGE
-        set_axis_crange("X", xStart, xEnd);
-        set_axis_crange("Y", yStart, yEnd);
+        set_axis_crange("X", xStart, xEnd, xLog);
+        set_axis_crange("Y", yStart, yEnd, yLog);
 
         //set ![x|y].type
         set_axis_type("X",xLog);
diff -ruN --exclude CVS gdl-0.9.2/src/plotting.cpp gdl/src/plotting.cpp
--- gdl-0.9.2/src/plotting.cpp	2011-09-19 06:06:11.000000000 -0600
+++ gdl/src/plotting.cpp	2012-03-05 08:35:07.000000000 -0700
@@ -1,1329 +1,1458 @@
-/***************************************************************************
-                       plotting.cpp  -  GDL routines for plotting
-                             -------------------
-    begin                : July 22 2002
-    copyright            : (C) 2002-2011 by Marc Schellens et al.
-    email                : m_schellens@users.sf.net
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "includefirst.hpp"
-
-#include <memory>
-
-// PLplot is used for direct graphics
-#include <plplot/plstream.h>
-
-#include "initsysvar.hpp"
-#include "envt.hpp"
-#include "graphics.hpp"
-#include "plotting.hpp"
-#include "math_utl.hpp"
-
-namespace lib {
-
-  using namespace std;
-
-  // local helper function
-  void GetMinMaxVal( DDoubleGDL* val, double* minVal, double* maxVal)
-  {
-    DLong minE, maxE;
-    const bool omitNaN = true;
-    val->MinMax( &minE, &maxE, NULL, NULL, omitNaN);
-    if( minVal != NULL) *minVal = (*val)[ minE];
-    if( maxVal != NULL) *maxVal = (*val)[ maxE];
-  }
-
-
-  PLFLT AutoTick(DDouble x)
-  {
-    if( x == 0.0) return 1.0;
-
-    DLong n = static_cast<DLong>( floor(log10(x/3.5)));
-    DDouble y = (x / (3.5 * pow(10.,static_cast<double>(n))));
-    DLong m;
-    if (y >= 1 && y < 2)
-      m = 1;
-    else if (y >= 2 && y < 5)
-      m = 2;
-    else if (y >= 5)
-      m = 5;
-
-    PLFLT intv = (PLFLT) (m * pow(10.,static_cast<double>(n)));
-    return intv;
-  }
-
-
-  PLFLT AutoIntv(DDouble x)
-  {
-    if( x == 0.0) {
-      //      cout << "zero"<<endl;
-      return 1.0;
-    }
-
-    DLong n = static_cast<DLong>( floor(log10(x/2.82)));
-    DDouble y = (x / (2.82 * pow(10.,static_cast<double>(n))));
-    DLong m;
-    if (y >= 1 && y < 2)
-      m = 1;
-    else if (y >= 2 && y < 4.47)
-      m = 2;
-    else if (y >= 4.47)
-      m = 5;
-    
-    //    cout << "AutoIntv" << x << " " << y << endl;
-
-    PLFLT intv = (PLFLT) (m * pow(10.,static_cast<double>(n)));
-    return intv;
-  }
-
-  //improved version of "AutoIntv" for:
-  // 1/ better managing ranges when all the data have same value
-  // 2/ mimic IDL behavior when data are all posivite
-  // please notice that (val_min, val_max) will be changed
-  // and "epsilon" is a coefficient if "extended range" is expected
-  PLFLT AutoIntvAC(DDouble &val_min, DDouble &val_max, DLong NoZero, bool log)
-  {
-    PLFLT intv = 1.;
-    int cas = 0 ;
-    DDouble x; 
-    bool debug = false ;
-    if (debug) {cout << "init: " <<  val_min << " " << val_max << endl;}
-    
-    if (log)
-    {
-      if (val_min == 0 || val_max == 0) return intv;
-      val_min = log10(val_min);
-      val_max = log10(val_max);
-    }
-
-    // case "all below ABS((MACHAR()).xmin)
-    if ((abs(val_min) < 1e-38) && (abs(val_max) < 1e-38)) 
-      {
-	val_min=DDouble(-1.);
-	val_max=DDouble( 1.);
-	intv = (PLFLT) (2.);
-	cas = 1 ;
-      }
-    
-    // case "all values are equal"
-    if (cas == 0)
-      {
-	x=val_max-val_min;
-	if (abs(x) < 1e-30) {
-	  DDouble val_ref;
-          val_ref=val_max;
-          if (0.98*val_min < val_ref) { // positive case
-            val_max=1.02*val_ref;
-            val_min=0.98*val_ref;
-          } else {     // negative case
-            val_max=0.98*val_ref;
-            val_min=1.02*val_ref;
-          }
-          if (debug) {cout << "Rescale : " << val_min << " " << val_max << endl;}
-	}
-      }
-    
-    // case "all data positive, must start at Zero" (mimic IDL behavior)
-    if ((cas == 0) && (val_min >= 0.0) && (NoZero == 0))
-      {
-	cas = 2 ;
-	DDouble resu, val_norm ;
-	// we used redundant scale (1.,1.2 and 10., 12. to avoid roundoff problem in log10)
-	DDouble levels[12]={1.,1.2,1.5,2.,2.5,3.,4.,5.,6.,8.,10.,12.};
-	int nb_levels= 12;
-	
-	DLong n = static_cast<DLong>( floor(log10(val_max)));
-	DDouble scale= pow(10.,static_cast<double>(n));
-	
-	val_norm=val_max/scale;
-     
-	resu=levels[0];
-	for (int c = 0; c < nb_levels; c++) {
-	  if ((val_norm > levels[c]) && (val_norm <= levels[c+1])) resu=levels[c+1] ;
-	}
-	val_min=0.0;
-	val_max=resu*scale;
-	intv = (PLFLT)(val_max);
-      }
-  
-    // general case (only negative OR negative and positive)
-    if (cas == 0)
-      {  
-	x=val_max-val_min;	
-	intv = AutoIntv( x);
-	val_max = ceil(val_max/intv) * intv;
-	val_min = floor(val_min/intv) * intv;
-      }
-  
-    if (debug) {cout << "cas: "<< cas << " new range: "<<  val_min << " " << val_max << endl;}
-
-    if (log)
-    {
-      val_min = pow(10, val_min);
-      val_max = pow(10, val_max);
-    }
-    
-    return intv;
-  }
-  
-  // !P
-  void GetPData( DLong& p_background,
-		 DLong& p_noErase, DLong& p_color, DLong& p_psym,
-		 DLong& p_linestyle,
-		 DFloat& p_symsize, DFloat& p_charsize, DFloat& p_thick,
-		 DString& p_title, DString& p_subTitle, DFloat& p_ticklen)
-  {
-    static DStructGDL* pStruct = SysVar::P();
-    static unsigned backgroundTag = pStruct->Desc()->TagIndex( "BACKGROUND");
-    static unsigned noEraseTag = pStruct->Desc()->TagIndex( "NOERASE");
-    static unsigned colorTag = pStruct->Desc()->TagIndex( "COLOR");
-    static unsigned psymTag = pStruct->Desc()->TagIndex( "PSYM");
-    static unsigned linestyleTag = pStruct->Desc()->TagIndex( "LINESTYLE");
-    static unsigned symsizeTag = pStruct->Desc()->TagIndex( "SYMSIZE");
-    static unsigned charsizeTag = pStruct->Desc()->TagIndex( "CHARSIZE");
-    static unsigned thickTag = pStruct->Desc()->TagIndex( "THICK");
-    static unsigned ticklenTag = pStruct->Desc()->TagIndex( "TICKLEN");
-    static unsigned titleTag = pStruct->Desc()->TagIndex( "TITLE");
-    static unsigned subTitleTag = pStruct->Desc()->TagIndex( "SUBTITLE");
-    p_background = 
-      (*static_cast<DLongGDL*>( pStruct->GetTag( backgroundTag, 0)))[0];
-    p_noErase = 
-      (*static_cast<DLongGDL*>( pStruct->GetTag( noEraseTag, 0)))[0];
-    p_color = 
-      (*static_cast<DLongGDL*>( pStruct->GetTag( colorTag, 0)))[0];
-    p_psym = 
-      (*static_cast<DLongGDL*>( pStruct->GetTag( psymTag, 0)))[0];
-    p_linestyle = 
-      (*static_cast<DLongGDL*>( pStruct->GetTag( linestyleTag, 0)))[0];
-    p_symsize = 
-      (*static_cast<DFloatGDL*>( pStruct->GetTag( symsizeTag, 0)))[0];
-    p_charsize = 
-      (*static_cast<DFloatGDL*>( pStruct->GetTag( charsizeTag, 0)))[0];
-    p_thick = 
-      (*static_cast<DFloatGDL*>( pStruct->GetTag( thickTag, 0)))[0];
-    p_title = 
-      (*static_cast<DStringGDL*>( pStruct->GetTag( titleTag, 0)))[0];
-    p_subTitle = 
-      (*static_cast<DStringGDL*>( pStruct->GetTag( subTitleTag, 0)))[0];
-    p_ticklen = 
-      (*static_cast<DFloatGDL*>( pStruct->GetTag( ticklenTag, 0)))[0];
-  }
-
-  // !X, !Y, !Z
-  void GetAxisData( DStructGDL* xStruct,
-		    DLong& style, DString& title, DFloat& charSize,
-		    DFloat& margin0, DFloat& margin1, DFloat& ticklen)
-  {		    
-    static unsigned styleTag = xStruct->Desc()->TagIndex( "STYLE");
-    static unsigned marginTag = xStruct->Desc()->TagIndex( "MARGIN");
-    static unsigned axisTitleTag = xStruct->Desc()->TagIndex( "TITLE");
-    static unsigned axischarsizeTag = xStruct->Desc()->TagIndex( "CHARSIZE");
-    static unsigned ticklenTag = xStruct->Desc()->TagIndex( "TICKLEN");
-    style = 
-      (*static_cast<DLongGDL*>( xStruct->GetTag( styleTag, 0)))[0];
-    title = 
-      (*static_cast<DStringGDL*>( xStruct->GetTag( axisTitleTag, 0)))[0];
-    charSize = 
-      (*static_cast<DFloatGDL*>( xStruct->GetTag( axischarsizeTag, 0)))[0];
-    margin0 = 
-      (*static_cast<DFloatGDL*>( xStruct->GetTag( marginTag, 0)))[0];
-    margin1 = 
-      (*static_cast<DFloatGDL*>( xStruct->GetTag( marginTag, 0)))[1];
-    ticklen = 
-      (*static_cast<DFloatGDL*>( xStruct->GetTag( ticklenTag, 0)))[0];
-  }
-
-  void AdjustAxisOpts(string& xOpt, string& yOpt,
-    DLong xStyle, DLong yStyle, DLong xTicks, DLong yTicks,
-    string& xTickformat, string& yTickformat, DLong xLog, DLong yLog
-  ) // {{{
-  {
-    if ((xStyle & 8) == 8) xOpt = "b";
-    if ((yStyle & 8) == 8) yOpt = "b";
-
-    if (xTicks == 1) xOpt += "t"; else xOpt += "st";
-    if (yTicks == 1) yOpt += "tv"; else yOpt += "stv";
-
-    if (xTickformat != "(A1)") xOpt += "n";
-    if (yTickformat != "(A1)") yOpt += "n";
-
-    if( xLog) xOpt += "l";
-    if( yLog) yOpt += "l";
-
-    if ((xStyle & 4) == 4) xOpt = "";
-    if ((yStyle & 4) == 4) yOpt = "";
-  } // }}}
-
-  void CheckMargin( EnvT* e, GDLGStream* actStream,
-		    DFloat xMarginL, 
-		    DFloat xMarginR, 
-		    DFloat yMarginB, 
-		    DFloat yMarginT,
-		    PLFLT& xMR,
-		    PLFLT& xML,
-		    PLFLT& yMB,
-		    PLFLT& yMT)
-  {
-    // get subpage in mm
-    PLFLT scrXL, scrXR, scrYB, scrYT;
-    actStream->gspa( scrXL, scrXR, scrYB, scrYT); 
-    PLFLT scrX = scrXR-scrXL;
-    PLFLT scrY = scrYT-scrYB;
-      
-    // get char size in mm (default, actual)
-    PLFLT defH, actH;
-    actStream->gchr( defH, actH);
-      
-    xML = xMarginL * actH / scrX;
-    xMR = xMarginR * actH / scrX;
-    
-    // factor 1.111 by ACoulais on 16/12/2010. Consequences on CONVERT_COORD
-    const float yCharExtension = 1.5*1.11111;
-    yMB = yMarginB * actH / scrY * yCharExtension;
-    yMT = yMarginT * actH / scrY * yCharExtension;
-    
-    if( xML+xMR >= 1.0)
-      {
-	Message( e->GetProName() + ": XMARGIN to large (adjusted).");
-	PLFLT xMMult = xML+xMR;
-	xML /= xMMult * 1.5;
-	xMR /= xMMult * 1.5;
-      }
-    if( yMB+yMT >= 1.0)
-      {
-	Message( e->GetProName() + ": YMARGIN to large (adjusted).");
-	PLFLT yMMult = yMB+yMT;
-	yMB /= yMMult * 1.5;
-	yMT /= yMMult * 1.5;
-      }
-  }
-
-  void Clipping( DDoubleGDL* clippingD, 
-		 DDouble& xStart,
-		 DDouble& xEnd,
-		 DDouble& minVal,
-		 DDouble& maxVal)
-  {
-    SizeT cEl=clippingD->N_Elements();
-    
-    // world coordinates
-    DDouble wcxs, wcxe,wcys, wcye; 
-    
-    if(cEl >= 1) wcxs=(*clippingD)[0]; else wcxs=0;
-    if(cEl >= 2) wcys=(*clippingD)[1]; else wcys=0;
-    if(cEl >= 3) wcxe=(*clippingD)[2]; else wcxe=wcxs;
-    if(cEl >= 4) wcye=(*clippingD)[3]; else wcye=wcys;
-    
-    if(wcxe < wcxs ) wcxe=wcxs; 
-    if(wcye < wcys ) wcye=wcys; 
-    
-    //     // viewport (0..1)
-    //     DDouble cxs, cxe,cys, cye;
-    //     cxs=(-xStart+wcxs)*(1-0)/(xEnd-xStart);
-    //     cxe=(-xStart+wcxe)*(1-0)/(xEnd-xStart);
-    //     cys=(-yStart+wcys)*(1-0)/(yEnd-yStart);
-    //     cye=(-yStart+wcye)*(1-0)/(yEnd-yStart);
-    //     actStream->vpor(cxs, cxe, cys, cye);
-    
-    xStart=wcxs; xEnd=wcxe; minVal=wcys; maxVal=wcye;
-  }
-
-
-  bool SetVP_WC( EnvT* e, 
-		 GDLGStream* actStream,
-		 DFloatGDL* pos,
-		 DDoubleGDL* clippingD,
-		 bool xLog, bool yLog,
-		 DFloat xMarginL, 
-		 DFloat xMarginR, 
-		 DFloat yMarginB, 
-		 DFloat yMarginT,
-		 // input/output
-		 DDouble xStart,
-		 DDouble xEnd,
-		 DDouble minVal,
-		 DDouble maxVal)
-  {
-    //    cout << "xStart " << xStart << "  xEnd "<<xEnd<<endl;
-    //    cout << "yStart " << minVal << "  yEnd "<<maxVal<<endl;
-
-
-    PLFLT xMR;
-    PLFLT xML; 
-    PLFLT yMB; 
-    PLFLT yMT;
-
-    CheckMargin( e, actStream,
-		 xMarginL, 
-		 xMarginR, 
-		 yMarginB, 
-		 yMarginT,
-		 xMR, xML, yMB, yMT);
-
-    // viewport - POSITION overrides
-    static bool kwP;
-    static PLFLT positionP[ 4]={0,0,0,0};
-    static PLFLT position[ 4];
-    DStructGDL* pStruct = SysVar::P();
-
-    // Get !P.position values
-    if(pStruct != NULL) {
-      static unsigned positionTag = pStruct->Desc()->TagIndex( "POSITION");
-      for( SizeT i=0; i<4; ++i)
-	positionP[i] = (PLFLT)
-	  (*static_cast<DFloatGDL*>(pStruct->GetTag( positionTag, 0)))[i];
-    }
-
-    // If pos == NULL (oplot)
-
-    if ( pos == NULL) {
-
-      // If position keyword previously set
-      if( kwP) {
-	actStream->vpor(position[0],position[2],position[1],position[3]);
-      } else {
-	// If !P.position not set
-	if (positionP[0] == 0 && positionP[1] == 0 &&
-	    positionP[2] == 0 && positionP[3] == 0)
-	  actStream->vpor(position[0],position[2],position[1],position[3]);
-	else {
-	  // !P.position set
-	  actStream->vpor(positionP[0],positionP[2],positionP[1],positionP[3]);
-	}
-      }
-      // New plot
-    } else if ( pos == (DFloatGDL*) 0xF) {
-      kwP = false;
-
-      // If !P.position not set use default values
-      if (positionP[0] == 0 && positionP[1] == 0 &&
-	  positionP[2] == 0 && positionP[3] == 0) {
-
-	// Set to default values
-	position[0] = xML;
-	position[1] = yMB;
-	position[2] = 1.0 - xMR;
-	position[3] = 1.0 - yMT;
-	actStream->vpor(position[0],position[2],position[1],position[3]);
-      } else {
-	// !P.position values
-	actStream->vpor(positionP[0],positionP[2],positionP[1],positionP[3]);
-      }
-      // Position keyword set
-    } else {
-      kwP = true;
-      for( SizeT i=0; i<4 && i<pos->N_Elements(); ++i)
-	position[ i] = (*pos)[ i];
-      actStream->vpor(position[0],position[2],position[1],position[3]);
-    }
-
-
-    // CLIPPING
-    if( clippingD != NULL)
-	Clipping( clippingD, xStart, xEnd, minVal, maxVal);
-
-    // for OPLOT start and end values are already log
-    // SA: changing only local variables!
-    if( pos != NULL)
-      {
-	if( xLog)
-	  {	  
-	    if( xStart <= 0.0) xStart = 0.0; else xStart = log10( xStart);
-	    if( xEnd   <= 0.0) return false; else xEnd = log10( xEnd);
-	  }
-	if( yLog)
-	  {
-	    if( minVal <= 0.0) minVal = 0.0; else minVal = log10( minVal);
-	    if( maxVal <= 0.0) return false; else maxVal = log10( maxVal);
-	  }
-      }
-	  
-    // set world coordinates
-    // cout << "VP wind: "<<xStart<<" "<<xEnd<<" "<<minVal<<" "<<maxVal<<endl;
-    //    printf("data lim (setv): %f %f %f %f\n", xStart, xEnd, minVal, maxVal);
-    actStream->wind( xStart, xEnd, minVal, maxVal);
-    //    cout << "xStart " << xStart << "  xEnd "<<xEnd<<endl;
-    //    cout << "yStart " << minVal << "  yEnd "<<maxVal<<endl;
-
-    return true;
-  }
-  
-  void UpdateSWPlotStructs(GDLGStream* actStream, DDouble xStart, DDouble xEnd, DDouble yStart, DDouble yEnd)
-  {
-    // Get viewpoint parameters and store in WINDOW & S
-    PLFLT p_xmin, p_xmax, p_ymin, p_ymax;
-    actStream->gvpd (p_xmin, p_xmax, p_ymin, p_ymax);
-
-    DStructGDL* Struct = NULL;
-
-    Struct = SysVar::X();
-    static unsigned windowTag = Struct->Desc()->TagIndex( "WINDOW");
-    static unsigned sTag = Struct->Desc()->TagIndex( "S");
-    if (Struct != NULL) 
-    {   
-      (*static_cast<DFloatGDL*>( Struct->GetTag( windowTag, 0)))[0] = p_xmin;
-      (*static_cast<DFloatGDL*>( Struct->GetTag( windowTag, 0)))[1] = p_xmax;
-
-      (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[0] = 
-        (p_xmin*xEnd - p_xmax*xStart) / (xEnd - xStart);
-      (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[1] = 
-        (p_xmax - p_xmin) / (xEnd - xStart);
-    }   
-
-    Struct = SysVar::Y();
-    if(Struct != NULL) 
-    {   
-      (*static_cast<DFloatGDL*>( Struct->GetTag( windowTag, 0)))[0] = p_ymin;
-      (*static_cast<DFloatGDL*>( Struct->GetTag( windowTag, 0)))[1] = p_ymax;
-
-      (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[0] = 
-        (p_ymin*yEnd - p_ymax*yStart) / (yEnd - yStart);
-      (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[1] = 
-        (p_ymax - p_ymin) / (yEnd - yStart);
-    }
-  }
-
-  void GetSFromPlotStructs(DDouble **sx, DDouble **sy)
-  {
-    static DStructGDL* xStruct = SysVar::X();
-    static DStructGDL* yStruct = SysVar::Y();
-    unsigned sxTag = xStruct->Desc()->TagIndex( "S");
-    unsigned syTag = yStruct->Desc()->TagIndex( "S");
-    *sx = &(*static_cast<DDoubleGDL*>( xStruct->GetTag( sxTag, 0)))[0];
-    *sy = &(*static_cast<DDoubleGDL*>( yStruct->GetTag( syTag, 0)))[0];
-  }
-    
-  void GetWFromPlotStructs(DFloat **wx, DFloat **wy)
-  {
-    static DStructGDL* xStruct = SysVar::X();
-    static DStructGDL* yStruct = SysVar::Y();
-    unsigned xwindowTag = xStruct->Desc()->TagIndex( "WINDOW");
-    unsigned ywindowTag = yStruct->Desc()->TagIndex( "WINDOW");
-    *wx = &(*static_cast<DFloatGDL*>( xStruct->GetTag( xwindowTag, 0)))[0];
-    *wy = &(*static_cast<DFloatGDL*>( yStruct->GetTag( ywindowTag, 0)))[0];
-  }
-    
-  void DataCoordLimits(DDouble *sx, DDouble *sy, DFloat *wx, DFloat *wy, 
-    DDouble *xStart, DDouble *xEnd, DDouble *yStart, DDouble *yEnd, bool clip_by_default)
-  {
-    *xStart = (wx[0] - sx[0]) / sx[1];
-    *xEnd   = (wx[1] - sx[0]) / sx[1];
-    *yStart = (wy[0] - sy[0]) / sy[1];
-    *yEnd   = (wy[1] - sy[0]) / sy[1];
-    //    cout << *xStart <<" "<< *xEnd << " "<< *yStart <<" "<< *yEnd << ""<< endl;
-
-    // patch from Joanna (tracker item no. 3029409, see test_clip.pro)
-    if (!clip_by_default) {
-      //      cout << "joanna" << endl;
-      DFloat wxlen = wx[1] - wx[0];
-      DFloat wylen = wy[1] - wy[0];
-      DFloat xlen = *xEnd - *xStart;
-      DFloat ylen = *yEnd - *yStart;
-      *xStart = *xStart - xlen/wxlen * wx[0];
-      *xEnd = *xEnd + xlen/wxlen * (1 - wx[1]);
-      *yStart = *yStart - ylen/wylen * wy[0];
-      *yEnd = *yEnd + ylen/wylen * (1 - wy[1]);
-    }  
-    //    cout << *xStart <<" "<< *xEnd << " "<< *yStart <<" "<< *yEnd << ""<< endl;
-  }
-
-
-  void ac_histo(GDLGStream *a, int i_buff, PLFLT *x_buff, PLFLT *y_buff )
-  {
-    PLFLT x,x1,y,y1;
-    for ( int jj=1; jj<i_buff; ++jj){
-      x1=x_buff[jj-1];
-      x=x_buff[jj];
-      y1=y_buff[jj-1];
-      y=y_buff[jj];
-      a->join(x1,y1,(x1+x)/2.0,y1);
-      a->join((x1+x)/2.0,y1,(x1+x)/2.0,y);
-      a->join((x1+x)/2.0,y,x,y);
-    }
-  }
-
-  //CORE PLOT FUNCTION -> Draws a line along xVal, yVal
-  template <typename T> bool draw_polyline(EnvT *e,  GDLGStream *a,
-					   T * xVal, T* yVal, 
-					   bool xLog, bool yLog, 
-					   DDouble yStart, DDouble yEnd, 
-					   DLong psym)
-  {
-    bool line=false;
-    bool valid=true;
-    DLong psym_=0;
-
-    if(psym <0 ) {line=true; psym_=-psym;}
-    else if(psym == 0 ) {line=true;psym_=psym;}
-    else {psym_=psym;}
-    DLong minEl = (xVal->N_Elements() < yVal->N_Elements())? 
-      xVal->N_Elements() : yVal->N_Elements();
-    // if scalar x
-    if (xVal->N_Elements() == 1 && xVal->Rank() == 0) 
-      minEl = yVal->N_Elements();
-    // if scalar y
-    if (yVal->N_Elements() == 1 && yVal->Rank() == 0) 
-      minEl = xVal->N_Elements();
-
-    DDouble *sx, *sy;
-    GetSFromPlotStructs(&sx, &sy);
-
-    bool mapSet=false;
-#ifdef USE_LIBPROJ4
-    // Map Stuff (xtype = 3)
-    LPTYPE idata;
-    XYTYPE odata;
-
-    get_mapset(mapSet);
-
-    DDouble xStart, xEnd;
-    get_axis_crange("X", xStart, xEnd);
-
-    if ( mapSet) {
-      ref = map_init();
-      if ( ref == NULL) {
-	e->Throw( "Projection initialization failed.");
-      }
-    }
-#endif
-
-    // is one of the 2 "arrays" a singleton or not ?
-
-    PLFLT y, y1, yMapBefore, y_ref;
-    int flag_y_const =0;
-    y_ref = static_cast<PLFLT>( (*yVal)[0]);
-    if (yVal->N_Elements() == 1 && yVal->Rank() == 0) flag_y_const=1 ;
-
-    PLFLT x, x1, xMapBefore, x_ref;
-    int flag_x_const =0;
-    x_ref = static_cast<PLFLT>( (*xVal)[0]);
-    if (xVal->N_Elements() == 1 && xVal->Rank() == 0) flag_x_const=1 ;
-
-    // AC 070601 we use a buffer to use the fast ->line method
-    // instead of the slow ->join one.
-    // 2 tricks: 
-    // trick 1/ size of buffer is limited to 1e4 (compromize syze/speed) in order to be able to manage very
-    //    large among of data whitout duplicating all the arrays
-    // trick 2/ when we have a NaN or and Inf, we realize the plot, then reset.
-    
-    int n_buff_max=500000; // idl default seems to be more than 2e6 !!
-    if (minEl < n_buff_max)  n_buff_max=minEl;
-    int i_buff=0;
-    PLFLT *x_buff = new PLFLT[n_buff_max];
-    PLFLT *y_buff = new PLFLT[n_buff_max];
-   
-    // flag to reset Buffer when a NaN or a Infinity are founded
-    int reset=0;
-
-    // translation plplot symbols - GDL symbols
-    // for now usersym is a circle
-    const PLINT codeArr[]={ 0,2,3,1,11,7,6,5,4};
-
-    for( int i=0; i<minEl; ++i)
-      {
-	if (!flag_x_const) x = static_cast<PLFLT>( (*xVal)[i]); else x=x_ref;
-	if (!flag_y_const) y = static_cast<PLFLT>( (*yVal)[i]); else y=y_ref;
-
-#ifdef USE_LIBPROJ4
-	if (mapSet && !e->KeywordSet("NORMAL")) {
-	  idata.lam = x * DEG_TO_RAD;
-	  idata.phi = y * DEG_TO_RAD;
-	  if (i >0) {
-	    xMapBefore=odata.x;
-	    yMapBefore=odata.y;
-	  }
-	  odata = PJ_FWD(idata, ref);
-	  x = odata.x;
-	  y = odata.y;	  
-	}
-#endif	
-	if (!isfinite(x) || !isfinite(y) || isnan(x) || isnan(y)) {
-	  reset=1;
-	  if (i_buff > 0) {
-	    if (line) { a->line (i_buff, x_buff, y_buff);}
-	    if (psym_ > 0 && psym_ < 10) { a->poin(i_buff, x_buff, y_buff, codeArr[psym_]);}
-	    if (psym_ == 10) {  ac_histo( a, i_buff, x_buff, y_buff ); }
-	    i_buff=0;
-	  }
-	  continue;
-	}
-
-#ifdef USE_LIBPROJ4
-	if (mapSet && !e->KeywordSet("NORMAL")) {
-	  if (i >0 ) //;&& (i_buff >0))
-	    {
-	      x1=xMapBefore;
-	      if (!isfinite(xMapBefore) || !isfinite(yMapBefore)) continue;
-
-	      // Break "jumps" across maps (kludge!)
-	      if (fabs(x-x1) > 0.5*(xEnd-xStart)) {
-		reset=1;
-		if ((i_buff > 0) && (line)) {
-		  a->line (i_buff, x_buff, y_buff);
-		  //		  x_buff[0]=x_buff[i_buff-1];
-		  //y_buff[0]=y_buff[i_buff-1];
-		  i_buff=0;
-		}
-		continue;
-	      }
-	    }
-	}
-#endif
-
-	if( xLog) if( x <= 0.0) continue; else x = log10( x);
-	if( yLog) if( y <= 0.0) continue; else y = log10( y);
-
-	x_buff[i_buff]=x;
-	y_buff[i_buff]=y;
-	i_buff=i_buff+1;
-	
-	if ((i_buff == n_buff_max-1) || (i == minEl-1 )) {
-	  if (line) { a->line(i_buff, x_buff, y_buff); };
-	  if (psym_ > 0 && psym_ < 10) { a->poin(i_buff, x_buff, y_buff, codeArr[psym_]);}
-	  if (psym_ == 10) {  ac_histo( a, i_buff, x_buff, y_buff ); }
-	    
-	  // we must recopy the last point since the line must continue (tested via small buffer ...)
-	  x_buff[0]=x_buff[i_buff-1];
-	  y_buff[0]=y_buff[i_buff-1];
-	  i_buff=1;
-	}
-      }
-    
-    delete[] x_buff;
-    delete[] y_buff;
-    
-    return (valid);
-  }
-  // explicit instantiation for SpDDouble
-  template bool draw_polyline(EnvT*, GDLGStream*, Data_<SpDDouble>*, Data_<SpDDouble>*, bool, bool, DDouble, DDouble, DLong);
-
-/********* SA: this is not used anywhere!
-  
-  //CORE PLOT FUNCTION -> Draws a line along xVal, yVal
-  template <typename T> bool draw_polyline_ref(EnvT *e,  GDLGStream *a,
-					   T *xVal, T *yVal, 
-					   bool xLog, bool yLog, 
-					   DDouble yStart, DDouble yEnd, 
-					   DLong psym)
-  {
-    bool line=false;
-    bool valid=true;
-    DLong psym_=0;
-
-    if(psym <0 ) {line=true; psym_=-psym;}
-    else if(psym == 0 ) {line=true;psym_=psym;}
-    else {psym_=psym;}
-    DLong minEl = (xVal->N_Elements() < yVal->N_Elements())? 
-      xVal->N_Elements() : yVal->N_Elements();
-    // if scalar x
-    if (xVal->N_Elements() == 1 && xVal->Rank() == 0) 
-      minEl = yVal->N_Elements();
-    // if scalar y
-    if (yVal->N_Elements() == 1 && yVal->Rank() == 0) 
-      minEl = xVal->N_Elements();
-
-    DDouble *sx, *sy;
-    GetSFromPlotStructs(&sx, &sy);
-
-    bool mapSet=false;
-#ifdef USE_LIBPROJ4
-    // Map Stuff (xtype = 3)
-    LPTYPE idata;
-    XYTYPE odata;
-
-    get_mapset(mapSet);
-
-    DDouble xStart, xEnd;
-    get_axis_crange("X", xStart, xEnd);
-
-    if ( mapSet) {
-      ref = map_init();
-      if ( ref == NULL) {
-	e->Throw( "Projection initialization failed.");
-      }
-    }
-#endif
-
-    for( int i=0; i<minEl; ++i)
-      {
-	PLFLT y;
-	if (yVal->N_Elements() == 1 && yVal->Rank() == 0) 
-	  y = static_cast<PLFLT>( (*yVal)[0]);
-	else
-	  y = static_cast<PLFLT>( (*yVal)[i]);
-
-	if( yLog) if( y <= 0.0) continue; else y = log10( y);
-	
-	PLFLT x;
-	if (xVal->N_Elements() == 1 && xVal->Rank() == 0) 
-	  x = static_cast<PLFLT>( (*xVal)[0]);
-	else
-	  x = static_cast<PLFLT>( (*xVal)[i]);
-
-	if( xLog) 
-	  if( x <= 0.0) 
-	    continue; 
-	  else 
-	    x = log10( x);
-
-#ifdef USE_LIBPROJ4
-	if (mapSet && !e->KeywordSet("NORMAL")) {
-	  idata.lam = x * DEG_TO_RAD;
-	  idata.phi = y * DEG_TO_RAD;
-	  odata = PJ_FWD(idata, ref);
-	  x = odata.x;
-	  y = odata.y;
-	  if (!isfinite(x) || !isfinite(y)) continue;
-	}
-#endif
-
-	if( i>0)
-	  {
-	    if( line)
-	      {
-		PLFLT y1;
-		if (yVal->N_Elements() == 1 && yVal->Rank() == 0) 
-		  y1 = static_cast<PLFLT>( (*yVal)[0]);
-		else
-		  y1 = static_cast<PLFLT>( (*yVal)[i-1]);
-
-		if( !yLog || y1 > 0.0)
-		  {
-		    if( yLog) y1 = log10( y1);
-
-		    PLFLT x1;
-		    if (xVal->N_Elements() == 1 && xVal->Rank() == 0) 
-		      x1 = static_cast<PLFLT>( (*xVal)[0]);
-		    else
-		      x1 = static_cast<PLFLT>( (*xVal)[i-1]);
-		    
-		    if( !xLog || x1 > 0.0)
-		      {
-			if( xLog) x1 = log10( x1);
-
-#ifdef USE_LIBPROJ4
-			// Convert from lon/lat in degrees to radians
-			// Convert from lon/lat in radians to data coord
-			if (mapSet && !e->KeywordSet("NORMAL")) {
-			  idata.lam = x1 * DEG_TO_RAD;
-			  idata.phi = y1 * DEG_TO_RAD;
-			  odata = PJ_FWD(idata, ref);
-			  x1 = odata.x;
-			  y1 = odata.y;
-			  if (!isfinite(x1) || !isfinite(y1)) continue;
-
-			  // Break "jumps" across maps (kludge!)
-			  if (fabs(x-x1) > 0.5*(xEnd-xStart)) continue;
-			}
-#endif
-
-			a->join(x1,y1,x,y);
-
-			// cout << "join( "<<x1<<", "<<y1<<", "<<
-			// x<<", "<<y<<")"<<endl;
-		      }
-		  }
-	      }
-	    else if( psym_ == 10)
-	      {	// histogram
-		PLFLT y1 = static_cast<PLFLT>( (*yVal)[i-1]);
-		
-		if( !yLog || y1 > 0.0)
-		  {
-		    if( yLog) y1 = log10( y1);
-		    if( y1 >= yStart && y1 <= yEnd)
-		      {
-			PLFLT x1 = static_cast<PLFLT>( (*xVal)[i-1]);
-			
-			if( !xLog || x1 > 0.0)
-			  {
-			    if( xLog) x1 = log10( x1);
-	
-#ifdef USE_LIBPROJ4
-			    if (mapSet && !e->KeywordSet("NORMAL")) {
-			      idata.lam = x1 * DEG_TO_RAD;
-			      idata.phi = y1 * DEG_TO_RAD;
-			      odata = PJ_FWD(idata, ref);
-			      x1 = odata.x;
-			      y1 = odata.y;
-			    }
-#endif		    
-			    a->join(x1,y1,(x1+x)/2.0,y1);
-			    a->join((x1+x)/2.0,y1,(x1+x)/2.0,y);
-			    a->join((x1+x)/2.0,y,x,y);
-			  }
-		      }
-		  }
-	      }
-	  }
-	if( psym_ == 0 || psym_ == 10) continue;
-	
-	// translation plplot symbols - GDL symbols
-	// for now usersym is a circle
-	const PLINT codeArr[]={ 0,2,3,1,11,7,6,5,4};
-
-	if (isfinite(x) && isfinite(y)) {
-	  a->poin(1,&x,&y,codeArr[psym_]);
-	}
-      }
-    return (valid);
-  }
-*********/
-
-  //MARGIN
-  void gkw_axis_margin(EnvT *e, string axis,DFloat &start, DFloat &end)
-  {
-    DStructGDL* Struct;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
-
-    if(Struct != NULL)
-      {
-	static unsigned marginTag = Struct->Desc()->TagIndex( "MARGIN");
-	start = 
-	  (*static_cast<DFloatGDL*>( Struct->GetTag( marginTag, 0)))[0];
-	end = 
-	  (*static_cast<DFloatGDL*>( Struct->GetTag( marginTag, 0)))[1];
-      }
-
-    string MarginName=axis+"MARGIN";
-    BaseGDL* Margin=e->GetKW(e->KeywordIx(MarginName));
-    if(Margin !=NULL)
-      {
-	if(Margin->N_Elements() > 2)
-	  e->Throw("Keyword array parameter "+MarginName+
-		   " must have from 1 to 2 elements.");
-	auto_ptr<DFloatGDL> guard;
-	DFloatGDL* MarginF = static_cast<DFloatGDL*>
-	  ( Margin->Convert2( FLOAT, BaseGDL::COPY));
-	guard.reset( MarginF);
-	start = (*MarginF)[0];
-	if( MarginF->N_Elements() > 1)
-	  end = (*MarginF)[1];
-      }
-  }
-
-  //BACKGROUND COLOR
-  void gkw_background(EnvT *e, GDLGStream *a, bool kw)
-  {
-    static DStructGDL* pStruct = SysVar::P();
-    DLong background = 
-      (*static_cast<DLongGDL*>
-       (pStruct->GetTag( pStruct->Desc()->TagIndex("BACKGROUND"), 0)))[0];
-    if(kw)
-      e->AssureLongScalarKWIfPresent( "BACKGROUND", background);
-
-    // Get decomposed value
-    Graphics* actDevice = Graphics::GetDevice();
-    DLong decomposed = actDevice->GetDecomposed();
-    if (decomposed != 0 && decomposed != 1) {decomposed=0;}
-
-    a->Background( background, decomposed);  
-  }
-
-  //COLOR
-  void gkw_color(EnvT *e, GDLGStream *a)
-  {
-    // Get COLOR from PLOT system variable
-    static DStructGDL* pStruct = SysVar::P();
-    DLong color = 
-      (*static_cast<DLongGDL*>
-       (pStruct->GetTag( pStruct->Desc()->TagIndex("COLOR"), 0)))[0];
-
-    // Get # of colors from DEVICE system variable
-    DVar *var=FindInVarList(sysVarList,"D");
-    DStructGDL* s = static_cast<DStructGDL*>( var->Data());
-    DLong ncolor = (*static_cast<DLongGDL*>
-                    (s->GetTag(s->Desc()->TagIndex("N_COLORS"), 0)))[0];
-
-    if (ncolor > 256 && color == 255) color = ncolor - 1;
-
-    e->AssureLongScalarKWIfPresent( "COLOR", color);
-
-    // Get decomposed value
-    Graphics* actDevice = Graphics::GetDevice();
-    DLong decomposed = actDevice->GetDecomposed();
-    if (decomposed != 0 && decomposed != 1) {decomposed=0;}
-    a->Color( color, decomposed, 2);  
-  }
-
-  // helper for NOERASE (but also used in XYOUTS)
-  void handle_pmulti_position(EnvT *e, GDLGStream *a)
-  {
-    // !P.MULTI is ignored if POSITION kw or !P.POSITION or !P.REGION is specified
-    // TODO: !P.REGION!
-
-    DFloatGDL* pos = NULL;
-
-    // system variable
-    static DStructGDL* pStruct = SysVar::P();
-    pos = static_cast<DFloatGDL*>(pStruct-> GetTag( pStruct->Desc()->TagIndex("POSITION"), 0));
-    if ((*pos)[0] == (*pos)[2]) pos = NULL;
-
-    // keyword
-    if (pos == NULL) 
-    {
-      DSub* pro = e->GetPro();
-      int positionIx = pro->FindKey( "POSITION");
-      if (positionIx != -1) pos = e->IfDefGetKWAs<DFloatGDL>( positionIx);
-    }
-
-    if (pos != NULL) a->NoSub();
-  }
-
-  //NOERASE
-  void gkw_noerase(EnvT *e,GDLGStream *a, bool noe)
-  {
-    DLong noErase=0;
-    DLongGDL* pMulti = SysVar::GetPMulti();
-    static DStructGDL* pStruct = SysVar::P();
-
-    if(!noe)
-      {
-	noErase = (*static_cast<DLongGDL*>
-		   ( pStruct->
-		     GetTag( pStruct->Desc()->TagIndex("NOERASE"), 0)))[0];
-	if(e->KeywordSet("NOERASE")) {
-	  noErase=1;
-	}
-      }
-    else
-      {
-	noErase=1;
-      }
-
-    a->NextPlot( !noErase);
-    handle_pmulti_position(e, a);
-  }
-
-  //PSYM
-  void gkw_psym(EnvT *e, GDLGStream *a, bool &line, DLong &psym)
-  {
-    static DStructGDL* pStruct = SysVar::P();
-    psym= (*static_cast<DLongGDL*>
-	   (pStruct->GetTag(pStruct->Desc()->TagIndex("PSYM"), 0)))[0];
-
-    line = false;
-    e->AssureLongScalarKWIfPresent( "PSYM", psym);
-    if( psym > 10 || psym < -8 || psym == 9)
-      e->Throw( 
-			  "PSYM (plotting symbol) out of range.");
-  }
-
-    //SYMSIZE
-  void gkw_symsize(EnvT *e, GDLGStream *a)
-  {
-    static DStructGDL* pStruct = SysVar::P();
-    DFloat symsize = (*static_cast<DFloatGDL*>
-		      (pStruct->GetTag( pStruct->Desc()->TagIndex("SYMSIZE"), 0)))[0];
-    e->AssureFloatScalarKWIfPresent( "SYMSIZE", symsize);
-    if( symsize <= 0.0) symsize = 1.0;
-    a->ssym(0.0, symsize);  
-  }
-
-  //CHARSIZE
-  void gkw_charsize(EnvT *e, GDLGStream *a, DFloat &charsize, bool kw)
-  {
-    static DStructGDL* pStruct = SysVar::P();
-    charsize = (*static_cast<DFloatGDL*>
-			(pStruct->GetTag
-			 ( pStruct->Desc()->TagIndex("CHARSIZE"), 0)))[0];
-    if(kw)
-      e->AssureFloatScalarKWIfPresent( "CHARSIZE", charsize);
-
-    if( charsize <= 0.0) charsize = 1.0;
-    a->schr(0.0, charsize);  
-  }
-  //THICK
-  void gkw_thick(EnvT *e, GDLGStream *a)
-  {
-    static DStructGDL* pStruct = SysVar::P();
-    DFloat thick = (*static_cast<DFloatGDL*>
-		    (pStruct->GetTag( pStruct->Desc()->TagIndex("THICK"), 0)))[0];
-
-    e->AssureFloatScalarKWIfPresent( "THICK", thick);
-    if( thick <= 0.0) thick = 1.0;
-    a->wid( static_cast<PLINT>(floor( thick-0.5)));
-  }
-
-  //LINESTYLE
-  void gkw_linestyle(EnvT *e, GDLGStream *a)
-  {
-    static DStructGDL* pStruct = SysVar::P();
-    DLong linestyle= 
-      (*static_cast<DLongGDL*>
-       (pStruct->GetTag( pStruct->Desc()->TagIndex("LINESTYLE"), 0)))[0];
-
-    // if the LINESTYLE keyword is present, the value will be change
-    DLong temp_linestyle=-1111;
-    e->AssureLongScalarKWIfPresent( "LINESTYLE",temp_linestyle);
-    
-    bool debug=false;
-    if (debug) {
-      cout << "temp_linestyle " <<  temp_linestyle << endl;
-      cout << "     linestyle " <<  linestyle << endl;
-    }
-    if (temp_linestyle != -1111) {linestyle=temp_linestyle;}//+1;
-    if (linestyle < 0 ) {linestyle=0;}
-    if (linestyle > 5 ) {linestyle=5;}
-
-      // see
-      // file:///home/coulais/SoftsExternes/plplot-5.5.3/examples/c++/x09.cc
-      // file:///home/coulais/SoftsExternes/plplot-5.5.3/doc/docbook/src/plstyl.html
-
-    if (linestyle == 0) { // solid (continuous line)
-      static PLINT nbp=0;
-      a->styl(nbp, NULL, NULL);
-    }
-    if (linestyle == 1) { // dots
-      static PLINT nbp=1;
-      static PLINT mark[] = {75};
-      static PLINT space[] = {1500};
-      a->styl(nbp, mark, space);
-    }
-    if (linestyle == 2) { // dashed
-      static PLINT nbp=1;
-      static PLINT mark[] = {1500};
-      static PLINT space[] = {1500};
-      a->styl(nbp, mark, space);
-  }
-    if (linestyle == 3) { // dash dot
-      static PLINT nbp=2;
-      static PLINT mark[] = {1500,100};
-      static PLINT space[] = {1000,1000};
-      a->styl(nbp, mark, space);
-    }
-    if (linestyle == 4) { // dash dot dot
-      static PLINT nbp=4;
-      static PLINT mark[] = {1500,100,100,100};
-      static PLINT space[] = {1000,1000,1000,1000};
-      a->styl(nbp, mark, space);
-    }
-    if (linestyle == 5) { // long dash
-      static PLINT nbp=1;
-      static PLINT mark[] = {3000};
-      static PLINT space[] = {1500}; 
-      a->styl(nbp, mark, space);
-    }
-  }
-
-  //TITLE
-  void gkw_title(EnvT* e, GDLGStream *a, PLFLT ad)
-  {
-    DLong thick=0;
-    e->AssureLongScalarKWIfPresent("CHARTHICK",thick);
-    a->wid(thick);
-
-    static DStructGDL* pStruct = SysVar::P();
-    static unsigned titleTag = pStruct->Desc()->TagIndex( "TITLE");
-    static unsigned subTitleTag = pStruct->Desc()->TagIndex( "SUBTITLE");
-    DString title =   
-      (*static_cast<DStringGDL*>( pStruct->GetTag( titleTag, 0)))[0];
-    DString subTitle =  
-      (*static_cast<DStringGDL*>( pStruct->GetTag( subTitleTag, 0)))[0];
-    e->AssureStringScalarKWIfPresent( "TITLE", title);
-    e->AssureStringScalarKWIfPresent( "SUBTITLE", subTitle);
-
-    a->schr( 0.0, 1.25*ad);
-    a->mtex("t",1.25,0.5,0.5,title.c_str());
-    a->schr( 0.0, ad); // charsize is reset here
-    a->mtex("b",5.4,0.5,0.5,subTitle.c_str());
-    a->wid(0);
-  }
-
-  //crange to struct
-  void set_axis_crange(string axis, DDouble Start, DDouble End)
-  {
-    DStructGDL* Struct=NULL;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
-    if(axis=="Z") Struct = SysVar::Z();
-    if(Struct!=NULL)
-      {
-	static unsigned crangeTag = Struct->Desc()->TagIndex( "CRANGE");
-	(*static_cast<DDoubleGDL*>( Struct->GetTag( crangeTag, 0)))[0] = Start;
-	(*static_cast<DDoubleGDL*>( Struct->GetTag( crangeTag, 0)))[1] = End;
-      }
-  }
-
-  //CRANGE from struct
-  void get_axis_crange(string axis, DDouble &Start, DDouble &End)
-  {
-    DStructGDL* Struct=NULL;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
-    if(axis=="Z") Struct = SysVar::Z();
-    if(Struct!=NULL)
-      {
-	static unsigned crangeTag = Struct->Desc()->TagIndex( "CRANGE");
-	Start = (*static_cast<DDoubleGDL*>( Struct->GetTag( crangeTag, 0)))[0]; 
-	End = (*static_cast<DDoubleGDL*>( Struct->GetTag( crangeTag, 0)))[1];
-      }
-  }
-
-   void get_axis_type(string axis,bool &log)
-  {
-    DStructGDL* Struct;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
-    if(axis=="Z") Struct = SysVar::Z();
-    if(Struct != NULL) {
-      static unsigned typeTag = Struct->Desc()->TagIndex( "TYPE");
-      if ((*static_cast<DLongGDL*>(Struct->GetTag( typeTag, 0)))[0] == 1)
-	log = 1;
-      else
-	log=0;
-    }
-  }
-
-  void get_mapset(bool &mapset)
-  {
-    DStructGDL* Struct = SysVar::X();
-    if(Struct != NULL) {
-      static unsigned typeTag = Struct->Desc()->TagIndex( "TYPE");
-
-      if ((*static_cast<DLongGDL*>(Struct->GetTag( typeTag, 0)))[0] == 3)
-	mapset = 1;
-      else
-	mapset = 0;
-    }
-  }
-
-  void set_mapset(bool mapset)
-  {
-    DStructGDL* Struct = SysVar::X();
-    if(Struct!=NULL)
-      {
-	static unsigned typeTag = Struct->Desc()->TagIndex( "TYPE");
-	(*static_cast<DLongGDL*>( Struct->GetTag( typeTag, 0)))[0] = mapset;
-      }
-  }
-  
-
-  //axis type (log..)
-  void set_axis_type(string axis, bool Type)
-  {
-    DStructGDL* Struct=NULL;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
-    if(axis=="Z") Struct = SysVar::Z();
-    if(Struct!=NULL)
-      {
-	static unsigned typeTag = Struct->Desc()->TagIndex("TYPE");   
-	(*static_cast<DLongGDL*>(Struct->GetTag(typeTag, 0)))[0] = Type; 
-      }
-  }
-
-  void gkw_axis_charsize(EnvT* e, string axis, DFloat &charsize)
-  {
-    DStructGDL* Struct;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
-
-    if(Struct != NULL)
-      {
-	static unsigned charsizeTag = Struct->Desc()->TagIndex("CHARSIZE");
-	charsize = 
-	  (*static_cast<DFloatGDL*>( Struct->GetTag( charsizeTag, 0)))[0];
-      }
-
-    string Charsize_s=axis+"CHARSIZE";
-    e->AssureFloatScalarKWIfPresent( Charsize_s, charsize);
-    if(charsize <=0.0) charsize=1.0;
-  }
-
-
-  //STYLE
-  void gkw_axis_style(EnvT *e, string axis, DLong &style)
-  {
-    DStructGDL* Struct;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
-    if(Struct != NULL)
-      {
-	static unsigned styleTag = Struct->Desc()->TagIndex( "STYLE");
-	style = 
-	  (*static_cast<DLongGDL*>( Struct->GetTag( styleTag, 0)))[0];
-      }
-
-    string StyleName=axis+"STYLE";
-
-  }
-
-  void gkw_axis_title(EnvT *e, string axis, DString &title)
-  {
-    DStructGDL* Struct;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
-    
-    if(Struct != NULL)
-      {
-	static unsigned titleTag = Struct->Desc()->TagIndex("TITLE");
-	title = 
-	  (*static_cast<DStringGDL*>( Struct->GetTag( titleTag, 0)))[0];
-      }
-
-    string TitleName=axis+"TITLE";
-    e->AssureStringScalarKWIfPresent( TitleName, title);
-
-  }
-
-  //GET RANGE
-  void gkw_axis_range(EnvT *e, string axis, DDouble &start, DDouble &end, 
-		      DLong &ynozero)
-  {
-    DStructGDL* Struct;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
-    if (Struct != NULL) 
-      {
-	DDouble test1, test2;
-	static unsigned rangeTag = Struct->Desc()->TagIndex( "RANGE");
-	test1 = (*static_cast<DDoubleGDL*>( Struct->GetTag( rangeTag, 0)))[0]; 
-	test2 = (*static_cast<DDoubleGDL*>( Struct->GetTag( rangeTag, 0)))[1];
-	if (!(test1 == 0.0 && test2 == 0.0)) 
-	{ 
-		start = test1; 
-		end = test2; 
-	}
-      }
-    string RangeName=axis+"RANGE";
-    BaseGDL* Range=e->GetKW(e->KeywordIx(RangeName));
-    if(Range !=NULL)
-      {
-	if(Range->N_Elements() != 2)
-	  e->Throw("Keyword array parameter "+RangeName+
-		   " must have 2 elements.");
-	auto_ptr<DFloatGDL> guard;
-	DFloatGDL* RangeF = static_cast<DFloatGDL*>
-	  ( Range->Convert2( FLOAT, BaseGDL::COPY));
-	guard.reset( RangeF);
-	start = (*RangeF)[0];
-	end = (*RangeF)[1];
-	if(axis=="Y") ynozero=1;
-      }
-  }
-
-  void get_axis_margin(string axis, DFloat &low, DFloat &high)
-  {
-    DStructGDL* Struct=NULL;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
-    if(Struct!=NULL)
-      {
-	static unsigned marginTag = Struct->Desc()->TagIndex( "MARGIN");
-	low = (*static_cast<DFloatGDL*>( Struct->GetTag( marginTag, 0)))[0]; 
-	high = (*static_cast<DFloatGDL*>( Struct->GetTag( marginTag, 0)))[1];
-      }
-  }
-
-} // namespace
+/***************************************************************************
+                       plotting.cpp  -  GDL routines for plotting
+                             -------------------
+    begin                : July 22 2002
+    copyright            : (C) 2002-2011 by Marc Schellens et al.
+    email                : m_schellens@users.sf.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "includefirst.hpp"
+
+#include <memory>
+
+// PLplot is used for direct graphics
+#include <plplot/plstream.h>
+
+#include "initsysvar.hpp"
+#include "envt.hpp"
+#include "graphics.hpp"
+#include "plotting.hpp"
+#include "math_utl.hpp"
+
+namespace lib {
+
+  using namespace std;
+
+  // local helper function
+  void GetMinMaxVal( DDoubleGDL* val, double* minVal, double* maxVal)
+  {
+    DLong minE, maxE;
+    const bool omitNaN = true;
+    val->MinMax( &minE, &maxE, NULL, NULL, omitNaN);
+    if( minVal != NULL) *minVal = (*val)[ minE];
+    if( maxVal != NULL) *maxVal = (*val)[ maxE];
+  }
+
+
+  PLFLT AutoTick(DDouble x)
+  {
+    if( x == 0.0) return 1.0;
+
+    DLong n = static_cast<DLong>( floor(log10(x/3.5)));
+    DDouble y = (x / (3.5 * pow(10.,static_cast<double>(n))));
+    DLong m;
+    if (y >= 1 && y < 2)
+      m = 1;
+    else if (y >= 2 && y < 5)
+      m = 2;
+    else if (y >= 5)
+      m = 5;
+
+    PLFLT intv = (PLFLT) (m * pow(10.,static_cast<double>(n)));
+    return intv;
+  }
+
+
+  PLFLT AutoIntv(DDouble x)
+  {
+    if( x == 0.0) {
+      //      cout << "zero"<<endl;
+      return 1.0;
+    }
+
+    DLong n = static_cast<DLong>( floor(log10(x/2.82)));
+    DDouble y = (x / (2.82 * pow(10.,static_cast<double>(n))));
+    DLong m;
+    if (y >= 1 && y < 2)
+      m = 1;
+    else if (y >= 2 && y < 4.47)
+      m = 2;
+    else if (y >= 4.47)
+      m = 5;
+
+    //    cout << "AutoIntv" << x << " " << y << endl;
+
+    PLFLT intv = (PLFLT) (m * pow(10.,static_cast<double>(n)));
+    return intv;
+  }
+
+  //improved version of "AutoIntv" for:
+  // 1/ better managing ranges when all the data have same value
+  // 2/ mimic IDL behavior when data are all positive
+  // please notice that (val_min, val_max) will be changed
+  // and "epsilon" is a coefficient if "extended range" is expected
+  PLFLT AutoIntvAC(DDouble &val_min, DDouble &val_max, DLong NoZero, bool log)
+  {
+    PLFLT intv = 1.;
+    int cas = 0 ;
+    DDouble x;
+    bool debug = false ;
+    if (debug) {cout << "init: " <<  val_min << " " << val_max << endl;}
+
+    if (log)
+    {
+      if (val_min == 0 || val_max == 0) return intv;
+      val_min = log10(val_min);
+      val_max = log10(val_max);
+    }
+
+    // case "all below ABS((MACHAR()).xmin)
+    if ((abs(val_min) < 1e-38) && (abs(val_max) < 1e-38))
+      {
+	val_min=DDouble(-1.);
+	val_max=DDouble( 1.);
+	intv = (PLFLT) (2.);
+	cas = 1 ;
+      }
+
+    // case "all values are equal"
+    if (cas == 0)
+      {
+	x=val_max-val_min;
+	if (abs(x) < 1e-30) {
+	  DDouble val_ref;
+          val_ref=val_max;
+          if (0.98*val_min < val_ref) { // positive case
+            val_max=1.02*val_ref;
+            val_min=0.98*val_ref;
+          } else {     // negative case
+            val_max=0.98*val_ref;
+            val_min=1.02*val_ref;
+          }
+          if (debug) {cout << "Rescale : " << val_min << " " << val_max << endl;}
+	}
+      }
+
+    // case "all data positive, must start at Zero" (mimic IDL behavior)
+    if ((cas == 0) && (val_min >= 0.0) && (NoZero == 0))
+      {
+	cas = 2 ;
+	DDouble resu, val_norm ;
+	// we used redundant scale (1.,1.2 and 10., 12. to avoid roundoff problem in log10)
+	DDouble levels[12]={1.,1.2,1.5,2.,2.5,3.,4.,5.,6.,8.,10.,12.};
+	int nb_levels= 12;
+
+	DLong n = static_cast<DLong>( floor(log10(val_max)));
+	DDouble scale= pow(10.,static_cast<double>(n));
+
+	val_norm=val_max/scale;
+
+	resu=levels[0];
+	for (int c = 0; c < nb_levels; c++) {
+	  if ((val_norm > levels[c]) && (val_norm <= levels[c+1])) resu=levels[c+1] ;
+	}
+	val_min=0.0;
+	val_max=resu*scale;
+	intv = (PLFLT)(val_max);
+      }
+
+    // general case (only negative OR negative and positive)
+    if (cas == 0)
+      {
+	x=val_max-val_min;
+	intv = AutoIntv( x);
+	val_max = ceil(val_max/intv) * intv;
+	val_min = floor(val_min/intv) * intv;
+      }
+
+    if (debug) {cout << "cas: "<< cas << " new range: "<<  val_min << " " << val_max << endl;}
+
+    if (log)
+    {
+      val_min = pow(10, val_min);
+      val_max = pow(10, val_max);
+    }
+
+    return intv;
+  }
+
+  // !P
+  void GetPData( DLong& p_background,
+		 DLong& p_noErase, DLong& p_color, DLong& p_psym,
+		 DLong& p_linestyle,
+		 DFloat& p_symsize, DFloat& p_charsize, DFloat& p_thick,
+		 DString& p_title, DString& p_subTitle, DFloat& p_ticklen)
+  {
+    static DStructGDL* pStruct = SysVar::P();
+    static unsigned backgroundTag = pStruct->Desc()->TagIndex( "BACKGROUND");
+    static unsigned noEraseTag = pStruct->Desc()->TagIndex( "NOERASE");
+    static unsigned colorTag = pStruct->Desc()->TagIndex( "COLOR");
+    static unsigned psymTag = pStruct->Desc()->TagIndex( "PSYM");
+    static unsigned linestyleTag = pStruct->Desc()->TagIndex( "LINESTYLE");
+    static unsigned symsizeTag = pStruct->Desc()->TagIndex( "SYMSIZE");
+    static unsigned charsizeTag = pStruct->Desc()->TagIndex( "CHARSIZE");
+    static unsigned thickTag = pStruct->Desc()->TagIndex( "THICK");
+    static unsigned ticklenTag = pStruct->Desc()->TagIndex( "TICKLEN");
+    static unsigned titleTag = pStruct->Desc()->TagIndex( "TITLE");
+    static unsigned subTitleTag = pStruct->Desc()->TagIndex( "SUBTITLE");
+    p_background =
+      (*static_cast<DLongGDL*>( pStruct->GetTag( backgroundTag, 0)))[0];
+    p_noErase =
+      (*static_cast<DLongGDL*>( pStruct->GetTag( noEraseTag, 0)))[0];
+    p_color =
+      (*static_cast<DLongGDL*>( pStruct->GetTag( colorTag, 0)))[0];
+    p_psym =
+      (*static_cast<DLongGDL*>( pStruct->GetTag( psymTag, 0)))[0];
+    p_linestyle =
+      (*static_cast<DLongGDL*>( pStruct->GetTag( linestyleTag, 0)))[0];
+    p_symsize =
+      (*static_cast<DFloatGDL*>( pStruct->GetTag( symsizeTag, 0)))[0];
+    p_charsize =
+      (*static_cast<DFloatGDL*>( pStruct->GetTag( charsizeTag, 0)))[0];
+    p_thick =
+      (*static_cast<DFloatGDL*>( pStruct->GetTag( thickTag, 0)))[0];
+    p_title =
+      (*static_cast<DStringGDL*>( pStruct->GetTag( titleTag, 0)))[0];
+    p_subTitle =
+      (*static_cast<DStringGDL*>( pStruct->GetTag( subTitleTag, 0)))[0];
+    p_ticklen =
+      (*static_cast<DFloatGDL*>( pStruct->GetTag( ticklenTag, 0)))[0];
+  }
+
+  // !X, !Y, !Z
+  void GetAxisData( DStructGDL* xStruct,
+		    DLong& style, DString& title, DFloat& charSize,
+		    DFloat& margin0, DFloat& margin1, DFloat& ticklen)
+  {
+    static unsigned styleTag = xStruct->Desc()->TagIndex( "STYLE");
+    static unsigned marginTag = xStruct->Desc()->TagIndex( "MARGIN");
+    static unsigned axisTitleTag = xStruct->Desc()->TagIndex( "TITLE");
+    static unsigned axischarsizeTag = xStruct->Desc()->TagIndex( "CHARSIZE");
+    static unsigned ticklenTag = xStruct->Desc()->TagIndex( "TICKLEN");
+    style =
+      (*static_cast<DLongGDL*>( xStruct->GetTag( styleTag, 0)))[0];
+    title =
+      (*static_cast<DStringGDL*>( xStruct->GetTag( axisTitleTag, 0)))[0];
+    charSize =
+      (*static_cast<DFloatGDL*>( xStruct->GetTag( axischarsizeTag, 0)))[0];
+    margin0 =
+      (*static_cast<DFloatGDL*>( xStruct->GetTag( marginTag, 0)))[0];
+    margin1 =
+      (*static_cast<DFloatGDL*>( xStruct->GetTag( marginTag, 0)))[1];
+    ticklen =
+      (*static_cast<DFloatGDL*>( xStruct->GetTag( ticklenTag, 0)))[0];
+  }
+
+  void GetUserSymSize(EnvT *e,  GDLGStream *a, DDouble& UsymConvX, DDouble& UsymConvY)
+  {
+    DDouble *scaleX, *scaleY;
+    GetSFromPlotStructs(&scaleX, &scaleY);
+    // get subpage in mm
+    PLFLT scrXL, scrXR, scrYB, scrYT;
+    a->gspa( scrXL, scrXR, scrYB, scrYT);
+    PLFLT scrX = scrXR-scrXL;
+    PLFLT scrY = scrYT-scrYB;
+    // get char size in mm (default, actual)
+    PLFLT defH, actH;
+    a->gchr( defH, actH);
+    //get symsize
+    static DStructGDL* pStruct = SysVar::P();
+    DFloat symsize = (*static_cast<DFloatGDL*>
+		      (pStruct->GetTag( pStruct->Desc()->TagIndex("SYMSIZE"), 0)))[0];
+    e->AssureFloatScalarKWIfPresent( "SYMSIZE", symsize);
+    if( symsize <= 0.0) symsize = 1.0;
+    UsymConvX=0.5*symsize*(defH/scrX)/scaleX[1];
+    UsymConvY=0.5*symsize*(defH/scrY)/scaleY[1];
+
+  }
+
+  void AdjustAxisOpts(string& xOpt, string& yOpt,
+    DLong xStyle, DLong yStyle, DLong xTicks, DLong yTicks,
+    string& xTickformat, string& yTickformat, DLong xLog, DLong yLog
+  ) // {{{
+  {
+    if ((xStyle & 8) == 8) xOpt = "b";
+    if ((yStyle & 8) == 8) yOpt = "b";
+
+    if (xTicks == 1) xOpt += "t"; else xOpt += "st";
+    if (yTicks == 1) yOpt += "tv"; else yOpt += "stv";
+
+    if (xTickformat != "(A1)") xOpt += "n";
+    if (yTickformat != "(A1)") yOpt += "n";
+
+    if( xLog) xOpt += "l";
+    if( yLog) yOpt += "l";
+
+    if ((xStyle & 4) == 4) xOpt = "";
+    if ((yStyle & 4) == 4) yOpt = "";
+  } // }}}
+
+  void CheckMargin( EnvT* e, GDLGStream* actStream,
+		    DFloat xMarginL,
+		    DFloat xMarginR,
+		    DFloat yMarginB,
+		    DFloat yMarginT,
+		    PLFLT& xMR,
+		    PLFLT& xML,
+		    PLFLT& yMB,
+		    PLFLT& yMT)
+  {
+    // get subpage in mm
+    PLFLT scrXL, scrXR, scrYB, scrYT;
+    actStream->gspa( scrXL, scrXR, scrYB, scrYT);
+    PLFLT scrX = scrXR-scrXL;
+    PLFLT scrY = scrYT-scrYB;
+
+    // get char size in mm (default, actual)
+    PLFLT defH, actH;
+    actStream->gchr( defH, actH);
+
+    xML = xMarginL * actH / scrX;
+    xMR = xMarginR * actH / scrX;
+
+    // factor 1.111 by ACoulais on 16/12/2010. Consequences on CONVERT_COORD
+    const float yCharExtension = 1.5*1.11111;
+    yMB = yMarginB * actH / scrY * yCharExtension;
+    yMT = yMarginT * actH / scrY * yCharExtension;
+
+    if( xML+xMR >= 1.0)
+      {
+	Message( e->GetProName() + ": XMARGIN to large (adjusted).");
+	PLFLT xMMult = xML+xMR;
+	xML /= xMMult * 1.5;
+	xMR /= xMMult * 1.5;
+      }
+    if( yMB+yMT >= 1.0)
+      {
+	Message( e->GetProName() + ": YMARGIN to large (adjusted).");
+	PLFLT yMMult = yMB+yMT;
+	yMB /= yMMult * 1.5;
+	yMT /= yMMult * 1.5;
+      }
+  }
+ void Clipping( DDoubleGDL* clippingD,
+		 DDouble& xStart,
+		 DDouble& xEnd,
+		 DDouble& minVal,
+		 DDouble& maxVal)
+  { //do nothing, clipping should not be done thusly.
+  }
+ // temporary ignor clipping
+//  void Clipping( DDoubleGDL* clippingD,
+//		 DDouble& xStart,
+//		 DDouble& xEnd,
+//		 DDouble& minVal,
+//		 DDouble& maxVal)
+//  {
+//    SizeT cEl=clippingD->N_Elements();
+//
+//    // world coordinates
+//    DDouble wcxs, wcxe,wcys, wcye;
+//
+//    if(cEl >= 1) wcxs=(*clippingD)[0]; else wcxs=0;
+//    if(cEl >= 2) wcys=(*clippingD)[1]; else wcys=0;
+//    if(cEl >= 3) wcxe=(*clippingD)[2]; else wcxe=wcxs;
+//    if(cEl >= 4) wcye=(*clippingD)[3]; else wcye=wcys;
+//
+//    if(wcxe < wcxs ) wcxe=wcxs;
+//    if(wcye < wcys ) wcye=wcys;
+//
+//    //     // viewport (0..1)
+//    //     DDouble cxs, cxe,cys, cye;
+//    //     cxs=(-xStart+wcxs)*(1-0)/(xEnd-xStart);
+//    //     cxe=(-xStart+wcxe)*(1-0)/(xEnd-xStart);
+//    //     cys=(-yStart+wcys)*(1-0)/(yEnd-yStart);
+//    //     cye=(-yStart+wcye)*(1-0)/(yEnd-yStart);
+//    //     actStream->vpor(cxs, cxe, cys, cye);
+//
+//    xStart=wcxs; xEnd=wcxe; minVal=wcys; maxVal=wcye;
+//  }
+
+  bool SetVP_WC( EnvT* e,
+		 GDLGStream* actStream,
+		 DFloatGDL* pos,
+		 DDoubleGDL* clippingD,
+		 bool xLog, bool yLog,
+		 DFloat xMarginL,
+		 DFloat xMarginR,
+		 DFloat yMarginB,
+		 DFloat yMarginT,
+		 // input/output
+		 DDouble xStart,
+		 DDouble xEnd,
+		 DDouble yStart,
+		 DDouble yEnd)
+  {
+    //    cout << "xStart " << xStart << "  xEnd "<<xEnd<<endl;
+    //    cout << "yStart " << yStart << "  yEnd "<<yEnd<<endl;
+
+
+    PLFLT xMR;
+    PLFLT xML;
+    PLFLT yMB;
+    PLFLT yMT;
+
+    CheckMargin( e, actStream,
+		 xMarginL,
+		 xMarginR,
+		 yMarginB,
+		 yMarginT,
+		 xMR, xML, yMB, yMT);
+
+    // viewport - POSITION overrides
+    static bool kwP;
+    static PLFLT positionP[ 4]={0,0,0,0};
+    static PLFLT position[ 4];
+    DStructGDL* pStruct = SysVar::P();
+
+    // Get !P.position values
+    if(pStruct != NULL) {
+      static unsigned positionTag = pStruct->Desc()->TagIndex( "POSITION");
+      for( SizeT i=0; i<4; ++i)
+	positionP[i] = (PLFLT)
+	  (*static_cast<DFloatGDL*>(pStruct->GetTag( positionTag, 0)))[i];
+    }
+
+    // If pos == NULL (oplot)
+
+  if (pos == NULL)
+  {
+
+    // If position keyword previously set
+    if (kwP)
+    {
+      actStream->vpor(position[0], position[2], position[1], position[3]);
+    }
+    else
+    {
+      // If !P.position not set
+      if (positionP[0] == 0 && positionP[1] == 0 &&
+          positionP[2] == 0 && positionP[3] == 0)
+        actStream->vpor(position[0], position[2], position[1], position[3]);
+      else
+      {
+        // !P.position set
+        actStream->vpor(positionP[0], positionP[2], positionP[1], positionP[3]);
+      }
+    }
+    // New plot
+  }
+  else if (pos == (DFloatGDL*) 0xF)
+  {
+    kwP = false;
+
+    // If !P.position not set use default values
+    if (positionP[0] == 0 && positionP[1] == 0 &&
+        positionP[2] == 0 && positionP[3] == 0)
+    {
+
+      // Set to default values
+      position[0] = xML;
+      position[1] = yMB;
+      position[2] = 1.0 - xMR;
+      position[3] = 1.0 - yMT;
+      actStream->vpor(position[0], position[2], position[1], position[3]);
+    }
+    else
+    {
+      // !P.position values
+      actStream->vpor(positionP[0], positionP[2], positionP[1], positionP[3]);
+    }
+    // Position keyword set
+  }
+  else
+  {
+    kwP = true;
+    for (SizeT i = 0; i < 4 && i < pos->N_Elements(); ++i)
+      position[ i] = (*pos)[ i];
+    actStream->vpor(position[0], position[2], position[1], position[3]);
+  }
+
+
+    // CLIPPING
+    if( clippingD != NULL)
+	Clipping( clippingD, xStart, xEnd, yStart, yEnd);
+
+    // for OPLOT start and end values are already log
+    // SA: changing only local variables!
+    if( pos != NULL)
+      {
+	if( xLog) //normally xStart at this point should never be <=0!
+	  {
+	    if( xStart <= 0.0) xStart = -12; else xStart = log10( xStart);
+	    if( xEnd   <= 0.0) return false; else xEnd = log10( xEnd);
+	  }
+	if( yLog) //normally yStart at this point should never be <=0!
+	  {
+	    if( yStart <= 0.0) yStart = -12; else yStart = log10( yStart);
+	    if( yEnd <= 0.0) return false; else yEnd = log10( yEnd);
+	  }
+      }
+//    cout << "VP wind: "<<xStart<<" "<<xEnd<<" "<<yStart<<" "<<yEnd<<endl;
+     //   printf("data lim (setv): %f %f %f %f\n", xStart, xEnd, yStart, yEnd);
+    // set world coordinates
+    actStream->wind( xStart, xEnd, yStart, yEnd);
+//       cout << "xStart " << xStart << "  xEnd "<<xEnd<<endl;
+//        cout << "yStart " << yStart << "  yEnd "<<yEnd<<endl;
+
+   return true;
+  }
+
+  void UpdateSWPlotStructs(GDLGStream* actStream, DDouble xStart, DDouble xEnd, DDouble yStart, DDouble yEnd, bool xLog, bool yLog)
+  {
+    // Get viewpoint parameters and store in WINDOW & S
+    PLFLT p_xmin, p_xmax, p_ymin, p_ymax;
+    actStream->gvpd (p_xmin, p_xmax, p_ymin, p_ymax);
+
+    DStructGDL* Struct = NULL;
+    if (xLog) xStart=log10(xStart);
+    if (xLog) xEnd=log10(xEnd);
+    if (yLog) yStart=log10(yStart);
+    if (yLog) yEnd=log10(yEnd);
+
+    Struct = SysVar::X();
+    static unsigned windowTag = Struct->Desc()->TagIndex( "WINDOW");
+    static unsigned sTag = Struct->Desc()->TagIndex( "S");
+    if (Struct != NULL)
+    {
+      (*static_cast<DFloatGDL*>( Struct->GetTag( windowTag, 0)))[0] = p_xmin;
+      (*static_cast<DFloatGDL*>( Struct->GetTag( windowTag, 0)))[1] = p_xmax;
+
+      (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[0] =
+        (p_xmin*xEnd - p_xmax*xStart) / (xEnd - xStart);
+      (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[1] =
+        (p_xmax - p_xmin) / (xEnd - xStart);
+    }
+
+    Struct = SysVar::Y();
+    if(Struct != NULL)
+    {
+      (*static_cast<DFloatGDL*>( Struct->GetTag( windowTag, 0)))[0] = p_ymin;
+      (*static_cast<DFloatGDL*>( Struct->GetTag( windowTag, 0)))[1] = p_ymax;
+
+      (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[0] =
+        (p_ymin*yEnd - p_ymax*yStart) / (yEnd - yStart);
+      (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[1] =
+        (p_ymax - p_ymin) / (yEnd - yStart);
+    }
+  }
+
+  void GetSFromPlotStructs(DDouble **sx, DDouble **sy)
+  {
+    static DStructGDL* xStruct = SysVar::X();
+    static DStructGDL* yStruct = SysVar::Y();
+    unsigned sxTag = xStruct->Desc()->TagIndex( "S");
+    unsigned syTag = yStruct->Desc()->TagIndex( "S");
+    *sx = &(*static_cast<DDoubleGDL*>( xStruct->GetTag( sxTag, 0)))[0];
+    *sy = &(*static_cast<DDoubleGDL*>( yStruct->GetTag( syTag, 0)))[0];
+  }
+
+  void GetWFromPlotStructs(DFloat **wx, DFloat **wy)
+  {
+    static DStructGDL* xStruct = SysVar::X();
+    static DStructGDL* yStruct = SysVar::Y();
+    unsigned xwindowTag = xStruct->Desc()->TagIndex( "WINDOW");
+    unsigned ywindowTag = yStruct->Desc()->TagIndex( "WINDOW");
+    *wx = &(*static_cast<DFloatGDL*>( xStruct->GetTag( xwindowTag, 0)))[0];
+    *wy = &(*static_cast<DFloatGDL*>( yStruct->GetTag( ywindowTag, 0)))[0];
+  }
+
+  void GetUsym(DLong **n, DInt **do_fill, DFloat **x, DFloat **y)
+  {
+    static DStructGDL* usymStruct = SysVar::USYM();
+    unsigned nTag = usymStruct->Desc()->TagIndex( "DIM");
+    unsigned fillTag = usymStruct->Desc()->TagIndex( "FILL");
+    unsigned xTag = usymStruct->Desc()->TagIndex( "X");
+    unsigned yTag = usymStruct->Desc()->TagIndex( "Y");
+
+    *n = &(*static_cast<DLongGDL*>( usymStruct->GetTag( nTag, 0)))[0];
+    *do_fill = &(*static_cast<DIntGDL*>( usymStruct->GetTag( fillTag, 0)))[0];
+    *x = &(*static_cast<DFloatGDL*>( usymStruct->GetTag( xTag, 0)))[0];
+    *y = &(*static_cast<DFloatGDL*>( usymStruct->GetTag( yTag, 0)))[0];
+  }
+
+  void SetUsym(DLong n, DInt do_fill, DFloat *x, DFloat *y)
+  {
+    static DStructGDL* usymStruct = SysVar::USYM();
+    unsigned xTag = usymStruct->Desc()->TagIndex( "X");
+    unsigned yTag = usymStruct->Desc()->TagIndex( "Y");
+    unsigned nTag = usymStruct->Desc()->TagIndex( "DIM");
+    unsigned fillTag = usymStruct->Desc()->TagIndex( "FILL");
+
+    (*static_cast<DLongGDL*>( usymStruct->GetTag( nTag, 0)))[0] = n;
+    (*static_cast<DIntGDL*>( usymStruct->GetTag( fillTag, 0)))[0] = do_fill;
+
+     for (int i=0; i<n; i++)
+     {
+        (*static_cast<DFloatGDL*>( usymStruct->GetTag( xTag, 0)))[i] = x[i];
+        (*static_cast<DFloatGDL*>( usymStruct->GetTag( yTag, 0)))[i] = y[i];
+     }
+   }
+
+  void DataCoordLimits(DDouble *sx, DDouble *sy, DFloat *wx, DFloat *wy,
+    DDouble *xStart, DDouble *xEnd, DDouble *yStart, DDouble *yEnd, bool clip_by_default)
+  {
+    *xStart = (wx[0] - sx[0]) / sx[1];
+    *xEnd   = (wx[1] - sx[0]) / sx[1];
+    *yStart = (wy[0] - sy[0]) / sy[1];
+    *yEnd   = (wy[1] - sy[0]) / sy[1];
+    //   cout << *xStart <<" "<< *xEnd << " "<< *yStart <<" "<< *yEnd << ""<< endl;
+
+    // patch from Joanna (tracker item no. 3029409, see test_clip.pro)
+    if (!clip_by_default) {
+      //      cout << "joanna" << endl;
+      DFloat wxlen = wx[1] - wx[0];
+      DFloat wylen = wy[1] - wy[0];
+      DFloat xlen = *xEnd - *xStart;
+      DFloat ylen = *yEnd - *yStart;
+      *xStart = *xStart - xlen/wxlen * wx[0];
+      *xEnd = *xEnd + xlen/wxlen * (1 - wx[1]);
+      *yStart = *yStart - ylen/wylen * wy[0];
+      *yEnd = *yEnd + ylen/wylen * (1 - wy[1]);
+    }
+    //    cout << *xStart <<" "<< *xEnd << " "<< *yStart <<" "<< *yEnd << ""<< endl;
+  }
+
+
+  void ac_histo(GDLGStream *a, int i_buff, PLFLT *x_buff, PLFLT *y_buff, bool xLog )
+  {
+    PLFLT x,x1,y,y1,val;
+    for ( int jj=1; jj<i_buff; ++jj)
+    {
+      x1=x_buff[jj-1];
+      x=x_buff[jj];
+      y1=y_buff[jj-1];
+      y=y_buff[jj];
+      if (xLog) val=(x1+x)/2.0;
+      else val=log10((pow(10.0,x1)+pow(10.0,x))/2.0);
+      a->join(x1,y1,val,y1);
+      a->join(val,y1,val,y);
+      a->join(val,y,x,y);
+    }
+  }
+
+  void getNormalizedCoordinatesFromPLPLOT(GDLGStream *a, DDouble wx, DDouble wy, DDouble *nx, DDouble *ny)
+  {
+    // from current values derive the relative coordinates in the sense of plplot
+    DDouble s1,s2;
+    PLFLT nxmin,nxmax,nymin,nymax,wxmin,wxmax,wymin,wymax;
+    a->gvpd(nxmin,nxmax,nymin,nymax);//norm of current box
+    a->gvpw(wxmin,wxmax,wymin,wymax);
+//   fprintf(stderr,"World: x=[%lf,%lf] y=[%lf,%lf] Norm: x=[%lf,%lf] y=[%lf,%lf]\n",wxmin,wxmax,wymin,wymax,nxmin,nxmax,nymin,nymax);
+    s1=(nxmax-nxmin)/(wxmax-wxmin);
+    s2=nxmin;
+    *nx=s1*(wx-wxmin)+s2;
+    s1=(nymax-nymin)/(wymax-wymin);
+    s2=nymin;
+    *ny=s1*(wy-wymin)+s2;
+  }
+  void getWorldCoordinatesFromPLPLOT(GDLGStream *a, DDouble nx, DDouble ny, DDouble *wx, DDouble *wy)
+  {
+    // from current values derive the world coordinates in the sense of plplot
+    DDouble s1,s2;
+    PLFLT nxmin,nxmax,nymin,nymax,wxmin,wxmax,wymin,wymax;
+    a->gvpd(nxmin,nxmax,nymin,nymax); //norm of current box
+    a->gvpw(wxmin,wxmax,wymin,wymax); //world of current box
+//   fprintf(stderr,"World: x=[%lf,%lf] y=[%lf,%lf] Norm: x=[%lf,%lf] y=[%lf,%lf]\n",wxmin,wxmax,wymin,wymax,nxmin,nxmax,nymin,nymax);
+    s1=(wxmax-wxmin)/(nxmax-nxmin);
+    s2=wxmin;
+    *wx=s1*(nx-nxmin)+s2;
+    s1=(wymax-wymin)/(nymax-nymin);
+    s2=wymin;
+    *wy=s1*(ny-nymin)+s2;
+ }
+
+ static DDouble savedPointX=0.0;
+ static DDouble savedPointY=0.0;
+ void saveLastPoint(GDLGStream *a, DDouble wx, DDouble wy)
+  {
+   DDouble nx;
+   DDouble ny;
+   getNormalizedCoordinatesFromPLPLOT(a, wx, wy, &savedPointX, &savedPointY);
+//   fprintf(stderr,"Saved norm: %lf %lf\n",savedPointX,savedPointY);
+  }
+  void getLastPoint(GDLGStream *a, DDouble* wx, DDouble* wy)
+  {
+   getWorldCoordinatesFromPLPLOT(a, savedPointX, savedPointY , wx, wy);
+//   fprintf(stderr,"Got norm: %lf %lf giving %lf %lf world\n", savedPointX, savedPointY, *wx, *wy);
+  }
+  //CORE PLOT FUNCTION -> Draws a line along xVal, yVal
+
+  template <typename T> bool draw_polyline(EnvT *e, GDLGStream *a,
+  T * xVal, T* yVal,
+  DDouble minVal, DDouble maxVal, bool doMinMax,
+  bool xLog, bool yLog,
+  DLong psym, bool append){
+    bool line = false;
+    bool valid = true;
+    DLong psym_ = 0;
+
+    if (psym < 0) {
+      line = true;
+      psym_ = -psym;
+    } else if (psym == 0) {
+      line = true;
+      psym_ = psym;
+    } else {
+      psym_ = psym;
+    }
+
+    //usersym
+    DFloat *userSymX, *userSymY;
+    DLong *userSymArrayDim;
+    DInt *do_fill;
+    if (psym_ == 8) {
+      GetUsym(&userSymArrayDim, &do_fill, &userSymX, &userSymY);
+      if (*userSymArrayDim == 0) {
+        e->Throw("No user symbol defined.");
+      }
+    }
+    DDouble UsymConvX, UsymConvY;
+    GetUserSymSize(e, a, UsymConvX, UsymConvY);
+
+    DLong minEl = (xVal->N_Elements() < yVal->N_Elements()) ?
+    xVal->N_Elements() : yVal->N_Elements();
+    // if scalar x
+    if (xVal->N_Elements() == 1 && xVal->Rank() == 0)
+      minEl = yVal->N_Elements();
+    // if scalar y
+    if (yVal->N_Elements() == 1 && yVal->Rank() == 0)
+      minEl = xVal->N_Elements();
+
+    bool mapSet = false;
+  #ifdef USE_LIBPROJ4
+    // Map Stuff (xtype = 3)
+    LPTYPE idata;
+    XYTYPE odata;
+
+    get_mapset(mapSet);
+
+    DDouble xStart, xEnd;
+    get_axis_crange("X", xStart, xEnd);
+
+    if (mapSet) {
+      ref = map_init();
+      if (ref == NULL) {
+        e->Throw("Projection initialization failed.");
+      }
+    }
+  #endif
+
+    // is one of the 2 "arrays" a singleton or not ?
+
+    PLFLT y, y1, yMapBefore, y_ref;
+    int flag_y_const = 0;
+    y_ref = static_cast<PLFLT>((*yVal)[0]);
+    if (yVal->N_Elements() == 1 && yVal->Rank() == 0) flag_y_const = 1;
+
+    PLFLT x, x1, xMapBefore, x_ref;
+    int flag_x_const = 0;
+    x_ref = static_cast<PLFLT>((*xVal)[0]);
+    if (xVal->N_Elements() == 1 && xVal->Rank() == 0) flag_x_const = 1;
+
+    // AC 070601 we use a buffer to use the fast ->line method
+    // instead of the slow ->join one.
+    // 2 tricks:
+    // trick 1/ size of buffer is limited to 1e4 (compromize syze/speed) in order to be able to manage very
+    //    large among of data whitout duplicating all the arrays
+    // trick 2/ when we have a NaN or and Inf, we realize the plot, then reset.
+
+    int debug_ac = 0;
+
+    int n_buff_max = 500000; // idl default seems to be more than 2e6 !!
+
+    if (minEl < n_buff_max) n_buff_max = append ? minEl + 1 : minEl;
+    int i_buff = 0;
+    PLFLT *x_buff = new PLFLT[n_buff_max];
+    PLFLT *y_buff = new PLFLT[n_buff_max];
+
+    // flag to reset Buffer when a NaN or a Infinity are founded
+    int reset = 0;
+
+    // translation plplot symbols - 8th symbol is superseded by USERSYM.
+    const PLINT codeArr[] = {0, 2, 3, 1, 11, 7, 6, 5, 4};
+    bool isBad = FALSE;
+    for (int i = 0; i < minEl; ++i) {
+      isBad = FALSE;
+      if (append) //start with the old point
+      {
+        getLastPoint(a, &x, &y);
+        i--; //to get good counter afterwards
+        append = FALSE; //and stop appending after!
+        if (xLog) x = pow(10, x);
+        if (yLog) y = pow(10, y);
+      } else {
+        if (!flag_x_const) x = static_cast<PLFLT>((*xVal)[i]);
+        else x = x_ref;
+        if (!flag_y_const) y = static_cast<PLFLT>((*yVal)[i]);
+        else y = y_ref;
+      }
+  #ifdef USE_LIBPROJ4
+      if (mapSet && !e->KeywordSet("NORMAL")) {
+        idata.lam = x * DEG_TO_RAD;
+        idata.phi = y * DEG_TO_RAD;
+        if (i > 0) {
+          xMapBefore = odata.x;
+          yMapBefore = odata.y;
+        }
+        odata = PJ_FWD(idata, ref);
+        x = odata.x;
+        y = odata.y;
+      }
+  #endif
+      isBad = (!isfinite(x) || !isfinite(y) || isnan(x) || isnan(y));
+      if (doMinMax) isBad = (isBad || (y < minVal) || (y > maxVal));
+      if (isBad) {
+        reset = 1;
+        if (i_buff > 0) {
+          if (line) {
+            a->line(i_buff, x_buff, y_buff);
+          }
+          if ((psym_ > 0 && psym_ < 8) || psym_ == 9) {
+            a->poin(i_buff, x_buff, y_buff, codeArr[psym_]);
+          }
+          if (psym_ == 8) {
+            PLFLT *xx = new PLFLT[*userSymArrayDim];
+            PLFLT *yy = new PLFLT[*userSymArrayDim];
+            for (int j = 0; j < i_buff; ++j) {
+              if (debug_ac) {
+                cout << "j: " << j << ", X: " << x_buff[j] << ", Y: " << y_buff[j] << endl;
+              };
+              for (int kk = 0; kk < *userSymArrayDim; kk++) {
+                xx[kk] = x_buff[j] + userSymX[kk] * UsymConvX;
+                yy[kk] = y_buff[j] + userSymY[kk] * UsymConvY;
+              }
+              if (*do_fill == 1) {
+                a->fill(*userSymArrayDim, xx, yy);
+              } else {
+                a->line(*userSymArrayDim, xx, yy);
+              }
+            }
+          }
+          if (psym_ == 10) {
+            ac_histo(a, i_buff, x_buff, y_buff, xLog);
+          }
+          i_buff = 0;
+        }
+        continue;
+      }
+
+  #ifdef USE_LIBPROJ4
+      if (mapSet && !e->KeywordSet("NORMAL")) {
+        if (i > 0) //;&& (i_buff >0))
+        {
+          x1 = xMapBefore;
+          if (!isfinite(xMapBefore) || !isfinite(yMapBefore)) continue;
+
+          // Break "jumps" across maps (kludge!)
+          if (fabs(x - x1) > 0.5 * (xEnd - xStart)) {
+            reset = 1;
+            if ((i_buff > 0) && (line)) {
+              a->line(i_buff, x_buff, y_buff);
+              //		  x_buff[0]=x_buff[i_buff-1];
+              //y_buff[0]=y_buff[i_buff-1];
+              i_buff = 0;
+            }
+            continue;
+          }
+        }
+      }
+  #endif
+      //note: here y is in minVal maxVal
+      if (xLog) if (x <= 0.0) continue;
+        else x = log10(x);
+      if (yLog) if (y <= 0.0) continue;
+        else y = log10(y);
+
+      x_buff[i_buff] = x;
+      y_buff[i_buff] = y;
+      i_buff = i_buff + 1;
+
+      //	cout << "nbuf: " << i << " " << i_buff << " "<< n_buff_max-1 << " " << minEl-1 << endl;
+
+      if ((i_buff == n_buff_max) || ((i == minEl - 1) && !append) || ((i == minEl) && append)) {
+        if (line) {
+          a->line(i_buff, x_buff, y_buff);
+        };
+        if ((psym_ > 0 && psym_ < 8) || psym_ == 9) {
+          a->poin(i_buff, x_buff, y_buff, codeArr[psym_]);
+        }
+        if (psym_ == 8) {
+          PLFLT *xx = new PLFLT[*userSymArrayDim];
+          PLFLT *yy = new PLFLT[*userSymArrayDim];
+          for (int j = 0; j < i_buff; ++j) {
+            if (debug_ac) {
+              cout << "j: " << j << ", X: " << x_buff[j] << ", Y: " << y_buff[j] << endl;
+            };
+            for (int kk = 0; kk < *userSymArrayDim; kk++) {
+              xx[kk] = x_buff[j] + userSymX[kk] * UsymConvX;
+              yy[kk] = y_buff[j] + userSymY[kk] * UsymConvY;
+            }
+            if (*do_fill == 1) {
+              a->fill(*userSymArrayDim, xx, yy);
+              //to be tested: provided we define a 'non-gradient' gradient before this should work
+              //                a->gradient(*userSymArrayDim,xx,yy,0.0);
+            } else {
+              a->line(*userSymArrayDim, xx, yy);
+            }
+          }
+        }
+        if (psym_ == 10) {
+          ac_histo(a, i_buff, x_buff, y_buff, xLog);
+        }
+
+        // we must recopy the last point since the line must continue (tested via small buffer ...)
+        x_buff[0] = x_buff[i_buff - 1];
+        y_buff[0] = y_buff[i_buff - 1];
+        i_buff = 1;
+      }
+    }
+
+    delete[] x_buff;
+    delete[] y_buff;
+    //save last point
+    saveLastPoint(a, x, y);
+    return (valid);
+  }
+  // explicit instantiation for SpDDouble
+  template bool draw_polyline(EnvT*, GDLGStream*, Data_<SpDDouble>*, Data_<SpDDouble>*, DDouble, DDouble, bool, bool, bool, DLong, bool);
+
+  //[XYZ]MARGIN kw decoding
+  void gkw_axis_margin(EnvT *e, string axis,DFloat &start, DFloat &end)
+  {
+    DStructGDL* Struct;
+    if(axis=="X") Struct = SysVar::X();
+    if(axis=="Y") Struct = SysVar::Y();
+
+    if(Struct != NULL)
+      {
+	static unsigned marginTag = Struct->Desc()->TagIndex( "MARGIN");
+	start =
+	  (*static_cast<DFloatGDL*>( Struct->GetTag( marginTag, 0)))[0];
+	end =
+	  (*static_cast<DFloatGDL*>( Struct->GetTag( marginTag, 0)))[1];
+      }
+
+    string MarginName=axis+"MARGIN";
+    BaseGDL* Margin=e->GetKW(e->KeywordIx(MarginName));
+    if(Margin !=NULL)
+      {
+	if(Margin->N_Elements() > 2)
+	  e->Throw("Keyword array parameter "+MarginName+
+		   " must have from 1 to 2 elements.");
+	auto_ptr<DFloatGDL> guard;
+	DFloatGDL* MarginF = static_cast<DFloatGDL*>
+	  ( Margin->Convert2( FLOAT, BaseGDL::COPY));
+	guard.reset( MarginF);
+	start = (*MarginF)[0];
+	if( MarginF->N_Elements() > 1)
+	  end = (*MarginF)[1];
+      }
+  }
+
+  //BACKGROUND COLOR
+  void gkw_background(EnvT *e, GDLGStream *a, bool kw)
+  {
+    static DStructGDL* pStruct = SysVar::P();
+    DLong background =
+      (*static_cast<DLongGDL*>
+       (pStruct->GetTag( pStruct->Desc()->TagIndex("BACKGROUND"), 0)))[0];
+    if(kw)
+      e->AssureLongScalarKWIfPresent( "BACKGROUND", background);
+
+    // Get decomposed value
+    Graphics* actDevice = Graphics::GetDevice();
+    DLong decomposed = actDevice->GetDecomposed();
+    if (decomposed != 0 && decomposed != 1) {decomposed=0;}
+
+    a->Background( background, decomposed);
+  }
+
+  //COLOR
+  void gkw_color(EnvT *e, GDLGStream *a)
+  {
+    // Get COLOR from PLOT system variable
+    static DStructGDL* pStruct = SysVar::P();
+    DLong color =
+      (*static_cast<DLongGDL*>
+       (pStruct->GetTag( pStruct->Desc()->TagIndex("COLOR"), 0)))[0];
+
+    // Get # of colors from DEVICE system variable
+    DVar *var=FindInVarList(sysVarList,"D");
+    DStructGDL* s = static_cast<DStructGDL*>( var->Data());
+    DLong ncolor = (*static_cast<DLongGDL*>
+                    (s->GetTag(s->Desc()->TagIndex("N_COLORS"), 0)))[0];
+
+    if (ncolor > 256 && color == 255) color = ncolor - 1;
+
+    e->AssureLongScalarKWIfPresent( "COLOR", color);
+
+    // Get decomposed value
+    Graphics* actDevice = Graphics::GetDevice();
+    DLong decomposed = actDevice->GetDecomposed();
+    if (decomposed != 0 && decomposed != 1) {decomposed=0;}
+    a->Color( color, decomposed, 2);
+  }
+
+  // helper for NOERASE (but also used in XYOUTS)
+  void handle_pmulti_position(EnvT *e, GDLGStream *a)
+  {
+    // !P.MULTI is ignored if POSITION kw or !P.POSITION or !P.REGION is specified
+    // TODO: !P.REGION!
+
+    DFloatGDL* pos = NULL;
+
+    // system variable
+    static DStructGDL* pStruct = SysVar::P();
+    pos = static_cast<DFloatGDL*>(pStruct-> GetTag( pStruct->Desc()->TagIndex("POSITION"), 0));
+    if ((*pos)[0] == (*pos)[2]) pos = NULL;
+
+    // keyword
+    if (pos == NULL)
+    {
+      DSub* pro = e->GetPro();
+      int positionIx = pro->FindKey( "POSITION");
+      if (positionIx != -1) pos = e->IfDefGetKWAs<DFloatGDL>( positionIx);
+    }
+
+    if (pos != NULL) a->NoSub();
+  }
+
+  //NOERASE
+  void gkw_noerase(EnvT *e,GDLGStream *a, bool noe)
+  {
+    DLong noErase=0;
+    DLongGDL* pMulti = SysVar::GetPMulti();
+    static DStructGDL* pStruct = SysVar::P();
+
+    if(!noe)
+      {
+	noErase = (*static_cast<DLongGDL*>
+		   ( pStruct->
+		     GetTag( pStruct->Desc()->TagIndex("NOERASE"), 0)))[0];
+	if(e->KeywordSet("NOERASE")) {
+	  noErase=1;
+	}
+      }
+    else
+      {
+	noErase=1;
+      }
+
+    a->NextPlot( !noErase);
+    handle_pmulti_position(e, a);
+  }
+
+  //PSYM
+  void gkw_psym(EnvT *e, DLong &psym)
+  {
+    static DStructGDL* pStruct = SysVar::P();
+    psym= (*static_cast<DLongGDL*>
+	   (pStruct->GetTag(pStruct->Desc()->TagIndex("PSYM"), 0)))[0];
+
+    e->AssureLongScalarKWIfPresent( "PSYM", psym);
+    if( psym > 10 || psym < -8 || psym == 9)
+      e->Throw(
+			  "PSYM (plotting symbol) out of range.");
+  }
+
+    //SYMSIZE
+  void gkw_symsize(EnvT *e, GDLGStream *a)
+  {
+    static DStructGDL* pStruct = SysVar::P();
+    DFloat symsize = (*static_cast<DFloatGDL*>
+		      (pStruct->GetTag( pStruct->Desc()->TagIndex("SYMSIZE"), 0)))[0];
+    e->AssureFloatScalarKWIfPresent( "SYMSIZE", symsize);
+    if( symsize <= 0.0) symsize = 1.0;
+    a->ssym(0.0, symsize);
+  }
+
+  //CHARSIZE
+  void gkw_charsize(EnvT *e, GDLGStream *a, DFloat &charsize, bool kw)
+  {
+    static DStructGDL* pStruct = SysVar::P();
+    charsize = (*static_cast<DFloatGDL*>
+			(pStruct->GetTag
+			 ( pStruct->Desc()->TagIndex("CHARSIZE"), 0)))[0];
+    if(kw)
+      e->AssureFloatScalarKWIfPresent( "CHARSIZE", charsize);
+
+    if( charsize <= 0.0) charsize = 1.0;
+    a->schr(0.0, charsize);
+  }
+  //OLD CHARSIZE (for xyouts only?)
+  void gkw_charsize_xyouts(EnvT *e, GDLGStream *a, DFloat &charsize)
+  {
+    static DStructGDL* pStruct = SysVar::P();
+    charsize = (*static_cast<DFloatGDL*>
+			(pStruct->GetTag
+			 ( pStruct->Desc()->TagIndex("CHARSIZE"), 0)))[0];
+    //imagine CHARSIZE & SIZE: we prefer CHARSIZE of course
+    if(e->KeywordSet("SIZE")) e->AssureFloatScalarKWIfPresent( "SIZE", charsize);
+    e->AssureFloatScalarKWIfPresent( "CHARSIZE", charsize);
+
+    if( charsize <= 0.0) charsize = 1.0;
+    a->schr(0.0, charsize);
+  }
+  //THICK
+  void gkw_thick(EnvT *e, GDLGStream *a)
+  {
+    static DStructGDL* pStruct = SysVar::P();
+    DFloat thick = (*static_cast<DFloatGDL*>
+		    (pStruct->GetTag( pStruct->Desc()->TagIndex("THICK"), 0)))[0];
+
+    e->AssureFloatScalarKWIfPresent( "THICK", thick);
+    if( thick <= 0.0) thick = 1.0;
+    a->wid( static_cast<PLINT>(floor( thick-0.5)));
+  }
+
+  //LINESTYLE
+  void gkw_linestyle(EnvT *e, GDLGStream *a)
+  {
+    static DStructGDL* pStruct = SysVar::P();
+    DLong linestyle=
+      (*static_cast<DLongGDL*>
+       (pStruct->GetTag( pStruct->Desc()->TagIndex("LINESTYLE"), 0)))[0];
+
+    // if the LINESTYLE keyword is present, the value will be change
+    DLong temp_linestyle=-1111;
+    e->AssureLongScalarKWIfPresent( "LINESTYLE",temp_linestyle);
+
+    bool debug=false;
+    if (debug) {
+      cout << "temp_linestyle " <<  temp_linestyle << endl;
+      cout << "     linestyle " <<  linestyle << endl;
+    }
+    if (temp_linestyle != -1111) {linestyle=temp_linestyle;}//+1;
+    if (linestyle < 0 ) {linestyle=0;}
+    if (linestyle > 5 ) {linestyle=5;}
+
+      // see
+      // file:///home/coulais/SoftsExternes/plplot-5.5.3/examples/c++/x09.cc
+      // file:///home/coulais/SoftsExternes/plplot-5.5.3/doc/docbook/src/plstyl.html
+
+    if (linestyle == 0) { // solid (continuous line)
+      static PLINT nbp=0;
+      a->styl(nbp, NULL, NULL);
+    }
+    if (linestyle == 1) { // dots
+      static PLINT nbp=1;
+      static PLINT mark[] = {75};
+      static PLINT space[] = {1500};
+      a->styl(nbp, mark, space);
+    }
+    if (linestyle == 2) { // dashed
+      static PLINT nbp=1;
+      static PLINT mark[] = {1500};
+      static PLINT space[] = {1500};
+      a->styl(nbp, mark, space);
+  }
+    if (linestyle == 3) { // dash dot
+      static PLINT nbp=2;
+      static PLINT mark[] = {1500,100};
+      static PLINT space[] = {1000,1000};
+      a->styl(nbp, mark, space);
+    }
+    if (linestyle == 4) { // dash dot dot
+      static PLINT nbp=4;
+      static PLINT mark[] = {1500,100,100,100};
+      static PLINT space[] = {1000,1000,1000,1000};
+      a->styl(nbp, mark, space);
+    }
+    if (linestyle == 5) { // long dash
+      static PLINT nbp=1;
+      static PLINT mark[] = {3000};
+      static PLINT space[] = {1500};
+      a->styl(nbp, mark, space);
+    }
+  }
+
+  //TITLE
+  void gkw_title(EnvT* e, GDLGStream *a, PLFLT ad)
+  {
+    DLong thick=0;
+    e->AssureLongScalarKWIfPresent("CHARTHICK",thick);
+    a->wid(thick);
+
+    static DStructGDL* pStruct = SysVar::P();
+    static unsigned titleTag = pStruct->Desc()->TagIndex( "TITLE");
+    static unsigned subTitleTag = pStruct->Desc()->TagIndex( "SUBTITLE");
+    DString title =
+      (*static_cast<DStringGDL*>( pStruct->GetTag( titleTag, 0)))[0];
+    DString subTitle =
+      (*static_cast<DStringGDL*>( pStruct->GetTag( subTitleTag, 0)))[0];
+    e->AssureStringScalarKWIfPresent( "TITLE", title);
+    e->AssureStringScalarKWIfPresent( "SUBTITLE", subTitle);
+
+    a->schr( 0.0, 1.25*ad);
+    a->mtex("t",1.25,0.5,0.5,title.c_str());
+    a->schr( 0.0, ad); // charsize is reset here
+    a->mtex("b",5.4,0.5,0.5,subTitle.c_str());
+    a->wid(0);
+  }
+
+  //crange to struct
+
+  void set_axis_crange(string axis, DDouble Start, DDouble End, bool log)
+  {
+    DStructGDL* Struct = NULL;
+    if (axis == "X") Struct = SysVar::X();
+    if (axis == "Y") Struct = SysVar::Y();
+    if (axis == "Z") Struct = SysVar::Z();
+    if (Struct != NULL)
+    {
+      int debug = 0;
+      if (debug) cout << "Set     :" << Start << " " << End << endl;
+
+      static unsigned crangeTag = Struct->Desc()->TagIndex("CRANGE");
+      if (log)
+      {
+        (*static_cast<DDoubleGDL*> (Struct->GetTag(crangeTag, 0)))[0] = log10(Start);
+        (*static_cast<DDoubleGDL*> (Struct->GetTag(crangeTag, 0)))[1] = log10(End);
+        if (debug) cout << "set log" << Start << " " << End << endl;
+      }
+      else
+      {
+        (*static_cast<DDoubleGDL*> (Struct->GetTag(crangeTag, 0)))[0] = Start;
+        (*static_cast<DDoubleGDL*> (Struct->GetTag(crangeTag, 0)))[1] = End;
+      }
+    }
+  }
+
+  //CRANGE from struct
+  void get_axis_crange(string axis, DDouble &Start, DDouble &End)
+  {
+    DStructGDL* Struct=NULL;
+    if(axis=="X") Struct = SysVar::X();
+    if(axis=="Y") Struct = SysVar::Y();
+    if(axis=="Z") Struct = SysVar::Z();
+    if(Struct!=NULL)
+    {
+	int debug=0;
+	if (debug) cout << "Get     :" << Start << " " << End << endl;
+
+	static unsigned crangeTag = Struct->Desc()->TagIndex( "CRANGE");
+	Start = (*static_cast<DDoubleGDL*>( Struct->GetTag( crangeTag, 0)))[0];
+	End = (*static_cast<DDoubleGDL*>( Struct->GetTag( crangeTag, 0)))[1];
+
+	static unsigned typeTag = Struct->Desc()->TagIndex( "TYPE");
+	if ((*static_cast<DLongGDL*>(Struct->GetTag( typeTag, 0)))[0] == 1)
+	  {
+	    Start=pow(10.,Start);
+	    End=pow(10.,End);
+	    if (debug) cout << "Get log :" << Start << " " << End << endl;
+	  }
+    }
+  }
+
+   void get_axis_type(string axis,bool &log)
+  {
+    DStructGDL* Struct;
+    if(axis=="X") Struct = SysVar::X();
+    if(axis=="Y") Struct = SysVar::Y();
+    if(axis=="Z") Struct = SysVar::Z();
+    if(Struct != NULL) {
+      static unsigned typeTag = Struct->Desc()->TagIndex( "TYPE");
+      if ((*static_cast<DLongGDL*>(Struct->GetTag( typeTag, 0)))[0] == 1)
+	log = 1;
+      else
+	log=0;
+    }
+  }
+
+  void get_mapset(bool &mapset)
+  {
+    DStructGDL* Struct = SysVar::X();
+    if(Struct != NULL) {
+      static unsigned typeTag = Struct->Desc()->TagIndex( "TYPE");
+
+      if ((*static_cast<DLongGDL*>(Struct->GetTag( typeTag, 0)))[0] == 3)
+	mapset = 1;
+      else
+	mapset = 0;
+    }
+  }
+
+  void set_mapset(bool mapset)
+  {
+    DStructGDL* Struct = SysVar::X();
+    if(Struct!=NULL)
+      {
+	static unsigned typeTag = Struct->Desc()->TagIndex( "TYPE");
+	(*static_cast<DLongGDL*>( Struct->GetTag( typeTag, 0)))[0] = mapset;
+      }
+  }
+
+
+  //axis type (log..)
+  void set_axis_type(string axis, bool Type)
+  {
+    DStructGDL* Struct=NULL;
+    if(axis=="X") Struct = SysVar::X();
+    if(axis=="Y") Struct = SysVar::Y();
+    if(axis=="Z") Struct = SysVar::Z();
+    if(Struct!=NULL)
+      {
+	static unsigned typeTag = Struct->Desc()->TagIndex("TYPE");
+	(*static_cast<DLongGDL*>(Struct->GetTag(typeTag, 0)))[0] = Type;
+      }
+  }
+
+  void gkw_axis_charsize(EnvT* e, string axis, DFloat &charsize)
+  {
+    DStructGDL* Struct;
+    if(axis=="X") Struct = SysVar::X();
+    if(axis=="Y") Struct = SysVar::Y();
+
+    if(Struct != NULL)
+      {
+	static unsigned charsizeTag = Struct->Desc()->TagIndex("CHARSIZE");
+	charsize =
+	  (*static_cast<DFloatGDL*>( Struct->GetTag( charsizeTag, 0)))[0];
+      }
+
+    string Charsize_s=axis+"CHARSIZE";
+    e->AssureFloatScalarKWIfPresent( Charsize_s, charsize);
+    if(charsize <=0.0) charsize=1.0;
+  }
+
+
+  //STYLE
+  void gkw_axis_style(EnvT *e, string axis, DLong &style)
+  {
+    DStructGDL* Struct;
+    if(axis=="X") Struct = SysVar::X();
+    if(axis=="Y") Struct = SysVar::Y();
+    if(Struct != NULL)
+      {
+	static unsigned styleTag = Struct->Desc()->TagIndex( "STYLE");
+	style =
+	  (*static_cast<DLongGDL*>( Struct->GetTag( styleTag, 0)))[0];
+      }
+
+    string StyleName=axis+"STYLE";
+
+  }
+
+  void gkw_axis_title(EnvT *e, string axis, DString &title)
+  {
+    DStructGDL* Struct;
+    if(axis=="X") Struct = SysVar::X();
+    if(axis=="Y") Struct = SysVar::Y();
+
+    if(Struct != NULL)
+      {
+	static unsigned titleTag = Struct->Desc()->TagIndex("TITLE");
+	title =
+	  (*static_cast<DStringGDL*>( Struct->GetTag( titleTag, 0)))[0];
+      }
+
+    string TitleName=axis+"TITLE";
+    e->AssureStringScalarKWIfPresent( TitleName, title);
+
+  }
+
+  //GET RANGE
+
+  void gkw_axis_range(EnvT *e, string axis, DDouble &start, DDouble &end,
+                      DLong &ynozero)
+  {
+    DStructGDL* Struct;
+    if (axis == "X") Struct = SysVar::X();
+    if (axis == "Y") Struct = SysVar::Y();
+    if (Struct != NULL)
+    {
+      DDouble test1, test2;
+      static unsigned rangeTag = Struct->Desc()->TagIndex("RANGE");
+      test1 = (*static_cast<DDoubleGDL*> (Struct->GetTag(rangeTag, 0)))[0];
+      test2 = (*static_cast<DDoubleGDL*> (Struct->GetTag(rangeTag, 0)))[1];
+      if (!(test1 == 0.0 && test2 == 0.0))
+      {
+        start = test1;
+        end = test2;
+      }
+    }
+    string RangeName = axis + "RANGE";
+    BaseGDL* Range = e->GetKW(e->KeywordIx(RangeName));
+    if (Range != NULL)
+    {
+      if (Range->N_Elements() != 2)
+        e->Throw("Keyword array parameter " + RangeName +
+                 " must have 2 elements.");
+      auto_ptr<DDoubleGDL> guard;
+      DDoubleGDL* RangeF = static_cast<DDoubleGDL*>
+	(Range->Convert2(DOUBLE, BaseGDL::COPY));
+      guard.reset(RangeF);
+      start = (*RangeF)[0];
+      end = (*RangeF)[1];
+      if (axis == "Y") ynozero = 1;
+    }
+  }
+  //current value of margin of axis 'axis'
+  void get_axis_margin(string axis, DFloat &low, DFloat &high)
+  {
+    DStructGDL* Struct=NULL;
+    if(axis=="X") Struct = SysVar::X();
+    if(axis=="Y") Struct = SysVar::Y();
+    if(Struct!=NULL)
+      {
+	static unsigned marginTag = Struct->Desc()->TagIndex( "MARGIN");
+	low = (*static_cast<DFloatGDL*>( Struct->GetTag( marginTag, 0)))[0];
+	high = (*static_cast<DFloatGDL*>( Struct->GetTag( marginTag, 0)))[1];
+      }
+  }
+  void usersym(EnvT *e)
+{
+      DFloatGDL *xyVal, *xVal, *yVal;
+      auto_ptr<BaseGDL> p0_guard;
+      DLong n;
+      DInt do_fill;
+      DFloat *x, *y;
+      SizeT nParam = e->NParam();
+
+      if (nParam == 1) {
+ 	   BaseGDL* p0 = e->GetNumericArrayParDefined( 0)->Transpose( NULL); //hence [1024,2]
+
+	xyVal = static_cast<DFloatGDL*>
+	  (p0->Convert2( FLOAT, BaseGDL::COPY));
+	p0_guard.reset( p0); // delete upon exit
+
+	if(xyVal->Rank() != 2 || xyVal->Dim(1) != 2)
+          e->Throw(e->GetParString(0)+" must be a 2-dim array of type [2,N] in this context.");
+
+            if (xyVal->Dim(0) > 1024)
+            {
+                e->Throw("Max array size for USERSYM is 1024");
+            }
+            n = xyVal->Dim(0);
+            // array is in the good order for direct C assignement
+            x=&(*xyVal)[0];
+            y=&(*xyVal)[n];
+       } else {
+            xVal = e->GetParAs< DFloatGDL > (0);
+            if (xVal->Rank() != 1)
+                e->Throw(e->GetParString(0)+" must be a 1D array in this context: ");
+
+            yVal = e->GetParAs< DFloatGDL > (1);
+            if (yVal->Rank() != 1)
+                e->Throw("Expression must be a 1D array in this context: " + e->GetParString(1));
+
+            if (xVal->Dim(0)!= yVal->Dim(0))
+            {
+               e->Throw("Arrays must have same size ");
+            }
+
+            if (xVal->Dim(0) > 1024)
+            {
+                e->Throw("Max array size for USERSYM is 1024");
+            }
+            n = xVal->Dim(0);
+            x=&(*xVal)[0];
+            y=&(*yVal)[0];
+        }
+        do_fill=0;
+        if (e->KeywordSet("FILL")) {
+        do_fill=1;
+        }
+        SetUsym(n,do_fill, x, y);
+  }
+} // namespace
diff -ruN --exclude CVS gdl-0.9.2/src/plotting_cursor.cpp gdl/src/plotting_cursor.cpp
--- gdl-0.9.2/src/plotting_cursor.cpp	2011-06-28 06:53:58.000000000 -0600
+++ gdl/src/plotting_cursor.cpp	2012-01-26 17:01:33.000000000 -0700
@@ -20,207 +20,233 @@
 #include "math_utl.hpp"
 #define PLK_Escape            0x1B
 
-namespace lib {
+namespace lib{
 
-  using namespace std;
+using namespace std;
 
-  // get cursor from plPlot     AC February 2008
-  // known limitations : WAIT parameter and similar keywords not fully managed (wait, nowait ...)
+// get cursor from plPlot     AC February 2008
+// known limitations : WAIT parameter and similar keywords not fully managed (wait, nowait ...)
 
-  void cursor( EnvT* e)
+void cursor(EnvT* e){
+  Graphics* actDevice = Graphics::GetDevice();
+  //cout << actDevice->Name() << endl;
+  if (actDevice->Name() != "X")
   {
-    Graphics* actDevice = Graphics::GetDevice();
-    //cout << actDevice->Name() << endl;
-    if (actDevice->Name() != "X") {
-      e->Throw( "Routine is not defined for current graphics device.");
-    }
+    e->Throw("Routine is not defined for current graphics device.");
+  }
 
-    int debug=0;
-    SizeT nParam=e->NParam( 1); 
+  int debug = 0;
+  SizeT nParam = e->NParam(1);
 
-    if ( nParam < 2 || nParam > 3) 
-      {
-	e->Throw( "Incorrect number of arguments.");
-      }
+  if (nParam < 2 || nParam > 3)
+  {
+    e->Throw("Incorrect number of arguments.");
+  }
 
-    e->AssureGlobalPar( 0);
-    e->AssureGlobalPar( 1);
-    
-    GDLGStream *plg = actDevice->GetStream();
-    if (plg == NULL) e->Throw("Unable to create window.");
-
-    static PLGraphicsIn gin;
-
-    // content of : plGetCursor();
-    // [retval, state, keysym, button, string, pX, pY, dX, dY, wX, wY, subwin]
-    
-    PLINT plplot_level;
-    plg->glevel (plplot_level);   
-    if (debug) cout << "Plplot_level : " << plplot_level<< endl;
-    // when level < 2, we have to read if ![x|y].crange exist
-    // if not, we have to build a [0,1]/[0,1] window
-    if (plplot_level < 2) {
-      plg->NextPlot();
-
-      plg->vpor(0,1,0,1);
-      plg->wind(0,1,0,1);
-
-      /* we are not ready for the correct way (rebuilding a window following
-	 stored info)
-
-      // we have to read them back from !x.crange and !y.crange
-      PLFLT xStart, xEnd, yStart, yEnd;
-      get_axis_crange("X", xStart, xEnd);
-      get_axis_crange("Y", yStart, yEnd);
-      if ((xStart == xEnd ) || ( xEnd ==0.0)) {
-	xStart=0.0;
-	xEnd=1.0;
-      }
-      if ((yStart == yEnd ) || ( yEnd ==0.0)) {
-	yStart=0.0;
-	yEnd=1.0;
-      }
-      AC_debug("crange", xStart, xEnd, yStart, yEnd);
+  e->AssureGlobalPar(0);
+  e->AssureGlobalPar(1);
 
-      bool okVPWC = SetVP_WC( e, plg, NULL, NULL, 0, 0,
-			      xStart, xEnd, yStart, yEnd, false, false);
-      if( !okVPWC) return;
-      */
-    }
+  GDLGStream *plg = actDevice->GetStream();
+  if (plg == NULL) e->Throw("Unable to create window.");
 
-    DLong wait=1;
+  static PLGraphicsIn gin;
 
-    if (nParam == 3) {
-      e->AssureLongScalarPar( 2, wait);
-    }
+  // content of : plGetCursor();
+  // [retval, state, keysym, button, string, pX, pY, dX, dY, wX, wY, subwin]
+
+  PLINT plplot_level;
+  plg->glevel(plplot_level);
+  if (debug) cout << "Plplot_level : " << plplot_level << endl;
+  // when level < 2, we have to read if ![x|y].crange exist
+  // if not, we have to build a [0,1]/[0,1] window
+  if (plplot_level < 2)
+  {
+    plg->NextPlot();
 
-    if ((wait == 1) || (wait == 3) || (wait == 4) ||
-	e->KeywordSet("WAIT") ||
-	e->KeywordSet("DOWN") ||
-	e->KeywordSet("UP") ) {
-      //cout << "Sorry, this option is currently not *really* managed. Help welcome" << endl;
-      // we toggle to "wait == 1" (the mouse can move but we return if mouse is pressed)
-      wait=1;
-    }
+    plg->vpor(0, 1, 0, 1);
+    plg->wind(0, 1, 0, 1);
 
-    int mode=0; // just a flag to manage the general case (cursor,x,y)
-    
-    if ((wait == 0) || e->KeywordSet("NOWAIT")) {
-      gin.button=1;
-      plg->GetCursor(&gin);
-      gin.button=0;
-      mode=1;
-      wait=0;
-    }
-    if (wait == 1) {
-      while (1) {
-	plg->GetCursor(&gin);
-	//	cout << gin.button << endl;
-	if (gin.button > 0) break;
- 	if( sigControlC)
- 		return;
-      }
-      mode=1;
-    }    
-    if ((wait == 2) || e->KeywordSet("CHANGE")) {
+    /* we are not ready for the correct way (rebuilding a window following
+   stored info)
+
+    // we have to read them back from !x.crange and !y.crange
+    PLFLT xStart, xEnd, yStart, yEnd;
+    get_axis_crange("X", xStart, xEnd);
+    get_axis_crange("Y", yStart, yEnd);
+    if ((xStart == xEnd ) || ( xEnd ==0.0)) {
+  xStart=0.0;
+  xEnd=1.0;
+    }
+    if ((yStart == yEnd ) || ( yEnd ==0.0)) {
+  yStart=0.0;
+  yEnd=1.0;
+    }
+    AC_debug("crange", xStart, xEnd, yStart, yEnd);
+
+    bool okVPWC = SetVP_WC( e, plg, NULL, NULL, 0, 0,
+                xStart, xEnd, yStart, yEnd, false, false);
+    if( !okVPWC) return;
+     */
+  }
+
+  DLong wait = 1;
+
+  if (nParam == 3)
+  {
+    e->AssureLongScalarPar(2, wait);
+  }
+
+  if ((wait == 1) || (wait == 3) || (wait == 4) ||
+  e->KeywordSet("WAIT") ||
+  e->KeywordSet("DOWN") ||
+  e->KeywordSet("UP"))
+  {
+    //cout << "Sorry, this option is currently not *really* managed. Help welcome" << endl;
+    // we toggle to "wait == 1" (the mouse can move but we return if mouse is pressed)
+    wait = 1;
+  }
+
+  int mode = 0; // just a flag to manage the general case (cursor,x,y)
+
+  if ((wait == 0) || e->KeywordSet("NOWAIT"))
+  {
+    gin.button = 1;
+    plg->GetCursor(&gin);
+    gin.button = 0;
+    mode = 1;
+    wait = 0;
+  }
+  if (wait == 1)
+  {
+    while (1)
+    {
       plg->GetCursor(&gin);
-      long RefX, RefY;
-      RefX=gin.pX;
-      RefY=gin.pY;
-      if (gin.button == 0) {
-	while (1) {
-	  plg->GetCursor(&gin);
-	  if (abs(RefX-gin.dX) >0 || abs(RefY-gin.dY) >0) break;
-	  if (gin.button > 0) break;
- 	if( sigControlC)
- 		return;
-	}
+      //	cout << gin.button << endl;
+      if (gin.button > 0) break;
+      if (sigControlC)
+        return;
+    }
+    mode = 1;
+  }
+  if ((wait == 2) || e->KeywordSet("CHANGE"))
+  {
+    plg->GetCursor(&gin);
+    long RefX, RefY;
+    RefX = gin.pX;
+    RefY = gin.pY;
+    if (gin.button == 0)
+    {
+      while (1)
+      {
+        plg->GetCursor(&gin);
+        if (abs(RefX - gin.dX) > 0 || abs(RefY - gin.dY) > 0) break;
+        if (gin.button > 0) break;
+        if (sigControlC)
+          return;
       }
-      mode=1;
     }
+    mode = 1;
+  }
 
-    if (mode == 0) {
-      while (1) {
-	plg->GetCursor(&gin);
-	// TODO: When no Mouse, should be extended later to any key of the keyboard 
-	if (gin.keysym == PLK_Escape) break;
-	if (gin.button > 0) break;
- 	if( sigControlC)
- 		return;
-      }
+  if (mode == 0)
+  {
+    while (1)
+    {
+      plg->GetCursor(&gin);
+      // TODO: When no Mouse, should be extended later to any key of the keyboard
+      if (gin.keysym == PLK_Escape) break;
+      if (gin.button > 0) break;
+      if (sigControlC)
+        return;
     }
-    
-    if (debug) {
-      // plg->text();
-      cout << "mouse button : " << gin.button << endl;
-      cout << "keysym : " << gin.keysym << endl;
-      //plg->gra();
-      /* if (gin.keysym < 0xFF && isprint(gin.keysym))
-	 cout << "wx = " << gin.wX << ", wy = " << gin.wY <<
-	 ", dx = " << gin.dX << ",  dy = " << gin.dY <<
-	 ",  c = '" << gin.keysym << "'" << endl;
-	 plg->gra(); */      
-    }
-
-    if (e->KeywordSet("DEVICE")) {
-      PLFLT xp, yp;
-      PLINT xleng, yleng, xoff, yoff;
-      plg->gpage (xp, yp, xleng, yleng, xoff, yoff);
-
-      DLongGDL* xLong;
-      DLongGDL* yLong;
-      xLong=new DLongGDL(gin.pX);
-      yLong=new DLongGDL(yleng-gin.pY);
-      
-      e->SetPar(0, xLong);
-      e->SetPar(1, yLong);
-    } else {
-      DDoubleGDL* x;
-      DDoubleGDL* y;
-      if (e->KeywordSet("NORMAL")) {
-	x=new DDoubleGDL(gin.dX );
-	y=new DDoubleGDL(gin.dY );
-      } else { // default (/data)
-	// bad info outside the window (following PLPlot meaning)
-	// TODO : we can compute that using !x.s and !y.s
+  }
+
+  if (debug)
+  {
+    // plg->text();
+    cout << "mouse button : " << gin.button << endl;
+    cout << "keysym : " << gin.keysym << endl;
+    //plg->gra();
+    /* if (gin.keysym < 0xFF && isprint(gin.keysym))
+   cout << "wx = " << gin.wX << ", wy = " << gin.wY <<
+   ", dx = " << gin.dX << ",  dy = " << gin.dY <<
+   ",  c = '" << gin.keysym << "'" << endl;
+   plg->gra(); */
+  }
+
+  if (e->KeywordSet("DEVICE"))
+  {
+    PLFLT xp, yp;
+    PLINT xleng, yleng, xoff, yoff;
+    plg->gpage(xp, yp, xleng, yleng, xoff, yoff);
+
+    DLongGDL* xLong;
+    DLongGDL* yLong;
+    xLong = new DLongGDL(gin.pX);
+    yLong = new DLongGDL(yleng - gin.pY);
+
+    e->SetPar(0, xLong);
+    e->SetPar(1, yLong);
+  }
+  else
+  {
+    DDoubleGDL* x;
+    DDoubleGDL* y;
+    if (e->KeywordSet("NORMAL"))
+    {
+      x = new DDoubleGDL(gin.dX);
+      y = new DDoubleGDL(gin.dY);
+    }
+    else
+    { // default (/data)
+      DDouble tempx,tempy;
 #ifdef USE_LIBPROJ4
-        bool mapSet = false;
-        get_mapset(mapSet);
-        if (!mapSet) 
-        {
+      bool mapSet = false;
+      get_mapset(mapSet);
+      if (!mapSet)
+      {
 #endif
- 	  x = new DDoubleGDL(gin.wX );
-	  y = new DDoubleGDL(gin.wY );
+
+        getWorldCoordinatesFromPLPLOT(plg, (DDouble)gin.dX, (DDouble)gin.dY, &tempx, &tempy);
 #ifdef USE_LIBPROJ4
-        } 
-        else 
-        {
-          PROJTYPE* ref = map_init();
-          if (ref == NULL) e->Throw("Projection initialization failed.");
-          XYTYPE idata;
-          idata.x = gin.wX;
-          idata.y = gin.wY;
-          LPTYPE odata = PJ_INV(idata, ref);
-          x = new DDoubleGDL(odata.lam * RAD_TO_DEG);
-          y = new DDoubleGDL(odata.phi * RAD_TO_DEG);
-        }
-#endif
       }
-      e->SetPar(0, x);
-      e->SetPar(1, y);
-    }
-    
-    // we update the !Mouse structure (4 fields, only 3 managed up to now)
-    DStructGDL* Struct= SysVar::Mouse();
-    if (Struct!=NULL) {
-      static unsigned xMouseTag = Struct->Desc()->TagIndex("X");
-      (*static_cast<DLongGDL*>(Struct->GetTag(xMouseTag)))[0] = gin.pX;
-      static unsigned yMouseTag = Struct->Desc()->TagIndex("Y");
-      (*static_cast<DLongGDL*>(Struct->GetTag(yMouseTag)))[0] = gin.pY;
-      static unsigned ButtonMouseTag = Struct->Desc()->TagIndex("BUTTON");
-      if (gin.button == 3) gin.button=4; // 4 values only (0,1,2,4)
-      (*static_cast<DLongGDL*>(Struct->GetTag(ButtonMouseTag)))[0]=gin.button;
+      else
+      {
+        PROJTYPE* ref = map_init();
+        if (ref == NULL) e->Throw("Projection initialization failed.");
+        XYTYPE idata, idataN;
+        idataN.x = gin.dX;
+        idataN.y = gin.dY;
+        getWorldCoordinatesFromPLPLOT(plg, idataN.x, idataN.y, &idata.x, &idata.y);
+        LPTYPE odata = PJ_INV(idata, ref);
+        tempx = odata.lam * RAD_TO_DEG;
+        tempy = odata.phi * RAD_TO_DEG;
+      }
+#endif
+      bool xLog, yLog;
+      get_axis_type("X", xLog);
+      get_axis_type("Y", yLog);
+      if(xLog) tempx=pow(10,tempx);
+      if(yLog) tempy=pow(10,tempy);
+      x = new DDoubleGDL(tempx);
+      y = new DDoubleGDL(tempy);
     }
+    e->SetPar(0, x);
+    e->SetPar(1, y);
   }
- 
+
+  // we update the !Mouse structure (4 fields, only 3 managed up to now)
+  DStructGDL* Struct = SysVar::Mouse();
+  if (Struct != NULL)
+  {
+    static unsigned xMouseTag = Struct->Desc()->TagIndex("X");
+    (*static_cast<DLongGDL*>(Struct->GetTag(xMouseTag)))[0] = gin.pX;
+    static unsigned yMouseTag = Struct->Desc()->TagIndex("Y");
+    (*static_cast<DLongGDL*>(Struct->GetTag(yMouseTag)))[0] = gin.pY;
+    static unsigned ButtonMouseTag = Struct->Desc()->TagIndex("BUTTON");
+    if (gin.button == 3) gin.button = 4; // 4 values only (0,1,2,4)
+    (*static_cast<DLongGDL*>(Struct->GetTag(ButtonMouseTag)))[0] = gin.button;
+  }
+}
+
 } // namespace
diff -ruN --exclude CVS gdl-0.9.2/src/plotting_erase.cpp gdl/src/plotting_erase.cpp
--- gdl-0.9.2/src/plotting_erase.cpp	2011-07-08 06:37:54.000000000 -0600
+++ gdl/src/plotting_erase.cpp	2012-03-13 10:17:36.000000000 -0600
@@ -38,19 +38,52 @@
 
     private: void call_plplot(EnvT* e, GDLGStream* actStream) // {{{
     {
+      //      if (e->KeywordPresent(0))
+      if (e->KeywordPresent(e->KeywordIx("CHANNEL")))
+	Message(e->GetProName() + " : CHANNEL keyword not yet supported.");
+
+      static int bColorIx = e->KeywordIx("COLOR");
+      
+      //      cout << "bColorIx"<< bColorIx << endl;
+
+      DLong MaxColorIdx;
+      DLong bColor=-1;
+      MaxColorIdx=256*256*256-1;
+      //      cout << MaxColorIdx << endl;
+      
       if (nParam() == 0)
-      {
-        actStream->Clear();
-      }
+	{
+	  if (e->KeywordPresent(e->KeywordIx("COLOR")))
+	    {
+	      e->AssureLongScalarKWIfPresent(bColorIx, bColor);
+	      if (bColor > MaxColorIdx) bColor = MaxColorIdx;
+	      if (bColor < 0)   bColor = 0;
+	      //if (bColor >= 0 & bColor <= MaxColorIdx)
+	      //actStream->Background( bColor, 1);
+	    }
+	  else
+	    // we have to read back !p.background value
+	    {
+	      static DStructGDL* pStruct = SysVar::P();
+	      bColor =(*static_cast<DLongGDL*>
+		       (pStruct->GetTag(pStruct->Desc()->TagIndex("BACKGROUND"),0)))[0];
+	    }
+	}
       else 
-      {
-        DLong bColor;
-        e->AssureLongScalarPar( 0, bColor);
-        if (bColor > 255) bColor = 255;
-        if (bColor < 0)   bColor = 0;
-        actStream->Clear( bColor);
-      }
-    } // }}}
+	{
+	  e->AssureLongScalarPar(0, bColor);	
+	  if (bColor > MaxColorIdx) bColor = MaxColorIdx;
+	  if (bColor < 0)   bColor = 0;
+	}
+
+      // Get decomposed value
+      Graphics* actDevice = Graphics::GetDevice();
+      DLong decomposed = actDevice->GetDecomposed();
+      if (decomposed != 0 && decomposed != 1) {decomposed=0;}
+
+      actStream->Background( bColor, decomposed);
+      actStream->Clear();      
+    }
 
     private: virtual void post_call(EnvT*, GDLGStream*) // {{{
     {
diff -ruN --exclude CVS gdl-0.9.2/src/plotting.hpp gdl/src/plotting.hpp
--- gdl-0.9.2/src/plotting.hpp	2011-07-08 06:37:54.000000000 -0600
+++ gdl/src/plotting.hpp	2012-03-05 08:35:07.000000000 -0700
@@ -35,6 +35,7 @@
   void xyouts( EnvT* e);
   void axis( EnvT* e);
   void polyfill( EnvT* e);
+  void usersym( EnvT* e);
 
   // other plotting routines
   void erase( EnvT* e);
@@ -95,8 +96,9 @@
 
   template <typename T> 
   bool draw_polyline(EnvT *e,  GDLGStream *a, T * xVal, T* yVal, 
+             DDouble minVal, DDouble maxVal, bool doMinMax,
 		     bool xLog, bool yLog, 
-		     DDouble yStart, DDouble yEnd, DLong psym=0);
+		     DLong psym=0, bool append=FALSE);
   
   void gkw_axis_margin(EnvT *e, string axis,DFloat &start, DFloat &end);
 
@@ -107,9 +109,11 @@
   //set the noerase flag
   void gkw_noerase(EnvT * e, GDLGStream * a,bool noe=0);
   //set the symbol shape
-  void gkw_psym(EnvT *e, GDLGStream *a, bool &line, DLong &psym);
+  void gkw_psym(EnvT *e, DLong &psym);
   //set the symbol size
   void gkw_symsize(EnvT * e, GDLGStream * a);
+  //set the character size, special version authorizing 'SIZE' keyword
+  void gkw_charsize_xyouts(EnvT * e, GDLGStream * a, DFloat& charsize);
   //set the character size
   void gkw_charsize(EnvT * e, GDLGStream * a, DFloat& charsize, bool kw=true);
   //set the line thickness
@@ -119,7 +123,7 @@
   //title
   void gkw_title(EnvT* e, GDLGStream *a, PLFLT ad);
   //set the !axis.crange vector
-  void set_axis_crange(string axis, DDouble Start, DDouble End);
+  void set_axis_crange(string axis, DDouble Start, DDouble End, bool log);
   //get the !axis.crange vector
   void get_axis_crange(string axis, DDouble &Start, DDouble &End);
   void get_axis_margin(string axis, DFloat &low, DFloat &high);
@@ -142,6 +146,7 @@
 
   void GetSFromPlotStructs(DDouble **sx, DDouble **sy);
   void GetWFromPlotStructs(DFloat **wx, DFloat **wy);
+  void getWorldCoordinatesFromPLPLOT(GDLGStream *a, DDouble nx, DDouble ny, DDouble *wx, DDouble *wy);
   void DataCoordLimits(DDouble *sx, DDouble *sy, DFloat *wx, DFloat *wy, 
     DDouble *xStart, DDouble *xEnd, DDouble *yStart, DDouble *yEnd, bool);
 
@@ -169,7 +174,7 @@
     void Clipping( DDoubleGDL* clippingD, 
                  DDouble& xStart, DDouble& xEnd, DDouble& minVal, DDouble& maxVal);
     void handle_pmulti_position(EnvT *e, GDLGStream *a);
-    void UpdateSWPlotStructs(GDLGStream* actStream, DDouble xStart, DDouble xEnd, DDouble yStart, DDouble yEnd);
+    void UpdateSWPlotStructs(GDLGStream* actStream, DDouble xStart, DDouble xEnd, DDouble yStart, DDouble yEnd, bool xLog, bool yLog);
 
 } // namespace
 
diff -ruN --exclude CVS gdl-0.9.2/src/plotting_misc.cpp gdl/src/plotting_misc.cpp
--- gdl-0.9.2/src/plotting_misc.cpp	2011-06-28 06:53:58.000000000 -0600
+++ gdl/src/plotting_misc.cpp	2012-02-07 04:23:00.000000000 -0700
@@ -200,6 +200,16 @@
 	      }
 	  }
       }
-  }
 
+    // AC, 07/02/2012, please report any unexpected side effect (see test_tvlct.pro)
+    if (~get) {
+      GDLGStream* actStream = Graphics::GetDevice()->GetStream(false);
+      if (actStream != NULL) {
+	PLINT red[ctSize], green[ctSize], blue[ctSize];
+	actCT->Get( red, green, blue);
+	actStream->scmap1( red, green, blue, ctSize); 
+      }
+    }
+  }
+  
 } // namespace
diff -ruN --exclude CVS gdl-0.9.2/src/plotting_oplot.cpp gdl/src/plotting_oplot.cpp
--- gdl-0.9.2/src/plotting_oplot.cpp	2011-07-08 06:37:54.000000000 -0600
+++ gdl/src/plotting_oplot.cpp	2012-06-20 09:26:32.000000000 -0600
@@ -24,99 +24,151 @@
 
   class oplot_call : public plotting_routine_call 
   {
+    DDoubleGDL *yVal, *xVal, *xTemp, *yTemp;
+    SizeT xEl, yEl;
+    auto_ptr<BaseGDL> xval_guard,yval_guard,xtempval_guard;
 
     private: bool handle_args( EnvT* e) // {{{
     {
-      return true;
-    } // }}}
-
-  private: void old_body( EnvT* e, GDLGStream* actStream) // {{{
-  {
-    bool valid, line;
-    valid=true;
-    DLong psym;
-    DDoubleGDL* yVal;
-    DDoubleGDL* xVal;
-    auto_ptr<BaseGDL> xval_guard;
-
-    if ( e->KeywordSet( "POLAR")) {
-       e->Throw( "Soory, POLAR keyword not ready");
+      bool polar=FALSE;
+      DLong nsum=1;
+      e->AssureLongScalarKWIfPresent( "NSUM", nsum);
+      if ( e->KeywordSet( "POLAR"))
+      {
+        polar=TRUE;
+       // e->Throw( "Sorry, POLAR keyword not ready");
       }
 
-    SizeT xEl;
-    SizeT yEl;
-    if( nParam() == 1)
+      DDoubleGDL *yValBis, *xValBis;
+      auto_ptr<BaseGDL> xvalBis_guard, yvalBis_guard;
+      //test and transform eventually if POLAR and/or NSUM!
+      if( nParam() == 1)
       {
-	yVal = e->GetParAs< DDoubleGDL>( 0);
-        if (yVal->Rank() == 0) 
+        yTemp = e->GetParAs< DDoubleGDL>( 0);
+        if (yTemp->Rank() == 0)
           e->Throw("Expression must be an array in this context: "+e->GetParString(0));
-	yEl = yVal->N_Elements();
-	
-	xVal = new DDoubleGDL( dimension( yEl), BaseGDL::INDGEN);
-	xval_guard.reset( xVal); // delete upon exit
-	xEl = yEl;
+        yEl=yTemp->N_Elements();
+        xEl=yEl;
+        xTemp = new DDoubleGDL( dimension( xEl), BaseGDL::INDGEN);
+        xtempval_guard.reset( xTemp); // delete upon exit
       }
-    else
+      else
       {
-	xVal = e->GetParAs< DDoubleGDL>( 0);
-        if (xVal->Rank() == 0) 
+        xTemp = e->GetParAs< DDoubleGDL>( 0);
+        if (xTemp->Rank() == 0)
           e->Throw("Expression must be an array in this context: "+e->GetParString(0));
-	xEl = xVal->N_Elements();
+        xEl=xTemp->N_Elements();
 
-	yVal = e->GetParAs< DDoubleGDL>( 1);
-        if (yVal->Rank() == 0) 
+        yTemp = e->GetParAs< DDoubleGDL>( 1);
+        if (yTemp->Rank() == 0)
           e->Throw("Expression must be an array in this context: "+e->GetParString(1));
-	yEl = yVal->N_Elements();
+        yEl=yTemp->N_Elements();
+        //silently drop unmatched values
+        if (yEl != xEl)
+        {
+          SizeT size;
+          size = min(xEl, yEl);
+          xEl = size;
+          yEl = size;
+        }
+      }
+      //check nsum validity
+      nsum=max(1,nsum);
+      nsum=min(nsum,(DLong)xEl);
+      if (nsum == 1)
+      {
+        if (polar)
+        {
+          xVal = new DDoubleGDL(dimension(xEl), BaseGDL::NOZERO);
+          xval_guard.reset(xVal); // delete upon exit
+          yVal = new DDoubleGDL(dimension(yEl), BaseGDL::NOZERO);
+          yval_guard.reset(yVal); // delete upon exit
+          for (int i = 0; i < xEl; i++) (*xVal)[i] = (*xTemp)[i] * cos((*yTemp)[i]);
+          for (int i = 0; i < yEl; i++) (*yVal)[i] = (*xTemp)[i] * sin((*yTemp)[i]);
+        }
+        else
+        { //careful about previously set autopointers!
+          if (nParam() == 1) xval_guard = xtempval_guard;
+          xVal = xTemp;
+          yVal = yTemp;
+        }
+      }
+      else
+      {
+        int i, j, k;
+        DLong size = xEl / nsum;
+        xVal = new DDoubleGDL(size, BaseGDL::ZERO); //SHOULD BE ZERO, IS NOT!
+        xval_guard.reset(xVal); // delete upon exit
+        yVal = new DDoubleGDL(size, BaseGDL::ZERO); //IDEM
+        yval_guard.reset(yVal); // delete upon exit
+        for (i = 0, k = 0; i < size; i++)
+        {
+          (*xVal)[i] = 0.0;
+          (*yVal)[i] = 0.0;
+          for (j = 0; j < nsum; j++, k++)
+          {
+            (*xVal)[i] += (*xTemp)[k];
+            (*yVal)[i] += (*yTemp)[k];
+          }
+        }
+        for (i = 0; i < size; i++) (*xVal)[i] /= nsum;
+        for (i = 0; i < size; i++) (*yVal)[i] /= nsum;
+
+        if (polar)
+        {
+          DDouble x, y;
+          for (i = 0; i < size; i++)
+          {
+            x = (*xVal)[i] * cos((*yVal)[i]);
+            y = (*xVal)[i] * sin((*yVal)[i]);
+            (*xVal)[i] = x;
+            (*yVal)[i] = y;
+          }
+        }
       }
-    DLong minEl = (xEl < yEl)? xEl : yEl;
+    }
 
-    // !X, !Y (also used below)
-    DString xTitle, yTitle; 
-    DFloat xMarginL, xMarginR, yMarginB, yMarginT; 
+  private: void old_body( EnvT* e, GDLGStream* actStream) // {{{
+  {
+    bool valid;
+    valid=true;
+    DLong psym;
 
-    get_axis_margin("X",xMarginL, xMarginR);
-    get_axis_margin("Y",yMarginB, yMarginT);
     // get ![XY].CRANGE
     DDouble xStart, xEnd, yStart, yEnd;
     get_axis_crange("X", xStart, xEnd);
     get_axis_crange("Y", yStart, yEnd);
-    DDouble minVal;
-    DDouble maxVal;
+    DDouble minVal, maxVal;
+    bool doMinMax;
 
     bool xLog;
     bool yLog;
     get_axis_type("X", xLog);
     get_axis_type("Y", yLog);
-    
-    //    int just = (e->KeywordSet("ISOTROPIC"))? 1 : 0;
-
-    // start drawing
-    gkw_background(e, actStream,false);
-    gkw_color(e, actStream);
-    //    gkw_noerase(e, actStream, true);
-    gkw_psym(e, actStream, line, psym);
-    DFloat charsize;
-    gkw_charsize(e,actStream, charsize, false);
-
 
-    if( (yStart == yEnd) || (xStart == xEnd))
-      {
-	if( yStart != 0.0 && yStart == yEnd)
-	  Message("OPLOT: !Y.CRANGE ERROR, setting to [0,1]");
-	yStart = 0; //yVal->min();
-	yEnd   = 1; //yVal->max();
-	    
-	if(xStart != 0.0 && xStart == xEnd)
-	  Message("OPLOT: !X.CRANGE ERROR, resetting range to data");
-	xStart = 0; //xVal->min();
-	xEnd   = 1; //xVal->max();
-	
-	set_axis_crange("X", xStart, xEnd);
-	set_axis_crange("Y", yStart, yEnd);
-      }	    
+    if ((yStart == yEnd) || (xStart == xEnd))
+    {
+      if (yStart != 0.0 && yStart == yEnd)
+        Message("OPLOT: !Y.CRANGE ERROR, setting to [0,1]");
+      yStart = 0; //yVal->min();
+      yEnd = 1; //yVal->max();
+
+      if (xStart != 0.0 && xStart == xEnd)
+        Message("OPLOT: !X.CRANGE ERROR, setting to [0,1]");
+      xStart = 0; //xVal->min();
+      xEnd = 1; //xVal->max();
+
+      set_axis_crange("X", xStart, xEnd, xLog);
+      set_axis_crange("Y", yStart, yEnd, yLog);
+    }
     
-    minVal = yStart;
-    maxVal = yEnd;
+    //now we can setup minVal and maxVal to defaults: Start-End and overload if KW present
+
+    minVal = yStart; //to give a reasonable value...
+    maxVal = yEnd;   //idem
+    doMinMax = false; //although we will not use it...
+    if( e->KeywordSet( "MIN_VALUE") || e->KeywordSet( "MAX_VALUE"))
+      doMinMax = true; //...unless explicitely required
     e->AssureDoubleScalarKWIfPresent( "MIN_VALUE", minVal);
     e->AssureDoubleScalarKWIfPresent( "MAX_VALUE", maxVal);
 
@@ -129,33 +181,35 @@
 	static int clippingix = e->KeywordIx( "CLIP"); 
 	clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
       }
-    
 
-    // viewport and world coordinates
-    bool okVPWC = SetVP_WC( e, actStream, NULL, clippingD, 
-			    xLog, yLog,
-			    xMarginL, xMarginR, yMarginB, yMarginT,
-			    xStart, xEnd, minVal, maxVal);
+    DFloat xMarginL, xMarginR, yMarginB, yMarginT;
+    get_axis_margin("X",xMarginL, xMarginR); 	 
+    get_axis_margin("Y",yMarginB, yMarginT);
+    // viewport and world coordinates 	 
+    bool okVPWC = SetVP_WC( e, actStream, NULL, clippingD, 	 
+			    xLog, yLog, 	 
+			    xMarginL, xMarginR, yMarginB, yMarginT, 	 
+			    xStart, xEnd, minVal, maxVal); 	 
     if( !okVPWC) return;
-    // pen thickness for axis
-    actStream->wid( 0);
 
-    // axis
-    //    string xOpt = "bcnst";
-    //string yOpt = "bcnstv";
-
-    //    if( xLog) xOpt += "l";
-    //if( yLog) yOpt += "l";
-    // pen thickness for plot
+    actStream->wid( 0);
+    // start drawing. Graphic Keywords accepted:CLIP(NO), COLOR(YES), LINESTYLE(YES), NOCLIP(YES),
+    //                                          PSYM(YES), SYMSIZE(YES), T3D(NO), ZVALUE(NO)
+    gkw_background(e, actStream, false);
+    gkw_color(e, actStream);
+    //    gkw_noerase(e, actStream, true);
+    gkw_psym(e, psym);
+    DFloat charsize;
+    gkw_charsize(e,actStream, charsize, false); //set !P.CHARSIZE
     gkw_thick(e, actStream);
     gkw_symsize(e, actStream);
     gkw_linestyle(e, actStream);
 
     // plot the data
-    if(valid)
+    if(valid) //invalid is not yet possible. Could be done by a severe clipping for example.
       valid=draw_polyline(e, actStream, 
-			  xVal, yVal, xLog, yLog, 
-			  yStart, yEnd, psym);
+			  xVal, yVal, minVal, maxVal, doMinMax, xLog, yLog,
+			  psym, FALSE);
 
 
     actStream->lsty(1);//reset linestyle
diff -ruN --exclude CVS gdl-0.9.2/src/plotting_plot.cpp gdl/src/plotting_plot.cpp
--- gdl-0.9.2/src/plotting_plot.cpp	2011-07-08 06:37:54.000000000 -0600
+++ gdl/src/plotting_plot.cpp	2012-03-05 08:35:07.000000000 -0700
@@ -1,306 +1,411 @@
-/***************************************************************************
-                       plotting_plot.cpp  -  GDL routines for plotting
-                             -------------------
-    begin                : July 22 2002
-    copyright            : (C) 2002-2011 by Marc Schellens et al.
-    email                : m_schellens@users.sf.net
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "includefirst.hpp"
-#include "plotting.hpp"
-
-namespace lib {
-
-  using namespace std;
-
-  class plot_call : public plotting_routine_call 
-  {
-    DDoubleGDL *yVal, *xVal;
-    DDouble minVal, maxVal, xStart, xEnd, yStart, yEnd;
-    bool xLog, yLog;
-    DLong psym;
-    auto_ptr<BaseGDL> xval_guard;
-
-    private: bool handle_args( EnvT* e) // {{{
-    {
-      if( nParam() == 1)
-      {
-        yVal = e->GetParAs< DDoubleGDL>( 0);
-        if (yVal->Rank() == 0) 
-          e->Throw("Expression must be an array in this context: "+e->GetParString(0));
-        xVal = new DDoubleGDL( dimension( yVal->N_Elements()), BaseGDL::INDGEN);
-        xval_guard.reset( xVal); // delete upon exit
-      }
-      else
-      {
-        xVal = e->GetParAs< DDoubleGDL>( 0);
-        if (xVal->Rank() == 0) 
-          e->Throw("Expression must be an array in this context: "+e->GetParString(0));
-        yVal = e->GetParAs< DDoubleGDL>( 1);
-        if (yVal->Rank() == 0) 
-          e->Throw("Expression must be an array in this context: "+e->GetParString(1));
-      }
-
-      if ( e->KeywordSet( "POLAR")) 
-      {
-        e->Throw( "Sorry, POLAR keyword not ready");
-      }
-
-      //   BaseGDL *x, *y;
-      {
-        DLong minEl, maxEl;
-
-        xVal->MinMax( &minEl, &maxEl, NULL, NULL, true);
-        xStart = (*xVal)[minEl];
-        xEnd = (*xVal)[maxEl];
-
-        yVal->MinMax( &minEl, &maxEl, NULL, NULL, true);
-        yStart = (*yVal)[minEl];
-        yEnd = (*yVal)[maxEl];
-      }
-      return false;
-    } // }}}
-
-  private: void old_body( EnvT* e, GDLGStream* actStream) // {{{
-  {
-
-    // [XY]STYLE
-    DLong xStyle=0, yStyle=0; 
-    gkw_axis_style(e, "X", xStyle);
-    gkw_axis_style(e, "Y", yStyle);
-
-    e->AssureLongScalarKWIfPresent( "XSTYLE", xStyle);
-    e->AssureLongScalarKWIfPresent( "YSTYLE", yStyle);
-
-    // AXIS TITLE
-    DString xTitle, yTitle; 
-    gkw_axis_title(e, "X", xTitle);
-    gkw_axis_title(e, "Y", yTitle);
-
-    // MARGIN
-    DFloat xMarginL, xMarginR, yMarginB, yMarginT; 
-    gkw_axis_margin(e, "X", xMarginL, xMarginR);
-    gkw_axis_margin(e, "Y", yMarginB, yMarginT);
-
-    DLong xnozero=1, ynozero=0;
-    if ( e->KeywordSet( "YNOZERO")) ynozero = 1;
-
-    // keyword overrides
-    static int xLogIx = e->KeywordIx( "XLOG");
-    static int yLogIx = e->KeywordIx( "YLOG");
-    xLog = e->KeywordSet( xLogIx);
-    yLog = e->KeywordSet( yLogIx);
-
-    if (xLog && xStart <= 0.0)
-      Warning( "PLOT: Infinite x plot range.");
-    if (yLog && yStart <= 0.0)
-      Warning( "PLOT: Infinite y plot range.");
-
-    if ( e->KeywordSet( "YNOZERO")) ynozero = 1;
-
-    if ((xStyle & 1) != 1) {
-      PLFLT intv = AutoIntvAC(xStart, xEnd, xnozero, xLog);
-    }
-    if ((yStyle & 1) != 1) {
-      PLFLT intv = AutoIntvAC(yStart, yEnd, ynozero, yLog);
-    }
-
-    // Please remember the {X|Y}range overwrite the data range
-    //[x|y]range keyword
-    gkw_axis_range(e, "X", xStart, xEnd, xnozero);
-    gkw_axis_range(e, "Y", yStart, yEnd, ynozero);
-
-    if (xLog && xStart <= 0.0)
-      Warning( "PLOT: Infinite x plot range.");
-    if (yLog && yStart <= 0.0)
-      Warning( "PLOT: Infinite y plot range.");
-
-    minVal = yStart;
-    maxVal = yEnd;
-    e->AssureDoubleScalarKWIfPresent( "MIN_VALUE", minVal);
-    e->AssureDoubleScalarKWIfPresent( "MAX_VALUE", maxVal);
-
-    DLong xTicks=0, yTicks=0; 
-    e->AssureLongScalarKWIfPresent( "XTICKS", xTicks);
-    e->AssureLongScalarKWIfPresent( "YTICKS", yTicks);
-
-    DLong xMinor=0, yMinor=0; 
-    e->AssureLongScalarKWIfPresent( "XMINOR", xMinor);
-    e->AssureLongScalarKWIfPresent( "YMINOR", yMinor);
-
-    DString xTickformat, yTickformat;
-    e->AssureStringScalarKWIfPresent( "XTICKFORMAT", xTickformat);
-    e->AssureStringScalarKWIfPresent( "YTICKFORMAT", yTickformat);
-
-    DDouble ticklen = 0.02;
-    e->AssureDoubleScalarKWIfPresent( "TICKLEN", ticklen);
-
-    DFloat xTicklen, yTicklen;
-    e->AssureFloatScalarKWIfPresent( "XTICKLEN", xTicklen);
-    e->AssureFloatScalarKWIfPresent( "YTICKLEN", yTicklen);
-    // plsmin (def, scale);
-
-    // POSITION
-    PLFLT xScale = 1.0;
-    PLFLT yScale = 1.0;
-
-    //    PLFLT scale = 1.0;
-    static int positionIx = e->KeywordIx( "POSITION"); 
-    DFloatGDL* pos = e->IfDefGetKWAs<DFloatGDL>( positionIx);
-    if (pos == NULL) pos = (DFloatGDL*) 0xF;
-
-    // *** start drawing
-    gkw_background(e, actStream);  //BACKGROUND
-    gkw_color(e, actStream);       //COLOR
-
-    {
-      bool line;
-      gkw_psym(e, actStream, line, psym);//PSYM
-    }
-
-    DFloat charsize, xCharSize, yCharSize;
-    gkw_charsize(e, actStream, charsize);  //CHARSIZE
-    gkw_axis_charsize(e, "X", xCharSize);   //XCHARSIZE
-    gkw_axis_charsize(e, "Y", yCharSize);   //YCHARSIZE
-
-    // Turn off map projection processing
-    set_mapset(0);
-
-    gkw_noerase(e, actStream);     //NOERASE
-
-    DLong noErase = 0;
-    if( e->KeywordSet( "NOERASE")) noErase = 1;
-    if( !noErase) actStream->Clear();
-
-    // Get device name
-    DStructGDL* dStruct = SysVar::D();
-    static unsigned nameTag = dStruct->Desc()->TagIndex( "NAME");
-    DString d_name = 
-      (*static_cast<DStringGDL*>( dStruct->GetTag( nameTag, 0)))[0];
-    // if PS and not noErase (ie, erase) then set !p.noerase=0    
-    if ((d_name == "PS" || d_name == "SVG") && !noErase) {
-      static DStructGDL* pStruct = SysVar::P();
-      static unsigned noEraseTag = pStruct->Desc()->TagIndex( "NOERASE");
-      (*static_cast<DLongGDL*>( pStruct->GetTag( noEraseTag, 0)))[0] = 0;
-    }
-
-    // plplot stuff
-    // set the charsize (scale factor)
-    DDouble charScale = 1.0;
-    DLongGDL* pMulti = SysVar::GetPMulti();
-    if( (*pMulti)[1] > 2 || (*pMulti)[2] > 2) charScale = 0.5;
-    actStream->schr( 0.0, charsize * charScale);
-
-    // get subpage in mm
-    PLFLT scrXL, scrXR, scrYB, scrYT;
-    actStream->gspa( scrXL, scrXR, scrYB, scrYT); 
-    PLFLT scrX = scrXR-scrXL;
-    PLFLT scrY = scrYT-scrYB;
-
-    // get char size in mm (default, actual)
-    PLFLT defH, actH;
-    actStream->gchr( defH, actH);
-
-    // CLIPPING
-    DDoubleGDL* clippingD=NULL;
-    DLong noclip=0;
-    e->AssureLongScalarKWIfPresent( "NOCLIP", noclip);
-    if(noclip == 0)
-    {
-      static int clippingix = e->KeywordIx( "CLIP"); 
-      clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
-    }
-    
-    // viewport and world coordinates
-    bool okVPWC = SetVP_WC( e, actStream, pos, clippingD, 
-			    xLog, yLog,
-			    xMarginL, xMarginR, yMarginB, yMarginT,
-			    xStart, xEnd, minVal, maxVal);
-    if( !okVPWC) return;
-
-    // pen thickness for axis
-    actStream->wid( 0);
-
-    // axis
-    string xOpt="bc", yOpt="bc";
-    AdjustAxisOpts(xOpt, yOpt, xStyle, yStyle, xTicks, yTicks, xTickformat, yTickformat, xLog, yLog);
-
-    // axis titles
-    actStream->schr( 0.0, actH/defH * xCharSize);
-    actStream->mtex("b",3.5,0.5,0.5,xTitle.c_str());
-
-    // the axis (separate for x and y axis because of charsize)
-    PLFLT xintv;
-    if (xTicks == 0) {
-      xintv = AutoTick(xEnd-xStart);
-    } else {
-      xintv = (xEnd - xStart) / xTicks;
-    }
-    actStream->box( xOpt.c_str(), xintv, xMinor, "", 0.0, 0);
-
-    actStream->schr( 0.0, actH/defH * yCharSize);
-    actStream->mtex("l",5.0,0.5,0.5,yTitle.c_str());
-    // the axis (separate for x and y axis because of charsize)
-    PLFLT yintv;
-    if (yTicks == 0) {
-      yintv = AutoTick(yEnd-yStart);
-    } else {
-      yintv = (yEnd - yStart) / yTicks;
-    }
-    actStream->box( "", 0.0, 0, yOpt.c_str(), yintv, yMinor);
-
-    // title and sub title
-    gkw_title(e, actStream, actH/defH);
-
-    // pen thickness for plot
-    gkw_thick(e, actStream);
-    gkw_symsize(e, actStream);
-    gkw_linestyle(e, actStream);
-
-    UpdateSWPlotStructs(actStream, xStart, xEnd, yStart, yEnd);
-
-  } // }}}
-  
-    private: void call_plplot(EnvT* e, GDLGStream* actStream) // {{{
-    {
-      // plot the data
-      static int nodataIx = e->KeywordIx( "NODATA"); 
-      if (!e->KeywordSet(nodataIx)) 
-      {
-        bool valid = draw_polyline(e, actStream, xVal, yVal, xLog, yLog, yStart, yEnd, psym);
-        // TODO: handle valid?
-      }
-    } // }}}
-
-    private: void post_call(EnvT* e, GDLGStream* actStream) // {{{
-    {
-      actStream->lsty(1);//reset linestyle
-
-      // set ![XY].CRANGE
-      set_axis_crange("X", xStart, xEnd);
-      set_axis_crange("Y", minVal, maxVal);    
-
-      //set ![x|y].type
-      set_axis_type("X",xLog);
-      set_axis_type("Y",yLog);
-    } // }}}
-
-  };
-
-  void plot(EnvT* e)
-  {
-    plot_call plot;
-    plot.call(e, 1);
-  }
-
-} // namespace
-
+/***************************************************************************
+                       plotting_plot.cpp  -  GDL routines for plotting
+                             -------------------
+    begin                : July 22 2002
+    copyright            : (C) 2002-2011 by Marc Schellens et al.
+    email                : m_schellens@users.sf.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "includefirst.hpp"
+#include "plotting.hpp"
+
+namespace lib {
+
+  using namespace std;
+
+  class plot_call : public plotting_routine_call 
+  {
+    DDoubleGDL *yVal, *xVal, *xTemp, *yTemp;
+    SizeT xEl, yEl;
+    DDouble minVal, maxVal, xStart, xEnd, yStart, yEnd;
+    bool doMinMax;
+    bool xLog, yLog, wasBadxLog, wasBadyLog;
+    DLong psym;
+    auto_ptr<BaseGDL> xval_guard,yval_guard,xtemp_guard;
+
+private:
+
+  bool handle_args(EnvT* e) // {{{
+  {
+    bool polar = FALSE;
+    DLong nsum = 1;
+    e->AssureLongScalarKWIfPresent("NSUM", nsum);
+    if (e->KeywordSet("POLAR"))
+    {
+      polar = TRUE;
+      // e->Throw( "Sorry, POLAR keyword not ready");
+    }
+
+    DDoubleGDL *yValBis, *xValBis;
+    auto_ptr<BaseGDL> xvalBis_guard, yvalBis_guard;
+    //test and transform eventually if POLAR and/or NSUM!
+    if (nParam() == 1)
+    {
+      yTemp = e->GetParAs< DDoubleGDL > (0);
+      if (yTemp->Rank() == 0)
+        e->Throw("Expression must be an array in this context: " + e->GetParString(0));
+      yEl=yTemp->N_Elements();
+      xEl=yEl;
+      xTemp = new DDoubleGDL(dimension(xEl), BaseGDL::INDGEN);
+      xtemp_guard.reset(xTemp); // delete upon exit
+    }
+    else
+    {
+      xTemp = e->GetParAs< DDoubleGDL > (0);
+      if (xTemp->Rank() == 0)
+        e->Throw("Expression must be an array in this context: " + e->GetParString(0));
+      xEl=xTemp->N_Elements();
+      yTemp = e->GetParAs< DDoubleGDL > (1);
+      if (yTemp->Rank() == 0)
+        e->Throw("Expression must be an array in this context: " + e->GetParString(1));
+      yEl=yTemp->N_Elements();
+      //silently drop unmatched values
+      if (yEl!= xEl)
+      {
+        SizeT size;
+        size = min(xEl, yEl);
+        xEl = size;
+        yEl = size;
+      }
+    }
+    //check nsum validity
+    nsum = max(1, nsum);
+    nsum = min(nsum, (DLong)xEl);
+
+    if (nsum == 1)
+    {
+      if (polar)
+      {
+        xVal = new DDoubleGDL(dimension(xEl), BaseGDL::NOZERO);
+        xval_guard.reset(xVal); // delete upon exit
+        yVal = new DDoubleGDL(dimension(yEl), BaseGDL::NOZERO);
+        yval_guard.reset(yVal); // delete upon exit
+        for (int i = 0; i < xEl; i++) (*xVal)[i] = (*xTemp)[i] * cos((*yTemp)[i]);
+        for (int i = 0; i < yEl; i++) (*yVal)[i] = (*xTemp)[i] * sin((*yTemp)[i]);
+      }
+      else
+      { //careful about previously set autopointers!
+        if (nParam() == 1) xval_guard = xtemp_guard;
+        xVal = xTemp;
+        yVal = yTemp;
+      }
+    }
+    else
+    {
+      int i, j, k;
+      DLong size = (DLong)xEl / nsum;
+      xVal = new DDoubleGDL(size, BaseGDL::ZERO); //SHOULD BE ZERO, IS NOT!
+      xval_guard.reset(xVal); // delete upon exit
+      yVal = new DDoubleGDL(size, BaseGDL::ZERO); //IDEM
+      yval_guard.reset(yVal); // delete upon exit
+      for (i = 0, k = 0; i < size; i++)
+      {
+        (*xVal)[i] = 0.0;
+        (*yVal)[i] = 0.0;
+        for (j = 0; j < nsum; j++, k++)
+        {
+          (*xVal)[i] += (*xTemp)[k];
+          (*yVal)[i] += (*yTemp)[k];
+        }
+      }
+      for (i = 0; i < size; i++) (*xVal)[i] /= nsum;
+      for (i = 0; i < size; i++) (*yVal)[i] /= nsum;
+
+      if (polar)
+      {
+        DDouble x, y;
+        for (i = 0; i < size; i++)
+        {
+          x = (*xVal)[i] * cos((*yVal)[i]);
+          y = (*xVal)[i] * sin((*yVal)[i]);
+          (*xVal)[i] = x;
+          (*yVal)[i] = y;
+        }
+      }
+    }
+    // keyword overrides
+    static int xLogIx = e->KeywordIx("XLOG");
+    static int yLogIx = e->KeywordIx("YLOG");
+    xLog = e->KeywordSet(xLogIx);
+    yLog = e->KeywordSet(yLogIx);
+    // compute adequate values for log scale, warn adequately...
+    wasBadxLog = FALSE;
+    wasBadyLog = FALSE;
+    if (xLog)
+    {
+      DLong minEl, maxEl;
+      xVal->MinMax(&minEl, &maxEl, NULL, NULL, true);
+      if ((*xVal)[minEl] <= 0.0) wasBadxLog = TRUE;
+      xValBis = new DDoubleGDL(dimension(xEl), BaseGDL::NOZERO);
+      xvalBis_guard.reset(xValBis); // delete upon exit
+      for (int i = 0; i < xEl; i++) (*xValBis)[i] = log10((*xVal)[i]);
+    }
+    else xValBis = xVal;
+    if (yLog)
+    {
+      DLong minEl, maxEl;
+      yVal->MinMax(&minEl, &maxEl, NULL, NULL, true);
+      if ((*yVal)[minEl] <= 0.0) wasBadyLog = TRUE;
+      yValBis = new DDoubleGDL(dimension(yEl), BaseGDL::NOZERO);
+      yvalBis_guard.reset(yValBis); // delete upon exit
+      for (int i = 0; i < yEl; i++) (*yValBis)[i] = log10((*yVal)[i]);
+    }
+    else yValBis = yVal;
+    //   BaseGDL *x, *y;
+    {
+      DLong minEl, maxEl;
+
+      xValBis->MinMax(&minEl, &maxEl, NULL, NULL, true);
+      xStart = (*xVal)[minEl];
+      if (isnan(xStart)) xStart = 1e-12;
+      xEnd = (*xVal)[maxEl];
+      if (isnan(xEnd)) xEnd = 1.0;
+
+      yValBis->MinMax(&minEl, &maxEl, NULL, NULL, true);
+      yStart = (*yVal)[minEl];
+      if (isnan(yStart)) yStart = 1e-12;
+      yEnd = (*yVal)[maxEl];
+      if (isnan(yEnd)) yEnd = 1.0;
+    }
+    return false;
+  } // }}}
+
+  private: void old_body( EnvT* e, GDLGStream* actStream) // {{{
+  {
+
+    // [XY]STYLE
+    DLong xStyle=0, yStyle=0; 
+    gkw_axis_style(e, "X", xStyle);
+    gkw_axis_style(e, "Y", yStyle);
+
+    e->AssureLongScalarKWIfPresent( "XSTYLE", xStyle);
+    e->AssureLongScalarKWIfPresent( "YSTYLE", yStyle);
+
+    // AXIS TITLE
+    DString xTitle, yTitle; 
+    gkw_axis_title(e, "X", xTitle);
+    gkw_axis_title(e, "Y", yTitle);
+
+    // MARGIN
+    DFloat xMarginL, xMarginR, yMarginB, yMarginT; 
+    gkw_axis_margin(e, "X", xMarginL, xMarginR);
+    gkw_axis_margin(e, "Y", yMarginB, yMarginT);
+
+    DLong xnozero=1, ynozero=0;
+    if ( e->KeywordSet( "YNOZERO")) ynozero = 1;
+
+    // Please remember the {X|Y}range overwrite the data range
+    //[x|y]range keyword
+    gkw_axis_range(e, "X", xStart, xEnd, xnozero);
+    gkw_axis_range(e, "Y", yStart, yEnd, ynozero);
+
+    if ((xLog && xStart <= 0.0) || wasBadxLog) Warning( "PLOT: Infinite x plot range.");
+    if ((yLog && yStart <= 0.0) || wasBadyLog) Warning( "PLOT: Infinite y plot range.");
+    //xStyle and yStyle apply on range values
+
+//    // style applies on the final values
+    if ((xStyle & 1) != 1) {
+      PLFLT intv = AutoIntvAC(xStart, xEnd, xnozero, xLog);
+    }
+    if ((yStyle & 1) != 1) {
+      PLFLT intv = AutoIntvAC(yStart, yEnd, ynozero, yLog);
+    }
+
+    DLong xTicks=0, yTicks=0;
+    e->AssureLongScalarKWIfPresent( "XTICKS", xTicks);
+    e->AssureLongScalarKWIfPresent( "YTICKS", yTicks);
+
+    DLong xMinor=0, yMinor=0; 
+    e->AssureLongScalarKWIfPresent( "XMINOR", xMinor);
+    e->AssureLongScalarKWIfPresent( "YMINOR", yMinor);
+
+    DString xTickformat, yTickformat;
+    e->AssureStringScalarKWIfPresent( "XTICKFORMAT", xTickformat);
+    e->AssureStringScalarKWIfPresent( "YTICKFORMAT", yTickformat);
+
+    DDouble ticklen = 0.02;
+    e->AssureDoubleScalarKWIfPresent( "TICKLEN", ticklen);
+
+    DFloat xTicklen, yTicklen;
+    e->AssureFloatScalarKWIfPresent( "XTICKLEN", xTicklen);
+    e->AssureFloatScalarKWIfPresent( "YTICKLEN", yTicklen);
+    // plsmin (def, scale);
+
+    // POSITION
+    static int positionIx = e->KeywordIx( "POSITION"); 
+    DFloatGDL* pos = e->IfDefGetKWAs<DFloatGDL>( positionIx);
+    if (pos == NULL) pos = (DFloatGDL*) 0xF;
+
+    // *** start drawing. Graphic Keywords accepted: BACKGROUND, CHARSIZE, CHARTHICK, CLIP, COLOR, DATA, DEVICE, FONT, LINESTYLE, NOCLIP, NODATA, NOERASE, NORMAL, POSITION, PSYM, SUBTITLE, SYMSIZE, T3D, THICK, TICKLEN, TITLE, [XYZ]CHARSIZE, [XYZ]GRIDSTYLE, [XYZ]MARGIN(OK), [XYZ]MINOR, [XYZ]RANGE, [XYZ]STYLE, [XYZ]THICK, [XYZ]TICKFORMAT, [XYZ]TICKINTERVAL, [XYZ]TICKLAYOUT, [XYZ]TICKLEN, [XYZ]TICKNAME, [XYZ]TICKS, [XYZ]TICKUNITS, [XYZ]TICKV, [XYZ]TICK_GET, [XYZ]TITLE, ZVALUE
+    gkw_background(e, actStream);  //BACKGROUND
+    gkw_color(e, actStream);       //COLOR
+
+    gkw_psym(e, psym);//PSYM
+
+    DFloat charsize, xCharSize, yCharSize;
+    gkw_charsize(e, actStream, charsize);  //CHARSIZE
+    gkw_axis_charsize(e, "X", xCharSize);   //XCHARSIZE
+    gkw_axis_charsize(e, "Y", yCharSize);   //YCHARSIZE
+
+    // Turn off map projection processing
+    set_mapset(0);
+
+    gkw_noerase(e, actStream);     //NOERASE
+
+    DLong noErase = 0;
+    if( e->KeywordSet( "NOERASE")) noErase = 1;
+    if( !noErase) actStream->Clear();
+
+    // Get device name
+    DStructGDL* dStruct = SysVar::D();
+    static unsigned nameTag = dStruct->Desc()->TagIndex( "NAME");
+    DString d_name = 
+      (*static_cast<DStringGDL*>( dStruct->GetTag( nameTag, 0)))[0];
+    // if PS and not noErase (ie, erase) then set !p.noerase=0    
+    if ((d_name == "PS" || d_name == "SVG") && !noErase) {
+      static DStructGDL* pStruct = SysVar::P();
+      static unsigned noEraseTag = pStruct->Desc()->TagIndex( "NOERASE");
+      (*static_cast<DLongGDL*>( pStruct->GetTag( noEraseTag, 0)))[0] = 0;
+    }
+
+    // plplot stuff
+    // set the charsize (scale factor)
+    DDouble charScale = 1.0;
+    DLongGDL* pMulti = SysVar::GetPMulti();
+    if( (*pMulti)[1] > 2 || (*pMulti)[2] > 2) charScale = 0.5;
+    actStream->schr( 0.0, charsize * charScale);
+
+    // get char size in mm (default, actual)
+    PLFLT defH, actH;
+    actStream->gchr( defH, actH);
+
+    // CLIPPING
+    DDoubleGDL* clippingD=NULL;
+    DLong noclip=0;
+    e->AssureLongScalarKWIfPresent( "NOCLIP", noclip);
+    if(noclip == 0)
+    {
+      static int clippingix = e->KeywordIx( "CLIP"); 
+      clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
+    }
+    
+    // viewport and world coordinates
+    bool okVPWC = SetVP_WC( e, actStream, pos, clippingD, 
+			    xLog, yLog,
+			    xMarginL, xMarginR, yMarginB, yMarginT,
+			    xStart, xEnd, yStart, yEnd);
+    if( !okVPWC) return;
+
+
+    //now we can setup minVal and maxVal to defaults: Start-End and overload if KW present
+
+    minVal = yStart; //to give a reasonable value...
+    maxVal = yEnd;   //idem
+    doMinMax = false; //although we will not use it...
+    if( e->KeywordSet( "MIN_VALUE") || e->KeywordSet( "MAX_VALUE"))
+      doMinMax = true; //...unless explicitely required
+    e->AssureDoubleScalarKWIfPresent( "MIN_VALUE", minVal);
+    e->AssureDoubleScalarKWIfPresent( "MAX_VALUE", maxVal);
+
+    //AXES:
+    // pen thickness for axis
+    actStream->wid( 0);
+
+    // axis
+    string xOpt="bc", yOpt="bc";
+    AdjustAxisOpts(xOpt, yOpt, xStyle, yStyle, xTicks, yTicks, xTickformat, yTickformat, xLog, yLog);
+
+    DLong charthick=0;
+    e->AssureLongScalarKWIfPresent("CHARTHICK",charthick);
+    actStream->wid(charthick);
+
+//X
+    // axis titles
+    actStream->schr( 0.0, actH/defH * xCharSize);
+    actStream->mtex("b",3.5,0.5,0.5,xTitle.c_str());
+
+    DLong xthick=0;
+    e->AssureLongScalarKWIfPresent("XTHICK",xthick);
+    actStream->wid(xthick);
+    // the axis (separate for x and y axis because of charsize)
+    PLFLT xintv;
+    if (xTicks == 0) {
+      xintv = AutoTick(xEnd-xStart);
+    } else {
+      xintv = (xEnd - xStart) / xTicks;
+    }
+    actStream->box( xOpt.c_str(), xintv, xMinor, "", 0.0, 0);
+//Y
+    actStream->wid(charthick);
+    actStream->schr( 0.0, actH/defH * yCharSize);
+    actStream->mtex("l",5.0,0.5,0.5,yTitle.c_str());
+    
+    DLong ythick=0;
+    e->AssureLongScalarKWIfPresent("YTHICK",ythick);
+    actStream->wid(ythick);
+    // the axis (separate for x and y axis because of charsize)
+    PLFLT yintv;
+    if (yTicks == 0) {
+      yintv = AutoTick(yEnd-yStart);
+    } else {
+      yintv = (yEnd - yStart) / yTicks;
+    }
+    actStream->box( "", 0.0, 0, yOpt.c_str(), yintv, yMinor);
+    // reset pen thickness
+    actStream->wid( 0);
+
+    // title and sub title
+    gkw_title(e, actStream, actH/defH);
+
+    // pen thickness for plot
+    gkw_thick(e, actStream);
+    gkw_symsize(e, actStream);
+    gkw_linestyle(e, actStream);
+
+    UpdateSWPlotStructs(actStream, xStart, xEnd, yStart, yEnd, xLog, yLog);
+
+  } // }}}
+  
+    private: void call_plplot(EnvT* e, GDLGStream* actStream) // {{{
+    {
+      // plot the data
+      static int nodataIx = e->KeywordIx( "NODATA"); 
+      if (!e->KeywordSet(nodataIx)) 
+      {
+        bool valid = draw_polyline(e, actStream, xVal, yVal, minVal, maxVal, doMinMax, xLog, yLog, psym, FALSE);
+        // TODO: handle valid?
+      }
+    } // }}}
+
+    private: void post_call(EnvT* e, GDLGStream* actStream) // {{{
+    {
+      actStream->lsty(1);//reset linestyle
+
+      // set ![XY].CRANGE
+      set_axis_crange("X", xStart, xEnd, xLog);
+      set_axis_crange("Y", yStart, yEnd, yLog);
+
+      //set ![x|y].type
+      set_axis_type("X",xLog);
+      set_axis_type("Y",yLog);
+    } // }}}
+
+  };
+
+  void plot(EnvT* e)
+  {
+    plot_call plot;
+    plot.call(e, 1);
+  }
+
+} // namespace
+
diff -ruN --exclude CVS gdl-0.9.2/src/plotting_plots.cpp gdl/src/plotting_plots.cpp
--- gdl-0.9.2/src/plotting_plots.cpp	2011-07-08 06:37:54.000000000 -0600
+++ gdl/src/plotting_plots.cpp	2012-03-05 08:35:07.000000000 -0700
@@ -1,331 +1,286 @@
-/***************************************************************************
-                       plotting.cpp  -  GDL routines for plotting
-                             -------------------
-    begin                : July 22 2002
-    copyright            : (C) 2002-2011 by Marc Schellens et al.
-    email                : m_schellens@users.sf.net
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "includefirst.hpp"
-#include "plotting.hpp"
-#include "math_utl.hpp"
-
-namespace lib {
-
-  using namespace std;
-
-  class plots_call : public plotting_routine_call
-  {
-
-    DDoubleGDL *xVal, *yVal, *zVal;
-    auto_ptr<BaseGDL> xval_guard, yval_guard;
-    DLong psym;
-    DDouble xStart, xEnd, yStart, yEnd, zStart, zEnd;
-    bool xLog, yLog;
-    SizeT xEl, yEl, zEl;
-    DDouble minVal, maxVal;
-
-    private: bool handle_args(EnvT* e) // {{{
-    {
-      if( nParam() == 1)
-      {
-        BaseGDL* p0;
-        p0 = e->GetParDefined( 0);  
-        if (p0->Dim(0) != 2)
-          e->Throw( "When only 1 param, dims must be (2,n)");
-
-        if (e->KeywordSet("T3D")) e->Throw("Only 3-argument case supported for T3D - FIXME!");
-        // TODO: the (3,n) case
-
-        DDoubleGDL *val = e->GetParAs< DDoubleGDL>( 0);
-
-        xEl = p0->N_Elements() / p0->Dim(0);
-        xVal = new DDoubleGDL( dimension( xEl), BaseGDL::NOZERO);
-        xval_guard.reset( xVal); // delete upon exit
-
-        yEl = p0->N_Elements() / p0->Dim(0);
-        yVal = new DDoubleGDL( dimension( yEl), BaseGDL::NOZERO);
-        yval_guard.reset( yVal); // delete upon exit
-
-        for( SizeT i = 0; i < xEl; i++) 
-        {
-	  (*xVal)[i] = (*val)[2*i];
-	  (*yVal)[i] = (*val)[2*i+1];
-        }
-      }
-      else if(nParam() == 2)
-      {
-        if (e->KeywordSet("T3D")) e->Throw("Only 3-argument case supported for T3D - FIXME!"); // TODO
-
-        xVal = e->GetParAs< DDoubleGDL>( 0);
-        xEl = xVal->N_Elements();
-
-        yVal = e->GetParAs< DDoubleGDL>( 1);
-        yEl = yVal->N_Elements();
-      }
-      else if(nParam() == 3)
-      {
-        zVal = e->GetParAs< DDoubleGDL>( 2);
-        zEl = zVal->N_Elements();
-
-        //if ((*zVal)[0] == 0 && zEl == 1) {
-          xVal = e->GetParAs< DDoubleGDL>( 0);
-          xEl = xVal->N_Elements();
-
-          yVal = e->GetParAs< DDoubleGDL>( 1);
-          yEl = yVal->N_Elements();
-	//}  
-        //else 
-        //{
-        //}
-      }
-    } // }}}
-
-  private: void old_body( EnvT* e, GDLGStream* actStream) // {{{
-  {
-    bool line;
-
-
-    // !X, !Y (also used below)
-    DFloat xMarginL, xMarginR, yMarginB, yMarginT; 
-    get_axis_margin("X",xMarginL, xMarginR);
-    get_axis_margin("Y",yMarginB, yMarginT);
-    // get ![XY].CRANGE
-    get_axis_crange("X", xStart, xEnd);
-    get_axis_crange("Y", yStart, yEnd);
-    if (e->KeywordSet("T3D")) get_axis_crange("Z", zStart, zEnd);
-
-    get_axis_type("X", xLog);
-    get_axis_type("Y", yLog);
-    
-//     if( xLog)
-//       {
-// 	xStart = pow(10.0,xStart);
-// 	xEnd   = pow(10.0,xEnd);
-//       }
-//     if( yLog)
-//       {
-// 	yStart = pow(10.0,yStart);
-// 	yEnd   = pow(10.0,yEnd);
-//       }
-    
-    //    int just = (e->KeywordSet("ISOTROPIC"))? 1 : 0;
-    /*    DLong background = p_background;
-    static int cix=e->KeywordIx("COLOR");
-    BaseGDL* color_arr=e->GetKW(cix);
-    DLongGDL* l_color_arr;
-
-    if(color_arr != NULL)
-      {
-	l_color_arr=static_cast<DLongGDL*>
-	  (color_arr->Convert2(LONG, BaseGDL::COPY));
-	if(color_arr->N_Elements() < minEl && color_arr->N_Elements() > 1)
-	  e->Throw( "Array "+e->GetParString(cix)+
-		    " does not have enough elements for COLOR keyword.");
-      }
-    DLong color = p_color;
-
-    if(color_arr != NULL)  
-      if(color_arr->N_Elements() >= 1) 
-	  	color=(*l_color_arr)[0];
-    */
-
-    // start drawing
-    gkw_background(e, actStream, false);
-    gkw_color(e, actStream);
-
-    gkw_psym(e, actStream, line, psym);
-    gkw_linestyle(e, actStream);
-    gkw_symsize(e, actStream);
-    gkw_thick(e, actStream);
-    DFloat charsize;
-    gkw_charsize(e,actStream, charsize, false);
-
-    // plplot stuff
-    PLFLT scrXL, scrXR, scrYB, scrYT;
-    actStream->gspa( scrXL, scrXR, scrYB, scrYT);
-    PLFLT scrX = scrXR-scrXL;
-    PLFLT scrY = scrYT-scrYB;
-
-    PLFLT xMR, xML, yMB, yMT;
-
-    CheckMargin( e, actStream,
-		 xMarginL, 
-		 xMarginR, 
-		 yMarginB, 
-		 yMarginT,
-		 xMR,
-		 xML,
-		 yMB,
-		 yMT);
-
-    bool mapSet=false;
-#ifdef USE_LIBPROJ4
-    // Map Stuff (xtype = 3)
-    LPTYPE idata;
-    XYTYPE odata;
-
-    get_mapset(mapSet);
-
-    if ( mapSet) {
-      ref = map_init();
-      if ( ref == NULL) {
-	e->Throw( "Projection initialization failed.");
-      }
-    }
-#endif
-
-    DDouble *sx, *sy;
-    DFloat *wx, *wy;
-    GetSFromPlotStructs(&sx, &sy);
-    GetWFromPlotStructs(&wx, &wy);
-
-    int toto=0;
-
-    if (!e->KeywordSet("T3D"))
-    {
-    if(e->KeywordSet("DEVICE")) {
-      PLFLT xpix, ypix;
-      PLINT xleng, yleng, xoff, yoff;
-      actStream->gpage(xpix, ypix,xleng, yleng, xoff, yoff);
-      xStart=0; xEnd=xleng;
-      yStart=0; yEnd=yleng;
-      xLog = false; yLog = false;
-      actStream->NoSub();
-      actStream->vpor(0, 1, 0, 1);
-    } else if(e->KeywordSet("NORMAL")) {
-      xStart = 0;
-      xEnd   = 1;
-      yStart = 0;
-      yEnd   = 1;
-      actStream->NoSub();
-      actStream->vpor(0, 1, 0, 1);
-      xLog = false; yLog = false;
-    } else {
-      toto=1;
-      actStream->NoSub();
-      if (xLog || yLog) actStream->vpor(wx[0], wx[1], wy[0], wy[1]);
-      else actStream->vpor(0, 1, 0, 1); // TODO (to be merged with the condition on DataCoordLimits...)
-    }
-    }
-
-    // Determine data coordinate limits (if mapSet is true)
-    // These are computed from window and scaling axis system
-    // variables because map routines change these directly.
-    
-    if (e->KeywordSet("DATA") || (toto == 1)) {
-      //    if (e->KeywordSet("NORMAL") || e->KeywordSet("DATA")) {
-      DataCoordLimits(sx, sy, wx, wy, &xStart, &xEnd, &yStart, &yEnd, xLog || yLog);
-    }
-
-    minVal=yStart; maxVal=yEnd;
-
-    //CLIPPING
-    DLong noclip = 1;
-    e->AssureLongScalarKWIfPresent( "NOCLIP", noclip);
-    if( noclip == 0)
-    {
-    static int clippingix = e->KeywordIx( "CLIP"); 
-    DDoubleGDL* clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
-    if( clippingD != NULL)
-      Clipping( clippingD, xStart, xEnd, minVal, maxVal);
-    }
-
-//    Comment out to fix bug [1560714] JMG 06/09/27
-//    if( xLog)
-//      {
-//	if( xStart <= 0.0) xStart = 0.0; else xStart = log10( xStart);
-//	if( xEnd   <= 0.0) return; else xEnd = log10( xEnd);
-//      }
-
-    if( yLog)
-      {
-	if( yStart <= 0.0) yStart = 0.0; else yStart = log10( yStart);
-	if( yEnd   <= 0.0) return; else yEnd = log10( yEnd);
-      }
-
-    if (!e->KeywordSet("T3D")) 
-    {
-      // SA: following a patch from Joanna (3029409) TODO: this is repeated in PLOTS POLYFILL and XYOUTS
-      if ( xEnd - xStart == 0 || yEnd - yStart == 0 || isnan(xStart) || isnan(yStart) ) {
-        actStream->wind( 0, 1, 0, 1 ); 
-      } else {
-        actStream->wind( xStart, xEnd, yStart, yEnd);
-      } 
-    }
-
-    // pen thickness for plot
-    gkw_thick(e, actStream);
-    gkw_symsize(e, actStream);
-    gkw_linestyle(e, actStream);
-
-  } // }}}
-
-    private: void call_plplot(EnvT* e, GDLGStream* actStream) // {{{
-    {
-      if (e->KeywordSet("T3D")) // TODO: check !P.T3D
-      {
-        Warning("PLOTS: 3D plotting does not really work yet (!P.T and !P.T3D are ignored for the moment)");
- /*       actStream->w3d(1.2, 1.2, 2.2, // TODO!
-          xStart, xEnd, yStart, yEnd, xStart, zEnd,
-          30, 30  // TODO!
-        );
-*/
-        PLINT n = xVal->N_Elements();
-        if (yEl > 1 && yEl < n) n = yEl;
-        if (zEl > 1 && zEl < n) n = zEl;
-
-        PLFLT *x = new PLFLT[n];
-        {
-          int a = (xEl != 1); 
-          for (PLINT i = 0; i < n; ++i) x[i] = (*xVal)[a * i];
-        }
-
-        PLFLT *y = new PLFLT[n];
-        {
-          int a = (yEl != 1); 
-          for (PLINT i = 0; i < n; ++i) y[i] = (*yVal)[a * i];
-        }
-
-        PLFLT *z = new PLFLT[n];
-        {
-          int a = (zEl != 1); 
-          for (PLINT i = 0; i < n; ++i) z[i] = (*zVal)[a * i];
-        }
-
-        actStream->line3(n, x, y, z);
-
-        delete[] x;
-        delete[] y;
-        delete[] z;
-      }
-      else 
-      {
-        bool valid = draw_polyline(e, actStream, xVal, yVal, xLog, yLog, yStart, yEnd, psym);
-        // TODO: handle valid?
-      }
-    } // }}}
-
-    private: virtual void post_call(EnvT*, GDLGStream* actStream) // {{{
-    {
-      actStream->lsty(1);//reset linestyle
-    } // }}}
-
-  }; // oplot_call class 
-
-  void plots(EnvT* e)
-  {
-    plots_call plots;
-    plots.call(e, 1);
-  }  
-
-} // namespace
+/***************************************************************************
+                       plotting.cpp  -  GDL routines for plotting
+                             -------------------
+    begin                : July 22 2002
+    copyright            : (C) 2002-2011 by Marc Schellens et al.
+    email                : m_schellens@users.sf.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "includefirst.hpp"
+#include "plotting.hpp"
+#include "math_utl.hpp"
+
+namespace lib {
+
+  using namespace std;
+
+  class plots_call : public plotting_routine_call
+  {
+
+    DDoubleGDL *xVal, *yVal, *zVal;
+    auto_ptr<BaseGDL> xval_guard, yval_guard;
+    DLong psym;
+    PLFLT xStart, xEnd, yStart, yEnd, zStart, zEnd;
+    PLFLT xMarginL, xMarginR, yMarginB, yMarginT;
+    bool xLog, yLog, xLogOrig, yLogOrig;
+    SizeT xEl, yEl, zEl;
+    bool append;
+
+    private: bool handle_args(EnvT* e) // {{{
+    {
+      append=e->KeywordSet("CONTINUE");
+      if( nParam() == 1)
+      {
+        BaseGDL* p0;
+        p0 = e->GetParDefined( 0);  
+        if (p0->Dim(0) != 2)
+          e->Throw( "When only 1 param, dims must be (2,n)");
+
+        if (e->KeywordSet("T3D")) e->Throw("Only 3-argument case supported for T3D - FIXME!");
+        // TODO: the (3,n) case
+
+        DDoubleGDL *val = e->GetParAs< DDoubleGDL>( 0);
+
+        xEl = p0->N_Elements() / p0->Dim(0);
+        xVal = new DDoubleGDL( dimension( xEl), BaseGDL::NOZERO);
+        xval_guard.reset( xVal); // delete upon exit
+
+        yEl = p0->N_Elements() / p0->Dim(0);
+        yVal = new DDoubleGDL( dimension( yEl), BaseGDL::NOZERO);
+        yval_guard.reset( yVal); // delete upon exit
+
+        for( SizeT i = 0; i < xEl; i++) 
+        {
+	  (*xVal)[i] = (*val)[2*i];
+	  (*yVal)[i] = (*val)[2*i+1];
+        }
+      }
+      else if(nParam() == 2)
+      {
+        if (e->KeywordSet("T3D")) e->Throw("Only 3-argument case supported for T3D - FIXME!"); // TODO
+
+        xVal = e->GetParAs< DDoubleGDL>( 0);
+        xEl = xVal->N_Elements();
+
+        yVal = e->GetParAs< DDoubleGDL>( 1);
+        yEl = yVal->N_Elements();
+        //silently drop unmatched values
+        if (yEl!=xEl)
+        {
+          SizeT size;
+          size=min(xEl,yEl);
+          xEl=size;
+          yEl=size;
+        }
+      }
+      else if(nParam() == 3)
+      {
+        zVal = e->GetParAs< DDoubleGDL>( 2);
+        zEl = zVal->N_Elements();
+
+        //if ((*zVal)[0] == 0 && zEl == 1) {
+          xVal = e->GetParAs< DDoubleGDL>( 0);
+          xEl = xVal->N_Elements();
+
+          yVal = e->GetParAs< DDoubleGDL>( 1);
+          yEl = yVal->N_Elements();
+        if (!(xEl==yEl && yEl==zEl))
+        {
+          SizeT size;
+          size=min(xEl,yEl);
+          size=min(size,zEl);
+          xEl=size;
+          yEl=size;
+          zEl=size;
+        }
+      }
+    } 
+
+  private: void old_body( EnvT* e, GDLGStream* actStream) // {{{
+  {
+    DDoubleGDL* clippingD=NULL;
+
+    actStream->gvpd(xMarginL,xMarginR,yMarginB,yMarginT);
+    if((xMarginL==0.0&&xMarginR==0.0)||(yMarginB==0.0&&yMarginT==0.0)) //if not initialized, set normalized mode
+    {
+        actStream->NoSub();
+        actStream->vpor(0, 1, 0, 1);
+        actStream->gvpd(xMarginL,xMarginR,yMarginB,yMarginT);
+        actStream->wind(0.0,1.0,0.0,1.0);
+   }
+    // get current viewport limit in world coords
+//    get_axis_crange("X",xStart,xEnd);
+//    get_axis_crange("Y",yStart,yEnd);
+    actStream->gvpw(xStart,xEnd,yStart,yEnd);
+    // get_axis_type
+    get_axis_type("X", xLogOrig); xLog=xLogOrig;
+    get_axis_type("Y", yLogOrig); yLog=yLogOrig;
+    
+    /*    DLong background = p_background;
+    static int cix=e->KeywordIx("COLOR");
+    BaseGDL* color_arr=e->GetKW(cix);
+    DLongGDL* l_color_arr;
+
+    if(color_arr != NULL)
+      {
+	l_color_arr=static_cast<DLongGDL*>
+	  (color_arr->Convert2(LONG, BaseGDL::COPY));
+	if(color_arr->N_Elements() < minEl && color_arr->N_Elements() > 1)
+	  e->Throw( "Array "+e->GetParString(cix)+
+		    " does not have enough elements for COLOR keyword.");
+      }
+    DLong color = p_color;
+
+    if(color_arr != NULL)  
+      if(color_arr->N_Elements() >= 1) 
+	  	color=(*l_color_arr)[0];
+    */
+  
+    bool mapSet=false;
+#ifdef USE_LIBPROJ4
+    // Map Stuff (xtype = 3)
+    LPTYPE idata;
+    XYTYPE odata;
+
+    get_mapset(mapSet);
+
+    if ( mapSet) {
+      ref = map_init();
+      if ( ref == NULL) {
+	e->Throw( "Projection initialization failed.");
+      }
+    }
+#endif
+    //CLIPPING
+    DLong noclip = 1; //PLOTS: default is not to clip, even when clip= is present. Only with noclip=0 a clip is done.
+    e->AssureLongScalarKWIfPresent( "NOCLIP", noclip);
+    if( noclip == 0)
+    {
+      static int clippingix = e->KeywordIx( "CLIP");
+      clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
+    }
+
+    if (!e->KeywordSet("T3D"))
+    {
+        actStream->NoSub();
+        if (e->KeywordSet("DEVICE"))
+      {
+        actStream->vpor(0, 1, 0, 1);
+        PLFLT xpix, ypix;
+        PLFLT un,deux,trois,quatre;
+        PLINT xleng, yleng, xoff, yoff;
+        actStream->gpage(xpix, ypix, xleng, yleng, xoff, yoff);
+        un=0.0; deux=xleng; trois=0.0; quatre=yleng;
+//        if( clippingD != NULL) Clipping( clippingD, un, deux, trois, quatre);
+        actStream->wind(un, deux, trois, quatre);
+        xLog = false;
+        yLog = false;
+      }
+      else if (e->KeywordSet("NORMAL"))
+      {
+        PLFLT un,deux,trois,quatre;
+        actStream->vpor(0, 1, 0, 1);
+        un=0.0; deux=1.0; trois=0.0; quatre=1.0;
+ //       if( clippingD != NULL) Clipping( clippingD, un, deux, trois, quatre);
+        actStream->wind(un, deux, trois, quatre);
+        xLog = false;
+        yLog = false;
+      }
+//      else if( clippingD != NULL)
+//      {
+//         PLFLT un,deux,trois,quatre;
+//         un=xStart; deux=xEnd; trois=yStart; quatre=yEnd;
+//         Clipping( clippingD, un, deux, trois, quatre);
+//         actStream->wind(un, deux, trois, quatre);
+//       }
+      else //with PLOTS, we can plot *outside* the box(e)s in DATA coordinates.
+      {
+        DDouble un, deux, trois, quatre;
+        getWorldCoordinatesFromPLPLOT(actStream, 0.0, 0.0, &un, &trois);
+        getWorldCoordinatesFromPLPLOT(actStream, 1.0, 1.0, &deux, &quatre);
+
+        actStream->vpor(0, 1, 0, 1);
+        actStream->wind((PLFLT)un, (PLFLT)deux, (PLFLT)trois, (PLFLT)quatre);
+      }
+   }
+    // start drawing. Graphic Keywords accepted: CLIP(YES), COLOR(OK), DATA(YES), DEVICE(YES),
+    //LINESTYLE(OK), NOCLIP(YES), NORMAL(YES), PSYM(OK), SYMSIZE(OK), T3D(NO), THICK(OK), Z(NO)
+    gkw_color(e, actStream); //COLOR
+    gkw_psym(e, psym); //PSYM
+    gkw_linestyle(e, actStream); //LINESTYLE
+    gkw_symsize(e, actStream); //SYMSIZE
+    gkw_thick(e, actStream); //THICK
+
+  } 
+
+    private: void call_plplot(EnvT* e, GDLGStream* actStream) // {{{
+    {
+      if (e->KeywordSet("T3D")) // TODO: check !P.T3D
+      {
+        Warning("PLOTS: 3D plotting does not really work yet (!P.T and !P.T3D are ignored for the moment)");
+ /*       actStream->w3d(1.2, 1.2, 2.2, // TODO!
+          xStart, xEnd, yStart, yEnd, xStart, zEnd,
+          30, 30  // TODO!
+        );
+*/
+        PLINT n = xVal->N_Elements();
+        if (yEl > 1 && yEl < n) n = yEl;
+        if (zEl > 1 && zEl < n) n = zEl;
+
+        PLFLT *x = new PLFLT[n];
+        {
+          int a = (xEl != 1); 
+          for (PLINT i = 0; i < n; ++i) x[i] = (*xVal)[a * i];
+        }
+
+        PLFLT *y = new PLFLT[n];
+        {
+          int a = (yEl != 1); 
+          for (PLINT i = 0; i < n; ++i) y[i] = (*yVal)[a * i];
+        }
+
+        PLFLT *z = new PLFLT[n];
+        {
+          int a = (zEl != 1); 
+          for (PLINT i = 0; i < n; ++i) z[i] = (*zVal)[a * i];
+        }
+
+        actStream->line3(n, x, y, z);
+
+        delete[] x;
+        delete[] y;
+        delete[] z;
+      }
+      else 
+      {
+        // there is no 'minmax' option for plots. 
+        bool valid = draw_polyline(e, actStream, xVal, yVal, 0.0, 0.0, false, xLog, yLog, psym, append);
+        // TODO: handle valid?
+      }
+    } 
+
+    private: virtual void post_call(EnvT*, GDLGStream* actStream) 
+    {
+      actStream->lsty(1);//reset linestyle
+      actStream->vpor(xMarginL, xMarginR, yMarginB, yMarginT);
+      actStream->wind(xStart, xEnd, yStart, yEnd);
+    } 
+
+  }; // oplot_call class 
+
+  void plots(EnvT* e)
+  {
+    plots_call plots;
+    plots.call(e, 1);
+  }  
+
+} // namespace
diff -ruN --exclude CVS gdl-0.9.2/src/plotting_polyfill.cpp gdl/src/plotting_polyfill.cpp
--- gdl-0.9.2/src/plotting_polyfill.cpp	2011-07-08 06:37:54.000000000 -0600
+++ gdl/src/plotting_polyfill.cpp	2012-01-26 17:01:33.000000000 -0700
@@ -134,14 +134,14 @@
     DDouble minVal = yStart, maxVal = yEnd;
 
     //CLIPPING
-    DLong noclip = 1;
-    e->AssureLongScalarKWIfPresent( "NOCLIP", noclip);
-    if (noclip == 0)
-    {
-      static int clippingix = e->KeywordIx( "CLIP"); 
-      DDoubleGDL* clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
-      if (clippingD != NULL) Clipping( clippingD, xStart, xEnd, minVal, maxVal);
-    }
+//    DLong noclip = 1;
+//    e->AssureLongScalarKWIfPresent( "NOCLIP", noclip);
+//    if (noclip == 0)
+//    {
+//      static int clippingix = e->KeywordIx( "CLIP");
+//      DDoubleGDL* clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
+//      if (clippingD != NULL) Clipping( clippingD, xStart, xEnd, minVal, maxVal);
+//    }
 
     // SA: following a patch from Joanna (3029409) TODO: this is repeated in PLOTS POLYFILL and XYOUTS
     if ( xEnd - xStart == 0 || yEnd - yStart == 0 || isnan(xStart) || isnan(yStart) ) {
diff -ruN --exclude CVS gdl-0.9.2/src/plotting_surface.cpp gdl/src/plotting_surface.cpp
--- gdl-0.9.2/src/plotting_surface.cpp	2011-07-08 06:37:54.000000000 -0600
+++ gdl/src/plotting_surface.cpp	2012-06-28 02:10:45.000000000 -0600
@@ -460,7 +460,8 @@
 	  xVec1[i] = (*xVal)[j*xEl+i];
 	  yVec1[i] = (*yVal)[j*xEl+i];
 	}
-	lib::mesh_nr(xVec1, yVec1, z1, (long int) xEl, 1,1);
+	//lib::mesh_nr(xVec1, yVec1, z1, (long int) xEl, 1,1);
+        actStream->mesh(xVec1, yVec1, z1, (long int) xEl, 1,1); 
       }
       delete[] z1;
       delete[] xVec1;
@@ -477,7 +478,8 @@
 	  xVec2[i] = (*xVal)[i*xEl+j];
 	  yVec2[i] = (*yVal)[i*xEl+j];
 	}
-	lib::mesh_nr(xVec2, yVec2, z2, 1, (long int) yEl, 2);
+	//lib::mesh_nr(xVec2, yVec2, z2, 1, (long int) yEl, 2);
+        actStream->mesh(xVec2, yVec2, z2, 1, (long int) yEl, 2); 
       }
       delete[] z2;
       delete[] xVec2;
@@ -485,7 +487,7 @@
     }
 
     // TODO: not sure if this is also valid for 3D?
-    UpdateSWPlotStructs(actStream, xStart, xEnd, yStart, yEnd);
+    UpdateSWPlotStructs(actStream, xStart, xEnd, yStart, yEnd, xLog, yLog);
 
     // title and sub title
     actStream->schr( 0.0, 1.25*actH/defH);
@@ -504,9 +506,9 @@
       actStream->lsty(1);//reset linestyle
 
       // set ![XY].CRANGE
-      set_axis_crange("X", xStart, xEnd);
-      set_axis_crange("Y", yStart, yEnd);
-      set_axis_crange("Z", zStart, zEnd);
+      set_axis_crange("X", xStart, xEnd, xLog);
+      set_axis_crange("Y", yStart, yEnd, yLog);
+      set_axis_crange("Z", zStart, zEnd, zLog);
 
       //set ![x|y].type
       set_axis_type("X", xLog);
diff -ruN --exclude CVS gdl-0.9.2/src/plotting_windows.cpp gdl/src/plotting_windows.cpp
--- gdl-0.9.2/src/plotting_windows.cpp	2011-07-02 09:14:05.000000000 -0600
+++ gdl/src/plotting_windows.cpp	2012-02-02 18:05:27.000000000 -0700
@@ -61,12 +61,9 @@
 	title = "GDL "+i2s( wIx);
       }
 
-    DLong xPos = 0;
-    if( e->KeywordPresent( 5)) // XPOS
-	e->AssureLongScalarKW( 5, xPos);
-    DLong yPos = 0;
-    if( e->KeywordPresent( 6)) // YPOS
-	e->AssureLongScalarKW( 6, yPos);
+    DLong xPos=0, yPos=0;
+    e->AssureLongScalarKWIfPresent( "XPOS", xPos);
+    e->AssureLongScalarKWIfPresent( "YPOS", yPos);
 
     DLong xSize, ySize;
     DeviceX::DefaultXYSize(&xSize, &ySize);
@@ -74,6 +71,12 @@
     e->AssureLongScalarKWIfPresent( "XSIZE", xSize);
     e->AssureLongScalarKWIfPresent( "YSIZE", ySize);
 
+    int debug=0;
+    if (debug) {
+      cout << "xPos/yPos   :"<<  xPos << " " << yPos << endl;
+      cout << "xSize/ySize :"<<  xSize << " " << ySize << endl;
+    }
+
     if( xSize <= 0 || ySize <= 0 || xPos < 0 || yPos < 0)
       e->Throw(  "Unable to create window "
 		 "(BadValue (integer parameter out of range for "
diff -ruN --exclude CVS gdl-0.9.2/src/plotting_xyouts.cpp gdl/src/plotting_xyouts.cpp
--- gdl-0.9.2/src/plotting_xyouts.cpp	2011-07-08 06:37:54.000000000 -0600
+++ gdl/src/plotting_xyouts.cpp	2012-01-26 17:01:33.000000000 -0700
@@ -75,7 +75,7 @@
     
     DDouble xStart, xEnd, yStart, yEnd;
     bool xLog, yLog;
-    DDouble minVal, maxVal;
+//    DDouble minVal, maxVal;
 
     get_axis_crange("X", xStart, xEnd);
     get_axis_crange("Y", yStart, yEnd);
@@ -106,7 +106,8 @@
 actStream->wid( 0);
 
 
-    //start drawing
+    //start drawing. KEYWORDS are: CLIP(NO), COLOR(PARTIALLY), DATA(YES) , DEVICE(YES) ,
+    // NORMAL(YES) , FONT(NO), ORIENTATION(YES), /NOCLIP(YES), T3D(NO), Z(NO)
     //    actStream->Background( background);
     //    actStream->Color( color);
     //    gkw_background(e, actStream);
@@ -141,7 +142,7 @@
     GetSFromPlotStructs(&sx, &sy);
     GetWFromPlotStructs(&wx, &wy);
 
-    int toto=0;
+    int isdatabydefault=0;
 
     if(e->KeywordSet("DEVICE")) {
       PLFLT xpix, ypix;
@@ -161,7 +162,7 @@
       actStream->vpor(0, 1, 0, 1);
       xLog = false; yLog = false;
     } else {
-      toto=1;
+      isdatabydefault=1;
       actStream->NoSub();
       if (xLog || yLog) actStream->vpor(wx[0], wx[1], wy[0], wy[1]);
       else actStream->vpor(0, 1, 0, 1); // (to be merged with the condition on DataCoordLimits...)
@@ -172,32 +173,26 @@
     // variables because map routines change these directly.
 
     //    if (e->KeywordSet("NORMAL") || e->KeywordSet("DATA")) {
-    if (e->KeywordSet("DATA") || (toto == 1)) {
+    if (e->KeywordSet("DATA") || (isdatabydefault == 1)) {
       DataCoordLimits(sx, sy, wx, wy, &xStart, &xEnd, &yStart, &yEnd, (xLog || yLog));
     }
 
-    minVal=yStart; maxVal=yEnd;
+//    minVal=yStart; maxVal=yEnd;
 
     //CLIPPING
-    DLong noclip=1;
-    e->AssureLongScalarKWIfPresent( "NOCLIP", noclip);
-    if(noclip == 0)
-      {
-	static int clippingix = e->KeywordIx( "CLIP"); 
-	DDoubleGDL* clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
-	if( clippingD != NULL)
-	    Clipping( clippingD, xStart, xEnd, minVal, maxVal);
-      }
+//    DLong noclip=1;
+//    e->AssureLongScalarKWIfPresent( "NOCLIP", noclip);
+//    if(noclip == 0)
+//      {
+//	static int clippingix = e->KeywordIx( "CLIP");
+//	DDoubleGDL* clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
+//	if( clippingD != NULL)
+//	    Clipping( clippingD, xStart, xEnd, minVal, maxVal);
+//      }
 
     // for orient
     PLFLT xScale = abs(xEnd - xStart), yScale = abs(yEnd - yStart);
 
-    // ??
-    if( yLog)
-      {
-	if( yStart <= 0.0) yStart = 0.0; else yStart = log10( yStart);
-	if( yEnd   <= 0.0) return; else yEnd = log10( yEnd);
-      }
 
     // SA: following a patch from Joanna (3029409) TODO: this is repeated in PLOTS POLYFILL and XYOUTS
     if ( xEnd - xStart == 0 || yEnd - yStart == 0 || isnan(xStart) || isnan(yStart) ) {
@@ -237,9 +232,10 @@
     DDouble alignment = 0.0;
     e->AssureDoubleScalarKWIfPresent( "ALIGNMENT", alignment);
 
-    //CHARSIZE
+    //CHARSIZE Note that SIZE is apparently used in some old implementations and
+    //seems to be supported silently with *DL. So we support it also:
     DFloat charsize;
-    gkw_charsize(e, actStream, charsize);
+    gkw_charsize_xyouts(e, actStream, charsize);
 
     // !P.MULTI vs. POSITION
     handle_pmulti_position(e, actStream);
diff -ruN --exclude CVS gdl-0.9.2/src/print.cpp gdl/src/print.cpp
--- gdl-0.9.2/src/print.cpp	2011-05-11 10:11:09.000000000 -0600
+++ gdl/src/print.cpp	2011-12-03 07:28:36.000000000 -0700
@@ -200,8 +200,8 @@
 
     // GDL magick (based on the Python interface code)
     static int printIx = LibProIx("PRINT");
-    EnvBaseT* env = new EnvT(NULL, libProList[printIx]);
-    auto_ptr<EnvBaseT> env_guard(env);
+    EnvT* env = new EnvT(NULL, libProList[printIx]);
+    auto_ptr<EnvT> env_guard(env);
     BaseGDL* par;
     env->SetNextPar(&par);
 
@@ -214,16 +214,16 @@
       env->SetKeyword("FORMAT", &e->GetKW(formatIx));
     }
 
-    // is it needed here?
-    StackSizeGuard<EnvStackT> guard( GDLInterpreter::CallStack());
-    GDLInterpreter::CallStack().push_back(env);
+//     // is it needed here? MS: not anymore :-)
+//     StackSizeGuard<EnvStackT> guard( GDLInterpreter::CallStack());
+//     GDLInterpreter::CallStack().push_back(env);
 
     // printing the title if TITLE keyword present
     static int titleIx = e->KeywordIx("TITLE");
     if (e->GetKW(titleIx) != NULL)
     {
       par = e->GetKW(titleIx);
-      static_cast<DLibPro*>(env->GetPro())->Pro()(static_cast<EnvT*>(env));
+      static_cast<DLibPro*>(env->GetPro())->Pro()( env);
     }
     
     // looping over the parameters
diff -ruN --exclude CVS gdl-0.9.2/src/pro/appleman.pro gdl/src/pro/appleman.pro
--- gdl-0.9.2/src/pro/appleman.pro	2010-01-20 04:41:56.000000000 -0700
+++ gdl/src/pro/appleman.pro	2012-01-02 14:20:38.000000000 -0700
@@ -1,50 +1,37 @@
-;$Id: appleman.pro,v 1.3 2010/01/20 11:41:56 slayoo Exp $
-pro AppleMan,xRange,yRange,RESULT=res
+pro AppleMan,xRange,yRange,RESULT=res,XSIZE=xS,YSIZE=yS,$
+              NoDisplay=NoDisplay, test=test, help=help
   on_error, 2
 ;+
 ;
-;
-;
 ; NAME:     appleman
 ;
-;
 ; PURPOSE:  Generate a GDL window showing the mandelbrot set.
 ;
-;
 ; CATEGORY: Demo
 ;
-;
-; CALLING SEQUENCE: appleman,[xRange,yRange,RESULT=result]
-;
-; 
+; CALLING SEQUENCE: appleman,[xRange,yRange,RESULT=result] 
 ;
 ; KEYWORD PARAMETERS: 
 ;     RESULT : the resulting byte array for further porcessing
 ;
-;
 ; COMMON BLOCKS: 
 ;
-;
 ; SIDE EFFECTS:
 ;
-;
 ; RESTRICTIONS:
 ;
-;
-; PROCEDURE:
-;
+; PROCEDURE: convergence or divergence of modulus of complex number
+;            after a given number of iterations
 ;
 ; EXAMPLE:
 ;
-;
-;
 ; MODIFICATION HISTORY:
 ; 	Written by: Marc Schellens 2004-12-01
-;
+;       2011-12-29: Alain : few extra keywords
 ;
 ;-
 ; LICENCE:
-; Copyright (C) 2004,
+; Copyright (C) 2004, 2011
 ; This program is free software; you can redistribute it and/or modify  
 ; it under the terms of the GNU General Public License as published by  
 ; the Free Software Foundation; either version 2 of the License, or     
@@ -55,54 +42,60 @@
 
 ;device,PSEUDO_COLOR=8,DECOMPOSED=0
 
-if n_elements( xRange) eq 0 then xRange = [ -1.0, 2.3]
-if n_elements( yRange) eq 0 then yRange = [ -1.3, 1.3]
-
+if KEYWORD_SET(help) then begin
+   print, 'pro AppleMan, xRange, yRange, RESULT=res, $'
+   print, '              NoDisplay=NoDisplay, test=test, help=help'
+   return
+endif
+;
+if N_ELEMENTS(xRange) eq 0 then xRange = [ -1.0, 2.3]
+if N_ELEMENTS(yRange) eq 0 then yRange = [ -1.3, 1.3]
+;
 iter = 255
 
-xS = 640
-yS = 512
+if ~keyword_set(xS) then xS = 640
+if ~keyword_set(yS) then yS = 512
 
 xD = float(xRange[1]-xRange[0])
 yD = float(yRange[1]-yRange[0])
 
 xStep = xD / xS
 yStep = yD / yS
+;
+xStartVec = LINDGEN( xS) * xStep + xRange[0]
+yStartVec = LINDGEN( yS) * yStep + yRange[0]
 
-xStartVec = lindgen( xS) * xStep + xRange[0]
-yStartVec = lindgen( yS) * yStep + yRange[0]
-
-constArr = complex( rebin( xStartVec, xS, yS),$
-                     rebin( transpose(yStartVec), xS, yS))
+constArr = COMPLEX(REBIN(xStartVec, xS, yS),$
+                   REBIN(TRANSPOSE(yStartVec), xS, yS))
 
-valArr = complexarr( xS, yS)
+valArr = COMPLEXARR( xS, yS)
 
-res = intarr( xS, yS)
+res = INTARR( xS, yS)
 
-oriIndex = lindgen( long(xS) * yS)
+oriIndex = LINDGEN( LONG(xS) * yS)
 
 for i = 0, iter-1 do begin
-
-    valArr = valArr^2 - constArr
-
-    whereIn = where( abs( valArr) le 4.0d, COMPLEMENT=whereOut)
-
-    if whereIn[0] eq -1 then break
-
-    valArr = valArr[ whereIn]
-
-    constArr = constArr[ whereIn]
-
-    if whereOut[0] ne -1 then begin
-
-        res[ oriIndex[ whereOut]] = i+1
-
-        oriIndex = oriIndex[ whereIn]
-    endif
+   ;;
+   valArr = valArr^2 - constArr
+   ;;
+   whereIn = WHERE((ABS(valArr) LE 4.0d), COMPLEMENT=whereOut)
+   ;;
+   if whereIn[0] eq -1 then break
+   ;;
+   valArr = valArr[ whereIn]
+   constArr = constArr[ whereIn]
+   ;;
+   if whereOut[0] ne -1 then begin
+      res[ oriIndex[ whereOut]] = i+1      
+      oriIndex = oriIndex[ whereIn]
+   endif
 endfor
 
-loadct,15
-
-tv,res
+if ~arg_present(res) || ~KEYWORD_SET(NoDisplay) then begin
+  loadct,15
+  tv,res
+endif
 
+if KEYWORD_SET(test) then STOP
+;
 end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/bilinear.pro gdl/src/pro/bilinear.pro
--- gdl-0.9.2/src/pro/bilinear.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/pro/bilinear.pro	2011-12-21 06:28:52.000000000 -0700
@@ -0,0 +1,56 @@
+; part of GNU Data Language - GDL 
+;-------------------------------------------------------------
+;+
+; NAME:
+;       BILINEAR
+; PURPOSE:
+;       Bilinearly regrid a 2D array on a set of x,y coordinates  
+; CATEGORY:
+;       Array Manipulation.
+; CALLING SEQUENCE:
+;       z2 = bilinear(z,x,y,missing=missing)
+; INPUTS:
+;       Z = input 2-d array.                   in
+;       X, Y : X and Y index positions where Z2 is to be estimated
+;       from Z
+;       missing: value for points falling outside the z boundaries
+; KEYWORD PARAMETERS:
+;       none
+; OUTPUTS:
+;       z2 = resulting array.                  out
+;
+; PROCEDURE:
+;       Uses INTERPOLATE /GRID
+;
+; MODIFICATION HISTORY:
+; 	Written by: 2011-12-17 G. Duvert (Initial import)
+;
+;-
+; LICENCE:
+; Copyright (C) 2011
+; This program is free software; you can redistribute it and/or modify  
+; it under the terms of the GNU General Public License as published by  
+; the Free Software Foundation; either version 2 of the License, or     
+; (at your option) any later version.                                   
+;
+;-
+;
+function BILINEAR, z, x, y, missing=missing
+;
+ON_ERROR, 2                     ;Return to caller if error
+;
+if (N_PARAMS() ne 3) then MESSAGE, 'Incorrect number of arguments.'
+;
+dimx=SIZE(x,/n_dimensions)
+dimy=SIZE(y,/n_dimensions)
+;
+if ((dimx gt 2) || (dimy gt 2)) then MESSAGE, 'X and Y must be 1D or 2D, max.'
+if ( dimx ne dimy ) then MESSAGE, 'X and Y must be of same dimension(s).'
+;
+if ((dimx eq 1) && (dimy eq 1)) then begin
+    return, INTERPOLATE(z, x, y, /GRID, missing=missing)
+endif else begin
+    return, INTERPOLATE(z, x, y, missing=missing)
+endelse
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/congrid.pro gdl/src/pro/congrid.pro
--- gdl-0.9.2/src/pro/congrid.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/pro/congrid.pro	2012-04-13 06:19:50.000000000 -0600
@@ -0,0 +1,142 @@
+; part of GNU Data Language - GDL 
+;-------------------------------------------------------------
+;+
+; NAME:
+;       CONGRID
+; PURPOSE:
+;       Shrink or expands an array (any dimensions) to any size,
+;       however only the first 3 dims (max) will be resized.
+; CATEGORY:
+;       Array Manipulation.
+; CALLING SEQUENCE:
+;       t2 = CONGRID(t,mx[,my[,mZ]])
+; INPUTS:
+;       t = input array.                       in
+;       mx, my, mz = new (output) array size.  in
+;       t2 = resulting array.                  out
+; KEYWORD PARAMETERS:
+;       /INTERPOLATE means do bilinear interpolation. Kept for
+;        compatibility but unused: interpolation IS linear.
+;       CUBIC=cubic: use a cubic interpolation. Currently limited by
+;       the availability of cubic interpolation in GDL's INTERPOLATE.
+;       /CENTERED means assume pixels centered.  This means
+;         the pixel at (0,[0,[0]]) is clipped to 1/4 size.
+;         Default is that pixel start (not center) is at index.'
+;       MISSING=missing gives a value for undefined pixels.
+;       /MINUS_ONE: option will be ignored. MISSING can be used instead.
+;       /HELP gives this help.'
+;
+; NOTE:
+;       CONGRID performs a resampling. Does not conserve Fluxes.
+; OUTPUTS:
+;       t2 = resulting array.                  out
+;
+; MODIFICATION HISTORY:
+; 	Written by: 2011-12-17 G. Duvert (Initial import)
+;
+;-
+; LICENCE:
+; Copyright (C) 2011
+; This program is free software; you can redistribute it and/or modify  
+; it under the terms of the GNU General Public License as published by  
+; the Free Software Foundation; either version 2 of the License, or     
+; (at your option) any later version.                                   
+;
+;-
+function CONGRID, t, mx, my, mz, $
+                  CENTER=center, $
+                  INTERP=interp, $
+                  CUBIC = cubic, $
+                  MINUS_ONE=minus_one, $
+                  MISSING=missing, $
+                  HELP=help, test=test
+
+npar=N_PARAMS()
+if (npar lt 2) or (npar gt 4) or KEYWORD_SET(help) then begin
+    print,' Shrink or expands an array (any dimensions) to any size,'
+    print,' however only the first 3 dims (max) will be resized.'
+    print,' CALLING SEQUENCE:'
+    print,'   t2 = congrid2(t,mx[,my][,mz])'
+    print,'   t = input array.                       in'
+    print,'   mx, my, mz = new (output) array size.  in'
+    print,'   t2 = resulting array.                  out'
+    print,' Keywords:'
+    print,'   /INTERPOLATE means do bilinear interpolation. Kept for'
+    print,'    compatibility but unused: interpolation IS linear.'
+    print,'   /CENTERED means assume pixels centered.  This means'
+    print,'   the pixel at (0,[0,[0]]) is clipped to 1/4 size.'
+    print,'   Default is that pixel start (not center) is at index.'
+    print,'   CUBIC=cubic: use a cubic interpolation. Currently limited by'
+    print,'   the availability of cubic interpolation in INTERPOLATE.'
+    print,'   /CENTERED means assume pixels centered.  This means'
+    print,'     the pixel at (0,[0,[0]]) is clipped to 1/4 size.'
+    print,'     Default is that pixel start (not center) is at index.'
+    print,'   MISSING=missing gives a value for undefined pixels.'
+    print,'   /MINUS_ONE: option will be ignored. MISSING can be used instead.'
+    print, '  /HELP gives this help.'
+    print,' NOTE: CONGRID performs a resampling. Does not conserve Fluxes.'
+    return,''
+endif
+;
+ON_ERROR, 2                   ;Return to caller if error
+;
+ndim = SIZE(t, /N_DIMENSIONS)
+dims = SIZE(t, /DIMENSIONS)
+;
+if(ndim gt 3) then $
+  MESSAGE, 'Warning, array dimensions >3, using non-standard CONGRID extension.', /informational
+;
+cflag = KEYWORD_SET(centered)	; 0=start, 1=centered.
+minone =  KEYWORD_SET(minus_one)
+nnbor = ~KEYWORD_SET(interp)  ; nearest neighbor is default for 1 and 2 dim
+;
+;  if (npar gt ndim+1) then message, 'Too many output dimensions.'
+;
+nopt=0
+IF (N_ELEMENTS(mx) NE 0) THEN BEGIN
+    fx= (minone gt 0)? 1.0D*(dims[0]-1)/(mx-1) : 1.0D*dims[0]/mx
+    x = (cflag gt 0) ?fx*FINDGEN(mx)+0.5 : fx*FINDGEN(mx)
+    nopt=1
+ENDIF
+;
+; if 2 dim my MUST be present!
+IF (N_ELEMENTS(my) EQ 0 && ndim ge 2) THEN MESSAGE, '2nd dimension not specified.'
+IF (N_ELEMENTS(my) NE 0 && ndim ge 2) THEN BEGIN
+    fy= (minone gt 0)? 1.0D*(dims[1]-1)/(my-1) : 1.0D*dims[1]/my
+    y = (cflag gt 0) ?fy*FINDGEN(my)+0.5 : fy*FINDGEN(my)
+    nopt=2
+ENDIF
+;
+; if 3 dim mz MUST be present!
+IF (N_ELEMENTS(mz) EQ 0 && ndim ge 3) THEN MESSAGE, '3rd dimension not specified.'
+
+IF (N_ELEMENTS(mz) NE 0 && ndim ge 3) THEN BEGIN
+    fz= (minone gt 0) ? 1.0D*(dims[2]-1)/(mz-1) : 1.0D*dims[2]/mz
+    z = (cflag gt 0) ?fz*FINDGEN(mz)+0.5 : fz*FINDGEN(mz)
+    nopt=3
+ENDIF
+;
+IF (nopt lt ndim) THEN BEGIN
+    ;; create a transposition vector
+    p=SHIFT(INDGEN(ndim),-nopt)
+    temp=TRANSPOSE(t,p)
+    CASE nopt OF
+        3: temp2 = INTERPOLATE(temp,x,y,z,/grid,cubic=cubic,missing=missing)
+        2: temp2 = INTERPOLATE(temp,x,y,/grid,nearest_neighbour=nnbor,cubic=cubic,missing=missing)
+        1: temp2 = INTERPOLATE(temp,x,/grid,nearest_neighbour=nnbor,cubic=cubic,missing=missing)
+    ENDCASE
+    p=SHIFT(INDGEN(ndim),nopt)
+    t2=TRANSPOSE(temp2,p)
+ENDIF ELSE BEGIN
+    CASE nopt OF
+        3: t2 = INTERPOLATE(t,x,y,z,/grid,cubic=cubic,missing=missing)
+        2: t2 = INTERPOLATE(t,x,y,/grid,nearest_neighbour=nnbor,cubic=cubic,missing=missing)
+        1: t2 = INTERPOLATE(t,x,/grid,nearest_neighbour=nnbor,cubic=cubic,missing=missing)
+    ENDCASE
+ENDELSE
+;
+if KEYWORD_SET(test) then STOP
+;
+return,t2
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/diag_matrix.pro gdl/src/pro/diag_matrix.pro
--- gdl-0.9.2/src/pro/diag_matrix.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/pro/diag_matrix.pro	2012-01-23 17:13:54.000000000 -0700
@@ -0,0 +1,100 @@
+;
+; limited version of DIAG_MATRIX
+; please report problems / examples / extensions
+;
+; Alain C., 23-JAN-2012, under GNU GPL v2 or later
+;
+function DIAG_MATRIX, input, position, $
+                      debug=debug, help=help, test=test
+;
+if N_PARAMS() EQ 0 then MESSAGE, 'Incorrect number of arguments.'
+;
+if KEYWORD_SET(help) then begin
+   print, 'function DIAG_MATRIX, input, position, $'
+   print, '                      debug=debug, help=help, test=test'
+   return, -1
+endif
+;
+if SIZE(input,/n_dim) GT 2 then begin
+   MESSAGE, 'Only 1 or 2 dimensions allowed '+input
+endif
+;
+if (SIZE(input,/n_dim) EQ 2) then begin
+   if N_PARAMS() EQ 1 then position=0
+   info_size=SIZE(input,/dim)
+   x=info_size[0]
+   y=info_size[1]
+   ;;   
+   diag=INDGEN(MIN([x,y]))
+   ;;
+   if (position EQ 0) then begin
+      xx=diag
+      yy=diag
+   endif
+   ;;
+   if (position GT 0) then begin
+      if (position GE x) then begin
+         MESSAGE, '% Specified offset to array is out of range: '+STRING(position)+' versus: '+STRING(x)
+      endif
+      xx=diag+position
+      xx=xx[WHERE(xx LT x)]
+      yy=diag[0:N_ELEMENTS(xx)-1]
+   endif  
+   if (position LT 0) then begin
+      if (ABS(position) GE y) then begin
+         MESSAGE, '% Specified offset to array is out of range: '+STRING(position)+' versus: '+STRING(y)
+      endif
+      yy=diag+ABS(position)
+      yy=yy[WHERE(yy LT y)]
+      xx=diag[0:N_ELEMENTS(yy)-1]
+   endif
+   resu=REFORM(input[xx,yy])
+   if KEYWORD_SET(debug) then begin
+      print, '-----------------------'
+      print, 'x :', x, ', y :', y, ', Position indice: ', position
+      print, 'input matrix :'
+      print, input
+      print, 'position XX :', xx
+      print, 'position YY :', yy
+      print, 'extracted vector :', resu
+   endif
+endif
+;
+if (SIZE(input,/n_dim) LE 1) then begin
+   if N_PARAMS() EQ 1 then position=0
+   nbp=N_ELEMENTS(input)+ABS(position)
+   resu=FLTARR(nbp,nbp)
+   diag=INDGEN(nbp)
+   if (position EQ 0) then begin
+      resu[diag,diag]=input
+      xx=diag
+      yy=diag
+   endif
+   if (position GT 0) then begin
+      xx=diag+position
+      xx=xx[WHERE(xx LT nbp)]
+      yy=diag[0:N_ELEMENTS(xx)-1]
+      resu[xx,yy]=input
+   endif
+   if (position LT 0) then begin
+      yy=diag+ABS(position)
+      yy=yy[WHERE(yy LT nbp)]
+      xx=diag[0:N_ELEMENTS(yy)-1]
+      resu[xx,yy]=input
+   endif
+   if KEYWORD_SET(debug) then begin
+      print, '-----------------------'
+      print, 'Position indice: ', position
+      print, 'input vector :', input
+      print, 'position XX :', xx
+      print, 'position YY :', yy
+      print, 'computed matrix :'
+      print, resu
+   endif      
+endif
+;
+if KEYWORD_SET(test) then STOP
+;
+return, resu
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/dicom/Makefile.in gdl/src/pro/dicom/Makefile.in
--- gdl-0.9.2/src/pro/dicom/Makefile.in	2011-11-01 17:46:37.000000000 -0600
+++ gdl/src/pro/dicom/Makefile.in	2012-06-28 03:54:55.000000000 -0600
@@ -103,6 +103,7 @@
 FGREP = @FGREP@
 GDLDATADIR = @GDLDATADIR@
 GREP = @GREP@
+GraphicsMagickConfig = @GraphicsMagickConfig@
 HAVE_64BIT_OS = @HAVE_64BIT_OS@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
diff -ruN --exclude CVS gdl-0.9.2/src/pro/file_lines.pro gdl/src/pro/file_lines.pro
--- gdl-0.9.2/src/pro/file_lines.pro	2010-01-14 16:03:57.000000000 -0700
+++ gdl/src/pro/file_lines.pro	2012-07-04 10:10:29.000000000 -0600
@@ -20,7 +20,9 @@
 ;
 ; COMMON BLOCKS: none
 ;
-; SIDE EFFECTS:  none
+; SIDE EFFECTS:  as is on July 2012, we still have problems related to
+;                WordExp() in "str.cpp", when a file is prefixed or
+;                suffixed by white space, FILE_TEST() returns "1" wrongly.
 ;
 ; RESTRICTIONS:  only for Unix (Unix, Linux and Mac OS X) systems
 ;
@@ -33,17 +35,22 @@
 ;   - 30/05/2008: Michael Mueller (U of Arizona) fixed inconsistent
 ;     handling of files that don't end in newline
 ;   - 14/01/2010: Lucio Baggio (LATMOS/CNRS) avoided shell interaction
+;   - 04/07/2012: Alain 
+;      * Correcting bug 3189065 : better message when no-existing file !
+;      * Correcting bug 3175753 : bad value when filename begin with number
+;      * managing input files list
 ;
 ;-
 ; LICENCE:
-; Copyright (C) 2006, Alain Coulais
+; Copyright (C) 2006, 2012 Alain Coulais
 ; This program is free software; you can redistribute it and/or modify  
 ; it under the terms of the GNU General Public License as published by  
 ; the Free Software Foundation; either version 2 of the License, or     
 ; (at your option) any later version.
 ;-
 ;
-function FILE_LINES, filename, compress=compress, noexpand_path=noexpand_path
+function FILE_LINES, filenames, compress=compress, noexpand_path=noexpand_path, $
+                     verbose=verbose, test=test
 ;
 ON_ERROR, 2    ;Return to caller
 if KEYWORD_SET(compress) then begin
@@ -56,13 +63,30 @@
     return, -1
 endif
 ;
-commande=["wc", "-l",filename]
-SPAWN, commande, resultat, /NOSHELL
-nbp=(LONG(STRCOMPRESS(resultat,/remove_all)))(0)
-commande=["tail","-c 1",filename]
-SPAWN, commande, resultat, /NOSHELL
-nbp += resultat NE ''
+nbp=LONARR(N_ELEMENTS(filenames))
 ;
-return, nbp
+for ii=0, N_ELEMENTS(filenames)-1 do begin
+    ;;
+    filename=filenames[ii]
+    if (FILE_TEST(filename) EQ 0) then begin
+        MESSAGE, 'Error opening file. File: '+filename
+    endif
+    ;;
+    commande=["wc", "-l",filename]
+    SPAWN, commande, resultat, /NOSHELL
+    nbp[ii]=(LONG((STRSPLIT(resultat,' ',/extract))[0]))
+    ;;nbp[ii]=(LONG(STRCOMPRESS(resultat,/remove_all)))(0)
+    ;;
+    ;; checking remaining missing bad endline
+    commande=["tail","-c 1",filename]
+    SPAWN, commande, resultat, /NOSHELL
+    nbp[ii] += resultat NE ''
+    ;;
+    if KEYWORD_SET(verbose) then print, filename, '  :  ', nbp[ii]
+endfor
+;
+if KEYWORD_SET(test) then STOP
+;
+if N_ELEMENTS(filenames) EQ 1 then return, nbp[0] else return, nbp
 ;
 end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/findex.pro gdl/src/pro/findex.pro
--- gdl-0.9.2/src/pro/findex.pro	2011-08-15 03:05:16.000000000 -0600
+++ gdl/src/pro/findex.pro	2012-02-27 18:08:50.000000000 -0700
@@ -1,97 +1,101 @@
- ;+
-   ; ROUTINE:  findex
-   ;
-   ; PURPOSE:  Compute "floating point index" into a table using binary
-   ;           search.  The resulting output may be used with INTERPOLATE.
-   ;
-   ; USAGE:    result = findex(u,v)
-   ;
-   ; INPUT:    
-   ;   u       a monotonically increasing or decreasing 1-D grid
-   ;   v       a scalar, or array of values
-   ;
-   ; OUTPUT:
-   ;   result  Floating point index. Integer part of RESULT(i) gives
-   ;           the index into to U such that V(i) is between
-   ;           U(RESULT(i)) and U(RESULT(i)+1).  The fractional part
-   ;           is the weighting factor
-   ;
-   ;                          V(i)-U(RESULT(i))
-   ;                          ---------------------
-   ;                     U(RESULT(i)+1)-U(RESULT(i))
-   ;
-   ;
-   ; DISCUSSION: 
-   ;           This routine is used to expedite one dimensional
-   ;           interpolation on irregular 1-d grids.  Using this routine
-   ;           with INTERPOLATE is much faster then IDL's INTERPOL
-   ;           procedure because it uses a binary instead of linear
-   ;           search algorithm.  The speedup is even more dramatic when
-   ;           the same independent variable (V) and grid (U) are used
-   ;           for several dependent variable interpolations.
-   ;
-   ;  
-   ; EXAMPLE:  
-   ;
-   ;; In this example I found the FINDEX + INTERPOLATE combination
-   ;; to be about 60 times faster then INTERPOL.
-   ;
-   ;  u=randomu(iseed,200000) & u=u(sort(u))
-   ;  v=randomu(iseed,10)     & v=v(sort(v))
-   ;  y=randomu(iseed,200000) & y=y(sort(y))
-   ;
-   ;  t=systime(1) & y1=interpolate(y,findex(u,v)) & print,systime(1)-t
-   ;  t=systime(1) & y2=interpol(y,u,v)            & print,systime(1)-t
-   ;  print,f='(3(a,10f7.4/))','findex:   ',y1,'interpol: ',y2,'diff:     ',y1-y2
-   ;
-   ; AUTHOR:   Paul Ricchiazzi                        21 Feb 97
-   ;           Institute for Computational Earth System Science
-   ;           University of California, Santa Barbara
-   ;           paul@icess.ucsb.edu
-   ;
-   ; REVISIONS:
-   ;
-   ; LICENCE: (note added by Sylwester Arabas)
-   ;  This code was posted by Paul Ricchiazzi at the comp.land.idl-pvwave 
-   ;  newsgroup on Feb 21 1997. The post mentions 'donating this procedure
-   ;  to the IDL community' - it is thus regarded as 'public domain' licence
-   ;  compatible with GNU GPL.
-   ;
-   ;-
-   ;
-   function findex,u,v
-   nu=n_elements(u)
-   nv=n_elements(v)
-
-   us=u-shift(u,+1)
-   us=us(1:*)
-   umx=max(us,min=umn)
-   if umx gt 0 and umn lt 0 then message,'u must be monotonic'
-   if umx gt 0 then inc=1 else inc=0
-
-   maxcomp=fix(alog(float(nu))/alog(2.)+.5) 
-
-   ; maxcomp = maximum number of binary search iteratios
-
-   jlim=lonarr(2,nv)
-   jlim(0,*)=0          ; array of lower limits
-   jlim(1,*)=nu-1       ; array of upper limits
-
-   iter=0
-   repeat begin
-     jj=(jlim(0,*)+jlim(1,*))/2
-     ii=where(v ge u(jj),n) & if n gt 0 then jlim(1-inc,ii)=jj(ii)
-     ii=where(v lt u(jj),n) & if n gt 0 then jlim(inc,ii)=jj(ii)
-     jdif=max(jlim(1,*)-jlim(0,*))
-     if iter gt maxcomp then begin
-       print,maxcomp,iter, jdif
-       message,'binary search failed'
-     endif
-     iter=iter+1
-   endrep until jdif eq 1 
-
-   w=v-v
-   w(*)=(v-u(jlim(0,*)))/(u(jlim(0,*)+1)-u(jlim(0,*)))+jlim(0,*)
-
-   return,w
-   end
+;+
+; ROUTINE:  findex
+;
+; PURPOSE:  Compute "floating point index" into a table using binary
+;           search.  The resulting output may be used with INTERPOLATE.
+;
+; USAGE:    result = findex(u,v)
+;
+; INPUT:    
+;   u       a monotonically increasing or decreasing 1-D grid
+;   v       a scalar, or array of values
+;
+; OUTPUT:
+;   result  Floating point index. Integer part of RESULT(i) gives
+;           the index into to U such that V(i) is between
+;           U(RESULT(i)) and U(RESULT(i)+1).  The fractional part
+;           is the weighting factor
+;
+;                          V(i)-U(RESULT(i))
+;                          ---------------------
+;                     U(RESULT(i)+1)-U(RESULT(i))
+;
+;
+; DISCUSSION: 
+;           This routine is used to expedite one dimensional
+;           interpolation on irregular 1-d grids.  Using this routine
+;           with INTERPOLATE is much faster then IDL's INTERPOL
+;           procedure because it uses a binary instead of linear
+;           search algorithm.  The speedup is even more dramatic when
+;           the same independent variable (V) and grid (U) are used
+;           for several dependent variable interpolations.
+;
+;  
+; EXAMPLE:  
+;
+;; In this example I found the FINDEX + INTERPOLATE combination
+;; to be about 60 times faster then INTERPOL.
+;
+;  u=randomu(iseed,200000) & u=u(SORT(u))
+;  v=randomu(iseed,10)     & v=v(SORT(v))
+;  y=randomu(iseed,200000) & y=y(SORT(y))
+;
+;  t=systime(1) & y1=interpolate(y,findex(u,v)) & print,systime(1)-t
+;  t=systime(1) & y2=interpol(y,u,v)            & print,systime(1)-t
+;  print,f='(3(a,10f7.4/))','findex:   ',y1,'interpol: ',y2,'diff:     ',y1-y2
+;
+; AUTHOR:   Paul Ricchiazzi                        21 Feb 97
+;           Institute for Computational Earth System Science
+;           University of California, Santa Barbara
+;           paul@icess.ucsb.edu
+;
+; REVISIONS:
+;
+; LICENCE: (note added by Sylwester Arabas)
+;  This code was posted by Paul Ricchiazzi at the comp.land.idl-pvwave 
+;  newsgroup on Feb 21 1997. The post mentions 'donating this procedure
+;  to the IDL community' - it is thus regarded as 'public domain' licence
+;  compatible with GNU GPL.
+;
+;-
+;
+function FINDEX, u, v, test=test
+;
+nu=N_ELEMENTS(u)
+nv=N_ELEMENTS(v)
+;
+us=u-SHIFT(u,+1)
+us=us(1:*)
+umx=max(us,min=umn)
+if umx gt 0 and umn lt 0 then MESSAGE,'u must be monotonic'
+if umx gt 0 then inc=1 else inc=0
+;
+maxcomp=FIX(ALOG(FLOAT(nu))/ALOG(2.)+.5) 
+;
+; maxcomp = maximum number of binary search iteratios
+;
+jlim=LONARR(2,nv)
+jlim(0,*)=0                     ; array of lower limits
+jlim(1,*)=nu-1                  ; array of upper limits
+;
+iter=0
+repeat begin
+   jj=(jlim(0,*)+jlim(1,*))/2
+   ii=WHERE(v ge u(jj),n) & if n gt 0 then jlim(1-inc,ii)=jj(ii)
+   ii=WHERE(v lt u(jj),n) & if n gt 0 then jlim(inc,ii)=jj(ii)
+   jdif=max(jlim(1,*)-jlim(0,*))
+   if iter gt maxcomp then begin
+      print, maxcomp, iter, jdif
+      MESSAGE, 'binary search failed'
+   endif
+   iter=iter+1
+endrep until jdif eq 1 
+;
+w=v-v
+w(*)=(v-u(jlim(0,*)))/(u(jlim(0,*)+1)-u(jlim(0,*)))+jlim(0,*)
+;
+if KEYWORD_SET(test) then STOP
+;
+return, w
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/get_login_info.pro gdl/src/pro/get_login_info.pro
--- gdl-0.9.2/src/pro/get_login_info.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/pro/get_login_info.pro	2012-01-24 06:30:03.000000000 -0700
@@ -0,0 +1,24 @@
+;
+; Under GNU GPL v2 or later
+; Alain C., 24-Jan-2012
+;
+; tested on various Linux and OSX ...
+;
+function GET_LOGIN_INFO
+;
+machine_name='Unknow'
+user_name='Unknow'
+;
+; it seems that it is better to use 'hostname' insteed 'hostname -s'
+;
+SPAWN, 'hostname', resu, exit_status=exit_status
+if (exit_status EQ 0) then machine_name=resu
+;
+SPAWN, 'whoami', resu, exit_status=exit_status
+if (exit_status EQ 0) then user_name=resu
+;
+return, {MACHINE_NAME: machine_name, $
+         USER_NAME: user_name}
+;
+end
+;
diff -ruN --exclude CVS gdl-0.9.2/src/pro/hist_equal.pro gdl/src/pro/hist_equal.pro
--- gdl-0.9.2/src/pro/hist_equal.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/pro/hist_equal.pro	2012-05-25 04:47:16.000000000 -0600
@@ -0,0 +1,197 @@
+;+
+;
+; NAME:
+;     HIST_EQUAL
+;
+; PURPOSE:
+;       Scales an input image by equalising its histogram. By setting
+;       a percent it can an also scale an image via a linear contrast.
+;
+; CATEGORY: Image processing.
+;
+; CALLING SEQUENCE: 
+;        Result = HIST_EQUAL(image, BinSIZE=value,
+;          Fcn=column_vector, Histogram_Only=value, Maxv=value,
+;          Minv=value, Omax=variable, Omin=variable, Percent=value,
+;          Top=value)
+;
+; KEYWORD PARAMETERS:
+;
+;       BINSIZE: The SIZE of the bin in which to construct the
+;        histogram. Defaulted to 1 for an image of type BYTE. The
+;        default for other data types is (maxv-minv)/5000double.
+;
+;       FCN: The cumulative probability distribution function. (Not
+;         currently implemented).
+;
+;       HISTOGRAM_ONLY: Returns the cumulative histogram of type Long.
+;
+;       MAXV: The maximum value of the original image to
+;        consider. Defaulted to 255 if image is of type BYTE,
+;        otherwise the image is searched for the maximum value.
+;
+;       MINV: The minimum value of the original image to
+;        consider. Default is 0 if image is of type BYTE, otherwise
+;        the image is searched for the minimum value.
+;
+;       PERCENT: If set to a value between 0 and 100, the histogram of
+;        the image will be linearly stretched between the upper and
+;        lower values found by the specified percent of the cumulative
+;        histogram.
+;
+;       TOP: The maximum value of the scaled result. Defaulted to 255.
+;
+; OUTPUTS: An image that is has been modified by its histogram. If the
+;       Histogram_Only keyword has been set, then the cumulative
+;       histogram (of type Long) will be output.
+;
+;
+; OPTIONAL OUTPUTS:
+;
+;   OMAX: Will contain the maximum value used for constructing the histogram.
+;   OMIN: Will contain the minimum value used for constructing the histogram.
+;
+; COMMON BLOCKS:
+;
+; SIDE EFFECTS:
+;
+; RESTRICTIONS:
+;
+;     The FCN keyword is currently not implemented.
+;
+; PROCEDURE:
+;     Sources:
+;     http://www.cacs.louisiana.edu/~cice/cacs508/fa11/lecture%2005%200908.pdf
+;     http://www.cis.rit.edu/class/simg782/lectures/lecture_05/lec782_05_05.pdf
+;
+; EXAMPLE:
+;       http://idlastro.gsfc.nasa.gov/idl_html_help/HIST_EQUAL.html
+;       image = dist(100)
+;       tv, image
+;       scl_img = hist_equal(image, minv=10, maxv=200, top=220)
+;       tv, scl_img
+;  
+;       window, 1, xSIZE=900, ySIZE=550
+;       !p.multi=[0,2,1]
+;       plot, histogram(image), title='Histogram'
+;       oplot, histogram(scl_img), color=255
+;       plot, total(histogram(image), /cumulative), title='Cumulative Histogram'
+;       oplot, total(histogram(scl_img), /cumulative), color=255
+;       xyouts, 0.2324805, 0.0200364, 'White = Original', /normal, charSIZE=2
+;       xyouts, 0.5795328, 0.0200364, 'Red = Equalised', /normal, charSIZE=2
+;
+; MODIFICATION HISTORY:
+;   01-May-2012 Written by:     Josh Sixsmith
+;   07-May-2012 Fixed percent keyword argument
+;   22-May-2012 Alain Coulais: Details (/help,/test), initial import in GDL
+;   25-May-2012 Alain: typo in LINEAR_PERCENT :( , formatting
+;
+;-
+; LICENCE:
+; Copyright (C) 2010, Josh Sixsmith
+; This program is free software; you can redistribute it and/or modify  
+; it under the terms of the GNU General Public License as published by  
+; the Free Software Foundation; either version 3 of the License, or     
+; (at your option) any later version.                                   
+;
+;-
+;
+pro LINEAR_PERCENT, cumuhist, percent, min, binSIZE, maxDN, minDN
+;
+n = cumuhist[N_ELEMENTS(cumuhist)-1]
+low = (percent/100.) 
+high = (1 - (percent/100.)) 
+;
+x1 = VALUE_LOCATE(cumuhist, n * low)
+if x1 eq -1 then x1 = 0
+while cumuhist[x1] eq cumuhist[x1 + 1] do begin
+    x1 = x1 + 1
+endwhile
+;
+close1 = abs(low - cumuhist[x1]/n)
+close2 = abs(low - cumuhist[x1 + 1]/n)
+x1 = (close1 le close2) ? x1 : x1 + 1
+minDN = x1 * binSIZE + min
+;
+x2 = VALUE_LOCATE(cumuhist, n * high)
+while cumuhist[x2] eq cumuhist[x2 - 1] do begin
+    x2 = x2 - 1
+endwhile
+;
+close1 = ABS(high - cumuhist[x2]/n)
+close2 = ABS(high - cumuhist[x2 + 1]/n)
+x2 = (close1 le close2) ? x2 : x2 + 1
+maxDN = x2 * binSIZE + min
+;
+end
+;
+; ------------------------------------
+;
+function HIST_EQUAL, img, binSIZE=bs, fcn=fcn, Histogram_Only=ho, $
+                     maxv=maxv, minv=minv, omax=omax_, omin=omin_, $
+                     percent=percent, Top=top_, $
+                     help=help, test=test
+;
+ON_ERROR, 2
+;
+if KEYWORD_SET(help) then begin
+    print, 'function HIST_EQUAL, img, binSIZE=bs, fcn=fcn, Histogram_Only=ho, $'
+    print, '                     maxv=maxv, minv=minv, omax=omax_, omin=omin_, $'
+    print, '                     percent=percent, Top=top_, $'
+    print, '                     help=help, test=test'
+    return, -1
+endif
+;
+txt='Cumulative Probability Distribution Function not currently supported'
+if KEYWORD_SET(fcn) then MESSAGE, txt
+;
+;    if (percent le 0) or (percent ge 100) then MESSAGE, 'Percent must be between 0 and 100'
+;
+if N_ELEMENTS(maxv) eq 0 then maxv = max(img, min=min_)
+if N_ELEMENTS(minv) eq 0 then minv = min_
+;
+if N_ELEMENTS(top_) eq 1 then top = top_[0] else top = 255
+;
+type = SIZE(img, /type)
+;
+if N_ELEMENTS(bs) eq 0 then begin
+    if type eq 1 then begin
+        bs = 1
+    endif else begin
+        ;; Calculate as double. Precision needed for very small values. 
+        bs = (maxv - minv)/5000d 
+    endelse
+endif
+;
+hist = HISTOGRAM(img, binSIZE=bs, omax=omax_, omin=omin_, max=maxv, min=minv)
+;; Zeroing the first element of the histogram
+hist[0] = 0
+;
+cumu = TOTAL(hist, /cumulative, /double)
+if KEYWORD_SET(ho) then return, long(cumu)
+;
+if N_ELEMENTS(percent) gt 0 then begin
+    if (percent le 0) or (percent ge 100) then MESSAGE, 'Percent must be between 0 and 100'
+    LINEAR_PERCENT, cumu, percent, minv, bs, maxDN, minDN
+    scl = BYTSCL(img, max=maxDN, min=minDN, top=top)
+    ;;
+    if KEYWORD_SET(test) then STOP
+    return, scl
+endif
+;
+bytsc = BYTSCL(cumu, top=top)
+;
+if SIZE(img, /type) eq 1 then begin
+    ;; Check for minv. Clip to zero if non zero
+    scl = (minv eq 0) ? bytsc[img] : bytsc[(img > minv) - minv]
+endif else begin
+    ;; Scale by the binSIZE to in order to get the bin position
+    ;; Check for minv. Clip to zero if non zero
+    scl = (minv eq 0) ? bytsc[img/bs] : bytsc[((img > minv) - minv)/bs]    
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+return, scl
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/identity.pro gdl/src/pro/identity.pro
--- gdl-0.9.2/src/pro/identity.pro	2011-02-27 12:05:38.000000000 -0700
+++ gdl/src/pro/identity.pro	2011-12-29 19:02:47.000000000 -0700
@@ -1,24 +1,18 @@
-;$Id: identity.pro,v 1.2 2011/02/27 19:05:38 slayoo Exp $
-
-function identity, n,double=double_keyword
-
+;$Id: identity.pro,v 1.3 2011/12/30 02:02:47 alaingdl Exp $
+function IDENTITY, n, double=double_keyword, help=help
 ;+
 ;
-;
-;
 ; NAME:
 ;    identity
 ;
 ; PURPOSE: 
 ;   returns an n x n identity matrix
 ;
-;
 ; CATEGORY:
 ;   Mathematics: Matrices
 ;
 ; CALLING SEQUENCE:
-;   i=identity(4)
-;
+;   i=IDENTITY(4)
 ;
 ; KEYWORD PARAMETERS: 
 ;     DOUBLE_KEYWORD : Keyword for double precision calculation
@@ -26,13 +20,12 @@
 ; OUTPUTS:
 ;     The identity matrix
 ;
-;
 ; PROCEDURE:
 ;     Creates an n x n matrix, fills the diagonal elements with the
 ;     value 1.0
 ;
 ; EXAMPLE:
-;     i = identity(4)
+;     i = IDENTITY(4)
 ;     print, i
 ;     1.00000    0.00000   0.0000    0.00000
 ;     0.00000    1.00000   0.0000    0.00000
@@ -41,32 +34,35 @@
 ;
 ; MODIFICATION HISTORY:
 ; 	Written by:  2004-03-20 Christopher Lee.
-;
+;                    2011-12-17 G. Duvert (if n==1 !)
 ;
 ;-
 ; LICENCE:
-; Copyright (C) 2004,
+; Copyright (C) 2004, 2011
 ; This program is free software; you can redistribute it and/or modify  
 ; it under the terms of the GNU General Public License as published by  
 ; the Free Software Foundation; either version 2 of the License, or     
 ; (at your option) any later version.                                   
 ;
-;
 ;-
-
-
-
-on_Error, 2
-if(keyword_set(double_keyword)) then begin
-    id=dblarr(n,n)
-    for i=0, n-1 do id[i,i]=1.0
+;
+ON_ERROR, 2
+;
+if KEYWORD_SET(help) then begin
+    print, "function IDENTITY, n, double=double_keyword, help=help"
+    return, -1
+endif
+;
+diag=INDGEN(n)
+;
+if (KEYWORD_SET(double_keyword)) then begin
+    id=DBLARR(n,n)
 endif else begin
-    id=fltarr(n,n)
-    for i=0, n-1 do id[i,i]=1.0d
+    id=FLTARR(n,n)
 endelse
-
+;
+id(diag,diag)=1
+;
 return, id
-
-
-
+;
 end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/image_statistics.pro gdl/src/pro/image_statistics.pro
--- gdl-0.9.2/src/pro/image_statistics.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/pro/image_statistics.pro	2011-11-15 08:16:50.000000000 -0700
@@ -0,0 +1,134 @@
+;+
+; NAME:    IMAGE_STATISTICS
+;
+; PURPOSE:
+;
+; CATEGORY:
+;
+;
+;
+; CALLING SEQUENCE:
+;
+;
+;
+; INPUTS:
+;
+;
+;
+; OPTIONAL INPUTS:
+;
+;
+;
+; KEYWORD PARAMETERS:
+;
+;
+;
+; OUTPUTS:
+;
+;
+;
+; OPTIONAL OUTPUTS:
+;
+;
+;
+; COMMON BLOCKS: none
+;
+; SIDE EFFECTS:
+;
+;
+;
+; RESTRICTIONS:
+;
+;
+;
+; PROCEDURE:
+;
+;
+;
+; EXAMPLE:
+;
+;
+; LICENCE: this code is under GNU GPL v2 or later. (C) 2011
+; 
+; MODIFICATION HISTORY:
+; -- first draft created by Alain Coulais, 10-Nov-2011
+; -- 15-Nov-2011 : AC : better managmenet of output types
+;
+;-
+;
+pro ImSt_MESS, keyword_name
+MESSAGE, /continue, 'This keyword '+STRUPCASE(keyword_name)+' is not available'
+MESSAGE, /continue, 'Please consider to contribute (by submitting Patches on SF.net)'
+end
+;
+pro IMAGE_STATISTICS, input_data, mask=mask, count=count, $
+                      data_sum=data_sum, maximum=maximum, $
+                      mean=mean_, minimum=minimum, $
+                      stddev=stddev_, sum_of_squares=sum_of_squares, $
+                      variance=variance_, $
+                      lut=lut, vector=vector, $
+                      weight_sum=weight_sum, weighted=weighted, $
+                      help=help, test=test, verbose=verbose
+;
+if N_PARAMS() NE 1 then MESSAGE, 'Incorrect number of arguments.'
+;
+if ((SIZE(input_data))[0] LT 1) then MESSAGE, 'Expression must be an array in this context'
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro IMAGE_STATISTICS, data, mask=mask, count=count, $'
+   print, '                data_sum=data_sum, maximum=maximum, $'
+   print, '                mean=mean_, minimum=minimum, $'
+   print, '                stddev=stddev_, sum_of_squares=sum_of_squares, $'
+   print, '                variance=variance_, $'
+   print, '                lut=lut, vector=vector, $'
+   print, '                weight_sum=weight_sum, weighted=weighted, $'
+   print, '                help=help, test=test, verbose=verbose'
+   return
+endif
+;
+if KEYWORD_SET(lut) then ImSt_MESS, 'lut'
+if KEYWORD_SET(vector) then ImSt_MESS, 'vector'
+if KEYWORD_SET(weight_sum) then ImSt_MESS, 'weight_sum'
+if KEYWORD_SET(weighted) then ImSt_MESS, 'weighted'
+;
+image=input_data
+if KEYWORD_SET(mask) then begin
+   OK=WHERE(mask NE 0, nbp_ok)
+   if (nbp_ok GT 0) then image=input_data[OK]
+endif
+;
+count=ULONG(N_ELEMENTS(image))
+data_sum=FLOAT(TOTAL(image,/double))
+mean_=FLOAT(MEAN(image,/double))
+maximum=MAX(image, min=minimum)
+maximum=FLOAT(maximum)
+minimum=FLOAT(minimum)
+sum_of_squares=FLOAT(TOTAL(image^2.D,/double))
+;
+if N_ELEMENTS(image) GT 1 then begin
+   stddev_=FLOAT(STDDEV(image,/double))
+   variance_=FLOAT(VARIANCE(image,/double))
+endif else begin
+   stddev_=0.0
+   variance_=0.0
+endelse
+;
+if KEYWORD_SET(verbose) then begin
+   if KEYWORD_SET(mask) then begin
+      print, 'Statistics on MASKED Image:'
+   endif else begin
+      print, 'Statistics on Image:'
+   endelse
+   print, 'Total Number of Pixels             = ', count
+   print, 'Total of Pixel Values              = ', data_sum
+   print, 'Maximum Pixel Value                = ', maximum
+   print, 'Mean of Pixel Values               = ', mean_
+   print, 'Minimum Pixel Value                = ', minimum
+   print, 'Standard Deviation of Pixel Values = ', stddev_
+   print, 'Total of Squared Pixel Values      = ', sum_of_squares
+   print, 'Variance of Pixel Values           = ', variance_
+endif
+;
+if KEYWORD_SET(test) then STOP
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/interpol.pro gdl/src/pro/interpol.pro
--- gdl-0.9.2/src/pro/interpol.pro	2011-08-15 03:05:16.000000000 -0600
+++ gdl/src/pro/interpol.pro	2012-03-05 07:50:55.000000000 -0700
@@ -1,55 +1,115 @@
+;
+; under GNU GPL v2 or later
+;
 ; by Sylwester Arabas <slayoo@igf.fuw.edu.pl>
 ; relies on findex.pro by Paul Ricchiazzi
-function interpol, p0, p1, p2, lsquadratic=lsquadratic, quadratic=quadratic, spline=spline
-  on_error, 2
-
-  ; sanity checks
-  if n_params() eq 1 then $
-    message, 'Two or three parameters required'
-  if keyword_set(lsquadratic) then $
-    message, 'LSQUADRATIC keyword not supported yet (FIXME!)'
-  if keyword_set(quadratic) then $
-    message, 'QUADRATIC keyword not supported yet (FIXME!)'
-
-;  if n_params() eq 3 and n_elements(p0) ne n_elements(p1) then $
-;    message, 'In the three-parameter case the first and second argument must be of equal length'
+;
+; revised 27-Feb-2012 by Alain C. after bug report 3495104
+; We have to manage also points in "p2" outside "p1" range ...
+; (new cases not include in testsuite/test_interpol.pro)
+;
+function INTERPOL, p0, p1, p2, lsquadratic=lsquadratic, $
+                   quadratic=quadratic, spline=spline, $
+                   test=test, help=help, debug=debug
+;
+ON_ERROR, 2
+;
+if KEYWORD_SET(help) then begin
+   print, 'function INTERPOL, p0, p1, p2, lsquadratic=lsquadratic, $'
+   print, '                   quadratic=quadratic, spline=spline, $'
+   print, '                   test=test, help=help, debug=debug'
+   print, '/lsquadratic and /quadratic not available, help welcome !'
+   return, -1
+endif
+;
+;; sanity checks
+;
+if N_PARAMS() eq 1 then $
+   MESSAGE, 'Two or three parameters required'
+if KEYWORD_SET(lsquadratic) then $
+   MESSAGE, 'LSQUADRATIC keyword not supported yet (FIXME!)'
+if KEYWORD_SET(quadratic) then $
+   MESSAGE, 'QUADRATIC keyword not supported yet (FIXME!)'
+;
+;  if N_PARAMS() eq 3 and N_ELEMENTS(p0) ne N_ELEMENTS(p1) then $
+;    MESSAGE, 'In the three-parameter case the first and second argument must be of equal length'
 ; <see bug no. 3104537>
-  if n_params() eq 3 then begin
-    if n_elements(p0) ne n_elements(p1) then $
-      message, 'In the three-parameter case the first and second argument must be of equal length'
-    all_equal_test=abs((p1 - shift(p1,+1))(1:*))
-    if min(temporary(all_equal_test)) eq 0 then message, $ ; usually only triggered for integer arrarys
-      'In the three-parameter case, the second argument must be strictly increasing or strictly decreasing.'
-  endif
+if N_PARAMS() eq 3 then begin
+   if N_ELEMENTS(p0) ne N_ELEMENTS(p1) then $
+      MESSAGE, 'In the three-parameter case the first and second argument must be of equal length'
+   ;;
+   ;; note by AC, 27-02-2012: is it really true ??
+   all_equal_test=ABS((p1 - SHIFT(p1,+1))(1:*))
+   if MIN(TEMPORARY(all_equal_test)) eq 0 then begin
+      MESSAGE, /cont, $         ; usually only triggered for integer arrays
+               'In the three-parameter case, the second argument must be strictly increasing or strictly decreasing.'
+   endif
+endif
 ; </...>
-
-  isint = size(p0, /ty) lt 4 || size(p0, /ty) gt 11
-
-  if n_params() eq 2 then begin
-    ; regular grid case
-    if size(p1, /dimensions) eq 0 then begin
-      ind = findgen(p1) / (p1 - (p1 eq 1 ? 0 : 1)) * (n_elements(p0) - 1)
-    endif else begin
-      message, 'In the two-parameter case the second parameter must be a scalar'
-      ; TODO: IDL does something else here...
-    endelse
-  endif else if ~keyword_set(spline) then begin
-    ; irregular grid case
-    ind = findex(p1, p2)
-  endif
-
-  if keyword_set(spline) then begin
-    ; spline case
-    if n_params() eq 2 then begin
-      x = findgen(n_elements(p0))
-      y = spl_interp(x, p0, spl_init(x, p0), ind)
-    endif else begin
-      y = spl_interp(p1, p0, spl_init(p1, p0), p2)
-    endelse
-    return, fix(temporary(y), type=size(p0, /type))
-  endif else begin
-    ; linear interpolation case
-    return, interpolate(isint ? float(p0) : p0, ind)
-  endelse
-
+;
+isint = SIZE(p0, /type) lt 4 || SIZE(p0, /type) gt 11
+;
+; AC 2012/03/05: useful values ... may be updated later
+nbp_inside=N_ELEMENTS(p0)
+nbp_outside=0
+;
+if N_PARAMS() eq 2 then begin
+   ;; regular grid case
+   if SIZE(p1, /dimensions) eq 0 then begin
+       ind = FINDGEN(p1) / (p1 - (p1 eq 1 ? 0 : 1)) * (N_ELEMENTS(p0) - 1)
+   endif else begin
+      MESSAGE, 'In the two-parameter case the second parameter must be a scalar'
+      ;; TODO: IDL does something else here...
+   endelse
+endif else if ~KEYWORD_SET(spline) then begin
+   ;; irregular grid case
+   ;; we need to manage points outside p1 range
+   p1_min=MIN(p1, max=p1_max)
+   outside_OK=WHERE((p2 LT p1_min) OR (p2 GT p1_max), nbp_outside)
+   if (nbp_outside GT 0) then begin
+      outside=p2[outside_OK]
+      inside_OK=WHERE((p2 GE p1_min) AND (p2 LE p1_max), nbp_inside)
+      if (nbp_inside GT 0) then begin
+         p2_inside=p2[inside_OK]
+         ind = FINDEX(p1, p2_inside)
+      endif      
+   endif else begin
+      ;; if we are here, all the points in "p2" are inside "p1" range
+      ind=FINDEX(p1,p2)
+   endelse
+endif
+;
+if KEYWORD_SET(spline) then begin
+   ;; spline case
+   if N_PARAMS() eq 2 then begin
+      x = FINDGEN(N_ELEMENTS(p0))
+      y = SPL_INTERP(x, p0, SPL_INIT(x, p0), ind)
+   endif else begin
+      y = SPL_INTERP(p1, p0, SPL_INIT(p1, p0), p2)
+   endelse
+   result=FIX(TEMPORARY(y), type=SIZE(p0, /type))
+endif else begin
+   ;; linear interpolation case
+   if (nbp_inside GT 0) then result=INTERPOLATE(isint ? FLOAT(p0) : p0, ind)
+   if (nbp_outside GT 0) then begin
+      tmp=p2
+      if (nbp_inside GT 0) then tmp[inside_OK]=result
+      last=N_ELEMENTS(p0)-1
+      slope_begin=(1.*p0[1]-p0[0])/(p1[1]-p1[0])
+      slope_end  =(1.*p0[last-1]-p0[last])/(p1[last-1]-p1[last])
+      for ii=0, nbp_outside-1 do begin
+         if outside[ii] LT p1_min then begin
+            tmp[outside_OK[ii]]=slope_begin*(outside[ii]-p1[0])+p0[0]
+         endif else begin
+            tmp[outside_OK[ii]]=slope_end*(outside[ii]-p1[last-1])+p0[last-1]
+         endelse
+      endfor
+      result=tmp
+   endif
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+return, result
+;
 end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/kurtosis.pro gdl/src/pro/kurtosis.pro
--- gdl-0.9.2/src/pro/kurtosis.pro	2005-07-25 01:33:25.000000000 -0600
+++ gdl/src/pro/kurtosis.pro	2012-07-13 16:28:02.000000000 -0600
@@ -1,27 +1,25 @@
-;$Id: kurtosis.pro,v 1.2 2005/07/25 07:33:25 m_schellens Exp $
-function kurtosis, x, double=double, NaN=NaN
-
-;+
+;$Id: kurtosis.pro,v 1.3 2012/07/13 22:28:02 alaingdl Exp $
 ;
+function KURTOSIS, x, double=double, NaN=NaN, dimension=dimension
 ;
+;+
 ;
-; NAME: 
-;       kurtosis
+; NAME: KURTOSIS
 ;
 ; PURPOSE: 
 ;     Calculates the kurtosis of the input data
 ;       
-;
 ; CATEGORY:
 ;     Mathematics: Statistics
 ;
 ; CALLING SEQUENCE:
 ;     Result=kurtosis(x)
 ;
-;
 ; KEYWORD PARAMETERS: 
 ;     DOUBLE : Keyword for double precision calculation
 ;     NAN    : Flag to treat IEEE Special Floating-Point values as missing data
+;     DIMENSION : if absent or equal to zero, compute the variance over the
+;                 whole data. otherwise, compute along the related dimension.
 ;
 ; OUTPUTS:
 ;    Result is the mean of input data
@@ -32,32 +30,35 @@
 ;    struct, ptr, object)
 ;
 ; PROCEDURE:
-;     kurtosis = 1/N sum((x-mean(x))^4/sqrt(variance(x))) - 3,
+;     kurtosis = 1/N sum((x-MEAN(x))^4/SQRT(VARIANCE(x))) - 3,
 ;     Uses the MOMENT function
 ;
 ; EXAMPLE:
-;     a=findgen(100)
-;     result=kurtosis(a)
+;     a=FINDGEN(100)
+;     result=KURTOSIS(a)
 ;     print, result
 ;     -1.23606
 ;
 ; MODIFICATION HISTORY:
 ;   20-Mar-2004 : Written by Christopher Lee
 ;   18-Jul-2005 : PC, moment.pro update
+;   13-Jul-2012 : Alain Coulais : adding DIMENSION keyword, using MOMENT()
 ;
 ; LICENCE:
-; Copyright (C) 2004, Christopher Lee
+; Copyright (C) 2004, Christopher Lee, 2005 P. Chanial, 2012 Alain Coulais
+;
 ; This program is free software; you can redistribute it and/or modify  
 ; it under the terms of the GNU General Public License as published by  
 ; the Free Software Foundation; either version 2 of the License, or     
 ; (at your option) any later version.                                   
 ;
-;
 ;-
-
- on_error, 2
- 
- m = moment(x, double=double, NaN=NaN)
- return, m[3]
-
+;
+ON_ERROR, 2
+;
+tmp=MOMENT(x, kurtosis=kurtosis, double=double, NaN=NaN, $
+           dimension=dimension, maxmoment=4)
+;
+return, kurtosis
+;
 end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/la_invert.pro gdl/src/pro/la_invert.pro
--- gdl-0.9.2/src/pro/la_invert.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/pro/la_invert.pro	2012-01-23 17:13:54.000000000 -0700
@@ -0,0 +1,11 @@
+;
+; A trivial wrap around for LA_INVERT,
+; for compatibility because it is used by iCosmo;
+; Alain C., 23-JAN-2012
+;
+function LA_INVERT, input, status=status, double=double
+;
+return, INVERT(input, status, double=double)
+;
+end
+
diff -ruN --exclude CVS gdl-0.9.2/src/pro/loadct.pro gdl/src/pro/loadct.pro
--- gdl-0.9.2/src/pro/loadct.pro	2011-03-31 20:21:49.000000000 -0600
+++ gdl/src/pro/loadct.pro	2012-03-14 19:07:08.000000000 -0600
@@ -93,10 +93,18 @@
 TVLCT,r,g,b,/GET
 
 if N_ELEMENTS( r_orig) eq 0 then begin
-
     r_orig = bytarr( !D.TABLE_SIZE)
     g_orig = bytarr( !D.TABLE_SIZE)
     b_orig = bytarr( !D.TABLE_SIZE)
+ endif
+
+if KEYWORD_SET(Ncolors) then begin
+   if N_ELEMENTS(Ncolors) NE 256 then begin
+      idx=Lindgen(Ncolors)*255/(Ncolors-1)
+      r=r[idx]
+      g=g[idx]
+      b=b[idx]
+   endif
 endif
 
 r_orig[bottom] = r
@@ -106,5 +114,7 @@
 g_curr = g_orig
 b_curr = b_orig
 
+TVLCT, r, g, b, bottom
+
 end
 
diff -ruN --exclude CVS gdl-0.9.2/src/pro/ludc.pro gdl/src/pro/ludc.pro
--- gdl-0.9.2/src/pro/ludc.pro	2010-04-21 15:48:07.000000000 -0600
+++ gdl/src/pro/ludc.pro	1969-12-31 17:00:00.000000000 -0700
@@ -1,7 +0,0 @@
-;
-; Alain Coulais, 21/04/2010, under GNU GPL 2 or later
-; fake LUDC to be able to run end-to-end IDL time_test3
-;
-pro LUDC, a,b,c
-MESSAGE, /Continue, 'Sorry, this procedure LUDC is not available'
-end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/Makefile.am gdl/src/pro/Makefile.am
--- gdl-0.9.2/src/pro/Makefile.am	2011-08-09 08:07:01.000000000 -0600
+++ gdl/src/pro/Makefile.am	2012-05-14 06:37:08.000000000 -0600
@@ -3,9 +3,12 @@
 prolib_DATA = \
   appleman.pro \
   array_indices.pro \
+  bilinear.pro \
   calendar.pro \
+  congrid.pro \
   correlate.pro \
   deriv.pro \
+  diag_matrix.pro \
   dialog_message.pro \
   dialog_pickfile.pro \
   dist.pro \
@@ -21,20 +24,23 @@
   filepath.pro \
   findex.pro \
   findfile.pro \
+  get_login_info.pro \
   helpform.pro \
   hist_2d.pro \
+  hist_equal.pro \
   hist_nd.pro \
   identity.pro \
   idl_validname.pro \
+  image_statistics.pro \
   imsl_erf.pro \
   imsl_zerosys.pro \
   interpol.pro \
   ishft.pro \
   kurtosis.pro \
+  la_invert.pro \
   last_item.pro \
   lmgr.pro \
   loadct.pro \
-  ludc.pro \
   map_clip_set.pro \
   matrix_multiply.pro \
   mean.pro \
@@ -64,6 +70,8 @@
   read_binary.pro \
   read_bmp.pro \
   read_dicom.pro \
+  read_gif.pro \
+  read_image.pro \
   read_jpeg.pro \
   read_pict.pro \
   read_png.pro \
@@ -80,8 +88,10 @@
   smooth.pro \
   spl_init_old.pro \
   spl_interp_old.pro \
+  standardize.pro \
   stddev.pro \
   str_sep.pro \
+  strmatch.pro \
   strsplit.pro \
   swap_endian.pro \
   swap_endian_inplace.pro \
@@ -93,6 +103,8 @@
   value_locate.pro \
   variance.pro \
   write_bmp.pro \
+  write_gif.pro \
+  write_image.pro \
   write_jpeg.pro \
   write_pict.pro \
   write_png.pro \
diff -ruN --exclude CVS gdl-0.9.2/src/pro/Makefile.in gdl/src/pro/Makefile.in
--- gdl-0.9.2/src/pro/Makefile.in	2011-11-01 17:46:37.000000000 -0600
+++ gdl/src/pro/Makefile.in	2012-06-28 03:54:55.000000000 -0600
@@ -158,6 +158,7 @@
 FGREP = @FGREP@
 GDLDATADIR = @GDLDATADIR@
 GREP = @GREP@
+GraphicsMagickConfig = @GraphicsMagickConfig@
 HAVE_64BIT_OS = @HAVE_64BIT_OS@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -266,9 +267,12 @@
 prolib_DATA = \
   appleman.pro \
   array_indices.pro \
+  bilinear.pro \
   calendar.pro \
+  congrid.pro \
   correlate.pro \
   deriv.pro \
+  diag_matrix.pro \
   dialog_message.pro \
   dialog_pickfile.pro \
   dist.pro \
@@ -284,20 +288,23 @@
   filepath.pro \
   findex.pro \
   findfile.pro \
+  get_login_info.pro \
   helpform.pro \
   hist_2d.pro \
+  hist_equal.pro \
   hist_nd.pro \
   identity.pro \
   idl_validname.pro \
+  image_statistics.pro \
   imsl_erf.pro \
   imsl_zerosys.pro \
   interpol.pro \
   ishft.pro \
   kurtosis.pro \
+  la_invert.pro \
   last_item.pro \
   lmgr.pro \
   loadct.pro \
-  ludc.pro \
   map_clip_set.pro \
   matrix_multiply.pro \
   mean.pro \
@@ -327,6 +334,8 @@
   read_binary.pro \
   read_bmp.pro \
   read_dicom.pro \
+  read_gif.pro \
+  read_image.pro \
   read_jpeg.pro \
   read_pict.pro \
   read_png.pro \
@@ -343,8 +352,10 @@
   smooth.pro \
   spl_init_old.pro \
   spl_interp_old.pro \
+  standardize.pro \
   stddev.pro \
   str_sep.pro \
+  strmatch.pro \
   strsplit.pro \
   swap_endian.pro \
   swap_endian_inplace.pro \
@@ -356,6 +367,8 @@
   value_locate.pro \
   variance.pro \
   write_bmp.pro \
+  write_gif.pro \
+  write_image.pro \
   write_jpeg.pro \
   write_pict.pro \
   write_png.pro \
diff -ruN --exclude CVS gdl-0.9.2/src/pro/mean.pro gdl/src/pro/mean.pro
--- gdl-0.9.2/src/pro/mean.pro	2005-07-25 01:33:25.000000000 -0600
+++ gdl/src/pro/mean.pro	2012-07-13 16:28:02.000000000 -0600
@@ -1,32 +1,29 @@
-;$Id: mean.pro,v 1.2 2005/07/25 07:33:25 m_schellens Exp $
-function mean, x, double=double, nan=nan
-
-;+
+;$Id: mean.pro,v 1.3 2012/07/13 22:28:02 alaingdl Exp $
 ;
+function MEAN, x, double=double, NaN=NaN, dimension=dimension
 ;
+;+
 ;
-; NAME: 
-;       mean
+; NAME: MEAN
 ;
 ; PURPOSE: 
 ;     Calculates the mean of the input data
 ;       
-;
 ; CATEGORY:
 ;     Mathematics: Statistics
 ;
 ; CALLING SEQUENCE:
 ;     Result=mean(x)
 ;
-;
 ; KEYWORD PARAMETERS: 
 ;     DOUBLE : Keyword for double precision calculation
 ;     NAN    : Flag to treat IEEE Special Floating-Point values as missing data
+;     DIMENSION : if absent or equal to zero, compute the variance over the
+;                 whole data. otherwise, compute along the related dimension.
 ;
 ; OUTPUTS:
 ;    Result is the mean of input data
 ;
-;
 ; RESTRICTIONS:
 ;    The input x needs to be an array of numbers (i.e not strings,
 ;    struct, ptr, object)
@@ -35,36 +32,42 @@
 ;     mean = 1/N sum(x)
 ;
 ; EXAMPLE:
-;     a=findgen(100)
-;     result=mean(a)
+;     a=FINDGEN(100)
+;     result=MEAN(a)
 ;     print, result
 ;     49.5000
 ;
 ; MODIFICATION HISTORY:
 ;   20-Mar-2004 : Written by Christopher Lee
 ;   18-Jul-2005 : Rewritten by Pierre Chanial
+;   13-Jul-2012 : Alain Coulais : adding DIMENSION keyword, using MOMENT()
 ;
 ; LICENCE:
-; Copyright (C) 2004, Christopher Lee
-;               2005, Pierre Chanial
+; Copyright (C) 2004, Christopher Lee, 2005 P. Chanial, 2012 Alain Coulais
+;
 ; This program is free software; you can redistribute it and/or modify  
 ; it under the terms of the GNU General Public License as published by  
 ; the Free Software Foundation; either version 2 of the License, or     
 ; (at your option) any later version.                                   
 ;
-;
 ;-
-
- on_error, 2
- 
- ; we don't call moment.pro, since it requires 2 or more elements
- if keyword_set(NaN) then begin
-    n = total(finite(x), double=double)
- endif else begin
-    n = n_elements(x)
- endelse
- 
- mean = total(x, double=double, NaN=NaN)/n
- return, mean
-
+;
+ON_ERROR, 2
+;
+; old version by PC, without Dimension
+; ; we don't call moment.pro, since it requires 2 or more elements
+; if keyword_set(NaN) then begin
+;    n = total(finite(x), double=double)
+; endif else begin
+;    n = n_elements(x)
+; endelse
+; 
+; mean = total(x, double=double, NaN=NaN)/n
+; return, mean
+;
+tmp=MOMENT(x, mean=mean, double=double, NaN=NaN, $
+           dimension=dimension, maxmoment=2)
+;
+return, mean
+;
 end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/moment.pro gdl/src/pro/moment.pro
--- gdl-0.9.2/src/pro/moment.pro	2010-10-13 16:55:48.000000000 -0600
+++ gdl/src/pro/moment.pro	2012-07-14 12:53:49.000000000 -0600
@@ -1,24 +1,20 @@
 function MOMENT, x, mdev=mdev, sdev=sdev, $
                  double=double, NaN=NaN, $
-                 maxmoment=maxmoment
+                 maxmoment=maxmoment, dimension=dimension, $
+                 kurtosis=kurtosis, mean=mean, $
+                 skewness=skewness, variance=variance
 ;+
 ;
-;
-;
-; NAME: 
-;       MOMENT
+; NAME: MOMENT
 ;
 ; PURPOSE: 
 ;     Calculates the following from the input data; mean, variance,
 ;     skewness, kurtosis, mean absolute deviation, standard deviation
 ;       
-;
 ; CATEGORY:
 ;     Mathematics: Statistics
 ;
-; CALLING SEQUENCE:
-;     Result=moment(x)
-;
+; CALLING SEQUENCE: Result=MOMENT(x)
 ;
 ; KEYWORD PARAMETERS: 
 ;     DOUBLE    : Keyword for double precision calculation
@@ -28,6 +24,10 @@
 ;                 2 - calculate mean, variance, mean absolute deviation and standard dev.
 ;                 3 - calculate all but kurtosis
 ;                 4 or 0 (keyword not present) - calculate all moments
+;     DIMENSION : if absent or equal to zero, compute the values
+;                 (moment, stddev, variance, skewness and kurtosis)
+;                 over the whole data. otherwise, compute along the related
+;                 dimension.
 ;
 ; OUTPUTS:
 ;    Result is a 4 element array, with
@@ -36,7 +36,7 @@
 ; OPTIONAL OUTPUTS:
 ;     MDEV   : Named variable which will contain the mean absolute deviation
 ;     SDEV   : Named variable which will contain the standard deviation
-;
+;     KURTOSIS, MEAN, SKEWNESS, VARIANCE: as named !
 ;
 ; RESTRICTIONS:
 ;    The input x needs to be an array of numbers (i.e not strings,
@@ -58,8 +58,8 @@
 ;     standard deviation = sqrt(variance)
 ;
 ; EXAMPLE:
-;     a=findgen(100)
-;     result=moment(a)
+;     a=FINDGEN(100)
+;     result=MOMENT(a)
 ;     print, result
 ;     49.5000    841.667     0.0000   1.73395
 ;
@@ -71,57 +71,88 @@
 ;   18-Jul-2005 : Rewritten by Pierre Chanial
 ;   10-Aug-2009 : MAXMOMENT keyword added by Sylwester Arabas
 ;   14-Oct-2010 : Correcting Bug in Kurtosis (by Alain C.)
-;
+;   16-Jun-2012 : Dimension Keyword (by Mathieu Pinter)
+;   14-Jul-2012 : check ASAP whether Dimension value is OK ... (by Alain C.)
 ;
 ; LICENCE:
 ; Copyright (C) 2004, Christopher Lee
 ;               2005, Pierre Chanial
 ;               2009, Sylwester Arabas
 ;               2010, Alain Coulais
+;               2012, Mathieu Pinter and Alain Coulais
 ; This program is free software; you can redistribute it and/or modify  
 ; it under the terms of the GNU General Public License as published by  
 ; the Free Software Foundation; either version 2 of the License, or     
 ; (at your option) any later version.                                   
 ;
-;
 ;-
-
-on_error, 2
+ON_ERROR, 2
 ;
 if (N_ELEMENTS(x) LE 1) then begin
    MESSAGE, 'Input Array must contain 2 OR more elements.'
 endif
 ;
 ; we don't reuse code in mean.pro, because we need variable n.
-if KEYWORD_SET(NaN) then begin
-   n = TOTAL(FINITE(x), double=double)
+;
+if KEYWORD_SET(dimension) then begin
+   ;; we check asap whether "dimension" in the good range
+   if ((dimension GT SIZE(x, /N_DIMENSION)) || (dimension LT 0)) then begin
+      MESSAGE, "Illegal keyword value for DIMENSION."
+   endif
+   dim = SIZE(x, /DIMENSION)
+   if KEYWORD_SET(NaN) then begin 
+      n = TOTAL(FINITE(x), dimension)
+   endif else begin
+      n = dim(dimension-1)
+   endelse
 endif else begin
-   n = N_ELEMENTS(x)
+   dimension = 0
+   if KEYWORD_SET(NaN) THEN BEGIN
+      n = TOTAL(FINITE(x), DOUBLE=double)
+   endif ELSE BEGIN
+      n = N_ELEMENTS(x)
+   endelse
 endelse
 ;
 ; if input is : print, MOMENT([1,!values.f_nan],/na)
 ;
-if (n LE 1) then begin
+if (TOTAL(n) LE 1) THEN BEGIN
    MESSAGE, 'Input Array must contain 2 OR more elements.'
 endif
 ; 
-; get the mean value in the required type (FLOAT or DOUBLE)
-; subsequent operations will rely on GDL automatic type conversion
+if ~KEYWORD_SET(maxmoment) THEN maxmoment = 4
 ;
-mean = TOTAL(x, double=double, NaN=NaN)/n
-x0   = x-mean
-;
-if ~KEYWORD_SET(maxmoment) then maxmoment = 4
+if dimension EQ 0 THEN BEGIN
+   ;;
+   ;; get the mean value in the required type (FLOAT or DOUBLE)
+   ;; subsequent operations will rely on GDL automatic type conversion
+   mean = TOTAL(x, DOUBLE=double, NaN=NaN)/n
+   x0   = x-mean
+   ;;
+   variance = maxmoment GE 2 ? TOTAL(x0^2, NaN=NaN)/(n-1)        : !VALUES.F_NAN
+   sdev     = maxmoment GE 2 ? SQRT(variance)                    : !VALUES.F_NAN 
+   skewness = maxmoment GE 3 ? TOTAL(x0^3, NaN=NaN)/sdev^3/n     : !VALUES.F_NAN
+   kurtosis = maxmoment GE 4 ? (TOTAL(x0^4, NaN=NaN)/sdev^4)/n-3 : !VALUES.F_NAN
+   result = [mean, variance, skewness, kurtosis]
+endif ELSE BEGIN
+   mean = TOTAL(x, dimension, DOUBLE=double, NaN=NaN)/n
+   dim2 = dim
+   dim2(dimension-1) = 1
+   if KEYWORD_SET(double) then nan1 = DBLARR(SIZE(mean, /DIMENSION)) 
+   if ~KEYWORD_SET(double) then nan1= FLTARR(SIZE(mean, /DIMENSION))
+   nan1(*) = !VALUES.F_NAN
+   x0 = (x-REBIN(REFORM(mean, dim2), dim))
+   variance = maxmoment GE 2 ? TOTAL((x0)^2, dimension, NaN=NaN)/(n-1)        : nan1
+   sdev     = maxmoment GE 2 ? SQRT(variance)                                 : nan1
+   skewness = maxmoment GE 3 ? TOTAL((x0)^3, dimension, NaN=NaN)/(n*sdev^3)   : nan1
+   kurtosis = maxmoment GE 4 ? TOTAL((x0)^4, dimension, NaN=NaN)/(n*sdev^4)-3 : nan1
+   result = [[[mean]], [[variance]], [[skewness]], [[kurtosis]]]
+endelse
 ;
-variance = maxmoment ge 2 ? TOTAL(x0^2, NaN=NaN)/(n-1)        : !VALUES.F_NAN
-sdev     = maxmoment ge 2 ? SQRT(variance)                    : !VALUES.F_NAN 
-skewness = maxmoment ge 3 ? TOTAL(x0^3, NaN=NaN)/sdev^3/n     : !VALUES.F_NAN
-kurtosis = maxmoment ge 4 ? (TOTAL(x0^4, NaN=NaN)/sdev^4)/n-3 : !VALUES.F_NAN
-
-if ARG_PRESENT(mdev) then begin
-   mdev = maxmoment ge 2 ? TOTAL(abs(x0), NaN=NaN)/n          : !VALUES.F_NAN
+if ARG_PRESENT(mdev) THEN BEGIN
+   mdev = maxmoment GE 2 ? TOTAL(ABS(x0), dimension, NaN=NaN)/n : !VALUES.F_NAN
 endif
 ;
-return, [mean, variance, skewness, kurtosis]
+return, result
 ; 
 end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/read_ascii.pro gdl/src/pro/read_ascii.pro
--- gdl-0.9.2/src/pro/read_ascii.pro	2009-10-18 16:03:55.000000000 -0600
+++ gdl/src/pro/read_ascii.pro	2011-11-15 17:51:17.000000000 -0700
@@ -1,5 +1,4 @@
 ;+
-;
 ; NAME: READ_ASCII
 ;
 ;
@@ -64,7 +63,7 @@
 ;   if field of different types are grouped together, the following priority
 ;   if assumed to determine the tag type:
 ;     BYTE<UINT<INT<ULONG<LONG<ULONG64<LONG64<FLOAT<DOUBLE<COMPLEX<DCOMPLEX
-;   Exception: grouping double and complex will result in a dcomplex
+;   Exception: grouping double and COMPLEX will result in a DCOMPLEX
 ;   No boundary check is made, so information could be lost.
 ;
 ;
@@ -82,7 +81,7 @@
 ;
 ;
 ; EXAMPLES:
-; t = {version:1.0, fieldnames : strsplit('fa,fb,fc,fd,fe,ff',',', /extr), $
+; t = {version:1.0, fieldnames : STRSPLIT('fa,fb,fc,fd,fe,ff',',', /extr), $
 ;      fieldtypes : [7, 4, 7, 2, 1, 5], fieldgroups : [0, 1, 2, 3, 4, 5], $
 ;      fieldcount: 6, fieldlocations:[0, 5, 9, 11, 14, 16], datastart:0, $
 ;      delimiter:'', missingvalue:-999, commentsymbol:';'}
@@ -98,10 +97,12 @@
 ; MODIFICATION HISTORY:
 ;   13-Jan-2006 : written by Pierre Chanial
 ;   06-APr-2008 : m_schellens: made data_start independent of header
+;   15-Nov-2011 : A. Coulais : better management of dir/file and
+;                 missing file
 ;
 ;-
 ; LICENCE:
-; Copyright (C) 2006, P. Chanial
+; Copyright (C) 2006, P. Chanial; 2011 A. Coulais
 ; This program is free software; you can redistribute it and/or modify
 ; it under the terms of the GNU General Public License as published by
 ; the Free Software Foundation; either version 2 of the License, or
@@ -109,283 +110,313 @@
 ;
 ;
 ;-
- 
-
-pro read_ascii_helper, tags, tag, structure, variable, default
- compile_opt hidden
+;
+pro READ_ASCII_HELPER, tags, tag, structure, variable, default
+;
+COMPILE_OPT hidden
 
- if n_elements(variable) ne 0 then return
- if n_elements(tags) eq 0 then begin
-    variable = default
-    return
- endif
- index = (where(tags eq tag, count))[0]
- if count eq 0 then begin
-    variable = default
- endif else begin
-    variable = structure.(index)
- endelse
+if N_ELEMENTS(variable) ne 0 then return
+if N_ELEMENTS(tags) eq 0 then begin
+   variable = default
+   return
+endif
+index = (WHERE(tags eq tag, count))[0]
+if count eq 0 then begin
+   variable = default
+endif else begin
+   variable = structure.(index)
+endelse;
 end
-
-function read_ascii_read, filename
- compile_opt hidden
- on_error, 2
- 
- if not file_test(filename) then message, 'Invalid filename'
- nline = file_lines(filename) 
- text = strarr(nline)
- openr, unit, filename, /get_lun
- readf, unit, text
- free_lun, unit
- return, text
- 
+;
+; -----------------------------------
+;
+function READ_ASCII_READ, filename
+;
+COMPILE_OPT hidden
+ON_ERROR, 2
+;
+if FILE_TEST(filename, /directory) then $
+   MESSAGE, 'this is not a file but a directory !'
+if not FILE_TEST(filename) then MESSAGE, 'Invalid filename'
+;
+nline = FILE_LINES(filename) 
+text = STRARR(nline)
+OPENR, unit, filename, /GET_LUN
+READF, unit, text
+FREE_LUN, unit
+return, text
+; 
 end
+;
+; -----------------------------------
+;
+function READ_ASCII_GETTYPE, types
 
-function read_ascii_gettype, types
- compile_opt hidden
- on_error, 2
- 
- priority = [ 0,  $; undefined
-              1,  $; byte
-              3,  $; int
-              5,  $; long
-              8,  $; float
-              9,  $; double
-              10, $; complex
-              99, $; string
-              0,  $; struct
-              11, $; dcomplex
-              0,  $; pointer
-              0,  $; object
-              2,  $; uint
-              4,  $; ulong
-              7,  $; long64
-              6   $; ulong64
- ]
- 
- p = max(priority[types], itype, min=status)
- if status eq 0 then message, 'Invalid field type.'
- type = types[itype]
+compile_opt hidden
+on_error, 2
 
- ; special case: double+complex -> dcomplex
- if max(types eq 5) and max(types eq 6) and (type ne 7) then type = 11
- 
- return, type
- 
+priority = [ 0,  $              ; undefined
+             1,  $              ; byte
+             3,  $              ; int
+             5,  $              ; long
+             8,  $              ; float
+             9,  $              ; double
+             10, $              ; COMPLEX
+             99, $              ; STRING
+             0,  $              ; struct
+             11, $              ; DCOMPLEX
+             0,  $              ; pointer
+             0,  $              ; object
+             2,  $              ; uint
+             4,  $              ; ulong
+             7,  $              ; long64
+             6   $              ; ulong64
+           ]
+ 
+p = MAX(priority[types], itype, min=status)
+if (status eq 0) then MESSAGE, 'Invalid field type.'
+type = types[itype]
+;
+; special case: double+COMPLEX -> DCOMPLEX
+if MAX(types eq 5) and MAX(types eq 6) and (type ne 7) then type = 11
+;
+return, type
+;
 end
+;
+; ----------------------------------
+;
 
-function read_ascii, filename, count=linecount, $
-                     data_start=data_start, delimiter=delimiter,               $
-                     missing_value=missing_value,comment_symbol=comment_symbol,$
+function READ_ASCII, filename, count=linecount, $
+                     data_start=data_start, delimiter=delimiter, $
+                     missing_value=missing_value, $
+                     comment_symbol=comment_symbol, $
                      num_records=num_records, record_start=record_start,   $
-                     template=template, header=header, verbose=verbose
-
- on_error, 2
-  
- if size(template, /tname) eq 'STRUCT' then begin
-    tags = tag_names(template)
-    deldefault = ''
- endif else begin
-    deldefault = ' 	'
- endelse
- read_ascii_helper, tags, 'DATASTART',     template, data_start,     0
- read_ascii_helper, tags, 'DELIMITER',     template, delimiter,      deldefault
- read_ascii_helper, tags, 'MISSINGVALUE',  template, missing_value,  'NaN'
- read_ascii_helper, tags, 'COMMENTSYMBOL', template, comment_symbol, ';'
- 
- text = read_ascii_read(filename)
-
- 
- ;----------------
- ; get the header
- ;----------------
-
- if arg_present(header) then begin
-    if data_start eq 0 then begin
-       if n_elements(header) ne 0 then junk = temporary(header)
-    endif else begin
-       header = text[0:data_start-1]
-       ;; text = text[data_start:*]
-    endelse
+                     template=template, header=header, $
+                     help=help, test=test, verbose=verbose
+;
+ON_ERROR, 2
+;
+if KEYWORD_SET(help) then begin
+   print, 'function READ_ASCII, filename, count=linecount, $'
+   print, '                     data_start=data_start, delimiter=delimiter, $'
+   print, '                     missing_value=missing_value, $'
+   print, '                     comment_symbol=comment_symbol, $
+   print, '                     num_records=num_records, record_start=record_start,   $'
+   print, '                     template=template, header=header, $'
+   print, '                     help=help, test=test, verbose=verbose'
+   return, -1
 endif
-
+;
+if (N_PARAMS() EQ 0) then begin
+; ~(FILE_INFO(filename)).exits then begin
+   filename=DIALOG_PICKFILE()
+endif
+;
+if SIZE(template, /tname) eq 'STRUCT' then begin
+   tags = tag_names(template)
+   deldefault = ''
+endif else begin
+   deldefault = ' 	'
+endelse
+READ_ASCII_HELPER, tags, 'DATASTART',     template, data_start,     0
+READ_ASCII_HELPER, tags, 'DELIMITER',     template, delimiter,      deldefault
+READ_ASCII_HELPER, tags, 'MISSINGVALUE',  template, missing_value,  'NaN'
+READ_ASCII_HELPER, tags, 'COMMENTSYMBOL', template, comment_symbol, ';'
+;
+text=READ_ASCII_READ(filename)
+;
+;----------------
+; get the header
+;----------------
+;
+if ARG_PRESENT(header) then begin
+   if data_start eq 0 then begin
+      if N_ELEMENTS(header) ne 0 then junk = TEMPORARY(header)
+   endif else begin
+      header = text[0:data_start-1]
+      ;; text = text[data_start:*]
+   endelse
+endif
+;
 if data_start ne 0 then begin
-    if data_start gt n_elements(text) - 1 then message, 'DATA_START value >= data length (' $
-      + strtrim(string(data_start), 2) + ' >= ' + strtrim(string(n_elements(text)),2) + ')' 
-    text = text[data_start:*]
+   if data_start gt N_ELEMENTS(text) - 1 then begin
+      MESSAGE, 'DATA_START value >= data length (' $
+               + STRTRIM(STRING(data_start), 2) + ' >= ' $
+               + STRTRIM(STRING(N_ELEMENTS(text)),2) + ')' 
+      text = text[data_start:*]
+   endif
+endif
+;
+;-----------------
+; remove comments
+;-----------------
+;
+if KEYWORD_SET(comment_symbol) then begin
+   pos = STRPOS(text, comment_symbol)
+   index = WHERE(pos ne -1, count)
+   for i=0, count-1 do begin
+      j = index[i]
+      text[j] = STRMID(text[j], 0, pos[j])
+   endfor
 endif
 
- 
- ;-----------------
- ; remove comments
- ;-----------------
-
- if keyword_set(comment_symbol) then begin
-    pos = strpos(text, comment_symbol)
-    index = where(pos ne -1, count)
-    for i=0, count-1 do begin
-       j = index[i]
-       text[j] = strmid(text[j], 0, pos[j])
-    endfor
- endif
- 
- 
- ;--------------------
- ; remove blank lines
- ;--------------------
-
- text = strtrim(text, 2)
- index = where(strlen(text) ne 0, linecount)
- if linecount eq 0 then return, 0
- text = text[index]
-
- 
- ;---------------------------
- ; get the requested records
- ;---------------------------
-
- if keyword_set(record_start) then begin
-    if record_start ge linecount then begin
-       message, 'Invalid record start ('+strtrim(record_start,1)+$
-                '): the file only has '+strtrim(linecount,1)+' lines.'
-    endif
-    text = text[record_start:*]
-    linecount = n_elements(text)
- endif
- 
- if keyword_set(num_records) then begin
-    if num_records gt linecount then begin
-       message, 'Excessive number of requested records.'
-    endif
-    text = text[0:num_records-1]
-    linecount = num_records
- endif
- 
- rnumber = '^[+-]?([0-9]*\.?[0-9]*[ed]?[+-]?[0-9]+\.?[0-9]*|NaN|Inf|Infinity)$'
-
- 
- ;------------------
- ; no-template case
- ;------------------
- 
- if n_elements(template) eq 0 then begin
-    ncolumns = lonarr(linecount)
-    for line=0l, linecount-1 do begin
-       ncolumns[line] = n_elements(strsplit(text[line], delimiter))
-    endfor
-    ncolumn = max(ncolumns)
-    result = make_array(ncolumn, linecount, /float, value=float(missing_value))
-    for line=0l, linecount-1 do begin
-       row = strsplit(text[line], delimiter, /extract)
-       index = where(stregex(row, rnumber, /fold_case, /boolean), count)
-       if count gt 0 then result[index, line] = float(row[index])
-    endfor
-    return, {field1:temporary(result)}
- endif
- 
- ; should take into account the field keyword, when RSI implements it.
- fieldcount  = template.fieldcount
- fieldtypes  = template.fieldtypes
- fieldnames  = template.fieldnames
- fieldlocs   = template.fieldlocations
- fieldgroups = template.fieldgroups
-
- strresult = strarr(fieldcount, linecount)
+;--------------------
+; remove blank lines
+;--------------------
+
+text = STRTRIM(text, 2)
+index = WHERE(STRLEN(text) ne 0, linecount)
+if linecount eq 0 then return, 0
+text = text[index]
+
+;---------------------------
+; get the requested records
+;---------------------------
+
+if KEYWORD_SET(record_start) then begin
+   if record_start ge linecount then begin
+      MESSAGE, 'Invalid record start ('+STRTRIM(record_start,1)+$
+               '): the file only has '+STRTRIM(linecount,1)+' lines.'
+   endif
+   text = text[record_start:*]
+   linecount = N_ELEMENTS(text)
+endif
 
- 
- ;-------------------------------------
- ; slice the file content into columns
- ;-------------------------------------
- 
- if keyword_set(delimiter) then begin
-    for line=0l, linecount-1 do begin
-       row = strsplit(text[line], string(delimiter), /extract)
-       strresult[0, line] = row
-    endfor
- endif else begin
-    for i=0l, fieldcount-2 do begin
-       strresult[i,*] = strmid(text, fieldlocs[i], fieldlocs[i+1]-fieldlocs[i])
-    endfor
-    strresult[i,*] = strmid(text, fieldlocs[i])
- endelse
- strresult = strtrim(strresult,2)
+if KEYWORD_SET(num_records) then begin
+   if num_records gt linecount then begin
+      MESSAGE, 'Excessive number of requested records.'
+   endif
+   text = text[0:num_records-1]
+   linecount = num_records
+endif
 
- 
- ;---------------------------
- ; get output structure info
- ;---------------------------
- 
- tagcount  = n_elements(uniq(fieldgroups, sort(fieldgroups)))
- tagncols  = lonarr(tagcount)
- tagnames  = strarr(tagcount)
- tagtypes  = intarr(tagcount)
- taggroups = lonarr(tagcount)
-
- ; get the group IDs of the tags, which are the unique elements of |fieldgroups|
- ; with preserved order (we can not use uniq)
- taggroups[0] = fieldgroups[0]
- itag = 1l
- for i=1l, fieldcount-1 do begin
-    if max(fieldgroups[i] eq taggroups[0:itag-1]) then continue
-    taggroups[itag++] = fieldgroups[i]
- endfor
-
- for i=0l, tagcount-1 do begin
-    index = where(fieldgroups eq taggroups[i], count)
-    tagncols[i] = count
-    tagnames[i] = fieldnames[index[0]]
-    tagtypes[i] = read_ascii_gettype(fieldtypes[index])
- endfor
- 
- 
- ;-----------------------------
- ; create the output structure
- ;-----------------------------
-
- ; deal with columns that will be grouped as a 2D array into a single tag
- dims = replicate(strtrim(linecount,1), tagcount)
- index = where(tagncols gt 1, count)
- if count gt 0 then dims[index] = strtrim(tagncols[index],1)+','+dims[index]
- 
- ; deal with the missing value. If it is not finite, use 0 for integers
- values = strarr(tagcount)
- index = where(tagtypes ne 7, count)
- if count gt 0 then values[index] = ', value=missing_value'
- 
- ; construct the statement
- arrays = 'make_array(dim=['+dims+'], type='+strtrim(tagtypes,1)+values+')'
- str = 'result={'+strjoin(tagnames+':'+arrays, ',')+'}'
- ok = execute(str)
+rnumber = '^[+-]?([0-9]*\.?[0-9]*[ed]?[+-]?[0-9]+\.?[0-9]*|NaN|Inf|Infinity)$'
 
- 
- ;---------------------------
- ; fill the output structure
- ;---------------------------
- 
- ; loop over the output structure tags
- for i=0l, tagcount-1 do begin
-    icol = where(fieldgroups eq taggroups[i], ncol)
-    ; loop over the columns in the same group
-    for j=0l, ncol-1 do begin
-       row = reform(strresult[icol[j],*])
-       if fieldtypes[i] eq 7 then begin
-          if ncol eq 1 then begin
-             result.(i) = row
-          endif else begin
-             result.(i)[j,*] = row
-          endelse
-       endif else begin
-          index = where(stregex(row, rnumber, /fold_case, /boolean), count)
-          if count eq 0 then continue
-          if ncol eq 1 then begin
-             result.(i)[index] = row[index]
-          endif else begin
-             result.(i)[j,index] = row[index]
-          endelse
-       endelse
-    endfor
- endfor
- 
- return, result
-    
+;------------------
+; no-template case
+;------------------
+
+if N_ELEMENTS(template) eq 0 then begin
+   ncolumns = LONARR(linecount)
+   for line=0l, linecount-1 do begin
+      ncolumns[line] = N_ELEMENTS(STRSPLIT(text[line], delimiter))
+   endfor
+   ncolumn = MAX(ncolumns)
+   result = MAKE_ARRAY(ncolumn, linecount, /float, value=FLOAT(missing_value))
+   for line=0l, linecount-1 do begin
+      row = STRSPLIT(text[line], delimiter, /extract)
+      index = WHERE(STREGEX(row, rnumber, /fold_case, /boolean), count)
+      if count gt 0 then result[index, line] = float(row[index])
+   endfor
+   return, {field1:TEMPORARY(result)}
+endif
+;
+; should take into account the field keyword, when RSI implements it.
+;
+fieldcount  = template.fieldcount
+fieldtypes  = template.fieldtypes
+fieldnames  = template.fieldnames
+fieldlocs   = template.fieldlocations
+fieldgroups = template.fieldgroups
+
+strresult = STRARR(fieldcount, linecount)
+
+
+;-------------------------------------
+; slice the file content into columns
+;-------------------------------------
+
+if KEYWORD_SET(delimiter) then begin
+   for line=0l, linecount-1 do begin
+      row = STRSPLIT(text[line], STRING(delimiter), /extract)
+      strresult[0, line] = row
+   endfor
+endif else begin
+   for i=0l, fieldcount-2 do begin
+      strresult[i,*] = STRMID(text, fieldlocs[i], fieldlocs[i+1]-fieldlocs[i])
+   endfor
+   strresult[i,*] = STRMID(text, fieldlocs[i])
+endelse
+strresult = STRTRIM(strresult,2)
+
+
+;---------------------------
+; get output structure info
+;---------------------------
+
+tagcount  = N_ELEMENTS(UNIQ(fieldgroups, SORT(fieldgroups)))
+tagncols  = LONARR(tagcount)
+tagnames  = STRARR(tagcount)
+tagtypes  = INTARR(tagcount)
+taggroups = LONARR(tagcount)
+
+; get the group IDs of the tags, which are the UNIQue elements of |fieldgroups|
+; with preserved order (we can not use UNIQ)
+taggroups[0] = fieldgroups[0]
+itag = 1l
+for i=1l, fieldcount-1 do begin
+   if max(fieldgroups[i] eq taggroups[0:itag-1]) then continue
+   taggroups[itag++] = fieldgroups[i]
+endfor
+
+for i=0l, tagcount-1 do begin
+   index = where(fieldgroups eq taggroups[i], count)
+   tagncols[i] = count
+   tagnames[i] = fieldnames[index[0]]
+   tagtypes[i] = read_ascii_gettype(fieldtypes[index])
+endfor
+
+
+;-----------------------------
+; create the output structure
+;-----------------------------
+
+; deal with columns that will be grouped as a 2D array into a single tag
+dims = replicate(STRTRIM(linecount,1), tagcount)
+index = where(tagncols gt 1, count)
+if count gt 0 then dims[index] = STRTRIM(tagncols[index],1)+','+dims[index]
+
+; deal with the missing value. If it is not finite, use 0 for integers
+values = STRARR(tagcount)
+index = where(tagtypes ne 7, count)
+if count gt 0 then values[index] = ', value=missing_value'
+
+; construct the statement
+arrays = 'MAKE_ARRAY(dim=['+dims+'], type='+STRTRIM(tagtypes,1)+values+')'
+str = 'result={'+STRJOIN(tagnames+':'+arrays, ',')+'}'
+ok = EXECUTE(str)
+
+;---------------------------
+; fill the output structure
+;---------------------------
+
+; loop over the output structure tags
+for i=0l, tagcount-1 do begin
+   icol = WHERE(fieldgroups eq taggroups[i], ncol)
+   ;; loop over the columns in the same group
+   for j=0l, ncol-1 do begin
+      row = REFORM(strresult[icol[j],*])
+      if fieldtypes[i] eq 7 then begin
+         if ncol eq 1 then begin
+            result.(i) = row
+         endif else begin
+            result.(i)[j,*] = row
+         endelse
+      endif else begin
+         index = WHERE(STREGEX(row, rnumber, /fold_case, /boolean), count)
+         if count eq 0 then continue
+         if ncol eq 1 then begin
+            result.(i)[index] = row[index]
+         endif else begin
+            result.(i)[j,index] = row[index]
+         endelse
+      endelse
+   endfor
+endfor
+;
+if KEYWORD_SET(test) then STOP
+;
+return, result
+;
 end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/read_gif.pro gdl/src/pro/read_gif.pro
--- gdl-0.9.2/src/pro/read_gif.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/pro/read_gif.pro	2011-11-30 06:33:09.000000000 -0700
@@ -0,0 +1,154 @@
+pro READ_GIF, filename, image, Red, Green, Blue, $
+              help=help, test=test, debug=debug
+;
+ON_ERROR, 2
+;+
+;
+; NAME: READ_GIF
+;
+; PURPOSE: Reads a GIF file into memory. This is a very limited
+; version, working on a 256 colors image.
+;
+; CATEGORY: Images (IO)
+;
+; CALLING SEQUENCE: 
+;      READ_GIF, filename, image, Red, Green, Blue
+;
+; KEYWORD PARAMETERS: 
+;
+; OUTPUTS: For true color images, data is a three dimensional array
+; with interleaving set by TRUE keyword
+;
+; OPTIONAL OUTPUTS: Red, Green, Blue
+;
+;
+; SIDE EFFECTS:
+;
+;
+; RESTRICTIONS:
+;         Requires ImageMagick (that means that GDL must have been
+;         compiled with ImageMagick)
+;
+; PROCEDURE:
+;         Use ImageMagick to read the data as requested
+;
+; EXAMPLE: An image of Saturn should be around in the GDL CVS
+;         file=FILE_WHICH('Saturn.jpg')
+;         READ_JPEG, file, image
+;         WRITE_GIF, 'Saturn.gif', image
+;         READ_GIF, 'Saturn.gif', image2, r, g, b
+;         TVLCT, r,g,b
+;         TV, image2
+;
+; MODIFICATION HISTORY:
+;    Written by: Alain Coulais : 2011-11-30, as a derivative work from READ_JPEG
+;-
+; LICENCE:
+; Copyright (C) 2011
+; This program is free software; you can redistribute it and/or modify  
+; it under the terms of the GNU General Public License as published by  
+; the Free Software Foundation; either version 2 of the License, or     
+; (at your option) any later version.                                   
+;
+;-
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro READ_GIF, filename, image, Red, Green, Blue, $'
+    print, '               help=help, test=test, debug=debug'
+    return
+endif
+;
+; Do we have access to ImageMagick functionnalities ??
+;
+if (MAGICK_EXISTS() EQ 0) then begin
+    MESSAGE, /continue, "GDL was compiled without ImageMagick support."
+    MESSAGE, "You must have ImageMagick support to use this functionaly."
+endif
+;
+; AC 2011-Aug-18: this test will be wrong when UNIT will be available
+if (N_PARAMS() EQ 0) then MESSAGE, "Incorrect number of arguments."
+;
+if (STRLEN(filename) EQ 0) then MESSAGE, "Null filename not allowed."
+if ((FILE_INFO(filename)).exists EQ 0) then MESSAGE, "Error opening file. File: "+filename
+if (FILE_TEST(filename, /regular) EQ 0) then MESSAGE, "Not a regular File: "+filename
+;
+if KEYWORD_SET(unit) then MESSAGE, "Keyword UNIT not supported"
+if KEYWORD_SET(buffer) then MESSAGE, "Keyword BUFFER not supported"
+;
+;
+MESSAGE, /continue, 'This is a very preliminary procedure, please report problems'
+MESSAGE, /continue, '(if possible with link to the input image/test case)'
+;
+if (not KEYWORD_SET(unit)) then mid=MAGICK_OPEN(filename)
+;
+colors=256
+;
+;;DITHER if necessary
+if (KEYWORD_SET(grayscale)) then begin
+    MAGICK_QUANTIZE, mid, /GRAYSCALE
+endif else begin
+   if (KEYWORD_SET(colors)) then begin
+      if ((colors LT 8) OR (colors GT 256)) then MESSAGE, "COLORS must be in the range 8 to 256"
+      if (KEYWORD_SET(two_pass_quantize)) then MESSAGE, "TWO_PASS_QUANTIZE not supported by ImageMagick."
+      MAGICK_QUANTIZE, mid, colors, dither=dither
+   endif
+endelse
+;
+;;flip if order is set
+;if (KEYWORD_SET(order)) then MAGICK_FLIP, mid
+;
+if (MAGICK_INDEXEDCOLOR(mid)) then begin
+    image=MAGICK_READINDEXES(mid)
+    MAGICK_READCOLORMAPRGB, mid, red, green, blue
+    ;;   colortable=[[red],[green],[blue]]
+endif else begin
+    image=MAGICK_READ(mid)
+endelse
+;
+if KEYWORD_SET(debug) then STOP
+;
+;; if 16-bit (unsigned short int) image convert to byte
+;; sz = SIZE(image)
+;; type = sz[sz[0]+1]
+;; if ((type EQ 2) OR (type EQ 12)) then begin
+;;     print, 'Converting 16-bit image to byte'
+;;     image = image / 256
+;;     image = BYTE(image)
+;; endif
+
+;;if (not KEYWORD_SET(unit)) then 
+MAGICK_CLOSE, mid
+;
+sz = SIZE(image)
+if (sz[0] EQ 2) then begin
+   image=ROTATE(image,7)
+endif
+if (sz[0] EQ 3) then begin
+   ;; "rotate" image to agree with IDL (JMG 08/18/04)
+   tmp = image[0,*,*]
+   image[0,*,*] = image[2,*,*]
+   image[2,*,*] = tmp
+   ;;
+   if KEYWORD_SET(TRUE) then begin
+      if (TRUE eq 1) then t=[0,1,2]
+      if (TRUE eq 2) then t=[1,0,2]
+      if (TRUE eq 3) then t=[1,2,0]
+      ;;
+      image=TRANSPOSE(image, t)
+      ;;  image=transpose(image[[2,1,0],*,*], t)
+   endif
+endif
+if (sz[0] GT 3) then begin
+    MESSAGE, /continue, $
+             "Dimensions of image > 3 : we don't know how to process now"
+endif
+;else begin
+;    image = image[[2,1,0],*,*]
+;endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+
+
+
diff -ruN --exclude CVS gdl-0.9.2/src/pro/read_image.pro gdl/src/pro/read_image.pro
--- gdl-0.9.2/src/pro/read_image.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/pro/read_image.pro	2012-02-15 08:09:52.000000000 -0700
@@ -0,0 +1,109 @@
+;+
+;
+; NAME: READ_IMAGE
+;
+; PURPOSE: Reads a image file (and colors tables) into memory
+;
+; CATEGORY: Images (IO)
+;
+; CALLING SEQUENCE: 
+;      READ_JPEG, filename, image, colortable
+;
+; KEYWORD PARAMETERS: 
+;        UNIT: not supported yet
+;        BUFFER: not supported yet
+;        COLORS: Number of colors to dither to (8->256)
+;        DITHER: Method of dithering to use
+;        GRAYSCALE: Return a grayscale image
+;        ORDER: flip the image in the vertical 
+;        TRUE: Interleaving (1:pixel, 2:line, 3:band)
+;        TWO_PASS_QUANTIZE: Not supported yet
+;
+; OUTPUTS: [n,m], [2,n,m], [3,n,m], [4,n,m] following image properties
+;          (transparency adds one extra Dim)
+;
+; OPTIONAL OUTPUTS: For pseudocolor only: Red, Green, Blue
+;
+; SIDE EFFECTS: 
+;
+; RESTRICTIONS:
+;         Requires ImageMagick (that means that GDL must have been
+;         compiled with ImageMagick)
+;
+; PROCEDURE:
+;         Use ImageMagick to read the data as requested
+;
+; EXAMPLE: An image of Saturn should be around in the GDL CVS
+;
+;         file=FILE_WHICH('Saturn.jpg')
+;         image=READ_IMAGE(file, image)
+;         TV, image, /true
+;
+; MODIFICATION HISTORY:
+;  Initial version written by: Alain Coulais, 2012-02-15
+;  2012-Feb-12, Alain Coulais :
+;
+;-
+; LICENCE:
+; Copyright (C) 2012
+; This program is free software; you can redistribute it and/or modify  
+; it under the terms of the GNU General Public License as published by  
+; the Free Software Foundation; either version 2 of the License, or     
+; (at your option) any later version.                                   
+;
+;-
+;
+function READ_IMAGE, filename, red, green, blue, $
+                     image_index=image_index, $
+                     help=help, test=test
+;
+if KEYWORD_SET(help) then begin
+   print, 'function READ_IMAGE, filename, red, green, blue, $'
+   print, '                    image_index=image_index, $'
+   print, '                    help=help, test=test'
+   return, -1
+endif
+;
+; Do we have access to ImageMagick functionnalities ??
+;
+if (MAGICK_EXISTS() EQ 0) then begin
+    MESSAGE, /continue, "GDL was compiled without ImageMagick support."
+    MESSAGE, "You must have ImageMagick support to use this functionaly."
+ endif
+;
+if ((N_PARAMS() EQ 0) OR (N_PARAMS() GT 4)) then $
+   MESSAGE, "Incorrect number of arguments."
+;
+if (STRLEN(filename) EQ 0) then MESSAGE, "Null filename not allowed."
+if ((FILE_INFO(filename)).exists EQ 0) then MESSAGE, "Error opening file. File: "+filename
+if (FILE_TEST(filename, /regular) EQ 0) then MESSAGE, "Not a regular File: "+filename
+;
+; First, we have to test whether the file is here
+;
+status=QUERY_IMAGE(filename, info)
+;
+if (status EQ 0) then begin
+   MESSAGE, 'Not a valid image file: '+filename
+endif
+;
+case info.type of
+   'JPEG' : begin
+      if (info.has_palette EQ 1) then begin
+         READ_JPEG, filename, image, colortable, colors=256
+         red=REFORM(colortable[*,0])
+         green=REFORM(colortable[*,1])
+         blue=REFORM(colortable[*,2])
+      endif else begin
+         READ_JPEG, filename, image
+      endelse
+   end
+   'PNG' : READ_PNG, filename, image, red, green, blue
+   'GIF' : READ_GIF, filename, image, red, green, blue
+   else: MESSAGE, 'This format is not managed today, please contribute'
+endcase
+;
+if KEYWORD_SET(test) then STOP
+;
+return, image
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/read_jpeg.pro gdl/src/pro/read_jpeg.pro
--- gdl-0.9.2/src/pro/read_jpeg.pro	2011-08-18 11:39:08.000000000 -0600
+++ gdl/src/pro/read_jpeg.pro	2012-02-07 16:23:25.000000000 -0700
@@ -1,9 +1,9 @@
-;$Id: read_jpeg.pro,v 1.6 2011/08/18 17:39:08 alaingdl Exp $
+;$Id: read_jpeg.pro,v 1.13 2012/02/07 23:23:25 alaingdl Exp $
 
 pro READ_JPEG, filename, unit=unit, image, colortable, buffer=buffer, $
                colors=colors, dither=dither, grayscale=grayscale, order=order, $
                true=true, two_pass_quantize=two_pass_quantize, $
-               help=help, test=test
+               help=help, test=test, debug=debug
 ;
 ON_ERROR, 2
 ;+
@@ -49,27 +49,31 @@
 ;         READ_JPEG, file, image
 ;
 ; MODIFICATION HISTORY:
-; 	Written by: Christopher Lee 2004-05-17
-;       2006-May-02, Joel Gales    : Add convert to byte if 16-bit image
-;       2011-Aug-18, Alain Coulais : More checks on inputs, verify if
+;  Written by: Christopher Lee 2004-05-17
+;  2006-May-02, Joel Gales    : Add convert to byte if 16-bit image
+;  2011-Aug-18, Alain Coulais : More checks on inputs, verify if
 ;       compiled with ImageMagick support !
+;  2011-Nov-09, Alain Coulais : correction for bug 3435468
+;       Grayscale (2D case)
+;  2012-Feb-07, Alain Coulais : new test cases in testsuite:
+;   test_read_standard_images.pro : 2 JPEG and 4 PNG (2 with transparency)
+;   The transpose for 2D image is no more need.
 ;
 ;-
 ; LICENCE:
-; Copyright (C) 2004, 2011
+; Copyright (C) 2004, 2011, 2012
 ; This program is free software; you can redistribute it and/or modify  
 ; it under the terms of the GNU General Public License as published by  
 ; the Free Software Foundation; either version 2 of the License, or     
 ; (at your option) any later version.                                   
 ;
-;
 ;-
 ;
 if KEYWORD_SET(help) then begin
     print, 'pro READ_JPEG, filename, unit=unit, image, colortable, buffer=buffer, $'
     print, '               colors=colors, dither=dither, grayscale=grayscale, order=order, $'
     print, '               true=true, two_pass_quantize=two_pass_quantize, $'
-    print, '               help=help, test=test'
+    print, '               help=help, test=test, debug=debug'
     return
 endif
 ;
@@ -85,6 +89,17 @@
 ;
 if (STRLEN(filename) EQ 0) then MESSAGE, "Null filename not allowed."
 if ((FILE_INFO(filename)).exists EQ 0) then MESSAGE, "Error opening file. File: "+filename
+if (FILE_TEST(filename, /regular) EQ 0) then MESSAGE, "Not a regular File: "+filename
+;
+; testing whether the format is as expected
+;
+if ~MAGICK_PING(filename, 'JPEG') then begin
+   MESSAGE, /continue, "JPEG error: Not a JPEG file:"
+   if MAGICK_PING(filename, 'PNG') then MESSAGE, "seems to be a PNG file"
+   if MAGICK_PING(filename, 'GIF') then MESSAGE, "seems to be a GIF file"
+   if MAGICK_PING(filename, 'PDF') then MESSAGE, "seems to be a PDF file"
+   MESSAGE, "unknown/untested format file"   
+endif
 ;
 if KEYWORD_SET(unit) then MESSAGE, "Keyword UNIT not supported"
 if KEYWORD_SET(buffer) then MESSAGE, "Keyword BUFFER not supported"
@@ -96,7 +111,7 @@
     MAGICK_QUANTIZE, mid, /GRAYSCALE
 endif else begin
    if (KEYWORD_SET(colors)) then begin
-      if ((colors LT 8) OR (color GT 256)) then MESSAGE, "COLORS must be in the range 8 to 256"
+      if ((colors LT 8) OR (colors GT 256)) then MESSAGE, "COLORS must be in the range 8 to 256"
       if (KEYWORD_SET(two_pass_quantize)) then MESSAGE, "TWO_PASS_QUANTIZE not supported by ImageMagick."
       MAGICK_QUANTIZE, mid, colors, dither=dither
    endif
@@ -109,10 +124,24 @@
     image=MAGICK_READINDEXES(mid)
     MAGICK_READCOLORMAPRGB, mid, red, green, blue
     colortable=[[red],[green],[blue]]
+    ;;
+    ;; try to catch a problem in ImageMagick
+    ;; (should be renormalized in, but not, as is on 28/01/2012)
+    ;; bug report 3471918 (see min/max)
+    if (KEYWORD_SET(grayscale)) then begin
+       temp=image
+       for ii=0, N_ELEMENTS(red)-1 do begin
+          ok=WHERE(image EQ ii, nbp)
+          if nbp GT 0 then temp[OK]=red[ii]
+       endfor
+       image=temp
+    endif
 endif else begin
     image=MAGICK_READ(mid)
 endelse
 ;
+if KEYWORD_SET(debug) then STOP
+;
 ; if 16-bit (unsigned short int) image convert to byte
 sz = SIZE(image)
 type = sz[sz[0]+1]
@@ -124,19 +153,29 @@
 ;
 if (not KEYWORD_SET(unit)) then MAGICK_CLOSE, mid
 ;
-;; "rotate" image to agree with IDL (JMG 08/18/04)
-tmp = image[0,*,*]
-image[0,*,*] = image[2,*,*]
-image[2,*,*] = tmp
-
-if KEYWORD_SET(TRUE) then begin
-    if (TRUE eq 1) then t=[0,1,2]
-    if (TRUE eq 2) then t=[1,0,2]
-    if (TRUE eq 3) then t=[1,2,0]
-    ;;
-    image=TRANSPOSE(image, t)
-    ;;  image=transpose(image[[2,1,0],*,*], t)
-endif 
+; this is no more need, code changed in MAGICK_READINDEXES
+;if (sz[0] EQ 2) then begin
+;   image=ROTATE(image,7)
+;endif
+if (sz[0] EQ 3) then begin
+   ;; "rotate" image to agree with IDL (JMG 08/18/04)
+   tmp = image[0,*,*]
+   image[0,*,*] = image[2,*,*]
+   image[2,*,*] = tmp
+   ;;
+   if KEYWORD_SET(TRUE) then begin
+      if (TRUE eq 1) then t=[0,1,2]
+      if (TRUE eq 2) then t=[1,0,2]
+      if (TRUE eq 3) then t=[1,2,0]
+      ;;
+      image=TRANSPOSE(image, t)
+      ;;  image=transpose(image[[2,1,0],*,*], t)
+   endif
+endif
+if (sz[0] GT 3) then begin
+    MESSAGE, /continue, $
+             "Dimensions of image > 3 : we don't know how to process now"
+endif
 ;else begin
 ;    image = image[[2,1,0],*,*]
 ;endelse
diff -ruN --exclude CVS gdl-0.9.2/src/pro/read_png.pro gdl/src/pro/read_png.pro
--- gdl-0.9.2/src/pro/read_png.pro	2011-08-18 11:26:43.000000000 -0600
+++ gdl/src/pro/read_png.pro	2012-05-25 15:27:39.000000000 -0600
@@ -1,34 +1,15 @@
-;$Id: read_png.pro,v 1.3 2011/08/18 17:26:43 alaingdl Exp $
-;
-pro READ_PNG, filename, image, red, green, blue, $
-              order=order, verbose=verbose, transparent=transparent, $
-              help=help, test=test
-;
-image=READ_PNG(filename, red, green, blue, $
-              order=order, verbose=verbose, transparent=transparent, $
-              help=help, test=test)
-;
-end
-;
-; ---------------------------------
-;
-function READ_PNG, filename, red, green, blue, $
-                   order=order, verbose=verbose, transparent=transparent, $
-                   help=help, test=test
-;
-ON_ERROR, 2
 ;+
 ;
 ; NAME: READ_PNG
 ;
-;
-; PURPOSE: Reads a PNG file into memory
+; PURPOSE: Reads a PNG file into memory (Function OR Procedure)
 ;
 ; CATEGORY: Images (IO)
 ;
+; CALLING SEQUENCE: 2 ways: Pro or Func
 ;
-; CALLING SEQUENCE: image=READ_PNG(filename,r,g,b)
-;
+;   Function:  image=READ_PNG(filename,r,g,b)
+;   Procedure: READ_PNG, filename, image, r,g,b
 ;
 ; KEYWORD PARAMETERS: 
 ;        ORDER: flip the image in the vertical 
@@ -38,8 +19,6 @@
 ; OUTPUTS: For true color images, data is a three dimensional array
 ; with interleaving set by TRUE keyword
 ;
-;
-;
 ; OPTIONAL OUTPUTS: For pseudocolor only
 ;        red  : the Red colormap vector (for PseudoColor images)
 ;        green: the Green colormap vector (for PseudoColor images)
@@ -52,32 +31,40 @@
 ;         Use ImageMagick to read the data as requested
 ;
 ; EXAMPLE:
-;         
-;
+;         See "test_read_standard_images.pro" in testsuite/
 ;
 ; MODIFICATION HISTORY:
-; 	Written by: Christopher Lee 2004-05-23
-;       2011-Aug-18, Alain Coulais : More checks on inputs; now verify if
-;       compiled with ImageMagick support !
+;  Written by: Christopher Lee 2004-05-23
+;  2011-Aug-18, Alain Coulais : More checks on inputs; now verify if
+;      compiled with ImageMagick support !
+;  2012-Feb-02, Alain Coulais :  the effective order of reading was bad ...
+;      now it is OK on all tested PNG images, including images with transparency
+;      see 3 examples:
+;  * testsuite/Saturn.jpg default conversion by Image Magick in PNG
+;  * http://www.gnu.org/graphics/meditate_fel.png (big, no transparency)
+;  * http://www.gnu.org/graphics/meditate.png (transparency)
+;
+;  2012-Feb-07, Alain Coulais : new test cases in testsuite:
+;   test_read_standard_images.pro : 2 JPEG and 4 PNG (2 with transparency)
+;   The transpose for 2D image is no more need.
+;
+;  2012-May-25, Alain Coulais : fake INTERNAL_READ_PNG to have both
+;   pro/func working transparently without pre-compilation
 ;
 ;-
 ; LICENCE:
-; Copyright (C) 2004,
+; Copyright (C) 2004, 2011, 2012
 ; This program is free software; you can redistribute it and/or modify  
 ; it under the terms of the GNU General Public License as published by  
 ; the Free Software Foundation; either version 2 of the License, or     
 ; (at your option) any later version.                                   
 ;
-;
 ;-
 ;
-if KEYWORD_SET(help) then begin
-    print, 'function READ_PNG, filename, red, green, blue, $'
-    print, '                   order=order, verbose=verbose, transparent=transparent, $'
-    print, '                   help=help, test=test'
-    return, -1
-endif
-;
+function INTERNAL_READ_PNG, filename, red, green, blue, $
+                            order=order, transparent=transparent, $
+                            test=test, verbose=verbose
+
 ; Do we have access to ImageMagick functionnalities ??
 ;
 if (MAGICK_EXISTS() EQ 0) then begin
@@ -86,9 +73,23 @@
 endif
 ;
 if (N_PARAMS() EQ 0) then MESSAGE, "Incorrect number of arguments."
+if ~((N_PARAMS() EQ 1) OR (N_PARAMS() EQ 4)) then $
+   MESSAGE, "Only 1 or 4 arguments allowed."
 ;
+if (SIZE(filename,/type) NE 7) then MESSAGE, "String expression required in this context: filename"
 if (STRLEN(filename) EQ 0) then MESSAGE, "Null filename not allowed."
 if ((FILE_INFO(filename)).exists EQ 0) then MESSAGE, "Error opening file. File: "+filename
+if (FILE_TEST(filename, /regular) EQ 0) then MESSAGE, "Not a regular File: "+filename
+;
+; testing whether the format is as expected
+;
+if ~MAGICK_PING(filename, 'PNG') then begin
+   MESSAGE, /continue, "PNG error: Not a PNG file:"
+   if MAGICK_PING(filename, 'JPEG') then MESSAGE, "seems to be a JPEG file"
+   if MAGICK_PING(filename, 'GIF') then MESSAGE, "seems to be a GIF file"
+   if MAGICK_PING(filename, 'PDF') then MESSAGE, "seems to be a PDF file"
+   MESSAGE, "unknown/untested format file"   
+endif
 ;
 mid=MAGICK_OPEN(filename)
 ;
@@ -101,7 +102,9 @@
     MAGICK_READCOLORMAPRGB, mid, red, green, blue
     colortable=[[red],[green],[blue]]
 endif else begin
-    image=MAGICK_READ(mid)
+   ;; AC 2012-Feb-02 the effective order of reading was bad ...
+   ;; now it is OK on all tested PNG images, including images with transparency
+   image=MAGICK_READ(mid, rgb=1)
 endelse
 ;
 MAGICK_CLOSE, mid
@@ -111,4 +114,47 @@
 return, image
 ;
 end
-
+;
+; ----------------------------- Procedure ------------------------
+;
+pro READ_PNG, filename, image, red, green, blue, $
+              order=order, transparent=transparent, $
+              help=help, test=test, verbose=verbose
+;
+ON_ERROR, 2
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro READ_PNG, filename, red, green, blue, $'
+   print, '              order=order, transparent=transparent, $'
+   print, '              help=help, test=test, verbose=verbose'
+   return
+endif
+;
+image=INTERNAL_READ_PNG(filename, red, green, blue, $
+                        order=order, transparent=transparent, $
+                        test=test, verbose=verbose)
+;
+end
+;
+; ----------------------------- Function ------------------------
+;
+function READ_PNG, filename, red, green, blue, $
+                   order=order, transparent=transparent, $
+                   help=help, test=test, verbose=verbose
+;
+ON_ERROR, 2
+;
+if KEYWORD_SET(help) then begin
+   print, 'function READ_PNG, filename, red, green, blue, $'
+   print, '                   order=order, transparent=transparent, $'
+   print, '                   help=help, test=test, verbose=verbose'
+   return, -1
+endif
+;
+image=INTERNAL_READ_PNG(filename, red, green, blue, $
+                        order=order, transparent=transparent, $
+                        test=test, verbose=verbose)
+;
+return, image
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/read_xwd.pro gdl/src/pro/read_xwd.pro
--- gdl-0.9.2/src/pro/read_xwd.pro	2010-01-20 04:41:59.000000000 -0700
+++ gdl/src/pro/read_xwd.pro	2011-11-15 17:51:17.000000000 -0700
@@ -1,77 +1,82 @@
-;$Id: read_xwd.pro,v 1.3 2010/01/20 11:41:59 slayoo Exp $
-
-function read_xwd, filename, red, green, blue
-  on_error, 2
+function READ_XWD, filename, red, green, blue
 ;+
 ;
-;
-;
 ; NAME: READ_XWD
 ;
 ;
 ; PURPOSE: Reads a X Windows Dump file into memory
 ;
-;
-;
 ; CATEGORY: Images (IO)
 ;
-;
 ; CALLING SEQUENCE: image=read_xwd(filename,red,green,blue)
 ;
-;
-;
 ; OUTPUTS: 
 ;    IMAGE: A 2d file containing the vector indices
 ;
-;
-;
 ; OPTIONAL OUTPUTS:
 ;        red  : the Red colormap vector (for PseudoColor images)
 ;        green: the Green colormap vector (for PseudoColor images)
 ;        blue : the Blue colormap vector (for PseudoColor images)
 ;
 ;
-
 ; RESTRICTIONS:
 ;         Requires ImageMagick
 ;
-;
 ; PROCEDURE:
 ;         Use ImageMagick to read the data as requested
 ;
 ; EXAMPLE:
 ;         
-;
-;
 ; MODIFICATION HISTORY:
 ; 	Written by: Christopher Lee 2004-05-17
-;
-;
+;       2011-Nov-15, Alain Coulais : do we try to read a real file ?!
 ;
 ;-
 ; LICENCE:
-; Copyright (C) 2004,
+; Copyright (C) 2004, 2011
 ; This program is free software; you can redistribute it and/or modify  
 ; it under the terms of the GNU General Public License as published by  
 ; the Free Software Foundation; either version 2 of the License, or     
 ; (at your option) any later version.                                   
 ;
-;
 ;-
-
-
-mid=magick_open(filename)
-
+;
+ON_ERROR, 2
+;
+if KEYWORD_SET(help) then begin
+    print, 'function READ_XWD, filename, red, green, blue, $'
+    print, '                   verbose=verbose, help=help, test=test'
+    return, -1
+endif
+;
+; Do we have access to ImageMagick functionnalities ??
+;
+if (MAGICK_EXISTS() EQ 0) then begin
+    MESSAGE, /continue, "GDL was compiled without ImageMagick support."
+    MESSAGE, "You must have ImageMagick support to use this functionaly."
+endif
+;
+if (N_PARAMS() EQ 0) then MESSAGE, "Incorrect number of arguments."
+if (STRLEN(filename) EQ 0) then MESSAGE, "Null filename not allowed."
+if ((FILE_INFO(filename)).exists EQ 0) then MESSAGE, "Error opening file. File: "+filename
+if (FILE_TEST(filename, /regular) EQ 0) then MESSAGE, "Not a regular File: "+filename
+;
+; starting effective reading !
+;
+mid=MAGICK_OPEN(filename)
+;
 print, magick_IndexedColor(mid)
-if(magick_IndexedColor(mid)) then begin
-    image=magick_readIndexes(mid)
-    magick_readcolormapRGB,mid,red,green,blue
+if (MAGICK_INDEXEDCOLOR(mid)) then begin
+    image=MAGICK_READINDEXES(mid)
+    MAGICK_READCOLORMAPRGB, mid, red, green, blue
 endif else begin
-    image=magick_read(mid)
+    image=MAGICK_READ(mid)
 endelse
-
-magick_close,mid
+;
+MAGICK_CLOSE, mid
+;
 return, image
+;
 end
 
 
diff -ruN --exclude CVS gdl-0.9.2/src/pro/skewness.pro gdl/src/pro/skewness.pro
--- gdl-0.9.2/src/pro/skewness.pro	2005-07-25 01:33:25.000000000 -0600
+++ gdl/src/pro/skewness.pro	2012-07-13 16:28:02.000000000 -0600
@@ -1,27 +1,24 @@
-;$Id: skewness.pro,v 1.2 2005/07/25 07:33:25 m_schellens Exp $
-function skewness, x, double=double, NaN=NaN
-
-;+
+;$Id: skewness.pro,v 1.3 2012/07/13 22:28:02 alaingdl Exp $
 ;
+function skewness, x, double=double, NaN=NaN, dimension=dimension
 ;
+;+
 ;
-; NAME: 
-;       skewness
+; NAME: SKEWNESS
 ;
 ; PURPOSE: 
 ;     Calculates the skewness of the input data
 ;       
-;
 ; CATEGORY:
 ;     Mathematics: Statistics
 ;
-; CALLING SEQUENCE:
-;     Result=skewness(x)
-;
+; CALLING SEQUENCE:  Result=SKEWNESS(x [, /nan][,/double][, dim=])
 ;
 ; KEYWORD PARAMETERS: 
 ;     DOUBLE : Keyword for double precision calculation
 ;     NAN    : Flag to treat IEEE Special Floating-Point values as missing data
+;     DIMENSION : if absent or equal to zero, compute the variance over the
+;                 whole data. otherwise, compute along the related dimension.
 ;
 ; OUTPUTS:
 ;    Result is the mean of input data
@@ -36,17 +33,19 @@
 ;     Uses the MOMENT function
 ;
 ; EXAMPLE:
-;     a=findgen(100)
-;     result=mean(a)
+;     a=FINDGEN(100)
+;     result=SKEWNESS(a)
 ;     print, result
 ;     0.0000
 ;
 ; MODIFICATION HISTORY:
 ;   20-Mar-2004 : Written by Christopher Lee
 ;   18-Jul-2005 : PC, moment.pro update
+;   13-Jul-2012 : Alain Coulais : adding DIMENSION keyword, using MOMENT()
 ;
 ; LICENCE:
-; Copyright (C) 2004,
+; Copyright (C) 2004, Christopher Lee, 2005 P. Chanial, 2012 Alain Coulais
+;
 ; This program is free software; you can redistribute it and/or modify  
 ; it under the terms of the GNU General Public License as published by  
 ; the Free Software Foundation; either version 2 of the License, or     
@@ -54,10 +53,12 @@
 ;
 ;
 ;-
-
- on_error, 2
- 
- m = moment(x, double=double, NaN=NaN)
- return, m[2]
-
+;
+ON_ERROR, 2
+;
+tmp = MOMENT(x, skewness=skewness, double=double, NaN=NaN, $
+             dimension=dimension, maxmoment=3)
+;
+return, skewness
+;
 end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/smooth.pro gdl/src/pro/smooth.pro
--- gdl-0.9.2/src/pro/smooth.pro	2008-03-28 04:25:23.000000000 -0600
+++ gdl/src/pro/smooth.pro	2012-05-08 03:48:44.000000000 -0600
@@ -3,9 +3,19 @@
 ;
 ; PURPOSE:  The SMOOTH function returns a smoothed array of the input array.
 ; smoothed with a boxcar average of the specified width.
-; The result has the same type and dimensions as Array. 
-; The algorithm used by SMOOTH is very simple: using the CONVOL
-; function with a "flat" kernel
+; The result has the same type and dimensions as Array.
+;
+; Two algorithms are used, the old slow using 2D convol, and
+; a new faster using 1D convol.
+; - The old slow algorithm used by SMOOTH is very simple: using the CONVOL
+; function with a "flat" kernel (no more the default, must be
+; triggered by keyword /SLOW_ALGO)
+; - The new fast algorithm [now default !], thanks to Sergey A.
+; [since 2012-Apr-29]
+; "The point of the optimization is to use several subsequental
+; 1d convolutions instead of 1 multidimensional convolution. 
+; This approach is mathematically correct for boxcar filter i.e. smooth."
+;  https://sourceforge.net/tracker/index.php?func=detail&aid=3522374&group_id=97659&atid=618685
 ;
 ; When something goes wrong (e.g. bad type or size of "width"), SMOOTH
 ; returns the initial input. 
@@ -14,7 +24,6 @@
 ;
 ; CALLING SEQUENCE:
 ;
-;
 ; Result = SMOOTH( Array, Width [, /EDGE_TRUNCATE] [, /NAN], [/TEST, /HELP]);
 ;
 ;
@@ -36,6 +45,9 @@
 ; -- Test : will stop just before the return statement
 ;    (useful for internal checking/debugging)
 ; -- verbose : print some informations
+; -- slow_algo : the old slow reference version ... [may be use
+;    later if different algo emerge ... can be useful to test
+;    future other alternatives]
 ;
 ; OUTPUTS:  return an array of the same size than the input one.
 ;
@@ -66,21 +78,24 @@
 ;               b=SMOOTH(randomu(seed,10,20,30), [3,5,7])
 ;
 ; MODIFICATION HISTORY:
-;   - 26/07/2006: created by Alain Coulais (ARSC) during CalTech visit
-;   - 28/03/2008: managing missing array input (0-element and 1-element)
+;  - 26/07/2006: created by Alain Coulais (ARSC) during CalTech visit
+;  - 28/03/2008: managing missing array input (0-element and 1-element)
+;  - 29/04/2012: Sergey A. : Patch ID 3522374 on sf.net. Optimized version.
+;        (using several 1d convolutions instead of multidimensional one).
 ;
 ;-
 ; LICENCE:
-; Copyright (C) 2006, Alain Coulais
+; Copyright (C) 2006, 2012 Alain Coulais and Sergey A.
 ; This program is free software; you can redistribute it and/or modify  
 ; it under the terms of the GNU General Public License as published by  
 ; the Free Software Foundation; either version 2 of the License, or     
 ; (at your option) any later version.
 ;-
 ;
-function SMOOTH, input_array, width, $
+function SMOOTH, input_array, width, $                 
                  EDGE_TRUNCATE=EDGE_TRUNCATE, NAN=NAN, $
-                 test=test, help=help, verbose=verbose
+                 slow_algo=slow_algo, $ ; the slow reference version
+                 test=test, help=help, debug=debug, verbose=verbose
 ;
 ON_ERROR, 2
 ;
@@ -89,14 +104,14 @@
 if (N_PARAMS() NE 2) then help=1
 ;
 if KEYWORD_SET(help) then begin
-    print, 'function SMOOTH, array, width, [/EDGE_TRUNCATE], [/NAN] [/help, /test, /verbose]'
-    if (N_PARAMS() NE 2) then return, -1 else return, input_array
+   print, 'function SMOOTH, array, width, [/EDGE_TRUNCATE], [/NAN] [/help, /test, /verbose]'
+   if (N_PARAMS() NE 2) then return, -1 else return, input_array
 endif
 ;
 if KEYWORD_SET(NaN) then begin
-    print, '------------------------ warning --------'
-    print, '-- /NaN  not fully ready now ------------'
-    print, '------------------------ warning --------'
+   print, '------------------------ warning --------'
+   print, '-- /NaN  not fully ready now ------------'
+   print, '------------------------ warning --------'
 endif
 ;
 if (SIZE(input_array,/type) EQ 7) then begin
@@ -110,7 +125,6 @@
 if (N_ELEMENTS(input_array) LE 1) then begin
    MESSAGE, 'Expression must be an array in this context:'
 endif
-
 ;
 n_dimensions=SIZE(input_array,/n_dimensions)
 dimensions=SIZE(input_array,/dimensions)
@@ -122,36 +136,36 @@
 ; This is checked in IDL
 ;
 if (N_ELEMENTS(width) GT 1) then begin
-    if (N_ELEMENTS(width) NE n_dimensions) then begin
-        message, 'Number of Array dimensions does not match number of Width dimensions', /continue
-        return, input_array
-    endif else begin
-        real_width=width
-    endelse
+   if (N_ELEMENTS(width) NE n_dimensions) then begin
+      MESSAGE, 'Number of Array dimensions does not match number of Width dimensions', /continue
+      return, input_array
+   endif else begin
+      real_width=width
+   endelse
 endif else begin
-    real_width=REPLICATE(width,n_dimensions)
+   real_width=REPLICATE(width,n_dimensions)
 endelse
 ;
 ; below here, no more use of "width"
 ;
 for ii=0, N_ELEMENTS(real_width)-1 do begin
-    if (real_width[ii] LT 0) then begin
-        MESSAGE, 'Width must be nonnegative',/continue
-        return, input_array
-    endif
-    ;;
-    ;; This is NOT check properly in IDL
-    if (real_width[ii] LE 1) then begin
-        MESSAGE, 'Width must be Great or Equal to 2',/continue
-        return, input_array
-    endif
-    ;;
-    if (dimensions[ii] LE real_width[ii]) then begin
-        MESSAGE, 'Width must be smaller than array dimensions',/continue
-        return, input_array
-    endif
-    ;;
-    if ((real_width[ii] MOD 2) EQ 0) then real_width[ii]=real_width[ii]+1
+   if (real_width[ii] LT 0) then begin
+      MESSAGE, 'Width must be nonnegative',/continue
+      return, input_array
+   endif
+   ;;
+   ;; This is NOT check properly in IDL
+   if (real_width[ii] LE 1) then begin
+      MESSAGE, 'Width must be Great or Equal to 2',/continue
+      return, input_array
+   endif
+   ;;
+   if (dimensions[ii] LE real_width[ii]) then begin
+      MESSAGE, 'Width must be smaller than array dimensions',/continue
+      return, input_array
+   endif
+   ;;
+   if ((real_width[ii] MOD 2) EQ 0) then real_width[ii]=real_width[ii]+1
 endfor
 ;
 half_width=real_width/2
@@ -165,74 +179,117 @@
 ; if the NaN switch ON ?
 ;
 if KEYWORD_SET(NaN) then begin
-    need_nan_process=1
-    nan_location=WHERE(FINITE(input_array) EQ 0, nbp_nan)
-    ;;
-    ;; can we switch OFF ?
-    if (nbp_nan EQ 0) then begin
-        if KEYWORD_SET(verbose) then print, 'NaN flag switch ON but no NaN founded'
-        need_nan_process=0
-    endif else begin
-        ;; we create an array of same size the input array but with Zero's 
-        pb=FLTARR(SIZE(input_array,/dimensions))
-        ;; Where we have NaN, we put "One" (1.)
-        pb[nan_location]=1.
-        ;; We put Zero's for Missing data
-        input_array[nan_location]=0.        
-    endelse
-endif
-;
-; calling of CONVOL with "constant" gate
-;
-gate=REPLICATE(1., real_width)
-norm_of_gate=TOTAL(gate)
-output_array=CONVOL(input_array, gate, norm_of_gate, EDGE_TRUNCATE=EDGE_TRUNCATE)
+   need_nan_process=1
+   nan_location=WHERE(FINITE(input_array) EQ 0, nbp_nan)
+   ;;
+   ;; can we switch OFF ?
+   if (nbp_nan EQ 0) then begin
+      if KEYWORD_SET(verbose) then print, 'NaN flag switch ON but no NaN founded'
+      need_nan_process=0
+   endif else begin
+      ;; we create an array of same size the input array but with Zero's 
+      pb=FLTARR(SIZE(input_array,/dimensions))
+      ;; Where we have NaN, we put "One" (1.)
+      pb[nan_location]=1.
+      ;; We put Zero's for Missing data
+      input_array[nan_location]=0.        
+   endelse
+endif
+;
+; The SLOW initial version.
+; We keep it just in case, and also because we use it in time tests
+;
+if KEYWORD_SET(slow_algo) then begin
+   if KEYWORD_SET(debug) then MESSAGE, /continue, 'Reference Algo (slowest)'
+   ;;
+   ;; calling of 2D CONVOL with "constant" gate
+   ;;
+   gate=REPLICATE(1., real_width)
+   norm_of_gate=TOTAL(gate)
+   output_array=CONVOL(input_array, gate, norm_of_gate, $
+                       EDGE_TRUNCATE=EDGE_TRUNCATE)
+endif else begin
+   if KEYWORD_SET(debug) then MESSAGE, /continue, 'Revisited Algo (fast)'
+   ;;
+   ;; A FAST version base on calls to 1D CONVOL
+   ;; calling of CONVOL for each dimension subsequently
+   ;; performing several 1d convolutions instead of  multidimensional one
+   ;;
+   temp_width=real_width*0.+1.
+   ;;
+   ;; this will be dimensions for 1d kernel ([1,1,1])
+   ;;
+   output_array=input_array
+   for i=0,N_ELEMENTS(real_width)-1 do begin
+      temp_width[i]=real_width[i]
+      ;;
+      ;;preparing dimensions for  1d kernel ( [1,1,1]->[1,3,1])
+      ;;
+      gate=REFORM(REPLICATE(1.0,real_width[i]),temp_width)
+      ;;
+      ;;creating kernel (gate) for 1d convolution
+      ;;
+      norm_of_gate=TOTAL(gate)
+      output_array=CONVOL(TEMPORARY(output_array), gate, norm_of_gate, $
+                          EDGE_TRUNCATE=EDGE_TRUNCATE)
+      ;;
+      ;;convolution with 1d kernel
+      ;;
+      temp_width[i]=1.
+      ;;
+      ;; returning kernel dimensions to the initial state ( [1,3,1]->[1,1,1])
+      ;;
+   endfor
+endelse
 ;
 ; Please remember that Convol return 0 on borders when EDGE_TRUNCATE is not set 
 ;
 if NOT(KEYWORD_SET(EDGE_TRUNCATE)) then begin
-    if (n_dimensions GT 3) then begin 
-        MESSAGE, '/EDGE_TRUNCATE not available in SMOOTH when N_dim > 3 ...', /continue
-        return, input_array
-    endif
-    ;; not very efficient but mandatory for the edges,
-    ;; and I never used SMOOTH in higher dimensions
-    if (n_dimensions EQ 1) then begin
-        output_array[0:half_width-1]=input_array[0:half_width-1]
-        output_array[dimensions[0]-half_width:dimensions[0]-1]=input_array[dimensions[0]-half_width:dimensions[0]-1]
-    endif
-    if (n_dimensions EQ 2) then begin
-        output_array[0:half_width[0]-1,*]=input_array[0:half_width[0]-1,*]
-        output_array[dimensions[0]-half_width[0]:dimensions[0]-1,*]=input_array[dimensions[0]-half_width[0]:dimensions[0]-1,*]
-        ;;
-        output_array[*,0:half_width[1]-1]=input_array[*,0:half_width[1]-1]
-        output_array[*,dimensions[1]-half_width[1]:dimensions[1]-1]=input_array[*,dimensions[1]-half_width[1]:dimensions[1]-1]
-    endif
-    if (n_dimensions EQ 3) then begin
-        output_array[0:half_width[0]-1,*,*]=input_array[0:half_width[0]-1,*,*]
-        output_array[dimensions[0]-half_width[0]:dimensions[0]-1,*,*]=input_array[dimensions[0]-half_width[0]:dimensions[0]-1,*,*]
-        ;;
-        output_array[*,0:half_width[1]-1,*]=input_array[*,0:half_width[1]-1,*]
-        output_array[*,dimensions[1]-half_width[1]:dimensions[1]-1,*]=input_array[*,dimensions[1]-half_width[1]:dimensions[1]-1,*]
-        ;;
-        output_array[*,*,0:half_width[2]-1]=input_array[*,*,0:half_width[2]-1]
-        output_array[*,*,dimensions[2]-half_width[2]:dimensions[2]-1]=input_array[*,*,dimensions[2]-half_width[2]:dimensions[2]-1]
-    endif
+   if (n_dimensions GT 3) then begin 
+      MESSAGE, '/EDGE_TRUNCATE not available in SMOOTH when N_dim > 3 ...', /continue
+      return, input_array
+   endif
+   ;; not very efficient but mandatory for the edges,
+   ;; and I never used SMOOTH in higher dimensions
+   ;;
+   if (n_dimensions EQ 1) then begin
+      output_array[0:half_width-1]=input_array[0:half_width-1]
+      output_array[dimensions[0]-half_width:dimensions[0]-1]=input_array[dimensions[0]-half_width:dimensions[0]-1]
+   endif
+   ;;
+   if (n_dimensions EQ 2) then begin
+      output_array[0:half_width[0]-1,*]=input_array[0:half_width[0]-1,*]
+      output_array[dimensions[0]-half_width[0]:dimensions[0]-1,*]=input_array[dimensions[0]-half_width[0]:dimensions[0]-1,*]
+      ;;
+      output_array[*,0:half_width[1]-1]=input_array[*,0:half_width[1]-1]
+      output_array[*,dimensions[1]-half_width[1]:dimensions[1]-1]=input_array[*,dimensions[1]-half_width[1]:dimensions[1]-1]
+   endif
+   ;;
+   if (n_dimensions EQ 3) then begin
+      output_array[0:half_width[0]-1,*,*]=input_array[0:half_width[0]-1,*,*]
+      output_array[dimensions[0]-half_width[0]:dimensions[0]-1,*,*]=input_array[dimensions[0]-half_width[0]:dimensions[0]-1,*,*]
+      ;;
+      output_array[*,0:half_width[1]-1,*]=input_array[*,0:half_width[1]-1,*]
+      output_array[*,dimensions[1]-half_width[1]:dimensions[1]-1,*]=input_array[*,dimensions[1]-half_width[1]:dimensions[1]-1,*]
+      ;;
+      output_array[*,*,0:half_width[2]-1]=input_array[*,*,0:half_width[2]-1]
+      output_array[*,*,dimensions[2]-half_width[2]:dimensions[2]-1]=input_array[*,*,dimensions[2]-half_width[2]:dimensions[2]-1]
+   endif
 endif
 ;
 ; 
 if (need_nan_process EQ 1) then begin
-    pb=CONVOL(pb, gate, norm_of_gate)
-    pb_remain=WHERE(pb GT 0.999999, nbp_pb_remain)
-    if (nbp_pb_remain GT 0) then begin
-        if KEYWORD_SET(verbose) then print, 'It remain''s some NaN points !'
-        output_array[pb_remain]=!values.f_NaN
-    endif else begin
-        if KEYWORD_SET(verbose) then print, 'No more NaN points !'
-    endelse
-    ;;
-    ;; we write back the NaN in the input array
-    input_array[nan_location]=!values.f_NaN
+   pb=CONVOL(pb, gate, norm_of_gate)
+   pb_remain=WHERE(pb GT 0.999999, nbp_pb_remain)
+   if (nbp_pb_remain GT 0) then begin
+      if KEYWORD_SET(verbose) then print, 'It remain''s some NaN points !'
+      output_array[pb_remain]=!values.f_NaN
+   endif else begin
+      if KEYWORD_SET(verbose) then print, 'No more NaN points !'
+   endelse
+   ;;
+   ;; we write back the NaN in the input array
+   input_array[nan_location]=!values.f_NaN
 endif
 ;
 if KEYWORD_SET(test) then STOP
diff -ruN --exclude CVS gdl-0.9.2/src/pro/standardize.pro gdl/src/pro/standardize.pro
--- gdl-0.9.2/src/pro/standardize.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/pro/standardize.pro	2012-05-16 08:38:39.000000000 -0600
@@ -0,0 +1,82 @@
+;+
+;
+; NAME: 
+;     standardize
+; PURPOSE: 
+;     Standardizes/normalizes an array of m variables and n observations
+;     (m by n).
+;
+; CATEGORY:
+;     Mathematics: Statistics
+;
+; CALLING SEQUENCE:
+;     Result = STANDARIZE(array)
+;
+; KEYWORD PARAMETERS:
+;     DOUBLE: Keyword for double precision calculation
+;     HELP: showing how to use and exit
+;     TEST: stop just at the end, before returning
+;
+; OUTPUTS:
+;     Result is a standarized/normalized array with a mean of zero and a
+;     variance of 1.
+;
+; RESTRICTIONS:
+;     The input array must be two dimensional numeric array
+;
+; EXAMPLE: see "testsuite/test_standarize,pro" in GDL CVS
+;
+;     (another exemple here:
+;     http://idlastro.gsfc.nasa.gov/idl_html_help/STANDARDIZE.html) 
+;     Define an array with 4 variables and 20 observations:  
+;     array = FLTARR(4, 20)
+;     array= [...]
+;     result = STANDARIZE(array)
+;     print, result
+;
+; MODIFICATION HISTORY:
+; 15-Apr-2012: Written by Josh Sixsmith
+; 13-May-2012: Alain: Correcting a sigm pb; Preparing for putting in GDL CVS ...
+; 15-May-2012: Josh: Form now properly reflects (x - mu)/sigma. 
+;                    Corrects the sign error as noted by Alain.
+;
+; LICENCE:
+; Copyright (C) 2012, Josh Sixsmith
+; This program is free software; you can redistribute it and/or modify  
+; it under the terms of the GNU General Public License as published by  
+; the Free Software Foundation; either version 3 of the License, or     
+; (at your option) any later version.                                   
+;
+;-
+ 
+function STANDARDIZE, array, DOUBLE=dbl, test=test, help=help
+;
+ON_ERROR, 2
+;
+if KEYWORD_SET(help) then begin
+   print, 'function STANDARDIZE, array, DOUBLE=dbl, test=test, help=help'
+   print, 'array must be a 2D array'
+   return, -1
+endif
+;
+if (SIZE(array))[0] ne 2 then MESSAGE, 'Array needs to be 2 dimensional'
+;
+dbl = KEYWORD_SET(dbl)
+;
+dims = SIZE(array, /dimensions)
+result = dbl ? dblarr(dims) : fltarr(dims)
+;                             
+; Uses the form for population (x - mu)/sigma
+; Unsure whether the form should be for a sample:
+; (x - xbar)/(sigma/sqrt(n))
+;
+for i=0, dims[0]-1 do begin
+   mom = MOMENT(array[i,*], sdev=stdv, Double = dbl)
+   result[i,*] = (array[i,*] - mom[0])/stdv
+endfor
+;
+if KEYWORD_SET(test) then STOP
+;
+return, result
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/STATUS gdl/src/pro/STATUS
--- gdl-0.9.2/src/pro/STATUS	2010-02-20 13:46:27.000000000 -0700
+++ gdl/src/pro/STATUS	2012-05-14 06:37:08.000000000 -0600
@@ -124,7 +124,7 @@
 !h_eq_int.pro
 !hilbert.pro
 =hist_2d.pro
-!hist_equal.pro
+~hist_equal.pro
  hls.pro
  hsv.pro
 !ibeta.pro
@@ -226,8 +226,8 @@
 ~read_binary.pro              ; TEMPLATE keyword missing
 =read_bmp.pro
 =read_dicom.pro
- read_gif.pro
- read_image.pro
+~read_gif.pro
+~read_image.pro
  read_interfile.pro
 =read_pict.pro
  read_ppm.pro
@@ -271,7 +271,7 @@
  sph_scat.pro
 !spline_p.pro
 !spline.pro
-!standardize.pro
+~standardize.pro
 =stddev.pro
  streamline.pro
  stretch.pro
@@ -313,8 +313,8 @@
  warp_tri.pro
  wf_draw.pro
 =write_bmp.pro
- write_gif.pro
- write_image.pro
+~write_gif.pro
+~write_image.pro
  write_nrif.pro
 =write_pict.pro
  write_ppm.pro
diff -ruN --exclude CVS gdl-0.9.2/src/pro/stddev.pro gdl/src/pro/stddev.pro
--- gdl-0.9.2/src/pro/stddev.pro	2005-07-25 01:33:25.000000000 -0600
+++ gdl/src/pro/stddev.pro	2012-07-13 16:28:02.000000000 -0600
@@ -1,33 +1,29 @@
-;$Id: stddev.pro,v 1.2 2005/07/25 07:33:25 m_schellens Exp $
-
-function stddev, x, double=double, NaN=NaN
-
-;+
+;$Id: stddev.pro,v 1.3 2012/07/13 22:28:02 alaingdl Exp $
 ;
+function STDDEV, x, double=double, NaN=NaN, dimension=dimension
 ;
+;+
 ;
-; NAME: 
-;       stddev
+; NAME: STDDEV
 ;
 ; PURPOSE: 
 ;     Calculates the standard deviation of the input data
 ;       
-;
 ; CATEGORY:
 ;     Mathematics: Statistics
 ;
 ; CALLING SEQUENCE:
-;     Result=stddev(x)
-;
+;     Result=STDDEV(x)
 ;
 ; KEYWORD PARAMETERS: 
 ;     DOUBLE : Keyword for double precision calculation
 ;     NAN    : Flag to treat IEEE Special Floating-Point values as missing data
+;     DIMENSION : if absent or equal to zero, compute the variance over the
+;                 whole data. otherwise, compute along the related dimension.
 ;
 ; OUTPUTS:
 ;    Result is the standard deviation of input data
 ;
-;
 ; RESTRICTIONS:
 ;    The input x needs to be an array of numbers (i.e not strings,
 ;    struct, ptr, object)
@@ -37,28 +33,31 @@
 ;     Uses the MOMENT function
 ;
 ; EXAMPLE:
-;     a=findgen(100)
-;     result=stddev(a)
+;     a=FINDGEN(100)
+;     result=STDDEV(a)
 ;     print, result
 ;     29.0115
 ;
 ; MODIFICATION HISTORY:
 ;   20-Mar-2004 : Written by Christopher Lee
 ;   18-Jul-2005 : PC, moment.pro update
+;   13-Jul-2012 : Alain Coulais : adding DIMENSION keyword, using MOMENT()
 ;
 ; LICENCE:
-; Copyright (C) 2004, Christopher Lee
+; Copyright (C) 2004, Christopher Lee, 2005 P. Chanial, 2012 Alain Coulais
+;
 ; This program is free software; you can redistribute it and/or modify  
 ; it under the terms of the GNU General Public License as published by  
 ; the Free Software Foundation; either version 2 of the License, or     
 ; (at your option) any later version.                                   
 ;
-;
 ;-
-
- on_error, 2
- 
- junk = moment(x, sdev=sdev, double=double, NaN=NaN)
- return, sdev
-
+;
+ON_ERROR, 2
+;
+tmp=MOMENT(x, sdev=sdev, double=double, NaN=NaN, $
+           dimension=dimension, maxmoment=2)
+;
+return, sdev
+;
 end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/strmatch.pro gdl/src/pro/strmatch.pro
--- gdl-0.9.2/src/pro/strmatch.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/pro/strmatch.pro	2011-11-22 10:54:39.000000000 -0700
@@ -0,0 +1,54 @@
+; part of GDL - GNU Data Language (GPL)
+; by Sylwester Arabas <slayoo@igf.fuw.edu.pl>
+
+; search & replace helper for strmatch()
+function strmatch_strreplace, str, a, b
+  pos = strpos(str, a)
+  if pos eq -1 then return, str
+  ret = strmid(str,0,pos)
+  la = strlen(a)
+  last = pos 
+  for i = pos, strlen(str) - 1 do begin
+    if strmid(str,i,la) eq a && (i eq 0 || strmid(str,i-1,1) ne '\') then begin
+      ret += strmid(str,last,i-last) + b 
+      last = i + la
+    endif
+  endfor
+  ret += strmid(str,last)
+  return, ret
+end
+
+; quick & dirty strmatch() implementation using stregex()
+function strmatch, mstr, sstr, fold_case=fold_case
+  on_error, 2
+  if (size(sstr))[0] ne 0 then message, 'second argument must be a scalar string'
+
+  tmp = sstr
+  ; . -> \. (but not \.)
+  tmp = strmatch_strreplace(tmp, '.', '\.')
+  ; ( -> \( (but not \()
+  tmp = strmatch_strreplace(tmp, '(', '\(')
+  ; ) -> \) (but not \))
+  tmp = strmatch_strreplace(tmp, ')', '\)')
+  ; + -> \+ (but not \+)
+  tmp = strmatch_strreplace(tmp, '+', '\+')
+  ; { -> \{ (but not \{)
+  tmp = strmatch_strreplace(tmp, '{', '\{')
+  ; } -> \} (but not \})
+  tmp = strmatch_strreplace(tmp, '}', '\}')
+  ; | -> \| (but not \|)
+  tmp = strmatch_strreplace(tmp, '|', '\|')
+  ; ^ -> \^ (but not \^)
+  tmp = strmatch_strreplace(tmp, '^', '\^')
+  ; $ -> \$ (but not \$)
+  tmp = strmatch_strreplace(tmp, '$', '\$')
+  ; * -> .* (but not \*)
+  tmp = strmatch_strreplace(tmp, '*', '.*')
+  ; ? -> . (but not \?)
+  tmp = strmatch_strreplace(tmp, '?', '.')
+  ; [!...] -> [^...] (but not \[!...)
+  tmp = strmatch_strreplace(tmp, '[!', '[^')
+  ; the leading a trailing markers
+  tmp = '^' + tmp + '$'
+  return, stregex(mstr, tmp, /boolean, fold_case=fold_case)
+end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/strsplit.pro gdl/src/pro/strsplit.pro
--- gdl-0.9.2/src/pro/strsplit.pro	2011-08-12 09:33:34.000000000 -0600
+++ gdl/src/pro/strsplit.pro	2012-07-11 07:45:51.000000000 -0600
@@ -19,6 +19,7 @@
 ;                 better managment of (missing/void) inputs
 ;   11-Aug-2011 : Alain Coulais : solving conflits due to
 ;                 /preserve_null and /regex; curing bugs in special cases
+;   11-Jul-2012 : When /extract, we must return STRARR even for 1-element
 ;
 ; LICENCE:
 ; Copyright (C)
@@ -139,7 +140,9 @@
       resu=0
       beg=0
       ;;
-      for ii=0, STRLEN(input2)-1 do resu=[resu, STRMULTIPOS(local_input1, STRMID(input2, ii, 1))]
+      for ii=0, STRLEN(input2)-1 do begin
+         resu=[resu, STRMULTIPOS(local_input1, STRMID(input2, ii, 1))]
+      endfor
       ;;
       resu=resu[WHERE(resu GE 0)]
       tst=resu[WHERE(resu EQ 0)]
@@ -162,13 +165,13 @@
             endif else begin
                sresu[0]=STRMID(local_input1, resu[0]+1, resu[1]-resu[0]-1)
             endelse
-
+            
             for ii=1, N_ELEMENTS(resu)-2 do begin
                ;;print, resu[ii]+1,resu[ii+1]-resu[ii]-1                    
                sresu[ii]=STRMID(local_input1, resu[ii]+1,resu[ii+1]-resu[ii]-1)
             endfor
             sresu[N_ELEMENTS(resu)-1]=STRMID(local_input1, resu[N_ELEMENTS(resu)-1]+1)
-                                ;stop
+            ;;stop
             resu=sresu
          endelse
          ;;
@@ -212,7 +215,17 @@
 ;
 if KEYWORD_SET(test) then STOP
 ;
-if (SIZE(resu,/type) NE 7) then resu=LONG(resu)
+if (SIZE(resu,/type) NE 7) then begin
+   resu=LONG(resu)
+endif else begin
+   ;; when we have a non null (not '') string singleton
+   ;; we must return an array
+   if (SIZE(resu,/n_dim) EQ 0) then begin
+      if (STRLEN(resu) GT 0) then resu=REFORM(resu,1)
+   endif
+endelse
+;
+if KEYWORD_SET(test) then STOP
 ;
 return, resu
 ;
diff -ruN --exclude CVS gdl-0.9.2/src/pro/tvscl.pro gdl/src/pro/tvscl.pro
--- gdl-0.9.2/src/pro/tvscl.pro	2010-04-14 09:10:22.000000000 -0600
+++ gdl/src/pro/tvscl.pro	2012-06-12 15:08:23.000000000 -0600
@@ -2,52 +2,69 @@
 ; NAME:
 ;	TVSCL
 ;
-;
 ; PURPOSE:
 ;	Replicates the built-in TVSCL procedure in IDL for GDL
 ;
-;
 ; CATEGORY:
 ;	Graphics
 ;
-;
 ; CALLING SEQUENCE:
 ;	TVSCL, image, x,y
 ;
-;
 ; INPUTS:
 ;	image	The image to be displayed, may be any numeric type.
 ;
-;
 ; OPTIONAL INPUTS:
 ;	x, y	The position of the lower-left corner of the image.
 ;
-;
 ; KEYWORD PARAMETERS:
 ;	/nan	If set, then treat non-numbers (infinity & nan) as
 ;		missing data.
 ;
 ;	Any keyword accepted by TV is also accepted by TVSCL.
 ;
-;
 ; SIDE EFFECTS:
 ;	An image is displayed on the current graphics device.
 ;
-; REESTRICTIONS:
-;	Has to use a slightly cumbersome procedure as the nan key is
+; REESTRICTIONS: (obsolete mention)
+;       Has to use a slightly cumbersome procedure as the nan key is
 ;	not yet implemented in MIN, MAX and BYTSCL.
+; REESTRICTIONS: (current version)
+;       When data contains NaN, we have no way to know what will
+;       happen in basic arithmetic ( a > 0 if a contains NaN may
+;       return 0. or NaN ...). Then we decide not to follow the rule
+;       and to manage NaN when /Nan not set ... Result becomes more
+;       predictable ...
 ;
 ; MODIFICATION HISTORY:
 ;     Original: 14/03/2005; SJT
-;     Modification: 14/04/2010; Alain Coulais: 
+;     Modifications:
+; 2010-04-14: Alain Coulais.
 ;        -- better managment of inputs
 ;        -- no use of "locs" if no /NaN !
-;
+; 2012-06-12: Alain Coulais. When first field in array is NaN,
+; we don't known how the range will be compute --> we decide
+; not to follow this rule ...
+;
+; LICENCE:
+; Copyright (C) 2005, SJT; 2012, A. Coulais
+; This program is free software; you can redistribute it and/or modify  
+; it under the terms of the GNU General Public License as published by  
+; the Free Software Foundation; either version 2 of the License, or     
+; (at your option) any later version.                                   
+; 
 ;-
-pro TVSCL, image, x, y, nan = nan, _extra = _extra
+pro TVSCL, image, x, y, NaN=NaN, $
+           help=help, verbose=verbose, test=test, _extra = _extra
 ;
 ON_ERROR, 2                     ; Return to caller on error.
 ;
+if KEYWORD_SET(help) then begin
+   print, 'pro TVSCL, image, x, y, NaN=NaN, $'
+   print, '           help=help, verbose=verbose, test=test, _extra = _extra'
+   return
+endif
+;
 if N_PARAMS() EQ 0 then begin
    MESSAGE, 'Incorrect number of arguments.'
    return
@@ -58,22 +75,33 @@
 endif
 ;
 if KEYWORD_SET(nan) then begin
-    locs = WHERE(FINITE(image), nf)
-    if (nf EQ 0) then MESSAGE, "No finite values found in image"
-    dmin = MIN(image[locs], max = dmax)
+   locs = WHERE(FINITE(image), nf)
+   if (nf EQ 0) then MESSAGE, "No finite values found in image"
+   dmin = MIN(image[locs], max = dmax)
 endif else begin
+   ;; unpredictable result if image does contain NaN values (see MIN
+   ;; doc. or Minimum and Maximum Operators in IDL doc.)
+   ;;
+   ;; this case is not well managed in IDL too (no warning)
    dmin = MIN(image, max = dmax)
+   if ~FINITE(dmin) OR ~FINITE(dmax) then begin
+      MESSAGE, /continue, 'Data range is wrong due to NaN/Inf, we used /NaN'
+      dmin = MIN(image, max = dmax, /nan)
+   endif
 endelse
-
-if !d.table_size eq 0 then imax = !d.n_colors-1 $
-else imax = !d.table_size-1
-
+;
+if !d.table_size eq 0 then imax = !d.n_colors-1 else imax = !d.table_size-1
+;
+if KEYWORD_SET(verbose) then print, 'Range, imax :', dmin, dmax, imax
+;
 img = BYTSCL(image, min = dmin, max = dmax, top = imax)
 
 case N_PARAMS() of
-    1: TV, img, _extra = _extra
-    2: TV, img, x, _extra = _extra
-    3: TV, img, x, y, _extra = _extra
+   1: TV, img, _extra = _extra
+   2: TV, img, x, _extra = _extra
+   3: TV, img, x, y, _extra = _extra
 endcase
-
+;
+if KEYWORD_SET(test) then STOP
+;
 end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/variance.pro gdl/src/pro/variance.pro
--- gdl-0.9.2/src/pro/variance.pro	2005-07-25 01:33:25.000000000 -0600
+++ gdl/src/pro/variance.pro	2012-07-13 16:28:02.000000000 -0600
@@ -1,17 +1,13 @@
-;$Id: variance.pro,v 1.2 2005/07/25 07:33:25 m_schellens Exp $
-function variance, x, double=double, NaN=NaN
-
-
-;+
+;$Id: variance.pro,v 1.3 2012/07/13 22:28:02 alaingdl Exp $
 ;
+function VARIANCE, x, double=double, NaN=NaN, dimension=dimension
 ;
+;+
 ;
-; NAME: 
-;       variance
+; NAME: VARIANCE
 ;
 ; PURPOSE: 
 ;     Calculates the variance of the input data
-;       
 ;
 ; CATEGORY:
 ;     Mathematics: Statistics
@@ -19,15 +15,15 @@
 ; CALLING SEQUENCE:
 ;     Result=variance(x)
 ;
-;
 ; KEYWORD PARAMETERS: 
 ;     DOUBLE : Keyword for double precision calculation
 ;     NAN    : Flag to treat IEEE Special Floating-Point values as missing data
+;     DIMENSION : if absent or equal to zero, compute the variance over the
+;                 whole data. otherwise, compute along the related dimension.
 ;
 ; OUTPUTS:
 ;    Result is the variance of input data
 ;
-;
 ; RESTRICTIONS:
 ;    The input x needs to be an array of numbers (i.e not strings,
 ;    struct, ptr, object)
@@ -37,28 +33,31 @@
 ;     Uses the MOMENT function
 ;
 ; EXAMPLE:
-;     a=findgen(100)
-;     result=variance(a)
+;     a=FINDGEN(100)
+;     result=VARIANCE(a)
 ;     print, result
 ;        841.667
 ;
 ; MODIFICATION HISTORY:
 ;   20-Mar-2004 : Written by Christopher Lee
-;   18-Jul-2005 : PC, moment.pro update 
+;   18-Jul-2005 : PC, moment.pro update
+;   13-Jul-2012 : Alain Coulais : adding DIMENSION keyword, using MOMENT()
 ;
 ; LICENCE:
-; Copyright (C) 2004, Christopher Lee
+; Copyright (C) 2004, Christopher Lee, 2005 P. Chanial, 2012 Alain Coulais
+;
 ; This program is free software; you can redistribute it and/or modify  
 ; it under the terms of the GNU General Public License as published by  
 ; the Free Software Foundation; either version 2 of the License, or     
 ; (at your option) any later version.                                   
 ;
-;
 ;-
-
- on_error, 2
- 
- m = moment(x, double=double, NaN=NaN)
- return, m[1]
-
+;
+ON_ERROR, 2
+;
+tmp = MOMENT(x, variance=variance, double=double, NaN=NaN, $
+             dimension=dimension, maxmoment=2)
+;
+return, variance
+;
 end
diff -ruN --exclude CVS gdl-0.9.2/src/pro/write_gif.pro gdl/src/pro/write_gif.pro
--- gdl-0.9.2/src/pro/write_gif.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/pro/write_gif.pro	2011-11-30 06:33:09.000000000 -0700
@@ -0,0 +1,120 @@
+;+
+;
+; NAME: WRITE_GIF
+;
+; PURPOSE: write a image from memory to a GIF
+;
+; CATEGORY: Images (IO)
+;
+; CALLING SEQUENCE: 
+;    WRITE_GIF, filename, image, Red, Green, Blue, $
+;               background_color=background_color, close=close, $
+;               delay_time=delay_time, disposal_method=disposal_method, $
+;               multiple=multiple, repeat_count=repeat_count, $
+;               transparent=transparent, user_input=user_input,                
+;               test=test, help=help, debug=debug
+;
+; KEYWORD PARAMETERS:
+;      Except very basic output, nothing is supported now, please contribute !
+;
+; OPTIONAL INPUTS: For pseudocolor only
+;        red  : the Red colormap vector (for PseudoColor images)
+;        green: the Green colormap vector (for PseudoColor images)
+;        blue : the Blue colormap vector (for PseudoColor images)
+;
+; RESTRICTIONS:
+;         Requires ImageMagick (tested)
+;         Most Keywords are not operational now.
+;
+; PROCEDURE:
+;         Use ImageMagick to write the data as requested
+;
+; EXAMPLE:
+;   READ_JPEG, 'testsuite/Saturn.jpg', image
+;   WRITE_GIF, 'Saturn2.gif', image
+;
+; MODIFICATION HISTORY:
+;  Written by: Alain Coulais 2011-11-30
+;  Derived work from WRITE_JPEG by: Christopher Lee 2004-05-17
+;-
+; LICENCE:
+; Copyright (C) 2011
+; This program is free software; you can redistribute it and/or modify  
+; it under the terms of the GNU General Public License as published by  
+; the Free Software Foundation; either version 2 of the License, or     
+; (at your option) any later version.                                   
+;
+;-
+;
+pro GIF_MESSAGE, mot_clef
+MESSAGE, /Continue, 'This Keyword '+STRUPCASE(mot_clef)+' is not operational'
+MESSAGE, /Continue, 'Please contribute !!'
+end
+;
+pro WRITE_GIF, filename, image, Red, Green, Blue, $
+               background_color=background_color, close=close, $
+               delay_time=delay_time, disposal_method=disposal_method, $
+               multiple=multiple, repeat_count=repeat_count, $
+               transparent=transparent, user_input=user_input, $
+               test=test, help=help, debug=debug
+;
+if ~KEYWORD_SET(debug) then ON_ERROR, 2
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro WRITE_GIF, filename, image, Red, Green, Blue, $'
+   print, '               background_color=background_color, close=close, $'
+   print, '               delay_time=delay_time, disposal_method=disposal_method, $'
+   print, '               multiple=multiple, repeat_count=repeat_count, $'
+   print, '               transparent=transparent, user_input=user_input, $'
+   print, '               help=help, test=test, debug=debug'
+   return
+endif
+;
+; Do we have access to ImageMagick functionnalities ??
+;
+if (MAGICK_EXISTS() EQ 0) then begin
+   MESSAGE, /continue, "GDL was compiled without ImageMagick support."
+   MESSAGE, "You must have ImageMagick support to use this functionaly."
+endif
+;
+if KEYWORD_SET(background_color) then GIF_MESSAGE, 'background_color'
+if KEYWORD_SET(close) then GIF_MESSAGE, 'close'
+if KEYWORD_SET(delay_time) then GIF_MESSAGE, 'delay_time'
+if KEYWORD_SET(disposal_method) then GIF_MESSAGE, 'disposal_method'
+if KEYWORD_SET(multiple) then GIF_MESSAGE, 'multiple'
+if KEYWORD_SET(user_input) then GIF_MESSAGE, 'user_input'
+if KEYWORD_SET(transparent) then GIF_MESSAGE, 'transparent'
+if KEYWORD_SET( user_input) then GIF_MESSAGE, ' user_input'
+;
+MESSAGE, /continue, 'This is a very preliminary procedure, please report problems'
+MESSAGE, /continue, '(if possible with link to the input image/test case)'
+;
+n=SIZE(image, /n_dimensions)
+s=SIZE(image, /dimensions)
+;
+if KEYWORD_SET(test) then STOP
+;
+if (n LT 2) then begin
+   MESSAGE, 'Image must be 2D or 3D'
+endif
+;
+if (n GT 3) then begin
+   MESSAGE, 'We don''t know how to manage a >3D image, please contribute'
+endif
+;
+if n EQ 2 then mid=MAGICK_CREATE(s[0],s[1])
+if n EQ 3 then mid=MAGICK_CREATE(s[1],s[2])
+;
+;TVLCT,r,g,b,/GET
+rgb=1
+MAGICK_WRITE, mid, image, rgb=rgb
+MAGICK_WRITEFILE, mid, filename,"GIF"
+MAGICK_CLOSE, mid
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+
+
+
+
diff -ruN --exclude CVS gdl-0.9.2/src/pro/write_image.pro gdl/src/pro/write_image.pro
--- gdl-0.9.2/src/pro/write_image.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/pro/write_image.pro	2012-02-15 09:00:15.000000000 -0700
@@ -0,0 +1,90 @@
+;+
+;
+; NAME: WRITE_IMAGE
+;
+; PURPOSE: write an image file (and colors tables) onto file
+;
+; CATEGORY: Images (IO)
+;
+; CALLING SEQUENCE: 
+;      WRITE_IMAGE, filename, format, image, [red, green, blue], /append
+;
+; KEYWORD PARAMETERS: 
+;        APPEND: not supported yet
+;
+; OUTPUTS: [n,m], [2,n,m], [3,n,m], [4,n,m] following image properties
+;          (transparency adds one extra Dim)
+;
+; OPTIONAL OUTPUTS: For pseudocolor only: Red, Green, Blue
+;
+; SIDE EFFECTS: 
+;
+; RESTRICTIONS:
+;         Requires ImageMagick (that means that GDL must have been
+;         compiled with ImageMagick)
+;
+; PROCEDURE:
+;         Use ImageMagick to read the data as requested
+;
+; EXAMPLE: An image of Saturn should be around in the GDL CVS
+;
+;         file=FILE_WHICH('Saturn.jpg')
+;         image=READ_IMAGE(file, image)
+;         TV, image, /true
+;         WRITE_IMAGE, 'Saturn.png', 'png', image
+;
+; MODIFICATION HISTORY:
+;  Initial version written by: Alain Coulais, 2012-02-15
+;  2012-Feb-12, Alain Coulais :
+;
+;-
+; LICENCE:
+; Copyright (C) 2012
+; This program is free software; you can redistribute it and/or modify  
+; it under the terms of the GNU General Public License as published by  
+; the Free Software Foundation; either version 2 of the License, or     
+; (at your option) any later version.                                   
+;
+;-
+;
+pro WRITE_IMAGE, filename, format, image, red, green, blue, $
+                 append=append, help=help, test=test
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro WRITE_IMAGE, filename, format, image, red, green, blue, $'
+   print, '                 append=append, help=help, test=test'
+   return
+endif
+;
+; Do we have access to ImageMagick functionnalities ??
+;
+if (MAGICK_EXISTS() EQ 0) then begin
+    MESSAGE, /continue, "GDL was compiled without ImageMagick support."
+    MESSAGE, "You must have ImageMagick support to use this functionaly."
+ endif
+;
+if ((N_PARAMS() EQ 0) OR (N_PARAMS() GT 6)) then $
+   MESSAGE, "Incorrect number of arguments."
+;
+if (STRLEN(filename) EQ 0) then MESSAGE, "Null filename not allowed."
+;
+case STRUPCASE(format) of
+   'JPEG' : begin
+      if (N_ELEMENTS(red) GT 0) then begin
+         colortable=BYTARR(256,3)
+         colortable[*,0]=red
+         colortable[*,1]=green
+         colortable[*,2]=blue
+         WRITE_JPEG, filename, image, colortable, colors=256
+      endif else begin
+         WRITE_JPEG, filename, image
+      endelse
+   end
+   'PNG' : WRITE_PNG, filename, image, red, green, blue
+   'GIF' : WRITE_GIF, filename, image, red, green, blue
+   else: MESSAGE, 'This format is not managed today, please contribute'
+endcase
+;
+if KEYWORD_SET(test) then STOP
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/src/prognode.cpp gdl/src/prognode.cpp
--- gdl-0.9.2/src/prognode.cpp	2011-11-07 16:38:21.000000000 -0700
+++ gdl/src/prognode.cpp	2011-12-13 00:20:25.000000000 -0700
@@ -552,7 +552,8 @@
 }
 
 
-
+// parameter nodes ////////////////////////////////////////////////
+// 1. keywords ////
 void KEYDEF_REFNode::Parameter( EnvBaseT* actEnv)
 {
   ProgNodeP _t = this->getFirstChild();
@@ -567,10 +568,6 @@
 			
   ProgNode::interpreter->_retTree = this->getNextSibling();
 }
-// void KEYDEF_REFNode::ParameterVarNum( EnvBaseT* actEnv)
-// {
-//   return Parameter( actEnv);
-// }
 
 void KEYDEF_REF_EXPRNode::Parameter( EnvBaseT* actEnv)
 {
@@ -591,10 +588,6 @@
 			
   ProgNode::interpreter->_retTree = this->getNextSibling();
 }
-// void KEYDEF_REF_EXPRNode::ParameterVarNum( EnvBaseT* actEnv)
-// {
-//   return Parameter( actEnv);
-// }
 
 void KEYDEFNode::Parameter( EnvBaseT* actEnv)
 {
@@ -608,11 +601,37 @@
 			
   ProgNode::interpreter->_retTree = this->getNextSibling();
 }
-// void KEYDEFNode::ParameterVarNum( EnvBaseT* actEnv)
-// {
-//   return Parameter( actEnv);
-// }
 
+void KEYDEF_REF_CHECKNode::Parameter( EnvBaseT* actEnv)
+{
+//   ProgNodeP _t = this->getFirstChild();
+//   ProgNodeP knameCk = _t;
+  // 			match(antlr::RefAST(_t),IDENTIFIER);
+//   _t = _t->getNextSibling();
+  BaseGDL* kval=ProgNode::interpreter->
+    lib_function_call(this->getFirstChild()->getNextSibling());
+			
+  BaseGDL** kvalRef = ProgNode::interpreter->callStack.back()->GetPtrTo( kval);
+  if( kvalRef != NULL)
+    {   // pass reference
+      actEnv->SetKeyword(this->getFirstChild()->getText(), kvalRef); 
+    }
+  else 
+    {   // pass value
+      actEnv->SetKeyword(this->getFirstChild()->getText(), kval); 
+    }
+			
+  ProgNode::interpreter->_retTree = this->getNextSibling();
+}
+
+
+// 2. Parameters ////
+bool REFNode::ParameterDirect( BaseGDL*& ref)
+{
+  BaseGDL** pvalRef=this->getFirstChild()->LEval();
+  ref = *pvalRef;
+  return true;
+}
 void REFNode::Parameter( EnvBaseT* actEnv)
 {
 //   ProgNodeP _t = this->getFirstChild();
@@ -631,6 +650,15 @@
   ProgNode::interpreter->_retTree = this->getNextSibling();
 }
 
+
+bool REF_EXPRNode::ParameterDirect( BaseGDL*& ref)
+{
+  BaseGDL* pval= this->getFirstChild()->Eval();//expr(_t);
+  delete pval;
+  BaseGDL** pvalRef=this->getFirstChild()->getNextSibling()->LEval();
+  ref = *pvalRef;
+  return true;
+}
 void REF_EXPRNode::Parameter( EnvBaseT* actEnv)
 {
   // 			match(antlr::RefAST(_t),REF_EXPR);
@@ -656,32 +684,21 @@
   ProgNode::interpreter->_retTree = this->getNextSibling();
 }
 
-void KEYDEF_REF_CHECKNode::Parameter( EnvBaseT* actEnv)
+// returns true if reference, false else
+bool REF_CHECKNode::ParameterDirect( BaseGDL*& pval)
 {
-//   ProgNodeP _t = this->getFirstChild();
-//   ProgNodeP knameCk = _t;
-  // 			match(antlr::RefAST(_t),IDENTIFIER);
-//   _t = _t->getNextSibling();
-  BaseGDL* kval=ProgNode::interpreter->
-    lib_function_call(this->getFirstChild()->getNextSibling());
-			
-  BaseGDL** kvalRef = ProgNode::interpreter->callStack.back()->GetPtrTo( kval);
-  if( kvalRef != NULL)
+  pval=ProgNode::interpreter->lib_function_call(this->getFirstChild());		
+  BaseGDL** pvalRef = ProgNode::interpreter->callStack.back()->GetPtrTo( pval);
+  return (pvalRef != NULL);
+  if( pvalRef != NULL)
     {   // pass reference
-      actEnv->SetKeyword(this->getFirstChild()->getText(), kvalRef); 
+      return true;
     }
   else 
     {   // pass value
-      actEnv->SetKeyword(this->getFirstChild()->getText(), kval); 
+      return false;
     }
-			
-  ProgNode::interpreter->_retTree = this->getNextSibling();
 }
-// void KEYDEF_REF_CHECKNode::ParameterVarNum( EnvBaseT* actEnv)
-// {
-//   return Parameter( actEnv);
-// }
-
 void REF_CHECKNode::Parameter( EnvBaseT* actEnv)
 {
   BaseGDL* pval=ProgNode::interpreter->lib_function_call(this->getFirstChild());
@@ -713,6 +730,11 @@
   ProgNode::interpreter->_retTree = this->getNextSibling();
 }
 
+bool ParameterNode::ParameterDirect( BaseGDL*& pval)
+{
+  pval = this->getFirstChild()->Eval(); 
+  return false;			
+}
 void ParameterNode::Parameter( EnvBaseT* actEnv)
 {
 //   BaseGDL* pval=this->Eval();//expr(this);
@@ -722,7 +744,6 @@
 			
   ProgNode::interpreter->_retTree = this->getNextSibling();
 }
-
 void ParameterVNNode::Parameter( EnvBaseT* actEnv)
 {
   actEnv->SetNextParUncheckedVarNum(this->getFirstChild()->Eval()); 
@@ -959,8 +980,8 @@
 
 RetCode  PCALL_LIBNode::Run()
 {
-  // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
-  StackGuard<EnvStackT> guard( ProgNode::interpreter->CallStack());
+//   // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+//   StackGuard<EnvStackT> guard( ProgNode::interpreter->CallStack());
   BaseGDL *self;
 	
   // 		match(antlr::RefAST(_t),PCALL_LIB);
@@ -972,11 +993,13 @@
   EnvT* newEnv=new EnvT( pl, pl->libPro);//libProList[pl->proIx]);
 		
   ProgNode::interpreter->parameter_def_nocheck(_t, newEnv);
+  auto_ptr<EnvT> guardEnv( newEnv);
+
   //   _t = _retTree;
   //if( this->getLine() != 0) ProgNode::interpreter->callStack.back()->SetLineNumber( this->getLine());
 		
-  // push environment onto call stack
-  ProgNode::interpreter->callStack.push_back(newEnv);
+//   // push environment onto call stack
+//   ProgNode::interpreter->callStack.push_back(newEnv);
 		
   // make the call
   static_cast<DLibPro*>(newEnv->GetPro())->Pro()(newEnv);
@@ -1748,13 +1771,13 @@
 }
 RetCode      BREAKNode::Run()
 {
-  if( this->breakTarget == NULL)
+  if( !this->breakTargetSet)
 	{
 	assert( interpreter != NULL);
 	EnvBaseT* e = interpreter->CallStack().back();
-	throw GDLException( this, "BREAK must be enclosed within a FOR, WHILE, or REPEAT loop.", true, false);
+	throw GDLException( this, "BREAK must be enclosed within a loop (FOR, WHILE, REPEAT), CASE or SWITCH statement.", true, false);
 	}
-ProgNode::interpreter->SetRetTree( this->breakTarget);
+  ProgNode::interpreter->SetRetTree( this->breakTarget);
   return RC_OK;
 }
 RetCode      LABELNode::Run()
diff -ruN --exclude CVS gdl-0.9.2/src/prognodeexpr.cpp gdl/src/prognodeexpr.cpp
--- gdl-0.9.2/src/prognodeexpr.cpp	2011-11-07 16:38:21.000000000 -0700
+++ gdl/src/prognodeexpr.cpp	2011-12-05 03:48:26.000000000 -0700
@@ -168,9 +168,11 @@
 //       throw GDLException( "Expressions of this type cannot be converted.");
 //     }
 
+  // Change > to >= JMG
+  if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+    {
   // COMPLEX op DOUBLE = COMPLEXDBL
-  if( (aTy == COMPLEX && bTy == DOUBLE) ||
-      (bTy == COMPLEX && aTy == DOUBLE))
+  if( (aTy == COMPLEX && bTy == DOUBLE))
     {
       e2 = e2->Convert2( COMPLEXDBL, BaseGDL::COPY);
       g2.reset( e2); // delete former e2
@@ -179,15 +181,22 @@
       return;
     }
 
-  // Change > to >= JMG
-  if( DTypeOrder[aTy] >= DTypeOrder[bTy])
-    {
       // convert e2 to e1
       e2 = e2->Convert2( aTy, BaseGDL::COPY);
       g2.reset( e2); // delete former e2
     }
   else
     {
+  // COMPLEX op DOUBLE = COMPLEXDBL
+  if( (bTy == COMPLEX && aTy == DOUBLE))
+    {
+      e2 = e2->Convert2( COMPLEXDBL, BaseGDL::COPY);
+      g2.reset( e2); // delete former e2
+      e1 = e1->Convert2( COMPLEXDBL, BaseGDL::COPY);
+      g1.reset( e1); // delete former e1
+      return;
+    }
+
       // convert e1 to e2
       e1 = e1->Convert2( bTy, BaseGDL::COPY);
       g1.reset( e1); // delete former e1
@@ -1231,6 +1240,132 @@
   res=e1->GtOp(e2);
   return res;
 }
+BaseGDL* PLUSNC12Node::Eval()
+{
+  BaseGDL *e1 = op1->EvalNC();
+  BaseGDL *e2 = op2->EvalNC();
+  DType aTy=e1->Type();
+  DType bTy=e2->Type();
+  if( aTy == bTy)
+  {
+    if ( e1->StrictScalar() )
+    {
+      return e2->AddInvSNew( e1 ); // scalar+scalar or array+scalar
+    }
+    else if ( e2->StrictScalar() )
+    {
+      return e1->AddSNew( e2); // array+scalar
+    }
+    else if ( e1->N_Elements() <= e2->N_Elements() )
+    {
+      return e1->AddNew ( e2 );
+    }
+    else // e1->N_Elements() > e2->N_Elements() )
+    {
+      return e2->AddInvNew( e1); // smaller + larger
+    }
+  }
+  auto_ptr<BaseGDL> g1;
+  auto_ptr<BaseGDL> g2;
+  if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+    {
+      // COMPLEX op DOUBLE = COMPLEXDBL
+      if(aTy == COMPLEX && bTy == DOUBLE)
+      {
+	  e2 = e2->Convert2( COMPLEXDBL, BaseGDL::COPY);
+	  g2.reset( e2);
+	  e1 = e1->Convert2( COMPLEXDBL, BaseGDL::COPY);
+	  g1.reset( e1);
+      }
+      else
+      {
+	// convert e2 to e1
+	e2 = e2->Convert2( aTy, BaseGDL::COPY);
+	g2.reset( e2);
+      }
+    }
+  else
+    {
+      // COMPLEX op DOUBLE = COMPLEXDBL
+      if( (bTy == COMPLEX && aTy == DOUBLE))
+	{
+	  e2 = e2->Convert2( COMPLEXDBL, BaseGDL::COPY);
+	  g2.reset( e2);
+	  e1 = e1->Convert2( COMPLEXDBL, BaseGDL::COPY);
+	  g1.reset( e1);
+	}
+      else
+	{// convert e1 to e2
+	    e1 = e1->Convert2( bTy, BaseGDL::COPY);
+	    g1.reset( e1);
+	}
+    }
+    
+  // 'classic handling from here
+  BaseGDL* res;
+  if ( e1->StrictScalar() )
+  {
+	  if ( g2.get() == NULL )
+	  {
+		  res= e2->AddInvSNew( e1 ); // scalar+scalar or array+scalar
+	  }
+	  else
+	  {
+		  g2.release();
+		  res= e2->AddInvS( e1 ); // scalar+scalar or array+scalar
+	  }
+  }
+  else if ( e2->StrictScalar() )
+  {
+	  if ( g1.get() == NULL )
+		  res= e1->AddSNew( e2); // array+scalar
+	  else
+	  {
+		  g1.release();
+		  res= e1->AddS( e2); // array+scalar
+	  }
+  }
+  else if ( e1->N_Elements() == e2->N_Elements() )
+  {
+	  if ( g1.get() != NULL )
+	  {
+		  g1.release();
+		  return e1->Add ( e2 );
+	  }
+	  if ( g2.get() != NULL )
+	  {
+		  g2.release();
+		  res = e2->AddInv ( e1 );
+		  res->SetDim ( e1->Dim() );
+		  return res;
+	  }
+	  else
+	  {
+		  return e1->AddNew ( e2 );
+	  }
+  }
+  else if ( e1->N_Elements() < e2->N_Elements() )
+  {
+	  if ( g1.get() == NULL )
+		  res= e1->AddNew ( e2 ); // smaller_array + larger_array or same size
+	    else
+	    {
+		  g1.release();
+		  res= e1->Add ( e2 ); // smaller_array + larger_array or same size
+	  }
+  }
+  else // e1->N_Elements() > e2->N_Elements() )
+  {
+	  if ( g2.get() == NULL )
+		  res= e2->AddInvNew( e1); // smaller + larger
+	  else
+	  {
+		  g2.release();
+		  res= e2->AddInv( e1); // smaller + larger
+	  }
+  }
+  return res;
+}
 BaseGDL* PLUSNCNode::Eval()
 {
 	BaseGDL* res;
@@ -1301,8 +1436,121 @@
 	}
 	return res;
 }
+
+
+BaseGDL* MINUSNC12Node::Eval()
+{ 
+  BaseGDL *e1 = op1->EvalNC();
+  BaseGDL *e2 = op2->EvalNC();
+  DType aTy=e1->Type();
+  DType bTy=e2->Type();
+  if( aTy == bTy)
+  {
+    if ( e1->StrictScalar() )
+    {
+      return e2->SubInvSNew( e1 ); // scalar+scalar or array+scalar
+    }
+    else if ( e2->StrictScalar() )
+    {
+      return e1->SubSNew( e2); // array+scalar
+    }
+    else if ( e1->N_Elements() <= e2->N_Elements() )
+    {
+      return e1->SubNew ( e2 );
+    }
+    else // e1->N_Elements() > e2->N_Elements() )
+    {
+      return e2->SubInvNew( e1); // smaller + larger
+    }
+  }
+
+  auto_ptr<BaseGDL> g1;
+  auto_ptr<BaseGDL> g2;
+  if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+    {
+      // COMPLEX op DOUBLE = COMPLEXDBL
+      if( aTy == COMPLEX && bTy == DOUBLE)
+      {
+	  e2 = e2->Convert2( COMPLEXDBL, BaseGDL::COPY);
+	  g2.reset( e2);
+	  e1 = e1->Convert2( COMPLEXDBL, BaseGDL::COPY);
+	  g1.reset( e1);
+      }
+      else
+      {
+	// convert e2 to e1
+	e2 = e2->Convert2( aTy, BaseGDL::COPY);
+	g2.reset( e2);
+      }
+    }
+  else
+    {
+      // COMPLEX op DOUBLE = COMPLEXDBL
+      if( (bTy == COMPLEX && aTy == DOUBLE))
+	{
+	  e2 = e2->Convert2( COMPLEXDBL, BaseGDL::COPY);
+	  g2.reset( e2);
+	  e1 = e1->Convert2( COMPLEXDBL, BaseGDL::COPY);
+	  g1.reset( e1);
+	}
+      else
+	{// convert e1 to e2
+	    e1 = e1->Convert2( bTy, BaseGDL::COPY);
+	    g1.reset( e1);
+	}
+    }
+    
+  // 'classic handling from here
+  BaseGDL* res;
+  if( e1->StrictScalar())
+    {
+      if( g2.get() == NULL) return e2->SubInvSNew( e1); else g2.release();
+      res= e2->SubInvS(e1); // scalar+scalar or array+scalar
+      
+    }
+  else
+    if( e2->StrictScalar())
+      {
+	if( g1.get() == NULL) return e1->SubSNew( e2); else g1.release();
+	res= e1->SubS(e2); // array+scalar
+	
+      }
+    else if( e1->N_Elements() == e2->N_Elements())
+    {
+      if( g1.get() != NULL)
+	{
+	  g1.release();
+	  return e1->Sub(e2);
+	}
+      if( g2.get() != NULL) 
+	{
+	  g2.release();
+	  res = e2->SubInv(e1);
+	  res->SetDim( e1->Dim());
+	  return res;
+	}
+      else
+	{
+	return e1->SubNew(e2); 
+	}
+    }
+  else if( e1->N_Elements() < e2->N_Elements())
+	{
+	  if( g1.get() == NULL) return e1->SubNew( e2); else g1.release();
+	  res= e1->Sub(e2); // smaller_array + larger_array or same size
+	  
+	}
+      else
+	{
+	  if( g2.get() == NULL) return e2->SubInvNew( e1); else g2.release();
+	  res= e2->SubInv(e1); // smaller + larger
+	  
+	}
+  return res;
+}
 BaseGDL* MINUSNCNode::Eval()
-{ BaseGDL* res;
+{ 
+ BaseGDL* res;
  auto_ptr<BaseGDL> g1;
  auto_ptr<BaseGDL> g2;
  BaseGDL *e1, *e2; AdjustTypesNC( g1, e1, g2, e2); 
@@ -1457,6 +1705,143 @@
        }
  return res;
 }
+
+BaseGDL* ASTERIXNC12Node::Eval()
+{
+  BaseGDL *e1 = op1->EvalNC();
+  BaseGDL *e2 = op2->EvalNC();
+  DType aTy=e1->Type();
+  DType bTy=e2->Type();
+  if( aTy == bTy)
+  {
+    if ( e1->StrictScalar() )
+    {
+      return e2->MultSNew( e1 ); // scalar+scalar or array+scalar
+    }
+    else if ( e2->StrictScalar() )
+    {
+      return e1->MultSNew( e2); // array+scalar
+    }
+    else if ( e1->N_Elements() <= e2->N_Elements() )
+    {
+      return e1->MultNew ( e2 );
+    }
+    else // e1->N_Elements() > e2->N_Elements() )
+    {
+      return e2->MultNew( e1); // smaller + larger
+    }
+  }
+  
+  auto_ptr<BaseGDL> g1;
+  auto_ptr<BaseGDL> g2;
+  if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+    {
+      // COMPLEX op DOUBLE = COMPLEXDBL
+      if( aTy == COMPLEX && bTy == DOUBLE)
+      {
+	  e2 = e2->Convert2( COMPLEXDBL, BaseGDL::COPY);
+	  g2.reset( e2);
+	  e1 = e1->Convert2( COMPLEXDBL, BaseGDL::COPY);
+	  g1.reset( e1);
+      }
+      else
+      {
+	// convert e2 to e1
+	e2 = e2->Convert2( aTy, BaseGDL::COPY);
+	g2.reset( e2);
+      }
+    }
+  else
+    {
+      // COMPLEX op DOUBLE = COMPLEXDBL
+      if( (bTy == COMPLEX && aTy == DOUBLE))
+	{
+	  e2 = e2->Convert2( COMPLEXDBL, BaseGDL::COPY);
+	  g2.reset( e2);
+	  e1 = e1->Convert2( COMPLEXDBL, BaseGDL::COPY);
+	  g1.reset( e1);
+	}
+      else
+	{// convert e1 to e2
+	    e1 = e1->Convert2( bTy, BaseGDL::COPY);
+	    g1.reset( e1);
+	}
+    }
+    
+  // 'classic handling from here
+  BaseGDL* res;
+  if ( e1->StrictScalar() )
+  {
+	  if ( g2.get() == NULL )
+	  {
+		  res= e2->MultSNew( e1); // scalar+scalar or array+scalar
+	  }
+	  else
+	  {
+		  g2.release();
+		  res= e2->MultS( e1); // scalar+scalar or array+scalar
+	  }
+  }
+  else	if ( e2->StrictScalar() )
+  {
+	  if ( g1.get() == NULL )
+	  {
+// 			return e1->New( e2);
+		  res= e1->MultSNew( e2); // array+scalar
+	  }
+	  else
+	  {
+		  g1.release();
+		  res= e1->MultS( e2); // array+scalar
+	  }
+  }
+  else if ( e1->N_Elements() == e2->N_Elements() )
+  {
+	  if ( g1.get() != NULL )
+	  {
+		  g1.release();
+		  return e1->Mult( e2);
+	  }
+	  else if ( g2.get() != NULL )
+	  {
+		  g2.release();
+		  res = e2->Mult( e1);
+		  res->SetDim( e1->Dim());
+		  return res;
+	  }
+	  else
+	  {
+		  return e1->MultNew( e2);
+// 			return e1->Dup()->Mult ( e2 );
+	  }
+  }
+  else if ( e1->N_Elements() < e2->N_Elements() )
+  {
+	  if ( g1.get() == NULL )
+	  {
+		  // 		 return e1->New( e2);
+		  res= e1->MultNew( e2); // smaller_array + larger_array or same size
+	    }
+	  else
+	  {
+		  g1.release();
+		  res= e1->Mult( e2); // smaller_array + larger_array or same size
+	  }
+  }
+  else
+  {
+	  if ( g2.get() == NULL )
+	  {
+		  res = e2->MultNew( e1); // smaller + larger
+	  }
+	    else
+	  {
+		  g2.release();
+		  res= e2->Mult( e1); // smaller + larger
+	  }
+  }
+  return res;
+}
 BaseGDL* ASTERIXNCNode::Eval()
 {
 	BaseGDL* res;
@@ -1640,6 +2025,118 @@
  res=e2->MatrixOp(e1);
  return res;
 }
+
+BaseGDL* SLASHNC12Node::Eval()
+{
+  BaseGDL *e1 = op1->EvalNC();
+  BaseGDL *e2 = op2->EvalNC();
+  DType aTy=e1->Type();
+  DType bTy=e2->Type();
+  if( aTy == bTy)
+  {
+    if ( e1->StrictScalar() )
+    {
+      return e2->DivInvSNew( e1 ); // scalar+scalar or array+scalar
+    }
+    else if ( e2->StrictScalar() )
+    {
+      return e1->DivSNew( e2); // array+scalar
+    }
+    else if ( e1->N_Elements() <= e2->N_Elements() )
+    {
+      return e1->DivNew ( e2 );
+    }
+    else // e1->N_Elements() > e2->N_Elements() )
+    {
+      return e2->DivInvNew( e1); // smaller + larger
+    }
+  }
+
+  auto_ptr<BaseGDL> g1;
+  auto_ptr<BaseGDL> g2;
+  if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+    {
+      // COMPLEX op DOUBLE = COMPLEXDBL
+      if( aTy == COMPLEX && bTy == DOUBLE)
+      {
+	  e2 = e2->Convert2( COMPLEXDBL, BaseGDL::COPY);
+	  g2.reset( e2);
+	  e1 = e1->Convert2( COMPLEXDBL, BaseGDL::COPY);
+	  g1.reset( e1);
+      }
+      else
+      {
+	// convert e2 to e1
+	e2 = e2->Convert2( aTy, BaseGDL::COPY);
+	g2.reset( e2);
+      }
+    }
+  else
+    {
+      // COMPLEX op DOUBLE = COMPLEXDBL
+      if( (bTy == COMPLEX && aTy == DOUBLE))
+	{
+	  e2 = e2->Convert2( COMPLEXDBL, BaseGDL::COPY);
+	  g2.reset( e2);
+	  e1 = e1->Convert2( COMPLEXDBL, BaseGDL::COPY);
+	  g1.reset( e1);
+	}
+      else
+	{// convert e1 to e2
+	    e1 = e1->Convert2( bTy, BaseGDL::COPY);
+	    g1.reset( e1);
+	}
+    }
+    
+ // 'classic handling from here
+ BaseGDL* res;
+ if( e1->StrictScalar())
+   {
+     if( g2.get() == NULL) return e2->DivInvSNew( e1); else g2.release();
+     res= e2->DivInvS(e1); // scalar+scalar or array+scalar
+     
+   }
+ else
+   if( e2->StrictScalar())
+     {
+       if( g1.get() == NULL) return e1->DivSNew( e2); else g1.release();
+       res= e1->DivS(e2); // array+scalar
+       
+     }
+   else if( e1->N_Elements() == e2->N_Elements())
+   {
+     if( g1.get() != NULL)
+       {
+	 g1.release();
+	 return e1->Div(e2);
+       }
+     if( g2.get() != NULL) 
+       {
+	 g2.release();
+	 res = e2->DivInv(e1);
+	 res->SetDim( e1->Dim());
+	 return res;
+       }
+     else
+       {
+       return e1->DivNew(e2); 
+       }
+   }
+else if( e1->N_Elements() < e2->N_Elements())
+       {
+	 if( g1.get() == NULL) return e1->DivNew( e2); else g1.release();
+	 res= e1->Div(e2); // smaller_array + larger_array or same size
+	 
+       }
+     else
+       {
+	 if( g2.get() == NULL) return e2->DivInvNew( e1); else g2.release();
+	 res= e2->DivInv(e1); // smaller + larger
+	 
+       }
+
+ return res;
+}
 BaseGDL* SLASHNCNode::Eval()
 { BaseGDL* res;
  auto_ptr<BaseGDL> g1;
@@ -1992,37 +2489,68 @@
 //   return new POSTINCNode( refNode);
 // }
 
-  BaseGDL** FCALL_LIB_RETNEWNode::LEval()
+  BaseGDL** FCALL_LIB_N_ELEMENTSNode::LEval()
   {
       // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
     StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+    throw GDLException(this,"Internal error: N_ELEMENTS called as left expr.");
+  }
+
+  BaseGDL* FCALL_LIB_N_ELEMENTSNode::Eval()
+  {
+    try
+      {
+	BaseGDL* param;
+	bool isReference = 
+	  static_cast<ParameterNode*>(this->getFirstChild())->ParameterDirect( param);
+	auto_ptr<BaseGDL> guard;
+	if( !isReference)
+	  guard.reset( param);
+
+	if( param == NULL)
+	  return new DLongGDL( 0);
+	
+	return new DLongGDL( param->N_Elements());   
+      } 
+    catch( GDLException& e)
+      {
+	// an error occured -> parameter is undefined 
+	return new DLongGDL( 0);
+      }
+  }
+
+  BaseGDL** FCALL_LIB_RETNEWNode::LEval()
+  {
     throw GDLException(this,"Internal error: FCALL_LIB_RETNEW as left expr.");
   }
-  
+
   BaseGDL* FCALL_LIB_RETNEWNode::Eval()
   {
-    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
-    StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
 // 	match(antlr::RefAST(_t),FCALL_LIB_RETNEW);
 //	_t = _t->getFirstChild();
 // 	match(antlr::RefAST(_t),IDENTIFIER);
     EnvT* newEnv=new EnvT( this, this->libFun);//libFunList[fl->funIx]);
+//     auto_ptr< EnvT> guardEnv( newEnv);
 // 	_t =_t->getFirstChild();
 // 	EnvT* newEnv=new EnvT( fl, fl->libFun);//libFunList[fl->funIx]);
 	// special handling for N_ELEMENTS()
-    static int n_elementsIx = LibFunIx("N_ELEMENTS");
-    static DLibFun* n_elementsFun = libFunList[n_elementsIx];
-
-    if( this->libFun == n_elementsFun)
-        {
-            ProgNode::interpreter->parameter_def_n_elements(this->getFirstChild(), newEnv);
-        }
-    else
-        {
+//     static int n_elementsIx = LibFunIx("N_ELEMENTS");
+//     static DLibFun* n_elementsFun = libFunList[n_elementsIx];
+// 
+//     if( this->libFun == n_elementsFun)
+//         {
+//             ProgNode::interpreter->parameter_def_n_elements(this->getFirstChild(), newEnv);
+//         }
+//     else
+//         {
             ProgNode::interpreter->parameter_def_nocheck(this->getFirstChild(), newEnv);
-        }
+//         }
     // push id.pro onto call stack
-    ProgNode::interpreter->CallStack().push_back(newEnv);
+// 	guardEnv.release();
+	auto_ptr<EnvT> guardEnv( newEnv);
+//     // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+//     StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+//     ProgNode::interpreter->CallStack().push_back(newEnv);
     // make the call
     //*** MUST always return a defined expression
     BaseGDL* res = static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
@@ -2030,22 +2558,60 @@
     return res;
   }
 
+  BaseGDL** FCALL_LIB_DIRECTNode::LEval()
+  {
+    throw GDLException(this,"Internal error: FCALL_LIB_DIRECTNode as left expr.");
+  }
+
+  BaseGDL* FCALL_LIB_DIRECTNode::Eval()
+  {
+    BaseGDL* param;
+    bool isReference = 
+      static_cast<ParameterNode*>(this->getFirstChild())->ParameterDirect( param);
+    auto_ptr<BaseGDL> guard;
+    if( !isReference)
+      guard.reset( param);
+    // check already here to keep functions leaner
+    if( param == NULL)
+    {
+      assert( isReference);
+      // unfortunately we cannot retrieve the variable's name here without some effort
+      throw GDLException(this, 
+			 this->libFun->ObjectName()+": Variable is undefined.",
+			 false,false);
+    }
+    try {
+      BaseGDL* res = 
+	static_cast<DLibFunDirect*>(this->libFun)->FunDirect()(param, isReference);
+      assert( res != NULL); //*** MUST always return a defined expression
+      if( res == param)
+	guard.release();
+      return res;
+    }
+    catch( GDLException& ex)
+    {
+      // annotate exception
+      throw GDLException(this, this->libFun->ObjectName()+": "+ ex.getMessage(),false,false); 
+    }
+  }
+
   BaseGDL** FCALL_LIBNode::LEval()
   {
-    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
-    StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+//     // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+//     StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
     // 	match(antlr::RefAST(_t),FCALL_LIB);
     EnvT* newEnv=new EnvT( this, this->libFun);//libFunList[fl->funIx]);
 
-    EnvT* callerEnv = static_cast<EnvT*>(ProgNode::interpreter->CallStackBack());
+//     EnvUDT* callerEnv = ProgNode::interpreter->CallStackBack();
 
     ProgNode::interpreter->parameter_def_nocheck(this->getFirstChild(), newEnv);
+	auto_ptr<EnvT> guardEnv( newEnv);
 
-    // push id.pro onto call stack
-    ProgNode::interpreter->CallStack().push_back(newEnv);
+//     // push id.pro onto call stack
+//     ProgNode::interpreter->CallStack().push_back(newEnv);
     // make the call
     BaseGDL* libRes =	static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
-    BaseGDL** res = callerEnv->GetPtrTo( libRes);
+    BaseGDL** res = ProgNode::interpreter->CallStackBack()->GetPtrTo( libRes);
     if( res == NULL)
 	    throw GDLException( this, "Library function must return a "
 	    "l-value in this context: "+this->getText());
@@ -2054,17 +2620,18 @@
 
   BaseGDL* FCALL_LIBNode::EvalFCALL_LIB()
   {
-    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
-    StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+//     // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+//     StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
     EnvT* newEnv=new EnvT( this, this->libFun);//libFunList[fl->funIx]);
 	
     ProgNode::interpreter->parameter_def_nocheck(this->getFirstChild(), newEnv);
+	auto_ptr<EnvT> guardEnv( newEnv);
 
     assert( dynamic_cast<EnvUDT*>(ProgNode::interpreter->CallStackBack()) != NULL);
     EnvUDT* callStackBack = static_cast<EnvUDT*>(ProgNode::interpreter->CallStackBack());
 		
-    // push id.pro onto call stack
-    ProgNode::interpreter->CallStack().push_back(newEnv);
+//     // push id.pro onto call stack
+//     ProgNode::interpreter->CallStack().push_back(newEnv);
     // make the call
     BaseGDL* res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
     // *** MUST always return a defined expression
@@ -2075,18 +2642,20 @@
   // returns always a new variable - see EvalFCALL_LIB
   BaseGDL* FCALL_LIBNode::Eval() 
   {
-    // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
-    StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
+//     // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+//     StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
     // 	match(antlr::RefAST(_t),FCALL_LIB);
     EnvT* newEnv=new EnvT( this, this->libFun);//libFunList[fl->funIx]);
 
     ProgNode::interpreter->parameter_def_nocheck(this->getFirstChild(), newEnv);
 
+	auto_ptr<EnvT> guardEnv( newEnv);
+
     assert( dynamic_cast<EnvUDT*>(ProgNode::interpreter->CallStackBack()) != NULL);
     EnvUDT* callStackBack = static_cast<EnvUDT*>(ProgNode::interpreter->CallStackBack());
-	    
-    // push id.pro onto call stack
-    ProgNode::interpreter->CallStack().push_back(newEnv);
+
+//     // push id.pro onto call stack
+//     ProgNode::interpreter->CallStack().push_back(newEnv);
     // make the call
     BaseGDL* res=static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
     // *** MUST always return a defined expression
diff -ruN --exclude CVS gdl-0.9.2/src/prognodeexpr.hpp gdl/src/prognodeexpr.hpp
--- gdl-0.9.2/src/prognodeexpr.hpp	2011-11-01 21:47:29.000000000 -0600
+++ gdl/src/prognodeexpr.hpp	2011-11-15 16:19:00.000000000 -0700
@@ -103,6 +103,24 @@
   BaseGDL* Eval();
 };
 
+class FCALL_LIB_DIRECTNode: public LeafNode
+{
+public:
+  FCALL_LIB_DIRECTNode( const RefDNode& refNode): LeafNode( refNode)
+  {}
+  BaseGDL** LEval();
+  BaseGDL* Eval();
+};
+
+class FCALL_LIB_N_ELEMENTSNode: public LeafNode
+{
+public:
+  FCALL_LIB_N_ELEMENTSNode( const RefDNode& refNode): LeafNode( refNode)
+  {}
+  BaseGDL** LEval();
+  BaseGDL* Eval();
+};
+
 
 
 class FCALL_LIBNode: public LeafNode
@@ -499,11 +517,21 @@
   PLUSNCNode( const RefDNode& refNode): BinaryExprNC( refNode){}
   BaseGDL* Eval();
 };
+class PLUSNC12Node: public BinaryExprNC // both are NC
+{ public:
+  PLUSNC12Node( const RefDNode& refNode): BinaryExprNC( refNode){}
+  BaseGDL* Eval();
+};
 class MINUSNCNode: public BinaryExprNC
 { public:
   MINUSNCNode( const RefDNode& refNode): BinaryExprNC( refNode){}
   BaseGDL* Eval();
 };
+class MINUSNC12Node: public BinaryExprNC
+{ public:
+  MINUSNC12Node( const RefDNode& refNode): BinaryExprNC( refNode){}
+  BaseGDL* Eval();
+};
 class LTMARKNCNode: public BinaryExprNC
 { public:
   LTMARKNCNode( const RefDNode& refNode): BinaryExprNC( refNode){}
@@ -514,6 +542,11 @@
   GTMARKNCNode( const RefDNode& refNode): BinaryExprNC( refNode){}
   BaseGDL* Eval();
 };
+class ASTERIXNC12Node: public BinaryExprNC // both are NC
+{ public:
+  ASTERIXNC12Node( const RefDNode& refNode): BinaryExprNC( refNode){}
+  BaseGDL* Eval();
+};
 class ASTERIXNCNode: public BinaryExprNC
 { public:
   ASTERIXNCNode( const RefDNode& refNode): BinaryExprNC( refNode){}
@@ -534,6 +567,11 @@
   SLASHNCNode( const RefDNode& refNode): BinaryExprNC( refNode){}
   BaseGDL* Eval();
 };
+class SLASHNC12Node: public BinaryExprNC
+{ public:
+  SLASHNC12Node( const RefDNode& refNode): BinaryExprNC( refNode){}
+  BaseGDL* Eval();
+};
 class MOD_OPNCNode: public BinaryExprNC
 { public:
   MOD_OPNCNode( const RefDNode& refNode): BinaryExprNC( refNode){}
diff -ruN --exclude CVS gdl-0.9.2/src/prognode.hpp gdl/src/prognode.hpp
--- gdl-0.9.2/src/prognode.hpp	2011-11-07 16:38:21.000000000 -0700
+++ gdl/src/prognode.hpp	2011-12-13 00:20:25.000000000 -0700
@@ -387,13 +387,17 @@
 };
 class BREAKNode: public DefaultNode
 {
+private:
+	bool breakTargetSet;
+
 public:
- RetCode      Run();
+	RetCode      Run();
 	
 
 	void SetAllBreak( ProgNodeP target)
 	{
 		breakTarget = target;
+		breakTargetSet = true;
 		
 		if( right != NULL && !keepRight)
 		{
@@ -401,9 +405,9 @@
 		}
 	}
 public:
-    BREAKNode(): DefaultNode()  {}
+    BREAKNode(): DefaultNode(), breakTargetSet(false)  {}
 	
-	BREAKNode( const RefDNode& refNode): DefaultNode( refNode)
+	BREAKNode( const RefDNode& refNode): DefaultNode( refNode), breakTargetSet(false)
 	{}
 };
 class LABELNode: public DefaultNode
@@ -1347,6 +1351,7 @@
 public:
   ParameterNode( const RefDNode& refNode): DefaultNode( refNode) {}
   virtual void Parameter( EnvBaseT* actEnv);
+  virtual bool ParameterDirect( BaseGDL*& paramP);
 //   virtual void ParameterVarNum( EnvBaseT* actEnv); // for variable number of parameters
 };
 
@@ -1395,6 +1400,7 @@
 public:
   REF_EXPRNode( const RefDNode& refNode): ParameterNode( refNode) {}
   void Parameter( EnvBaseT* actEnv);
+  bool ParameterDirect( BaseGDL*& paramP);
 //   void ParameterVarNum( EnvBaseT* actEnv); // for variable number of parameters
 };
 class REF_EXPRVNNode: public ParameterNode
@@ -1410,6 +1416,7 @@
 public:
   REF_CHECKNode( const RefDNode& refNode): ParameterNode( refNode) {}
   void Parameter( EnvBaseT* actEnv);
+  bool ParameterDirect( BaseGDL*& paramP);
 //   void ParameterVarNum( EnvBaseT* actEnv); // for variable number of parameters
 };
 class REF_CHECKVNNode: public ParameterNode
@@ -1425,6 +1432,7 @@
 public:
   REFNode( const RefDNode& refNode): ParameterNode( refNode) {}
   void Parameter( EnvBaseT* actEnv);
+  bool ParameterDirect( BaseGDL*& paramP);
 //   void ParameterVarNum( EnvBaseT* actEnv); // for variable number of parameters
 };
 class REFVNNode: public ParameterNode
diff -ruN --exclude CVS gdl-0.9.2/src/specializations.hpp gdl/src/specializations.hpp
--- gdl-0.9.2/src/specializations.hpp	2011-10-19 08:45:19.000000000 -0600
+++ gdl/src/specializations.hpp	2011-12-08 00:03:09.000000000 -0700
@@ -673,6 +673,12 @@
 
 
 
+template<>
+BaseGDL* Data_<SpDString>::CShift( DLong d) const;
+template<>
+BaseGDL* Data_<SpDPtr>::CShift( DLong d) const;
+template<>
+BaseGDL* Data_<SpDObj>::CShift( DLong d) const;
 
 
 // topython.cpp
diff -ruN --exclude CVS gdl-0.9.2/src/str.cpp gdl/src/str.cpp
--- gdl-0.9.2/src/str.cpp	2011-11-08 15:15:51.000000000 -0700
+++ gdl/src/str.cpp	2011-11-29 22:43:03.000000000 -0700
@@ -179,6 +179,17 @@
     r[i]=toupper(sCStr[i]);
   return string(r);
 }
+void StrUpCaseInplace( string& s)
+{
+  unsigned len=s.length();
+//   char const *sCStr=s.c_str();
+//   char* r = new char[len+1];
+//   ArrayGuard<char> guard( r);
+//   r[len]=0;
+  for(unsigned i=0;i<len;i++)
+    s[i]=toupper(s[i]);
+//   return string(r);
+}
 
 string StrLowCase(const string& s)
 {
@@ -191,6 +202,14 @@
     r[i]=tolower(sCStr[i]);
   return string(r);
 }
+void StrLowCaseInplace(string& s)
+{
+  unsigned len=s.length();
+//   char const *sCStr=s.c_str();
+  for(unsigned i=0;i<len;i++)
+    s[i]=tolower(s[i]);
+//     s[i]=tolower(sCStr[i]);
+}
 
 double Str2D( const char* cStart)
 {
@@ -247,17 +266,30 @@
 //cout << "WordExp  in: " << s << endl;
 #if !defined(__OpenBSD__)
 // esc whitespace
-       string sEsc;
-       for( int i=0; i<s.length(); ++i)
-       {
-               if( s[i] == ' ')
-                       sEsc += "\\ ";
-               else
-                       sEsc += s[i];
-       }
+// which is not already escaped
+//   string sEsc;
+//   for( int i=0; i<s.length(); ++i)
+//   {
+//     if( s[i] == ' ')
+// 	sEsc += "\\ ";
+//     else if( s[i] == '\\')
+//       {
+// 	if( (i+1)<s.length())
+// 	{
+// 	  if( s[i+1] == ' ')
+// 	  {
+// 	    sEsc += "\\ ";
+// 	    ++i;
+// 	  }
+// 	}	  
+//       }    
+//     else
+// 	sEsc += s[i];
+//   }
 //cout << "WordExp esc: " << sEsc << endl;
  wordexp_t p;
- int ok0 = wordexp( sEsc.c_str(), &p, 0);
+ int ok0 = wordexp( s.c_str(), &p, 0);
+//  int ok0 = wordexp( sEsc.c_str(), &p, 0);
  if( ok0 == 0)
    {
      if( p.we_wordc > 0)
diff -ruN --exclude CVS gdl-0.9.2/src/str.hpp gdl/src/str.hpp
--- gdl-0.9.2/src/str.hpp	2008-12-09 12:05:36.000000000 -0700
+++ gdl/src/str.hpp	2011-11-29 22:43:03.000000000 -0700
@@ -75,7 +75,9 @@
 	     bool reverseOffset, bool reverseSearch);
 std::string StrMid(const std::string& s, long first, long len, bool reverse);
 std::string StrUpCase(const std::string&);
+void StrUpCaseInplace(std::string&);
 std::string StrLowCase(const std::string&);
+void StrLowCaseInplace(std::string&);
 std::string StrCompress(const std::string&,bool removeAll);
 void StrPut(std::string& s1, const std::string& s2, DLong pos);
 
diff -ruN --exclude CVS gdl-0.9.2/src/typedefs.hpp gdl/src/typedefs.hpp
--- gdl-0.9.2/src/typedefs.hpp	2011-11-08 16:44:26.000000000 -0700
+++ gdl/src/typedefs.hpp	2012-01-02 14:20:38.000000000 -0700
@@ -406,7 +406,7 @@
 
   T& operator[]( SizeT ix) throw()
   {
-   if( ix >= sz)
+   //if( ix >= sz)
     assert( ix < sz);
     return buf[ ix];
   }
@@ -422,7 +422,7 @@
 {
 // 	// assert( sz == right.size());
 // 	if ( sz != right.size() )
-// 		ThrowGDLException ( "GDLArray::operator= operands have not same size (this: " + i2s ( sz ) +", right: " + i2s ( right.size() ) + ")");;
+// 		ThrowGDLException ( "GDLArray::operator= operands have not same size (this: " + i2s ( sz ) +", right: " + i2s ( right.size() ) + ")");
 	assert( &right != this);
  	assert ( sz == right.size() );
     std::memcpy(buf,right.buf,sz*sizeof(T));
@@ -431,7 +431,7 @@
 GDLArray& operator= ( const GDLArray& right )
 {
 // 	if ( sz != right.size() )
-// 		ThrowGDLException ( "GDLArray::operator= operands have not same size (this: " + i2s ( sz ) +", right: " + i2s ( right.size() ) + ")");;
+// 		ThrowGDLException ( "GDLArray::operator= operands have not same size (this: " + i2s ( sz ) +", right: " + i2s ( right.size() ) + ")");
 
     assert( this != &right);
 	assert( sz == right.size());
diff -ruN --exclude CVS gdl-0.9.2/src/widget.cpp gdl/src/widget.cpp
--- gdl-0.9.2/src/widget.cpp	2011-04-04 20:09:26.000000000 -0600
+++ gdl/src/widget.cpp	2012-02-19 21:10:38.000000000 -0700
@@ -675,9 +675,10 @@
       // Call widget event handler routine
       if ( lasttop != top) {
 	caller = e->Caller();
-	e->Interpreter()->CallStack().pop_back();
+// ms: commented out to comply with new stack handling
+	// 	e->Interpreter()->CallStack().pop_back();
 	//	std::cout << "before delete e" << std::endl;
-	delete e;
+// 	delete e;
       }
 
       executeString2( caller, &istr);
@@ -902,8 +903,9 @@
 	  istringstream istr(line+"\n");
 
 	  // Call SETV procedure
+// ms: commented out to comply with new stack handling
 	  EnvBaseT* caller = e->Caller();
-	  e->Interpreter()->CallStack().pop_back();
+// 	  e->Interpreter()->CallStack().pop_back();
 	  executeString2( caller, &istr);
 	}
 
diff -ruN --exclude CVS gdl-0.9.2/templates/cpp gdl/templates/cpp
--- gdl-0.9.2/templates/cpp	1969-12-31 17:00:00.000000000 -0700
+++ gdl/templates/cpp	2004-12-09 08:10:21.000000000 -0700
@@ -0,0 +1,16 @@
+/***************************************************************************
+                          $FILENAME$  -  description
+                             -------------------
+    begin                : $DATE$
+    copyright            : (C) $YEAR$ by $AUTHOR$
+    email                : $EMAIL$
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
diff -ruN --exclude CVS gdl-0.9.2/templates/h gdl/templates/h
--- gdl-0.9.2/templates/h	1969-12-31 17:00:00.000000000 -0700
+++ gdl/templates/h	2004-12-09 08:10:21.000000000 -0700
@@ -0,0 +1,16 @@
+/***************************************************************************
+                          $FILENAME$  -  description
+                             -------------------
+    begin                : $DATE$
+    copyright            : (C) $YEAR$ by $AUTHOR$
+    email                : $EMAIL$
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
diff -ruN --exclude CVS gdl-0.9.2/testsuite/Makefile.am gdl/testsuite/Makefile.am
--- gdl-0.9.2/testsuite/Makefile.am	2011-11-02 17:17:58.000000000 -0600
+++ gdl/testsuite/Makefile.am	2012-06-27 17:07:02.000000000 -0600
@@ -33,6 +33,7 @@
   test_bug_3147181.pro \
   test_bug_3147733.pro \
   test_bug_3151760.pro \
+  test_bug_3152892.pro \
   test_bug_3152899.pro \
   test_bug_3189072.pro \
   test_bug_3199465.pro \
@@ -46,9 +47,14 @@
   test_bug_3300626.pro \
   test_bug_3313522.pro \
   test_bug_3376577.pro \
+  test_bug_3453775.pro \
+  test_bug_3488003.pro \
+  test_call_function.pro \
+  test_call_procedure.pro \
   test_ce.pro \
   test_clip.pro \
   test_common.pro \
+  test_congrid.pro \
   test_constants.pro \
   test_correlate.pro \
   test_deriv.pro \
@@ -64,16 +70,21 @@
   test_file_dirname.pro \
   test_file_search.pro \
   test_file_which.pro \
+  test_finite.pro \
   test_fix.pro \
   test_fixprint.pro \
+  test_fx_root.pro \
+  test_fz_roots.pro \
   test_gc.pro \
   test_get_screen_size.pro \
   test_grib.pro \
   test_hist_2d.pro \
   test_idl8.pro \
   test_idl_validname.pro \
+  test_image_statistics.pro \
   test_interpol.pro \
   test_interpolate_missing.pro \
+  test_ludc_lusol.pro \
   test_memory.pro \
   test_moment.pro \
   test_mpfit.pro \
@@ -87,6 +98,9 @@
   test_python_module_0.pro \
   test_python_module_1.pro \
   test_python_module_2.pro \
+  test_qromb.pro \
+  test_qromo.pro \
+  test_random.pro \
   test_readf.pro \
   test_rebin.pro \
   test_rk4.pro \
@@ -95,13 +109,16 @@
   test_spawn_unit.pro \
   test_spher_harm.pro \
   test_spl_init.pro \
+  test_standardize.pro \
   test_step.pro \
   test_str_functions.pro \
   test_str_sep.pro \
   test_stregex.pro \
+  test_strmatch.pro \
   test_strsplit.pro \
   test_suite.pro \
   test_systime.pro \
+  test_trisol.pro \
   test_url.pro \
   test_wavelet.pro \
   test_zeropoly.pro \
diff -ruN --exclude CVS gdl-0.9.2/testsuite/Makefile.in gdl/testsuite/Makefile.in
--- gdl-0.9.2/testsuite/Makefile.in	2011-11-02 17:17:58.000000000 -0600
+++ gdl/testsuite/Makefile.in	2012-06-28 03:54:55.000000000 -0600
@@ -115,6 +115,7 @@
 FGREP = @FGREP@
 GDLDATADIR = @GDLDATADIR@
 GREP = @GREP@
+GraphicsMagickConfig = @GraphicsMagickConfig@
 HAVE_64BIT_OS = @HAVE_64BIT_OS@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
@@ -252,6 +253,7 @@
   test_bug_3147181.pro \
   test_bug_3147733.pro \
   test_bug_3151760.pro \
+  test_bug_3152892.pro \
   test_bug_3152899.pro \
   test_bug_3189072.pro \
   test_bug_3199465.pro \
@@ -265,9 +267,14 @@
   test_bug_3300626.pro \
   test_bug_3313522.pro \
   test_bug_3376577.pro \
+  test_bug_3453775.pro \
+  test_bug_3488003.pro \
+  test_call_function.pro \
+  test_call_procedure.pro \
   test_ce.pro \
   test_clip.pro \
   test_common.pro \
+  test_congrid.pro \
   test_constants.pro \
   test_correlate.pro \
   test_deriv.pro \
@@ -283,16 +290,21 @@
   test_file_dirname.pro \
   test_file_search.pro \
   test_file_which.pro \
+  test_finite.pro \
   test_fix.pro \
   test_fixprint.pro \
+  test_fx_root.pro \
+  test_fz_roots.pro \
   test_gc.pro \
   test_get_screen_size.pro \
   test_grib.pro \
   test_hist_2d.pro \
   test_idl8.pro \
   test_idl_validname.pro \
+  test_image_statistics.pro \
   test_interpol.pro \
   test_interpolate_missing.pro \
+  test_ludc_lusol.pro \
   test_memory.pro \
   test_moment.pro \
   test_mpfit.pro \
@@ -306,6 +318,9 @@
   test_python_module_0.pro \
   test_python_module_1.pro \
   test_python_module_2.pro \
+  test_qromb.pro \
+  test_qromo.pro \
+  test_random.pro \
   test_readf.pro \
   test_rebin.pro \
   test_rk4.pro \
@@ -314,13 +329,16 @@
   test_spawn_unit.pro \
   test_spher_harm.pro \
   test_spl_init.pro \
+  test_standardize.pro \
   test_step.pro \
   test_str_functions.pro \
   test_str_sep.pro \
   test_stregex.pro \
+  test_strmatch.pro \
   test_strsplit.pro \
   test_suite.pro \
   test_systime.pro \
+  test_trisol.pro \
   test_url.pro \
   test_wavelet.pro \
   test_zeropoly.pro \
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_bug_3152892.pro gdl/testsuite/test_bug_3152892.pro
--- gdl-0.9.2/testsuite/test_bug_3152892.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_bug_3152892.pro	2012-02-21 06:49:31.000000000 -0700
@@ -0,0 +1,3 @@
+pro test_bug_3152892
+  help, *(ptr_new([1,2,3.]))
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_bug_3453775.pro gdl/testsuite/test_bug_3453775.pro
--- gdl-0.9.2/testsuite/test_bug_3453775.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_bug_3453775.pro	2011-12-28 04:51:37.000000000 -0700
@@ -0,0 +1,4 @@
+pro test_bug_3453775
+  a=[1,2,3]
+  aa=shift(a,0) ; this caused a segfault
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_bug_3488003.pro gdl/testsuite/test_bug_3488003.pro
--- gdl-0.9.2/testsuite/test_bug_3488003.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_bug_3488003.pro	2012-02-20 12:23:58.000000000 -0700
@@ -0,0 +1,9 @@
+; test code by Gilles Duvert
+pro test_bug_3488003
+  A = REPLICATE({VALUE1:DINDGEN(15)},20)
+  help,a
+  help,a,/Struct
+  help,a.VALUE1
+  mask=[59,70,89,103,115,119,130,145,179,193]
+  a.value1[mask]=1
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_call_function.pro gdl/testsuite/test_call_function.pro
--- gdl-0.9.2/testsuite/test_call_function.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_call_function.pro	2012-06-29 15:39:57.000000000 -0600
@@ -0,0 +1,91 @@
+;
+; Alain C., 22 June 2012
+;
+; More systematic tests on EXECUTE, CALL_FUNCTION and CALL_PROCEDURE
+;
+; ----------------------------------------------
+; we add a keyword to test also keyword, because of bug report 3490415 
+;
+function FUNC_MY_FUNC, x, add_one=add_one
+;
+resultat=x+5
+if KEYWORD_SET(add_one) then resultat=resultat+1
+return, resultat
+;
+end
+;
+; --------------------
+;
+pro BASIC_CALL_FUNCTION, help=help, test=test, no_exit=no_exit, verbose=verbose
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro BASIC_CALL_FUNCTION, help=help, test=test, no_exit=no_exit, verbose=verbose'
+    return
+endif
+;
+nb_errors = 0
+tolerance=1e-5
+;
+; internal intrinsic function, single value
+expected=-1.
+result=CALL_FUNCTION('COS', !pi)
+;
+if (ABS(result-expected) GT tolerance)  then nb_errors=nb_errors+1
+if KEYWORD_SET(verbose) then print, result, expected
+;
+; internal intrinsic function, array
+;
+expected=REPLICATE(-1.,10)
+result=CALL_FUNCTION('COS', REPLICATE(!pi,10))
+;
+if (TOTAL(ABS(result-expected)) GT tolerance)  then nb_errors=nb_errors+1
+if KEYWORD_SET(verbose) then print, result, expected
+;
+; external function, single element
+;
+expected=0.
+result=CALL_FUNCTION('FUNC_MY_FUNC', -5.)
+;
+if (ABS(result-expected) GT tolerance)  then nb_errors=nb_errors+1
+if KEYWORD_SET(verbose) then print, result, expected
+;
+; external function, single element, one keyword
+;
+expected=1.
+result=CALL_FUNCTION('FUNC_MY_FUNC', -5., /add_one)
+;
+if (ABS(result-expected) GT tolerance)  then nb_errors=nb_errors+1
+if KEYWORD_SET(verbose) then print, result, expected
+;
+; external function, value 2D array
+;
+expected=0.
+result=CALL_FUNCTION('FUNC_MY_FUNC', REPLICATE(-5,12,3))
+;
+if (TOTAL(ABS(result-expected)) GT tolerance)  then nb_errors=nb_errors+1
+if KEYWORD_SET(verbose) then print, result, expected
+;
+;
+;
+if (nb_errors GT 0) then begin
+    MESSAGE, STRING(nb_errors)+' Errors founded when testing CALL_FUNCTION', /continue
+endif else begin
+    MESSAGE, 'testing CALL_FUNCTION: No Errors founded', /continue
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+if (nb_errors GT 0) AND ~KEYWORD_SET(no_exit) then EXIT, status=1
+;
+end
+;
+pro TEST_CALL_FUNCTION, help=help, test=test, no_exit=no_exit, verbose=verbose
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro TEST_CALL_FUNCTION, help=help, test=test, no_exit=no_exit, verbose=verbose'
+    return
+endif
+;
+BASIC_CALL_FUNCTION, help=help, test=test, no_exit=no_exit, verbose=verbose
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_call_procedure.pro gdl/testsuite/test_call_procedure.pro
--- gdl-0.9.2/testsuite/test_call_procedure.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_call_procedure.pro	2012-06-29 15:39:57.000000000 -0600
@@ -0,0 +1,92 @@
+;
+; Alain C., 22 June 2012
+;
+; More systematic tests on EXECUTE, CALL_FUNCTION and CALL_PROCEDURE
+;
+; ----------------------------------------------
+; we add a keyword to test also keyword, because of bug report 3490415 
+;
+pro PRO_MY_PRO, x, y, add_one=add_one
+;
+y=x+5
+;
+if KEYWORD_SET(add_one) then y=y+1.
+;
+end
+;
+; --------------------
+;
+pro BASIC_CALL_PROCEDURE, help=help, test=test, no_exit=no_exit, verbose=verbose
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro BASIC_CALL_PROCEDURE, help=help, test=test, no_exit=no_exit, verbose=verbose'
+    return
+endif
+;
+nb_errors = 0
+tolerance=1e-5
+;
+; internal intrinsic function, single value
+;
+txt1='XYZ is cool'
+txt2='GDL is cool'
+CALL_PROCEDURE, 'STRPUT', txt1, 'GDL', 0
+;
+if (STRCMP(txt1, txt2) NE 1)  then nb_errors=nb_errors+1
+if KEYWORD_SET(verbose) then print, txt1, txt2
+;
+; internal intrinsic function, array
+;
+; no idea now, help welcome
+;
+; external function, single element
+;
+expected=17.
+CALL_PROCEDURE, 'PRO_MY_PRO', 12, result
+;
+if (ABS(result-expected) GT tolerance)  then nb_errors=nb_errors+1
+if KEYWORD_SET(verbose) then print, result, expected
+;
+; external function, single element, keyword
+;
+expected=17.+1.
+CALL_PROCEDURE, 'PRO_MY_PRO', 12, result, /add_one
+;
+if (ABS(result-expected) GT tolerance)  then nb_errors=nb_errors+1
+if KEYWORD_SET(verbose) then print, result, expected
+;
+; external function, value 2D array
+;
+data_in=REPLICATE(-5,12,3)
+PRO_MY_PRO, data_in, data_out1
+CALL_PROCEDURE, 'PRO_MY_PRO', data_in, data_out2
+;
+if (TOTAL(ABS(data_out1-data_out2)) GT tolerance)  then nb_errors=nb_errors+1
+if KEYWORD_SET(verbose) then print, data_out1-data_out2
+;
+;
+;
+if (nb_errors GT 0) then begin
+    MESSAGE, STRING(nb_errors)+' Errors founded when testing CALL_PROCEDURE', /continue
+endif else begin
+    MESSAGE, 'testing CALL_PROCEDURE: No Errors founded', /continue
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+if (nb_errors GT 0) AND ~KEYWORD_SET(no_exit) then EXIT, status=1
+;
+end
+;
+; ----------------------------------------------------
+;
+pro TEST_CALL_PROCEDURE, help=help, test=test, no_exit=no_exit, verbose=verbose
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro TEST_CALL_PROCEDURE, help=help, test=test, no_exit=no_exit, verbose=verbose'
+    return
+endif
+;
+BASIC_CALL_PROCEDURE, help=help, test=test, no_exit=no_exit, verbose=verbose
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_congrid.pro gdl/testsuite/test_congrid.pro
--- gdl-0.9.2/testsuite/test_congrid.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_congrid.pro	2012-04-13 15:08:47.000000000 -0600
@@ -0,0 +1,146 @@
+;
+; This basic test for CONGRID, using the Saturn.jpg image in the
+; testsuite is under GNU GPL V2 or later
+;
+; G. Duvert, 17-Dec-2011
+;
+; Note by Alain: it would also be great to have some "numerical null
+; tests"
+;
+; AC 10-Feb-2012: adding a true self-consistant test (TEST_CONGRID_BASIC)
+;
+; ---------------------------------
+;
+pro TEST_CONGRID_BASIC, nbp=nbp, test=test, byte=byte, noexit=noexit
+;default is double, byte errors come from gdl rounding, not congrid.
+if N_ELEMENTS(nbp) EQ 0 then nbp=9
+;
+isbyte=KEYWORD_SET(byte)
+nb_errors=0
+error=1e-9
+;
+if (isbyte) then in=BINDGEN(3,3) else in=DINDGEN(3,3)
+;
+; test /Sample
+;
+out_rs=REBIN(in,9,9, /sample)
+out_c=CONGRID(in,9,9)
+resu=SQRT(TOTAL((out_rs-out_c)^2))
+if (resu GT error) then nb_errors=nb_errors+1
+;
+; test /interpol
+;
+out_r=REBIN(in,9,9)
+out_ci=CONGRID(in,9,9,/interp)
+resu=SQRT(TOTAL((out_r-out_ci)^2))
+if (resu GT error) then nb_errors=nb_errors+1
+;
+if (nb_errors GT 0) then begin
+   MESSAGE, /continue, "Problems !! on nbp="+STRING(nbp)
+   if ~KEYWORD_SET(noexit) then EXIT, status=1
+endif else begin
+   MESSAGE, /continue, "Basic tests OK on nbp="+STRING(nbp)
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; -----------------------------
+;
+pro TEST_CONGRID_ON_IMAGES, image=image, filename=filename, test=test
+;
+; Do we have access to ImageMagick functionnalities ??
+;
+DEFSYSV, '!gdl', exists=is_it_gdl
+;
+if (is_it_gdl EQ 1) then begin
+   ok=EXECUTE('resu=MAGICK_EXISTS()')
+   if (resu EQ 0) then begin
+      MESSAGE, /continue, "GDL was compiled without ImageMagick support."
+      MESSAGE, /con, "You must have ImageMagick support to use this functionaly."
+      EXIT, status=77
+   endif
+endif
+;
+if (N_ELEMENTS(image) EQ 0) then begin
+    if (N_ELEMENTS(filename) EQ 0) then begin
+        ;; we know we have "Saturn" in testsuite/, which should be in !PATH
+        filename='Saturn.jpg'
+        list_of_dirs=STRSPLIT(!PATH, PATH_SEP(/SEARCH_PATH), /EXTRACT)
+        file=FILE_SEARCH(list_of_dirs+PATH_SEP()+filename)
+    endif else begin
+        file=FILE_SEARCH(filename)
+        if STRLEN(file) EQ 0 then begin
+            list_of_dirs=STRSPLIT(!PATH, PATH_SEP(/SEARCH_PATH), /EXTRACT)
+            file=FILE_SEARCH(list_of_dirs+PATH_SEP()+filename)
+        endif
+    endelse
+    ;;
+    if STRLEN(file) EQ 0 then MESSAGE, 'File not found :'+filename
+    file=file[0]
+    ;;   
+    status=QUERY_IMAGE(file, info)
+    CASE info.type OF
+        'JPEG' : READ_JPEG, file, image, /gray
+        'GIF'  : READ_GIF, file, image, /gray
+        'BMP'  : image=READ_BMP(file)
+    endcase
+endif
+;
+if (SIZE(image, /n_dim) LT 2) OR (SIZE(image, /n_dim) GT 3)  then begin
+    MESSAGE, 'Image must be 2D or 3D'
+endif
+if (SIZE(image, /n_dim) EQ 3) then begin
+    ;; conversion into GRAY using Coyote formula
+    ;; http://www.idlcoyote.com/ip_tips/color2gray.html
+    gray_image=0.3*REFORM(image[0,*,*]) + 0.59*REFORM(image[1,*,*]) + 0.11*REFORM(image[2,*,*])
+endif
+if (SIZE(image, /n_dim) EQ 2) then gray_image=image
+;
+;screensize=GET_SCREEN_SIZE()
+ndims=SIZE(gray_image,/dim)
+;
+;stop
+
+LOADCT, 28  
+DEVICE, DECOMPOSED = 0
+WINDOW, 0, XSIZE = 600, YSIZE = 260
+TV, gray_image
+;
+nbpX=ndims[0]*2
+nbpY=ROUND(ndims[1]*1.5)
+big_image=CONGRID(gray_image, nbpX, nbpY, /INTERP, /CENTER, /CUB)
+;
+WINDOW, 1, XSIZE=nbpX, YSIZE=nbpY
+TV, big_image
+;
+nbpX=ndims[0]/2
+nbpY=ndims[1]/2
+small_image=CONGRID(gray_image, nbpX, nbpY, /INTERP, /CENTER, /CUB)
+;
+WINDOW, 2, XSIZE=nbpX, YSIZE=nbpY
+TV, small_image
+;
+nbpX=ndims[0]/4
+nbpY=ndims[1]/2
+small_image=CONGRID(gray_image, nbpX, nbpY, /INTERP, /CENTER, /CUB)
+;
+WINDOW, 3, XSIZE=nbpX, YSIZE=nbpY
+TV, small_image
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; ---------------------------------
+;
+pro TEST_CONGRID, noexit=noexit
+;
+TEST_CONGRID_BASIC, noexit=noexit, nbp=9
+TEST_CONGRID_BASIC, noexit=noexit, nbp=21
+TEST_CONGRID_BASIC, noexit=noexit, nbp=121
+;
+TEST_CONGRID_ON_IMAGES
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_diag_matrix.pro gdl/testsuite/test_diag_matrix.pro
--- gdl-0.9.2/testsuite/test_diag_matrix.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_diag_matrix.pro	2012-01-23 17:20:17.000000000 -0700
@@ -0,0 +1,40 @@
+;
+; Alain C.
+; very preliminary tests (not really tested ...)
+;
+pro TEST_DIAG_MATRIX_EXTRACT
+;
+debug=1
+;
+m3x4=REFORM(INDGEN(12),3,4)
+;
+a=DIAG_MATRIX(m3x4, debug=debug)
+a=DIAG_MATRIX(m3x4, 1, debug=debug)
+a=DIAG_MATRIX(m3x4, -1, debug=debug)
+;
+m4x3=REFORM(INDGEN(12),4,3)
+;
+a=DIAG_MATRIX(m4x3, debug=debug)
+a=DIAG_MATRIX(m4x3, 1, debug=debug)
+a=DIAG_MATRIX(m4x3, -1, debug=debug)
+;
+end
+
+pro TEST_DIAG_MATRIX_INSERT
+;
+debug=1
+;
+diag=10+FINDGEN(5)
+;
+a=DIAG_MATRIX(diag, debug=debug)
+a=DIAG_MATRIX(REVERSE(10+findgen(4)), 1, debug=debug)
+a=DIAG_MATRIX(-REVERSE(10+findgen(4)), -1, debug=debug)
+;
+end
+;
+pro TEST_DIAG_MATRIX
+;
+TEST_DIAG_MATRIX_EXTRACT
+TEST_DIAG_MATRIX_INSERT
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_dicom.pro gdl/testsuite/test_dicom.pro
--- gdl-0.9.2/testsuite/test_dicom.pro	2010-12-28 11:19:26.000000000 -0700
+++ gdl/testsuite/test_dicom.pro	2012-07-05 13:22:22.000000000 -0600
@@ -1,4 +1,26 @@
+;
 ; just tests if gdlffdicom is in path
-pro test_dicom
-  a = gdlffdicom_date()
+;
+pro TEST_DICOM, version=version
+;
+; bug 3150207 (I was not able to reproduce it on July 2012)
+;
+if ~KEYWORD_SET(version) then begin
+    w=OBJ_NEW('gdlffdicom')
+    print, 'hello post OBJ_NEW'
+    help, w
+endif else begin
+    HELP, OBJ_NEW('gdlffdicom')
+endelse
+;
+; dates ...
+;
+dicom_dat = GDLFFDICOM_DATE()
+SPAWN, 'date +%Y%m%d', unix_date
+;
+if (unix_date[0] NE dicom_dat) then EXIT, status=1
+;
+MESSAGE, /continue, 'very basic tests OK on DICOM'
+MESSAGE, /continue, 'please contribute extending the test cases'
+;
 end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_execute.pro gdl/testsuite/test_execute.pro
--- gdl-0.9.2/testsuite/test_execute.pro	2010-08-27 08:25:17.000000000 -0600
+++ gdl/testsuite/test_execute.pro	2012-06-27 17:07:02.000000000 -0600
@@ -1,9 +1,138 @@
+;
+; Alain C., 22 June 2012
+;
+; More systematic tests on EXECUTE, CALL_FUNCTION and CALL_PROCEDURE
+;
+pro PRO_MY_PRO, x, y
+;
+y=x+5
+;
+end
+;
+function FUNC_MY_FUNC, x
+;
+return, x+5
+;
+end
+;
+; ---------------------
+; old temporay bug
+;
+pro TEST_BUG_3441031
+;; this caused a segfault
+res=EXECUTE("a = STRJOIN(STRSPLIT((['a'])[1],'a'),'a')")
+;
+end
+;
+; another old temporay bug
+;
 ; by Sylwester Arabas <slayoo@igf.fuw.edu.pl>
-pro test_execute
-
-  if execute('print,execute([''''])') then begin
-    message, 'EXECUTE should not accept array arguments', /conti
-    exit, status=1
-  endif
+pro OLD_TEST_EXECUTE
 
+if EXECUTE('print, EXECUTE([''''])') then begin
+   MESSAGE, 'EXECUTE should not accept array arguments', /conti
+   EXIT, status=1
+endif
+;
+end
+;
+; --------------------
+;
+pro BASIC_EXECUTE, help=help, test=test, no_exit=no_exit, verbose=verbose
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro BASIC_EXECUTE, help=help, test=test, no_exit=no_exit, verbose=verbose'
+    return
+endif
+;
+nb_errors = 0
+tolerance=1e-5
+;
+; internal intrinsic function, single value
+com='a=COS(!pi)'
+expected=-1.
+status=EXECUTE(com)
+;
+if (status NE 1) then nb_errors=nb_errors+1
+if (ABS(a-expected) GT tolerance)  then nb_errors=nb_errors+1
+if KEYWORD_SET(verbose) then print, com, status, a, expected
+;
+; internal intrinsic function, array
+;
+com='a=COS(REPLICATE(!pi,10))'
+expected=REPLICATE(-1.,10)
+status=EXECUTE(com)
+;
+if (status NE 1) then nb_errors=nb_errors+1
+if (TOTAL(ABS(a-expected)) GT tolerance)  then nb_errors=nb_errors+1
+if KEYWORD_SET(verbose) then print, com, status, a, expected
+;
+; internal intrinsic procedure (better idea welcome !)
+;
+com='plot, SIN(!pi*findgen(100)/10.)'
+status=EXECUTE(com)
+;
+if (status NE 1) then nb_errors=nb_errors+1
+;
+; external function, single element
+;
+com='a=FUNC_MY_FUNC(12.)'
+expected=17.
+status=EXECUTE(com)
+;
+if (status NE 1) then nb_errors=nb_errors+1
+if (ABS(a-expected) GT tolerance)  then nb_errors=nb_errors+1
+if KEYWORD_SET(verbose) then print, com, status, a, expected
+;
+; external function, value 2D array
+;
+com='a=FUNC_MY_FUNC(REPLICATE(-5,12,3))'
+expected=REPLICATE(0.,12,3)
+status=EXECUTE(com)
+;
+if (status NE 1) then nb_errors=nb_errors+1
+if (TOTAL(ABS(a-expected)) GT tolerance)  then nb_errors=nb_errors+1
+if KEYWORD_SET(verbose) then print, com, status, a, expected
+;
+; external function, named' 2D array
+;
+input=REPLICATE(-5,12,3)
+com='a=FUNC_MY_FUNC(input)'
+expected=input+5.
+status=EXECUTE(com)
+;
+if (status NE 1) then nb_errors=nb_errors+1
+if (TOTAL(ABS(a-expected)) GT tolerance)  then nb_errors=nb_errors+1
+if KEYWORD_SET(verbose) then print, com, status, a, expected
+;
+;
+;
+if (nb_errors GT 0) then begin
+    MESSAGE, STRING(nb_errors)+' Errors founded when testing EXECUTE', /continue
+endif else begin
+    MESSAGE, 'testing EXECUTE: No Errors founded', /continue
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+if (nb_errors GT 0) AND ~KEYWORD_SET(no_exit) then EXIT, status=1
+;
+WDELETE
+;
+end
+;
+; ----------------------------------------------------
+;
+pro TEST_EXECUTE, help=help, test=test, no_exit=no_exit, verbose=verbose
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro TEST_EXECUTE, help=help, test=test, no_exit=no_exit, verbose=verbose'
+    return
+endif;
+;
+TEST_BUG_3441031
+OLD_TEST_EXECUTE
+;
+BASIC_EXECUTE, help=help, test=test, no_exit=no_exit, verbose=verbose
+;
 end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_fft_dim.pro gdl/testsuite/test_fft_dim.pro
--- gdl-0.9.2/testsuite/test_fft_dim.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_fft_dim.pro	2012-07-05 17:58:57.000000000 -0600
@@ -0,0 +1,26 @@
+;
+; Alain C. and Mathieu P. under GNU GPL v2 or later
+;
+; Visual empiric preliminary test of FFT(dim=)
+; A shift line by in an array should have no consequence
+; on the FFT module ...
+;
+pro TEST_FFT_DIM
+
+; Create a cosine wave damped by an exponential.
+n = 256
+x = FINDGEN(n)
+y = COS(x*!PI/6)*EXP(-((x - n/2)/30)^2/2)
+; Construct a two-dimensional image of the wave.
+z = REBIN(y, n, n)
+z1=z
+for ii=0, n-1 do z1[*,ii]=shift(z1[*,ii],ii)
+
+window, xsi=3*n, ysize=n
+tvscl, z1,0
+tvscl, ABS(FFT(z1, dim=1)),1
+tvscl, ABS(FFT(z1, dim=2)),2
+
+; we can do the diff, no phase diff  ...
+
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_file_copy.pro gdl/testsuite/test_file_copy.pro
--- gdl-0.9.2/testsuite/test_file_copy.pro	2010-06-29 02:47:39.000000000 -0600
+++ gdl/testsuite/test_file_copy.pro	2011-11-15 17:57:05.000000000 -0700
@@ -4,18 +4,32 @@
 ; Lea Noreskal, June 2010
 ; under GNU GPL 2 or later
 ; 
-pro del_test_files , to_delete 
-
+pro DEL_TEST_FILES, to_delete, verbose=verbose
+;
 ; Delete files and directories
+;
 for ii=0, N_ELEMENTS(to_delete)-1 do begin
-   if(FILE_TEST(to_delete[ii]) eq 1) then SPAWN , 'rm -rf '+escape_special_char(to_delete[ii])
+   if KEYWORD_SET(verbose) then begin
+      print, 'File or Dir. >>'+to_delete[ii]+'<< to be deleted'
+      print, 'Interpreted as: >>'+ESCAPE_SPECIAL_CHAR(to_delete[ii])+'<<'
+   endif
+   if (FILE_TEST(to_delete[ii]) eq 1) then begin
+      SPAWN , 'rm -rf '+ESCAPE_SPECIAL_CHAR(to_delete[ii])
+      ;; we don't check whether the file is deleted or not
+   endif else begin
+      if KEYWORD_SET(verbose) then begin
+         print, 'File or Dir. >>'+to_delete[ii]+'<< not found'
+         print, 'Interpreted as: >>'+ESCAPE_SPECIAL_CHAR(to_delete[ii])+'<<'
+      endif
+   endelse
 endfor
-
+;
 end
-
-
-pro TEST_FILE_COPY , test=test
-
+;
+; --------------------------------
+;
+pro TEST_FILE_COPY, test=test
+;
 ; Create test directory
 tdir='tdir_test_f_copy_gdl'
 if FILE_TEST(tdir) EQ 0 then SPAWN, 'mkdir '+tdir
@@ -39,69 +53,66 @@
 
 if FILE_TEST(files1[0]) EQ 0 then SPAWN, 'touch '+files1[0]
 if FILE_TEST(files1[1]) EQ 0 then SPAWN, 'touch '+files1[1]
-if FILE_TEST(file2) EQ 0 then SPAWN, 'touch '+escape_special_char(file2)
-
-
+if FILE_TEST(file2) EQ 0 then SPAWN, 'touch '+ESCAPE_SPECIAL_CHAR(file2)
+;
+;
 sce=MAKE_ARRAY(N_ELEMENTS(files1))
 dest=MAKE_ARRAY(N_ELEMENTS(files1))
-
-
+;
 ; Add elements to files
 for ii=0, N_ELEMENTS(files1)-1 do begin
-	SPAWN , 'echo '+more+' >> '+files1[ii]
+   SPAWN , 'echo '+more+' >> '+files1[ii]
 endfor
-
+;
 print , 'COPY N1'
 ; Copy files1 into tdir
 FILE_COPY, files1 , tdir
-
+;
 sce=FILE_INFO(files1)
 dest=FILE_INFO(f1) 
-
+;
 ;print, 'Size sce',  sce[0].size
 ;print, 'Size dest', dest[0].size
-
+;
 ; if files1 et f1 have same size , cp ok
-
+;
 for ii=0, N_ELEMENTS(sce)-1 do begin
    if(sce[ii].size ne dest[ii].size ) then begin
       MESSAGE, 'error cp', /continue
-      del_test_files , all_files_and_directories
+      DEL_TEST_FILES, all_files_and_directories
       EXIT, status=1
    endif
 endfor
-
+;
 ; add elements to files
 for ii=0, N_ELEMENTS(files1)-1 do begin
-	SPAWN , 'echo '+more+' >> '+files1[ii]
+   SPAWN, 'echo '+more+' >> '+files1[ii]
 endfor
-
+;
 print , 'COPY N2'
 ; Copy files1 into tdir again
 FILE_COPY, files1 , tdir
-
+;
 sce=FILE_INFO(files1)
 dest=FILE_INFO(f1) 
-
+;
 ;print , 'Size sce',  sce[0].size
 ;print , 'Size dest', dest[0].size
-
+;
 ; if files1 et f1 don't have same size , because overwrite is not allowed
-
+;
 for ii=0, N_ELEMENTS(sce)-1 do begin
    if(sce[ii].size eq dest[ii].size ) then begin
       MESSAGE, 'error cp', /continue
-      del_test_files , all_files_and_directories
+      DEL_TEST_FILES, all_files_and_directories
       EXIT, status=1
    endif
 endfor
-
-
-
+;
 for ii=0, N_ELEMENTS(files1)-1 do begin
-	SPAWN , 'echo '+more+' >> '+files1[ii]
+   SPAWN, 'echo '+more+' >> '+files1[ii]
 endfor
-
+;
 ; Overwrite -  maj :::: t0 < t1
 print , 'OVERWRITE' 
 FILE_COPY, files1 , tdir , /overwrite 
@@ -109,125 +120,115 @@
 sce=FILE_INFO(files1)
 ;print, 'Size sce',  sce[0].size
 ;print, 'Size dest', dest[0].size
-
+;
 ; if files1 et f1 have same size , cp ok
 for ii=0, N_ELEMENTS(sce)-1 do begin
    if(sce[ii].size ne dest[ii].size ) then begin
       MESSAGE, 'error cp', /continue
-      del_test_files , all_files_and_directories
+      DEL_TEST_FILES, all_files_and_directories
       EXIT, status=1
    endif
 endfor
-
-
+;
 for ii=0, N_ELEMENTS(files1)-1 do begin
-	SPAWN , 'echo '+more+' >> '+files1[ii]
+   SPAWN, 'echo '+more+' >> '+files1[ii]
 endfor
-
+;
 ; CP files > files
-
+;
 print , 'Require_dir ' 
 FILE_COPY, files1 , files2 , /require_dir
 ; if files2 exist : error
-
+;
 for ii=0, N_ELEMENTS(files2)-1 do begin
    if(FILE_TEST(files2[ii]) eq 1 ) then begin
       MESSAGE, 'error require_dir', /continue
-      del_test_files , all_files_and_directories                
+      DEL_TEST_FILES, all_files_and_directories                
       EXIT, status=1
    endif
 endfor
-
+;
 ;print , 'Sce=tab of files Dest=file ' 
 FILE_COPY, files1 , file2 , /require_dir
-
-
+;
 print , 'files to files' 
 FILE_COPY, files1 , files2
-
+;
 sce=FILE_INFO(files2)
 dest=FILE_INFO(files1) 
-
+;
 ;print, 'Size sce', sce[0].size
 ;print, 'Size dest',  dest[0].size
 ; if files1 et files2 have same size , cp ok
-
+;
 for ii=0, N_ELEMENTS(sce)-1 do begin
    if(sce[ii].size ne dest[ii].size ) then begin
       MESSAGE, 'error cp', /continue
-      del_test_files , all_files_and_directories
+      DEL_TEST_FILES, all_files_and_directories
       EXIT, status=1
    endif
 endfor
-
+;
 ;;;;;;;;;;;;;;;;;;;;;
 ; How to verify with allow_same?
-
+;
 ; Without allow_same
 print , 'WITHOUT ALLOW_SAME' 
 FILE_COPY, files1 , files1
-
-
+;
 ; With Allow_same
 print , 'WITH ALLOW_SAME' 
 FILE_COPY, files1 , files1 , /allow_same
-
+;
 ;;;;;;;;;;;;;;;;;;;;;
-
 ;recursive
-
+;
 ; Test with directories
 tdir3=['test_dir1' , '$&dir2_&-spec$'] ; 
 tdir2=['td2_1' , 'td2_2'] ; 
 td2cp=[tdir+'/td2_1' , tdir+'/td2_2'] ; 
-
+;
 all_files_and_directories=[all_files_and_directories,tdir2]
-
-
+;
 if FILE_TEST(tdir2[0], /directory) EQ 0 then SPAWN, 'mkdir '+tdir2[0]
 if FILE_TEST(tdir2[1], /directory) EQ 0 then SPAWN, 'mkdir '+tdir2[1]
-
+;
 for ii=0,N_ELEMENTS(tdir2)-1 do begin
    for jj=0, 5 do begin
       fname = tdir2[ii]+'/'+STRCOMPRESS('fi' + string(jj), /remove_all)
       SPAWN , 'touch '+fname
    endfor
 endfor
-
-
+;
 print , 'WITHOUT RECURSIVE'
 FILE_COPY, tdir2 , tdir
 ;tdir/tdir2 : copy not allowed
-
+;
 for ii=0, N_ELEMENTS(td2cp)-1 do begin
    if(FILE_TEST(td2cp[ii]) eq 1 ) then begin
       MESSAGE, 'error whtout rec', /continue
-      del_test_files , all_files_and_directories
+      DEL_TEST_FILES, all_files_and_directories
       EXIT, status=1
    endif
 endfor
-
-
+;
 print , 'WITH RECURSIVE'
 FILE_COPY, tdir2 , tdir , /recursive
 ;copy ok
 sce=FILE_INFO(tdir2)
 dest=FILE_INFO(td2cp) 
-
+;
 for ii=0, N_ELEMENTS(td2cp)-1 do begin
    if(FILE_TEST(td2cp[ii]) eq 0 ) then begin
       MESSAGE, 'error recursive', /continue
-      del_test_files , all_files_and_directories
+      DEL_TEST_FILES, all_files_and_directories
       EXIT, status=1
    endif
 endfor
-
-
+;
 ;delete all
-del_test_files , all_files_and_directories
-
-
-
+DEL_TEST_FILES, all_files_and_directories
+;
 print, 'All tests done'
 ;
 if KEYWORD_SET(test) then STOP
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_file_delete.pro gdl/testsuite/test_file_delete.pro
--- gdl-0.9.2/testsuite/test_file_delete.pro	2010-06-29 02:47:39.000000000 -0600
+++ gdl/testsuite/test_file_delete.pro	2011-11-15 17:57:05.000000000 -0700
@@ -5,56 +5,61 @@
 ; initial version by AC, 28 Avril 2009
 ; very basic tests for FILE_DELETE
 ;
-pro TEST_FILE_DELETE, full_test=full_test, test=test
-
-; Files
+pro TEST_FILE_DELETE, full_test=full_test, test=test, help=help
+;
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro TEST_FILE_DELETE, full_test=full_test, test=test, help=help'
+   return
+endif
+;
+; Files Names
 files1=['fd_test1a','fd_test1b', '$chops &up str*ings.' ]
 file2='fd_test2'
 files3=['/etc/passwd', '/etc/passwd1']
 specfile='$f_tst*.mq' ; filename with special characters
-
 ;
 ; creation des fichiers temporaires de test
 ;
 if FILE_TEST(files1[0]) EQ 0 then SPAWN, 'touch '+files1[0]
 if FILE_TEST(files1[1]) EQ 0 then SPAWN, 'touch '+files1[1]
-if FILE_TEST(files1[2]) EQ 0 then SPAWN, 'touch '+escape_special_char(files1[2])
+if FILE_TEST(files1[2]) EQ 0 then SPAWN, 'touch '+ESCAPE_SPECIAL_CHAR(files1[2])
 if FILE_TEST(file2) EQ 0 then SPAWN, 'touch '+file2
 ;
-
 all_files_and_directories=files1 
 all_files_and_directories=[all_files_and_directories,file2]
-
+;
 FILE_DELETE, files1, file2, /quiet
-
+;
 for ii=0,N_ELEMENTS(files1)-1 do begin
    if (FILE_TEST(files1[ii]) EQ 1 ) then begin
-      MESSAGE, 'files1 has not been deleted', /continue
-      del_test_files , all_files_and_directories
+      MESSAGE, 'files1 >>'+files1[ii]+'<<has not been deleted', /continue
+      DEL_TEST_FILES, all_files_and_directories
       EXIT, status=1
    endif
 endfor
-
+;
 if (FILE_TEST(file2) EQ 1) then begin
    MESSAGE, 'file2 has not been deleted', /continue
-   del_test_files , all_files_and_directories
+   DEL_TEST_FILES, all_files_and_directories
    EXIT, status=1
 endif
-
-; test with no existing file
+;
+; Test with no existing file
+;
 FILE_DELETE, specfile
 FILE_DELETE, specfile , /quiet
 FILE_DELETE, specfile , /allow_nonexistent
 FILE_DELETE, specfile , /quiet , /verbose
-
+;
 ; Test with directories 
+;
 tdir=['test_dir1' , '$&dir2_&-spec$'] ; empty directories 
 tdir2=['td2_1' , 'td2_2'] ; Not empty directories
-
-
+;
 print , 'Empty directories'
 if FILE_TEST(tdir[0], /directory) EQ 0 then SPAWN, 'mkdir '+tdir[0]
-if FILE_TEST(escape_special_char(tdir[1]), /directory) EQ 0 then SPAWN, 'mkdir '+escape_special_char(tdir[1])
+if FILE_TEST(ESCAPE_SPECIAL_CHAR(tdir[1]), /directory) EQ 0 then SPAWN, 'mkdir '+ESCAPE_SPECIAL_CHAR(tdir[1])
 
 all_files_and_directories=[all_files_and_directories,tdir]
 
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_finite.pro gdl/testsuite/test_finite.pro
--- gdl-0.9.2/testsuite/test_finite.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_finite.pro	2012-06-28 07:29:22.000000000 -0600
@@ -0,0 +1,135 @@
+;
+; under GNU GPL v2 or later
+; Alain Coulais, 19-June-2012
+; Mathieu Pinter, 19-June-2012
+; 
+pro BASIC_FINITE, data=data, comp=comp, double=double, test=test
+;
+if ~ARG_PRESENT(data) then begin
+   data=[0., -0.0, 10, -10., !values.f_nan, -!values.f_nan]
+   data=[data, !values.f_infinity, -!values.f_infinity]
+endif
+;
+if KEYWORD_SET(double) then data=DOUBLE(data)
+if KEYWORD_SET(comp) then data=COMPLEX(0.,0.)+data
+;
+print, data
+print, FINITE(data)
+print, FINITE(data,/nan)
+print, FINITE(data,/inf)
+;
+print, FINITE(data,/nan, sign=-1)
+print, FINITE(data,/nan, sign=0)
+print, FINITE(data,/nan, sign=1)
+;
+print, FINITE(data,/inf, sign=-1)
+print, FINITE(data,/inf, sign=0)
+print, FINITE(data,/inf, sign=1)
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+; -------------------------------------------------
+;
+pro TEST_FINITE, help=help, test=test, debug=debug, $
+                 no_exit=no_exit, verbose=verbose
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro TEST_FINITE, help=help, test=test, debug=debug, $'
+    print, '                 no_exit=no_exit, verbose=verbose'
+    return
+endif
+;
+nb_errors = 0
+tab=[[1.,!VALUES.F_INFINITY,1],$
+     [0,!VALUES.F_NAN,5],$
+     [-!VALUES.F_INFINITY,-!VALUES.F_NAN,100]]
+;
+a=FINITE(tab) 
+if a(1,0) NE 0 then nb_errors=nb_errors + 1
+;
+a=FINITE(tab, /INF) 
+if a(1,0) NE 1 then nb_errors=nb_errors + 1
+;
+a=FINITE(tab, /NAN) 
+if a(1,1) NE 1 then nb_errors=nb_errors + 1
+;
+a=FINITE(tab, /INF, SIGN=1) 
+if a(1,0) NE 1 then nb_errors=nb_errors + 1
+;
+a=FINITE(tab, /INF, SIGN=-1) 
+if a(0,2) NE 1 then nb_errors=nb_errors + 1
+;
+a=FINITE(tab, /NAN, SIGN=1) 
+if a(1,1) NE 1 then nb_errors=nb_errors + 1
+;
+a=FINITE(tab, /NAN, SIGN=-1) 
+if a(1,2) NE 1 then nb_errors=nb_errors + 1
+;
+if KEYWORD_SET(debug) then STOP
+;
+b=FLTARR(1000)
+b[10:19]=-!VALUES.F_NAN
+b[110:119]=!VALUES.F_NAN
+a=WHERE(FINITE(b, /NAN, SIGN=-1) EQ 1, count)
+if count NE 10 then nb_errors=nb_errors + 1
+;
+if count EQ 20 then begin
+    MESSAGE,/continue, "This platform does not distinguish between +Nan and -Nan"
+endif
+;
+a=WHERE(FINITE(b, /inf, SIGN=-1) EQ 1, count)
+if count NE 0 then nb_errors=nb_errors + 1
+; counting +Inf
+b[210:219]=!VALUES.F_infinity
+b[410:419]=-!VALUES.F_infinity
+a=WHERE(FINITE(b, /inf, SIGN=1) EQ 1, count)
+if count NE 10 then nb_errors=nb_errors + 1
+if count EQ 20 then begin
+    MESSAGE,/continue, "This platform does not distinguish between +Inf and -Inf"
+endif
+;
+; now we have +-Nan and +inf, do we still know how to count ?
+a=WHERE(FINITE(b, /NAN, SIGN=-1) EQ 1, count)
+if count NE 10 then nb_errors=nb_errors + 1
+;
+if (nb_errors GT 0) then begin
+    MESSAGE, STRING(nb_errors)+' Errors founded when testing FINITE', /continue
+endif else begin
+    MESSAGE, 'testing FINITE: No Errors founded', /continue
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+if (nb_errors GT 0) AND ~KEYWORD_SET(no_exit) then EXIT, status=1
+;
+end
+;
+;
+;
+pro TEST_FINITE_TIMETEST, nbp=nbp, test=test
+
+if ~ARG_PRESENT(nbp) then nbp=1e7
+
+a=randomu(seed, nbp)
+
+a(where(a GT 0.75))=!values.f_nan
+a(where(a LT 0.25))=-!values.f_nan
+
+print, 'finite only'
+t0=systime(1) & b=finite(a) & print, systime(1)-t0
+
+print, 'NaN only'
+t0=systime(1) & b=finite(a, /nan) & print, systime(1)-t0
+t0=systime(1) & b=finite(a, /nan, sign=1) & print, systime(1)-t0
+t0=systime(1) & b=finite(a, /nan, sign=-1) & print, systime(1)-t0
+
+print, 'Inf only'
+t0=systime(1) & b=finite(a, /inf) & print, systime(1)-t0
+t0=systime(1) & b=finite(a, /inf, sign=1) & print, systime(1)-t0
+t0=systime(1) & b=finite(a, /inf, sign=-1) & print, systime(1)-t0
+
+if KEYWORD_SET(test) then STOP
+
+
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_fx_root.pro gdl/testsuite/test_fx_root.pro
--- gdl-0.9.2/testsuite/test_fx_root.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_fx_root.pro	2012-07-05 16:59:54.000000000 -0600
@@ -0,0 +1,127 @@
+;
+; under GNU GPL v2 or later
+; Benjamin Laurent, 18-June-2012
+; long term contact : Alain Coulais
+;
+; 06-July-2012: we change Func1 to a better one !
+; 
+; -------------------------------------------------
+; usage: in GDL CLI:
+; GDL> test_fx_root
+;
+; -------------------------------------------------
+;
+; AC 06/07/2012 the example in IDL doc is stupid !
+function FUNC1_STUPID, X  
+  return, EXP(SIN(X)^2 + COS(X)^2 - 1) - 1.
+end
+; alternative example found in Matlab Tuto
+function FUNC1, X  
+  return, COS(x)-x
+end
+;
+; from GDL doc
+function FUNC2, X
+  return, X^2-5.
+end
+;
+; from http://objectmix.com/idl-pvwave/169016-better-root-finder.html
+; three roots, depending the range where we are computing
+function FUNC3, x
+return, x^3-8.0
+end
+;
+; -------------------------------------------------
+;
+pro TEST_FX_ROOT_ON_FUNC, init=init, function_name=function_name, $
+                          iter=iter, eps=eps, help=help, test=test
+  
+if KEYWORD_SET(help) then begin
+    print, 'pro TEST_FX_ROOT_ON_FUNC, init=init, function_name=function_name, $'
+    print, '                          iter=iter, eps=eps, help=help, test=test'
+    return
+endif
+;
+;Error tolerance
+if (N_ELEMENTS(eps) EQ 0) then eps=1e-4
+;
+if N_ELEMENTS(function_name) EQ 0 then function_name='FUNC1'
+;
+nb_errors=0
+;
+;return one root
+resuFX=FX_ROOT(init,function_name,ITMAX=iter,/DOUBLE,STOP=1,TOL=0.00001)
+resuNW=NEWTON(4.,function_name) 
+;;  
+print, 'FX_ROOT : ',  resuFX
+print, 'FX_NEWTON : ', resuNW
+;
+; comparing
+;
+if ABS(CALL_FUNCTION(function_name,resuFX)) GT eps then nb_errors=nb_errors+1
+;
+if ABS(resuFX-resuNW) GT eps then nb_errors=nb_errors+1
+;
+if (nb_errors GT 0) then begin
+    MESSAGE, /continue, STRING(nb_errors)+' Errors founded'
+    if ~KEYWORD_SET(test) then EXIT, status=1
+endif else begin
+    MESSAGE, /continue, 'Function '+function_name+' : No Errors founded'
+endelse
+  
+if KEYWORD_SET(test) then STOP
+
+end
+;
+; depending the [x0,x1,x2] values, we can converge to different roots
+;
+pro WHERE_DO_WE_CONVERGE
+;
+tol=1.e-5
+expected_module=2.
+re_r1=-1
+;
+root1=FX_ROOT([-10,0,.5], 'FUNC3')
+root2=FX_ROOT([0,.5,3], 'FUNC3')    
+;
+errors=0
+; checking module values
+if ABS(ABS(root1)-expected_module) GT tol then begin
+   errors=errors+1
+   MESSAGE,/continue, 'root1 inaccurate'
+endif
+if ABS(ABS(root2)-expected_module) GT tol then begin
+   errors=errors+1
+   MESSAGE,/continue, 'root2 inaccurate'
+endif
+;
+; checking roots values
+if ABS(real_part(root1)-re_r1) GT tol then begin
+   errors=errors+1
+   MESSAGE,/continue, 'unexpected root1'
+endif
+if ABS(real_part(root2)-expected_module) GT tol then begin
+   errors=errors+1
+   MESSAGE,/continue, 'unexpected root2'
+endif
+;
+if errors EQ 0 then MESSAGE,/continue, 'convergence on expected roots well done'
+;
+end
+;
+pro TEST_FX_ROOT
+;
+;float precision for double DCOMPLEXARR
+C = COMPLEXARR(1,3)
+C[0] = complex(1,0)
+C[1] = complex(2,0)
+C[2] = complex(3,0)
+c=reform(c)
+;
+TEST_FX_ROOT_ON_FUNC, init=C, function_name='FUNC1', iter=100
+TEST_FX_ROOT_ON_FUNC, init=C, function_name='FUNC2', iter=100
+;
+; informational test
+WHERE_DO_WE_CONVERGE
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_fz_roots.pro gdl/testsuite/test_fz_roots.pro
--- gdl-0.9.2/testsuite/test_fz_roots.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_fz_roots.pro	2012-06-16 15:35:44.000000000 -0600
@@ -0,0 +1,114 @@
+;
+; under GNU GPL v2 or later
+; Benjamin Laurent, 15-Juin-2012
+; 
+; -------------------------------------------------
+;
+; to be extended ...
+;
+; -------------------------------------------------
+;
+;usage:
+;GDL> test_fz_roots
+
+function poly, m, c , r , index, double;Return the maximum error between 'exact' roots and fz_roots 
+  resp=0
+  resn=0
+  epsref=1e-6
+  s=fz_roots(*c[m],/double)  
+  ;Sorting, index gives the relation
+  ;between 'exact' roots and fz_roots (cause to different orders...)
+  for j = 0,n_elements(*r[m])-1 do begin
+     for i = 0,n_elements(*r[m])-1 do begin
+        if ( abs(s[j]-(*r[m])[i]) lt epsref ) then begin
+           (*index[m])[j]=i
+        endif
+     endfor
+  endfor
+  
+  for j = 0,n_elements(*r[m])-1 do begin
+     resn=abs(s[j]-(*r[m])[(*index[m])[j]])
+     if (resn GT resp) then begin resp = resn
+     endif
+  endfor
+  return, resp
+end
+
+pro TEST_FZ_ROOTS_ON_POLY, numberpoly=numberpoly, eps=eps, help=help, test=test , c=c, r=r, index=index, double=double
+
+  if KEYWORD_SET(help) then begin
+     print, 'pro TEST_FZ_ROOTS_POLY, numberpoly=m, eps=eps, help=help, test=test, c=c, r=r, index=index, double=double'
+     return
+  endif
+
+;Error tolerance
+  if (N_ELEMENTS(eps) EQ 0) then begin eps=1e-6
+  endif
+  if (N_ELEMENTS(numberpoly) EQ 0) then begin m=0
+  endif
+  nb_errors=0
+
+  resuFZ=poly(numberpoly,c,r,index,double);maximum error
+
+  if resuFZ GT eps then begin nb_errors=nb_errors+1 ;comparing
+  endif
+
+  if (nb_errors GT 0) then begin
+     MESSAGE, /continue, STRING(nb_errors)+' Errors founded'
+     if ~KEYWORD_SET(test) then EXIT, status=1
+  endif else begin
+     MESSAGE, /continue, 'Polynomial '+string(format='(I1)',numberpoly)+' : No Errors founded'
+  endelse
+
+
+;
+  if KEYWORD_SET(test) then begin STOP
+  endif
+;
+end
+
+
+
+pro TEST_FZ_ROOTS
+
+n=5;number of polynomials
+c=ptrarr(n);polynomial coefficients
+r=ptrarr(n);polynomial roots
+
+c[0]=ptr_new([-1,0,0,0,0,1])
+r[0]=ptr_new(exp([0,2,4,6,8] * !PI * complex(0,1) / 5))
+
+c[1]=ptr_new([-1,0,0,0,0,1])
+r[1]=ptr_new(exp([0,2,4,6,8] * !PI * complex(0,1) / 5))
+
+; IDL-doc example (IMSL_ZEROPOLY)
+c[2] = ptr_new([-2, 4, -3, 1])
+r[2] = ptr_new([1, complex(1,-1), complex(1,1)])
+
+; IDL-doc examples (FZ_ROOTS)
+c[3] = ptr_new([-2, -9, -7, 6])
+r[3] = ptr_new([-.5, -1./3, 2.])
+
+c[4] = ptr_new([2, 0, 3, 0, 1])
+r[4] = ptr_new(complex(0,[-sqrt(2), sqrt(2), -1, 1]))
+
+;c[5]=ptr_new([1]);To check error handling of degree zero polynomial
+;c[6]=ptr_new([complex(0,1),0,0,1]);To check error handling of complex coefficients polynomial
+   
+index=ptrarr(5)
+index[0]=ptr_new([0,0,0,0,0])
+index[1]=ptr_new([0,0,0,0,0])
+index[2]=ptr_new([0,0,0])
+index[3]=ptr_new([0,0,0])
+index[4]=ptr_new([0,0,0,0])
+
+TEST_FZ_ROOTS_ON_POLY, numberpoly=0, c=c, r=r, index=index, double=double
+TEST_FZ_ROOTS_ON_POLY, numberpoly=1, c=c, r=r, index=index, double=double
+TEST_FZ_ROOTS_ON_POLY, numberpoly=2, c=c, r=r, index=index, double=double
+TEST_FZ_ROOTS_ON_POLY, numberpoly=3, c=c, r=r, index=index, double=double
+TEST_FZ_ROOTS_ON_POLY, numberpoly=4, c=c, r=r, index=index, double=double
+end
+
+
+
+
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_get_kbrd.pro gdl/testsuite/test_get_kbrd.pro
--- gdl-0.9.2/testsuite/test_get_kbrd.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_get_kbrd.pro	2011-12-29 19:11:38.000000000 -0700
@@ -0,0 +1,47 @@
+;
+; under GNU GPL or later
+;
+; Alain Coulais, 14-Dec-2011, because Gille Duvert submits
+; a patch for GET_KBRD()
+;
+; We have to take care that the behavior of GET_KBRD() and GET_KBRD(0)
+; is different
+;
+; Also take care that it was no possible to call GET_KBRD()
+; without arg until IDL 6.x (x > 0)
+;
+pro TEST_GET_KBRD
+;
+print, 'During 3 seconds delay, please type : azerty'
+WAIT, 3
+;
+print, ">>", GET_KBRD(), '<<'
+;
+for ii=0, 5 do print, GET_KBRD(0)
+;
+end
+;
+pro TEST_GET_KBRD_ZERO
+;
+print, 'During 3 seconds delay, please type : azerty'
+WAIT, 3
+;
+print, ">>", GET_KBRD(0), '<<'
+;
+for ii=0, 5 do print, GET_KBRD(0)
+;
+end
+;
+pro TEST_GET_KBRD_WAIT, wait=wait
+;
+if N_ELEMENTS(wait) EQ 0 then wait=1
+if wait LE 0 then wait=1
+;
+print, 'During 3 seconds delay, please type : azerty'
+WAIT, 3
+;
+print, ">>", GET_KBRD(wait), '<<'
+;
+for ii=0, 5 do print, GET_KBRD(wait)
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_hist_equal.pro gdl/testsuite/test_hist_equal.pro
--- gdl-0.9.2/testsuite/test_hist_equal.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_hist_equal.pro	2012-05-22 09:33:00.000000000 -0600
@@ -0,0 +1,70 @@
+;
+; Josh Sixsmith 16 May 2012, under GNU GPL v3 or later
+;
+; A simple statistical test for distribution shape
+;
+; After HIST_EQUAL we check that:
+; -- kurtosis of the image is roughly -1.2
+; -- skewness of the image is roughly 0
+; This should describe a Uniform distribution
+;
+pro TEST_HIST_EQUAL, samples=samples, test=test, verbose=verbose, help=help
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro TEST_HIST_EQUAL, samples=samples, test=test, $'
+    print, '                     verbose=verbose. help=help'
+    return
+endif
+;
+if N_ELEMENTS(samples) eq 0 then samples=100
+;
+; We will calculate an image from a random normal distribution.
+; This should (roughly) have a skewness of 0 and a kurtosis of 0.
+img = RANDOMN(sd, samples,samples)
+;
+; compute the histogram equalisation on the image
+scl = HIST_EQUAL(img)
+;
+; compute the moment of the raw image and the scaled image
+m_raw    = MOMENT(img)
+m_scl = MOMENT(scl)
+;
+; The more samples used in the image creation, the closer the
+; image is to being a normal distribution.
+; As such, some variation will be expected, so an error of 0.1
+; should suffice.
+err = 0.1
+total_pb = 0
+;
+if (ABS(m_scl[3] + 1.2) ge err) then begin
+    if KEYWORD_SET(verbose) then MESSAGE, 'pb with kurtosis ofimage', /continue
+    total_pb = total_pb + 1
+endif
+;
+if (ABS(m_scl[2]) ge err) then begin
+    if KEYWORD_SET(verbose) then MESSAGE, 'pb with skewness of image', /continue
+    total_pb = total_pb + 1
+endif
+;
+if KEYWORD_SET(verbose) then begin
+    print, 'Stats on Raw Image:'
+    print, 'Mean: ', m_raw[0] & print, 'Variance: ', m_raw[1]
+    print, 'Skewness: ', m_raw[2] & print, 'Kurtosis: ', m_raw[3]
+    print, 'Stats on Equalised Image:'
+    print, 'Mean: ', m_scl[0] & print, 'Variance: ', m_scl[1]
+    print, 'Skewness: ', m_scl[2] & print, 'Kurtosis: ', m_scl[3]
+endif
+;
+if KEYWORD_SET(test) then stop
+;
+if (total_pb gt 0) then begin
+    if KEYWORD_SET(no_exit) then begin
+        MESSAGE, 'Tests failed. Increase sample SIZE?', /continue
+    endif else begin
+        EXIT, status=1
+    endelse
+endif else begin
+    MESSAGE, 'Tests successful.', /continue
+endelse
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_histo.pro gdl/testsuite/test_histo.pro
--- gdl-0.9.2/testsuite/test_histo.pro	2009-10-30 10:56:27.000000000 -0600
+++ gdl/testsuite/test_histo.pro	2011-12-06 15:30:24.000000000 -0700
@@ -1,9 +1,9 @@
 ;
-; AC 01-jun-2007
-; SA 30-aug-2009 (test_histo_basic)
+; AC 01-Jun-2007
+; SA 30-Aug-2009 (TEST_HISTO_BASIC)
+; AC 06-Dec-2011 (adding TEST_HISTO_NAN)
 ;
-;
-pro test_histo_randomu, nbp=nbp, nan=nan
+pro TEST_HISTO_RANDOMU, nbp=nbp, nan=nan
 ;
 if (N_ELEMENTS(nbp) EQ 0) then nbp=1e2
 a=randomu(seed,nbp)
@@ -40,7 +40,7 @@
 end
 
 ; SA: intended for checking basic histogram functionality
-pro test_histo_basic
+pro TEST_HISTO_BASIC
 
   ; for any input if MAX/MIN kw. value is the max/min element of input
   ; it shoud be counted in the last/first bins
@@ -76,3 +76,47 @@
   ; TODO: test other possible keyword/input combinations...
 
 end
+;
+; ----------------------------------
+;
+; array "b" did not contain +/- Inf, it is OK
+; array "c" did contain +/- Inf, it is not OK without /nan
+;
+pro TEST_HISTO_NAN, all=all
+;
+a=FINDGEN(10)
+;
+b=a
+b[5]=!values.f_nan
+;
+c=b
+c[7]=!values.f_infinity
+;
+print, HISTOGRAM(a)
+print, HISTOGRAM(b)
+print, HISTOGRAM(b,/nan)
+if KEYWORD_SET(all) then begin
+   print, HISTOGRAM(c)
+   print, HISTOGRAM(c,/nan)
+endif
+;
+print, HISTOGRAM(a, bin=2)
+print, HISTOGRAM(b, bin=2)
+print, HISTOGRAM(b, bin=2,/nan)
+if KEYWORD_SET(all) then begin
+   print, HISTOGRAM(c, bin=2)
+   print, HISTOGRAM(c, bin=2,/nan)
+endif
+;
+print, HISTOGRAM(a, nbin=4)
+print, HISTOGRAM(b, nbin=4)
+print, HISTOGRAM(b, nbin=4,/nan)
+if KEYWORD_SET(all) then begin
+   print, HISTOGRAM(c, nbin=4)
+   print, HISTOGRAM(c, nbin=4,/nan)
+endif
+;
+end
+
+
+
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_image_statistics.pro gdl/testsuite/test_image_statistics.pro
--- gdl-0.9.2/testsuite/test_image_statistics.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_image_statistics.pro	2012-03-05 17:21:54.000000000 -0700
@@ -0,0 +1,96 @@
+;
+; Alain Coulais, 16-Nov-2011, from an idea by LLuvia
+;
+; do we have good statitical/numerical processing, using a know entry ?
+; (was tested with success on x86 and x86_64
+; after "correction" in IMAGE_STATISTICS (type conversion
+; and exact way to call MEAN, STDDEV, TOTAL with /double))
+;
+function DIFF_BELOW_TOL, number1, number2, tolerance
+if (ABS(number1-number2) LT tolerance) then return, 1 else return, 0
+end
+;
+pro TEST_IMAGE_STATISTICS, fake_error=fake_error, $
+                           help=help, test=test, verbose=verbose
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro TEST_IMAGE_STATISTICS, fake_error=fake_error, $'
+   print, '                           help=help, test=test, verbose=verbose'
+   return
+endif
+;
+; Do we have access to ImageMagick functionnalities ??
+;
+if (MAGICK_EXISTS() EQ 0) then begin
+    MESSAGE, /continue, "GDL was compiled without ImageMagick support."
+    MESSAGE, /con, "You must have ImageMagick support to use this functionaly."
+    EXIT, status=77
+endif
+;
+filename='Saturn.jpg'
+path=!path
+;
+liste_of_files=FILE_SEARCH(STRSPLIT(path,':',/ex),filename)
+;
+if (N_ELEMENTS(liste_of_files) EQ 1) then begin
+   if (STRLEN(liste_of_files) EQ 0) then begin
+      MESSAGE, /continue, 'No file founded ...'
+      MESSAGE, /continue, 'File : '+filename
+      MESSAGE, /continue, 'Path : '+path
+      return
+   endif else begin
+      one_file_and_path=liste_of_files[0]
+   endelse
+endif
+if N_ELEMENTS(liste_of_files) GT 1 then begin
+   MESSAGE, /continue, $
+            'Warning: more than one file found, we used the first one !'
+   one_file_and_path=liste_of_files[0]
+endif
+;
+READ_JPEG, one_file_and_path, cube
+;
+if KEYWORD_SET(verbose) then begin
+   MESSAGE, /continue, 'Reading : '+one_file_and_path
+endif
+;
+if SIZE(cube, /N_dim) NE 3 then begin
+   MESSAGE, /continue, '3D cube expected ! Bad reading !!'
+   EXIT, status=1
+endif
+;
+; exemple of introducing fake error:
+if KEYWORD_SET(fake_error) then cube[0,0,1]=234
+;
+; computation of various numbers ...
+;
+IMAGE_STATISTICS, cube, COUNT = pixelNumber, $  
+                  DATA_SUM = pixelTotal, MAXIMUM = pixelMax, $  
+                  MEAN = pixelMean, MINIMUM = pixelMin, $  
+                  STDDEV = pixelDeviation, $  
+                  SUM_OF_SQUARES = pixelSquareSum, $  
+                  VARIANCE = pixelVariance, verbose=verbose
+;
+; we know the expected values
+;
+nb_errors=0
+;
+if pixelNumber NE 466200 then nb_errors=nb_errors+1
+if ~DIFF_BELOW_TOL(pixelTotal, 2.26349e+07, 1e3) then nb_errors=nb_errors+1
+if ~DIFF_BELOW_TOL(pixelMax, 255.0, 0.001) then nb_errors=nb_errors+1
+if ~DIFF_BELOW_TOL(pixelMean, 48.5520, 0.0001) then nb_errors=nb_errors+1
+if ~DIFF_BELOW_TOL(pixelMin,0.0, 0.0001) then nb_errors=nb_errors+1
+if ~DIFF_BELOW_TOL(pixelDeviation, 65.5660, 0.0001) then nb_errors=nb_errors+1
+if ~DIFF_BELOW_TOL(pixelSquareSum, 3.10312e+09, 1e4) then nb_errors=nb_errors+1
+if ~DIFF_BELOW_TOL(pixelVariance, 4298.91, 0.01) then nb_errors=nb_errors+1
+;
+if (nb_errors GT 0) then begin
+   MESSAGE, /continue, 'Number of Errors: '+STRING(nb_errors)
+   if ~KEYWORD_SET(test) then EXIT, status=1
+endif else begin
+   MESSAGE, /continue, 'No Errors founded'
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_interpol.pro gdl/testsuite/test_interpol.pro
--- gdl-0.9.2/testsuite/test_interpol.pro	2010-04-09 04:30:38.000000000 -0600
+++ gdl/testsuite/test_interpol.pro	2012-03-05 07:50:56.000000000 -0700
@@ -1,39 +1,126 @@
+;
+; testin INTERPOL on few basic cases ...
+;
 ; by Sylwester Arabas <slayoo@igf.fuw.edu.pl>
-pro test_interpol
-
-  ; test data - a parabola probed at four points
-  x = [0.,1.,2.,3.]
-  y = x*x
-
-  ; 2-parameter case, linear interpolation, sanity check
-  if ~array_equal(y, interpol(y, 4)) then begin
-    message, '2p, linear', /conti
-    exit, status=1
-  endif 
-
-  ; 2-parameter case, linear vs. spline interpolation
-  wh = where(interpol(y, 7, /spline) gt interpol(y, 7), cnt)
-  if cnt ne 0 then begin
-    message, '2p, spline', /conti
-    exit, status=1
-  endif
-
-  ; 3-parameter case, linear vs. spline interpolation
-  mid = [.5,1.5,2.5]
-  wh = where(interpol(y, x, mid, /spline) gt interpol(y, x, mid), cnt)
-  if cnt ne 0 then begin
-    message, '3p, spline', /conti
-    exit, status=1
-  endif
-
-  ; ensuring interpol(/spline) returns the same as spl_interp() 
-  ; (intentionally swapping x,y with y,x)
-  if ~array_equal( $
-    interpol(x, y, mid, /spline), $
-    spl_interp(y, x, spl_init(y, x), mid) $
-  ) then begin
-    message, 'interpol(/spline) != spl_interp', /conti
-    exit, status=1
-  endif
-
+;
+; Extended by Alain Coulais on March 5, 2012
+;
+pro TEST_INTERPOL, test=test, quiet=quiet, help=help
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro TEST_INTERPOL, test=test, quiet=quiet, help=help'
+    return
+endif
+;
+error_level=1e-6
+nb_errors=0
+;
+; test data - a parabola probed at four points
+x = [0.,1.,2.,3.]
+y = x*x
+;
+; 2-parameter case, linear interpolation, sanity check
+;
+if ~ARRAY_EQUAL(y, INTERPOL(y, 4)) then begin
+    MESSAGE, 'ERROR: 2p, linear', /continue
+    nb_errors=nb_errors+1
+endif else begin
+    if ~KEYWORD_SET(quiet) then MESSAGE, 'SUCCESS: 2p, linear:', /continue
+endelse
+
+; 2-parameter case, linear vs. spline interpolation
+;
+wh = WHERE(INTERPOL(y, 7, /spline) gt INTERPOL(y, 7), cnt)
+if (cnt NE 0) then begin
+    MESSAGE, 'ERROR: 2p, spline', /continue
+    nb_errors=nb_errors+1
+endif else begin
+    if ~KEYWORD_SET(quiet) then MESSAGE, 'SUCCESS: 2p, spline', /continue
+endelse
+
+; 3-parameter case, linear vs. spline interpolation
+;
+mid = [0.5,1.5,2.5]
+wh = WHERE(INTERPOL(y, x, mid, /spline) gt INTERPOL(y, x, mid), cnt)
+if (cnt NE 0) then begin
+    MESSAGE, 'ERROR: 3p, spline', /conti
+    nb_errors=nb_errors+1
+endif else begin
+    if ~KEYWORD_SET(quiet) then MESSAGE, 'SUCCESS: 3p, spline', /continue
+endelse
+;
+; ensuring INTERPOL(/spline) returns the same as spl_interp() 
+; (intentionally swapping x,y with y,x)
+;
+res_interpol=INTERPOL(x, y, mid, /spline)
+res_spline=SPL_INTERP(y, x, SPL_INIT(y, x), mid)
+if ~ARRAY_EQUAL(res_interpol,res_spline) then begin
+    MESSAGE, 'ERROR: INTERPOL(/spline) != spl_interp', /continue
+    nb_errors=nb_errors+1
+endif else begin
+    if ~KEYWORD_SET(quiet) then MESSAGE, 'SUCCESS: INTERPOL(/spline) != spl_interp', /continue
+endelse
+;
+; testing computation outside input range
+;
+; flat case (very basic case)
+;
+yy=REPLICATE(2.,N_ELEMENTS(x))
+zz=[-10,-5,x, 5, 10]
+;
+res_interpol=(INTERPOL(yy, x, zz)-2.)
+res_spline=(INTERPOL(yy, x, zz, /spline)-2)
+;
+if (MAX(ABS(res_interpol)) GT error_level) then begin
+    MESSAGE, 'ERROR: extrapol. flat linear', /continue
+    nb_errors=nb_errors+1
+endif else begin
+    if ~KEYWORD_SET(quiet) then MESSAGE, 'SUCCESS: extrapol. flat linear', /continue
+endelse
+;
+if (MAX(ABS(res_spline)) GT error_level) then begin
+    MESSAGE, 'ERROR: extrapol. flat spline', /continue
+    nb_errors=nb_errors+1
+endif else begin
+    if ~KEYWORD_SET(quiet) then MESSAGE, 'SUCCESS: extrapol. flat spline', /continue
+endelse
+;
+; linear case (basic case)
+;
+nbp=11
+x=FINDGEN(nbp)-nbp/2.
+y=x
+;
+nbp=21
+x_new=1.1*(FINDGEN(nbp)-nbp/2.)
+y_new=x_new
+;
+res_interpol=INTERPOL(y, x, x_new)
+res_spline=INTERPOL(y*1.d, x, x_new, /spline)  ;; we compute in Double, IDL pb
+;
+if (MAX(ABS(res_interpol-y_new)) GT error_level) then begin
+    MESSAGE, 'ERROR: extrapol. linear linear', /continue
+    nb_errors=nb_errors+1
+endif else begin
+    if ~KEYWORD_SET(quiet) then MESSAGE, 'SUCCESS: extrapol. linear linear', /continue
+endelse
+;
+if (MAX(ABS(res_spline-y_new)) GT error_level) then begin
+    MESSAGE, 'ERROR: extrapol. line w. spline', /continue
+    nb_errors=nb_errors+1
+endif else begin
+    if ~KEYWORD_SET(quiet) then MESSAGE, 'SUCCESS: extrapol. line w. spline', /continue
+endelse
+;
+; ------------------- final errors count ------------------
+;
+if (nb_errors GT 0) then begin
+    MESSAGE, /continue, STRING(nb_errors)+' Errors founded'
+    if ~KEYWORD_SET(test) then EXIT, status=1
+endif else begin
+    MESSAGE, /continue, 'No Errors founded'
+endelse
+;
+if KEYWORD_SET(test) then STOP    
+;
 end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_ludc_lusol.pro gdl/testsuite/test_ludc_lusol.pro
--- gdl-0.9.2/testsuite/test_ludc_lusol.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_ludc_lusol.pro	2012-02-13 09:07:58.000000000 -0700
@@ -0,0 +1,121 @@
+;
+; AC 9-dec-2011
+; this is a very preliminary test case for LUDC and LUSOL,
+; working ONLY when inputs are of DOUBLE types.
+;
+; AC 13-Feb-2012: extended to other types but LUDC is today
+; only able to return Double type.
+;
+; help welcome, extensions welcome (esp. examples and code for
+; missing parameters (/column, interchanges= ...)
+;
+; ------------------------------------------------
+; the first test is based on the example given on IDL pages
+; http://idlastro.gsfc.nasa.gov/idl_html_help/LUSOL.html
+;
+pro TEST_LUDC_IDL, double=double, noexit=noexit, test=test, verbose=verbose
+;
+print, 'testing LUDC then LUSOL on IDL example'
+
+; Define array A:  
+A = [[ 2.0,  1.0,  1.0], $
+     [ 4.0, -6.0,  0.0], $  
+     [-2.0,  7.0,  2.0]]
+a_ref=a
+; Define right-hand side vector B:  
+B = [3.0, -8.0, 10.0]  
+;
+if KEYWORD_set(double) then begin 
+   ;; A and B must be DOUBLE now ...
+   a=A*1.D
+   b=b*1.D
+endif
+;
+; Decompose A:  
+LUDC, A, INDEX  
+;
+res=LUSOL(a, index, b)
+;
+print, "expected:", b
+print, "computed:", TRANSPOSE(a_ref##res)
+;
+error=1e-5
+nb_errors=0
+;
+resu=SQRT(TOTAL((b-TRANSPOSE(a_ref##res))^2))
+if (resu GT error) then nb_errors=nb_errors+1
+;
+if (nb_errors GT 0) then begin
+   MESSAGE, /continue, "Problems !!"
+   if ~KEYWORD_SET(noexit) then EXIT, status=1
+endif else begin
+   MESSAGE, /continue, "Basic tests OK"
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; ------------------------------------------------
+;
+; the second test is based on the example given on GSL pages
+; http://www.gnu.org/s/gsl/manual/html_node/Linear-Algebra-Examples.html
+;
+pro TEST_LUDC_GSL, double=double, noexit=noexit, $
+                   test=test, verbose=verbose, debug=debug
+;
+print, 'testing LUDC then LUSOL on GSL example'
+
+A = [[ 0.18, 0.60, 0.57, 0.96], $
+     [ 0.41, 0.24, 0.99, 0.58], $
+     [ 0.14, 0.30, 0.97, 0.66], $
+     [ 0.51, 0.13, 0.19, 0.85]]
+a_ref=a
+;
+b=[ 1.0, 2.0, 3.0, 4.0]
+;
+if KEYWORD_set(double) then begin 
+   ;; A and B must be DOUBLE now ...
+   a=A*1.D
+   b=b*1.D
+endif
+
+LUDC, A, INDEX
+
+if KEYWORD_SET(debug) then STOP
+
+res=LUSOL(a, index, b)
+;print, res
+
+print, "expected:", b
+print, "computed:", TRANSPOSE(a_ref##res)
+;
+error=1e-5
+nb_errors=0
+;
+resu=SQRT(TOTAL((b-TRANSPOSE(a_ref##res))^2))
+if (resu GT error) then nb_errors=nb_errors+1
+;
+if (nb_errors GT 0) then begin
+   MESSAGE, /continue, "Problems !!"
+   if ~KEYWORD_SET(noexit) then EXIT, status=1
+endif else begin
+   MESSAGE, /continue, "Basic tests OK"
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; ------------------------
+; to be extended in such a way errors codes can be managed ...
+;
+pro TEST_LUDC_LUSOL
+;
+TEST_LUDC_IDL
+TEST_LUDC_GSL
+;
+TEST_LUDC_IDL,/double
+TEST_LUDC_GSL,/double
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_moment.pro gdl/testsuite/test_moment.pro
--- gdl-0.9.2/testsuite/test_moment.pro	2010-10-13 17:07:51.000000000 -0600
+++ gdl/testsuite/test_moment.pro	2012-07-14 13:01:41.000000000 -0600
@@ -5,11 +5,126 @@
 ;
 ; ToDo: testing /NaN ?!
 ;
+; Since 16 June 2012, we also have DIMENSION for MOMENT() (Mathieu Pinter)
+; Since 14 July 2012, we also have DIMENSION for related codes:
+;                     MEAN(), STDDEV(), VARIANCE(), SKEWNESS(), KURTOSIS()
+;
+; -------------------------------------------------------------
+;
 function ERREUR, x1, x2
 return, SQRT(TOTAL((x1-x2)^2))
 end
 ;
-pro TEST_MOMENT, test=test
+; -------------------------------------------------------------
+;
+function CHECK_DIMENSION_CAPABILITY, verbose=verbose
+;
+; IDL before version 8 cannot manage DIMENSION keyword
+;
+; Since 16 June 2012, we also have DIMENSION for MOMENT()
+; Since 14 July 2012, we also have DIMENSION for related codes:
+;    MEAN(), STDDEV(), VARIANCE(), SKEWNESS(), KURTOSIS()
+;
+if KEYWORD_SET(verbose) then begin
+   txt1='dimension keyword is available in MOMENT() and related codes:'
+   txt2='MEAN(), STDDEV(), VARIANCE(), SKEWNESS(), KURTOSIS()'
+endif
+;
+DEFSYSV, '!gdl', exists=isGDL
+;
+check_dim=0
+;
+if (isGDL) then begin
+   check_dim=1
+   if KEYWORD_SET(verbose) then begin
+      MESSAGE,/cont, 'in GDL, '+txt1
+      MESSAGE,/cont, txt2
+   endif
+endif else begin
+   ;; when IDL, which major version ? we assume "." is the separator !
+   version=!version.release
+   if (FIX(STRMID(version,0, STRPOS(version,'.'))) GE 8) then check_dim=1
+   if KEYWORD_SET(verbose) then begin
+      if (check_dim EQ 0) then begin
+         MESSAGE,/cont, 'in IDL, before 8.0, dimension keyword not available !'
+      endif else begin
+         MESSAGE,/cont, 'in IDL, since 8.0, '+txt1
+         MESSAGE,/cont, txt2
+      endelse
+   endif
+endelse
+;
+return, check_dim
+;
+end
+;
+; -------------------------------------------------------------
+;
+pro CHECK_VISUAL_MOMENT, data, force_dim=force_dim, no_exit=no_exit, $
+                         help=help, test=test, verbose=verbose
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro CHECK_VISUAL_MOMENT, data, force_dim=force_dim, no_exit=no_exit, $'
+   print, '                         help=help, test=test, verbose=verbose'
+   return
+endif
+;
+; do we have the dimension keyword capability ?
+;
+if ~KEYWORD_SET(force_dim) then begin
+   check_dim=CHECK_DIMENSION_CAPABILITY()
+endif else check_dim=1
+;
+if (check_dim EQ 0) then begin
+   MESSAGE, 'this test requires Dimension keyword capability'
+endif
+;
+if N_PARAMS() EQ 0 then data=DIST(115, 128)
+;
+nb_nan=N_ELEMENTS(data)/10
+pos=FIX(RANDOMU(seed,nb_nan)*N_ELEMENTS(data))
+data_NaN=data
+data_NaN[pos]=!values.f_nan
+;
+for ii=0,1 do begin
+   if ii EQ 0 then begin
+      tmp=data 
+      title='no NaN'
+   endif else begin
+      tmp=data_NaN
+      title='with 10% NaN'
+   endelse
+   WINDOW, ii, xsize=400, ysize=750, title=title
+   !p.multi=[0,2,4]
+   ;;
+   plot, MEAN(tmp, dim=1,/nan), title='MEAN, dim=1'
+   plot, MEAN(tmp, dim=2,/nan), title='MEAN, dim=1'
+   plot, STDDEV(tmp, dim=1,/nan), title='STDDEV, dim=1'
+   plot, STDDEV(tmp, dim=2,/nan), title='STDDEV, dim=2'
+   plot, SKEWNESS(tmp, dim=1,/nan), title='SKEWNESS, dim=1'
+   plot, SKEWNESS(tmp, dim=2,/nan), title='SKEWNESS, dim=2'
+   plot, KURTOSIS(tmp, dim=1,/nan), title='KURTOSIS, dim=1'
+   plot, KURTOSIS(tmp, dim=2,/nan), title='KURTOSIS, dim=2'
+endfor
+;
+!p.multi=0
+;
+end
+;
+pro TEST_NUMERICAL_MOMENT, force_dim=force_dim, no_exit=no_exit, $
+                           help=help, test=test, verbose=verbose
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro TEST_NUMERICAL_MOMENT, force_dim=force_dim, no_exit=no_exit, $'
+    print, '                           help=help, test=test, verbose=verbose'
+    return
+endif
+;
+; do we have the dimension keyword capability ?
+;
+if ~KEYWORD_SET(force_dim) then begin
+   check_dim=CHECK_DIMENSION_CAPABILITY(/verbose)
+endif else check_dim=1
 ;
 nb_pb=0
 ;
@@ -27,13 +142,67 @@
 e2=ERREUR(expected_resu2, resu2)
 if (e2 GT 1e-5) then nb_pb=nb_pb+1
 ;
-if KEYWORD_SET(test) then STOP
+; -----
+;
+a=FINDGEN(3, 2, 3)^2
+expected_resu3=[[[60.0000, 73.0000, 88.0000], $
+                 [105.000, 124.000, 145.000]], $
+                [[5616.00, 7488.00, 9648.00], $
+                 [12096.0, 14832.0, 17856.0]], $
+                [[0.287409, 0.256015, 0.229751], $
+                 [0.207827, 0.189413, 0.173812]], $
+                [[-2.33333, -2.33333, -2.33333], $
+                 [-2.33333, -2.33333, -2.33333]]]
+if (check_dim) then begin
+    resu3=MOMENT(a, DIMENSION=3)
+    e3=ERREUR(expected_resu3, resu3)
+    if (e3 GT 1e-5) then nb_pb=nb_pb+1
+endif else MESSAGE, /continue, 'skipping /DIM test'
+;
+; -----
+;
+a=[1,4,5,!VALUES.F_NAN]
+expected_resu4=[3.33333, 4.33333, -0.28741, -2.33333]
+resu4=MOMENT(a, /NAN)
+e4=ERREUR(expected_resu4, resu4)
+if (e4 GT 1e-5) then nb_pb=nb_pb+1
+;
+; -----
+;
+a=[[1,4,5,!VALUES.F_NAN],[6,8,!VALUES.F_NAN, 9]]
+expected_resu5=[[3.33333,7.66667], $
+                [4.33333,2.33333],[-0.28741,-0.20783], $
+                [-2.33333,-2.33333]]
+if (check_dim) then begin
+    resu5=MOMENT(a, DIMENSION=1, /NAN)
+    e5=ERREUR(expected_resu5, resu5)
+    if (e5 GT 1e-5) then nb_pb=nb_pb+1
+endif else MESSAGE, /continue, 'skipping /DIM test'
+;
+; -----------------
 ;
 if (nb_pb EQ 0) then begin 
    MESSAGE, 'No problem found in TEST_MOMENT', /continue
 endif else begin
    MESSAGE, STRING(nb_pb)+' problem(s) found in TEST_MOMENT', /continue
-   EXIT, status=1
 endelse
 ;
+if KEYWORD_SET(test) then STOP
+;
+if (nb_pb GT 0) AND ~KEYWORD_SET(no_exit) then EXIT, status=1
+;
+end
+;
+; ------------------------------------
+;
+pro TEST_MOMENT, force_dim=force_dim, $
+                 help=help, test=test, no_exit=no_exit, verbose=verbose
+;
+TEST_NUMERICAL_MOMENT, force_dim=force_dim, help=help, $
+                       test=test, no_exit=no_exit, verbose=verbose
+;
+CHECK_VISUAL_MOMENT, force_dim=force_dim, help=help, $
+                     test=test, no_exit=no_exit, verbose=verbose
+;
 end
+
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_mpfit.pro gdl/testsuite/test_mpfit.pro
--- gdl-0.9.2/testsuite/test_mpfit.pro	2010-10-26 16:30:15.000000000 -0600
+++ gdl/testsuite/test_mpfit.pro	2011-11-16 15:32:57.000000000 -0700
@@ -6,6 +6,12 @@
 ; AC 26/10/2010: better managment of error when CMSV lib. or MPFIT
 ; lib. are not in the path ...
 ;
+; 16-Nov-2011
+; G. Duvert submitted a patch when we have several occurences
+; of MPFIT files in the GDL_PATH !
+;
+; this file is under GNU GPL v2 or later
+;
 function PARABOLE, x, params
 ;
 return, params[2]*x*params[1]*x+x+params[0]
@@ -69,11 +75,15 @@
 ; We are checking if MPFIT Lib. is in the !PATH
 ;
 paths=STRSPLIT(!PATH, PATH_SEP(/SEARCH_PATH), /EXTRACT)
-mpfit_path=FILE_SEARCH(paths+'/mpfit.pro')
-if STRLEN(mpfit_path) EQ 0 then MESSAGE, 'MPfit Lib. not in PATH ...'
-;
-datafile=FILE_SEARCH(paths+'/fakedata.sav')
-if STRLEN(datafile) EQ 0 then MESSAGE, '<<fakedata.sav>> file missing ...'
+mpfit_path=FILE_SEARCH(paths+'/mpfit.pro', count=nfiles)
+if (nfiles EQ 0) then MESSAGE, 'MPfit Lib. not in PATH ...'
+if (nfiles GT 1) then MESSAGE, /cont, 'multiple occurence of MPfit Lib., first used'
+mpfit_path=mpfit_path[0]
+;
+datafile=FILE_SEARCH(paths+'/fakedata.sav', count=nfiles)
+if (nfiles EQ 0) then MESSAGE, '<<fakedata.sav>> file missing ...'
+if (nfiles GT 1) then MESSAGE, /cont, 'multiple occurence of <<fakedata.sav>> file, first used'
+datafile=datafile[0]
 ;
 ; reading back the data
 RESTORE, datafile
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_plotting_ranges.pro gdl/testsuite/test_plotting_ranges.pro
--- gdl-0.9.2/testsuite/test_plotting_ranges.pro	2011-07-03 06:52:03.000000000 -0600
+++ gdl/testsuite/test_plotting_ranges.pro	2012-01-26 16:18:51.000000000 -0700
@@ -15,12 +15,11 @@
 
   print, '2'
   plot, [1, 10], /ylog
-  if !Y.CRANGE[0] ne 1 then err += 1
+  if !Y.CRANGE[0] ne 0 then err += 1
 
-; still to be fixed 
-;  print, '3'
-;  plot, [0], yrange=[400,1500] 
-;  if !Y.CRANGE[1] lt 1600 then err += 1
+  print, '3'
+  plot, [0], yrange=[400,1500] 
+  if !Y.CRANGE[1] lt 1600 then err += 1
 
   if err ne 0 then exit, status=1
 
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_poly2d.pro gdl/testsuite/test_poly2d.pro
--- gdl-0.9.2/testsuite/test_poly2d.pro	2009-11-24 09:44:13.000000000 -0700
+++ gdl/testsuite/test_poly2d.pro	2012-01-23 09:51:41.000000000 -0700
@@ -1,4 +1,14 @@
-pro test_poly2d
+;
+; Visual tests for POLY_2D
+;
+; reworked by Alain on 2011-Dec-15
+;
+; TEST_POLY2D_NEW is not finished but it is now
+; more convenient to see that:
+;  -- missing is not working
+;  -- we have a problem at some edges or in some regions
+;
+pro TEST_POLY2D_OLD
 
 XO = [61, 62, 143, 133]  
 YO = [89, 34, 38, 105]  
@@ -17,23 +27,23 @@
 
 window,0,xs=300,ys=300 & tv,a1
 
-B0 = POLY_2D(A1, P, Q,missing=0)
+B0 = POLY_2D(A1, P, Q,missing=128)
 window,1,xs=220,ys=220
 tv,b0
 
-B1 = POLY_2D(A1, P, Q,missing=0,cubic=-0.5)
+B1 = POLY_2D(A1, P, Q,missing=128,cubic=-0.5)
 window,2,xs=220,ys=220
 tv,b1
 
-B2 = POLY_2D(A1, P, Q,2,missing=0)
+B2 = POLY_2D(A1, P, Q,2,missing=128)
 window,3,xs=220,ys=220
 tv,b1
 
-B3 = POLY_2D(A1, P, Q,1,missing=0)
+B3 = POLY_2D(A1, P, Q,1,missing=128)
 window,4,xs=220,ys=220
 tv,b3
 
-B4 = POLY_2D(A1, P, Q,1,50,100,missing=0)
+B4 = POLY_2D(A1, P, Q,1,50,100,missing=128)
 window,5,xs=220,ys=220
 tv,b4
 
@@ -99,10 +109,10 @@
 z=30.5
 p=[[z,0.],[1,0]] & q=[[0.,1],[0,0]]
 
-B1a = POLY_2D(A1, P, Q,missing=0)
+B1a = POLY_2D(A1, P, Q,missing=128)
 window,13,xs=220,ys=220 & tv,b1a
 
-B1b = POLY_2D(A1, P, Q,missing=0,cubic=-0.5)
+B1b = POLY_2D(A1, P, Q,missing=128,cubic=-0.5)
 window,14,xs=220,ys=220 & tv,b1b
 
 diff=b1b-b1a
@@ -113,10 +123,10 @@
 z=40.5
 p=[[0,0.],[1,0]] & q=[[z,1],[0,0]]
 
-B1a = POLY_2D(A1, P, Q,missing=0)
+B1a = POLY_2D(A1, P, Q,missing=128)
 window,13,xs=220,ys=220 & tv,b1a
 
-B1b = POLY_2D(A1, P, Q,missing=0,cubic=-0.5)
+B1b = POLY_2D(A1, P, Q,missing=128,cubic=-0.5)
 window,14,xs=220,ys=220 & tv,b1b
 
 diff=b1b-b1a
@@ -127,10 +137,10 @@
 z=40.5
 p=[[z,0.],[1,0]] & q=[[z,1],[0,0]]
 
-B1a = POLY_2D(A1, P, Q,missing=0)
+B1a = POLY_2D(A1, P, Q,missing=128)
 window,13,xs=220,ys=220 & tv,b1a
 
-B1b = POLY_2D(A1, P, Q,missing=0,cubic=-0.5)
+B1b = POLY_2D(A1, P, Q,missing=128,cubic=-0.5)
 window,14,xs=220,ys=220 & tv,b1b
 
 diff=b1b-b1a
@@ -138,3 +148,241 @@
 
 return
 end
+;
+; reworked by Alain on 2011-Dec-15
+;
+pro INIT_POLYWARP, P, Q, $
+                   xI=xI, yI=yI, xO=xO, yO=yO, degree=degree, $
+                   test=test, help=help
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro INIT_POLYWARP, P, Q, $'
+   print, '                   xI=xI, yI=yI, xO=xO, yO=yO, degree=degree, $'
+   print, '                   test=test, help=help'
+endif
+;
+paths=STRSPLIT(!PATH, PATH_SEP(/SEARCH_PATH), /EXTRACT)
+polywarp_path=FILE_SEARCH(paths+'/polywarp.pro', count=nfiles)
+if (nfiles EQ 0) then begin
+   MESSAGE, /continue, 'POLYWARP not in the !PATH ... Fixed values used'
+   p=[[-5.37842,-0.320945],[ 0.751471,  0.00222929]]
+   q=[[-10.1480,  1.07085],[-0.0168754,-0.000576214]]
+endif else begin
+   ;; Set up the arrays of points to be fit:  
+   if N_ELEMENTS(xI) EQ 0 then xI = [24, 35, 102, 92]  
+   if N_ELEMENTS(yI) EQ 0 then yI = [81, 24, 25, 92]  
+   if N_ELEMENTS(xO) EQ 0 then xO = [61, 62, 143, 133]  
+   if N_ELEMENTS(yO) EQ 0 then yO = [89, 34, 38, 105]  
+   if N_ELEMENTS(degree) EQ 0 then degree=1
+   ;; Use POLYWARP to generate the P and Q inputs to POLY_2D:  
+   POLYWARP, XI, YI, XO, YO, 1, P, Q
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; ------------------------------
+;
+pro TV_OR_WINDOW, image, position, split, title=title
+;
+if (split NE 0) then begin
+   ws=SIZE(image,/dim)
+   WINDOW, xs=ws[0], ys=ws[1], title=title,/free
+   TV, image
+endif else begin
+   TV, image, position
+endelse
+end
+;
+; ------------------------------
+;
+pro TEST_POLY2D_NEW, image,nbpX=nbpX, nbpY=nbpY, $
+                     split_windows=split_windows, $
+                     test=test, debug=debug, help=help
+;
+split=0
+if KEYWORD_SET(split_windows) then split=1
+;
+INIT_POLYWARP, P, Q
+;
+; Perform an image warping based on P and Q:  
+; Create and display a simple image:  
+;
+if N_PARAMS() EQ 0 then begin
+   A = BYTSCL(SIN(DIST(250)))
+   a1=DOUBLE(a)
+endif else begin
+   a1=DOUBLE(image)
+endelse
+;
+if (N_ELEMENTS(nbpX) EQ 0 ) then nbpX=100
+if (N_ELEMENTS(nbpY) EQ 0 ) then nbpY=200
+;
+a1=a1[0:nbpX-1,0:nbpY-1]
+;
+;
+WINDOW, 0, xs=300, ys=300, title='input'
+TV, a1
+;
+WINDOW, 1, xs=6*nbpX, ys=nbpY, title='input (L), 5 transforms (/miss)'
+position=0
+;
+TV_OR_WINDOW, a1, position, split, title='ref.'
+;
+B0 = POLY_2D(a1, P, Q, missing=128)
+TV_OR_WINDOW, b0, position+1, split, title='ref.'
+TV, b0, position+1
+;
+b1 = POLY_2D(a1, P, Q, missing=128, cubic=-0.5)
+TV_OR_WINDOW, b1, position+2, split, title='ref.'
+;
+b2 = POLY_2D(a1, P, Q, 2, missing=128)
+TV_OR_WINDOW, b2, position+3, split, title=''
+;
+b3 = POLY_2D(a1, P, Q, 1, missing=128)
+TV_OR_WINDOW, b3, position+4, split, title=''
+;
+; here it is more tricky because the size of "b4"
+; is changed. We need to copy it.
+b4f=FLTARR(SIZE(a1,/dim))
+b4 = POLY_2D(a1, P, Q, 1, 50, 100)
+b4f[0:50-1,0:100-1]=b4
+TV_OR_WINDOW, b4f, position+5, split, title='sub image'
+;
+if KEYWORD_SET(debug) then STOP
+;
+; Same than previous but without activating Missing Keyword
+;
+WINDOW, 2, xs=6*nbpX, ys=nbpY, title='input (L), 5 trans. (no missing)'
+position=0
+;
+TV_OR_WINDOW, a1, position, split, title=''
+;
+b0 = POLY_2D(a1, P, Q)
+TV_OR_WINDOW, b0, position+1, split, title=''
+;
+b1 = POLY_2D(a1, P, Q,cubic=-0.5)
+TV_OR_WINDOW, b1, position+2, split, title=''
+;
+b2 = POLY_2D(a1, P, Q, 2)
+TV_OR_WINDOW, b2, position+3, split, title=''
+;
+b3 = POLY_2D(a1, P, Q, 1)
+TV_OR_WINDOW, b3, position+4, split, title=''
+;
+; here it is more tricky because the size of "b4"
+; is changed. We need to copy it.
+b4f=FLTARR(SIZE(a1,/dim))
+b4 = POLY_2D(a1, P, Q, 1, 50, 100)
+b4f[0:50-1,0:100-1]=b4
+TV_OR_WINDOW, b4f, position+5, split, title=''
+;
+if KEYWORD_SET(debug) then STOP
+;
+; --------------------
+; LINEAR
+WINDOW, 3, xs=4*nbpX, ys=3*nbpY
+position=0
+;
+; Identity
+b1=poly_2d(a1,[0,0,1,0],[0,1,0,0])
+TV, b1, position
+;
+; stretch x by factor 2
+b1=poly_2d(a1,[0,0,0.5,0],[0,1,0,0])
+TV, b1, position+1
+;
+; shrink y by factor 2
+b1=poly_2d(a1,[0,0,1,0],[0,2,0,0],/missing)
+TV, b1, position+2
+;
+; stretch x by factor 2 & shrink y by factor 2
+b1=poly_2d(a1,[0,0,0.5,0],[0,2,0,0],/missing)
+TV, b1, position+3
+;
+; shift left by 20 pixels
+b1=poly_2d(a1,[20,0,1,0],[0,1,0,0],/missing)
+TV, b1, position+4
+;
+; shift right by 20 pixels
+b1=poly_2d(a1,[-20,0,1,0],[0,1,0,0],/missing)
+TV, b1, position+5
+;
+; shift up by 20 pixels
+b1=poly_2d(a1,[0,0,1,0],[20,1,0,0],/missing)
+TV, b1, position+6
+;
+; shift down by 20 pixels
+b1=poly_2d(a1,[0,0,1,0],[-20,1,0,0],/missing)
+TV, b1, position+7
+;
+; shift left by 40 up by 20 pixels
+b1=poly_2d(a1,[40,0,1,0],[20,1,0,0],/missing)
+TV, b1, position+8
+;
+; rotate by 30 degrees
+c=cos(30*!pi/180)
+s=sin(30*!pi/180)
+b1=poly_2d(a1,[0,c,s,0],[0,-s,c,0],/missing)
+TV, b1, position+9
+
+; stretch x by factor 2 & shrink y by factor 2
+b1=poly_2d(a1,[0,0,0.5,0],[0,2,0,0],0,50,100,/missing)
+TV, b1, position+10
+
+; shift left by 40 up by 20 pixels
+b1=poly_2d(a1,[40,0,1,0],[20,1,0,0],0,50,100,/missing)
+TV, b1, position+11
+
+stop
+
+; X-Translation
+z=30.5
+p=[[z,0.],[1,0]] & q=[[0.,1],[0,0]]
+
+b1a = POLY_2D(a1, P, Q,missing=128)
+WINDOW,13,xs=220,ys=220 & TV, b1a
+
+b1b = POLY_2D(a1, P, Q,missing=128,cubic=-0.5)
+WINDOW,14,xs=220,ys=220 & TV, b1b
+
+diff=b1b-b1a
+TV,diff
+
+
+; Y-Translation
+z=40.5
+p=[[0,0.],[1,0]] & q=[[z,1],[0,0]]
+
+b1a = POLY_2D(a1, P, Q,missing=128)
+WINDOW,13,xs=220,ys=220 & TV, b1a
+
+b1b = POLY_2D(a1, P, Q,missing=128,cubic=-0.5)
+WINDOW,14,xs=220,ys=220 & TV, b1b
+
+diff=b1b-b1a
+TV,diff
+
+
+; XY-Translation
+z=40.5
+p=[[z,0.],[1,0]] & q=[[z,1],[0,0]]
+
+b1a = POLY_2D(a1, P, Q,missing=128)
+WINDOW,13,xs=220,ys=220 & TV, b1a
+
+b1b = POLY_2D(a1, P, Q,missing=128,cubic=-0.5)
+WINDOW,14,xs=220,ys=220 & TV, b1b
+
+diff=b1b-b1a
+TV,diff
+
+return
+end
+
+pro TEST_POLY2D
+
+TEST_POLY2D_NEW
+
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_postscript.pro gdl/testsuite/test_postscript.pro
--- gdl-0.9.2/testsuite/test_postscript.pro	2011-08-30 02:37:21.000000000 -0600
+++ gdl/testsuite/test_postscript.pro	2011-12-29 18:10:47.000000000 -0700
@@ -3,7 +3,35 @@
 ;
 ; Alain Coulais 23/08/2011
 ;
-pro TEST_POSTSCRIPT
+; adding APPLEMAN and SATURN test due to great progress by Sylwester
+;
+; -------------------------------------------
+;
+pro TEST_POSTSCRIPT_APPLEMAN
+;
+DEFSYSV, '!gdl', exists=isGDL
+if isGDL then prefix='GDL_' else prefix='IDL_'
+;
+SET_PLOT, 'PS'
+;
+DEVICE, filename=prefix+'appleman.ps'
+;
+plot, findgen(1000), /nodata, $
+      xrange=[-10, 650], yrange=[-10,522], /xstyle, /ystyle
+;
+APPLEMAN, res=res, /NoDisplay
+LOADCT, 15
+TV, res, xsize=640, ysize=512
+;
+DEVICE, /close
+;
+SET_PLOT, 'X'
+;
+end
+;
+; -------------------------------------------
+;
+pro TEST_POSTSCRIPT_BASIC
 ;
 DEFSYSV, '!gdl', exists=isGDL
 if isGDL then prefix='GDL_' else prefix='IDL_'
@@ -32,6 +60,17 @@
 plot, FINDGEN(10)
 device, /close
 ;
-SET_PLOT, 'PS'
+; back to X11
+SET_PLOT, 'X'
+;
+end
+
+pro TEST_POSTSCRIPT
+;
+TEST_POSTSCRIPT_BASIC
+TEST_POSTSCRIPT_APPLEMAN
+;
+; to do TEST_POSTSCRIPT_SATURN
 ;
 end
+
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_ps_decomposed.pro gdl/testsuite/test_ps_decomposed.pro
--- gdl-0.9.2/testsuite/test_ps_decomposed.pro	2011-10-29 03:55:16.000000000 -0600
+++ gdl/testsuite/test_ps_decomposed.pro	2011-12-29 18:10:47.000000000 -0700
@@ -5,7 +5,7 @@
 ; this code was failing on a computer with "bad" locale (fr_FR.utf8)
 ;
 pro CHECK_PS_COLOR, file=file, delete=delete, decomposed=decomposed, $
-                    color=color, expected_rgb=expected_rgb
+                    color=color, expected_rgb=expected_rgb, test=test
 
 DEVICE, /color, decomposed=decomposed, file=file
 POLYFILL, [0,1,1,0], [0,0,1,1], color=color, /normal
@@ -15,21 +15,30 @@
 command=command+ file + "|tail -1"
 SPAWN, command, output
 ;
-if KEYWORD_SET(delete) then FILE_DELETE, tmpfile, /quiet
+; eventual cleaning of temporary files
+if KEYWORD_SET(delete) then FILE_DELETE, file, /quiet
 ;
-READS, output, r,g,b
+READS, output, r, g, b
 if ~ARRAY_EQUAL(BYTE(255*[r,g,b]), expected_rgb) then begin
    MESSAGE, /continue, $
             'rgb triple read from the PS file does not math the expected one'
    EXIT, status=1
 endif
 ;
+if KEYWORD_SET(test) then STOP
+;
 end
 ;
 ; ------------------------------
 ;
-pro TEST_PS_DECOMPOSED, no_delete=no_delete
+pro TEST_PS_DECOMPOSED, no_delete=no_delete, help=help, test=test
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro TEST_PS_DECOMPOSED, no_delete=no_delete, help=help, test=test'
+   return
+endif
 ;
+; by default, the temporary files will be deleted
 delete=0
 if ~KEYWORD_SET(no_delete) then delete=1
 ;
@@ -51,4 +60,6 @@
 CHECK_PS_COLOR, file=tmpfile+'_B'+suffix, delete=delete, $
                 color='ff0000'x, /decomposed, expected_rgb=[0,0,255]
 ;
+if KEYWORD_SET(test) then STOP
+;
 end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_qromb.pro gdl/testsuite/test_qromb.pro
--- gdl-0.9.2/testsuite/test_qromb.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_qromb.pro	2012-01-22 15:39:09.000000000 -0700
@@ -0,0 +1,119 @@
+;
+; under GNU GPL v2 or later
+; Alain Coulais, 20-Jan-2012
+; 
+; -------------------------------------------------
+;
+; We compare the output from QROMB with exact velues on
+; well know integrales.
+; We also check that the dimensions of the outputs are OK
+;
+; You can also provide a known function TOTO but also TOTO_INTEGRAL ...
+;
+; -------------------------------------------------
+;
+function SLOPE, x
+return, x
+end
+;
+function SQUARE, x
+return, x*x
+end
+;
+function SLOPE_INTEGRAL, x
+return, 0.5*x*x+1d-3
+end
+;
+function SQUARE_INTEGRAL, x
+return, 1./3.*x*x*x
+end
+;
+; -------------------------------------------------
+;
+pro TEST_QROMB_DIM, function_name=function_name, eps=eps, $
+                    help=help, verbose=verbose, test=test
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro TEST_QROMB_dim, function_name=function_name, eps=eps, $'
+   print, '                    help=help, verbose=verbose, test=test'
+   return
+endif
+;
+; error tolerance
+if (N_ELEMENTS(eps) EQ 0) then eps=1e-5
+nb_errors=0
+;
+; ranges
+;
+a=0.0
+b_1d=1.+findgen(10)
+b_2d=REFORM(b_1d, 2, 5)
+;
+if N_ELEMENTS(function_name) EQ 0 then function_name='SLOPE'
+function_intgrl=function_name+'_INTEGRAL'
+;
+if (EXECUTE('res='+function_name+'(0)') EQ 0) then begin
+   MESSAGE, 'Missing function : '+function_name
+endif
+;
+if (EXECUTE('res='+function_name+'_INTEGRAL(0)') EQ 0) then begin
+   MESSAGE, 'Missing function : '+function_name+'_INTEGRAL'
+endif
+;
+; --- simple cases : one of the 2 inputs is "singleton" element
+;
+resuQR=QROMB(function_name, a, b_1d)
+resuIN=CALL_FUNCTION(function_intgrl,b_1d)-CALL_FUNCTION(function_intgrl,a)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+resuQR=QROMB(function_name, a, b_2d)
+resuIN=CALL_FUNCTION(function_intgrl,b_2d)-CALL_FUNCTION(function_intgrl,a)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+resuQR=QROMB(function_name, b_1d, a)
+resuIN=CALL_FUNCTION(function_intgrl,a)-CALL_FUNCTION(function_intgrl,b_1d)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+resuQR=QROMB(function_name, b_2d, a)
+resuIN=CALL_FUNCTION(function_intgrl,a)-CALL_FUNCTION(function_intgrl,b_2d)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+;
+; --- both inputs are more than one element arrays
+;
+a_1d=replicate(0, 4)
+a_2d=REFORM(a_1d, 2, 2)
+;
+resuQR=QROMB(function_name, a_1d, b_1d)
+resuIN=CALL_FUNCTION(function_intgrl,b_1d)-CALL_FUNCTION(function_intgrl,a_1d)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+resuQR=QROMB(function_name, a_1d, b_2d)
+resuIN=CALL_FUNCTION(function_intgrl,b_2d)-CALL_FUNCTION(function_intgrl,a_1d)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+resuQR=QROMB(function_name, a_2d, b_1d)
+resuIN=CALL_FUNCTION(function_intgrl,b_1d)-CALL_FUNCTION(function_intgrl,a_2d)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+resuQR=QROMB(function_name, a_2d, b_2d)
+resuIN=CALL_FUNCTION(function_intgrl,b_2d)-CALL_FUNCTION(function_intgrl,a_2d)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+if (nb_errors GT 0) then begin
+    MESSAGE, /continue, STRING(nb_errors)+' Errors founded'
+    if ~KEYWORD_SET(test) then EXIT, status=1
+endif else begin
+    MESSAGE, /continue, 'function '+function_name+' : No Errors founded'
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+pro TEST_QROMB
+;
+TEST_QROMB_DIM, function_name='SLOPE'
+TEST_QROMB_DIM, function_name='SQUARE'
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_qromo.pro gdl/testsuite/test_qromo.pro
--- gdl-0.9.2/testsuite/test_qromo.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_qromo.pro	2012-06-19 04:17:43.000000000 -0600
@@ -0,0 +1,167 @@
+;
+; under GNU GPL v2 or later
+; Alain Coulais, 20-Jan-2012
+; Mathieu Pinter, 12-June-2012
+; 
+; -------------------------------------------------
+;
+; We compare the output from QROMO with exact values on
+; well know integrales.
+; We also check that the dimensions of the outputs are OK
+;
+; You can also provide a known function TOTO but also TOTO_INTEGRAL ...
+; -------------------------------------------------
+;
+; http://www.mathcurve.com/courbes2d/agnesi/agnesi.shtml
+function AGNESI_SQUARE, x
+common agnesi_param, a
+return, (a^3/(a^2+x^2))^2
+end
+;
+pro TEST_QROMO_ON_AGNESI, cumul=cumul, no_exit=no_exit, test=test, verbose=verbose
+;
+common agnesi_param, a
+;
+a=1.
+debut=2.0
+fin=1.
+fin2=12.
+;
+expected1=0.031382
+expected2=0.6427
+expected3=0.14251
+;
+comp1=QROMO('AGNESI_SQUARE', debut, /MIDEXP)
+comp2=QROMO('AGNESI_SQUARE', 0, fin)
+comp3=QROMO('AGNESI_SQUARE', fin, fin2)
+;
+eps=1e-3
+;
+nb_errors=0
+if (ABS(expected1-comp1) GT eps) then nb_errors=nb_errors+1
+if (ABS(expected2-comp2) GT eps) then nb_errors=nb_errors+1
+if (ABS(expected3-comp3) GT eps) then nb_errors=nb_errors+1
+;
+if KEYWORD_SET(verbose) then begin
+    print, 'AGNESI_SQUARE espec/comp/err: ', expected1, comp1, expected1-comp1
+    print, 'AGNESI_SQUARE espec/comp/err: ', expected2, comp2, expected2-comp2
+    print, 'AGNESI_SQUARE espec/comp/err: ', expected3, comp3, expected3-comp3
+endif
+;
+if (nb_errors GT 0) then begin
+    MESSAGE, /continue, STRING(nb_errors)+' Numerical Errors founded'
+endif else begin
+    MESSAGE, /continue, 'No Numerical Errors founded'
+endelse
+;
+if (nb_errors GT 0) AND ~KEYWORD_SET(no_exit) then EXIT, status=1
+;
+if ARG_PRESENT(cumul) then begin
+    if KEYWORD_SET(cumul) then cumul=cumul+nb_errors else cumul=nb_errors
+endif
+;
+if KEYWORD_set(test) then STOP
+;
+end
+;
+; -------------------------------
+;
+function EXPON, x
+return, exp(-x)
+end
+;
+function EXPON_INTEGRAL, x
+return, -exp(-x)
+end
+;
+function INV, x
+return, 1/(1+x^2)+exp(-x)
+end
+;
+function INV_INTEGRAL, x
+return, atan(x)-exp(-x)
+end
+;
+; -------------------------------
+;
+pro TEST_QROMO_DIM, function_name=function_name, cumul=cumul, $
+                    no_exit=no_exit, test=test, verbose=verbose
+;
+debut=1.0
+fin=2.0
+infini=1.0e30
+;
+if (N_ELEMENTS(eps) EQ 0) then eps=1e-6
+nb_errors=0
+;
+resuQR=QROMO(function_name, debut, fin, JMAX=7)
+resuIN=CALL_FUNCTION(function_name+'_INTEGRAL', fin)-CALL_FUNCTION(function_name+'_INTEGRAL', debut)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+resuQR=QROMO(function_name, debut, fin, /MIDPNT)
+resuIN=CALL_FUNCTION(function_name+'_INTEGRAL', fin)-CALL_FUNCTION(function_name+'_INTEGRAL', debut)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+resuQR=QROMO(function_name, debut, /MIDEXP)
+resuIN=CALL_FUNCTION(function_name+'_INTEGRAL', infini)-CALL_FUNCTION(function_name+'_INTEGRAL', debut)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+resuQR=QROMO(function_name, debut, fin, /DOUBLE)
+resuIN=CALL_FUNCTION(function_name+'_INTEGRAL', fin)-CALL_FUNCTION(function_name+'_INTEGRAL', debut)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+resuQR=QROMO(function_name, debut, /MIDEXP, EPS=1e-13)
+resuIN=CALL_FUNCTION(function_name+'_INTEGRAL', infini)-CALL_FUNCTION(function_name+'_INTEGRAL', debut)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+resuQR=QROMO(function_name, debut, fin, /MIDINF)
+resuIN=CALL_FUNCTION(function_name+'_INTEGRAL', fin)-CALL_FUNCTION(function_name+'_INTEGRAL', debut)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+resuQR=QROMO(function_name, debut, fin, /MIDSQL)
+resuIN=CALL_FUNCTION(function_name+'_INTEGRAL', fin)-CALL_FUNCTION(function_name+'_INTEGRAL', debut)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+resuQR=QROMO(function_name, debut, fin, /MIDSQU)
+resuIN=CALL_FUNCTION(function_name+'_INTEGRAL', fin)-CALL_FUNCTION(function_name+'_INTEGRAL', debut)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+resuQR=QROMO(function_name, debut, fin, K=6)
+resuIN=CALL_FUNCTION(function_name+'_INTEGRAL', fin)-CALL_FUNCTION(function_name+'_INTEGRAL', debut)
+if TOTAL((resuQR-resuIN)^2) GT eps then nb_errors=nb_errors+1
+;
+if (nb_errors GT 0) then begin
+    MESSAGE, /continue, STRING(nb_errors)+' Errors founded'
+endif else begin
+    MESSAGE, /continue, 'function ' + function_name + ': No Errors founded'
+endelse
+;
+if (nb_errors GT 0) AND ~KEYWORD_SET(no_exit) then EXIT, status=1
+;
+if ARG_PRESENT(cumul) then begin
+    if KEYWORD_SET(cumeul) then cumul=cumul+nb_errors else cumul=nb_errors
+endif
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; ----------------------------------
+;
+pro TEST_QROMO
+;
+cumul=0
+;
+TEST_QROMO_DIM, function_name='EXPON', cumul=cumul, /no_exit
+TEST_QROMO_DIM, function_name='INV', cumul=cumul, /no_exit
+;
+TEST_QROMO_ON_AGNESI, cumul=cumul, /no_exit
+;
+if (cumul GT 0) then begin
+    MESSAGE, /continue, STRING(cumul)+' Errors founded'
+    EXIT, status=1
+endif else begin
+    MESSAGE, /continue, 'No Errors founded'
+endelse
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_random.pro gdl/testsuite/test_random.pro
--- gdl-0.9.2/testsuite/test_random.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_random.pro	2012-04-13 15:10:27.000000000 -0600
@@ -0,0 +1,68 @@
+;
+; Alain Coulais, 5 Janvier 2011, under GNU GPL v2 or later
+;
+; few tests can help to check whether the
+; computations are in good range or not
+;
+; ---------------------------------------
+;
+pro RANDOM_GAMMA
+;
+window, 1
+;
+PLOT, HISTOGRAM(RANDOMN(SEED, 20000, gamma=1), BINSIZE=0.1)
+OPLOT, HISTOGRAM(RANDOMN(SEED, 20000, gamma=2), BINSIZE=0.1)
+OPLOT, HISTOGRAM(RANDOMN(SEED, 20000, gamma=3), BINSIZE=0.1)
+OPLOT, HISTOGRAM(RANDOMN(SEED, 20000, gamma=4), BINSIZE=0.1)
+;
+end
+;
+; ------------------------------------------
+;
+; Idea: when the number is big enough, mean value
+; of the realization should be close to the "value".
+; If computation is wrong (e.g. calling bad noise, algo),
+; we can expect not to have goor prediction ;-)
+; (and this test fails "often" when NPB =< 100)
+;
+pro RANDOM_BINOMIAL, nbp=nbp, amplitude=amplitude, $
+                     verbose=verbose, test=test
+;
+if ~KEYWORD_SET(nbp) then nbp=10000
+if ~KEYWORD_SET(amplitude) then amplitude=10.
+;
+values=[0.10,0.25,0.50,0.75,0.90]
+error=0
+;
+if KEYWORD_SET(verbose) then begin
+   print, format='(6A12)', ['Amplitude', 'values', 'expected', 'Mean', 'disp.', 'Error']
+endif
+for ii=0, N_ELEMENTS(values)-1 do begin
+   resu=RANDOMU(seed, nbp, BINOMIAL=[amplitude,values[ii]])
+   dispersion=ABS(MEAN(resu)-amplitude*values[ii])
+   if (dispersion GT amplitude/100.) then error=error+1
+   if KEYWORD_SET(verbose) then begin
+      print, format='(5f12,6x,I1.1)', amplitude, values[ii], $
+             amplitude*values[ii], MEAN(resu), dispersion,  (dispersion GT amplitude/100.)
+   endif
+   ;;
+endfor
+;
+if KEYWORD_SET(test) then stop
+;
+if (error GT 0) then EXIT, status=1
+;
+end
+;
+; ------------------------------------------
+; extensions welcome
+;
+pro TEST_RANDOM
+;
+RANDOM_GAMMA
+RANDOM_BINOMIAL, ampl=1.
+RANDOM_BINOMIAL, ampl=10.
+RANDOM_BINOMIAL, ampl=100.
+;
+end
+
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test-read_ascii.pro gdl/testsuite/test-read_ascii.pro
--- gdl-0.9.2/testsuite/test-read_ascii.pro	2011-06-07 10:45:42.000000000 -0600
+++ gdl/testsuite/test-read_ascii.pro	2011-11-15 17:49:34.000000000 -0700
@@ -1,14 +1,14 @@
 ;
 ; Script : test-read_ascii
 ;
-pro TEST_READ_ASCII
+pro TEST_READ_ASCII, test=test
 ;
 ;; we need a way to know whether IDL or GDL is running...
 DEFSYSV, '!gdl', exists=isGDL
 filename = (isGDL?'gdl':'idl'+strtrim(!version.release,1))+$
            '-test-read_ascii.txt'
-journal, filename
-
+JOURNAL, filename
+;
 ;;------------------------------------------------------------------------------
 ;; IDL 6.0 hangs on this one
 print
@@ -18,7 +18,7 @@
      fieldtypes : [7, 4, 7, 2, 1, 5], fieldgroups : [0, 1, 2, 3, 4, 5], $
      fieldcount: 6, fieldlocations:[0, 5, 9, 11, 14, 16], datastart:0, $
      delimiter:'', missingvalue:'NaN', commentsymbol:';'}
-a = read_ascii('test-read_ascii.txt', template=t, header=header, data_start=2, count=count)
+a = READ_ASCII('test-read_ascii.txt', template=t, header=header, data_start=2, count=count)
 help, header, count
 help, a, /structure
 print, a.fa, a.fb, a.fc, a.fd, a.fe, a.ff
@@ -32,7 +32,7 @@
      fieldtypes : [7, 4, 7, 2, 1, 5], fieldgroups : [0, 1, 2, 3, 4, 5], $
      fieldcount: 6, fieldlocations:[0, 5, 9, 11, 14, 16], datastart:0, $
      delimiter:'', missingvalue:!values.f_nan, commentsymbol:';'}
-a = read_ascii('test-read_ascii.txt', template=t, header=header, data_start=2, count=count)
+a = READ_ASCII('test-read_ascii.txt', template=t, header=header, data_start=2, count=count)
 help, count, header
 for i=0, n_elements(header)-1 do print, header[i]
 
@@ -47,7 +47,7 @@
      fieldtypes : [7, 4, 7, 2, 1, 5], fieldgroups : [0, 1, 2, 3, 4, 5], $
      fieldcount: 6, fieldlocations:[0, 5, 9, 11, 14, 16], datastart:0, $
      delimiter:'', missingvalue:-999, commentsymbol:';'}
-a = read_ascii('test-read_ascii.txt', template=t, header=header, data_start=2, count=count)
+a = READ_ASCII('test-read_ascii.txt', template=t, header=header, data_start=2, count=count)
 help, a, /structure
 print, a.fa, a.fb, a.fc, a.fd, a.fe, a.ff
 
@@ -60,8 +60,8 @@
      fieldtypes : [7, 4, 7, 2, 1, 5], fieldgroups : [15, 1, 2, 1, 0, 1], $
      fieldcount: 6, fieldlocations:[0, 5, 9, 11, 14, 16], datastart:0, $
      delimiter:'', missingvalue:-999, commentsymbol:';'}
-a = read_ascii('test-read_ascii.txt', template=t, header=header, data_start=2, count=count)
-hs, a
+a = READ_ASCII('test-read_ascii.txt', template=t, header=header, data_start=2, count=count)
+help, a, /structure
 print, a.fa, a.fb, a.fc, a.fe
 
 ;;------------------------------------------------------------------------------
@@ -71,11 +71,15 @@
 ;; IDL bug: type of group "1" should be string
 goto, skip2
 t.fieldtypes  = [7 , 7, 7, 2, 1, 5]
-a = read_ascii('test-read_ascii.txt', template=t, header=header, data_start=2, count=count)
-hs, a
+a = READ_ASCII('test-read_ascii.txt', template=t, header=header, data_start=2, count=count)
+help, a, /structure
 print, a.fa, a.fb, a.fc, a.fe
 skip2:
+;
+;;------------------------------------------------------------------------------
+;
+if KEYWORD_SET(test) then STOP
 
-journal
+JOURNAL
 
 end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_read_jpeg.pro gdl/testsuite/test_read_jpeg.pro
--- gdl-0.9.2/testsuite/test_read_jpeg.pro	2010-04-14 09:07:58.000000000 -0600
+++ gdl/testsuite/test_read_jpeg.pro	2012-01-24 02:11:39.000000000 -0700
@@ -6,8 +6,9 @@
 ; What is tested ?
 ; -- reading back a small (600x259) JPEG image
 ; -- using well positions index in TVSCL
+; -- reading a color image in Grayscale ... (09/11/2011)
 ;
-pro TEST_READ_JPEG, filename=filename, path=path, $
+pro TEST_READ_JPEG, filename=filename, path=path, factor=factor, $
                     help=help, test=test, debug=debug, verbose=verbose
 ;
 if KEYWORD_SET(help) then begin
@@ -22,8 +23,11 @@
 if N_ELEMENTS(path) EQ 0 then path=!path
 if N_ELEMENTS(filename) EQ 0 then filename='Saturn.jpg'
 ;
-title0='the 3 channels in greyscale'
+if N_ELEMENTS(factor) EQ 0 then factor=1
+;
+title0='the 3 channels in Grayscale'
 title1='<<'+filename+'>> in Colors'
+title2='read in Grayscale only'
 ;
 liste_of_files=FILE_SEARCH(STRSPLIT(path,':',/ex),filename)
 ;
@@ -103,6 +107,13 @@
 WINDOW, 1, xsize=xy_win1[0], ysize=xy_win1[1], title=title1
 TVSCL, image, /true
 ;
+; is the /Grayscale keyword OK ?
+;
+READ_JPEG, one_file_and_path, image_gray, /GRAY
+WINDOW, 2, xsize=xy_win1[0], ysize=xy_win1[1], title=title2
+image_gray=REBIN(image_gray[0:xy_win1[0]*factor-1,0:xy_win1[1]*factor-1],xy_win1[0],xy_win1[1])
+TVSCL, image_gray
+;
 if KEYWORD_SET(test) then STOP
 ;
 end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_read_standard_images.pro gdl/testsuite/test_read_standard_images.pro
--- gdl-0.9.2/testsuite/test_read_standard_images.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_read_standard_images.pro	2012-05-09 18:10:52.000000000 -0600
@@ -0,0 +1,435 @@
+;
+; AC, 5-Feb-2012
+;
+; Revisited on May 2012, after I realized that ImageMagick is not
+; reliable (different results with various lib. versions OR different
+; OS).
+;
+; GOAL : the goal of this program is to quickly check
+; that reading and displaying known images (JPEG and PNG) is OK
+; We used images available on the WEB, on Wikipedia;
+; if not on Hard Drive, automatic download available.
+;
+; Consistancy checks (md5 sum and expected values) hardcoded
+;
+; The test cases in this code can easily be extended.
+;
+; HISTORY: based on exchanges on 
+; https://sourceforge.net/projects/gnudatalanguage/forums/forum/338692/topic/4992595/index/page/1
+;
+; -----------------------------------------------------------
+;
+pro PRINT_INFO_IMAGE_STRUCTURE, images, noheader=noheader
+;
+nb_images=N_ELEMENTS(images)
+if nb_images EQ 0 then begin
+   MESSAGE,/continue, 'No Image provided !'
+   return
+endif
+;
+myformat1="(A40,a3,a6,a3,a6,a3,a12,a3,a6,a3,a6,a3,a5,a3)"
+myformat2="(A40,a3,a6,a3,a6,a3,a12,a3,i6,a3,i6,a3,i5,a3)"
+sep=' | '
+;
+if ~KEYWORD_SET(no_header) then begin
+   print, format=myformat1, 'name', sep, 'format', sep, $
+          'class', sep, 'type', sep, 'matte', sep,$
+          'pal.', sep, 'chan.', sep
+endif
+;
+for ii=0, nb_images-1 do begin
+   print, format=myformat2, images[ii].name, sep, images[ii].format, sep, $
+          images[ii].class, sep,$
+          images[ii].type, sep, images[ii].matte, sep, $
+          images[ii].has_palette, sep, images[ii].channels, sep
+endfor
+;
+end
+;
+; -----------------------------------------------------------
+;
+function TEST_DOWNLOAD_TOOLS, verbose=verbose
+;
+wget_ok=0
+SPAWN, 'which wget', res
+if STRLEN(res) GT 0 then begin
+   wget_ok=1
+   script='wget '
+   return, script
+endif
+;
+curl_ok=0
+SPAWN, 'which curl', res
+if STRLEN(res) GT 0 then begin
+   curl_ok=1
+   script='curl -O '
+   return, script
+endif
+;
+if ((wget_ok EQ 0) AND (curl_ok EQ 0)) then begin
+   MESSAGE, /continue, 'No download tool (wget, curl) found'
+   MESSAGE, /continue, 'If need you can download by hand or add one of those tools'
+   STOP
+endif
+;
+end
+;
+; -----------------------------------------------------------
+;
+pro CHECK_MD5_OF_IMAGES, images, test=test, verbose=verbose
+;
+list_of_names=images.name
+list_of_md5=images.md5
+;
+md5cmd=''
+if STRLOWCASE(!version.os_name) eq 'linux' then md5cmd='md5sum '
+if STRLOWCASE(!version.os_name) eq 'darwin' then  md5cmd='md5 -r '
+;
+if (STRLEN(md5cmd) EQ 0) then begin
+   MESSAGE, /cont, 'MD5 command not known for your system: '+!version.os_name
+   MESSAGE, /cont, 'please contribute, no test done.'
+   return
+endif
+;
+md5lenght=32
+
+for ii=0, N_ELEMENTS(list_of_names)-1 do begin
+   SPAWN, md5cmd+list_of_names[ii], result, error
+   subresult=STRMID(result,0, 32)
+   if (subresult NE list_of_md5[ii]) then begin
+      MESSAGE,/cont, 'MD5 checksum error for image : '+list_of_names[ii]
+   endif else begin
+      if KEYWORD_SET(verbose) then $
+         print, 'MD5 checksum OK for image : '+list_of_names[ii]
+   endelse
+endfor
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+; -----------------------------------------------------------
+;
+pro GET_IMAGES, images, download=download, $
+                help=help, test=test, verbose=verbose
+;
+list_of_names=images.name
+links_to_images=images.link
+;
+if KEYWORD_SET(download) then script=TEST_DOWNLOAD_TOOLS()
+;
+nb_images=N_ELEMENTS(list_of_names)
+;
+; first turn: if image is missing and we ask for download, we try to download
+;
+for ii=0, nb_images-1 do begin
+   flag=QUERY_IMAGE(list_of_names[ii])
+   if (flag EQ 0) then begin
+      print, 'Missing Image : ', list_of_names[ii]
+      if KEYWORD_SET(download) then begin
+         SPAWN, script+links_to_images[ii]
+      endif
+   endif
+endfor
+;
+; second turn: if image is missing, we remove it from list
+;
+liste_OK=REPLICATE(1, nb_images)
+;
+for ii=0, nb_images-1 do begin
+   flag=QUERY_IMAGE(list_of_names[ii])
+   if (flag EQ 0) then liste_OK[ii]=0
+endfor
+;
+ok=WHERE(liste_OK EQ 1, nb_ok)
+if (nb_ok EQ 0) then begin
+   MESSAGE, /continue, 'No image found'
+   MESSAGE, /continue, '(First time, please use keyword /Download !)'
+   EXIT, status=77
+endif
+if (nb_ok LT nb_images) then begin
+   MESSAGE, /continue, 'Expected '+STRING(nb_images)+' images'
+   MESSAGE, /continue, 'Only '+STRING(nb_ok)+' images really available'
+endif
+;
+; we remove the missing images
+;
+images=images[OK]
+;
+if KEYWORD_SET(verbose) then begin
+   print, STRCOMPRESS(STRING(N_ELEMENTS(images))), ' images are really present.'
+   PRINT_INFO_IMAGE_STRUCTURE, images
+endif
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; -----------------------------------------------------------
+;
+; We compare IDL, GDL results through QUERY_IMAGE with expect known
+; results. 
+;
+pro CHECK_IMAGES_CONSISTANCY, images, $
+                              test=test, help=help, verbose=verbose
+;
+nb_images=N_ELEMENTS(images)
+;
+DEFSYSV, '!gdl', exists=is_it_gdl
+;
+; we are not ready for all GDL tests ...
+is_it_gdl=0
+;
+GlobalPB=0
+;
+for ii=0, nb_images-1 do begin
+   ;; "encountered problems" increments ...
+   pb=0
+   ;;
+   if KEYWORD_SET(verbose) then begin
+      print, '---------------------'
+      print, '* Checking image : ', images[ii].name
+   endif
+   ;; when we call GDL version, we have extra hidden info to check
+   ;; whether GraphicMagick OR ImageMagick work as expected
+   ;;
+   if (is_it_gdl EQ 1) then begin
+      flag=QUERY_IMAGE(images[ii].name, info, gdl_extra_info)
+   endif else begin
+      flag=QUERY_IMAGE(images[ii].name, info)
+   endelse
+   ;; do we have a file ?
+   if (flag EQ 1) then begin
+      if KEYWORD_SET(verbose) then begin
+         print, '* Processing image : ', images[ii].name
+         ;HELP,/struct, info
+      endif
+      if images[ii].format NE info.type then begin
+         if KEYWORD_SET(verbose) then print, '  --> pb within Type/Format'
+         pb=pb+1
+      endif
+            if images[ii].has_palette NE info.has_palette then begin
+         if KEYWORD_SET(verbose) then print, '  --> pb within Has_Palette'
+         pb=pb+1
+      endif
+      if images[ii].channels NE info.channels then begin
+         if KEYWORD_SET(verbose) then print, '  --> pb within Channels number'
+         pb=pb+1
+      endif
+      if (is_it_gdl EQ 1) then begin
+         print, 'this is not ready'
+      endif
+      if (pb EQ 0) then print, '  --> OK !'
+   endif else begin
+      MESSAGE, /continue, 'Missing file : '+images[ii].name
+   endelse
+   ;;
+   if pb GT 0 then GlobalPB=GlobalPB+1
+endfor
+;
+if (GlobalPB GT 0) then begin
+   MESSAGE, /continue, 'Number of Images giving problems : '+STRING(GlobalPB)   
+endif
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+; -----------------------------------------------------------
+;
+; a definition list of "type" can be found here:
+; http://www.graphicsmagick.org/Magick++/Image.html#type
+;
+pro SET_IMAGES_NAMES, images, test=test, help=help, verbose=verbose
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro SET_IMAGES_NAMES, images, test=test, help=help, verbose=verbose'
+endif
+;
+pref0='http://upload.wikimedia.org/wikipedia/commons/'
+pref='http://upload.wikimedia.org/wikipedia/commons/thumb/'
+;
+; IDL 6.0 and 7.1 gave same results on those test images
+;
+nb_images=6
+;
+; Proporties for a given image. 
+; When Matte ==1, we have transparency (1+1, 3+1 ...)
+image={name: '', link:'', md5:'', format:'', $
+       class: 'No', type:'No', matte: 0, has_palette:0, channels:0}
+images=REPLICATE(image,nb_images)
+;
+ii=0
+images[ii].link=pref+'9/94/Lubinus_Duchy_of_Pomerania_Map_1618_monocromatic.jpg/640px-Lubinus_Duchy_of_Pomerania_Map_1618_monocromatic.jpg'
+images[ii].md5='fe5184f2149460470752e942321dcc8c'
+images[ii].format='JPEG'
+images[ii].class='PseudoClass'
+images[ii].type='GrayScale'
+images[ii].matte=0
+images[ii].has_palette=0
+images[ii].channels=1
+;
+ii=ii+1
+images[ii].link=pref+'4/41/European_Alps.jpg/615px-European_Alps.jpg'
+images[ii].md5='37288476231f29b7d54412dce4922999'
+images[ii].format='JPEG'
+images[ii].class='DirectClass'
+images[ii].type='TrueColor'
+images[ii].matte=0
+images[ii].has_palette=0
+images[ii].channels=3
+;
+ii=ii+1
+images[ii].link=pref0+'c/cf/Indexed_palette.png'
+images[ii].md5='769fde91867799febf633942c1a07960'
+images[ii].format='PNG'
+images[ii].class='PseudoClass'
+images[ii].type='Palette'
+images[ii].matte=0
+images[ii].has_palette=1
+images[ii].channels=1
+;
+ii=ii+1
+images[ii].link=pref+'4/44/Lavandula_spica_monochrome.png/589px-Lavandula_spica_monochrome.png'
+images[ii].md5='2044b4ee7a0f34083cf1bd5a416e6ae5'
+images[ii].format='PNG'
+images[ii].class='PseudoClass'
+; one special case : see as 'grayscale' by Graphics Magick, but
+; matte==1 and 2 channels ...
+images[ii].type='GrayScaleMatte'
+images[ii].matte=1
+images[ii].has_palette=0
+images[ii].channels=2
+;
+ii=ii+1
+images[ii].link=pref+'2/27/Kafa_gnu.png/432px-Kafa_gnu.png'
+images[ii].md5='9865555b28a3013a378edbdd6f03b4ef'
+images[ii].format='PNG'
+images[ii].class='DirectClass'
+images[ii].type='TrueColor'
+images[ii].matte=0
+images[ii].has_palette=0
+images[ii].channels=3
+;
+ii=ii+1
+images[ii].link=pref+'6/64/Gnu_meditate_levitate.png/553px-Gnu_meditate_levitate.png'
+images[ii].md5='496bfa9eb810bd76124d59cfb1e8abe6'
+images[ii].format='PNG'
+images[ii].class='DirectClass'
+images[ii].type='TrueColorMatte'
+images[ii].matte=1
+images[ii].has_palette=0
+images[ii].channels=4
+;
+fins=STRPOS(images.link,'/',/reverse_search)
+list_of_names=STRARR(nb_images)
+for ii=0, nb_images-1 do begin
+   list_of_names[ii]=STRMID(images[ii].link,fins[ii]+1)
+endfor
+images.name=list_of_names
+;
+if KEYWORD_SET(verbose) then begin
+   print, STRCOMPRESS(STRING(nb_images)), ' images have been initialized:'
+   PRINT_INFO_IMAGE_STRUCTURE, images
+endif
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; -----------------------------------------------------------
+;
+pro TEST_READ_STANDARD_IMAGES, download=download, delais=delais, $
+                               verbose=verbose, $
+                               test=test, help=help, debug=debug
+;
+DEVICE, decomposed=0
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro TEST_READ_STANDARD_IMAGES, download=download, delais=delais, $'
+   print, '                               verbose=verbose, $'
+   print, '                               test=test, help=help'
+   return
+endif
+;
+; when delais > 0, we close just after
+if N_ELEMENTS(delais) EQ 0 then delais=1
+;
+; when download > 0, we will try to download missing images
+if N_ELEMENTS(download) EQ 0 then download=1
+;
+; set a (extensible) list of images (name, external link, properties)
+SET_IMAGES_NAMES, images, verbose=verbose
+;
+; verify is images are around or trying to download.
+; Number of images may change here
+GET_IMAGES, images, download=download, verbose=verbose
+;
+; here we check we are processing the images we expect to process !!
+CHECK_MD5_OF_IMAGES, images, verbose=verbose
+;
+; Here we check that the know properties of images are in agreement
+; with what is extracted from QUERY_IMAGE(image_name, image_info)
+CHECK_IMAGES_CONSISTANCY, images, verbose=verbose
+;
+; after that, we will try to display the images ...
+;
+nb_images=N_ELEMENTS(images)
+list_of_names=images.name
+;
+if KEYWORD_SET(debug) then STOP
+;
+nb_images=N_ELEMENTS(list_of_names)
+;
+for ii=0, nb_images-1 do begin
+   flag=QUERY_IMAGE(list_of_names[ii], info)
+   if (flag EQ 1) then begin
+      if KEYWORD_SET(verbose) then begin
+         print, 'Processing image : ', list_of_names[ii]
+         HELP,/struct, info
+      endif
+      ;; managing the dedicated window
+      titre=info.type+' : '+list_of_names[ii]
+      WINDOW, ii, title=titre, $
+              xsize=info.dimensions[0], ysize=info.dimensions[1]
+      ;;
+      ;; reading with the rigth function
+      ;;
+      ;; JPEG (only two cases known today)
+      ;;
+      if (info.type EQ 'JPEG') then begin
+         READ_JPEG, list_of_names[ii], image
+         if (info.channels EQ 1) then begin
+            LOADCT, 0
+            TV, image
+         endif
+         if (info.channels EQ 3) then TV, image, /true
+      endif
+      ;;
+      ;; PNG
+      ;;
+      if (info.type EQ 'PNG') then begin
+         if (info.HAS_PALETTE EQ 1) then begin
+            READ_PNG, list_of_names[ii], image, r, g, b
+            TVLCT, r, g, b           
+         endif else begin
+            READ_PNG, list_of_names[ii], image
+         endelse
+         if (info.channels EQ 1) then TV, image
+         if (info.channels EQ 2) then begin
+            loadct, 0
+            TV, image[0,*,*]
+         endif
+         if (info.channels EQ 3) then TV, image, /true
+         if (info.channels EQ 4) then TV, image[0:2,*,*], /true
+      endif
+      if (delais GT 0) then begin
+         WAIT, delais
+         WDELETE, ii
+      endif
+   endif else begin
+      MESSAGE, /Continue, 'Missing image : '+list_of_names[ii]
+   endelse
+endfor
+;
+if KEYWORD_SET(test) then STOP
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_smooth.pro gdl/testsuite/test_smooth.pro
--- gdl-0.9.2/testsuite/test_smooth.pro	2006-10-05 17:42:30.000000000 -0600
+++ gdl/testsuite/test_smooth.pro	2012-05-08 03:48:44.000000000 -0600
@@ -1,9 +1,112 @@
 ;
-; ARSC 13/07/2006
-; some tests for SMOOTH
+; under GNU GPL v2 or later
+;
+; Important remark: this code is not ready for inclusion in Regression
+; Tests (make check) Help welcome.
+;
+; Alain Coulais
+; Initial version 13/07/2006, only some basic fonctional tests for SMOOTH
+;
+; Extended on 7 May 2012 for testing new algo and time
+;
+; Just testing if new algo for SMOOTH is well scaled
+; and errors did not diverge
+; 
+; A way to test the patch and also that a new algo
+; did not change the outputs values too much ...
+;
+; If a third algo will be provided, we have to  manage "/slow"
+; and put it as param ...
+;
+; -----------------------------------------------
+;
+pro Internal_Calcul, array, window, times, error, $
+                     test=test, verbose=verbose
+;
+times=FLTARR(2)
+;
+t0=SYSTIME(1)
+r1=SMOOTH(array,window,/slow)
+times[0]=SYSTIME(1)-t0
+
+t0=systime(1)
+r2=SMOOTH(array,window)
+times[1]=systime(1)-t0
+
+error=SQRT(TOTAL((r1-r2)^2))
+if KEYWORD_SET(verbose) then begin
+   print, 'kernel ', window, ': ', times, ', Error :', error
+endif
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; -----------------------------------------------
+;
+pro TEST_TIME_SMOOTH, testcase, nbpX=nbpX, nbpY=nbpY, $
+                      test=test, help=help, verbose=verbose
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro TEST_TIME_SMOOTH, testcase, nbpX=nbpX, nbpX=nbpX, $'
+   print, '                      test=test, help=help, verbose=verbose'
+   return
+endif
+;
+if N_PARAMS() EQ 0 then testcase=0
+;
+if ~KEYWORD_SET(nbpX) then nbpX=1024
+if ~KEYWORD_SET(nbpY) then nbpY=nbpX
+;
+max_testcase=4
+if testcase EQ 0 then test_array=DIST(nbpX)
+if testcase EQ 1 then test_array=RANDOMU(seed, nbpX, nbpY)
+if testcase EQ 2 then test_array=RANDOMU(seed, nbpX)
+if testcase EQ 3 then test_array=REPLICATE(1.,nbpX, nbpY)
+if testcase EQ 4 then test_array=REPLICATE(1.,nbpX)
+;
+if testcase LT 0 OR testcase GT max_testcase then MESSAGE, 'bad testcase ...'
+;
+kernels=[3,5,7,9,15,21,31,41,51]
+nb_kernels=N_ELEMENTS(kernels)
+alltimes=FLTARR(2,nb_kernels)
+allerrors=FLTARR(nb_kernels)
+;
+for ii=0, nb_kernels-1 do begin
+   Internal_Calcul, test_array, kernels[ii] , times, error, verbose=verbose
+   alltimes[*,ii]=times
+   allerrors[ii]=error
+endfor
+;
+WINDOW, 0
+PLOT, kernels, alltimes[0,*], psym=-2, linestyle=1, $
+      xtitle='kernel size', ytitle='time (s)'
+OPLOT, kernels, alltimes[1,*], psym=-4, linestyle=4
+; legend
+xpos=[0.05, 0.2, 0.25]*!x.crange[1]
+ypos=[0.9, 0.9]*!y.crange[1]
+OPLOT, xpos[0:1], ypos, psym=-2, linestyle=1
+XYOUTS, xpos[2], ypos, 'Old Slow Ref'
+ypos=[0.8, 0.8]*!y.crange[1]
+OPLOT, xpos[0:1], ypos, psym=-4, linestyle=4
+XYOUTS, xpos[2], ypos, 'New faster'
+;
+WINDOW, 1
+PLOT, kernels, allerrors, psym=-2, linestyle=2, $
+      xtitle='kernel size', ytitle='time (s)'
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; -----------------------------------------------
 ;
 pro TEST_SMOOTH, nbp=nbp
 ;
+print, 'No clear test defined now'
+print, 'Only Time Test between two versions ...'
+print, 'Help welcome !'
+;
 if (N_ELEMENTS(nbp) EQ 0) then nbp=9
 ;
 ; extra check specific for GDL
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_standardize.pro gdl/testsuite/test_standardize.pro
--- gdl-0.9.2/testsuite/test_standardize.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_standardize.pro	2012-05-14 08:22:35.000000000 -0600
@@ -0,0 +1,99 @@
+;
+; Alain Coulais, 13 May 2012, under GNU GPL v2 or later
+;
+; a very basic test for STANDARDIZE
+;
+; after STANDARDIZE, we check that:
+; -- values in first column are very close to Zero
+; -- values in second column are very close to One
+; -- values in third and fourth column are close to initial values
+;
+pro TEST_STANDARDIZE, liste_var, nb_var=nb_var, nb_obs=nb_obs, $
+                      no_exit=no_exit, double=double, $
+                      test=test, help=help, verbose=verbose
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro TEST_STANDARDIZE, liste_var, nb_var=nb_var, nb_obs=nb_obs, $'
+    print, '                      no_exit=no_exit, double=double, $'
+    print, '                      test=test, help=help, verbose=verbose'
+    return
+endif
+;
+if N_PARAMS() EQ 0 then liste_var=[-100., -10., 1e-3, 25., 1e3]
+;
+if N_ELEMENTS(nb_var) EQ 0 then nb_var=N_ELEMENTS(liste_var)
+;
+if N_ELEMENTS(nb_obs) EQ 0 then nb_obs=1000
+;
+data=FLTARR(nb_var,nb_obs)
+;
+for ii=0, nb_var-1 do begin
+   data[ii,*]=REPLICATE(liste_var[ii],nb_obs)+RANDOMN(seed,nb_obs)
+endfor
+;
+; Compute the mean and variance of each variable using the MOMENT   
+; function. The skewness and kurtosis are also computed:
+;
+raw_res=FLTARR(4,nb_var)
+std_res=FLTARR(4,nb_var)
+;
+for ii=0, nb_var-1 do raw_res[*,ii]=MOMENT(data[ii,*])  
+  
+; Compute the standardized variables:  
+std_data = STANDARDIZE(data, double=double)  
+  
+; Compute the mean and variance of each standardized variable using   
+; the MOMENT function. The skewness and kurtosis are also computed:  
+for ii=0, nb_var-1 do std_res[*,ii]=MOMENT(std_data[ii,*])  
+;
+; now we can check the results 
+; (column "0" must be close to 0, column "0" must be equal to 1,
+; other 2 columns should remain the sames)
+;
+total_pb=0
+error=1e-2
+; first column must be close to Zero
+pb=WHERE(ABS(std_res[0,*]) GT error, nb_pb)
+if nb_pb GT 0 then begin
+   if KEYWORD_SET(verbose) then MESSAGE,/continue, 'pb with Zero''s'
+   total_pb=total_pb+nb_pb
+endif
+; second column must be close to One
+pb=WHERE(ABS(std_res[1,*]-1.0) GT error, nb_pb)
+if nb_pb GT 0 then begin
+   if KEYWORD_SET(verbose) then MESSAGE,/continue, 'pb with One''s'
+   total_pb=total_pb+nb_pb
+endif
+; third and fourth columns must remain equal
+pb=WHERE(ABS(std_res[2,*]-raw_res[2,*]) GT error, nb_pb)
+if nb_pb GT 0 then begin
+   if KEYWORD_SET(verbose) then MESSAGE,/continue, 'pb with Two''s'
+   total_pb=total_pb+nb_pb
+endif
+pb=WHERE(ABS(std_res[3,*]-raw_res[3,*]) GT error, nb_pb)
+if nb_pb GT 0 then begin
+   if KEYWORD_SET(verbose) then MESSAGE,/continue, 'pb with Three''s'
+   total_pb=total_pb+nb_pb
+endif
+;
+if KEYWORD_SET(verbose) then begin
+   print, "Stats on input array:"
+   print, raw_res
+   print, "Stats on STANDARDIZEd array:"
+   print, std_res
+endif
+;
+if KEYWORD_SET(test) then STOP
+;
+if (total_pb GT 0) then begin
+    if KEYWORD_SET(no_exit) then begin
+        MESSAGE, /continue, ' tests failed (but base on RANDOMN ...'
+    endif else begin
+        EXIT, status=1
+    endelse
+endif else begin
+    MESSAGE,/continue, 'tests successful'
+endelse
+;
+end
+
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_str_functions.pro gdl/testsuite/test_str_functions.pro
--- gdl-0.9.2/testsuite/test_str_functions.pro	2010-04-16 08:41:32.000000000 -0600
+++ gdl/testsuite/test_str_functions.pro	2011-11-29 04:04:20.000000000 -0700
@@ -3,6 +3,10 @@
 ;
 ; Few basic tests on functions working on Strings
 ;
+; Adding few new tests for STRMID, /reverse was broken but not tested !
+; We really need as exhaustive as possible tests to avoid
+; any unwanted regression, including improbables (e.g. typo in commit !)
+;
 pro TEST_STRMID, exit_on_error=exit_on_error, test=test
 ;
 a='azerty'
@@ -14,11 +18,20 @@
 res=STRMID(a,3)
 if NOT(STRCMP(res,'rty')) then flag_pb=flag_pb+1
 ;
+res=STRMID(a,3,1)
+if NOT(STRCMP(res,'r')) then flag_pb=flag_pb+1
+;
+res=STRMID(a,2,1,/reverse)
+if NOT(STRCMP(res,'r')) then flag_pb=flag_pb+1
+;
+res=STRMID(a,2,/reverse)
+if NOT(STRCMP(res,'rty')) then flag_pb=flag_pb+1
+;
 if flag_pb GT 0 then begin
     MESSAGE, /continue, STRING(flag_pb)+' ERROR(s) found in STRMID'
     if KEYWORD_SET(exit_on_error) then  EXIT, status=1
 endif else begin
-    MESSAGE, /continue, 'No  ERROR found in STRMID'
+    MESSAGE, /continue, 'No ERROR found in STRMID'
 endelse
 ;
 if KEYWORD_SET(test) then STOP
@@ -63,7 +76,7 @@
     MESSAGE, /continue, STRING(flag_pb)+' ERROR(s) found in STRSPLIT'
     if KEYWORD_SET(exit_on_error) then  EXIT, status=1
 endif else begin
-    MESSAGE, /continue, 'No  ERROR found in STRSPLIT'
+    MESSAGE, /continue, 'No ERROR found in STRSPLIT'
 endelse
 ;
 if KEYWORD_SET(test) then STOP
@@ -74,6 +87,9 @@
 ;
 pro TEST_STR_FUNCTIONS
 ;
+; this is bad because tests in TEST_STRSPLIT
+; will not be done if fails in TEST_STRMID ...
+; 
 TEST_STRMID, /exit_on_error
 TEST_STRSPLIT, /exit_on_error
 ;
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_strmatch.pro gdl/testsuite/test_strmatch.pro
--- gdl-0.9.2/testsuite/test_strmatch.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_strmatch.pro	2011-11-22 10:54:38.000000000 -0700
@@ -0,0 +1,45 @@
+; part of GDL - GNU Data Language (GPL)
+; by Sylwester Arabas <slayoo@igf.fuw.edu.pl>
+function assert, str, xpr, bool, fold_case=fold_case
+  if ~keyword_set(fold_case) then fold_case=0
+  if strmatch(str, xpr, fold_case=fold_case) ne bool then begin
+    message, 'strmatch(''' + str + ''', ''' + xpr + ''', fold=' + strtrim(fold_case,2) + ') ne ' + strtrim(bool,2)
+    return, 1
+  endif
+  return, 0
+end
+
+pro test_strmatch
+  err = 0
+  err += assert('gdl', 'gdl', 1)
+  err += assert('gpl', 'gdl', 0)
+  err += assert('gdl', 'gd', 0)
+  err += assert('GDL', 'gdl', 0)
+  err += assert('GDL', 'gdl', 1, /fold)
+  err += assert('GDL', 'gd*', 0)
+  err += assert('GDL', 'gd*', 1, /fold)
+  err += assert('GDL', '*dl', 0)
+  err += assert('GDL', '*dl', 1, /fold)
+  err += assert('GDL', 'g?l', 0)
+  err += assert('GDL', 'g?l', 1, /fold)
+  err += assert('GDL', 'g?', 0)
+  err += assert('GDL', 'g?', 0, /fold)
+  err += assert('GDLGDL', 'GD?G*L', 1)
+  err += assert('GDLGDL', 'G?G*L', 0)
+  err += assert('GDLGDL', '*DL*', 1)
+  err += assert('GDLGDL', '\*DL\*', 0)
+  err += assert('A*DL*A', 'A\*DL\*A', 1)
+  err += assert('A?DL?A', 'A\?DL\?A', 1)
+  err += assert('*DL*', '\*DL\*', 1)
+  err += assert('?DL?', '\?DL\?', 1)
+  err += assert('GDLGDL', '?DL?', 0)
+  err += assert('GDLGDL', 'G[ABCD]LGDL', 1)
+  err += assert('GDLGDL', 'G[!ABCD]LGDL', 0)
+  err += assert('GDLGDL', 'G[A-D]LGDL', 1)
+  err += assert('.()+{}|^$', '.()+{}|^$', 1)
+  err += assert('.()+{}|^$', '.()+{*^$', 1)
+  err += assert('.()+{}|^$', '.()+{?^$', 0)
+  err += assert('foot', 'f??t', 1)
+  err += ~array_equal(strmatch(['gdl', 'GDL'], 'gdl'), [1,0])
+  if err ne 0 then exit, status=1
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_strsplit.pro gdl/testsuite/test_strsplit.pro
--- gdl-0.9.2/testsuite/test_strsplit.pro	2011-08-19 06:38:14.000000000 -0600
+++ gdl/testsuite/test_strsplit.pro	2012-07-11 07:55:34.000000000 -0600
@@ -244,6 +244,27 @@
    nb_pbs=nb_pbs+1
 endif
 ;
+; we must return a STRARR except for ''
+;
+tab=STRSPLIT('eeee','e',/extract)
+if (SIZE(tab, /n_dim) NE 0) then begin
+   if KEYWORD_SET(verbose) then MESSAGE, 'bad size for void string', /continue
+   nb_pbs=nb_pbs+1
+endif
+tab=STRSPLIT('eeABCee','e',/extract)
+if (SIZE(tab, /n_dim) NE 1) then begin
+   if KEYWORD_SET(verbose) then MESSAGE, 'bad size for 1D STRARR', /continue
+   nb_pbs=nb_pbs+1
+endif
+if (tab NE 'ABC') then begin
+   if KEYWORD_SET(verbose) then MESSAGE, 'bad value in STRARR', /continue
+   nb_pbs=nb_pbs+1
+endif
+tab=STRSPLIT('eeABCeeABCee','e',/extract)
+if (SIZE(tab, /n_dim) NE 1) then begin
+   if KEYWORD_SET(verbose) then MESSAGE, 'bad size for 2 elements STRARR', /continue
+   nb_pbs=nb_pbs+1
+endif
 ;
 vide=''
 if (EXECUTE('res=TEXTOIDL(vide)') EQ 0) then begin
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_trisol.pro gdl/testsuite/test_trisol.pro
--- gdl-0.9.2/testsuite/test_trisol.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_trisol.pro	2012-02-03 08:11:48.000000000 -0700
@@ -0,0 +1,62 @@
+;
+; Alain Coulais, 03 Fevrier 2012,
+; under GNU GPL v2 or later
+;
+; basic tests for TRISOL
+;
+pro TEST_TRISOL, double=double, verbose=verbose, $
+                 help=help, test=test, debug=debug
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro TEST_TRISOL, double=double, verbose=verbose, $'
+    print, '                 help=help, test=test, debug=debug'
+    return
+endif
+;
+; Define Sub Diag Vect. containing the sub-diagonal elements
+; with a strarting  0.0 element:  
+subdiag=REPLICATE(1.0,4)*2.
+subdiag[0]=0.0
+;
+; Define "diag" containing the main diagonal elements:  
+diag=REPLICATE(-4.0,4)
+;
+; Define Sup Diag Vect. containing the super-diagonal elements
+; with a trailing  0.0 element:  
+supdiag=REPLICATE(1.0,4)
+supdiag[-1]=0.0
+; 
+; Define the right-hand side vector:  
+RHSvect = [6.0, -8.0, -5.0, 8.0]
+;
+; Compute the solution and print:  
+result = TRISOL(subdiag*1D, diag*1D, supdiag*1D, RHSvect*1D, double=double)
+;result = TRISOL(subdiag, diag, supdiag, RHSvect, double=double)
+PRINT, result
+;
+TheMatrix=DIAG_MATRIX(diag)
+TheMatrix=TheMatrix+DIAG_MATRIX(subdiag[1:*],-1)
+TheMatrix=TheMatrix+DIAG_MATRIX(supdiag[0:-1-1],1)
+if KEYWORD_SET(debug) then begin
+   print, TheMatrix
+endif
+;
+LHSvect=TheMatrix##result
+error=TOTAL((LHSvect-RHSvect)^2)
+;
+if (error GT 1e-10) then begin
+   if KEYWORD_SET(test) then STOP
+   ;; please notice the error may also come from other parts of codes
+   ;; (e.g. bug in DIAG_MATRIX)
+   MESSAGE, /continue, 'Numerical error founded.'
+   EXIT, status=1
+endif else begin
+   if ~KEYWORD_SET(verbose) then begin
+      MESSAGE, /continue, 'TRISOL succesfully tested'
+   endif
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_tvlct.pro gdl/testsuite/test_tvlct.pro
--- gdl-0.9.2/testsuite/test_tvlct.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_tvlct.pro	2012-02-06 02:51:42.000000000 -0700
@@ -0,0 +1,51 @@
+;
+; AC, 05-Feb-2012
+;
+; Testing if TVLCT is working ...
+;
+pro GENERATE_COLORS, nbp, r, g, b
+;
+r=BYTSCL(SIN(FINDGEN(nbp)*!pi/nbp*10))
+g=BYTSCL(SIN(FINDGEN(nbp)*!pi/nbp*30))
+b=BINDGEN(nbp) 
+;
+end
+;
+pro TEST_TVLCT
+;
+; direct switch into True Color mode
+DEVICE, decomposed=0
+;
+nbp=256
+x_pos=10
+y_pos=500
+offset=nbp
+;
+GENERATE_COLORS, nbp, r, g, b
+;
+WINDOW, 0, title='TVLCT, R,G,B', $
+        xpos=x_pos, ypos=y_pos, xsize=nbp, ysize=nbp
+TVLCT, r, g, b
+TV, DIST(nbp)
+;
+; permutation
+WINDOW, 1, title='TVLCT, B,R,G', $
+        xpos=x_pos+offset, ypos=y_pos, xsize=nbp, ysize=nbp
+TVLCT, b, r, g
+TV, DIST(nbp)
+;
+; vectors
+;
+; reset to basic RGB
+WINDOW, 2, title='TVLCT, [R, G, B]', $
+        xpos=x_pos, ypos=y_pos-offset, xsize=nbp, ysize=nbp
+TVLCT, [[r],[g],[b]]
+TV, DIST(nbp)
+;
+; permutation
+WINDOW, 3, title='TVLCT, [B, G, R]', $
+        xpos=x_pos+offset, ypos=y_pos-offset, xsize=nbp, ysize=nbp
+TVLCT, [[b],[r],[g]]
+TV, DIST(nbp)
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_usersym.pro gdl/testsuite/test_usersym.pro
--- gdl-0.9.2/testsuite/test_usersym.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_usersym.pro	2011-11-28 08:54:55.000000000 -0700
@@ -0,0 +1,53 @@
+;
+; Alain Coulais, 28/11/2011
+; Help tracking bug related to USERSYM
+;
+pro INTERNAL_PLOT, nbp, title=title, psym=psym, NaN=NaN
+;
+if N_PARAMS() EQ 0 then nbp=2
+;
+x=FINDGEN(nbp)/nbp
+y=x
+;
+if KEYWORD_SET(NaN) and (nbp GT 4) then begin
+   x[4]=!values.f_nan
+   x[6]=!values.f_nan
+   x[7]=!values.f_nan
+endif
+;
+plot, x,y, psym=psym, xrange=[-1,2], yrange=[-1,2], title=title
+;
+;print, '==========================================='
+;
+end
+;
+; ----------------------------------
+;
+pro TEST_USERSYM, psym=psym, help=help, test=test
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro TEST_USERSYM, psym=psym, help=help, test=test'
+   return
+end
+;
+if N_ELEMENTS(psym) EQ 0 then psym=8
+;
+UserSym, [-1, -0.5, -0.5, 0.5, 0.5, 1, -1], $
+         [-0.7, -0.7, 0.7, 0.7, -0.7, -0.7, -0.7]
+;
+!p.multi=[0,2,2]
+;
+WINDOW, 0, title='Without NaN'
+INTERNAL_PLOT, 1, psym=psym, title='1 point'
+INTERNAL_PLOT, 2, psym=psym, title='2 point'
+INTERNAL_PLOT, 3, psym=psym, title='3 point'
+INTERNAL_PLOT, 12, psym=psym, title='12 point'
+;
+WINDOW, 1, title='With NaN'
+INTERNAL_PLOT, 12, psym=psym, title='12 point', /nan
+;
+!p.multi=0
+;
+if KEYWORD_SET(test) then STOP
+;
+end
diff -ruN --exclude CVS gdl-0.9.2/testsuite/test_zip.pro gdl/testsuite/test_zip.pro
--- gdl-0.9.2/testsuite/test_zip.pro	2010-06-29 03:20:57.000000000 -0600
+++ gdl/testsuite/test_zip.pro	2012-05-14 08:22:35.000000000 -0600
@@ -3,124 +3,216 @@
 ;
 ; Maxime Lenoir, June 2010
 ; under GNU GPL 2 or later
-; 
-pro TEST_ZIP
-
+;
+; AC May 2012:
+; -- clarification (options, Upcases, identations)
+; -- on Linux, "stat --printf=%s " does not work on few systems ...
+;
+; Some commands called using SPAWN may not work. Please submit
+; an alternative via GDL Bug Traker on SourceForge.
+; You can see the cammands used by running /verbose
+;
+; by default, we exit at first pb, maybe to be less strict later
+; --but no problem today with /compress files ...--
+;
+pro CATCH_EXIT, nb_problems, no_exit=no_exit
+;
+if KEYWORD_SET(no_exit) then begin
+   nb_problems=nb_problems+1
+endif else begin
+   EXIT, status=1
+endelse
+end
+;
+; ---------------------------------
+;
+pro TEST_ZIP, no_exit=no_exit, help=help, test=test, verbose=verbose, quiet=quiet
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro TEST_ZIP, no_exit=no_exit, help=help, test=test, verbose=verbose, quiet=quiet'
+   return
+end
+;
+nb_pbs=0
+;
 file='test_zip.gz'
-spawn,'echo -e "GDL - GNU Data Language\nA free IDL (Interactive Data Language) compatible incremental\ncompiler (i. e. runs IDL programs)." | gzip > '+file
-
-openr,fd,file,/get,/compress,/delete
-
-;; Size test (FSTAT)
-if strlowcase(!version.os_name) eq 'linux' then spawn,'stat --printf=%s '+file,s else spawn,'stat -f%z '+file,s
-if (fstat(fd)).size ne s then begin
-	message,/continue,'Bad size returned for zipped file'
-	exit,status=1
-endif
-
+;
+txt='"GDL - GNU Data Language\nA free IDL (Interactive Data Language) compatible incremental\n'
+txt=txt+'compiler (i. e. runs IDL programs)."'
+;
+SPAWN, 'echo -e '+txt+' | gzip > '+file
+OPENR, fd, file, /get, /compress, /delete
+;
+; Size test (FSTAT)
+if STRLOWCASE(!version.os_name) eq 'linux' then begin
+   commande='stat --printf=%s '+file
+   if KEYWORD_SET(verbose) then print, 'commande: ', commande
+   SPAWN, commande, size, error_mess, exit_status=exit_status
+   if (exit_status GT 0) then begin
+      commande='stat -c %s '+file
+      if KEYWORD_SET(verbose) then print, 'commande: ', commande
+      SPAWN, 'stat -c %s '+file, size, error_mess, exit_status=exit_status
+   endif
+endif else begin
+   ;; this is OK on OSX
+   commande='stat -f%z '+file
+   if KEYWORD_SET(verbose) then print, 'commande: ', commande
+   SPAWN, commande, size, error_mess, exit_status=exit_status
+endelse
+;
+if (exit_status GT 0) then begin
+   ;; we skip the test if no result received !
+   MESSAGE, /continue, 'the option used by STAT is not working, please report'
+endif else begin
+   if ((FSTAT(fd)).size ne size) then begin
+      MESSAGE, /continue, 'Bad SIZE returned for zipped file'
+      CATCH_EXIT, nb_pbs, no_exit=no_exit
+   endif
+endelse
+;
 ;; READ TESTS
-
+;
 ; Readf test
+;
 str=''
-readf,fd,str
-spawn,'cat '+file+' | gunzip - | head -1',head1
-if str ne head1 then begin
-	message,/continue,'Readf doesn''t work on zipped file'
-	exit,status=1
-endif
-
-readf,fd,str
-spawn,'cat '+file+' | gunzip - | head -2 | tail -1',head2
-if str ne head2 then begin
-	message,/continue,'Readf doesn''t work twice on zipped file'
-	exit,status=1
-endif
-
-point_lun,fd,0
-readf,fd,str ; At this point, readf works well, so we can test point_lun
-if str ne head1 then begin
-	message,/continue,'Point_lun doesn''t work on zipped file (read mode)'
-	exit,status=1
+READF, fd, str
+;
+commande='cat '+file+' | gunzip - | head -1'
+if KEYWORD_SET(verbose) then print, 'commande: ', commande
+SPAWN, commande, head1
+if (str ne head1) then begin
+   MESSAGE, /continue, 'Readf doesn''t work on zipped file'
+   if ~KEYWORD_SET(no_exit) then EXIT, status=1
+endif
+;
+READF, fd, str
+commande='cat '+file+' | gunzip - | head -2 | tail -1'
+if KEYWORD_SET(verbose) then print, 'commande: ', commande
+SPAWN, commande, head2
+;
+if (str ne head2) then begin
+   MESSAGE, /continue, 'Readf doesn''t work twice on zipped file'
+   CATCH_EXIT, nb_pbs, no_exit=no_exit
 endif
-
+;
+POINT_LUN, fd, 0
+READF, fd, str ; At this point, readf works well, so we can test point_lun
+if (str ne head1) then begin
+   MESSAGE, /continue, 'Point_lun doesn''t work on zipped file (read mode)'
+   CATCH_EXIT, nb_pbs, no_exit=no_exit
+endif
+;
 ; Assoc test
-point_lun,fd,0
-a=assoc(fd,bytarr(5))
-spawn,'cat '+file+' | gunzip - | head -1 | cut -b 1-5',cut15
-if string(a[0]) ne cut15 then begin
-	message,/continue,'Assoc doesn''t work on zipped file'
-	exit,status=1
-endif
-
-point_lun,fd,5
-
-if string(a[0]) ne cut15 then begin
-	message,/continue,'Assoc doesn''t work twice on zipped file'
-	exit,status=1
-endif
-
-spawn,'cat '+file+' | gunzip - | head -1 | cut -b 6-10',cut15
-if string(a[1]) ne ' GNU ' then begin
-	message,/continue,'Assoc doesn''t work with differents indexes on zipped file'
-	exit,status=1
+POINT_LUN, fd, 0
+a=ASSOC(fd, BYTARR(5))
+commande='cat '+file+' | gunzip - | head -1 | cut -b 1-5'
+if KEYWORD_SET(verbose) then print, 'commande: ', commande
+SPAWN, commande, cut15
+;
+if STRING(a[0]) ne cut15 then begin
+   MESSAGE, /continue, 'Assoc doesn''t work on zipped file'
+   CATCH_EXIT, nb_pbs, no_exit=no_exit
+   if ~KEYWORD_SET(no_exit) then EXIT, status=1
+   exit, status=1
+endif
+;
+; ----------
+;
+POINT_LUN, fd, 5
+if STRING(a[0]) ne cut15 then begin
+   MESSAGE, /continue, 'Assoc doesn''t work twice on zipped file'
+   CATCH_EXIT, nb_pbs, no_exit=no_exit
 endif
-
+;
+; ----------
+;
+commande='cat '+file+' | gunzip - | head -1 | cut -b 6-10'
+if KEYWORD_SET(verbose) then print, 'commande: ', commande
+SPAWN, commande, cut610
+;
+if STRING(a[1]) ne ' GNU ' then begin
+   MESSAGE, /continue, 'ASSOC doesn''t work with differents indexes on zipped file'
+   CATCH_EXIT, nb_pbs, no_exit=no_exit
+endif
+;
+; ----------
+;
 ; Readu test
-point_lun,fd,0
+POINT_LUN, fd, 0
 str='123'
-readu,fd,str
-if str ne 'GDL' then begin
-	message,/continue,'Readu doesn''t work on zipped file'
-	exit,status=1
-endif
-
-readu,fd,str
-if str ne ' - ' then begin
-	message,/continue,'Readu doesn''t work twice on zipped file'
-	exit,status=1
-endif
-
-close,fd
-free_lun,fd
-
+READU, fd, str
+;
+if (str ne 'GDL') then begin
+   MESSAGE, /continue, 'READU doesn''t work on zipped file'
+   CATCH_EXIT, nb_pbs, no_exit=no_exit
+endif
+;
+READU, fd, str
+;
+if (str ne ' - ') then begin
+   MESSAGE, /continue, 'READU doesn''t work twice on zipped file'
+   CATCH_EXIT, nb_pbs, no_exit=no_exit
+endif
+;
+CLOSE, fd
+FREE_LUN, fd
+;
+; ------------------------------
+;
 ;; WRITE TESTS
-
+;
 file='test_zipw.gz'
-openw,fd,file,/get,/compress
-printf,fd,'GNU Data Language'
-close,fd
-free_lun,fd
-
-openr,fd,file,/get,/compress
-readf,fd,str
-if str ne 'GNU Data Language' then begin
-	message,/continue,'Printf doesn''t work on zipped file'
-	exit,status=1
-endif
-close,fd
-free_lun,fd
-
-openw,fd,file,/get,/compress
-printf,fd,'GNU Data Language'
-point_lun,fd,10
+OPENW, fd, file, /get, /compress
+PRINTF, fd, 'GNU Data Language'
+CLOSE, fd
+FREE_LUN, fd
+;
+OPENR, fd, file, /get, /compress
+READF, fd, str
+;
+if (str ne 'GNU Data Language') then begin
+   MESSAGE, /continue, 'Printf doesn''t work on zipped file'
+   CATCH_EXIT, nb_pbs, no_exit=no_exit
+endif
+;
+CLOSE, fd
+FREE_LUN, fd
+;
+; ----------
+;
+OPENW, fd, file, /get, /compress
+PRINTF, fd, 'GNU Data Language'
+POINT_LUN, fd, 10
 ; point_lun used in write mode is pretty useless cause you can only move forward and it cause premature EOF.
 ; Also, you can't open a file in write mode, with compress and append keywords.
 ; So, if you don't specify append, you truncate the file, and point_lun become useless.
 ; To summarize, you can't write data and go backward to overwrite it. (Just don't use it)
-
-printf,fd,'rocks' ; GNU Data Language\nrocks\n
-close,fd
-free_lun,fd
-
-openr,fd,file,/get,/compress,/delete
-a=assoc(fd,bytarr(10))
-
-if string(a[0]) ne 'GNU Data L' or strmid(string(a[1]),0,7) ne 'anguage' then begin
-	message,/continue,'Point_lun doesn''t work on zipped file (write mode)'
-	exit,status=1
-endif
-
-close,fd
-free_lun,fd
-
+;
+PRINTF, fd, 'rocks' ; GNU Data Language\nrocks\n
+CLOSE, fd
+FREE_LUN, fd
+;
+OPENR, fd, file, /get, /compress, /delete
+a=ASSOC(fd, BYTARR(10))
+;
+if (STRING(a[0]) ne 'GNU Data L') OR (STRMID(STRING(a[1]), 0, 7) ne 'anguage') then begin
+   MESSAGE, /continue, 'Point_lun doesn''t work on zipped file (write mode)'
+   CATCH_EXIT, nb_pbs, no_exit=no_exit
+endif
+;
+CLOSE, fd
+FREE_LUN, fd
+;
+; if we are here and nb_pbs > 0 then /No_exit was set.
+;
+if ~KEYWORD_SET(quiet) then begin
+   if (nb_pbs EQ 0) then begin
+      MESSAGE, /continue, 'All ZIP/COMPRESS related tests successful'
+   endif else begin
+      MESSAGE, /continue, STRING(nb_pbs)+' tests failed'
+   endelse
+endif
+;
+if KEYWORD_SET(test) then STOP
+;
 end
