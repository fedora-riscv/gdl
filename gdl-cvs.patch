Only in gdl-0.9.3: aclocal.m4
Only in gdl-0.9.3: CMakeFiles
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/CMakeLists.txt gdl/CMakeLists.txt
--- gdl-0.9.3/CMakeLists.txt	2012-12-27 09:22:45.000000000 -0700
+++ gdl/CMakeLists.txt	2013-05-16 12:36:32.155861726 -0600
@@ -14,13 +14,14 @@
 project(GDL)
 
 # X.X.X CVS becomes release X.X.X+1
-set(VERSION "0.9.3")
+set(VERSION "0.9.3 CVS")
 enable_testing()
 
 include(CheckIncludeFile)
 include(CheckIncludeFileCXX)
 include(CheckLibraryExists)
 include(CheckFunctionExists)
+include(CheckSymbolExists)
 include(CheckCSourceRuns)
 include(FindPkgConfig)
 include(FindPackageHandleStandardArgs)
@@ -49,15 +50,23 @@
 set(UDUNITS OFF CACHE BOOL "Enable UDUNITS-2 ?")
 set(UDUNITSDIR "" CACHE PATH "Specify the UDUNITS-2 directory tree")
 
+set(EIGEN3 ON CACHE BOOL "Enable Eigen3 ?")
+set(EIGEN3DIR "" CACHE PATH "Specify the Eigen3 directory tree")
+
 set(PSLIB ON CACHE BOOL "Enable pslib ?")
 set(PSLIBDIR "" CACHE PATH "Specify the pslib directory tree")
 
 set(GRIB OFF CACHE BOOL "Enable Grib ?")
 set(GRIBDIR "" CACHE PATH "Specifiy the GRIB directory tree")
 
-set(MAGICK ON CACHE BOOL "Enable Magick ?")
+
+set(MAGICK ON CACHE BOOL "Enable ImageMagick ?")
 set(MAGICKDIR "" CACHE PATH "Specifiy the ImageMagick directory tree")
 
+# GraphicsMagick is a good alternative to ImageMagick
+set(GRAPHICSMAGICK ON CACHE BOOL "Enable GraphicsMagick ?")
+set(GRAPHICSMAGICKDIR "" CACHE PATH "Specify the GraphicsMagick directory tree")
+
 set(NETCDF ON CACHE BOOL "Enable NetCDF ?")
 set(NETCDFDIR "" CACHE PATH "Specifiy the netCDF directory tree")
 
@@ -285,12 +294,49 @@
         "(suitable Fedora package: plplot-devel)")
 endif(PLPLOT_FOUND)
 
-check_library_exists("${PLPLOT_LIBRARIES}" plP_mmpcx "" HAVE_PLPLOT_BEFORE_5994)
-if(HAVE_PLPLOT_BEFORE_5994)
-  message(STATUS "OK for XYOUTS in plplot")
-else(HAVE_PLPLOT_BEFORE_5994)
-  message(STATUS "warning for XYOUTS in plplot")
-endif(HAVE_PLPLOT_BEFORE_5994)
+if(PLPLOT_FOUND)
+	check_library_exists("${PLPLOT_LIBRARIES}" c_plslabelfunc "" HAVE_PLPLOT_SLABELFUNC)
+	if(HAVE_PLPLOT_SLABELFUNC)
+	  set(HAVE_PLPLOT_SLABELFUNC 1)
+	else(HAVE_PLPLOT_SLABELFUNC)
+	  message(STATUS "warning, due to old plplot library, [XYZ]TICKFORMAT option for plot axis will not be supported.\n"
+	    "you should upgrade to plplot version > 5.9.6")
+	endif(HAVE_PLPLOT_SLABELFUNC)
+	check_library_exists("${PLPLOT_LIBRARIES}" plstrl "" PLPLOT_PRIVATE_NOT_HIDDEN)
+	if(PLPLOT_PRIVATE_NOT_HIDDEN)
+	  set(PLPLOT_PRIVATE_NOT_HIDDEN 1)
+	else(PLPLOT_PRIVATE_NOT_HIDDEN)
+	  message(STATUS "Using a plplot library without private functions - workarounds will be used.")
+	endif(PLPLOT_PRIVATE_NOT_HIDDEN)
+endif(PLPLOT_FOUND)
+	
+# GRAPHICSMAGICK is an alternative to the classical ImageMagick Lib.
+#
+# -DGRAPHICSMAGICK=ON|OFF
+# -DGRAPHICSMAGICKDIR=DIR
+if(GRAPHICSMAGICK)
+	if (MAGICK_FOUND)
+	   message("We prefer to use GraphicsMagick than ImageMagick")
+	   set(MAGICK off)
+	endif(MAGICK_FOUND)
+	set(CMAKE_PREFIX_PATH ${GRAPHICSMAGICKDIR})
+	find_package(GraphicsMagick QUIET)
+	set(USE_MAGICK ${GRAPHICSMAGICK_FOUND})
+	if(GRAPHICSMAGICK_FOUND)
+		include_directories(${GRAPHICSMAGICK_INCLUDE_DIR})	
+		set(LIBRARIES ${LIBRARIES} ${GRAPHICSMAGICK_LIBRARIES})		
+	else(GRAPHICSMAGICK_FOUND)
+		message(FATAL_ERROR "GRAPHICSMAGICK is required but was not found.\n"
+		"Use -DGRAPHICSMAGICKDIR=DIR to specify the GraphicsMagick directory tree.\n"
+		"Use -DGRAPHICSMAGICK=OFF to not use it.\n"
+                "(suitable Fedora package: GraphicsMagick-c++-devel"
+		"   Debian/Ubuntu package: libgraphicsmagick++1-devel)")
+	endif(GRAPHICSMAGICK_FOUND)
+endif(GRAPHICSMAGICK)
+
+if(GRAPHICSMAGICK_FOUND)
+	set(MAGICK OFF)
+endif(GRAPHICSMAGICK_FOUND)
 
 if(MAGICK) # support Magick
 	check_library_exists("${PLPLOT_LIBRARIES}" plGetDrvDir "" HAVE_PLGETDRVDIR)
@@ -366,18 +412,18 @@
 	find_package(NetCDF QUIET)
 	if(NETCDF_FOUND)
 		set(CMAKE_REQUIRED_INCLUDES ${NETCDF_INCLUDE_DIRS})
-		check_include_file_cxx(netcdfcpp.h HAVE_NETCDFCPP_H)
-		if(HAVE_NETCDFCPP_H)
+		check_include_file_cxx(netcdf.h HAVE_NETCDF_H)
+		if(HAVE_NETCDF_H)
 			set(LIBRARIES ${LIBRARIES} ${NETCDF_LIBRARIES})
 			set(LINK_DIRECTORIES ${LINK_DIRECTORIES} ${NETCDF_LIBRARY_DIRS})
 			include_directories(${NETCDF_INCLUDE_DIRS})
 			set(USE_NETCDF 1)
-		else(HAVE_NETCDFCPP_H)
+		else(HAVE_NETCDF_H)
 			message(FATAL_ERROR "NetCDF installation seems not to be usable.\n"
 			"This suggests a conflicting netCDF-HDF4 installation e.g.\n"
 			"- Uninstalling HDF4 after installation of NetCDF.\n"
 			"- Installing NetCDF before HDF4.")
-		endif(HAVE_NETCDFCPP_H)
+		endif(HAVE_NETCDF_H)
 		set(CMAKE_REQUIRED_INCLUDES)
 	else(NETCDF_FOUND)
 		message(FATAL_ERROR "NetCDF version 3.5.1 or later is required but was not found.\n"
@@ -555,8 +601,13 @@
                   message("-- Found Python executable: ${PYTHON_EXECUTABLE}")
                 endif()
 	else()
+		if(PYTHONVERSION)
+			set(PythonLibs_FIND_VERSION ${PYTHONVERSION})
+		else()
+			set(PythonLibs_FIND_VERSION 2)
+		endif()
 		find_package(PythonLibs)
-                include(FindPythonInterp)
+		include(FindPythonInterp)
 	endif()
 	set(USE_PYTHON ${PYTHONLIBS_FOUND})
 	if(PYTHONLIBS_FOUND)
@@ -596,6 +647,23 @@
 	endif(UDUNITS_FOUND)
 endif(UDUNITS)
 
+# eigen3
+# -DEIGEN3=ON|OFF
+# -DEIGEN3DIR=DIR
+if(EIGEN3)
+	set(CMAKE_PREFIX_PATH ${EIGEN3DIR})
+	find_package(Eigen3 QUIET)
+	set(USE_EIGEN ${EIGEN3_FOUND})
+	if(EIGEN3_FOUND)
+		include_directories(${EIGEN3_INCLUDE_DIR})	
+	else(EIGEN3_FOUND)
+		message(FATAL_ERROR "EIGEN3 is required but was not found.\n"
+		"Use -DEIGEN3DIR=DIR to specify the Eigen3 directory tree.\n"
+		"Use -DEIGEN3=OFF to not use it.\n"
+                "(suitable Fedora package: eigen3-devel)")
+	endif(EIGEN3_FOUND)
+endif(EIGEN3)
+
 # pslib
 # -DPSLIB=ON|OFF
 # -DPSLIBDIR=DIR
@@ -716,9 +784,9 @@
 ENDIF(NOT CMAKE_BUILD_TYPE)
 
 if(WIN32 AND NOT CYGWIN)
-SET(MACHINE_ARCH ${MSVC_C_ARCHITECTURE_ID})
-IF(NOT MACHINE_ARCH)
-  SET(MACHINE_ARCH ${MSVC_CXX_ARCHITECTURE_ID})
+SET(MACHINE_ARCH ${MSVC_C_ARCHITECTURE_ID})
+IF(NOT MACHINE_ARCH)
+  SET(MACHINE_ARCH ${MSVC_CXX_ARCHITECTURE_ID})
 ENDIF(NOT MACHINE_ARCH)
 set_target_properties(gdl PROPERTIES LINK_FLAGS "/machine:${MACHINE_ARCH}")
 endif(WIN32 AND NOT CYGWIN)
@@ -726,7 +794,6 @@
 # AC, 12-oct-2011, solved by Marc 
 # set_target_properties(gdl PROPERTIES LINK_FLAGS "-Wl,-z,muldefs")
 # set_target_properties(gdl PROPERTIES LINK_FLAGS "-z muldefs")
-
 #
 if(CMAKE_BUILD_TYPE STREQUAL None OR NOT CMAKE_BUILD_TYPE)
 	set(FLAGS ${CMAKE_CXX_FLAGS})
@@ -739,6 +806,8 @@
 elseif(CMAKE_BUILD_TYPE STREQUAL MinSizeRel)
 	set(FLAGS ${CMAKE_CXX_FLAGS_MINSIZEREL})
 endif(CMAKE_BUILD_TYPE STREQUAL None OR NOT CMAKE_BUILD_TYPE)
+
+
 message(STATUS
 "Summary
 
@@ -767,6 +836,8 @@
 module(MPICH     "MPICH      ")
 module(PYTHON    "Python     ")
 module(UDUNITS   "UDUNITS-2  ")
+module(EIGEN3    "EIGEN3     ")
+module(GRAPHICSMAGICK "GRAPHICSMAGICK")
 module(GRIB      "GRIB       ")
 set(GSHHS_LIBRARIES ${GSHHS_INCLUDE_DIR})
 module(GSHHS     "GSHHS      ")
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/CMakeModules/FindEigen3.cmake gdl/CMakeModules/FindEigen3.cmake
--- gdl-0.9.3/CMakeModules/FindEigen3.cmake	1969-12-31 17:00:00.000000000 -0700
+++ gdl/CMakeModules/FindEigen3.cmake	2013-02-18 02:05:41.000000000 -0700
@@ -0,0 +1,81 @@
+# - Try to find Eigen3 lib
+#
+# This module supports requiring a minimum version, e.g. you can do
+#   find_package(Eigen3 3.1.2)
+# to require version 3.1.2 or newer of Eigen3.
+#
+# Once done this will define
+#
+#  EIGEN3_FOUND - system has eigen lib with correct version
+#  EIGEN3_INCLUDE_DIR - the eigen include directory
+#  EIGEN3_VERSION - eigen version
+
+# Copyright (c) 2006, 2007 Montel Laurent, <montel@kde.org>
+# Copyright (c) 2008, 2009 Gael Guennebaud, <g.gael@free.fr>
+# Copyright (c) 2009 Benoit Jacob <jacob.benoit.1@gmail.com>
+# Redistribution and use is allowed according to the terms of the 2-clause BSD license.
+
+if(NOT Eigen3_FIND_VERSION)
+  if(NOT Eigen3_FIND_VERSION_MAJOR)
+    set(Eigen3_FIND_VERSION_MAJOR 2)
+  endif(NOT Eigen3_FIND_VERSION_MAJOR)
+  if(NOT Eigen3_FIND_VERSION_MINOR)
+    set(Eigen3_FIND_VERSION_MINOR 91)
+  endif(NOT Eigen3_FIND_VERSION_MINOR)
+  if(NOT Eigen3_FIND_VERSION_PATCH)
+    set(Eigen3_FIND_VERSION_PATCH 0)
+  endif(NOT Eigen3_FIND_VERSION_PATCH)
+
+  set(Eigen3_FIND_VERSION "${Eigen3_FIND_VERSION_MAJOR}.${Eigen3_FIND_VERSION_MINOR}.${Eigen3_FIND_VERSION_PATCH}")
+endif(NOT Eigen3_FIND_VERSION)
+
+macro(_eigen3_check_version)
+  file(READ "${EIGEN3_INCLUDE_DIR}/Eigen/src/Core/util/Macros.h" _eigen3_version_header)
+
+  string(REGEX MATCH "define[ \t]+EIGEN_WORLD_VERSION[ \t]+([0-9]+)" _eigen3_world_version_match "${_eigen3_version_header}")
+  set(EIGEN3_WORLD_VERSION "${CMAKE_MATCH_1}")
+  string(REGEX MATCH "define[ \t]+EIGEN_MAJOR_VERSION[ \t]+([0-9]+)" _eigen3_major_version_match "${_eigen3_version_header}")
+  set(EIGEN3_MAJOR_VERSION "${CMAKE_MATCH_1}")
+  string(REGEX MATCH "define[ \t]+EIGEN_MINOR_VERSION[ \t]+([0-9]+)" _eigen3_minor_version_match "${_eigen3_version_header}")
+  set(EIGEN3_MINOR_VERSION "${CMAKE_MATCH_1}")
+
+  set(EIGEN3_VERSION ${EIGEN3_WORLD_VERSION}.${EIGEN3_MAJOR_VERSION}.${EIGEN3_MINOR_VERSION})
+  if(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
+    set(EIGEN3_VERSION_OK FALSE)
+  else(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
+    set(EIGEN3_VERSION_OK TRUE)
+  endif(${EIGEN3_VERSION} VERSION_LESS ${Eigen3_FIND_VERSION})
+
+  if(NOT EIGEN3_VERSION_OK)
+
+    message(STATUS "Eigen3 version ${EIGEN3_VERSION} found in ${EIGEN3_INCLUDE_DIR}, "
+                   "but at least version ${Eigen3_FIND_VERSION} is required")
+  endif(NOT EIGEN3_VERSION_OK)
+endmacro(_eigen3_check_version)
+
+if (EIGEN3_INCLUDE_DIR)
+
+  # in cache already
+  _eigen3_check_version()
+  set(EIGEN3_FOUND ${EIGEN3_VERSION_OK})
+
+else (EIGEN3_INCLUDE_DIR)
+
+  find_path(EIGEN3_INCLUDE_DIR NAMES signature_of_eigen3_matrix_library
+      PATHS
+      ${CMAKE_INSTALL_PREFIX}/include
+      ${KDE4_INCLUDE_DIR}
+      PATH_SUFFIXES eigen3 eigen
+    )
+
+  if(EIGEN3_INCLUDE_DIR)
+    _eigen3_check_version()
+  endif(EIGEN3_INCLUDE_DIR)
+
+  include(FindPackageHandleStandardArgs)
+  find_package_handle_standard_args(Eigen3 DEFAULT_MSG EIGEN3_INCLUDE_DIR EIGEN3_VERSION_OK)
+
+  mark_as_advanced(EIGEN3_INCLUDE_DIR)
+
+endif(EIGEN3_INCLUDE_DIR)
+
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/CMakeModules/FindGraphicsMagick.cmake gdl/CMakeModules/FindGraphicsMagick.cmake
--- gdl-0.9.3/CMakeModules/FindGraphicsMagick.cmake	1969-12-31 17:00:00.000000000 -0700
+++ gdl/CMakeModules/FindGraphicsMagick.cmake	2013-04-23 08:09:40.000000000 -0600
@@ -0,0 +1,24 @@
+#
+# copyright : (c) 2013 Sacha Hony
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation; either version 2 of the License, or
+#  (at your option) any later version.
+#
+# http://sourceforge.net/tracker/?func=detail&aid=3611651&group_id=97659&atid=618685
+#
+# Find the GraphicsMagick includes and library
+# 
+
+find_library(GRAPHICSMAGICK_LIBRARY NAMES GraphicsMagick)
+find_library(GRAPHICSMAGICKXX_LIBRARY NAMES GraphicsMagick++)
+set(GRAPHICSMAGICK_LIBRARIES ${GRAPHICSMAGICK_LIBRARY} ${GRAPHICSMAGICKXX_LIBRARY})
+find_path(GRAPHICSMAGICK_INCLUDE_DIR NAMES magick/api.h PATH_SUFFIXES GraphicsMagick)
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(GRAPHICSMAGICK DEFAULT_MSG GRAPHICSMAGICK_LIBRARIES GRAPHICSMAGICK_INCLUDE_DIR)
+
+mark_as_advanced(
+GRAPHICSMAGICK_LIBRARIES
+GRAPHICSMAGICK_INCLUDE_DIR
+)
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/CMakeModules/Findlibps.cmake gdl/CMakeModules/Findlibps.cmake
--- gdl-0.9.3/CMakeModules/Findlibps.cmake	2012-12-27 09:22:45.000000000 -0700
+++ gdl/CMakeModules/Findlibps.cmake	2013-02-25 17:04:20.673197101 -0700
@@ -1,4 +1,4 @@
-find_path(LIBPSPKG libps.pc PATH_SUFFIXES lib lib/pkgconfig)
+find_path(LIBPSPKG libps.pc PATH_SUFFIXES lib lib/pkgconfig lib64/pkgconfig)
 include(FindPackageHandleStandardArgs)
 if(LIBPSPKG)
 	set(ENV{PKG_CONFIG_PATH} ${LIBPSPKG}) # pkg search path
Only in gdl-0.9.3/CMakeModules: Findlibps.cmake.~1.2.~
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/CMakeModules/FindNetCDF.cmake gdl/CMakeModules/FindNetCDF.cmake
--- gdl-0.9.3/CMakeModules/FindNetCDF.cmake	2012-12-27 09:22:45.000000000 -0700
+++ gdl/CMakeModules/FindNetCDF.cmake	2013-05-16 12:36:32.195861583 -0600
@@ -9,24 +9,17 @@
 #
 
 
-find_path(NETCDFPKG netcdf.pc PATH_SUFFIXES lib lib/pkgconfig)
-include(FindPackageHandleStandardArgs)
-if(NETCDFPKG)
-	set(ENV{PKG_CONFIG_PATH} ${NETCDFPKG}) # pkg search path
-	include(FindPkgConfig)
-	pkg_check_modules(NETCDF netcdf)
-	if(NETCDF_FOUND)
-		find_package_handle_standard_args(NETCDF DEFAULT_MSG NETCDF_LIBRARIES NETCDF_INCLUDE_DIRS)
-	endif(NETCDF_FOUND)
-else(NETCDFPKG) # no netcdf.pc file
+find_package(PkgConfig QUIET)
+pkg_check_modules(NETCDF netcdf)
+if(NETCDF_FOUND) # no netcdf.pc file
+	find_package_handle_standard_args(NETCDF DEFAULT_MSG NETCDF_LIBRARIES)
+else(NETCDF_FOUND) # no netcdf.pc file
 	find_library(NETCDF_LIBRARIES NAMES netcdf)
-	find_path(NETCDF_INCLUDE_DIRS NAMES netcdfcpp.h PATH_SUFFIXES netcdf-3)	
+	find_path(NETCDF_INCLUDE_DIRS NAMES netcdf.h PATH_SUFFIXES netcdf-3)
 	find_package_handle_standard_args(NETCDF DEFAULT_MSG NETCDF_LIBRARIES NETCDF_INCLUDE_DIRS)
-endif(NETCDFPKG)
+endif(NETCDF_FOUND)
 
 mark_as_advanced(
-NETCDFPKG
-NETCDF
 NETCDF_INCLUDE_DIRS
 NETCDF_LIBRARIES
 )
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/CMakeModules/FindPCRE.cmake gdl/CMakeModules/FindPCRE.cmake
--- gdl-0.9.3/CMakeModules/FindPCRE.cmake	2012-12-27 09:22:45.000000000 -0700
+++ gdl/CMakeModules/FindPCRE.cmake	2012-09-28 04:20:00.000000000 -0600
@@ -1,8 +1,7 @@
 #
-# copyright : (c) 2010 Maxime Lenoir, Alain Coulais,
-#                      Sylwester Arabas, and Orion Poplawski
-#
-# 2012/Sep/18 Jeongbin Park added this file; to support Windows platform.
+# copyright : (c) 2012 Jeongbin Park
+#
+# 2012/Sep/18 Jeongbin Park added this file; to support Windows platform.
 #
 #  This program is free software; you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License as published by
@@ -10,7 +9,6 @@
 #  (at your option) any later version.
 #
 
-
 find_library(PCRE_LIBRARY NAMES pcre)
 set(PCRE_LIBRARIES ${PCRE_LIBRARY})
 find_path(PCRE_INCLUDE_DIR NAMES regex.h)
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/CMakeModules/FindXdr.cmake gdl/CMakeModules/FindXdr.cmake
--- gdl-0.9.3/CMakeModules/FindXdr.cmake	2012-12-27 09:22:45.000000000 -0700
+++ gdl/CMakeModules/FindXdr.cmake	2012-09-28 04:20:00.000000000 -0600
@@ -1,24 +1,22 @@
-#
-# copyright : (c) 2010 Maxime Lenoir, Alain Coulais,
-#                      Sylwester Arabas, and Orion Poplawski
-#
-# 2012/Sep/18 Jeongbin Park added this file; to support Windows platform.
-#
-#  This program is free software; you can redistribute it and/or modify
-#  it under the terms of the GNU General Public License as published by
-#  the Free Software Foundation; either version 2 of the License, or
-#  (at your option) any later version.
-#
-
-
-find_library(XDR_LIBRARY NAMES xdr)
-set(XDR_LIBRARIES ${XDR_LIBRARY})
-find_path(XDR_INCLUDE_DIR NAMES rpc/xdr.h)
-include(FindPackageHandleStandardArgs)
-find_package_handle_standard_args(XDR DEFAULT_MSG XDR_LIBRARIES XDR_INCLUDE_DIR)
-
-mark_as_advanced(
-XDR_LIBRARY
-XDR_LIBRARIES
-XDR_INCLUDE_DIR 
-)
+#
+# copyright : (c) 2012 Jeongbin Park
+#
+# 2012/Sep/18 Jeongbin Park added this file; to support Windows platform.
+#
+#  This program is free software; you can redistribute it and/or modify
+#  it under the terms of the GNU General Public License as published by
+#  the Free Software Foundation; either version 2 of the License, or
+#  (at your option) any later version.
+#
+
+find_library(XDR_LIBRARY NAMES xdr)
+set(XDR_LIBRARIES ${XDR_LIBRARY})
+find_path(XDR_INCLUDE_DIR NAMES rpc/xdr.h)
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(XDR DEFAULT_MSG XDR_LIBRARIES XDR_INCLUDE_DIR)
+
+mark_as_advanced(
+XDR_LIBRARY
+XDR_LIBRARIES
+XDR_INCLUDE_DIR 
+)
Only in gdl-0.9.3: config.guess
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/config.h.cmake gdl/config.h.cmake
--- gdl-0.9.3/config.h.cmake	2012-12-27 09:22:44.000000000 -0700
+++ gdl/config.h.cmake	2013-05-16 12:36:32.175861654 -0600
@@ -27,7 +27,8 @@
 #cmakedefine HAVE_MEMORY_H 1
 #cmakedefine HAVE_NEXTTOWARD 1
 #cmakedefine HAVE_OLDPLPLOT 1
-#cmakedefine HAVE_PLPLOT_BEFORE_5994 1
+#cmakedefine HAVE_PLPLOT_SLABELFUNC 1
+#cmakedefine PLPLOT_PRIVATE_NOT_HIDDEN 1
 #ifndef HAVE_STDINT_H
 #cmakedefine HAVE_STDINT_H 1
 #endif
@@ -66,5 +67,6 @@
 #cmakedefine USE_PYTHON 1
 #cmakedefine USE_UDUNITS 1
 #cmakedefine USE_PSLIB 1
+#cmakedefine USE_EIGEN 1
 
 #endif
Only in gdl-0.9.3: config.sub
Only in gdl-0.9.3: configure
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/configure.in gdl/configure.in
--- gdl-0.9.3/configure.in	2012-12-27 09:22:45.000000000 -0700
+++ gdl/configure.in	2013-05-16 12:36:32.177861647 -0600
@@ -1,4 +1,4 @@
-AC_INIT(gdl, 0.9.3)
+AC_INIT(gdl, 0.9.3 CVS)
 AC_CONFIG_MACRO_DIR([m4])
 
 dnl == Configuration (of the configure script)  ============
@@ -16,6 +16,7 @@
 if test "x$with_grib"        = "x"; then with_grib=no;         fi
 if test "x$with_Magick"      = "x"; then with_Magick=yes;      fi
 if test "x$with_GraphicsMagick" = "x"; then with_GraphicsMagick=no;      fi
+if test "x$with_eigen3"       = "x"; then with_eigen3=auto;      fi
 if test "x$with_netcdf"      = "x"; then with_netcdf=yes;      fi
 if test "x$with_hdf"         = "x"; then with_hdf=yes;         fi
 if test "x$with_hdf5"        = "x"; then with_hdf5=yes;        fi
@@ -497,6 +498,26 @@
   )
 fi
 
+dnl == Eigen3 =================================================
+dnl ========================================================
+
+if test "x$with_eigen3" = "xauto"; then
+   AC_CHECK_FILE("/usr/include/eigen3/signature_of_eigen3_matrix_library",
+   	[with_eigen3=yes], [with_eigen3=no])
+   if test "x$with_eigen3" = "xyes"; then
+     AC_DEFINE([USE_EIGEN], [1], [Define if you want to use Eigen lib.])
+     INCLUDES="$INCLUDES -I/usr/include/eigen3/"
+   fi
+else
+  AC_ARG_WITH(eigen3,	
+ 	[  --with-eigen3=DIR       specify the Eigen3 package ((with optional path DIR) ],
+ 	[with_eigen3="$withval" ])
+
+  if test "x$with_eigen3" != "xno"; then
+    AC_DEFINE([USE_EIGEN], [1], [Define if you want to use Eigen lib.])
+    	 INCLUDES="$INCLUDES -I$with_eigen3"
+  fi
+fi
 dnl == netCDF ==============================================
 dnl ========================================================
 
@@ -541,8 +562,8 @@
     exit -1
     ])
 
-  AC_CHECK_HEADERS("netcdfcpp.h", [], [
-    AC_CHECK_HEADERS("$ncdfincdir/netcdfcpp.h", [], [
+  AC_CHECK_HEADERS("netcdf.h", [], [
+    AC_CHECK_HEADERS("$ncdfincdir/netcdf.h", [], [
       echo ""
       echo "Error! netCDF installation seems not to be usable"
       echo "       This suggests a conflicting netCDF-HDF4 installation, e.g."
@@ -1203,6 +1224,8 @@
     then echo 'no'; else echo yes; fi`
   GraphicsMagick:      `if test no = $with_GraphicsMagick;
     then echo 'no'; else echo yes; fi`
+  Eigen:               `if test no = $with_eigen;
+    then echo 'no'; else echo yes; fi`
   NetCDF:              `if test no = $with_netcdf;
     then echo 'no'; else echo yes; fi`
   HDF4:                `if test no = $with_hdf;
Only in gdl-0.9.3: depcomp
Only in gdl-0.9.3/doc: Makefile.in
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/udg/README.txt gdl/doc/udg/README.txt
--- gdl-0.9.3/doc/udg/README.txt	2012-12-27 09:22:45.000000000 -0700
+++ gdl/doc/udg/README.txt	2013-05-16 12:36:32.241861417 -0600
@@ -7,6 +7,11 @@
 0/ You must have compiled GDL before
 
 1/ You must collect some external files before:
+-- forloop.sty
+http://www.ctan.org/tex-archive/macros/latex/contrib/forloop
+
+-- stringstrings.sty
+http://www.ctan.org/tex-archive/macros/latex/contrib/stringstrings
 
 -- pdfdraftcopy.sty  
 see http://sarovar.org/projects/pdfdraftcopy/
@@ -19,6 +24,7 @@
 -- copernicus.bst
 see http://publications.copernicus.org/
 (wget http://publications.copernicus.org/Copernicus.bst)
+note: you need to rename it "copernicus.bst"
 
 -- Perl Script authorindex
 see http://mirrors.ctan.org/indexing/authorindex/
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/contribute.html gdl/doc/www/contribute.html
--- gdl-0.9.3/doc/www/contribute.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/contribute.html	2013-02-25 17:04:23.433185845 -0700
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL Contribute</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/support.php"/>
+  </head>
+  <body>
+  </body>
+</html>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/credits.html gdl/doc/www/credits.html
--- gdl-0.9.3/doc/www/credits.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/credits.html	2013-02-25 17:04:23.439185821 -0700
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL credits</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/credits.php"/>
+  </head>
+  <body>
+  </body>
+</html>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/credits.php gdl/doc/www/credits.php
--- gdl-0.9.3/doc/www/credits.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/credits.php	2013-02-25 17:04:23.445185797 -0700
@@ -0,0 +1,128 @@
+<?php require('_header.inc.php'); ?>
+			
+<h2>Credits</h2>
+
+<p>
+The project was founded and is maintained by:
+</p>
+
+<ul><li>
+<a href="mailto:m_schellens@users.sourceforge.net">Marc Schellens</a>
+<br/>
+Compiler, Interpreter, Library routines...
+</li></ul>
+
+<p>
+As of 2012 the core team consists additionally of (in alphabetical order):
+</p>
+
+<ul>
+<li>
+<a href="mailto:slayoo@users.sourceforge.net">Sylwester Arabas</a> 
+<br/>
+Library routines, testing, documentation, portability issues 
+</li>
+
+<li>
+<a href="mailto:alaingdl@users.sourceforge.net">Alain Coulais</a> 
+<br/>
+Library routines, testing, documentation, presentations 
+</li>
+
+<li>
+<a href="mailto:gilles-duvert@users.sourceforge.net">Gilles Duvert</a> 
+<br/>
+Library routines, plotting, testing
+</li>
+
+<li>
+<a href="mailto:jomoga@users.sourceforge.net">Joel Gales</a>
+<br/>
+Library routines (TV, FFT, HISTOGRAM, HDF support, widgets)
+</li>
+</ul>
+
+<p>
+Among many good folks who provided patches and valuable feedback (in alphabetical order):
+</p>
+<p>
+<a>M&eacute;d&eacute;ric&nbsp;Bocquien</a>,
+<a>Justin&nbsp;Bronn</a>,
+<a>Pierre&nbsp;Chanial</a>,
+<a>Christoph&nbsp;Fuchs</a>,
+<a>Nicolas&nbsp;Galmiche</a>,
+<a>Greg&nbsp;Huey</a>,
+<a>Gaurav&nbsp;Khanna</a>,
+<a>Benjamin&nbsp;Laurent</a>,
+<a>Christopher&nbsp;Lee</a>,
+<a>Maxime&nbsp;Lenoir</a>,
+<a>Peter&nbsp;Messmer</a>,
+<a>Gregory&nbsp;Marchal</a>,
+<a>Thibaut&nbsp;Mermet</a>,
+<a>L&eacute;a&nbsp;Noreskal</a>,
+<a>Jeong&nbsp;Bin&nbsp;Park</a>,
+<a>Mathieu&nbsp;Pinter</a>,
+<a>Orion&nbsp;Poplawski</a>,
+<a>Rene&nbsp;Preusker</a>,
+<a>Mateusz&nbsp;Turcza</a>,
+<a>Joanna&nbsp;Woo</a>,
+<a>H&nbsp;Xu</a>,
+...
+</p>
+
+<p>
+GDL contains snippets of code borrowed from other free and open-source projects credited to:
+</p>
+
+<p>
+<a>Deepak&nbsp;Bandyopadhyay</a>,
+<a>Sergio&nbsp;Gelato</a>,
+<a>Lutz&nbsp;Kettner</a>,
+<a>Craig&nbsp;B.&nbsp;Markwardt</a>,
+<a>Paul&nbsp;Ricchiazzi</a>,
+<a>Danny&nbsp;Smith</a>,
+<a>J.D.&nbsp;Smith</a>,
+<a>Richard&nbsp;Schwartz</a>,
+<a>Paul&nbsp;Wessel</a>,
+<a>Bob&nbsp;Withers</a>,
+...
+</p>
+
+<p>Pre-compiled or pre-configured packages of GDL are available for numerous systems thanks to:</p>
+
+<p>
+<a>Juan&nbsp;A.&nbsp;A&ntilde;el</a>,
+<a>Axel&nbsp;Beckert</a>, 
+<a>Markus&nbsp;Dittrich</a>,
+<a>Takeshi&nbsp;Enomoto</a>, 
+<a>S&eacute;bastien&nbsp;Fabbro</a>, 
+<a>Orlando&nbsp;Garcia&nbsp;Feal</a>,
+<a>Gaurav&nbsp;Khanna</a>, 
+<a>Justin&nbsp;Lecher</a>, 
+<a>S&eacute;bastien&nbsp;Maret</a>,
+<a>L&eacute;a&nbsp;Noreskal</a>, 
+<a>Orion&nbsp;Poplawski</a>,
+<a>Marius&nbsp;Schamschula</a>,
+<a>G&uuml;rkan&nbsp;Seng&uuml;n</a>,
+<a>Thierry&nbsp;Thomas</a>,
+...
+</p>
+
+<p>
+GDL is written in C++ using the <a>Terence Parr's</a>
+ANTLR language-recognition framework.
+Most of the library routines are implemented as interfaces to open-source packages
+  such as <a>GNU Scientific Library</a>, <a>PLPlot</a>, <a>FFTW</a>, <a>ImageMagick</a>, and many many more.
+</p>
+
+<p>
+Last but not least, we would like to acknowledge the designers of <a>IDL</a> and <a>PV-WAVE</a>.
+</p>
+
+<p>
+  Please do report any missing name on the lists above in the same way
+    as any other bug in GDL (see <a href="support.php">support &amp; feedback</a>).
+  Please also let us know if you would not like to be listed.
+</p>
+ 
+<?php require('_footer.inc.php'); ?>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/documentation.php gdl/doc/www/documentation.php
--- gdl-0.9.3/doc/www/documentation.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/documentation.php	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,31 @@
+<?php require('_header.inc.php'); ?>
+
+<h2><a href="index.html">GDL Documentation</a></h2>
+			
+<p>
+There's an ongoing effort to write the GDL User's and Developer's guide.
+Currently the documentation covers an automatically-generated list of all available library routines 
+and their keywords, about 100 code examples, and a few drafts of library 
+routine descriptions and other chapters.
+</p>
+
+<p>
+The documentation is available as a single PDF file (only in English):
+<a href="http://gnudatalanguage.sf.net/gdl.pdf">http://gnudatalanguage.sf.net/gdl.pdf [PDF, 1.2 MiB]</a>
+</p>
+
+<p>
+While GDL itself reached a beta status of development, the documentation
+  is far from reaching an alpha status - help is very welcome!
+Please report any inconsistencies in the documentation as any other
+  bugs in GDL. Please submit new additions to the text (incl. code examples)
+  as patches to GDL (see <a href="support.php">support &amp; feedback</a>).
+</p>
+
+<p>
+As GDL is almost 100% compatible to IDL (although not complete as many subroutines 
+  are waiting to be implemented), documentation and tutorials for IDL can also be 
+  utilized for GDL (see <a href="resources.php">resources</a>).
+</p>
+
+<?php require('_footer.inc.php'); ?>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/download.html gdl/doc/www/download.html
--- gdl-0.9.3/doc/www/download.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/download.html	2013-02-25 17:04:23.462185727 -0700
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>Download GDL</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/downloads.php"/>
+  </head>
+  <body>
+  </body>
+</html>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/downloads.php gdl/doc/www/downloads.php
--- gdl-0.9.3/doc/www/downloads.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/downloads.php	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,57 @@
+<?php require('_header.inc.php'); ?>
+
+<h2><a href="index.html">Obtaining GDL</a></h2>
+			
+<p>
+  GDL compiles "out of the box" on Linux, Mac OS X and several other UNIX systems
+  (see <a href="requirements.php">requirements</a> for details).
+</p>
+
+<p>
+  The source code distribution is available from
+  <a href="http://sourceforge.net/projects/gnudatalanguage/">SourceForge</a>.
+</p>
+
+<p>
+  The latest development version of GDL can be obtained via CVS - consult the
+  <a href="http://sourceforge.net/projects/gnudatalanguage/develop/">SF.net project development page</a>
+  for details. It is also possible to 
+  <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/">
+    browse the CVS repository using a web-based interface</a>.
+</p>
+
+<p>
+  There are numerous packaged versions of GDL available for various OSes:
+</p>
+  <ul>
+    <li>Linux
+      <ul>
+        <li><a href="http://koji.fedoraproject.org/koji/packageinfo?packageID=1830">Fedora</a></li>
+        <li><a href="http://packages.debian.org/search?keywords=gnudatalanguage">Debian GNU/Linux</a></li>
+        <li><a href="http://gentoo-portage.com/dev-lang/gdl">Gentoo</a></li>
+        <li><a href="http://aur.archlinux.org/packages.php?ID=2493">Arch Linux</a></li>
+        <li><a href="http://packages.ubuntu.com/gnudatalanguage">Ubuntu</a></li>
+      </ul>
+    </li>
+    <li>Mac OS X
+      <ul>
+        <li><a href="<?php echo(htmlspecialchars('http://www.macports.org/ports.php?by=name&substr=gnudatalanguage'));?>">Macports</a></li>
+<!--        <li><a href="http://hpc.sourceforge.net/">HPC page</a></li> -->
+        <li><a href="http://www.hmug.org/pub/MacOS_X/X/Applications/Science/gdl/">HMUG</a></li>
+        <li><a href="http://pdb.finkproject.org/pdb/package.php/gdl">Fink</a></li>
+      </ul>
+    </li>
+    <li>BSD
+      <ul>
+        <li><a href="http://www.freebsd.org/cgi/cvsweb.cgi/ports/science/gnudatalanguage/">FreeBSD</a></li>
+        <li><a href="http://packages.debian.org/search?keywords=gnudatalanguage">Debian GNU/kFreeBSD</a></li>
+      </ul>
+    </li>
+  </ul>
+
+<p>
+  Please note that several features of GDL depend on compile-time configuration, 
+    and might not be available in pre-built or pre-configured packages.
+</p>
+
+<?php require('_footer.inc.php'); ?>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/faq.php gdl/doc/www/faq.php
--- gdl-0.9.3/doc/www/faq.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/faq.php	2013-02-25 17:04:23.475185674 -0700
@@ -0,0 +1,58 @@
+<?php require('_header.inc.php'); ?>
+
+<h2><a href="index.html">Frequently Asked Questions</a></h2>
+
+<h3>Installation and portability issues</h3>
+<ul>
+<li>
+<a>Is it possible to run GDL on MS-Windows?</a>
+<br>Yes.
+<br>Solution 1: It's possible to compile GDL under Cygwin or e.g. to run GDL under the coLinux platform.
+<br>Solution 2: since GDL 0.9.3, GDL should be compilable under MS-windows thanks to <a>Jeong Bin Park</a>
+Please follow the <a href="http://cyfinity.egloos.com/1727847">instructions described here</a>.
+Feedback realy welcome. Please notice SPAWN functionnalities currently not working, which explain large
+number of FAIL in testsuite.
+<br>N.B.: Due to lack of Windows developer- or user-base there is virtually no testing done on Windows, though. Help welcome!
+    </li>
+  </ul>
+
+<h3>Compatibility with IDL</h3>
+  <ul>
+    <li>
+      <a>Is there an equivalent of IDL Virtual Machine in GDL?</a>
+      <br />
+      No. 
+      GDL is free/libre/open-source software. 
+      The distinction between a developers' (costly) version and a users' (free) version is not applicable.
+      Any user is free to use the full power of GDL.
+    </li>
+    <li>
+      <a>Is there a way to save/distribute pre-compiled GDL routines (as&nbsp;.sav&nbsp;files in IDL)?</a>
+      <br />
+      No. GDL does not support saving/loading pre-compiled routines yet.
+      It does support saving/loading variables into IDL-compatible .sav files, though.
+      Since compatibility with IDL-saved routines is not going to be possible anyhow, 
+      and since the virtual-machine context is not applicable to GDL (see above),
+      implementing routine saving has a low priority.
+    </li>
+    <li>
+      <a>Does GDL support the so-called ''object graphics'', ''function graphics''/''new graphics''?</a>
+      <br />
+      No. GDL supports ''direct graphics'' only.
+    </li>
+    <li>
+      <a>Why does the CATCH statement not work properly in GDL?</a>
+      <br />
+      It's one of very few IDL syntax elements not implemented in GDL yet.
+    </li>
+  </ul>
+
+<h3>Mapping</h3>
+  <ul>
+    <li>
+      <a>Why the continent/country/shoreline boundaries have so poor resolution in comparison with IDL</a><br />
+      Try the HIRES keyword to MAP_CONTINENTS!
+      </li>
+  </ul>
+
+<?php require('_footer.inc.php'); ?>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/feedback.html gdl/doc/www/feedback.html
--- gdl-0.9.3/doc/www/feedback.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/feedback.html	2013-02-25 17:04:23.475185674 -0700
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL Feedback</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/support.php"/>
+  </head>
+  <body>
+  </body>
+</html>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/_footer.inc.php gdl/doc/www/_footer.inc.php
--- gdl-0.9.3/doc/www/_footer.inc.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/_footer.inc.php	2011-08-10 03:35:34.000000000 -0600
@@ -0,0 +1,59 @@
+			<br />	
+
+		<!-- main ends -->	
+		</div>
+		
+		<!-- sidebar starts -->
+		<div id="sidebar">
+		
+			<h3>What's new</h3>
+<?php require('_news.inc.php'); ?>
+
+			<h3>Some stats (ohloh.net)</h3>
+<div class="ohloh" style="margin-top:10px">
+<script type="text/javascript" src="http://www.ohloh.net/p/28445/widgets/project_basic_stats.js"></script>
+</div>
+
+<!--
+			<h3>Search Box</h3>	
+			<form action="#" class="searchform">
+				<p>
+				<input name="search_query" class="textbox" type="text" />
+  				<input name="search" class="button" value="Search" type="submit" />
+				</p>			
+			</form>		
+-->
+			
+						
+		<!-- sidebar ends -->		
+		</div>
+		
+	<!-- content-wrap ends-->	
+	</div>
+		
+	<!-- footer starts here -->	
+	<div id="footer-wrap"><div id="footer-content">
+	
+		<p>
+			Website content is developed by <a href="credits.php">The GDL Team</a> and is released under the CC BY-SA license (i.e. Wikipedia compatible)<br />
+                        GDL documentation is a part of the GDL project and is released under the GNU General Public License<br />
+			Website layout based on the <strong>Colourise</strong> template by <a href="http://www.styleshout.com/">styleshout.com</a><br />
+                        Hosted by <a href="http://sf.net/">Sourceforge.net</a>
+          	</p>
+		
+<!--
+		<p class="float-right">
+              		<a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a> |
+               		<a href="http://validator.w3.org/check/referer">XHTML</a>
+		</p>
+-->
+			
+	</div></div>
+	<div class="clearer"></div>
+	<!-- footer ends here -->
+
+<!-- wrap ends here -->
+</div>
+
+</body>
+</html>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/_header.inc.php gdl/doc/www/_header.inc.php
--- gdl-0.9.3/doc/www/_header.inc.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/_header.inc.php	2012-02-21 09:54:33.000000000 -0700
@@ -0,0 +1,68 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+
+<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
+
+<head>
+  <title>GDL - GNU Data Language</title>
+  <meta http-equiv="content-type" content="application/xhtml+xml; charset=UTF-8" />
+  <link rel="stylesheet" href="images/Colourise.css" type="text/css" />
+</head>
+
+<body>
+
+<!-- wrap starts here -->
+<div id="wrap">
+
+	<!--header -->
+	<div id="header">			
+				
+		<h1 id="logo-text"><a>GDL - GNU Data Language</a></h1>		
+		<p id="intro">
+                  A free and open-source IDL<sup>&reg;*</sup>/PV-WAVE<sup>**</sup> compiler<br />
+                  <small>
+                    * IDL is a registered trademark of <a href="http://exelisvis.com/">Exelis Visual Information Solutions</a><br />
+                    ** PV-WAVE is a product of <a href="http://roguewave.com/">Rogue Wave Software</a>
+                  </small><br />
+		</p>	
+		
+		<div  id="nav">
+			<ul>
+<?php 
+  $menu = array(
+    'index.php' => 'Features',
+    'screenshots.php' => 'Screenshots',
+    'downloads.php' => 'Downloads',
+    'requirements.php' => 'Requirements',
+    'documentation.php' => 'Documentation',
+    'support.php' => 'Support &amp; Feedback',
+    'resources.php' => 'Resources',
+    'faq.php' => 'FAQ',
+    'credits.php' => 'Credits'
+  );
+  foreach ($menu as $file => $name) 
+  {
+    echo('<li');
+    if (basename($_SERVER['SCRIPT_FILENAME']) == $file) echo(' id="current"');
+    echo('><a href="' . $file . '">' . $name . '</a></li>');
+  }
+?>
+			</ul>		
+		</div>	
+		
+<!--
+		<form id="quick-search" action="index.html" method="get" >
+			<p>
+			<label for="qsearch">Search:</label>
+			<input class="tbox" id="qsearch" type="text" name="qsearch" value="Search..." title="Start typing and hit ENTER" />
+			<input class="btn" type="submit" value="Submit" />
+			</p>
+		</form>			
+-->
+				
+	<!--header ends-->					
+	</div>
+	
+	<!-- content-wrap starts -->
+	<div id="content-wrap">
+		<div id="main">
+			<a name="TemplateInfo"></a>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/home.html gdl/doc/www/home.html
--- gdl-0.9.3/doc/www/home.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/home.html	2013-02-25 17:04:23.489185617 -0700
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL ::. Home</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/index.php"/>
+  </head>
+  <body>
+  </body>
+</html>
Binary files gdl-0.9.3/doc/www/images/bg.jpg and gdl/doc/www/images/bg.jpg differ
Binary files gdl-0.9.3/doc/www/images/bullet.gif and gdl/doc/www/images/bullet.gif differ
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/images/Colourise.css gdl/doc/www/images/Colourise.css
--- gdl-0.9.3/doc/www/images/Colourise.css	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/images/Colourise.css	2012-02-21 09:54:33.000000000 -0700
@@ -0,0 +1,526 @@
+/* ----------------------------------------------
+	Template Name : Colourise
+	Template Code : S-0022
+	Version : 1.1   
+	Author : Erwin Aligam
+	Author URI : http://www.styleshout.com/       
+	Last Date Modified :  January 17, 2010
+ ------------------------------------------------ */
+ 
+/* ----------------------------------------------
+   HTML ELEMENTS
+------------------------------------------------- */ 
+
+/* Top Elements */
+* { margin: 0; padding: 0; outline: 0 }
+
+body {
+	font: 11px/165% 'Lucida Grande', Geneva, Verdana, Arial, Helvetica, sans-serif;
+	color: #9B9B9B; 	
+	margin: 0; 	padding: 0; 
+	background: #070707 url(bg.jpg) no-repeat center top;
+	text-align: center;
+}
+
+/* Links */
+a, a:active, a:link {
+	text-decoration: none;
+	color: #006193;			
+}
+a:visited {
+	text-decoration: none;
+}
+a:hover {
+	color: #fff;
+	border-bottom: 1px dotted #438800;
+}
+
+/* headers */
+h1, h2, h3 {
+	font-family: 'Trebuchet MS', Tahoma, Arial, Sans-serif;
+	color: #ABABAB;
+}
+h1 {
+	font-size: 3.6em;
+	font-weight: normal;
+	letter-spacing: -2px;
+	padding: 15px 10px 5px 10px;	
+}
+h2 {
+	font-size: 2.2em;
+	color: #895F30;
+	padding: 20px 10px 5px 10px;	
+}
+h3 {
+	font-size: 1.8em;
+	font-weight: normal;
+	padding: 20px 10px 5px 10px;	
+}
+
+p, dl { padding: 10px; margin: 0; }
+
+ul, ol {
+	margin: 10px 20px;
+	padding: 0 20px;
+}
+ul { list-style: none; }
+
+dt {
+  font-weight: bold;
+  color: #fff;
+}
+dd {
+  padding-left: 25px; 
+}
+
+/* images */
+img {
+	background: #1B1B1B;
+    border: 1px solid #1B1B1B;
+	padding: 8px;
+}
+img.float-right {
+  	margin: 5px 0px 10px 10px;  
+}
+img.float-left {
+  	margin: 5px 10px 10px 0px;
+}
+
+code {
+  	margin: 5px 0;
+  	padding: 15px;
+  	text-align: left;
+  	display: block;
+  	overflow: auto;  
+  	font: 500 1em/1.5em 'Lucida Console', 'Courier New', Monospace ;
+  	/* white-space: pre; */
+  	background: #111;  
+}
+acronym {
+  	cursor: help;
+  	border-bottom: 1px dotted #5B5B5B;
+}
+blockquote {
+	margin: 15px 10px;
+ 	padding: 10px 10px 10px 35px;  
+   background: #111 url(quote.jpg) no-repeat 10px 10px;
+	font-weight: normal;
+	font-size: 18px;
+	line-height: 1.6em;
+	font-style: italic;
+	font-family: Georgia, 'Times New Roman', Times, serif;	
+	color: #808080;	
+}
+
+/* start - table */
+table {
+	margin: 15px 10px; 
+	border-collapse: collapse;			
+}
+th {
+	background: #000;
+	color: #fff;
+	height: 38px;
+	padding-left: 12px;
+	padding-right: 12px;	
+	text-align: left;
+	border-left: 1px solid #211E20;
+	border-right: 1px solid #211E20;
+	border-bottom: 1px solid #211E20; 
+	border-top: 1px solid #48780E;
+}
+tr {
+	color: #5b5b5b;
+	height: 34px;	
+}
+td {
+	padding-left: 12px;
+	padding-right: 12px;
+	border: 1px solid #111;	
+}
+/* end - table */
+
+/* form elements */
+form {
+	margin: 20px 10px; padding: 5px 10px 20px 10px;
+	border: 1px solid #111; 
+	background: #070707; 	
+}
+label {
+	display: block;
+	font-weight: bold;
+	margin: 8px 0;
+	color: #fff;
+}
+input, select, textarea {
+	padding: 5px 4px;
+	font: normal 1em Verdana, Tahoma, sans-serif;
+	color: #6A6969;
+	background: #0C0C0C;  
+	border: 1px solid #1C1C1C;
+}
+textarea {
+	width: 400px;
+	height: 100px;
+	display: block;	
+}
+input.button { 
+	font: bold 12px Arial, Sans-serif; 
+	height: 30px;
+	margin: 0;
+	padding: 2px 3px; 
+	color: #48780E;
+	background: #000;
+	
+	border-width: 1px;
+  	border-style: solid;
+  	border-color: #1c1c1c;
+}
+
+/* search form */
+.searchform {
+	background-color: transparent;
+	border: none;	
+	margin: 0; padding: 20px 0 15px 8px;	
+	width: 270px;	
+}
+.searchform p { margin: 0; padding: 0 0 10px 0; }
+.searchform input.textbox { 
+	width: 185px;
+	height: 18px;
+	padding: 2px;	
+	vertical-align: top;
+}
+.searchform input.button { 
+	width: 60px;
+	height: 24px;
+	padding: 2px 5px;
+	vertical-align: top;
+}
+
+/* ------------------------------------------
+   LAYOUT
+------------------------------------------- */ 
+#wrap {
+	position: relative;
+	width: 900px;	
+	margin: 0 auto;
+	text-align: left;		
+}
+#content-wrap {
+	position: relative;
+	clear: both;
+	width: 900px;	
+	padding: 0; 		
+	margin-left: 5px;	
+	background: transparent;
+	float: left;	
+	display: inline;	
+	border-top: 1px solid #1A1A1A;
+}
+#header {
+	position: relative;
+	width: 900px;	
+	height: 370px;	
+	margin: 0; padding: 0;		
+	background: transparent;
+}
+
+/* header search */
+#header form#quick-search {
+	position: absolute;
+	top: 38px; right: 0;
+	padding: 0; margin: 0;
+	border: none;
+	width: 262px; height: 30px;
+	background: url(header-search.jpg) no-repeat;	
+	z-index: 999999;
+}
+#header form#quick-search p {
+	margin: 0; padding: 0;		
+}
+#header form#quick-search .tbox {
+	margin: 2px 0 0 5px; 
+	width: 210px;
+	background: none;
+	border: none;
+}
+#header form#quick-search label,
+#header form#quick-search .btn {
+	display: none;	
+}
+
+/*  Navigation  */
+#nav {
+	position: absolute;
+	margin: 0; padding: 0;		
+	height: 40px;
+	width: 900px;	
+	left: 0;	top: 35px;	
+	border-bottom: 1px solid #1A1A1A;
+}
+#nav ul {
+	float: left;
+	list-style: none;
+	width: 880px;		
+	height: 40px;
+	margin: 0 0 0 5px; padding: 0;	
+	display: inline;
+}
+#nav ul li {
+	display: inline;
+	margin: 0; padding: 0;
+}
+#nav ul li a {
+	float: left;
+	margin: 0;	padding: 0 8px;
+	font: bold 15px/35px 'Trebuchet MS', Helvetica, Arial, Geneva, sans-serif;
+	text-decoration: none;	
+	color: #5c9a12;	
+}
+#nav ul li a:hover, 
+#nav ul li a:active {
+	color: #eee;
+	background: none;
+	border: none;
+}
+#nav ul li#current a {	
+	color: #0077B5;	
+}
+
+#header h1#logo-text a {
+	position: absolute;
+	margin: 0; padding: 0;
+	font: normal 60px Georgia, 'Times New Roman', Times, serif;
+	letter-spacing: -1.5px;
+	color: #fff;
+	text-decoration: none;
+	
+	/* change the values of top and left to adjust the position of the logo*/
+	top: 120px; left: 10px;	
+}
+#header h1#logo-text a:hover {
+	background: none;	border: none;
+}
+#header p#intro {
+	position: absolute;
+	margin: 0; padding: 0;
+	font-family: Georgia, 'Times New Roman', Times, serif;
+	font-weight: normal;
+	font-size: 18px;
+	line-height: 1.6em;
+	font-style: italic;
+	text-transform: none;
+	color: #cd9857;
+	width: 500px;
+	
+	/* change the values of top and left to adjust the position */
+	top: 195px; left: 15px;		
+}
+
+/* Main Column */
+#main {
+	float: left;
+	width: 545px;
+	padding: 0; margin: 0;
+	display: inline;		
+}
+#main h2 {
+	padding-bottom: 3px;
+	margin-top: 15px;
+	font: normal 3.5em 'Trebuchet MS', Tahoma, Helvetica, Arial, sans-serif;
+	color: #fff; 
+	letter-spacing: -2px;	
+	text-transform: none;	
+}
+#main h2 a {
+	color: #fff;
+	text-decoration: none;		
+	border: none;	
+}
+#main ul li {
+	list-style-image: url(bullet.gif);
+	font-size: 14px;
+}
+#main p {
+	font-size: 14px;
+}
+
+/* Sidebar */	
+#sidebar {
+	float: right;
+	width: 290px;
+	padding: 0; margin: 25px 0 0 0;		
+	display: inline;	
+}	
+#sidebar h3 {
+	margin-top: 10px;
+	padding: 15px 5px 10px 5px; 
+	font: bold 2em 'Trebuchet MS', Tahoma, Helvetica, Arial, sans-serif;
+	background: url(footer-top.jpg) no-repeat center bottom;
+	color: #fefefe;
+}
+#sidebar ul.sidemenu {
+	text-align: left;
+	margin: 7px 5px 8px 0px; padding: 0;				
+}
+#sidebar ul.sidemenu li {
+	list-style: none;
+	padding: 8px 10px;
+	margin: 0;		
+	border-bottom: 1px solid #111;
+}
+* html body #sidebar ul.sidemenu li {
+	height: 1%;
+}
+#sidebar ul.sidemenu li a {
+	text-decoration: none;	
+	border: none;
+	color: #5d5d5d; 	
+		
+	font-weight: bold;		
+	font-family: 'Trebuchet MS', Tahoma, Helvetica, Arial, Sans-serif;
+	font-size: 14px;	
+	/* letter-spacing: .5px;  */
+}
+#sidebar ul.sidemenu li a span {
+	color: #444;	
+	font-family: Georgia, 'Times New Roman', Times, serif;
+	font-style: italic;
+	font-weight: normal;	
+	font-size: 11px;
+}
+#sidebar ul.sidemenu li a:hover,
+#sidebar ul.sidemenu li a:hover span {	
+	color: #fff;	
+}
+#sidebar ul.sidemenu ul { margin: 0 0 0 5px; padding: 0; }
+#sidebar ul.sidemenu ul li { border: none; }
+
+/* footer */
+#footer-wrap {
+	position: relative;
+	clear: both;
+	padding: 1em 0 2.5em 0;
+	margin-top: 30px;
+	font: normal 1em 'Trebuchet MS', Tahoma, sans-serif;	
+	background: #070707 url(footer-top.jpg) no-repeat center top;
+	color: #555;
+	width: 900px;
+	float: left;	
+	display: inline;
+}
+#footer-wrap h3 {
+	font: bold 2em/1.6em 'Trebuchet MS', Tahoma, sans-serif;
+	color: #ABABAB;	
+}
+#footer-content {	
+	margin: 0 auto;		
+	width: 880px;
+	text-align: left;		
+}
+#footer-content ul.col-list {
+	border-top: 1px solid #111;
+	list-style: none;
+	margin: 5px 0 0 5px; padding: 0;	
+	width: 98%;
+}
+#footer-content ul.col-list li {
+	border-bottom: 1px solid #111;
+}
+#footer-content ul.col-list li a {
+	display: block;
+	line-height: 1.5em;
+	font-weight: bold;
+	padding: 7px 0 7px 8px;
+	width: 98%;	
+	color: #555;
+	border: none;
+}
+#footer-content ul.col-list li a span {
+	color: #444;
+	font-style: italic;
+	font-weight: normal;
+	font-family: Georgia, 'Times New Roman', Times, serif;
+}
+#footer-content ul.col-list li a:hover,
+#footer-content ul.col-list li a:hover span {
+	color: #fff;
+	text-decoration: none;
+}
+
+#footer-content .col {
+	width: 280px;
+	padding: 0 0 30px 0;			
+	display: inline;
+}
+#footer-content .col2 {
+	width: 285px;
+	padding: 0 0 30px 0;	
+	display: inline;	
+}
+#footer-content .space-sep {
+	margin-right: 12px;
+}
+
+/* postmeta */
+.postmeta {	
+	padding: 7px 5px; margin: 20px 10px 15px 10px;	
+	font-size: 1em;	
+	color: #545454;
+	border: 1px solid #111;
+	background: #111;
+}
+.postmeta .date{ margin: 0 10px 0 5px;	}
+.postmeta a.comments { margin: 0 10px 0 5px;	}
+.postmeta a.readmore { margin: 0 10px 0 5px;	}
+
+.post-info { font-size: .95em; padding-top: 3px; margin-left: 5px; color: #444;	}
+.post-info a { color: #BD4200; }
+
+/* alignment classes */
+.float-left  { float: left; }
+.float-right { float: right; }
+.align-left  { text-align: left; }
+.align-right { text-align: right; }
+
+/* display and additional classes */
+.clearer { clear: both; }
+
+.clear {
+	display:inline-block;
+}
+.clear:after {
+	display:block; 
+	visibility:hidden; 
+	clear:both; 
+	height:0; 
+	content: "."; 
+}
+
+div.ohloh div.gadget 
+{
+	border:0;
+}
+div.ohloh div.gadget div.main 
+{
+	width:140px;
+}
+div.ohloh div.gadget div.updated
+{
+	width:240px;
+}
+
+div.ohloh, div.ohloh div div p, div.ohloh div div h3, div.ohloh div div a 
+{ 
+	padding:1px;
+	font-size:10px;
+        color: black;
+        background-color: white;
+}
+
+div.ohloh img
+{
+  border-color: white;
+  padding:0;
+}
Binary files gdl-0.9.3/doc/www/images/footer-top.jpg and gdl/doc/www/images/footer-top.jpg differ
Binary files gdl-0.9.3/doc/www/images/header-search.jpg and gdl/doc/www/images/header-search.jpg differ
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/index.html gdl/doc/www/index.html
--- gdl-0.9.3/doc/www/index.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/index.html	2013-02-25 17:04:23.546185380 -0700
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html>
+  <head>
+    <title>GDL - GNU Data Language</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/index.php"/>
+  </head>
+  <body>
+  </body>
+</html>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/index.php gdl/doc/www/index.php
--- gdl-0.9.3/doc/www/index.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/index.php	2011-08-12 10:20:48.000000000 -0600
@@ -0,0 +1,91 @@
+<?php require('_header.inc.php'); ?>
+			
+<h2>Introduction</h2>
+
+<p>
+GNU Data Language (GDL) is a free/libre/open source incremental compiler
+  compatible with IDL and to some extent with PV-WAVE.
+Together with its library routines it serves as a tool for data analysis 
+  and visualization in such disciplines as astronomy, geosciences and 
+  medical imaging. 
+GDL is free software licensed under the <a href="http://www.gnu.org/licenses/gpl.html">GPL</a>.
+GDL is developed by an international <a href="credits.php">team</a> of volunteers led by Marc Schellens - the project's founder
+</p>
+
+<p>
+GDL as a language is dynamically-typed, vectorized and has 
+  object-oriented programming capabilities. 
+GDL library routines handle numerical calculations, data visualisation, 
+  signal/image processing, interaction with host OS and data input/output. 
+GDL supports several data formats such as netCDF, HDF4, HDF5, GRIB, PNG, TIFF, 
+  DICOM, etc. 
+Graphical output is handled by X11, PostScript, SVG or z-buffer terminals, 
+  the last one allowing output graphics (plots) to be saved in a variety of  
+  raster graphics formats.
+GDL features integrated debugging facilities. 
+GDL has also a Python bridge (Python code can be called from GDL; GDL can be compiled 
+  as a Python module). 
+</p>
+
+<p>
+Packaged versions of GDL are available for several Linux and BSD flavours as well as Mac&nbsp;OS&nbsp;X. 
+The source code compiles as well on other UNIX systems, including Solaris.
+</p>
+
+<p>
+Other open-source numerical data analysis tools similar to GDL include
+<a href="http://www.gnu.org/software/octave/">GNU&nbsp;Octave</a>,
+<a href="http://www.ncl.ucar.edu/">NCL&nbsp;-&nbsp;NCAR&nbsp;Command&nbsp;Language</a>,
+<a href="http://pdl.perl.org/">PDL&nbsp;-&nbsp;Perl&nbsp;Data&nbsp;Language</a>,
+<a href="http://www.r-project.org/">R</a>,
+<a href="http://www.scilab.org/">Scilab</a>,
+<a href="http://www.scipy.org/">SciPy</a>,
+<a href="http://yorick.sourceforge.net/">Yorick</a> ...
+</p>
+
+<h2>Feature summary</h2>
+
+<p>Full syntax compatibility with IDL up to version 7.1 (for &gt;8.0 see below):</p>
+
+<ul>
+    <li>objects, pointers, structs and arrays,</li>
+    <li>system, common block and assoc variables,</li>
+    <li>all operators and datatypes,</li>
+    <li>_EXTRA, _STRICT_EXTRA and _REF_EXTRA keywords...</li>
+</ul>
+
+<p>Supported IDL 8.0 language elements:</p>
+
+<ul>
+    <li>FOREACH loop</li>
+    <li>negative array indices</li>
+    <li>garbage collection pointers and objects</li>
+    <li>call methods on an object using "." (e. g. object.aMemberProcedure,arg1)</li>
+</ul>
+
+<p>The file input output system is fully implemented<br/>
+(Exception: For formatted I/O the C() sub-codes are not supported yet)</p>
+
+<p>Supported file formats include:</p>
+<ul>
+  <li>netCDF 3 (read/write)</li>
+  <li>HDF4 (read/write)</li>
+  <li>HDF5 (read-only, limited support)</li>
+  <li>IDL SAVE files (supported using the Craig Markwardt's <a href="http://cow.physics.wisc.edu/~craigm/idl/down/cmsvlib.tar.gz">CMSVLIB</a>)</li>
+  <li>FITS files, when Astro Lib. is in the path (<a href="http://www.cv.nrao.edu/fits/data/tests/pg93/NRAO pg93"> test suite</a> OK)</li>
+  <li>various graphic formats (e.g. PNG if compiled with ImageMagick)</li>
+  <li>...</li>
+</ul>
+
+<p>
+Graphical output is partially implemented. The PLOT, OPLOT, PLOTS,
+ XYOUTS, CONTOUR, SURFACE, TVRD and TV commands
+(along with WINDOW, WDELETE, SET_PLOT, WSET, TVLCT) work 
+(important keywords, some !P
+system variable tags and multi-plots are supported) 
+for X windows, z-buffer and postscript output.
+</p>
+
+<p>GUI support (widgets) is officially provided since the 0.9 version (but it's not complete yet).</p>
+ 
+<?php require('_footer.inc.php'); ?>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/menu.html gdl/doc/www/menu.html
--- gdl-0.9.3/doc/www/menu.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/menu.html	2013-02-25 17:04:23.555185347 -0700
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL ::. menu</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/index.php"/>
+  </head>
+  <body>
+  </body>
+</html>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/_news.inc.php gdl/doc/www/_news.inc.php
--- gdl-0.9.3/doc/www/_news.inc.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/_news.inc.php	2013-02-25 17:04:23.430185858 -0700
@@ -0,0 +1,48 @@
+<h2>GDL 0.9.3 released</h2>
+<p>
+  2013-01-05: <a href="http://packages.debian.org/experimental/gnudatalanguage">Debian port updated</a><br />
+  2013-01-02: <a href="http://sources.gentoo.org/cgi-bin/viewvc.cgi/gentoo-x86/dev-lang/gdl/">Gentoo port updated</a><br />
+  2013-01-01: <a href="http://www.freshports.org/science/gnudatalanguage/">FreeBSD port updated</a><br />
+  2012-12-28: <a href="https://aur.archlinux.org/packages.php?ID=2493">ArchLinux package updated</a><br />
+  2012-12-28: <a href="http://www.rpmfind.net/linux/rpm2html/search.php?query=config(gdl)">Fedora package updated</a><br />
+  2012-12-27: GDL 0.9.3 source tarball released.<br />
+  <span class="align-right"><a href="http://sourceforge.net/projects/gnudatalanguage/files/gdl/0.9.3/README/download">release notes</a> | <a href="downloads.php">downloads</a></span>
+</p>
+
+<h2>GDL 0.9.2 released</h2>
+<p>
+  2012-02-20: Ubuntu package updated<br />
+  2011-12-27: Gentoo package updated<br />
+  2011-11-16: Fink package updated<br />
+  2011-11-15: Debian package updated<br />
+  2011-11-14: Macports port updated<br />
+  2011-11-13: HMUG package updated<br />
+  2011-11-13: FreeBSD port updated<br />
+  2011-11-12: ArchLinux package updated<br />
+  2011-11-11: Fedora package updated<br />
+  2011-11-09: GDL 0.9.2 source tarball released.<br />
+  <span class="align-right"><a href="http://sourceforge.net/projects/gnudatalanguage/files/gdl/0.9.2/README/download">release notes</a> | <a href="downloads.php">downloads</a></span>
+</p>
+
+<h2>GDL @ADASS XXI</h2>
+<p>2011-11-09: <a href="http://aramis.obspm.fr/~coulais/IDL_et_GDL/Adass2011/slides_ADASS2011_GDL_Coulais.pdf">GDL talk</a> and <a href="http://aramis.obspm.fr/~coulais/IDL_et_GDL/Adass2011/O11_ADASS2011_GDL_Coulais.pdf">GDL paper</a> at the <a href="http://www.eso.org/sci/meetings/2011/adass2011.html">ADASS XXI</a> in Paris</p>
+
+<h2>GDL @GHM2011</h2>
+<p>2011-08-27: <a href="http://www.igf.fuw.edu.pl/~slayoo/gdl-ghm2011paris.pdf">GDL talk</a> at the <a href="http://www.gnu.org/ghm/2011/paris/">GHM</a> in Paris</p>
+
+<h2>New website</h2>
+<p>2011-07-07: We have new website!</p>
+
+<h2>GDL 0.9.1 released</h2>
+<p>
+  2011-07-02: Macports port updated<br />
+  2011-04-19: Fink package updated<br />
+  2011-04-08: HMUG package updated<br />
+  2011-04-08: Gentoo package updated<br />
+  2011-04-06: FreeBSD port updated<br />
+  2011-04-02: ArchLinux package updated<br />
+  2011-03-31: Debian/Ubuntu package updated<br />
+  2011-03-30: Fedora package updated<br />
+  2011-03-29: GDL 0.9.1 source tarball released.
+  <span class="align-right"><a href="http://sourceforge.net/projects/gnudatalanguage/files/gdl/0.9.1/gdl-0.9.1.relnotes/download">release notes</a> | <a href="downloads.php">downloads</a></span>
+</p>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/require.html gdl/doc/www/require.html
--- gdl-0.9.3/doc/www/require.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/require.html	2013-02-25 17:04:23.561185323 -0700
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL requirements</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/requirements.php"/>
+  </head>
+  <body>
+  </body>
+</html>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/requirements.php gdl/doc/www/requirements.php
--- gdl-0.9.3/doc/www/requirements.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/requirements.php	2011-09-20 09:46:45.000000000 -0600
@@ -0,0 +1,86 @@
+<?php require('_header.inc.php'); ?>
+			
+<h2>Requirements</h2>
+
+<p>Obligatory libraries:</p>
+<ul>
+    <li><a href="http://plplot.sourceforge.net/">plplot</a></li>      
+    <li><a href="http://www.gnu.org/software/gsl">gsl</a></li>         
+    <li><a href="http://tiswww.case.edu/php/chet/readline/rltop.html">readline</a></li>
+</ul>    
+
+<p>Optional libraries:</p>
+<ul>
+    <li>Xlib (part of any X11 distribution; needed for ploting on screens !)</li>
+    <li><a href="http://www.imagemagick.org/Magick++/">Magick++</a> (ImageMagick's C++ API; PNG and JPEG support)</li>   
+    <li><a href="http://www.fftw.org/">FFTW</a> (both float and double versions needed; faster than FFT code provide by the GSL for 2^N 3^M 5^O cases)</li>
+    <li><a href="http://www.unidata.ucar.edu/software/netcdf/">netCDF</a> (v3 or v4)</li>   
+    <li><a href="http://www.hdfgroup.org/products/hdf4/">HDF4</a></li>
+    <li><a href="http://www.hdfgroup.org/HDF5/">HDF5</a></li>
+    <li><a href="http://www.ecmwf.int/products/data/software/grib_api.html">GRIB API</a></li>
+    <li><a href="http://www.unidata.ucar.edu/software/udunits/">UDUNITS-2</a></li>
+    <li><a href="http://www.wxwidgets.org/">wxWidgets</a></li>
+    <li><a href="http://home.comcast.net/~gevenden56/proj/">libproject</a> (mapping on Earth)</li>
+    <li><a href="ftp://ftp.soest.hawaii.edu/pwessel/gshhs/">GSHHS</a> (see GDL's <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/MAP_INSTALL">MAP_INSTALL</a> file)</li>
+    <li><a href="http://pslib.sourceforge.net/">pslib</a> (fine-tuning PostScript output)</li>
+</ul>
+
+<p>The Python interface (see <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/PYTHON.txt">PYTHON.txt</a>) requires:</p>
+<ul>
+    <li><a href="http://www.python.org/">Python</a></li>   
+    <li><a href="http://numpy.scipy.org/">Numpy</a></li>
+</ul>
+
+<p>Useful IDL/GDL-written libraries:</p>
+<ul>
+    <li><a href="http://cow.physics.wisc.edu/~craigm/idl/cmsave.html">CMSVLIB</a> (for SAVE and RESTORE)</li>
+    <li><a href="http://cow.physics.wisc.edu/~craigm/idl/fitting.html">MPFIT</a> (fitting)</li>
+    <li><a href="http://idlastro.gsfc.nasa.gov/">Astron Lib</a> (FITS format I/O, astronomy-related procedures)</li>
+    <li><a href="http://physics.mnstate.edu/craig/textoidl/">TeXtoIDL</a> (Greek letters, special symbols, sub/superscripts via TeX commands)</li>
+</ul>
+
+<p>At least g++ 3.2 (or a similar C++ standard conforming
+compiler) is needed for compiling GDL. 
+<!--Note that problems were reported with following versions of g++:
+</p>
+<ul>
+  <li>g++ 3.3.1 (problems with static casts)</li>
+  <li>g++ 3.3.5 (buggy nested templates)</li>
+  <li>g++ 3.3 build 1671 shipped with OS X</li>
+</ul>
+<p>
+-->
+Succesfull compilations were reported with Intel C++ compiler and numerous versions
+of GCC including the 3.x and 4.x families, on various UNIX environments including
+Linux, Mac OS X, FreeBSD, OpenSolaris, Cygwin and OpenBSD. 
+GCC &gt;= 4.2 is needed for OpenMP.
+</p>
+
+<p>The <a href="http://ftp.gnu.org/pub/gnu/readline/readline-5.0.tar.gz">GNU readline</a>
+library 4.3 or later is needed (GDL should compile
+without it, but it's very inconvenient to use that way, furthermore,
+proper event handling for graphic windows requires readline).<br/>
+OS X 10.4: Note that the the readline library which comes with OS X is <b>
+not</b> GNU readline. You need to install GNU readline and set the --with-readlinedir=DIR option to configure.
+</p>
+
+<p>
+  GDL supports compilation using both the shipped autotools "configure" script as well as using CMake.
+  Consult the <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/README">README</a> 
+  and the <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/INSTALL">INSTALL</a> 
+  files in the GDL distribution for further details on GDL requirements and configuration.
+</p>
+
+<p>GDL was developed using <a href="http://www.antlr2.org">ANTLR v2</a> 
+but unless you want to change the grammar (*.g files) you don't need
+ANTLR. All relevant ANTLR files are included in the package.<br/>
+</p>
+
+<!--
+<p>GDL is currently developed using <a href="http://www.kdevelop.org">KDevelop</a> 
+3.5.1 under the GNU/Linux distribution Kubuntu. The KDevelop project file is included in the tarball, so if you
+have KDevelop you should be able to use it with GDL seamlessly.</p>
+-->
+
+ 
+<?php require('_footer.inc.php'); ?>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/resources.html gdl/doc/www/resources.html
--- gdl-0.9.3/doc/www/resources.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/resources.html	2013-02-25 17:04:23.590185209 -0700
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL Resources</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/resources.php"/>
+  </head>
+  <body>
+  </body>
+</html>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/resources.php gdl/doc/www/resources.php
--- gdl-0.9.3/doc/www/resources.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/resources.php	2013-02-25 17:04:23.595185184 -0700
@@ -0,0 +1,124 @@
+<?php require('_header.inc.php'); ?>
+
+<h2><a href="index.html">GDL resources</a></h2>
+
+<p>
+  A <a href="documentation.php">draft of GDL documentation</a> is currently under development.
+</p>
+
+<p>
+  There were several talks and posters on GDL prepared by the project team:
+</p>
+<ul>
+  <li><a href="http://aramis.obspm.fr/~coulais/IDL_et_GDL/Adass2011/slides_ADASS2011_GDL_Coulais.pdf">talk @ ADASS 2011</a> by Alain Coulais</li> (no definitive version of the <a href="http://aramis.obspm.fr/~coulais/IDL_et_GDL/Adass2011/O11_ADASS2011_GDL_Coulais.pdf">corresponding paper</a>)
+  <li><a href="http://www.igf.fuw.edu.pl/~slayoo/gdl-ghm2011paris.pdf">talk @ GHM 2011</a> by Alain Coulais &amp; Sylwester Arabas</li>
+  <li><a href="http://www.igf.fuw.edu.pl/~slayoo/gdl-fosdem-2011-talk.pdf">talk @ FOSDEM 2011</a> by Sylwester Arabas</li>
+  <li><a href="http://www.igf.fuw.edu.pl/~slayoo/prezentacja-jamstec-20100820.pdf">talk/tutorial at The Earth Simulator Center</a> by Alain Coulais, Sylwester Arabas &amp; Takeshi Enomoto</li>
+  <li><a href="http://www.igf.fuw.edu.pl/~slayoo/gdl-poster-egu2010.pdf">poster @ EGU 2010</a> by Sylwester Arabas</li>
+  <li><a href="http://aramis.obspm.fr/~coulais/IDL_et_GDL/ADASS09_GDL_Coulais.pdf">talk @ ADASS 2009</a> by Alain Coulais</li>
+  <li><a href="http://2007.rmll.info/IMG/pdf/RMLL07Sc_GDL_ACoulais.pdf">talk @ RMLL 2007</a> by Alain Coulais</li>
+</ul>
+
+<p>
+  The ADASS talks have corresponding papers in the ASP Conference Series (and&nbsp;in&nbsp;arXiv), and this is currently the best way to cite GDL:
+</p>
+<ul>
+
+<li><a href="http://www.aspbooks.org/a/volumes/article_details?paper_id=34743">Coulais et al. 2012 @ ACP CS 461
+ (ISBN: 978-1-58381-804-6)</a>
+(no definitive version of the <a href="http://aramis.obspm.fr/~coulais/IDL_et_GDL/Adass2011/O11_ADASS2011_GDL_Coulais.pdf">corresponding paper</a>)
+<a href="http://cdsads.u-strasbg.fr/abs/2012ASPC..461..615C">ADS link</a> with abstract</li>
+</li>
+  <li><a href="http://www.aspbooks.org/a/volumes/article_details/?paper_id=32122">Coulais et al. 2010 @ ACP CS 434
+(ISBN: 978-1-58381-748-3)</a>
+(no definitive version of the <a href="http://arxiv.org/abs/1101.0679">corresponding paper</a>) 
+<a href="http://cdsads.u-strasbg.fr/abs/2010ASPC..434..187C">ADS link</a> with abstract</li>
+</ul>
+
+<p>
+  Alain Coulais maintains:
+</p>
+  <ul>
+    <li><a href="https://sympa.obspm.fr/wws/info/gdl-announces">a mailing list with announces about GDL</a></li>
+    <li><a href="http://aramis.obspm.fr/~coulais/IDL_et_GDL/memo_GDL.html">a constantly updated memo about GDL (in French)</a></li>
+    <li><a href="http://aramis.obspm.fr/~coulais/IDL_et_GDL/Matrice_IDLvsGDL.html">a list of IDL routines versus GDL availability</a> (see also <a href="documentation.php">the docs</a>)</li>
+  </ul>
+
+<p>
+  Several people prepared scholarly materials using or mentioning GDL:
+</p>
+  <ul>
+    <li><a href="http://www.ita.uni-heidelberg.de/~dullemond/lectures/num_fluid_2009/index.shtml">A series of lectures on numerical hydrodynamics including ''IDL / GDL Micro-manual and exercises''</a></li>
+    <li><a href="http://blog.redbranch.net/series/gdl-gnu-data-language/">A series of blog posts on GDL (installation, usage, code examples)</a></li>
+    <li><a href="http://www.sgeier.net/tools/GDL-intro.pdf">Getting started with GDL</a> by Sven Geier (2006)</li>
+    <li><a href="http://solar.physics.montana.edu/clowder/IDL/idlguide.pdf">Interactive Data Language Guide</a> by Chris Lowder (2010)</li>
+    <li><a href="http://www.igf.fuw.edu.pl/~slayoo/mpdm2009/">A course in meteo data processing in GDL</a> by Sylwester Arabas (2009, slides in Polish)</li>
+    <li><a href="http://www.igf.fuw.edu.pl/~slayoo/mpdm2008/">A course in meteo data processing in GDL</a> by Sylwester Arabas (2008, slides in Polish)</li>
+  </ul>
+
+<p>
+  Some uses of GDL were documented by the users:
+</p>
+  <ul>
+    <li>article ''<a href="http://arxiv.org/abs/1004.1507">Scalelength of disc galaxies</a>'' by Fathi et al. mentioning use of GDL</li>
+    <li>article ''<a href="http://arxiv.org/abs/0903.2056">Detection of VHE Gamma Radiation from the Pulsar Wind Nebula MSH 15-52 with H.E.S.S.</a>'' by Frank Breitling mentioning use of GDL</li>
+    <li>article ''<a href="http://arxiv.org/abs/0903.2979">ULySS: A Full Spectrum Fitting Package</a>'' by Koleva et al. mentioning GDL</li>
+    <li>article ''<a href="http://arxiv.org/abs/1004.4506v3">On the suspected timing error in WMAP map-making</a>'' by Boudewijn Roukema mentioning use of GDL</a> 
+    <li><a href="http://www.nvidia.com/content/GTC/posters/89_Cheung_GPU_Acceleration_of_the_Scientific_Data.pdf">GPU Acceleration of the Scientific Data Analysis Package GDL</a> by A. Jaffey, A. Kobashi and M. C. M. Cheung (AGU poster)</li>
+    <li><a href="http://esoads.eso.org/abs/2008AGUFMIN13A1062J">Online data analysis using Web GDL</a> by Jaffey, A., Cheung, M. &amp; Kobashi, A. (AGU abstract)</li>
+    <li><a href="http://healpix.jpl.nasa.gov/html/install.htm">HEALPix Facility Installation Guidelines</a>(including a section on GDL compatibility)</li>
+    <li><a href="http://www-astro.physics.ox.ac.uk/~mxc/idl/">Michele Cappellari IDL (and free GDL) Programs</a></li>
+    <li><a href="http://idlastro.gsfc.nasa.gov/idlfaq.html">The IDL Astronomy Library FAQ</a> (including a note on GDL)</li>
+    <li><a href="http://hesperia.gsfc.nasa.gov/colinux/">Using the GNU Data Language (GDL) on Windows in a Cooperative Linux (coLinux) Environment</a> by Merrick Berg (2006)</li>
+  </ul>
+
+<h2><a href="index.html">IDL resources</a></h2>
+
+<p>As GDL is almost 100% compatible to IDL (although not complete as many
+subroutines are waiting to be implemented), resources for IDL can also
+be utilized for GDL.</p>
+ 
+<p>
+Many IDL resources can be found on the pages run by IDL gurus: <a href="http://www.idlcoyote.com/">David Fanning</a>
+  and <a href="http://michaelgalloy.com/">Michael Galloy</a>,
+  and at the <a href="http://groups.google.com/group/comp.lang.idl-pvwave">comp.lang.idl-pvwave</a> usenet group.
+
+</p>
+<!--
+<p>
+Lots of routines written for IDL can be found with the
+<a href="http://www.astro.washington.edu/deutsch/idl/htmlhelp/"
+target="_self">IDL Libraries Browser</a> many of them should also
+work with GDL.
+</p>
+-->
+
+<p>
+IDL 6.4 documentation is published at the <a href="http://idlastro.gsfc.nasa.gov/idl_html_help/home.html">NASA website</a>.
+Documentation for the current version of IDL is available for download from the <a href="http://ittvis.com">ITTVIS website</a>.
+</p>
+
+<p>
+An IDL online tutorial is available at the Scientific Computing and
+Visualization <a href="http://www.bu.edu/tech/research/training/tutorials/idl/">website</a>.
+</p>
+
+<p>
+<a href="http://www.mpia.de/imprs-hd/documents/IDLGuide.pdf">A (very) quick guide to IDL</a> was written by Chris North.
+</p>
+
+<p>
+Robert da Silva maintains the <a href="http://slugidl.pbworks.com/w/page/28913065/A-Slug's-Guide-to-IDL">Slug's Guide to IDL</a>.
+</p>
+
+<p>
+Mark Piper maintains the <a href="http://idldatapoint.com/">The IDL Data Point</a>.
+</p>
+
+<p>
+For writing programs in GDL using <a href="http://www.gnu.org/software/emacs/">Emacs</a> the Emacs addon (mode) 
+<a href="http://www.idlwave.org/">IDLWAVE</a>, maintained
+by J.D. Smith is highly appreciated. <a href="http://www.vim.org/">Vim</a> support IDL/GDL syntax highlighting by default.
+</p>
+
+<?php require('_footer.inc.php'); ?>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/screenshot.html gdl/doc/www/screenshot.html
--- gdl-0.9.3/doc/www/screenshot.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/screenshot.html	2013-02-25 17:04:23.643184981 -0700
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL ::. Screenshots</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/screenshots.php"/>
+  </head>
+  <body>
+  </body>
+</html>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/screenshots/make_thumbnails gdl/doc/www/screenshots/make_thumbnails
--- gdl-0.9.3/doc/www/screenshots/make_thumbnails	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/screenshots/make_thumbnails	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,4 @@
+rm *_thumb.png
+for i in *.png; do 
+  convert $i -thumbnail 250x400 -unsharp 0x.5 `basename $i .png`_thumb.png
+done
Binary files gdl-0.9.3/doc/www/screenshots/screenshot01.png and gdl/doc/www/screenshots/screenshot01.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot01_thumb.png and gdl/doc/www/screenshots/screenshot01_thumb.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot02.png and gdl/doc/www/screenshots/screenshot02.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot02_thumb.png and gdl/doc/www/screenshots/screenshot02_thumb.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot03.png and gdl/doc/www/screenshots/screenshot03.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot03_thumb.png and gdl/doc/www/screenshots/screenshot03_thumb.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot04.png and gdl/doc/www/screenshots/screenshot04.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot04_thumb.png and gdl/doc/www/screenshots/screenshot04_thumb.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot05.png and gdl/doc/www/screenshots/screenshot05.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot05_thumb.png and gdl/doc/www/screenshots/screenshot05_thumb.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot06.png and gdl/doc/www/screenshots/screenshot06.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot06_thumb.png and gdl/doc/www/screenshots/screenshot06_thumb.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot07.png and gdl/doc/www/screenshots/screenshot07.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot07_thumb.png and gdl/doc/www/screenshots/screenshot07_thumb.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot08.png and gdl/doc/www/screenshots/screenshot08.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot08_thumb.png and gdl/doc/www/screenshots/screenshot08_thumb.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot09.png and gdl/doc/www/screenshots/screenshot09.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot09_thumb.png and gdl/doc/www/screenshots/screenshot09_thumb.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot10.png and gdl/doc/www/screenshots/screenshot10.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot10_thumb.png and gdl/doc/www/screenshots/screenshot10_thumb.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot11.png and gdl/doc/www/screenshots/screenshot11.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot11_thumb.png and gdl/doc/www/screenshots/screenshot11_thumb.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot12.png and gdl/doc/www/screenshots/screenshot12.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot12_thumb.png and gdl/doc/www/screenshots/screenshot12_thumb.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot13.png and gdl/doc/www/screenshots/screenshot13.png differ
Binary files gdl-0.9.3/doc/www/screenshots/screenshot13_thumb.png and gdl/doc/www/screenshots/screenshot13_thumb.png differ
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/screenshots.php gdl/doc/www/screenshots.php
--- gdl-0.9.3/doc/www/screenshots.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/screenshots.php	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,125 @@
+<?php require('_header.inc.php'); ?>
+
+<h2><a href="index.html">Screenshots</a></h2>
+
+<table cellspacing="10">
+
+  <tr>
+    <td>
+      <a href="screenshots/screenshot01.png">
+        <img src="screenshots/screenshot01_thumb.png" alt="GDL drawing fractals" /> 
+      </a>
+      <br />
+      GDL rendering the Mandelbrot set. Screenshot generated using the APPLEMAN procedure
+      (included in GDL distribution, file: src/pro/appleman.pro)
+    </td>
+    <td>
+      <a href="screenshots/screenshot02.png">
+        <img src="screenshots/screenshot02_thumb.png" alt="GDL compressing weather-radar data using wavelet transform" /> 
+      </a>
+      <br />
+      GDL compressing weather-radar images using truncated wavelet approximation.
+    </td>
+  </tr>
+
+  <tr>
+    <td>
+      <a href="screenshots/screenshot03.png">
+        <img src="screenshots/screenshot03_thumb.png" alt="GDL run via a web interface" /> 
+      </a>
+      <br />
+      GDL used as a part of a web-interface for controlling 2D fluid flow simulation and 
+      visualizing the output (reading netCDF files and outputting SVG plots).
+    </td>
+    <td>
+      <a href="screenshots/screenshot04.png">
+        <img src="screenshots/screenshot04_thumb.png" alt="GDL plotting data from a MODIS HDF file" /> 
+      </a>
+      <br />
+      GDL plotting data from a HDF file with MODIS satellite image.
+    </td>
+  </tr>
+
+  <tr>
+    <td>
+      <a href="screenshots/screenshot05.png">
+        <img src="screenshots/screenshot05_thumb.png" alt="GDL used for demonstrating Kalman filtering" /> 
+      </a>
+      <br />
+      GDL used for demonstrating Kalman filtering.
+    </td>
+    <td>
+      <a href="screenshots/screenshot06.png">
+        <img src="screenshots/screenshot06_thumb.png" alt="GDL-generated PostScript plot of a Fourier tranform in a LaTeX-generated PDF file" /> 
+      </a>
+      GDL-generated PostScript plot of a Fourier spectrum in a LaTeX-generated PDF file.
+    </td>
+  </tr>
+
+  <tr>
+    <td>
+      <a href="screenshots/screenshot07.png">
+        <img src="screenshots/screenshot07_thumb.png" alt="GDL plotting weather-forecast map from a GRIB file with the GFS model output" /> 
+      </a>
+      <br />
+      GDL plotting weather-forecast map from a GRIB file with NOAA GFS model output.
+    </td>
+    <td>
+      <a href="screenshots/screenshot08.png">
+        <img src="screenshots/screenshot08_thumb.png" alt="GDL plotting Daubechies wavelet to an SVG file under OpenSolaris" /> 
+      </a>
+      <br />
+      GDL plotting Daubechies wavelet to an SVG file under OpenSolaris.
+    </td>
+  </tr>
+
+  <tr>
+    <td>
+      <a href="screenshots/screenshot09.png">
+        <img src="screenshots/screenshot09_thumb.png" alt="GDL writing a surface plot to a PNG file under Cygwin on Windows" /> 
+      </a>
+      <br />
+      GDL writing a surface plot to a PNG file under Cygwin on Windows (by Mateusz Turcza).
+    </td>
+    <td>
+      <a href="screenshots/screenshot10.png">
+        <img src="screenshots/screenshot10_thumb.png" alt="GDL rendering the Madnelbrot set in an X window under coLinux on Windows" /> 
+      </a>
+      <br />
+      GDL rendering the Mandelbrot set in an X window under coLinux on Windows (<a href="http://hesperia.gsfc.nasa.gov/colinux/" >by Merrick Berg</a>).
+    </td>
+  </tr>
+  <tr>
+    <td>
+      <a href="screenshots/screenshot11.png">
+        <img src="screenshots/screenshot11_thumb.png" alt="GDL rendering two HST images of Saturn (FITS files read with
+							   Astron Lib) on Mandriva Linux 2009" /> 
+      </a>
+      <br />
+      GDL rendering two HST images of <a href="http://fr.wikipedia.org/wiki/Aurore_polaire">Polar Aurorae</a> on Saturn in UV
+      taken with STIS camera (by <a href="http://www.lesia.obspm.fr/Sur-les-autres-planetes-du-systeme.html">Palier and Prange</a>, 1999) (FITS files read with
+      <a href="http://idlastro.gsfc.nasa.gov/">Astron Lib</a>) on <a href="http://mandriva.com/">Mandriva Linux 2009</a>.
+    </td>
+    <td>
+      <a href="screenshots/screenshot12.png">
+        <img src="screenshots/screenshot12_thumb.png" alt=""/>
+      </a>
+      <br />
+      GDL used for analyzing <a href="http://en.wikipedia.org/wiki/LIDAR">LIDAR</a> data (reading them from netCDF files, producing PostScript plots) on Linux, using <a href="http://idlwave.org/">the IDLWAVE mode for Emacs</a>. (by Micha&#322; Pi&#261;d&#322;owski)
+    </td>
+  </tr>
+  <tr>
+    <td>
+      <a href="screenshots/screenshot13.png">
+        <img src="screenshots/screenshot13_thumb.png" alt="" />
+      </a>
+      <br />
+      Calling GDL from Python and vice versa (using <a href="http://numpy.scipy.org/">Numpy</a> and <a href="http://matplotlib.sourceforge.net/">matplotlib</a>).
+    </td>
+    <td>&nbsp;
+    </td>
+  </tr>
+  
+</table>
+			
+<?php require('_footer.inc.php'); ?>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/support.html gdl/doc/www/support.html
--- gdl-0.9.3/doc/www/support.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/support.html	2013-02-25 17:04:23.656184938 -0700
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL Support</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/support.php"/>
+  </head>
+  <body>
+  </body>
+</html>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/support.php gdl/doc/www/support.php
--- gdl-0.9.3/doc/www/support.php	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/support.php	2011-07-08 07:06:48.000000000 -0600
@@ -0,0 +1,59 @@
+<?php require('_header.inc.php'); ?>
+
+<h2><a href="index.html">How to get support?</a></h2>
+<p>
+  If you don't find an answer to your problem in:
+</p>
+  <ul>
+    <li><a href="documentation.php">GDL documentation draft</a></li>
+    <li><a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/">README/INSTALL files</a></li>
+    <li><a href="resources.php">other GDL- and IDL-related resources</a></li>
+  </ul>
+<p>
+  you might use one of these <a href="http://sourceforge.net/tracker/?group_id=97659">trackers</a>
+  or
+  <a href="http://sourceforge.net/projects/gnudatalanguage/forums">forums</a>. 
+</p>
+  
+			
+<h2><a href="index.html">How to provide feedback?</a></h2>
+<p>
+  Your comments are welcome! Let us know what you use GDL for. 
+  Or if you don't, why not. 
+  Which functionality are you missing/would appreciate most for comming versions.
+
+  Please send your bug reports, complaints, suggestions and comments using the
+  <a href="http://sourceforge.net/tracker/?group_id=97659">trackers</a>
+  or
+  <a href="http://sourceforge.net/projects/gnudatalanguage/forums">forums</a>.
+</p>
+
+<h2><a href="index.html">How to contribute?</a></h2>
+<p>
+  GDL is actively developed and has already a lot of functionality.
+  But it is still in beta state as of July 2011.
+  Even though it can already be used for many tasks, there are many
+  things left to be done.<br/>
+  Any contributions are very welcome. Currently contributions can be made in C/C++, GDL and python.
+  See the files 
+  <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/HACKING">HACKING</a>
+  and 
+  <a href="http://gnudatalanguage.cvs.sourceforge.net/viewvc/gnudatalanguage/gdl/PYTHON.txt">PYHTON.txt</a>
+  in the GDL root directory.
+</p>
+
+<p>Urgent things to do are:</p>
+<ul>
+  <li>Library functions and procedures</li>
+  <li>Documentation and code examples</li>
+  <li>Completing the graphical output system</li>
+  <li>Testing and test routines written in GDL</li>
+  <li>Enhancing the GUI (widget) functionality</li>
+  <li>Porting GDL to other platforms</li>
+</ul>
+
+<p>
+  Please send your contributions using the <a href="http://sourceforge.net/tracker/?group_id=97659">trackers</a>.
+</p>
+
+<?php require('_footer.inc.php'); ?>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/doc/www/tdl.html gdl/doc/www/tdl.html
--- gdl-0.9.3/doc/www/tdl.html	1969-12-31 17:00:00.000000000 -0700
+++ gdl/doc/www/tdl.html	2013-02-25 17:04:23.662184911 -0700
@@ -0,0 +1,9 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+  <head>
+    <title>GDL -TDL</title>
+    <meta http-equiv="REFRESH" content="0;url=http://gnudatalanguage.sf.net/index.php"/>
+  </head>
+  <body>
+  </body>
+</html>
Only in gdl-0.9.3: gdl.kdev4
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/gdl.kdevelop gdl/gdl.kdevelop
--- gdl-0.9.3/gdl.kdevelop	1969-12-31 17:00:00.000000000 -0700
+++ gdl/gdl.kdevelop	2010-03-26 16:55:40.000000000 -0600
@@ -0,0 +1,285 @@
+<?xml version = '1.0'?>
+<kdevelop>
+  <general>
+    <author>Marc Schellens</author>
+    <email>m_schellens@users.sourceforge.net</email>
+    <version>0.9</version>
+    <projectmanagement>KDevAutoProject</projectmanagement>
+    <primarylanguage>C++</primarylanguage>
+    <keywords>
+      <keyword>C++</keyword>
+      <keyword>Code</keyword>
+    </keywords>
+    <projectdirectory>.</projectdirectory>
+    <absoluteprojectpath>false</absoluteprojectpath>
+    <description></description>
+    <ignoreparts/>
+    <secondaryLanguages>
+      <language>Python</language>
+    </secondaryLanguages>
+    <versioncontrol/>
+    <projectname>gdl</projectname>
+    <defaultencoding></defaultencoding>
+  </general>
+  <kdevautoproject>
+    <general>
+      <activetarget>src/gdl</activetarget>
+      <useconfiguration>debug</useconfiguration>
+      <useactivetarget>true</useactivetarget>
+    </general>
+    <run>
+      <mainprogram>/home/marc/gdl/debug/src/gdl</mainprogram>
+      <terminal>false</terminal>
+      <directoryradio>executable</directoryradio>
+      <customdirectory>/</customdirectory>
+      <programargs></programargs>
+      <autocompile>true</autocompile>
+      <envvars/>
+      <runarguments>
+        <gdl/>
+      </runarguments>
+      <globaldebugarguments></globaldebugarguments>
+      <globalcwd>/home/marc/gdl/debug/src</globalcwd>
+      <useglobalprogram>true</useglobalprogram>
+      <autoinstall>false</autoinstall>
+      <autokdesu>false</autokdesu>
+    </run>
+    <configurations>
+      <optimized>
+        <builddir>optimized</builddir>
+        <ccompiler>kdevgccoptions</ccompiler>
+        <cxxcompiler>kdevgppoptions</cxxcompiler>
+        <f77compiler>kdevg77options</f77compiler>
+        <cxxflags>-O2 -DNDEBUG -msse3 -mfpmath=sse,387</cxxflags>
+        <envvars/>
+        <configargs>--enable-debug=full --with-netcdf=no --with-python=no --with-hdf=no --with-hdf5=no --with-plplot=/usr --with-python=no --disable-python_module --with-wxWidgets=no --with-Magick=yes --enable-oldplplot</configargs>
+        <topsourcedir/>
+        <cppflags/>
+        <ldflags/>
+        <ccompilerbinary/>
+        <cxxcompilerbinary/>
+        <f77compilerbinary/>
+        <cflags/>
+        <f77flags/>
+      </optimized>
+      <debug>
+        <configargs>--with-readlinedir=yes --with-hdf=yes --with-hdf5=yes --with-plplotdir=/usr/local --with-python=yes --disable-python_module --with-netcdf=no --disable-oldplplot --with-openmp=no --with-libproj4=no --with-mpich=/usr/lib/mpich --with-wxWidgets=yes --with-Magick=yes</configargs>
+        <builddir>debug</builddir>
+        <ccompiler>kdevgccoptions</ccompiler>
+        <cxxcompiler>kdevgppoptions</cxxcompiler>
+        <f77compiler>kdevg77options</f77compiler>
+        <cxxflags>-O0 -g3</cxxflags>
+        <topsourcedir></topsourcedir>
+        <cppflags></cppflags>
+        <ldflags></ldflags>
+        <ccompilerbinary></ccompilerbinary>
+        <cxxcompilerbinary></cxxcompilerbinary>
+        <f77compilerbinary></f77compilerbinary>
+        <cflags></cflags>
+        <f77flags></f77flags>
+        <envvars/>
+      </debug>
+      <default>
+        <configargs>--with-python=yes --with-hdf=no --with-hdf5=no --with-netcdf=/usr/local --disable-python_module</configargs>
+        <builddir>default</builddir>
+        <topsourcedir/>
+        <cppflags/>
+        <ldflags>-pg</ldflags>
+        <ccompiler>kdevgccoptions</ccompiler>
+        <cxxcompiler>kdevgppoptions</cxxcompiler>
+        <f77compiler>kdevg77options</f77compiler>
+        <ccompilerbinary/>
+        <cxxcompilerbinary/>
+        <f77compilerbinary/>
+        <cflags/>
+        <cxxflags>-O3 -g3 -DNDEBUG</cxxflags>
+        <f77flags/>
+        <envvars/>
+      </default>
+    </configurations>
+    <make>
+      <envvars>
+        <envvar value="1" name="WANT_AUTOCONF_2_5" />
+        <envvar value="1" name="WANT_AUTOMAKE_1_6" />
+      </envvars>
+      <abortonerror>true</abortonerror>
+      <numberofjobs>2</numberofjobs>
+      <dontact>false</dontact>
+      <makebin></makebin>
+      <prio>0</prio>
+      <runmultiplejobs>true</runmultiplejobs>
+    </make>
+  </kdevautoproject>
+  <kdevdoctreeview>
+    <ignoretocs>
+      <toc>ada</toc>
+      <toc>ada_bugs_gcc</toc>
+      <toc>bash</toc>
+      <toc>bash_bugs</toc>
+      <toc>clanlib</toc>
+      <toc>w3c-dom-level2-html</toc>
+      <toc>fortran_bugs_gcc</toc>
+      <toc>gnome1</toc>
+      <toc>gnustep</toc>
+      <toc>gtk</toc>
+      <toc>gtk_bugs</toc>
+      <toc>haskell</toc>
+      <toc>haskell_bugs_ghc</toc>
+      <toc>java_bugs_gcc</toc>
+      <toc>java_bugs_sun</toc>
+      <toc>kde2book</toc>
+      <toc>opengl</toc>
+      <toc>pascal_bugs_fp</toc>
+      <toc>php</toc>
+      <toc>php_bugs</toc>
+      <toc>perl</toc>
+      <toc>perl_bugs</toc>
+      <toc>python</toc>
+      <toc>python_bugs</toc>
+      <toc>qt-kdev3</toc>
+      <toc>ruby</toc>
+      <toc>ruby_bugs</toc>
+      <toc>sdl</toc>
+      <toc>w3c-svg</toc>
+      <toc>sw</toc>
+      <toc>w3c-uaag10</toc>
+      <toc>wxwindows_bugs</toc>
+    </ignoretocs>
+    <ignoreqt_xml>
+      <toc>Guide to the Qt Translation Tools</toc>
+      <toc>Qt Assistant Manual</toc>
+      <toc>Qt Designer Manual</toc>
+      <toc>Qt Reference Documentation</toc>
+      <toc>qmake User Guide</toc>
+    </ignoreqt_xml>
+    <ignoredoxygen>
+      <toc>KDE Libraries (Doxygen)</toc>
+    </ignoredoxygen>
+    <projectdoc>
+      <userdocDir>html/</userdocDir>
+      <apidocDir>html/</apidocDir>
+    </projectdoc>
+    <ignorekdocs/>
+    <ignoredevhelp/>
+  </kdevdoctreeview>
+  <kdevfilecreate>
+    <filetypes/>
+    <useglobaltypes>
+      <type ext="cpp" />
+      <type ext="h" />
+    </useglobaltypes>
+  </kdevfilecreate>
+  <kdevfileview>
+    <groups>
+      <group pattern="*.g" name="Grammar files" />
+      <group pattern="*.hpp" name="Header files" />
+      <group pattern="*.cpp" name="Source files" />
+      <hidenonprojectfiles>false</hidenonprojectfiles>
+      <hidenonlocation>false</hidenonlocation>
+    </groups>
+    <tree>
+      <hidepatterns>*.o,*.lo,CVS</hidepatterns>
+      <hidenonprojectfiles>false</hidenonprojectfiles>
+      <showvcsfields>false</showvcsfields>
+    </tree>
+  </kdevfileview>
+  <cppsupportpart>
+    <filetemplates>
+      <interfacesuffix>.hpp</interfacesuffix>
+      <implementationsuffix>.cpp</implementationsuffix>
+    </filetemplates>
+  </cppsupportpart>
+  <kdevcppsupport>
+    <codecompletion>
+      <includeGlobalFunctions>true</includeGlobalFunctions>
+      <includeTypes>true</includeTypes>
+      <includeEnums>true</includeEnums>
+      <includeTypedefs>false</includeTypedefs>
+      <automaticCodeCompletion>true</automaticCodeCompletion>
+      <automaticArgumentsHint>true</automaticArgumentsHint>
+      <automaticHeaderCompletion>true</automaticHeaderCompletion>
+      <codeCompletionDelay>250</codeCompletionDelay>
+      <argumentsHintDelay>400</argumentsHintDelay>
+      <headerCompletionDelay>250</headerCompletionDelay>
+      <showOnlyAccessibleItems>false</showOnlyAccessibleItems>
+      <completionBoxItemOrder>0</completionBoxItemOrder>
+      <howEvaluationContextMenu>true</howEvaluationContextMenu>
+      <showCommentWithArgumentHint>true</showCommentWithArgumentHint>
+      <statusBarTypeEvaluation>false</statusBarTypeEvaluation>
+      <namespaceAliases>std=_GLIBCXX_STD;__gnu_cxx=std</namespaceAliases>
+      <processPrimaryTypes>true</processPrimaryTypes>
+      <processFunctionArguments>false</processFunctionArguments>
+      <preProcessAllHeaders>false</preProcessAllHeaders>
+      <parseMissingHeaders>false</parseMissingHeaders>
+      <resolveIncludePaths>true</resolveIncludePaths>
+      <alwaysParseInBackground>true</alwaysParseInBackground>
+      <usePermanentCaching>true</usePermanentCaching>
+      <alwaysIncludeNamespaces>false</alwaysIncludeNamespaces>
+      <includePaths>.;</includePaths>
+      <parseMissingHeadersExperimental>false</parseMissingHeadersExperimental>
+      <resolveIncludePathsUsingMakeExperimental>false</resolveIncludePathsUsingMakeExperimental>
+    </codecompletion>
+    <references/>
+    <creategettersetter>
+      <prefixGet></prefixGet>
+      <prefixSet>set</prefixSet>
+      <prefixVariable>m_,_</prefixVariable>
+      <parameterName>theValue</parameterName>
+      <inlineGet>true</inlineGet>
+      <inlineSet>true</inlineSet>
+    </creategettersetter>
+    <qt>
+      <used>false</used>
+      <version>3</version>
+      <root>/usr/share/qt3</root>
+      <includestyle>3</includestyle>
+      <designerintegration>EmbeddedKDevDesigner</designerintegration>
+      <qmake></qmake>
+      <designer></designer>
+      <designerpluginpaths/>
+    </qt>
+    <splitheadersource>
+      <enabled>false</enabled>
+      <synchronize>true</synchronize>
+      <orientation>Vertical</orientation>
+    </splitheadersource>
+  </kdevcppsupport>
+  <kdevdebugger>
+    <general>
+      <programargs/>
+      <gdbpath></gdbpath>
+      <dbgshell></dbgshell>
+      <configGdbScript></configGdbScript>
+      <runShellScript></runShellScript>
+      <runGdbScript></runGdbScript>
+      <breakonloadinglibs>true</breakonloadinglibs>
+      <separatetty>true</separatetty>
+      <floatingtoolbar>true</floatingtoolbar>
+      <raiseGDBOnStart>false</raiseGDBOnStart>
+    </general>
+    <display>
+      <staticmembers>true</staticmembers>
+      <demanglenames>true</demanglenames>
+      <outputradix>10</outputradix>
+    </display>
+  </kdevdebugger>
+  <kdevdocumentation>
+    <projectdoc>
+      <docsystem/>
+      <docurl/>
+      <usermanualurl/>
+    </projectdoc>
+  </kdevdocumentation>
+  <kdevcvsservice>
+    <recursivewhenupdate>true</recursivewhenupdate>
+    <prunedirswhenupdate>true</prunedirswhenupdate>
+    <createdirswhenupdate>true</createdirswhenupdate>
+    <recursivewhencommitremove>true</recursivewhencommitremove>
+    <revertoptions>-C</revertoptions>
+  </kdevcvsservice>
+  <ctagspart>
+    <customArguments/>
+    <customTagfilePath>/home/marc/gdl/tags</customTagfilePath>
+    <activeTagsFiles/>
+  </ctagspart>
+</kdevelop>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/INSTALL gdl/INSTALL
--- gdl-0.9.3/INSTALL	2012-12-27 09:22:45.000000000 -0700
+++ gdl/INSTALL	2013-02-25 17:04:20.640197236 -0700
@@ -93,6 +93,8 @@
 --with-fftw=DIR        to specify the FFTW directory tree
 --with-fftw=no         to not use FFTW
 
+--with-eigen=DIR       to specify the Eigen3 directory tree
+
 ... and so on for: wxWidgets, hdf, hdf5, fftw, libproj4, python, udunits, 
 grib, GSHHS, and others - see README file for details (REQUIREMENTS section).
 
Only in gdl-0.9.3: install-sh
Only in gdl-0.9.3: .kdev4
Only in gdl-0.9.3: ltmain.sh
Only in gdl-0.9.3: m4
Only in gdl-0.9.3: Makefile
Only in gdl-0.9.3: Makefile.in
Only in gdl-0.9.3: missing
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/NEWS gdl/NEWS
--- gdl-0.9.3/NEWS	2012-12-27 10:55:04.000000000 -0700
+++ gdl/NEWS	2013-02-25 17:04:20.642197228 -0700
@@ -568,3 +568,25 @@
 	     _overloadPlus, _overloadMinus, _overloadBracketsLeftSide,
 	     _overloadBracketsRightSide, _overloadEQ, _overloadNE)
 	   - support for .SKIP [NSteps] command
+
+0.9.4:
+           - large change in various graphic/plotting keywords:
+              - PLOT, OPLOT: All keywords supported except Z and T3D,  Correct handling of log/DATA/NORMAL/DEVICE coordinates and CLIPPING.
+              - PSYMs shapes now identical to IDL's.
+              - PLOTS: idem as above, plus /CONTINUE
+              - XYOUTS: idem as above, one-argument support (XYOUTS,"string"). Enhancement wrt. reference program: color,size,angle,etc of text are vectors.
+              - CONTOUR: Support of all options except ZVALUE, ZAXIS,CELL_FILL, C_ANNOTATIONS, CLOSED, DOWNHILL, IRREGULAR, TRIANGULATION,PATH_***
+                                  Correct implementation of Z, [X,Y], i.e., contours may be skewed, rotated, etc depending on X and Y.
+                                  Better than IDL:
+                                  - a new ZLOG option makes log contours as well.
+                                  - C_ORIENTATION, C_SPACING are also vectors.
+                                  - log axes give better results
+                                  - good contouring of Not-A-Number values in Z and MIN_VALUE/MAX_VALUE
+                                  - CLIPPING ok.
+                                    Automatic limits in some cases still different from IDL.
+              - AXIS and boxes in plots: all [XYZ]TICK[***] options supported except TICKV and a few TICKFORMAT specifics.
+              - CURSOR: full support for CURSOR command, which is interruptible by control-c and has all the options.
+              - Added cursor-related functions TVCRS and command EMPTY. 
+              - Added DEVICE options CURSOR_CROSSHAIR, CURSOR_STANDARD, CURSOR_ORIGINAL and GET/SET_GRAPHICS_FUNCTION (GXoR, GXand, etc). 
+              - Disabled by default the focus in the X11 graphics windows as IDL does and repositioned WINDOWS by default to top-right of screen.
+           - when compiled with Eigen3 library, significant speed improvement in MATRIX_MULTIPLY() (not available now for # operator), especially on multi-cores.
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/README gdl/README
--- gdl-0.9.3/README	2012-12-27 09:22:45.000000000 -0700
+++ gdl/README	2013-02-25 17:04:20.643197224 -0700
@@ -101,6 +101,7 @@
 GSHHS         (consult the MAP_INSTALL file)
 wxWidgets     http://www.wxwidgets.org/
 pslib         http://pslib.sourceforge.net/
+Eigen         http://eigen.tuxfamily.org
 
 Only with python:
 numpy          http://numpy.scipy.org/
@@ -119,6 +120,8 @@
 If installed, the SAVE and RESTORE commands (data only) are
 available through wrapper routines. You get CMSVLIB here: 
 http://cow.physics.wisc.edu/~craigm/idl/down/cmsvlib.tar.gz
+You must add yourself the CMSVLIB path in the GDL_PATH.
+CMSVLIB provides a test suite: please run CMSV_TEST.
 
 At least g++ 3.2 (or a similar C++ standard conforming
 compiler) is needed for compiling GDL.
@@ -144,7 +147,7 @@
 A possible problem was reported:
 On opening more than one window, plplot causes a segmentation fault
 if GDL is compiled with ImageMagick. This happens if plplot uses 
-dynamic drivers .
+dynamic drivers.
 The current solution is to disable dynamic drivers for plplot
 (-DENABLE_DYNDRIVERS=OFF option for cmake).
 Current ubuntu/debian distributions are using dynamic drivers, so plplot
@@ -272,11 +275,18 @@
 library (http://www.unidata.ucar.edu/software/udunits/)
 If you want to use it, use --with-udunits=DIR
 
-GDL supports the GRIB file format - see README_GRIB
+GDL supports the GRIB file format - see README_GRIB (optional)
 
-GDL uses GSHHS to implement MAP_CONTINENTS - see MAP_INSTALL
+GDL uses GSHHS to implement MAP_CONTINENTS - see MAP_INSTALL (optional)
 
-GDL uses pslib for fine-tuning PostScript output.
+GDL uses pslib for fine-tuning PostScript output. (optional)
+
+GDL uses Eigen for fast matrix multiplication. (optional)
+The simpliest way to compile with it is to copy all the header files
+under sub-directory src/Eigen. Another solution is to provide full path
+to the include files (e.g. --with-eigen=/home/toto/Eigen3.1.4/include/eigen3/
+in that case Eigen would have been prepared using:
+cmake . -DCMAKE_INSTALL_PREFIX=/home/toto/Eigen3.1.4/ )
 
 GDL 0.9 was developed using ANTLR 2.7.6,   
 but unless you want to change the grammar (*.g files) you don't need
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/accessdesc.hpp gdl/src/accessdesc.hpp
--- gdl-0.9.3/src/accessdesc.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/accessdesc.hpp	2013-03-25 10:36:38.082971126 -0600
@@ -300,32 +300,32 @@
     SizeT nDot=tag.size();
     SizeT d;
     for( d=0; d<nDot; ++d)
+    {
+      if( ix[d] == NULL)
+      { // loop over all elements
+	if( dStruct[d]->N_Elements() > 1)
+		dim >> dStruct[d]->Dim();
+      }
+      else
       {
-	  if( ix[d] == NULL)
-	  { // loop over all elements
-		  if( dStruct[d]->N_Elements() > 1)
-			  dim >> dStruct[d]->Dim();
-	  }
-	  else
-	  {
-		  ix[d]->SetVariable( dStruct[d]);
-		  if( ix[d]->N_Elements() > 1)
-			  dim >> ix[d]->GetDim();
-	  }
+	ix[d]->SetVariable( dStruct[d]);
+	if( ix[d]->N_Elements() > 1)
+		dim >> ix[d]->GetDim();
       }
-//     dimension topDim;
+    }
+    //     dimension topDim;
     if( ix[d] == NULL)
     { // loop over all elements
-// 	topDim=top->Dim();
-// 	dim >> topDim;
-	dim >> top->Dim();
+    // 	topDim=top->Dim();
+    // 	dim >> topDim;
+	    dim >> top->Dim();
     }
     else
     {
-	ix[d]->SetVariable( top);
-// 	topDim=ix[d]->GetDim();
-// 	dim >> topDim;
-	dim >> ix[d]->GetDim();
+	    ix[d]->SetVariable( top);
+    // 	topDim=ix[d]->GetDim();
+    // 	dim >> topDim;
+	    dim >> ix[d]->GetDim();
     }
   }
   
@@ -364,7 +364,7 @@
 
     BaseGDL* newData;
     // no zeroing, here the new variable is created 
-    // zero only for GDL_PTR and GDL_OBJ (refcounting)
+    // zero only for GDL_PTR and GDL_OBJ (because of ref counting)
     if( top->Type() == GDL_PTR || top->Type() == GDL_OBJ)
       newData=top->New( dim);//, BaseGDL::NOZERO);
     else
@@ -391,7 +391,7 @@
     SizeT rRank=r->Rank();
 
 //     if( rRank > lRank)
-//       throw GDLException(NULL,"Conflicting data structures (rank).",true,false);
+//       throw GDLException(-1,NULL,"Conflicting data structures (rank).",true,false);
 
     SizeT topRank=top->Rank();
 
@@ -408,7 +408,7 @@
       {
 	 // IDL seems to allow a maximum of one rank more for the r-value
 // 	if( rRank > (topRank+1))
-// 	  throw GDLException(NULL,"Conflicting data structures (top-rank).",true,false);
+// 	  throw GDLException(-1,NULL,"Conflicting data structures (top-rank).",true,false);
 
 	// inplace copy to every instance of top
 	// just loop over all top elements and insert (at appropriate indices)
@@ -418,7 +418,7 @@
 	if( r->Type() != top->Type())
 	  {
 	    BaseGDL* rConv = r->Convert2( top->Type(), BaseGDL::COPY);
-	    std::auto_ptr<BaseGDL> conv_guard( rConv);
+	    Guard<BaseGDL> conv_guard( rConv);
 
 	    DoAssign( dStruct[0], rConv);
 	  }
@@ -431,7 +431,7 @@
 	// all dimensions must match here
 	for( SizeT i=0; i<rRank; i++)
 	  if( dim[i] != r->Dim(i))
-	    throw GDLException(NULL,"Conflicting data structures (dim).",true,false);
+	    throw GDLException(-1,NULL,"Conflicting data structures (dim).",true,false);
 
 	// copy only topRank dimensions each time (topElem elements)
 	// topRank is the dim to start the outer loop with
@@ -445,7 +445,7 @@
 	if( r->Type() != top->Type())
 	  {
 	    BaseGDL* rConv = r->Convert2( top->Type(), BaseGDL::COPY);
-	    std::auto_ptr<BaseGDL> conv_guard( rConv);
+	    Guard<BaseGDL> conv_guard( rConv);
 
 	    DoAssign( dStruct[0], rConv);
 	  }
@@ -491,7 +491,7 @@
   void ADRoot( DStructGDL* s, ArrayIndexListT* ix_=NULL) // root
   {
 //     if( s->IsAssoc())
-//       throw GDLException(NULL,"File expression not allowed in this context.",true,false);
+//       throw GDLException(-1,NULL,"File expression not allowed in this context.",true,false);
     propertyAccess = false;
     dStruct.push_back(s);
     ix.push_back(ix_); 
@@ -507,20 +507,27 @@
 // 	// must only have one time property access
 // 	if( propertyAccess)
 // 	{
-// 	  throw GDLException(NULL,"Cannot access tag: "+ tagName+" [of property: "+propertyName+"].",true,false);
+// 	  throw GDLException(-1,NULL,"Cannot access tag: "+ tagName+" [of property: "+propertyName+"].",true,false);
 // 	}
 // 	propertyName = tagName;
 // 	propertyAccess = true;
 // 	return; // no further change
 // 	// hence "Add( SizeT)" will fail next time as well -> no further action here
 //       }
-      throw GDLException(NULL,"Left side of a tag must be a STRUCT: "+tagName);
+      assert( top != NULL);
+      if( top->Type() == GDL_OBJ) 
+	throw GDLException(-1,NULL,"Nested structure references are not allowed with objects. Consider using parentheses: "+tagName);
+      else 
+	throw GDLException(-1,NULL,"Left side of a tag must be a STRUCT: "+tagName);
     }
    
     int t=dStruct.back()->Desc()->TagIndex( tagName);
     if( t == -1) 
-      throw GDLException(NULL,"Tag name: "+tagName+" is undefined for STRUCT.",true,false);
-    
+    {
+      // TODO: Check for call to Get/SetProperty
+      
+      throw GDLException(-1,NULL,"Tag name: "+tagName+" is undefined for STRUCT.",true,false);
+    }
     // call SizeT version
     SizeT tagIx=static_cast<SizeT>(t);
     ADAdd( tagIx);
@@ -532,35 +539,38 @@
     DStructGDL* actTop=dStruct.back();
 
     if( actTop == NULL)
-      throw GDLException(NULL,"Expression must be a STRUCT in this context.",true,false);
+      throw GDLException(-1,NULL,"Expression must be a STRUCT in this context.",true,false);
     
     if( actTop->N_Elements() == 0) // maybe not needed
-      throw GDLException(NULL,"Error struct data empty.",true,false);
+      throw GDLException(-1,NULL,"Error struct data empty.",true,false);
     
     SizeT nTags=actTop->Desc()->NTags();
     
     if( tagN >= nTags)
-      throw GDLException(NULL,"Invalid tag number.",true,false);
+      throw GDLException(-1,NULL,"Invalid tag number.",true,false);
 
+    // TODO: Insert object struct for Get/SetProperty
+    // tagN == -1 (change type to int)?
+      
     top=actTop->GetTag( tagN, 0);
 
     // push struct onto struct stack
-    DStructGDL* newTop;
     if( top->Type() == GDL_STRUCT)
-      newTop = static_cast<DStructGDL*>(top);
+    {
+      DStructGDL* newTop=static_cast<DStructGDL*>(top);
+      dStruct.push_back( newTop);
+    }
     else
-      newTop = NULL;
-
-    //    if( newTop != NULL) dStruct.push_back( newTop);
-    dStruct.push_back( newTop);
-
+    {
+      dStruct.push_back( NULL);      
+    }
     tag.push_back(tagN);
   }
 
   void ADAddIx( ArrayIndexListT* ix_) // tags
   {
     if( propertyAccess && ix_ != NULL)
-	  throw GDLException(NULL,"Property must not be indexed: "+propertyName+".",true,false);      
+	  throw GDLException(-1,NULL,"Property must not be indexed: "+propertyName+".",true,false);      
     ix.push_back(ix_); 
   }
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/allix.cpp gdl/src/allix.cpp
--- gdl-0.9.3/src/allix.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/allix.cpp	2013-02-25 17:04:24.222182628 -0700
@@ -60,7 +60,7 @@
 assert( upperSet);
 SizeT index = ref->GetAsIndexStrict( i);
 if( index > upper)
-	throw GDLException(NULL,"Array used to subscript array "
+	throw GDLException(-1,NULL,"Array used to subscript array "
 			   "contains out of range subscript (at index: "+i2s(i)+").",true,false);
 return index;
 }
@@ -71,7 +71,7 @@
 seqIx = 0;
 SizeT index = ref->GetAsIndexStrict( 0);
 if( index > upper)
-	throw GDLException(NULL,"Array used to subscript array "
+	throw GDLException(-1,NULL,"Array used to subscript array "
 			   "contains out of range subscript (at index: "+i2s(index)+").",true,false);
 return index;
 }
@@ -81,7 +81,7 @@
 assert( upperSet);
 SizeT index = ref->GetAsIndexStrict( ++seqIx);
 if( index > upper)
-	throw GDLException(NULL,"Array used to subscript array "
+	throw GDLException(-1,NULL,"Array used to subscript array "
 			   "contains out of range subscript (at index: "+i2s(index)+").",true,false);
 return index;
 }
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/antlr/LLkParser.cpp gdl/src/antlr/LLkParser.cpp
--- gdl-0.9.3/src/antlr/LLkParser.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/antlr/LLkParser.cpp	2013-05-16 12:36:33.773855916 -0600
@@ -2,7 +2,7 @@
  * Project led by Terence Parr at http://www.jGuru.com
  * Software rights: http://www.antlr.org/license.html
  *
- * $Id: LLkParser.cpp,v 1.6 2012/11/13 14:30:14 m_schellens Exp $
+ * $Id: LLkParser.cpp,v 1.8 2013/05/07 13:13:52 m_schellens Exp $
  */
 
 #include "antlr/LLkParser.hpp"
@@ -40,7 +40,8 @@
 
 void LLkParser::trace(const char* ee, const char* rname)
 {
-  //if(inputState->guessing>0) return;
+  // only show non-guessing (production) calls
+  if(inputState->guessing>0) return;
 	
   traceIndent();
   
Only in gdl-0.9.3/src/antlr: LLkParser.cpp~
Only in gdl-0.9.3/src/antlr: .#LLkParser.cpp.1.4
Only in gdl-0.9.3/src/antlr: Makefile.in
Only in gdl-0.9.3/src/antlr: Parser.cpp~
Only in gdl-0.9.3/src/antlr: Parser.hpp~
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/arrayindex.cpp gdl/src/arrayindex.cpp
--- gdl-0.9.3/src/arrayindex.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/arrayindex.cpp	2013-03-25 10:36:38.091971084 -0600
@@ -271,7 +271,7 @@
   {
     sInit = GDLInterpreter::CallStackBack()->GetKW( varIx)->LoopIndex();
     if( sInit < 0)
-      throw GDLException( NULL,"Record number must be a scalar > 0 in this context.",true,false);      
+      throw GDLException(-1,NULL,"Record number must be a scalar > 0 in this context.",true,false);      
     lastIx = sInit;
     return true;
   }
@@ -345,7 +345,7 @@
     else
       {
 	BaseGDL* rConv = right->Convert2( var->Type(), BaseGDL::COPY);
-	std::auto_ptr<BaseGDL> conv_guard( rConv);
+	Guard<BaseGDL> conv_guard( rConv);
 	
 	var->AssignAt( rConv, this); // assigns inplace
       }
@@ -377,7 +377,7 @@
     else
       {
 	BaseGDL* rConv = right->Convert2( var->Type(), BaseGDL::COPY);
-	std::auto_ptr<BaseGDL> conv_guard( rConv);
+	Guard<BaseGDL> conv_guard( rConv);
 	
 	var->AssignAt( rConv, this); // assigns inplace
       }
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/arrayindex.hpp gdl/src/arrayindex.hpp
--- gdl-0.9.3/src/arrayindex.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/arrayindex.hpp	2013-05-16 12:36:33.075858422 -0600
@@ -78,10 +78,10 @@
   virtual void Init( BaseGDL*, BaseGDL*, BaseGDL*) { assert( false);}
 
   virtual bool IsRange() { return false;} // default for non-ranges
-  virtual BaseGDL* OverloadIndexNew() { assert( false);}
-  virtual BaseGDL* OverloadIndexNew( BaseGDL*) { assert( false);}
-  virtual BaseGDL* OverloadIndexNew( BaseGDL*, BaseGDL*) { assert( false);}
-  virtual BaseGDL* OverloadIndexNew( BaseGDL*, BaseGDL*, BaseGDL*) { assert( false);}
+  virtual BaseGDL* OverloadIndexNew() { assert( false); return 0;}
+  virtual BaseGDL* OverloadIndexNew( BaseGDL*) { assert( false); return 0;}
+  virtual BaseGDL* OverloadIndexNew( BaseGDL*, BaseGDL*) { assert( false); return 0;}
+  virtual BaseGDL* OverloadIndexNew( BaseGDL*, BaseGDL*, BaseGDL*) { assert( false); return 0;}
 
   virtual void Clear() {}
   virtual ~ArrayIndexT() {}
@@ -390,7 +390,7 @@
 //   BaseGDL* Index( BaseGDL* var, IxExprListT& ixL)
 //   {
 //     if( s >= var->Size())
-//       throw GDLException(NULL,"Scalar subscript out of range [>].h1",true,false);
+//       throw GDLException(-1,NULL,"Scalar subscript out of range [>].h1",true,false);
 //     return var->NewIx( s);
 //   }
 
@@ -404,13 +404,13 @@
       s = sInit;
 
     if( s < 0)
-	throw GDLException(NULL,"Constant scalar subscript out of range [-i].",true,false);
+	throw GDLException(-1,NULL,"Constant scalar subscript out of range [-i].",true,false);
     if( s >= varDim && s > 0) // varDim == 0 && s == 0 ok
-	throw GDLException(NULL,"Constant scalar out of range [i].",true,false);
+	throw GDLException(-1,NULL,"Constant scalar out of range [i].",true,false);
     return 1;
 
 //     if( s >= varDim && s > 0) // varDim == 0 && s == 0 ok
-//       throw GDLException(NULL,"Scalar subscript out of range [>].h2",true,false);
+//       throw GDLException(-1,NULL,"Scalar subscript out of range [>].h2",true,false);
 //     return 1;
   }
 }; //class CArrayIndexScalar: public ArrayIndexT
@@ -528,7 +528,7 @@
       // 	if( ret == -1) // index < 0
       // 	  {
       // 	    throw 
-      // 	      GDLException(NULL, "Subscript range values of the"
+      // 	      GDLException(-1,NULL, "Subscript range values of the"
       // 			    " form low:high must be >= 0, < size,"
       // 			    " with low <= high.",true,false);
       // 	  }
@@ -543,7 +543,7 @@
 
     int typeCheck = DTypeOrder[ dType];
     if( typeCheck >= 100)
-      throw GDLException(NULL,"Type not allowed as subscript.",true,false);
+      throw GDLException(-1, NULL,"Type not allowed as subscript.",true,false);
 
     //SizeT nElem = ix_->N_Elements();
     //    ix = new SizeT[ nElem]; // allocate array
@@ -572,9 +572,9 @@
 	s = sInit;
 
       if( s < 0)
-	throw GDLException(NULL,"Subscript out of range [-i].",true,false);
+	throw GDLException(-1, NULL,"Subscript out of range [-i].",true,false);
       if( s >= varDim && s > 0)
-	throw GDLException(NULL,"Subscript out of range [i].",true,false);
+	throw GDLException(-1, NULL,"Subscript out of range [i].",true,false);
       return 1;
     }
     // INDEXED
@@ -684,7 +684,7 @@
     DType dType = rawData->Type();
     int typeCheck = DTypeOrder[ dType];
     if( typeCheck >= 100)
-      throw GDLException(NULL,"Type not allowed as subscript.",true,false);
+      throw GDLException(-1, NULL,"Type not allowed as subscript.",true,false);
 
     if( strictArrSubs)
       ix = new (ixBuf) AllIxIndicesStrictT( rawData);
@@ -715,9 +715,9 @@
 	s = sInit;
 
       if( s < 0)
-	throw GDLException(NULL,"Subscript out of range [-i].",true,false);
+	throw GDLException(-1, NULL,"Subscript out of range [-i].",true,false);
       if( s >= varDim && s > 0)
-	throw GDLException(NULL,"Subscript out of range [i].",true,false);
+	throw GDLException(-1, NULL,"Subscript out of range [i].",true,false);
       return 1;
     }
     // INDEXED
@@ -778,7 +778,7 @@
   BaseGDL* OverloadIndexNew( BaseGDL* s_) 
   {
     Init( s_);
-    DLong arr[3] = {sInit,-1,1};
+    DLong arr[3] = {static_cast<DLong>(sInit),-1,1};
     return new DLongGDL( arr, 3);
   }
   
@@ -803,18 +803,18 @@
       {
 	if( s_->N_Elements() == 0)
 	  throw 
-	    GDLException(NULL,"Internal error: Scalar2RangeT:"
+	    GDLException(-1,NULL,"Internal error: Scalar2RangeT:"
 			  " 1st index empty",true,false); 
 	else
 	  throw 
-	    GDLException(NULL,"Expression must be a scalar"
+	    GDLException(-1,NULL,"Expression must be a scalar"
 			  " in this context.",true,false); 
       }
 // not with Scalar2RangeT():
 //     if( retMsg == -1) // index < 0
 //       {
 // 	throw 
-// 	  GDLException(NULL,"Subscript range values of the"
+// 	  GDLException(-1,NULL,"Subscript range values of the"
 // 			" form low:high must be >= 0, < size, "
 // 			"with low <= high.",true,false);
 //       }
@@ -823,12 +823,12 @@
   SizeT NIter( SizeT varDim)
   {
     if( sInit >= varDim) // && s > 0)
-      throw GDLException(NULL,"Subscript out of range [s:*].",true,false);
+      throw GDLException(-1,NULL,"Subscript out of range [s:*].",true,false);
     if( sInit < 0)
     {
       s = sInit + varDim;
       if( s < 0)
-	      throw GDLException(NULL,"Subscript out of range [-s:*].",true,false);
+	      throw GDLException(-1,NULL,"Subscript out of range [-s:*].",true,false);
 	  
       return (varDim - s);
     }
@@ -848,7 +848,7 @@
 
   BaseGDL* OverloadIndexNew()
   {
-    DLong arr[3] = {sInit,-1,1};
+    DLong arr[3] = {static_cast<DLong>(sInit),-1,1};
     return new DLongGDL( arr, 3);
   }
 
@@ -888,7 +888,7 @@
   BaseGDL* OverloadIndexNew( BaseGDL* s_, BaseGDL* e_) 
   {
     Init( s_, e_);
-    DLong arr[3] = {sInit,eInit,1};
+    DLong arr[3] = {static_cast<DLong>(sInit),static_cast<DLong>(eInit),1};
     return new DLongGDL( arr, 3);
   }
 
@@ -916,15 +916,15 @@
       {
 	if( s_->N_Elements() == 0)
 	  throw 
-	    GDLException(NULL,"Internal error: Scalar2RangeT: 1st index empty.",true,false);
+	    GDLException(-1,NULL,"Internal error: Scalar2RangeT: 1st index empty.",true,false);
 	else
 	  throw 
-	    GDLException(NULL,"Expression must be a scalar in this context.",true,false); 
+	    GDLException(-1,NULL,"Expression must be a scalar in this context.",true,false); 
       }
 //     if( retMsg == -1) // index < 0
 //       {
 // 	throw 
-// 	  GDLException(NULL,"Subscript range values of the form low:high " 
+// 	  GDLException(-1,NULL,"Subscript range values of the form low:high " 
 // 			"must be >= 0, < size, with low <= high.",true,false);
 //       }
     
@@ -933,10 +933,10 @@
       {
 	if( e_->N_Elements() == 0)
 	  throw 
-	    GDLException(NULL,"Internal error: Scalar2RangeT: 2nd index empty.",true,false);
+	    GDLException(-1,NULL,"Internal error: Scalar2RangeT: 2nd index empty.",true,false);
 	else
 	  throw 
-	    GDLException(NULL,"Expression must be a scalar in this context.",true,false); 
+	    GDLException(-1,NULL,"Expression must be a scalar in this context.",true,false); 
       }
   }
 
@@ -949,7 +949,7 @@
     {
 	    s = sInit + varDim;
 	    if( s < 0)
-		    throw GDLException(NULL,"Subscript out of range [S:e].",true,false);
+		    throw GDLException(-1,NULL,"Subscript out of range [S:e].",true,false);
     }
     else
 	    s = sInit;
@@ -957,17 +957,17 @@
     {
 	    e = eInit + varDim;
 	    if( e < 0)
-		    throw GDLException(NULL,"Subscript out of range [s:E].",true,false);
+		    throw GDLException(-1,NULL,"Subscript out of range [s:E].",true,false);
     }
     else
 	    e = eInit;
 
     if( s > e)
       throw 
-	GDLException(NULL,"Subscript range values of the form low:high "
+	GDLException(-1,NULL,"Subscript range values of the form low:high "
 		"must be < size, with low <= high",true,false);
     if( e >= varDim) // && e > 0)
-		throw GDLException(NULL,"Subscript out of range [s:e].",true,false);
+		throw GDLException(-1,NULL,"Subscript out of range [s:e].",true,false);
     return (e - s + 1);
   }
 };
@@ -983,7 +983,7 @@
 
   BaseGDL* OverloadIndexNew()
   {
-    DLong arr[3] = {sInit,eInit,1};
+    DLong arr[3] = {static_cast<DLong>(sInit),static_cast<DLong>(eInit),1};
     return new DLongGDL( arr, 3);
   }
 
@@ -1026,7 +1026,7 @@
   BaseGDL* OverloadIndexNew( BaseGDL* s_, BaseGDL* stride_) 
   {
     Init( s_, stride_);
-    DLong arr[3] = {sInit,-1,stride};
+    DLong arr[3] = {static_cast<DLong>(sInit),-1,static_cast<DLong>(stride)};
     return new DLongGDL( arr, 3);
   }
 
@@ -1066,12 +1066,12 @@
 // 			" form low:high must be >= 0, < size, with low <= high.",true,false);
 //       }
     // stride
-    retMsg=stride_->Scalar2index( stride);
+    retMsg=stride_->Scalar2Index( stride);
     if( retMsg == 0) // index empty or array
       {
 			if( stride_->N_Elements() == 0)
 			throw
-				GDLException(  "Internal error: Scalar2index:"
+				GDLException(  "Internal error: Scalar2Index:"
 					" stride index empty",true,false);
 			else
 			throw
@@ -1093,14 +1093,14 @@
       {
 	s = sInit + varDim;
 	if( s < 0)
-		throw GDLException(NULL,"Subscript out of range [-S:*:stride].",true,false);
+		throw GDLException(-1,NULL,"Subscript out of range [-S:*:stride].",true,false);
 	return (varDim - s + stride - 1)/stride;
       }
     else
       s= sInit;
 
     if( s >= varDim) // && s > 0)
-      throw GDLException(NULL,"Subscript out of range [s:*:stride].",true,false);
+      throw GDLException(-1,NULL,"Subscript out of range [s:*:stride].",true,false);
     return (varDim - s + stride - 1)/stride;
   }
 };
@@ -1114,7 +1114,7 @@
 
   BaseGDL* OverloadIndexNew()
   {
-    DLong arr[3] = {sInit,-1,stride};
+    DLong arr[3] = {static_cast<DLong>(sInit),-1,static_cast<DLong>(stride)};
     return new DLongGDL( arr, 3);
   }
 
@@ -1166,7 +1166,7 @@
   BaseGDL* OverloadIndexNew( BaseGDL* s_, BaseGDL* e_, BaseGDL* stride_)
   {
     Init( s_, e_, stride_);
-    DLong arr[3] = {sInit,eInit,stride};
+    DLong arr[3] = {static_cast<DLong>(sInit),static_cast<DLong>(eInit),static_cast<DLong>(stride)};
     return new DLongGDL( arr, 3);
   }
 
@@ -1218,12 +1218,12 @@
       }
                             
     // stride
-    retMsg=stride_->Scalar2index(stride);
+    retMsg=stride_->Scalar2Index(stride);
     if( retMsg == 0) // index empty or array
       {
 	if( stride_->N_Elements() == 0)
 	  throw 
-	    GDLException(  "Internal error: Scalar2index:"
+	    GDLException(  "Internal error: Scalar2Index:"
 			  " stride index empty",true,false); 
 	else
 	  throw 
@@ -1246,7 +1246,7 @@
 	    {
 	      s = sInit + varDim;
 	      if( s < 0)
-		      throw GDLException(NULL,"Subscript out of range [-S:e:stride].",true,false);
+		      throw GDLException(-1,NULL,"Subscript out of range [-S:e:stride].",true,false);
 	    }
     else
 	    s = sInit;
@@ -1254,19 +1254,19 @@
 	    {
 	      e = eInit + varDim;
 	      if( e < 0)
-		      throw GDLException(NULL,"Subscript out of range [s:-E:stride].",true,false);
+		      throw GDLException(-1,NULL,"Subscript out of range [s:-E:stride].",true,false);
 	    }
     else
 	    e = eInit;
     
     if( s > e)
 		throw 
-			GDLException(NULL,"Subscript range values of the form low:high "
+			GDLException(-1,NULL,"Subscript range values of the form low:high "
 				"must be < size, with low <= high",true,false);
     
     if( e >= varDim) // && e > 0)
       {
-		throw GDLException(NULL,"Subscript out of range [s:E:st].",true,false);
+		throw GDLException(-1,NULL,"Subscript out of range [s:E:st].",true,false);
       }
     return (e - s + stride)/stride;
   }
@@ -1281,7 +1281,7 @@
 
   BaseGDL* OverloadIndexNew()
   {
-    DLong arr[3] = {sInit,eInit,stride};
+    DLong arr[3] = {static_cast<DLong>(sInit),static_cast<DLong>(eInit),static_cast<DLong>(stride)};
     return new DLongGDL( arr, 3);
   }
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/arrayindexlistnoassoct.hpp gdl/src/arrayindexlistnoassoct.hpp
--- gdl-0.9.3/src/arrayindexlistnoassoct.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/arrayindexlistnoassoct.hpp	2013-03-25 10:36:38.105971020 -0600
@@ -165,7 +165,7 @@
   bool ToAssocIndex( SizeT& lastIx)
   {
     assert( 0);
-    throw GDLException( NULL,"Internal error: ArrayIndexListOneNoAssocT::ToAssocIndex(...) called.",true,false);
+    throw GDLException(-1,NULL,"Internal error: ArrayIndexListOneNoAssocT::ToAssocIndex(...) called.",true,false);
     return true;
   }
 
@@ -291,7 +291,7 @@
     else
       {
 	BaseGDL* rConv = right->Convert2( var->Type(), BaseGDL::COPY);
-	std::auto_ptr<BaseGDL> conv_guard( rConv);
+	Guard<BaseGDL> conv_guard( rConv);
 	
 	var->AssignAt( rConv, this); // assigns inplace
       }
@@ -511,7 +511,7 @@
   {
     sInit = varPtr->Data()->LoopIndex();
     if( sInit < 0)
-      throw GDLException( NULL,"Record number must be a scalar > 0 in this context.",true,false);
+      throw GDLException(-1,NULL,"Record number must be a scalar > 0 in this context.",true,false);
     s = sInit;
     lastIx = s;
     return true;
@@ -529,9 +529,9 @@
     // for assoc variables last index is the record
 //     if( var->IsAssoc()) return;
     if( s >= var->Size())
-      throw GDLException(NULL,"Scalar subscript out of range [>].1",true,false);
+      throw GDLException(-1,NULL,"Scalar subscript out of range [>].1",true,false);
     if( s < 0)
-      throw GDLException(NULL,"Scalar subscript out of range [<].1",true,false);
+      throw GDLException(-1,NULL,"Scalar subscript out of range [<].1",true,false);
   }
   
   // structure of indexed expression
@@ -576,7 +576,7 @@
       {
 	s = varPtr->Data()->LoopIndex();
 	if( s >= var->Size())
-	  throw GDLException(NULL,"Scalar subscript out of range [>].2",true,false);
+	  throw GDLException(-1,NULL,"Scalar subscript out of range [>].2",true,false);
 	var->AssignAtIx( s, right);
 	return;
       }
@@ -589,7 +589,7 @@
     else
       {
 	BaseGDL* rConv = right->Convert2( var->Type(), BaseGDL::COPY);
-	std::auto_ptr<BaseGDL> conv_guard( rConv);
+	Guard<BaseGDL> conv_guard( rConv);
 	
 	var->AssignAt( rConv, this); // assigns inplace
       }
@@ -709,7 +709,7 @@
   bool ToAssocIndex( SizeT& lastIx)
   {
     if( sInit < 0)
-      throw GDLException( NULL,"Record number must be a scalar > 0 in this context.",true,false);      
+      throw GDLException(-1,NULL,"Record number must be a scalar > 0 in this context.",true,false);      
     lastIx = sInit;
     return true;
   }
@@ -722,9 +722,9 @@
       s = sInit + var->Size();
     // for assoc variables last index is the record
     if( s < 0)
-      throw GDLException(NULL,"Scalar subscript out of range [<].1",true,false);
+      throw GDLException(-1,NULL,"Scalar subscript out of range [<].1",true,false);
     if( s >= var->Size())
-      throw GDLException(NULL,"Scalar subscript out of range [>].1",true,false);
+      throw GDLException(-1,NULL,"Scalar subscript out of range [>].1",true,false);
   }
 
   // returns one dim long ix in case of one element array index
@@ -747,9 +747,9 @@
 	if( sInit < 0)
 	  s = sInit + var->Size();
 	if( s < 0)
-	  throw GDLException(NULL,"Scalar subscript out of range [<].4",true,false);
+	  throw GDLException(-1,NULL,"Scalar subscript out of range [<].4",true,false);
 	if( s >= var->Size())
-	  throw GDLException(NULL,"Scalar subscript out of range [>].4",true,false);
+	  throw GDLException(-1,NULL,"Scalar subscript out of range [>].4",true,false);
 	var->AssignAtIx( s, right); // must use COPY_BYTE_AS_INT
 	return;
       }
@@ -762,7 +762,7 @@
     else
       {
 		BaseGDL* rConv = right->Convert2( var->Type(), BaseGDL::COPY);
-		std::auto_ptr<BaseGDL> conv_guard( rConv);
+		Guard<BaseGDL> conv_guard( rConv);
 	
 		var->AssignAt( rConv, this); // assigns inplace
       }
@@ -777,11 +777,11 @@
 	if( sInit < 0)
 	  s = sInit + var->Size();
 	if( s < 0)
-		throw GDLException(NULL,"Scalar subscript out of range [<].5",true,false);
+		throw GDLException(-1,NULL,"Scalar subscript out of range [<].5",true,false);
 	if( s >= var->Size())
 	{
 // 	    std::cout << s << " var->Size():" << var->Size() << std::endl;
-		throw GDLException(NULL,"Scalar subscript out of range [>].5",true,false);
+		throw GDLException(-1,NULL,"Scalar subscript out of range [>].5",true,false);
 	}
 	
 	return var->NewIx( s);
@@ -877,7 +877,7 @@
 //     ixListEnd( NULL)
   {
     if( ix->size() > MAXRANK)
-      throw GDLException(NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
+      throw GDLException(-1,NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
 
     assert( ixList.size() > 1); // must be, from compiler
     
@@ -1001,7 +1001,7 @@
     else
       {
 	BaseGDL* rConv = right->Convert2( var->Type(), BaseGDL::COPY);
-	std::auto_ptr<BaseGDL> conv_guard( rConv);
+	Guard<BaseGDL> conv_guard( rConv);
 	
 	var->AssignAt( rConv, this); // assigns inplace (not only scalar)
       }
@@ -1089,7 +1089,7 @@
     ixList( *ix)
   {
     if( ix->size() > MAXRANK)
-      throw GDLException(NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
+      throw GDLException(-1,NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
 
     assert( ixList.size() == 2); // must be, from compiler
     nParam = 0;
@@ -1177,7 +1177,7 @@
     else
       {
 	BaseGDL* rConv = right->Convert2( var->Type(), BaseGDL::COPY);
-	std::auto_ptr<BaseGDL> conv_guard( rConv);
+	Guard<BaseGDL> conv_guard( rConv);
 	
 	var->AssignAt( rConv, this); // assigns inplace (not only scalar)
       }
@@ -1308,7 +1308,7 @@
     assert( ix->size() != 0); // must be, from compiler
 
     if( ixList.size() > MAXRANK)
-      throw GDLException(NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
+      throw GDLException(-1,NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
 
     nParam = 0;
     for( SizeT i=0; i<ix->size(); ++i)
@@ -1577,30 +1577,31 @@
     const dimension& varDim  = var->Dim();
     SizeT            varRank = varDim.Rank();
 
+    varStride = var->Dim().Stride();
+
     if( accessType == ALLINDEXED)
     {
+      baseIx = 0;
+      
       nIx=ixList[0]->NIter( (0<varRank)?varDim[0]:1);
       assert( nIx > 1);
-      for( SizeT i=1; i<acRank; ++i)
-	      {
-		SizeT nIter = ixList[i]->NIter( (i<varRank)?varDim[i]:1);
-		if( nIter != nIx)
-			throw GDLException(NULL, "All array subscripts must be of same size.", true, false);
-	      }
 
+      for( SizeT i=1; i<acRank; ++i)
+      {
+	  SizeT nIter = ixList[i]->NIter( (i<varRank)?varDim[i]:1);
+	  if( nIter != nIx)
+		  throw GDLException(-1,NULL, "All array subscripts must be of same size.", true, false);	
+      }
       // in this case, having more index dimensions does not matter
       // indices are used only upto variables rank
       // ok as we set acRank here
       if( varRank < acRank) 
 	acRank = varRank;
-
-      varStride = var->Dim().Stride();
-// 		varDim.Stride( varStride,acRank); // copy variables stride into varStride
+      //varDim.Stride( varStride,acRank); // copy variables stride into varStride
       return;
     }
     
     // NORMAL
-    varStride = var->Dim().Stride();
     //     varDim.Stride( varStride,acRank); // copy variables stride into varStride
     assert( varStride[0] == 1);
 
@@ -1758,7 +1759,7 @@
     else
       {
 	BaseGDL* rConv = right->Convert2( var->Type(), BaseGDL::COPY);
-	std::auto_ptr<BaseGDL> conv_guard( rConv);
+	Guard<BaseGDL> conv_guard( rConv);
 	
 	var->AssignAt( rConv, this); // assigns inplace
       }
@@ -1829,7 +1830,7 @@
     assert( ix->size() != 0); // must be, from compiler
 
     if( ixList.size() > MAXRANK)
-      throw GDLException(NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
+      throw GDLException(-1,NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
 
     nParam = 0;
     for( SizeT i=0; i<ix->size(); ++i)
@@ -2133,7 +2134,7 @@
     assert( ix->size() != 0); // must be, from compiler
 
     if( ixList.size() > MAXRANK)
-      throw GDLException(NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
+      throw GDLException(-1,NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
 
     nParam = 0;
     for( SizeT i=0; i<ix->size(); ++i)
@@ -2222,7 +2223,7 @@
 			{
 				SizeT nIter = ixList[i]->NIter( (i<varRank)?varDim[i]:1);
 				if( nIter != nIx)
-					throw GDLException(NULL, "All array subscripts must be of same size.", true, false);
+					throw GDLException(-1,NULL, "All array subscripts must be of same size.", true, false);
 			}
 
 		// in this case, having more index dimensions does not matter
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/arrayindexlistt.hpp gdl/src/arrayindexlistt.hpp
--- gdl-0.9.3/src/arrayindexlistt.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/arrayindexlistt.hpp	2013-03-25 10:36:38.110970997 -0600
@@ -45,19 +45,19 @@
 
   virtual void InitAsOverloadIndex( IxExprListT& ixIn, IxExprListT* cleanupIx, IxExprListT& ixOut) 
   { 
-    throw GDLException( NULL,"Internal error: ArrayIndexListT::InitAsOverladIndex( IxExprListT& ixInOut) called.",true,false);    
+    throw GDLException( -1, NULL,"Internal error: ArrayIndexListT::InitAsOverladIndex( IxExprListT& ixInOut) called.",true,false);    
   }
   virtual void Init( IxExprListT& ix, IxExprListT* cleanupIx) 
   { 
     assert( 0);
-    throw GDLException( NULL,"Internal error: ArrayIndexListT::Init( IxExprListT& ix, IxExprListT* cleanupIx) called.",true,false);    
+    throw GDLException( -1, NULL,"Internal error: ArrayIndexListT::Init( IxExprListT& ix, IxExprListT* cleanupIx) called.",true,false);    
   }
   virtual void Init() {}
   
    virtual bool ToAssocIndex( SizeT& lastIx) 
    { 
     assert( 0);       
-    throw GDLException( NULL,"Internal error: ArrayIndexListT::ToAssocIndex( SizeT& lastIx) called.",true,false);
+    throw GDLException( -1, NULL,"Internal error: ArrayIndexListT::ToAssocIndex( SizeT& lastIx) called.",true,false);
    }
 //  virtual bool ToAssocIndex( RangeT& lastIx) = 0;
 
@@ -188,10 +188,10 @@
     // cannot be ArrayIndexScalar[VP] ix->Init();
     RangeT lastValIx;
     if( !ix->Scalar( lastValIx))
-      throw GDLException( NULL,"Record number must be a scalar in this context.",true,false);
+      throw GDLException( -1, NULL,"Record number must be a scalar in this context.",true,false);
 
     if( lastValIx < 0)
-      throw GDLException( NULL,"Record number must be a scalar > 0 in this context.",true,false);
+      throw GDLException( -1, NULL,"Record number must be a scalar > 0 in this context.",true,false);
 
     lastIx = lastValIx;
     return true;
@@ -319,7 +319,7 @@
     else
       {
 	BaseGDL* rConv = right->Convert2( var->Type(), BaseGDL::COPY);
-	std::auto_ptr<BaseGDL> conv_guard( rConv);
+	Guard<BaseGDL> conv_guard( rConv);
 	
 	var->AssignAt( rConv, this); // assigns inplace
       }
@@ -535,7 +535,7 @@
   {
     sInit = varPtr->Data()->LoopIndex();
     if( sInit < 0)
-      throw GDLException( NULL,"Record number must be a scalar > 0 in this context.",true,false);
+      throw GDLException( -1, NULL,"Record number must be a scalar > 0 in this context.",true,false);
     s = sInit;
     lastIx = s;
     return true;
@@ -553,9 +553,9 @@
     // for assoc variables last index is the record
     if( var->IsAssoc()) return;
     if( s >= var->Size())
-      throw GDLException(NULL,"Scalar subscript out of range [>].1",true,false);
+      throw GDLException(-1, NULL,"Scalar subscript out of range [>].1",true,false);
     if( s < 0)
-      throw GDLException(NULL,"Scalar subscript out of range [<].1",true,false);
+      throw GDLException(-1,NULL,"Scalar subscript out of range [<].1",true,false);
   }
   
   // structure of indexed expression
@@ -600,7 +600,7 @@
       {
 	s = varPtr->Data()->LoopIndex();
 	if( s >= var->Size())
-	  throw GDLException(NULL,"Scalar subscript out of range [>].2",true,false);
+	  throw GDLException(-1,NULL,"Scalar subscript out of range [>].2",true,false);
 	var->AssignAtIx( s, right);
 	return;
       }
@@ -613,7 +613,7 @@
     else
       {
 	BaseGDL* rConv = right->Convert2( var->Type(), BaseGDL::COPY);
-	std::auto_ptr<BaseGDL> conv_guard( rConv);
+	Guard<BaseGDL> conv_guard( rConv);
 	
 	var->AssignAt( rConv, this); // assigns inplace
       }
@@ -714,7 +714,7 @@
   bool ToAssocIndex( SizeT& lastIx)
   {
     if( sInit < 0)
-      throw GDLException( NULL,"Record number must be a scalar > 0 in this context.",true,false);      
+      throw GDLException(-1,NULL,"Record number must be a scalar > 0 in this context.",true,false);      
     lastIx = sInit;
     return true;
   }
@@ -727,9 +727,9 @@
       s = sInit + var->Size();
     // for assoc variables last index is the record
     if( s < 0)
-      throw GDLException(NULL,"Scalar subscript out of range [<].1",true,false);
+      throw GDLException(-1,NULL,"Scalar subscript out of range [<].1",true,false);
     if( s >= var->Size())
-      throw GDLException(NULL,"Scalar subscript out of range [>].1",true,false);
+      throw GDLException(-1,NULL,"Scalar subscript out of range [>].1",true,false);
   }
 
   // returns one dim long ix in case of one element array index
@@ -752,9 +752,9 @@
 	if( sInit < 0)
 	  s = sInit + var->Size();
 	if( s < 0)
-	  throw GDLException(NULL,"Scalar subscript out of range [<].2",true,false);
+	  throw GDLException(-1,NULL,"Scalar subscript out of range [<].2",true,false);
 	if( s >= var->Size())
-	  throw GDLException(NULL,"Scalar subscript out of range [>].2",true,false);
+	  throw GDLException(-1,NULL,"Scalar subscript out of range [>].2",true,false);
 	var->AssignAtIx( s, right);
 	return;
       }
@@ -767,7 +767,7 @@
     else
       {
 		BaseGDL* rConv = right->Convert2( var->Type(), BaseGDL::COPY);
-		std::auto_ptr<BaseGDL> conv_guard( rConv);
+		Guard<BaseGDL> conv_guard( rConv);
 	
 		var->AssignAt( rConv, this); // assigns inplace
       }
@@ -782,11 +782,11 @@
 	if( sInit < 0)
 	  s = sInit + var->Size();
 	if( s < 0)
-		throw GDLException(NULL,"Scalar subscript out of range [<].3",true,false);
+		throw GDLException(-1,NULL,"Scalar subscript out of range [<].3",true,false);
 	if( s >= var->Size())
 	{
 // 	    std::cout << s << " var->Size():" << var->Size() << std::endl;
-		throw GDLException(NULL,"Scalar subscript out of range [>].3",true,false);
+		throw GDLException(-1,NULL,"Scalar subscript out of range [>].3",true,false);
 	}
 	
 	return var->NewIx( s);
@@ -879,7 +879,7 @@
     assert( ixList.size() > 1); // must be, from compiler
     
     if( ix->size() > MAXRANK)
-      throw GDLException(NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
+      throw GDLException(-1,NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
 
     nParam = 0;
     for( SizeT i=0; i<ixList.size(); ++i)
@@ -941,7 +941,7 @@
     ixListEnd->Scalar( lastIxVal); // always scalar
 
     if( lastIxVal < 0)
-      throw GDLException( NULL,"Record number must be a scalar > 0 in this context.",true,false);
+      throw GDLException(-1,NULL,"Record number must be a scalar > 0 in this context.",true,false);
     
     lastIx = lastIxVal;
     return false; // multi dim
@@ -1047,7 +1047,7 @@
     else
       {
 	BaseGDL* rConv = right->Convert2( var->Type(), BaseGDL::COPY);
-	std::auto_ptr<BaseGDL> conv_guard( rConv);
+	Guard<BaseGDL> conv_guard( rConv);
 	
 	var->AssignAt( rConv, this); // assigns inplace (not only scalar)
       }
@@ -1209,7 +1209,7 @@
     assert( ix->size() != 0); // must be, from compiler
 
     if( ixList.size() > MAXRANK)
-      throw GDLException(NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
+      throw GDLException(-1,NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
 
     nParam = 0;
     for( SizeT i=0; i<ix->size(); ++i)
@@ -1326,10 +1326,10 @@
     
     RangeT lastValIx;
     if( !ixListEndTmp->Scalar( lastValIx))
-      throw GDLException(NULL ,"Record number must be a scalar in this context.",true,false);
+      throw GDLException(-1, NULL ,"Record number must be a scalar in this context.",true,false);
 
     if( lastValIx < 0)
-      throw GDLException( NULL,"Record number must be a scalar > 0 in this context.",true,false);
+      throw GDLException(-1, NULL,"Record number must be a scalar > 0 in this context.",true,false);
 
     lastIx = lastValIx;
    
@@ -1463,7 +1463,7 @@
 	      {
 		SizeT nIter = ixList[i]->NIter( (i<varRank)?varDim[i]:1);
 		if( nIter != nIx)
-			throw GDLException(NULL, "All array subscripts must be of same size.", true, false);
+			throw GDLException(-1,NULL, "All array subscripts must be of same size.", true, false);
 	      }
 
       // in this case, having more index dimensions does not matter
@@ -1668,7 +1668,7 @@
     else
       {
 	BaseGDL* rConv = right->Convert2( var->Type(), BaseGDL::COPY);
-	std::auto_ptr<BaseGDL> conv_guard( rConv);
+	Guard<BaseGDL> conv_guard( rConv);
 	
 	var->AssignAt( rConv, this); // assigns inplace
       }
@@ -1738,7 +1738,7 @@
     assert( ix->size() != 0); // must be, from compiler
 
     if( ixList.size() > MAXRANK)
-      throw GDLException(NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
+      throw GDLException(-1,NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
 
     nParam = 0;
     for( SizeT i=0; i<ix->size(); ++i)
@@ -1976,7 +1976,7 @@
     assert( ix->size() != 0); // must be, from compiler
 
     if( ixList.size() > MAXRANK)
-      throw GDLException(NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
+      throw GDLException(-1,NULL,"Maximum of "+MAXRANK_STR+" dimensions allowed.",true,false);
 
     nParam = 0;
     for( SizeT i=0; i<ix->size(); ++i)
@@ -2066,7 +2066,7 @@
 			{
 				SizeT nIter = ixList[i]->NIter( (i<varRank)?varDim[i]:1);
 				if( nIter != nIx)
-					throw GDLException(NULL, "All array subscripts must be of same size.", true, false);
+					throw GDLException(-1,NULL, "All array subscripts must be of same size.", true, false);
 			}
 
 		// in this case, having more index dimensions does not matter
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/assocdata.hpp gdl/src/assocdata.hpp
--- gdl-0.9.3/src/assocdata.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/assocdata.hpp	2013-05-16 12:36:33.083858393 -0600
@@ -134,7 +134,7 @@
     throw GDLException("Assoc_::GetInstance(...) called.");
   }
 
-  int Scalar2index(SizeT& ret) const 
+  int Scalar2Index(SizeT& ret) const 
   { 
     throw GDLException("File expression not allowed in this context.");
   }
@@ -346,7 +346,7 @@
     throw GDLException("File expression not allowed in this context.");
   }
 
-  Parent_* MatrixOp( BaseGDL* r)   
+  Parent_* MatrixOp( BaseGDL* r, bool, bool)   
   {
     throw GDLException("File expression not allowed in this context.");
   }
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/basegdl.cpp gdl/src/basegdl.cpp
--- gdl-0.9.3/src/basegdl.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/basegdl.cpp	2013-05-16 12:36:33.084858389 -0600
@@ -202,7 +202,7 @@
   throw GDLException("BaseGDL::SetBufferSize called.");
 }
 
-int BaseGDL::Scalar2index(SizeT& ret) const 
+int BaseGDL::Scalar2Index(SizeT& ret) const 
 { 
   throw GDLException("Operation not defined for UNDEF 1.");
 }
@@ -456,7 +456,7 @@
   throw GDLException("Operation not defined for UNDEF 170.");
 }
 
-BaseGDL* BaseGDL::MatrixOp( BaseGDL* r, bool rtranspose, bool transposeResult, bool strassen)
+BaseGDL* BaseGDL::MatrixOp( BaseGDL* r, bool atranspose, bool btranspose)
 {
   throw GDLException("Operation not defined for UNDEF 18.");
 }
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/basegdl.hpp gdl/src/basegdl.hpp
--- gdl-0.9.3/src/basegdl.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/basegdl.hpp	2013-05-16 12:36:33.088858375 -0600
@@ -63,6 +63,22 @@
   GDL_ULONG,      // 13 unsigned long int
   GDL_LONG64,     // 14 64 bit integer
   GDL_ULONG64     // 15 unsigned 64 bit integer
+
+  // not yet implemented
+  , GDL_LONG128  // 128 bit integer
+  , GDL_ULONG128 // unsigned 128 bit integer
+  
+  , GDL_LONGABI // arbitrary length int
+  //, GDL_ULONGABI // arbitrary length unsigned int (pointless)
+  
+  , GDL_LDOUBLE // long double  precision float (80 or 128bit)
+  , GDL_COMPLEXLDBL // Complex long double
+
+  , GDL_ARBITRARY // arbitrary precision float
+  , GDL_COMPLEXABI // Complex arbitrary
+
+  , GDL_RATIONAL // arbitrary length rational
+  , GDL_COMPLEXRAT // Complex arbitrary length rational
 };
 
 // order of conversion precedence if two types are the same,
@@ -74,17 +90,55 @@
   4, 	//GDL_LONG,	
   8, 	//GDL_FLOAT,	
   9, 	//GDL_DOUBLE,	
-  10, 	//GDL_COMPLEX,	
+  20, 	//GDL_COMPLEX,	
   1, 	//GDL_STRING,	
   101, 	//GDL_STRUCT,	
-  11, 	//GDL_COMPLEXDBL,	
+  21, 	//GDL_COMPLEXDBL,	
   102, 	//GDL_PTR,		
   103, 	//GDL_OBJ, // must be highest number (see AdjustTypes... functions)
   3, 	//GDL_UINT,	
   4, 	//GDL_ULONG,
   5, 	//GDL_LONG64,
   5 	//GDL_ULONG64
+  
+  // not yet implemented
+  ,6  //   , GDL_LONG128  // 128 bit integer
+  ,6  //   , GDL_ULONG128 // unsigned 128 bit integer
+    //   
+  ,7  //   , GDL_LONGAB // arbitrary length int
+  // ,7  //   , GDL_ULONGAR // arbitrary length unsigned int (pointless)
+    //   
+  ,10  //   , GDL_LDOUBLE // quad precision float (80 or 128bit)
+  ,22  //   , GDL_COMPLEXLDBL // Complex quad
+    // 
+  ,11  //   , GDL_ARBITRARY // arbitrary precision float
+  ,23  //   , GDL_COMPLEXAR // Complex arbitrary
+    // 
+  ,12  //   , GDL_RATIONAL // arbitrary length rational
+  ,24  //   , GDL_COMPLEXRAT // Complex arbitrary length rational
 };	
+
+
+inline DType PromoteMatrixOperands( DType aTy, DType bTy)
+{
+  DType maxTy=(DTypeOrder[aTy] >= DTypeOrder[bTy])? aTy: bTy;
+  if( maxTy == GDL_BYTE || maxTy == GDL_INT)
+    return GDL_LONG;
+  else if( maxTy == GDL_UINT)
+    return GDL_ULONG;
+  return maxTy;
+}
+
+inline DType PromoteComplexOperand( DType aTy, DType bTy)
+{
+  if((aTy == GDL_COMPLEX && bTy == GDL_DOUBLE) ||
+     (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE) )
+    return GDL_COMPLEXDBL;
+  return GDL_UNDEF;
+}
+
+namespace gdl_type_lookup {
+
 const bool IsConvertableType[]={
   false, 	//GDL_UNDEF
   true, 	//GDL_BYTE
@@ -176,14 +230,17 @@
   false 	//GDL_ULONG64
 };	
 
+  
+} //namespace gdl_type_lookup 
+
 inline bool NonPODType( DType t)
 {
-  return IsNonPODType[ t];
+  return gdl_type_lookup::IsNonPODType[ t];
 //   return (t == GDL_COMPLEX) || (t == GDL_COMPLEXDBL) || (t == GDL_STRING) || (t == GDL_STRUCT);
 }
 inline bool IntType( DType t)
 {
-  return IsIntType[ t];
+  return gdl_type_lookup::IsIntType[ t];
 //   int o = DTypeOrder[ t];
 //   return (o >= 2 && o <= 5);
 }
@@ -193,7 +250,7 @@
 }
 inline bool RealType( DType t) // Float or Int
 {
-  return IsRealType[ t];
+  return gdl_type_lookup::IsRealType[ t];
 //   int o = DTypeOrder[ t];
 //   return (o >= 2 && o <= 9);
 }
@@ -203,13 +260,13 @@
 }
 inline bool NumericType( DType t) // Float or Int or Complex
 {
-  return IsNumericType[ t];
+  return gdl_type_lookup::IsNumericType[ t];
 //   int o = DTypeOrder[ t];
 //   return (o >= 2 && o <= 11);
 }
 inline bool ConvertableType( DType t) // everything except Struct, Ptr, Obj
 {
-  return IsConvertableType[ t];
+  return gdl_type_lookup::IsConvertableType[ t];
 //   int o = DTypeOrder[ t];
 //   return (o >= 1 && o <= 11);
 }
@@ -441,7 +498,7 @@
   virtual BaseGDL* GetEmptyInstance() const;
   virtual BaseGDL* SetBuffer( const void* b);
   virtual void     SetBufferSize( SizeT s);
-  virtual int Scalar2index(SizeT& ret) const;
+  virtual int Scalar2Index(SizeT& ret) const;
   virtual int Scalar2RangeT(RangeT& ret) const;
   virtual SizeT GetAsIndex( SizeT i) const;
   virtual SizeT GetAsIndexStrict( SizeT i) const;
@@ -598,7 +655,7 @@
 
   
   //  virtual BaseGDL* PowInvNew( BaseGDL* r);
-  virtual BaseGDL* MatrixOp( BaseGDL* r, bool rtranspose = false, bool transposeResult =false, bool strassen = false);
+  virtual BaseGDL* MatrixOp( BaseGDL* r, bool atranspose=false, bool btranspose=false);
   virtual void AssignAt( BaseGDL* srcIn, ArrayIndexListT* ixList, SizeT offset);
   virtual void AssignAt( BaseGDL* srcIn, ArrayIndexListT* ixList);
   virtual void AssignAt( BaseGDL* srcIn);
@@ -626,6 +683,9 @@
 
   virtual PyObject* ToPython();
 #endif
+
+  virtual bool Test2() {return false;}
+  
 };
 
 
Only in gdl-0.9.3/src: .#basegdl.hpp.1.71
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/basic_fun_cl.cpp gdl/src/basic_fun_cl.cpp
--- gdl-0.9.3/src/basic_fun_cl.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/basic_fun_cl.cpp	2013-03-25 10:36:38.152970802 -0600
@@ -1,529 +1,529 @@
-/***************************************************************************
-                          basic_fun.cpp  -  basic GDL library function
-                             -------------------
-    begin                : March 14 2004
-    copyright            : (C) 2004 by Christopher Lee
-    email                : leec_gdl@publius.co.uk
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#else
-// default: assume we have netCDF
-#define USE_NETCDF 1
-// default: assume we have ImageMagick
-#define USE_MAGICK 1
-#endif
-
-#include "includefirst.hpp"
-
-#include <string>
-#include <fstream>
-#include <memory>
-
-#include <gsl/gsl_sys.h>
-#include <gsl/gsl_linalg.h>
-#include <gsl/gsl_sf.h>
-#include <gsl/gsl_errno.h>
-#include <gsl/gsl_spline.h>
-
-#include "initsysvar.hpp"
-#include "datatypes.hpp"
-#include "envt.hpp"
-//#include "dpro.hpp"
-//#include "dinterpreter.hpp"
-#include "basic_fun_cl.hpp"
-//#include "terminfo.hpp"
-
-#define MAX_DATE_STRING_LENGTH 80
-
+/***************************************************************************
+                          basic_fun.cpp  -  basic GDL library function
+                             -------------------
+    begin                : March 14 2004
+    copyright            : (C) 2004 by Christopher Lee
+    email                : leec_gdl@publius.co.uk
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#else
+// default: assume we have netCDF
+#define USE_NETCDF 1
+// default: assume we have ImageMagick
+#define USE_MAGICK 1
+#endif
+
+#include "includefirst.hpp"
+
+#include <string>
+#include <fstream>
+#include <memory>
+
+#include <gsl/gsl_sys.h>
+#include <gsl/gsl_linalg.h>
+#include <gsl/gsl_sf.h>
+#include <gsl/gsl_errno.h>
+#include <gsl/gsl_spline.h>
+
+#include "initsysvar.hpp"
+#include "datatypes.hpp"
+#include "envt.hpp"
+//#include "dpro.hpp"
+//#include "dinterpreter.hpp"
+#include "basic_fun_cl.hpp"
+//#include "terminfo.hpp"
+
+#define MAX_DATE_STRING_LENGTH 80
+
 #ifdef _MSC_VER
 #include "gtdhelper.hpp"
 #else
 #include <sys/time.h>
-#endif
-
-namespace lib {
-
-  using namespace std;
-  using namespace antlr;
-
-  BaseGDL* magick_exists(EnvT *e)
-  {
-#ifdef USE_MAGICK
-    return new DIntGDL(1);
-#else
-    return new DIntGDL(0);
-#endif
-  }
-
-  BaseGDL* ncdf_exists(EnvT* e)
-  {
-#ifdef USE_NETCDF
-    return new DIntGDL(1);
-#else
-    return new DIntGDL(0);
-#endif
-  }
-
-  double Gregorian2Julian(struct tm *ts)
-  {
-    double jd;
-    // SA: gives bad results, e.g.: 
-    // IDL> print, systime(/julian), f='(G)'
-    //    2454995.131712963
-    // GDL> print, systime(/julian), f='(G)'
-    //    2454994.527534722
-    //
-    // jd = 367.0*(1900.+ts->tm_year) 
-    //   - (7.0*((1900.+ts->tm_year) + ((1+ts->tm_mon+9.0)/12.0))/4.0)
-    //   + (275.0*(1+ts->tm_mon)/9.0)+ts->tm_mday 
-    //   + (ts->tm_hour + (ts->tm_min + ts->tm_sec/60.0)/60.0)/24.0 
-    //   + 1721013.5;
-    //
-    // SA: an alterntive from the NOVAS library 
-    //     (http://aa.usno.navy.mil/software/novas/novas_c/novasc_info.php)
-    jd = ts->tm_mday - 32075L + 1461L * (ts->tm_year + 1900 + 4800L
-      + (1 + ts->tm_mon - 14L) / 12L) / 4L 
-      + 367L * (1 + ts->tm_mon - 2L - (1 + ts->tm_mon - 14L) / 12L * 12L) 
-      / 12L - 3L * ((1900 + ts->tm_year + 4900L + (1 + ts->tm_mon - 14L) / 12L) 
-      / 100L) / 4L
-      + (ts->tm_hour + (ts->tm_min + ts->tm_sec/60.0)/60.0)/24.0 - .5;
-    // SA: end of modifications, the code below was here before
-    
-    if ((100.0*(1900.+ts->tm_year)  + 1+ts->tm_mon - 190002.5) < 0) jd=jd+1.0;
-
-    return jd;
-
-  }
-
-  BaseGDL* systime(EnvT* e)
-  {
-    struct timeval tval;
-    struct timezone tzone;
-
-    /*get the time before doing anything else, 
-      this hopefully gives a more meaningful "time"
-      than if the t=time(0) call came after an 
-      arbitary number of conditional statements.*/
-    //    cout << "lib::systime: " << t << endl;
-    gettimeofday(&tval,&tzone);
-    double tt = tval.tv_sec+tval.tv_usec/1e+6; // time in UTC seconds
-
-    SizeT nParam=e->NParam(0); //,"SYSTIME");
-    bool ret_seconds=false;
-
-    auto_ptr<BaseGDL> v_guard;
-    auto_ptr<BaseGDL> v1_guard;
-
-    if (nParam == 1) {
-      //1 parameter, 
-      //      1->current UTC time seconds
-      //      default
-      DIntGDL* v = static_cast<DIntGDL*>(e->GetParDefined(0)->Convert2(GDL_INT,BaseGDL::COPY));
-      v_guard.reset( v); //  e->Guard(v);
-
-      if ( (*v)[0] == 1) //->EqualNoDelete( static_cDIntGDL(1)))
-        ret_seconds=true;
-    } else if (nParam == 2) {
-      if (e->KeywordSet("JULIAN")) e->Throw("Conflicting keywords.");
-
-      //2 parameters
-      //if the first param is 0, return the date of the second arg
-      //if the first param is 1, return the 'double' of the second arg
-      DIntGDL* v1 = static_cast<DIntGDL*>(e->GetParDefined(0)->Convert2(GDL_INT,BaseGDL::COPY));
-      v_guard.reset( v1); //  e->Guard(v1);
-      DDoubleGDL* v2 = static_cast<DDoubleGDL*>(e->GetParDefined(1)->Convert2(GDL_DOUBLE,BaseGDL::COPY));
-
-      if( (*v1)[0] == 0) { //v1->EqualNoDelete( DIntGDL(0))) { //0, read the second argument as time_t;
-        tval.tv_sec = static_cast<long int>((*v2)[0]);
-        tval.tv_usec = static_cast<long int>(((*v2)[0]-tval.tv_sec)*1e+6);
-        delete v2; // we delete v2 here as it is not guarded. Avoids a "new" in the following "else"
-      } else { //1
-        return v2;
-      }
-    }
-
-    //return the variable in seconds, either JULIAN, JULIAN+UTC,
-    //or no other keywords
-    struct tm *tstruct;
-    if( ret_seconds || e->KeywordSet("SECONDS") )
-      {
-       if( e->KeywordSet("JULIAN") )
-         {
-           if( e->KeywordSet("UTC") )
-             tstruct=gmtime((time_t *)&tval.tv_sec);
-           else
-             tstruct=localtime((time_t *)&tval.tv_sec);
-
-           return new DDoubleGDL(Gregorian2Julian(tstruct));
-         }
-       else
-         {
-           // does not (necessaryly) work: time might count backwards
-           //double tickTime = static_cast<double>(t) + tt - floor( tt);
-           return new DDoubleGDL(static_cast<double>(tt));
-         }
-      }
-
-    //return a string of the time, either UTC or local (default)
-    if(e->KeywordSet("UTC"))
-      tstruct= gmtime((time_t *)&tval.tv_sec);
-    else
-      tstruct= localtime((time_t *)&tval.tv_sec);
-
-    //Convert the time to JULIAN or NOT
-    if(e->KeywordSet("JULIAN"))
-        return new DDoubleGDL(Gregorian2Julian(tstruct));
-    else 
-      {
-       char *st=new char[MAX_DATE_STRING_LENGTH];
-       const char *format="%a %h %d %T %Y";//my IDL date format.
-       DStringGDL *S;
-
-       SizeT res=strftime(st,MAX_DATE_STRING_LENGTH,format,tstruct);
-
-       if(res != 0)
-         S=new DStringGDL(st);
-       else
-         S=new DStringGDL("");
-
-       delete st;
-
-       return S;
-      }
-  }
-
-  BaseGDL* legendre(EnvT* e)
-  {
-    auto_ptr<BaseGDL> x_guard;
-    auto_ptr<BaseGDL> l_guard;
-    auto_ptr<BaseGDL> m_guard;
-
-    SizeT nParam=e->NParam(2); //, "LEGENDRE");
-    auto_ptr<BaseGDL> guard;
-    int count;
-    
-    
-    BaseGDL* xvals,* lvals,* mvals;
-
-    xvals= e->GetParDefined(0); //,"LEGENDRE");
-    
-    SizeT nEx,nEl, nEm,nmin;
-    nEl=0;
-    nEm=0;
-
-    
-    nEx=xvals->N_Elements();
-    if(nEx == 0)
-      e->Throw( 
-	       "Variable is undefined: "
-	       +e->GetParString(0));
-    
-    lvals=e->GetParDefined(1); //,"LEGENDRE");
-    nEl=lvals->N_Elements();
-    if(nEl == 0)
-      e->Throw( 
-	       "Variable is undefined: "
-	       +e->GetParString(1));
-    
-    
-    if(nParam > 2)
-      {
-	mvals=e->GetParDefined(2); //,"LEGENDRE");
-	nEm=mvals->N_Elements();
-      } else {
-	mvals=new DIntGDL(0);
-	nEm=1;
-	guard.reset(mvals);
-      }
-
-    if(nEm == 0)
-      e->Throw( 
-	       "Variable is undefined: "
-	       +e->GetParString(2));
-
-    
-    nmin=nEx;
-    if(nEl < nmin && nEl > 1) 	nmin=nEl;    
-    if(nEm < nmin && nEm > 1) 	nmin=nEm;
-    
-    if (xvals->Type() == GDL_STRING) {
-      e->Throw( 
-	       "String expression not allowed in this context: "
-	       +e->GetParString(0));
-    } else if (xvals->Type() == GDL_PTR) {
-      e->Throw( 
-	       "Pointer expression not allowed in this context: "
-	       +e->GetParString(0));
-    } else if (xvals->Type() == GDL_OBJ) {
-      e->Throw( 
-	       "Object expression not allowed in this context: "
-	       +e->GetParString(0));
-    } else if (xvals->Type() == GDL_STRUCT) {
-      e->Throw( 
-	       "Struct expression not allowed in this context: "
-	       +e->GetParString(0));
-    } else if(xvals->Type() == GDL_COMPLEX ||
-	      xvals->Type() == GDL_COMPLEXDBL) {
-      e->Throw( 
-	       "Complex Legendre not implemented: ");
-    }        else      {
-      //byte, int, long float, double, uint, ulong, int64, uint64
-
-      DDoubleGDL* res;
-      DDoubleGDL* x_cast;
-      DIntGDL* l_cast,*m_cast;
-
-      if(xvals->Type() == GDL_DOUBLE) 
-	x_cast=  static_cast<DDoubleGDL*>(xvals);
-      else
-	{
-	x_cast=  static_cast<DDoubleGDL*>(xvals->Convert2(GDL_DOUBLE,BaseGDL::COPY));
-	x_guard.reset(x_cast);//e->Guard( x_cast);
-	}
-
-      //lval check
-      if (lvals->Type() == GDL_STRING)
-	e->Throw( 
-		 "String expression not allowed in this context: "
-		 +e->GetParString(1));
-      else if (lvals->Type() == GDL_PTR)
-	e->Throw( 
-		 "Pointer expression not allowed in this context: "
-		 +e->GetParString(1));
-      else if (lvals->Type() == GDL_OBJ) 
-	e->Throw( 
-		 "Object expression not allowed in this context: "
-		 +e->GetParString(1));
-      else if (lvals->Type() == GDL_STRUCT) 
-	e->Throw( 
-		 "Struct expression not allowed in this context: "
-		 +e->GetParString(1));
-      else if(lvals->Type() == GDL_COMPLEX ||
-	      lvals->Type() == GDL_COMPLEXDBL) 
-	e->Throw( 
-		 "Complex Legendre not implemented: ");
-      else if(lvals->Type() == GDL_INT)
-	l_cast=static_cast<DIntGDL*>(lvals);
-      else
-	{
-	  l_cast=static_cast<DIntGDL*>(lvals->Convert2(GDL_INT,BaseGDL::COPY));
-	  l_guard.reset(l_cast);//e->Guard( l_cast);
-	}
-
-      //mval check
-      if (mvals->Type() == GDL_STRING)
-	e->Throw( 
-		 "String expression not allowed in this context: "
-		 +e->GetParString(2));
-      else if (mvals->Type() == GDL_PTR)
-	e->Throw( 
-		 "Pointer expression not allowed in this context: "
-		 +e->GetParString(2));
-      else if (mvals->Type() == GDL_OBJ) 
-	e->Throw( 
-		 "Object expression not allowed in this context: "
-		 +e->GetParString(2));
-      else if (mvals->Type() == GDL_STRUCT) 
-	e->Throw( 
-		 "Struct expression not allowed in this context: "
-		 +e->GetParString(2));
-      else if(mvals->Type() == GDL_COMPLEX ||
-	      mvals->Type() == GDL_COMPLEXDBL) 
-	e->Throw( 
-		 "Complex Legendre not implemented: ");
-      else if(mvals->Type() == GDL_INT)
-	m_cast=static_cast<DIntGDL*>(mvals);
-      else
-	{
-	  m_cast=static_cast<DIntGDL*>(mvals->Convert2(GDL_INT,BaseGDL::COPY));
-	  //e->Guard( m_cast);
-	  m_guard.reset(m_cast);
-	}
-
-      //x,m,l are converted to the correct format (double, int, int) here
-	
-
-      //make the result array have the same size as the smallest x,m,l array
-      if(nmin == nEx) res=new DDoubleGDL(xvals->Dim(),BaseGDL::NOZERO);
-      else if(nmin == nEl) res=new DDoubleGDL(lvals->Dim(),BaseGDL::NOZERO);
-      else if(nmin == nEm) res=new DDoubleGDL(mvals->Dim(),BaseGDL::NOZERO);
-	  
-      for (count=0;count<nmin;count++)
-	{
-	  DDouble xNow = (*x_cast)[nmin > nEx?0:count];
-	  DInt lNow =    (*l_cast)[nmin > nEl?0:count];
-	  DInt mNow =    (*m_cast)[nmin > nEm?0:count];
-
-	  if( xNow < -1.0 || xNow > 1.0)
-	    e->Throw( "Argument X must be in the range [-1.0, 1.0]");
-	  if( lNow < 0)
-	    e->Throw( "Argument L must be greater than or equal to zero.");
-	  if( mNow < -lNow || mNow > lNow)
-	    e->Throw( "Argument M must be in the range [-L, L].");
-	 
-	  if( mNow >= 0)
-	    (*res)[count]= 
-	      gsl_sf_legendre_Plm( lNow, mNow, xNow);
-	  else
-	    {
-	      mNow = -mNow;
-	      
-	      int addIx  = lNow+mNow;
-	      DDouble mul = 1.0;
-	      DDouble dD  = static_cast<DDouble>( lNow-mNow+1);
-	      for( int d=lNow-mNow+1; d<=addIx; ++d)
-		{
-		  mul *= dD;
-		  dD  += 1.0;
-		}
-
-	      DDouble Pm = gsl_sf_legendre_Plm( lNow, mNow, xNow);
-	      if( mNow % 2 == 1) Pm = -Pm;
-
-	      (*res)[count] = Pm / mul;
-	    }
-	}
-	
-      //convert things back
-      if(xvals->Type() != GDL_DOUBLE && !e->KeywordSet("DOUBLE"))
-	{
-	  return res->Convert2(GDL_FLOAT,BaseGDL::CONVERT);
-	}
-      else
-	{
-	  return res;
-	}
-    }
-    return new DByteGDL(0);
-  }
-
-  // Gamma, LnGamma, IGamma and Beta are now in math_fun_gm.cpp
-  // I rewrite them because they had many bugs (gregory.marchal_at_obspm.fr)
-
-  BaseGDL* gsl_exp(EnvT* e)
-  {
-    auto_ptr<BaseGDL> cdr_guard;
-    auto_ptr<BaseGDL> cd_guard;
-    auto_ptr<BaseGDL> d_guard;
-    auto_ptr<BaseGDL> fr_guard;
-
-
-    SizeT nParam = e->NParam(1);
-    BaseGDL* v=e->GetParDefined(0);   
-
-    size_t nEl = v->N_Elements();
-    size_t i;
-    if (v->Type() == GDL_STRING) {
-      e->Throw( 
-		  "String expression not allowed in this context: "
-			  +e->GetParString(0));
-    } else if (v->Type() == GDL_PTR) {
-      e->Throw( 
-		  "Pointer expression not allowed in this context: "
-			  +e->GetParString(0));
-    } else if (v->Type() == GDL_OBJ) {
-      e->Throw( 
-		  "Object expression not allowed in this context: "
-			  +e->GetParString(0));
-    } else if (v->Type() == GDL_STRUCT) {
-      e->Throw( 
-		  "Struct expression not allowed in this context: "
-			  +e->GetParString(0));		  
-    } else   {
-      //      DDoubleGDL* d;
-      DDoubleGDL* dr = new DDoubleGDL(v->Dim(), BaseGDL::NOZERO);
-      //      e->Guard( dr);
-
-      if(v->Type() == GDL_COMPLEX) {
-	DComplexDblGDL* cd=
-	  static_cast<DComplexDblGDL*>(v->Convert2(GDL_COMPLEXDBL, BaseGDL::COPY));
-	cd_guard.reset(cd);//e->Guard( cd);
-
-	DComplexDblGDL* cdr =
-	  new DComplexDblGDL(v->Dim(), BaseGDL::NOZERO);
-	cdr_guard.reset(cdr);//e->Guard( cdr);
-
-	if(nEl == 1) 
-	  (*cdr)[0]=
-	   DComplex((gsl_sf_exp((*cd)[0].real())*cos((*cd)[0].imag())),
-		    (gsl_sf_exp((*cd)[0].real())*sin((*cd)[0].imag())));
-	else
-	  for(i=0;i<nEl;++i) 
-	    (*cdr)[i]=
-	      DComplex((gsl_sf_exp((*cd)[i].real())*cos((*cd)[i].imag())),
-		       (gsl_sf_exp((*cd)[i].real())*sin((*cd)[i].imag())));
-
-	return static_cast<DComplexGDL*>(cdr->Convert2(GDL_COMPLEX,BaseGDL::COPY));
-
-      } else if(v->Type() == GDL_COMPLEXDBL) {
-	DComplexDblGDL* cd=
-	  static_cast<DComplexDblGDL*>(v->Convert2(GDL_COMPLEXDBL, BaseGDL::COPY));
-	cd_guard.reset(cd);//e->Guard( cd);
-
-	DComplexDblGDL* cdr =
-	  new DComplexDblGDL(v->Dim(), BaseGDL::NOZERO);
-
-	if(nEl == 1) 
-	  (*cdr)[0]=
-	   DComplex((gsl_sf_exp((*cd)[0].real())*cos((*cd)[0].imag())),
-		    (gsl_sf_exp((*cd)[0].real())*sin((*cd)[0].imag())));
-	else
-	  for(i=0;i<nEl;i++) 
-	    (*cdr)[i]=
-	      DComplex((gsl_sf_exp((*cd)[i].real())*cos((*cd)[i].imag())),
-		       (gsl_sf_exp((*cd)[i].real())*sin((*cd)[i].imag())));
-	
-	return cdr;
-	
-      } else if(v->Type() == GDL_DOUBLE) {
-	
-	DDoubleGDL* d=static_cast<DDoubleGDL*>(v->Convert2(GDL_DOUBLE, 
-							   BaseGDL::COPY));
-	d_guard.reset(d);//e->Guard( d);
-	if(nEl == 1) 
-	  (*dr)[0]=gsl_sf_exp((*d)[0]);
-	else
-	  for (i=0;i<nEl;++i) (*dr)[i]=gsl_sf_exp((*d)[i]);
-	
-	return dr;
-      } else if(v->Type() == GDL_FLOAT || 
-		v->Type() == GDL_INT ||
-		v->Type() == GDL_LONG) {
-	
-	DFloatGDL *fr=new DFloatGDL(v->Dim(), BaseGDL::NOZERO);
-	fr_guard.reset(fr);//e->Guard( fr);
-
-	DDoubleGDL* d=static_cast<DDoubleGDL*>(v->Convert2(GDL_DOUBLE, 
-							   BaseGDL::COPY));
-	d_guard.reset(d);//e->Guard( d);
-
-	if(nEl == 1) 
-	  (*dr)[0]=gsl_sf_exp((*d)[0]);
-	else
-	  for (i=0;i<nEl;++i) (*dr)[i]=gsl_sf_exp((*d)[i]);
-
-	return static_cast<DFloatGDL*>(dr->Convert2(GDL_FLOAT,BaseGDL::COPY));
-      }
-
-    }
-  }
-
-
-
-
-      
-
-
-			  			  
- 
-} // namespace
+#endif
+
+namespace lib {
+
+  using namespace std;
+  using namespace antlr;
+
+  BaseGDL* magick_exists(EnvT *e)
+  {
+#ifdef USE_MAGICK
+    return new DIntGDL(1);
+#else
+    return new DIntGDL(0);
+#endif
+  }
+
+  BaseGDL* ncdf_exists(EnvT* e)
+  {
+#ifdef USE_NETCDF
+    return new DIntGDL(1);
+#else
+    return new DIntGDL(0);
+#endif
+  }
+
+  double Gregorian2Julian(struct tm *ts)
+  {
+    double jd;
+    // SA: gives bad results, e.g.: 
+    // IDL> print, systime(/julian), f='(G)'
+    //    2454995.131712963
+    // GDL> print, systime(/julian), f='(G)'
+    //    2454994.527534722
+    //
+    // jd = 367.0*(1900.+ts->tm_year) 
+    //   - (7.0*((1900.+ts->tm_year) + ((1+ts->tm_mon+9.0)/12.0))/4.0)
+    //   + (275.0*(1+ts->tm_mon)/9.0)+ts->tm_mday 
+    //   + (ts->tm_hour + (ts->tm_min + ts->tm_sec/60.0)/60.0)/24.0 
+    //   + 1721013.5;
+    //
+    // SA: an alterntive from the NOVAS library 
+    //     (http://aa.usno.navy.mil/software/novas/novas_c/novasc_info.php)
+    jd = ts->tm_mday - 32075L + 1461L * (ts->tm_year + 1900 + 4800L
+      + (1 + ts->tm_mon - 14L) / 12L) / 4L 
+      + 367L * (1 + ts->tm_mon - 2L - (1 + ts->tm_mon - 14L) / 12L * 12L) 
+      / 12L - 3L * ((1900 + ts->tm_year + 4900L + (1 + ts->tm_mon - 14L) / 12L) 
+      / 100L) / 4L
+      + (ts->tm_hour + (ts->tm_min + ts->tm_sec/60.0)/60.0)/24.0 - .5;
+    // SA: end of modifications, the code below was here before
+    
+    if ((100.0*(1900.+ts->tm_year)  + 1+ts->tm_mon - 190002.5) < 0) jd=jd+1.0;
+
+    return jd;
+
+  }
+
+  BaseGDL* systime(EnvT* e)
+  {
+    struct timeval tval;
+    struct timezone tzone;
+
+    /*get the time before doing anything else, 
+      this hopefully gives a more meaningful "time"
+      than if the t=time(0) call came after an 
+      arbitary number of conditional statements.*/
+    //    cout << "lib::systime: " << t << endl;
+    gettimeofday(&tval,&tzone);
+    double tt = tval.tv_sec+tval.tv_usec/1e+6; // time in UTC seconds
+
+    SizeT nParam=e->NParam(0); //,"SYSTIME");
+    bool ret_seconds=false;
+
+    Guard<BaseGDL> v_guard;
+    Guard<BaseGDL> v1_guard;
+
+    if (nParam == 1) {
+      //1 parameter, 
+      //      1->current UTC time seconds
+      //      default
+      DIntGDL* v = static_cast<DIntGDL*>(e->GetParDefined(0)->Convert2(GDL_INT,BaseGDL::COPY));
+      v_guard.Reset( v); //  e->Guard(v);
+
+      if ( (*v)[0] == 1) //->EqualNoDelete( static_cDIntGDL(1)))
+        ret_seconds=true;
+    } else if (nParam == 2) {
+      if (e->KeywordSet("JULIAN")) e->Throw("Conflicting keywords.");
+
+      //2 parameters
+      //if the first param is 0, return the date of the second arg
+      //if the first param is 1, return the 'double' of the second arg
+      DIntGDL* v1 = static_cast<DIntGDL*>(e->GetParDefined(0)->Convert2(GDL_INT,BaseGDL::COPY));
+      v_guard.Reset( v1); //  e->Guard(v1);
+      DDoubleGDL* v2 = static_cast<DDoubleGDL*>(e->GetParDefined(1)->Convert2(GDL_DOUBLE,BaseGDL::COPY));
+
+      if( (*v1)[0] == 0) { //v1->EqualNoDelete( DIntGDL(0))) { //0, read the second argument as time_t;
+        tval.tv_sec = static_cast<long int>((*v2)[0]);
+        tval.tv_usec = static_cast<long int>(((*v2)[0]-tval.tv_sec)*1e+6);
+        delete v2; // we delete v2 here as it is not guarded. Avoids a "new" in the following "else"
+      } else { //1
+        return v2;
+      }
+    }
+
+    //return the variable in seconds, either JULIAN, JULIAN+UTC,
+    //or no other keywords
+    struct tm *tstruct;
+    if( ret_seconds || e->KeywordSet("SECONDS") )
+      {
+       if( e->KeywordSet("JULIAN") )
+         {
+           if( e->KeywordSet("UTC") )
+             tstruct=gmtime((time_t *)&tval.tv_sec);
+           else
+             tstruct=localtime((time_t *)&tval.tv_sec);
+
+           return new DDoubleGDL(Gregorian2Julian(tstruct));
+         }
+       else
+         {
+           // does not (necessaryly) work: time might count backwards
+           //double tickTime = static_cast<double>(t) + tt - floor( tt);
+           return new DDoubleGDL(static_cast<double>(tt));
+         }
+      }
+
+    //return a string of the time, either UTC or local (default)
+    if(e->KeywordSet("UTC"))
+      tstruct= gmtime((time_t *)&tval.tv_sec);
+    else
+      tstruct= localtime((time_t *)&tval.tv_sec);
+
+    //Convert the time to JULIAN or NOT
+    if(e->KeywordSet("JULIAN"))
+        return new DDoubleGDL(Gregorian2Julian(tstruct));
+    else 
+      {
+       char *st=new char[MAX_DATE_STRING_LENGTH];
+       const char *format="%a %h %d %T %Y";//my IDL date format.
+       DStringGDL *S;
+
+       SizeT res=strftime(st,MAX_DATE_STRING_LENGTH,format,tstruct);
+
+       if(res != 0)
+         S=new DStringGDL(st);
+       else
+         S=new DStringGDL("");
+
+       delete st;
+
+       return S;
+      }
+  }
+
+  BaseGDL* legendre(EnvT* e)
+  {
+    Guard<BaseGDL> x_guard;
+    Guard<BaseGDL> l_guard;
+    Guard<BaseGDL> m_guard;
+
+    SizeT nParam=e->NParam(2); //, "LEGENDRE");
+    Guard<BaseGDL> guard;
+    int count;
+    
+    
+    BaseGDL* xvals,* lvals,* mvals;
+
+    xvals= e->GetParDefined(0); //,"LEGENDRE");
+    
+    SizeT nEx,nEl, nEm,nmin;
+    nEl=0;
+    nEm=0;
+
+    
+    nEx=xvals->N_Elements();
+    if(nEx == 0)
+      e->Throw( 
+	       "Variable is undefined: "
+	       +e->GetParString(0));
+    
+    lvals=e->GetParDefined(1); //,"LEGENDRE");
+    nEl=lvals->N_Elements();
+    if(nEl == 0)
+      e->Throw( 
+	       "Variable is undefined: "
+	       +e->GetParString(1));
+    
+    
+    if(nParam > 2)
+      {
+	mvals=e->GetParDefined(2); //,"LEGENDRE");
+	nEm=mvals->N_Elements();
+      } else {
+	mvals=new DIntGDL(0);
+	nEm=1;
+	guard.Reset(mvals);
+      }
+
+    if(nEm == 0)
+      e->Throw( 
+	       "Variable is undefined: "
+	       +e->GetParString(2));
+
+    
+    nmin=nEx;
+    if(nEl < nmin && nEl > 1) 	nmin=nEl;    
+    if(nEm < nmin && nEm > 1) 	nmin=nEm;
+    
+    if (xvals->Type() == GDL_STRING) {
+      e->Throw( 
+	       "String expression not allowed in this context: "
+	       +e->GetParString(0));
+    } else if (xvals->Type() == GDL_PTR) {
+      e->Throw( 
+	       "Pointer expression not allowed in this context: "
+	       +e->GetParString(0));
+    } else if (xvals->Type() == GDL_OBJ) {
+      e->Throw( 
+	       "Object expression not allowed in this context: "
+	       +e->GetParString(0));
+    } else if (xvals->Type() == GDL_STRUCT) {
+      e->Throw( 
+	       "Struct expression not allowed in this context: "
+	       +e->GetParString(0));
+    } else if(xvals->Type() == GDL_COMPLEX ||
+	      xvals->Type() == GDL_COMPLEXDBL) {
+      e->Throw( 
+	       "Complex Legendre not implemented: ");
+    }        else      {
+      //byte, int, long float, double, uint, ulong, int64, uint64
+
+      DDoubleGDL* res;
+      DDoubleGDL* x_cast;
+      DIntGDL* l_cast,*m_cast;
+
+      if(xvals->Type() == GDL_DOUBLE) 
+	x_cast=  static_cast<DDoubleGDL*>(xvals);
+      else
+	{
+	x_cast=  static_cast<DDoubleGDL*>(xvals->Convert2(GDL_DOUBLE,BaseGDL::COPY));
+	x_guard.Reset(x_cast);//e->Guard( x_cast);
+	}
+
+      //lval check
+      if (lvals->Type() == GDL_STRING)
+	e->Throw( 
+		 "String expression not allowed in this context: "
+		 +e->GetParString(1));
+      else if (lvals->Type() == GDL_PTR)
+	e->Throw( 
+		 "Pointer expression not allowed in this context: "
+		 +e->GetParString(1));
+      else if (lvals->Type() == GDL_OBJ) 
+	e->Throw( 
+		 "Object expression not allowed in this context: "
+		 +e->GetParString(1));
+      else if (lvals->Type() == GDL_STRUCT) 
+	e->Throw( 
+		 "Struct expression not allowed in this context: "
+		 +e->GetParString(1));
+      else if(lvals->Type() == GDL_COMPLEX ||
+	      lvals->Type() == GDL_COMPLEXDBL) 
+	e->Throw( 
+		 "Complex Legendre not implemented: ");
+      else if(lvals->Type() == GDL_INT)
+	l_cast=static_cast<DIntGDL*>(lvals);
+      else
+	{
+	  l_cast=static_cast<DIntGDL*>(lvals->Convert2(GDL_INT,BaseGDL::COPY));
+	  l_guard.Reset(l_cast);//e->Guard( l_cast);
+	}
+
+      //mval check
+      if (mvals->Type() == GDL_STRING)
+	e->Throw( 
+		 "String expression not allowed in this context: "
+		 +e->GetParString(2));
+      else if (mvals->Type() == GDL_PTR)
+	e->Throw( 
+		 "Pointer expression not allowed in this context: "
+		 +e->GetParString(2));
+      else if (mvals->Type() == GDL_OBJ) 
+	e->Throw( 
+		 "Object expression not allowed in this context: "
+		 +e->GetParString(2));
+      else if (mvals->Type() == GDL_STRUCT) 
+	e->Throw( 
+		 "Struct expression not allowed in this context: "
+		 +e->GetParString(2));
+      else if(mvals->Type() == GDL_COMPLEX ||
+	      mvals->Type() == GDL_COMPLEXDBL) 
+	e->Throw( 
+		 "Complex Legendre not implemented: ");
+      else if(mvals->Type() == GDL_INT)
+	m_cast=static_cast<DIntGDL*>(mvals);
+      else
+	{
+	  m_cast=static_cast<DIntGDL*>(mvals->Convert2(GDL_INT,BaseGDL::COPY));
+	  //e->Guard( m_cast);
+	  m_guard.Reset(m_cast);
+	}
+
+      //x,m,l are converted to the correct format (double, int, int) here
+	
+
+      //make the result array have the same size as the smallest x,m,l array
+      if(nmin == nEx) res=new DDoubleGDL(xvals->Dim(),BaseGDL::NOZERO);
+      else if(nmin == nEl) res=new DDoubleGDL(lvals->Dim(),BaseGDL::NOZERO);
+      else if(nmin == nEm) res=new DDoubleGDL(mvals->Dim(),BaseGDL::NOZERO);
+	  
+      for (count=0;count<nmin;count++)
+	{
+	  DDouble xNow = (*x_cast)[nmin > nEx?0:count];
+	  DInt lNow =    (*l_cast)[nmin > nEl?0:count];
+	  DInt mNow =    (*m_cast)[nmin > nEm?0:count];
+
+	  if( xNow < -1.0 || xNow > 1.0)
+	    e->Throw( "Argument X must be in the range [-1.0, 1.0]");
+	  if( lNow < 0)
+	    e->Throw( "Argument L must be greater than or equal to zero.");
+	  if( mNow < -lNow || mNow > lNow)
+	    e->Throw( "Argument M must be in the range [-L, L].");
+	 
+	  if( mNow >= 0)
+	    (*res)[count]= 
+	      gsl_sf_legendre_Plm( lNow, mNow, xNow);
+	  else
+	    {
+	      mNow = -mNow;
+	      
+	      int addIx  = lNow+mNow;
+	      DDouble mul = 1.0;
+	      DDouble dD  = static_cast<DDouble>( lNow-mNow+1);
+	      for( int d=lNow-mNow+1; d<=addIx; ++d)
+		{
+		  mul *= dD;
+		  dD  += 1.0;
+		}
+
+	      DDouble Pm = gsl_sf_legendre_Plm( lNow, mNow, xNow);
+	      if( mNow % 2 == 1) Pm = -Pm;
+
+	      (*res)[count] = Pm / mul;
+	    }
+	}
+	
+      //convert things back
+      if(xvals->Type() != GDL_DOUBLE && !e->KeywordSet("DOUBLE"))
+	{
+	  return res->Convert2(GDL_FLOAT,BaseGDL::CONVERT);
+	}
+      else
+	{
+	  return res;
+	}
+    }
+    return new DByteGDL(0);
+  }
+
+  // Gamma, LnGamma, IGamma and Beta are now in math_fun_gm.cpp
+  // I rewrite them because they had many bugs (gregory.marchal_at_obspm.fr)
+
+  BaseGDL* gsl_exp(EnvT* e)
+  {
+    Guard<BaseGDL> cdr_guard;
+    Guard<BaseGDL> cd_guard;
+    Guard<BaseGDL> d_guard;
+    Guard<BaseGDL> fr_guard;
+
+
+    SizeT nParam = e->NParam(1);
+    BaseGDL* v=e->GetParDefined(0);   
+
+    size_t nEl = v->N_Elements();
+    size_t i;
+    if (v->Type() == GDL_STRING) {
+      e->Throw( 
+		  "String expression not allowed in this context: "
+			  +e->GetParString(0));
+    } else if (v->Type() == GDL_PTR) {
+      e->Throw( 
+		  "Pointer expression not allowed in this context: "
+			  +e->GetParString(0));
+    } else if (v->Type() == GDL_OBJ) {
+      e->Throw( 
+		  "Object expression not allowed in this context: "
+			  +e->GetParString(0));
+    } else if (v->Type() == GDL_STRUCT) {
+      e->Throw( 
+		  "Struct expression not allowed in this context: "
+			  +e->GetParString(0));		  
+    } else   {
+      //      DDoubleGDL* d;
+      DDoubleGDL* dr = new DDoubleGDL(v->Dim(), BaseGDL::NOZERO);
+      //      e->Guard( dr);
+
+      if(v->Type() == GDL_COMPLEX) {
+	DComplexDblGDL* cd=
+	  static_cast<DComplexDblGDL*>(v->Convert2(GDL_COMPLEXDBL, BaseGDL::COPY));
+	cd_guard.Reset(cd);//e->Guard( cd);
+
+	DComplexDblGDL* cdr =
+	  new DComplexDblGDL(v->Dim(), BaseGDL::NOZERO);
+	cdr_guard.Reset(cdr);//e->Guard( cdr);
+
+	if(nEl == 1) 
+	  (*cdr)[0]=
+	   DComplex((gsl_sf_exp((*cd)[0].real())*cos((*cd)[0].imag())),
+		    (gsl_sf_exp((*cd)[0].real())*sin((*cd)[0].imag())));
+	else
+	  for(i=0;i<nEl;++i) 
+	    (*cdr)[i]=
+	      DComplex((gsl_sf_exp((*cd)[i].real())*cos((*cd)[i].imag())),
+		       (gsl_sf_exp((*cd)[i].real())*sin((*cd)[i].imag())));
+
+	return static_cast<DComplexGDL*>(cdr->Convert2(GDL_COMPLEX,BaseGDL::COPY));
+
+      } else if(v->Type() == GDL_COMPLEXDBL) {
+	DComplexDblGDL* cd=
+	  static_cast<DComplexDblGDL*>(v->Convert2(GDL_COMPLEXDBL, BaseGDL::COPY));
+	cd_guard.Reset(cd);//e->Guard( cd);
+
+	DComplexDblGDL* cdr =
+	  new DComplexDblGDL(v->Dim(), BaseGDL::NOZERO);
+
+	if(nEl == 1) 
+	  (*cdr)[0]=
+	   DComplex((gsl_sf_exp((*cd)[0].real())*cos((*cd)[0].imag())),
+		    (gsl_sf_exp((*cd)[0].real())*sin((*cd)[0].imag())));
+	else
+	  for(i=0;i<nEl;i++) 
+	    (*cdr)[i]=
+	      DComplex((gsl_sf_exp((*cd)[i].real())*cos((*cd)[i].imag())),
+		       (gsl_sf_exp((*cd)[i].real())*sin((*cd)[i].imag())));
+	
+	return cdr;
+	
+      } else if(v->Type() == GDL_DOUBLE) {
+	
+	DDoubleGDL* d=static_cast<DDoubleGDL*>(v->Convert2(GDL_DOUBLE, 
+							   BaseGDL::COPY));
+	d_guard.Reset(d);//e->Guard( d);
+	if(nEl == 1) 
+	  (*dr)[0]=gsl_sf_exp((*d)[0]);
+	else
+	  for (i=0;i<nEl;++i) (*dr)[i]=gsl_sf_exp((*d)[i]);
+	
+	return dr;
+      } else if(v->Type() == GDL_FLOAT || 
+		v->Type() == GDL_INT ||
+		v->Type() == GDL_LONG) {
+	
+	DFloatGDL *fr=new DFloatGDL(v->Dim(), BaseGDL::NOZERO);
+	fr_guard.Reset(fr);//e->Guard( fr);
+
+	DDoubleGDL* d=static_cast<DDoubleGDL*>(v->Convert2(GDL_DOUBLE, 
+							   BaseGDL::COPY));
+	d_guard.Reset(d);//e->Guard( d);
+
+	if(nEl == 1) 
+	  (*dr)[0]=gsl_sf_exp((*d)[0]);
+	else
+	  for (i=0;i<nEl;++i) (*dr)[i]=gsl_sf_exp((*d)[i]);
+
+	return static_cast<DFloatGDL*>(dr->Convert2(GDL_FLOAT,BaseGDL::COPY));
+      }
+
+    }
+  }
+
+
+
+
+      
+
+
+			  			  
+ 
+} // namespace
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/basic_fun.cpp gdl/src/basic_fun.cpp
--- gdl-0.9.3/src/basic_fun.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/basic_fun.cpp	2013-05-16 12:36:33.114858282 -0600
@@ -1,6657 +1,6730 @@
-/***************************************************************************
-                          basic_fun.cpp  -  basic GDL library function
-                             -------------------
-    begin                : July 22 2002
-    copyright            : (C) 2002 by Marc Schellens (exceptions see below)
-    email                : m_schellens@users.sf.net
-
- strtok_fun, getenv_fun, tag_names_fun, stregex_fun:
- (C) 2004 by Peter Messmer    
- 
-***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "includefirst.hpp"
-
-// get_kbrd patch
-// http://sourceforge.net/forum/forum.php?thread_id=3292183&forum_id=338691
-#ifndef _MSC_VER
-#include <termios.h> 
-#include <unistd.h> 
-#endif
-#include <limits>
-#include <string>
-#include <fstream>
-//#include <memory>
-#include <regex.h> // stregex
-
-#ifdef __APPLE__
-# include <crt_externs.h>
-# define environ (*_NSGetEnviron())
-#endif
-
-#if defined(__FreeBSD__) || defined(__sun__) || defined(__OpenBSD__)
-extern "C" char **environ;
-#endif
-
-#include "nullgdl.hpp"
-#include "datatypes.hpp"
-#include "envt.hpp"
-#include "dpro.hpp"
-#include "dinterpreter.hpp"
-#include "basic_pro.hpp"
-#include "terminfo.hpp"
-#include "typedefs.hpp"
-#include "base64.hpp"
-
-#ifdef HAVE_LOCALE_H
-# include <locale.h>
-#endif
-
-/* max regexp error message length */
-#define MAX_REGEXPERR_LENGTH 80
-
-#ifdef _MSC_VER
-#define isfinite _finite
-#define isnan _isnan
-#define round(f) floor(f+0.5)
-int strncasecmp(const char *s1, const char *s2, size_t n)
-{
-  if (n == 0)
-    return 0;
-  while (n-- != 0 && tolower(*s1) == tolower(*s2))
-    {
-      if (n == 0 || *s1 == '\0' || *s2 == '\0')
-    break;
-      s1++;
-      s2++;
-    }
-
-  return tolower(*(unsigned char *) s1) - tolower(*(unsigned char *) s2);
-}
-#else
-#include <sys/utsname.h>
-#endif
-
-namespace lib {
-
-  using namespace std;
-  using namespace antlr;
-
-  // assumes all parameters from pOffs till end are dim
-  void arr( EnvT* e, dimension& dim, SizeT pOffs=0)
-  {
-
-    int nParam=e->NParam()-pOffs;
-
-    if( nParam <= 0)
-      e->Throw( "Incorrect number of arguments.");
-
-    const string BadDims="Array dimensions must be greater than 0.";
-
-
-    if( nParam == 1 ) {
-
-      BaseGDL* par = e->GetParDefined( pOffs); 
- 	
-      SizeT newDim;
-      int ret = par->Scalar2index( newDim);
-
-      if (ret < 0) throw GDLException(BadDims);
-
-      if( ret > 0) {  // single argument
-	if (newDim < 1) throw GDLException(BadDims);
-	dim << newDim;
-	return;
-      } 
-      if( ret == 0) { //  array argument
-	DLongGDL* ind = 
-	  static_cast<DLongGDL*>(par->Convert2(GDL_LONG, BaseGDL::COPY)); 	 
-	auto_ptr<DLongGDL> ind_guard( ind);
-		    //e->Guard( ind);
-
-	for(SizeT i =0; i < par->N_Elements(); ++i){
-	  if  ((*ind)[i] < 1) throw GDLException(BadDims);
-	  dim << (*ind)[i];
-	}
-	return;
-      }
-      e->Throw( "arr: should never arrive here.");	
-      return;
-    }
-
-    // max number checked in interpreter
-    SizeT endIx=nParam+pOffs;
-    for( SizeT i=pOffs; i<endIx; i++)
-      {
-	BaseGDL* par=e->GetParDefined( i);
-
-	SizeT newDim;
-	int ret=par->Scalar2index( newDim);
-	if( ret < 1 || newDim == 0) throw GDLException(BadDims);
-	dim << newDim;
-      }
-  }
-
-  BaseGDL* bytarr( EnvT* e)
-  {
-    dimension dim;
-//    try{
-      arr( e, dim);
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      if( e->KeywordSet(0)) return new DByteGDL(dim, BaseGDL::NOZERO);
-      return new DByteGDL(dim);
- //   }
- //   catch( GDLException& ex)
- //     {
-//	e->Throw( ex.getMessage());
-//      }
-  }
-  BaseGDL* intarr( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      if( e->KeywordSet(0)) return new DIntGDL(dim, BaseGDL::NOZERO);
-      return new DIntGDL(dim);
-//     }
-//     catch( GDLException& ex)
-//       {
-// 	e->Throw( "INTARR: "+ex.getMessage());
-//       }
-  }
-  BaseGDL* uintarr( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      if( e->KeywordSet(0)) return new DUIntGDL(dim, BaseGDL::NOZERO);
-      return new DUIntGDL(dim);
-//     }
-//     catch( GDLException& ex)
-//       {
-// 	e->Throw( "UINTARR: "+ex.getMessage());
-//       }
-  }
-  BaseGDL* lonarr( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      if( e->KeywordSet(0)) return new DLongGDL(dim, BaseGDL::NOZERO);
-      return new DLongGDL(dim);
-/*    }
-    catch( GDLException& ex)
-      {
-	e->Throw( "LONARR: "+ex.getMessage());
-      }*/
-  }
-  BaseGDL* ulonarr( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      if( e->KeywordSet(0)) return new DULongGDL(dim, BaseGDL::NOZERO);
-      return new DULongGDL(dim);
- /*   }
-    catch( GDLException& ex)
-      {
-	e->Throw( "ULONARR: "+ex.getMessage());
-      }
- */ 
-}
-  BaseGDL* lon64arr( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      if( e->KeywordSet(0)) return new DLong64GDL(dim, BaseGDL::NOZERO);
-      return new DLong64GDL(dim);
-/*    }
-    catch( GDLException& ex)
-      {
-	e->Throw( "LON64ARR: "+ex.getMessage());
-      }*/
-  }
-  BaseGDL* ulon64arr( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      if( e->KeywordSet(0)) return new DULong64GDL(dim, BaseGDL::NOZERO);
-      return new DULong64GDL(dim);
-/*  }
-    catch( GDLException& ex)
-      {
-	e->Throw( "ULON64ARR: "+ex.getMessage());
-      }*/
-  }
-  BaseGDL* fltarr( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      if( e->KeywordSet(0)) return new DFloatGDL(dim, BaseGDL::NOZERO);
-      return new DFloatGDL(dim);
-   /* }
-    catch( GDLException& ex)
-      {
-	e->Throw( "FLTARR: "+ex.getMessage());
-      }
-  */}
-  BaseGDL* dblarr( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      if( e->KeywordSet(0)) return new DDoubleGDL(dim, BaseGDL::NOZERO);
-      return new DDoubleGDL(dim);
-   /* }
-    catch( GDLException& ex)
-      {
-	e->Throw( "DBLARR: "+ex.getMessage());
-      }*/
-  }
-  BaseGDL* strarr( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      if( e->KeywordSet(0)) 
-	e->Throw( "Keyword parameters not allowed in call.");
-      return new DStringGDL(dim);
- /*   }
-    catch( GDLException& ex)
-      {
-	e->Throw( "STRARR: "+ex.getMessage());
-      }
- */ }
-  BaseGDL* complexarr( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      if( e->KeywordSet(0)) return new DComplexGDL(dim, BaseGDL::NOZERO);
-      return new DComplexGDL(dim);
-    /*}
-    catch( GDLException& ex)
-      {
-	e->Throw( "COMPLEXARR: "+ex.getMessage());
-      }
- */ }
-  BaseGDL* dcomplexarr( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-
-	if( e->KeywordSet(0)) return new DComplexDblGDL(dim, BaseGDL::NOZERO);
-      return new DComplexDblGDL(dim);
- /*   }
-    catch( GDLException& ex)
-      {
-	e->Throw( "DCOMPLEXARR: "+ex.getMessage());
-      }
- */ }
-  BaseGDL* ptrarr( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      DPtrGDL* ret;
-
-//       if( e->KeywordSet(0))
-// 	       ret= new DPtrGDL(dim);//, BaseGDL::NOZERO);
-//       else
-//     if( e->KeywordSet(1))
-// 	ret= new DPtrGDL(dim, BaseGDL::NOZERO);
-//       else
-// 	return new DPtrGDL(dim);
-    if( !e->KeywordSet(1))
-		return new DPtrGDL(dim);
-
-	ret= new DPtrGDL(dim, BaseGDL::NOZERO);
-
-	  SizeT nEl=ret->N_Elements();
-	  SizeT sIx=e->NewHeap(nEl);
-// #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
-// #pragma omp for
-	  for( SizeT i=0; i<nEl; i++)
-		(*ret)[i]=sIx+i;
-}
-      return ret;
-/*    }
-    catch( GDLException& ex)
-      {
-	e->Throw( "PTRARR: "+ex.getMessage());
-      }*/
-  }
-  BaseGDL* objarr( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-// reference counting      if( e->KeywordSet(0)) return new DObjGDL(dim, BaseGDL::NOZERO);
-      return new DObjGDL(dim);
-  /*  }
-    catch( GDLException& ex)
-      {
-	e->Throw( "OBJARR: "+ex.getMessage());
-      }
- */ }
-
-  BaseGDL* ptr_new( EnvT* e)
-  {
-    int nParam=e->NParam();
-    
-    if( nParam > 0)
-      {
-	// new ptr from undefined variable is allowed as well
-	BaseGDL* p= e->GetPar( 0);
-        if( p == NULL)
-	  {
-	    DPtr heapID= e->NewHeap();
-	    return new DPtrGDL( heapID);
-	  }
-
-	if( e->KeywordSet(0)) // NO_COPY
-	  {
-	    BaseGDL** p= &e->GetPar( 0);
-	    // 	    if( *p == NULL)
-	    // 	      e->Throw( "Parameter undefined: "+
-	    // 				  e->GetParString(0));
-
-	    DPtr heapID= e->NewHeap( 1, *p);
-	    *p=NULL;
-	    return new DPtrGDL( heapID);
-	  }
-	else
-	  {
-	    BaseGDL* p= e->GetParDefined( 0);
-
-	    DPtr heapID= e->NewHeap( 1, p->Dup());
-	    return new DPtrGDL( heapID);
-	  }
-      }
-    else
-      {
-	if( e->KeywordSet(1)) // ALLOCATE_HEAP
-	  {
-	    DPtr heapID= e->NewHeap();
-	    return new DPtrGDL( heapID);
-	  }
-	else
-	  {
-	    return new DPtrGDL( 0); // null ptr
-	  }
-      }
-  }
-
-  BaseGDL* ptr_valid( EnvT* e)
-  {
-    int nParam=e->NParam();
-    
-    if( e->KeywordPresent( 1)) // COUNT
-      {
-	e->SetKW( 1, new DLongGDL( e->Interpreter()->HeapSize()));
-      }
-
-    if( nParam == 0)
-      {
-	return e->Interpreter()->GetAllHeap();
-      } 
-
-    BaseGDL* p = e->GetPar( 0);
-    if( p == NULL)
-      {
-	return new DByteGDL( 0);
-      } 
-
-    if( e->KeywordSet( 0)) // CAST
-      {
-	DLongGDL* pL = dynamic_cast<DLongGDL*>( p);
-	auto_ptr<DLongGDL> pL_guard;
-	if( pL == NULL)
-	  {
-	    pL = static_cast<DLongGDL*>(p->Convert2(GDL_LONG,BaseGDL::COPY)); 
-	    pL_guard.reset( pL);
-	  }
-	
-	SizeT nEl = pL->N_Elements();
-	DPtrGDL* ret = new DPtrGDL( pL->Dim()); // zero
-	GDLInterpreter* interpreter = e->Interpreter();
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    if( interpreter->PtrValid( (*pL)[ i])) 
-	      (*ret)[ i] = (*pL)[ i];
-	  }
-	return ret;
-      }
-
-    DPtrGDL* pPtr = dynamic_cast<DPtrGDL*>( p);
-    if( pPtr == NULL)
-      {
-	return new DByteGDL( p->Dim()); // zero
-      }
-
-    SizeT nEl = pPtr->N_Elements();
-    DByteGDL* ret = new DByteGDL( pPtr->Dim()); // zero
-    GDLInterpreter* interpreter = e->Interpreter();
-    for( SizeT i=0; i<nEl; ++i)
-      {
-	if( interpreter->PtrValid( (*pPtr)[ i])) 
-	  (*ret)[ i] = 1;
-      }
-    return ret;
-  }
-
-  BaseGDL* obj_valid( EnvT* e)
-  {
-    int nParam=e->NParam();
-    
-    if( e->KeywordPresent( 1)) // COUNT
-      {
-	e->SetKW( 1, new DLongGDL( e->Interpreter()->ObjHeapSize()));
-      }
-
-    if( nParam == 0)
-      {
-	return e->Interpreter()->GetAllObjHeap();
-      } 
-
-    BaseGDL* p = e->GetPar( 0);
-    if( p == NULL)
-      {
-	return new DByteGDL( 0);
-      } 
-
-    if( e->KeywordSet( 0)) // CAST
-      {
-	DLongGDL* pL = dynamic_cast<DLongGDL*>( p);
-	auto_ptr<DLongGDL> pL_guard;
-	if( pL == NULL)
-	  {
-	    pL = static_cast<DLongGDL*>(p->Convert2(GDL_LONG,BaseGDL::COPY));
-	    pL_guard.reset( pL);
-	    //	    e->Guard( pL);
-	  }
-	
-	SizeT nEl = pL->N_Elements();
-	DObjGDL* ret = new DObjGDL( pL->Dim()); // zero
-	GDLInterpreter* interpreter = e->Interpreter();
-	for( SizeT i=0; i<nEl; ++i)
-	  {
-	    if( interpreter->ObjValid( (*pL)[ i])) 
-	      (*ret)[ i] = (*pL)[ i];
-	  }
-	return ret;
-      }
-
-    DObjGDL* pObj = dynamic_cast<DObjGDL*>( p);
-    if( pObj == NULL)
-      {
-	return new DByteGDL( p->Dim()); // zero
-      }
-
-    SizeT nEl = pObj->N_Elements();
-    DByteGDL* ret = new DByteGDL( pObj->Dim()); // zero
-    GDLInterpreter* interpreter = e->Interpreter();
-    for( SizeT i=0; i<nEl; ++i)
-      {
-	if( interpreter->ObjValid( (*pObj)[ i])) 
-	  (*ret)[ i] = 1;
-      }
-    return ret;
-  }
-
-  BaseGDL* obj_new( EnvT* e)
-  {
-    StackGuard<EnvStackT> guard( e->Interpreter()->CallStack());
-    
-    int nParam=e->NParam();
-    
-    if( nParam == 0)
-      {
-	return new DObjGDL( 0);
-      }
-    
-    DString objName;
-    e->AssureScalarPar<DStringGDL>( 0, objName);
-
-    // this is a struct name -> convert to UPPERCASE
-    objName=StrUpCase(objName);
-    if( objName == "IDL_OBJECT")
-      objName = GDL_OBJECT_NAME; // replacement also done in GDLParser
-
-    DStructDesc* objDesc=e->Interpreter()->GetStruct( objName, e->CallingNode());
-
-    DStructGDL* objStruct= new DStructGDL( objDesc, dimension());
-
-    DObj objID= e->NewObjHeap( 1, objStruct); // owns objStruct
-
-    BaseGDL* newObj = new DObjGDL( objID); // the object
-
-    try {
-      // call INIT function
-      DFun* objINIT= objDesc->GetFun( "INIT");
-      if( objINIT != NULL)
-	{
-	  // morph to obj environment and push it onto the stack again
-	  e->PushNewEnvUD( objINIT, 1, &newObj);
-	
-	  BaseGDL* res=e->Interpreter()->call_fun( objINIT->GetTree());
-	
-	  if( res == NULL || (!res->Scalar()) || res->False())
-	    {
-	      GDLDelete(res);
-	      return new DObjGDL( 0);
-	    }
-	  GDLDelete(res);
-	}
-    } catch(...) {
-      e->FreeObjHeap( objID); // newObj might be changed
-      GDLDelete(newObj);
-      throw;
-    }
-
-    return newObj;
-  }
-
-  BaseGDL* bindgen( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      return new DByteGDL(dim, BaseGDL::INDGEN);
-   /* }
-    catch( GDLException& ex)
-      {
-	e->Throw( "BINDGEN: "+ex.getMessage());
-      }
- */ }
-  // keywords not supported yet
-  BaseGDL* indgen( EnvT* e)
-  {
-    dimension dim;
-
-    // Defaulting to GDL_INT
-    DType type = GDL_INT;
-
-    static int kwIx1 = e->KeywordIx("BYTE");
-    if (e->KeywordSet(kwIx1)){ type = GDL_BYTE; }
-
-    static int kwIx2 = e->KeywordIx("COMPLEX");
-    if (e->KeywordSet(kwIx2)){ type = GDL_COMPLEX; }
-    
-    static int kwIx3 = e->KeywordIx("DCOMPLEX");
-    if (e->KeywordSet(kwIx3)){ type = GDL_COMPLEXDBL; }
-
-    static int kwIx4 = e->KeywordIx("DOUBLE");
-    if (e->KeywordSet(kwIx4)){ type = GDL_DOUBLE; }
-
-    static int kwIx5 = e->KeywordIx("FLOAT");
-    if (e->KeywordSet(kwIx5)){ type = GDL_FLOAT; }
-    
-    static int kwIx6 = e->KeywordIx("L64");
-    if (e->KeywordSet(kwIx6)){ type = GDL_LONG64; }
-
-    static int kwIx7 = e->KeywordIx("LONG");
-    if (e->KeywordSet(kwIx7)){ type = GDL_LONG; }
-
-    static int kwIx8 = e->KeywordIx("STRING");
-    if (e->KeywordSet(kwIx8)){ type = GDL_STRING; }
-
-    static int kwIx9 = e->KeywordIx("UINT");
-    if (e->KeywordSet(kwIx9)){ type = GDL_UINT; }
-
-    static int kwIx10 = e->KeywordIx("UL64");
-    if (e->KeywordSet(kwIx10)){ type = GDL_ULONG64; }
-
-    static int kwIx11 = e->KeywordIx("ULONG");
-    if (e->KeywordSet(kwIx11)){ type = GDL_ULONG; }
-    
-    /*try
-      {*/
-	// Seeing if the user passed in a TYPE code
-	static int kwIx12 = e->KeywordIx("TYPE");
-	if ( e->KeywordPresent(kwIx12)){
-	  DLong temp_long;
-	  e->AssureLongScalarKW(kwIx12, temp_long);
-	  type = static_cast<DType>(temp_long);
-	}
-
-	arr(e, dim);
-	if (dim[0] == 0)
-	  throw GDLException( "Array dimensions must be greater than 0");
-
-	switch(type)
-	  {
-	  case GDL_INT:        return new DIntGDL(dim, BaseGDL::INDGEN);
-	  case GDL_BYTE:       return new DByteGDL(dim, BaseGDL::INDGEN);
-	  case GDL_COMPLEX:    return new DComplexGDL(dim, BaseGDL::INDGEN);
-	  case GDL_COMPLEXDBL: return new DComplexDblGDL(dim, BaseGDL::INDGEN);
-	  case GDL_DOUBLE:     return new DDoubleGDL(dim, BaseGDL::INDGEN);
-	  case GDL_FLOAT:      return new DFloatGDL(dim, BaseGDL::INDGEN);
-	  case GDL_LONG64:     return new DLong64GDL(dim, BaseGDL::INDGEN);
-	  case GDL_LONG:       return new DLongGDL(dim, BaseGDL::INDGEN);
-	  case GDL_STRING: {
-	    DULongGDL* iGen = new DULongGDL(dim, BaseGDL::INDGEN);
-	    return iGen->Convert2(GDL_STRING);
-	  }
-	  case GDL_UINT:       return new DUIntGDL(dim, BaseGDL::INDGEN);
-	  case GDL_ULONG64:    return new DULong64GDL(dim, BaseGDL::INDGEN);
-	  case GDL_ULONG:      return new DULongGDL(dim, BaseGDL::INDGEN);
-	  default:
-	    e->Throw( "Invalid type code specified.");
-	    break;
-	  }
-/*      }
-    catch( GDLException& ex)
-      {
-	e->Throw( ex.getMessage());
-      }*/
-  }
-
-  BaseGDL* uindgen( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      return new DUIntGDL(dim, BaseGDL::INDGEN);
-   /* }
-    catch( GDLException& ex)
-      {
-	e->Throw( "UINDGEN: "+ex.getMessage());
-      }
- */ }
-  BaseGDL* sindgen( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      DULongGDL* iGen = new DULongGDL(dim, BaseGDL::INDGEN);
-      return iGen->Convert2( GDL_STRING);
-/*    }
-    catch( GDLException& ex)
-      {
-	e->Throw( "SINDGEN: "+ex.getMessage());
-      }*/
-  }
-  BaseGDL* lindgen( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      return new DLongGDL(dim, BaseGDL::INDGEN);
-/*    }
-    catch( GDLException& ex)
-      {
-	e->Throw( "LINDGEN: "+ex.getMessage());
-      }*/
-  }
-  BaseGDL* ulindgen( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      return new DULongGDL(dim, BaseGDL::INDGEN);
-/*    }
-    catch( GDLException& ex)
-      {
-	e->Throw( "ULINDGEN: "+ex.getMessage());
-      }*/
-  }
-  BaseGDL* l64indgen( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      return new DLong64GDL(dim, BaseGDL::INDGEN);
-  /*  }
-    catch( GDLException& ex)
-      {
-	e->Throw( "L64INDGEN: "+ex.getMessage());
-      }*/
-  }
-  BaseGDL* ul64indgen( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      return new DULong64GDL(dim, BaseGDL::INDGEN);
- /*   }
-    catch( GDLException& ex)
-      {
-	e->Throw( "UL64INDGEN: "+ex.getMessage());
-      }
- */ }
-  BaseGDL* findgen( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      return new DFloatGDL(dim, BaseGDL::INDGEN);
-  /*  }
-    catch( GDLException& ex)
-      {
-	e->Throw( "FINDGEN: "+ex.getMessage());
-      }*/
-  }
-  BaseGDL* dindgen( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      return new DDoubleGDL(dim, BaseGDL::INDGEN);
-  /*  }
-    catch( GDLException& ex)
-      {
-	e->Throw( "DINDGEN: "+ex.getMessage());
-      }*/
-  }
-  BaseGDL* cindgen( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      return new DComplexGDL(dim, BaseGDL::INDGEN);
-  /*  }
-    catch( GDLException& ex)
-      {
-	e->Throw( "CINDGEN: "+ex.getMessage());
-      }*/
-  }
-  BaseGDL* dcindgen( EnvT* e)
-  {
-    dimension dim;
-//     try{
-      arr( e, dim); 
-      if (dim[0] == 0)
-	throw GDLException( "Array dimensions must be greater than 0");
-
-      return new DComplexDblGDL(dim, BaseGDL::INDGEN);
-  /*  }
-    catch( GDLException& ex)
-      {
-	e->Throw( "DCINDGEN: "+ex.getMessage());
-      }
- */ }
-
-  // only called from CALL_FUNCTION 
-  // otherwise done directly in FCALL_LIB_N_ELEMENTSNode::Eval();
-  // (but must be defined anyway for LibInit() for correct parametrization)
-  // N_ELEMENTS is special because on error it just returns 0L
-  // (the error is just caught and dropped)
-  BaseGDL* n_elements( EnvT* e)
-  {
-    SizeT nParam=e->NParam(1);
-
-    BaseGDL* p0=e->GetPar( 0);
-
-    if( p0 == NULL) return new DLongGDL( 0);
-    return new DLongGDL( p0->N_Elements()); 
-    
-//     assert( 0);
-//     e->Throw("Internal error: lib::n_elements called.");
-//     return NULL; // get rid of compiler warning
-  }
-
-  template< typename ComplexGDL, typename Complex, typename Float>
-  BaseGDL* complex_fun_template( EnvT* e)
-  {
-    SizeT nParam=e->NParam( 1);
-    if( nParam <= 2)
-      {
-	if( nParam == 2)
-	  {
-	    BaseGDL* p0=e->GetParDefined( 0);
-	    BaseGDL* p1=e->GetParDefined( 1);
-	    auto_ptr<Float> p0Float( static_cast<Float*>
-				     (p0->Convert2( Float::t,BaseGDL::COPY)));
-	    auto_ptr<Float> p1Float( static_cast<Float*>
-				     (p1->Convert2( Float::t,BaseGDL::COPY)));
-	    if( p0Float->Rank() == 0)
-	      {
-		ComplexGDL* res = new ComplexGDL( p1Float->Dim(), 
-						  BaseGDL::NOZERO);
-		
-		SizeT nE=p1Float->N_Elements();
-// #pragma omp parallel if (nE >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nE))
-{
-// #pragma omp for
-		for( SizeT i=0; i<nE; i++)
-		  {
-		    (*res)[i]=Complex( (*p0Float)[0], (*p1Float)[i]);
-		  }
-}
-		return res;
-	      }
-	    else if( p1Float->Rank() == 0)
-	      {
-		ComplexGDL* res = new ComplexGDL( p0Float->Dim(), 
-						  BaseGDL::NOZERO);
-		
-		SizeT nE=p0Float->N_Elements();
-// #pragma omp parallel if (nE >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nE))
-{
-// #pragma omp for
-		for( SizeT i=0; i<nE; i++)
-		  {
-		    (*res)[i]=Complex( (*p0Float)[i], (*p1Float)[0]);
-		  }
-}
-		return res;
-	      }
-	    else if( p0Float->N_Elements() >= p1Float->N_Elements())
-	      {
-		ComplexGDL* res = new ComplexGDL( p1Float->Dim(), 
-						  BaseGDL::NOZERO);
-
-		SizeT nE=p1Float->N_Elements();
-// #pragma omp parallel if (nE >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nE))
-{
-// #pragma omp for
-		for( SizeT i=0; i<nE; i++)
-		  {
-		    (*res)[i]=Complex( (*p0Float)[i], (*p1Float)[i]);
-		  }
-}
-		return res;
-	      }
-	    else
-	      {
-		ComplexGDL* res = new ComplexGDL( p0Float->Dim(), 
-						  BaseGDL::NOZERO);
-		
-		SizeT nE=p0Float->N_Elements();
-// #pragma omp parallel if (nE >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nE))
-{
-// #pragma omp for
-		for( SizeT i=0; i<nE; i++)
-		  {
-		    (*res)[i]=Complex( (*p0Float)[i], (*p1Float)[i]);
-		  }
-}
-		return res;
-	      }
-	  }
-	else
-	  {
-            // SA: see tracker item 3151760 
-	    BaseGDL* p0 = e->GetParDefined( 0);
-            if (ComplexGDL::t == p0->Type() && e->GlobalPar(0)) return p0;
-	    return p0->Convert2( ComplexGDL::t, BaseGDL::COPY);
-	  }
-      }
-    else // GDL_COMPLEX( expr, offs, dim1,..,dim8)
-      {
-	BaseGDL* p0 = e->GetParDefined( 0);
-	// *** WRONG: with offs data is converted bytewise
-	auto_ptr<Float> p0Float(static_cast<Float*>
-				(p0->Convert2( Float::t,
-					       BaseGDL::COPY)));
-	DLong offs;
-	e->AssureLongScalarPar( 1, offs);
-      
-	dimension dim;
-	arr( e, dim, 2);
-
-	SizeT nElCreate=dim.NDimElements();
-	
-	SizeT nElSource=p0->N_Elements();
-      
-	if( (offs+2*nElCreate) > nElSource)
-	  e->Throw( "Specified offset to"
-		    " array is out of range: "+e->GetParString(0));
-	
-	ComplexGDL* res=new ComplexGDL( dim, BaseGDL::NOZERO);
-
-// #pragma omp parallel if (nElCreate >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nElCreate))
-{
-// #pragma omp for
-	for( SizeT i=0; i<nElCreate; i++)
-	  {
-	    SizeT srcIx=2*i+offs;
-	    (*res)[i]=Complex( (*p0Float)[srcIx], (*p0Float)[srcIx+1]);
-	  }
-}	
-	return res;
-      }
-  }
-
-BaseGDL* complex_fun( EnvT* e)
-{
-  if (e->KeywordSet("DOUBLE")) {
-    return complex_fun_template< DComplexDblGDL, DComplexDbl, DDoubleGDL>( e);
-  } else {
-    return complex_fun_template< DComplexGDL, DComplex, DFloatGDL>( e);
-  }      
-}
-BaseGDL* dcomplex_fun( EnvT* e)
-{
-  return complex_fun_template< DComplexDblGDL, DComplexDbl, DDoubleGDL>( e);
-}
-
-  template< class TargetClass>
-  BaseGDL* type_fun( EnvT* e)
-  {
-    SizeT nParam=e->NParam(1);
-
-    if( nParam == 1)
-      {
-	BaseGDL* p0=e->GetParDefined( 0);
-
-	assert( dynamic_cast< EnvUDT*>( e->Caller()) != NULL);
-
-	// type_fun( expr) just convert
-	if( static_cast< EnvUDT*>( e->Caller())->GetIOError() != NULL) 
-	  return p0->Convert2( TargetClass::t, 
-			       BaseGDL::COPY_THROWIOERROR);
-        // SA: see tracker item no. 3151760 
-        else if (TargetClass::t == p0->Type() && e->GlobalPar(0)) 
-          return p0;
-	else
-	  return p0->Convert2( TargetClass::t, BaseGDL::COPY);
-      }
-    
-    BaseGDL* p0=e->GetNumericParDefined( 0);
-
-    // GDL_BYTE( expr, offs, dim1,..,dim8)
-    DLong offs;
-    e->AssureLongScalarPar( 1, offs);
-
-    dimension dim;
-
-    if( nParam > 2)
-      arr( e, dim, 2);
-    
-    TargetClass* res=new TargetClass( dim, BaseGDL::NOZERO);
-
-    SizeT nByteCreate=res->NBytes(); // net size of new data
-      
-    SizeT nByteSource=p0->NBytes(); // net size of src
-      
-    if( offs < 0 || (offs+nByteCreate) > nByteSource)
-      {
-	GDLDelete(res);
-	e->Throw( "Specified offset to"
-		  " expression is out of range: "+e->GetParString(0));
-      }
-
-    //*** POSSIBLE ERROR because of alignment here
-    void* srcAddr = static_cast<void*>( static_cast<char*>(p0->DataAddr()) + 
-					offs);
-    void* dstAddr = static_cast<void*>(&(*res)[0]);
-    memcpy( dstAddr, srcAddr, nByteCreate);
-
-    //     char* srcAddr = reinterpret_cast<char*>(p0->DataAddr());
-    //     char* dstAddr = reinterpret_cast<char*>(&(*res)[0]);
-    //     copy( srcAddr, srcAddr+nByteCreate, dstAddr);
-
-    return res;
-  }
-
-  BaseGDL* byte_fun( EnvT* e)
-  {
-    return type_fun<DByteGDL>( e);
-  }
-  BaseGDL* uint_fun( EnvT* e)
-  {
-    return type_fun<DUIntGDL>( e);
-  }
-  BaseGDL* long_fun( EnvT* e)
-  {
-    return type_fun<DLongGDL>( e);
-  }
-  BaseGDL* ulong_fun( EnvT* e)
-  {
-    return type_fun<DULongGDL>( e);
-  }
-  BaseGDL* long64_fun( EnvT* e)
-  {
-    return type_fun<DLong64GDL>( e);
-  }
-  BaseGDL* ulong64_fun( EnvT* e)
-  {
-    return type_fun<DULong64GDL>( e);
-  }
-  BaseGDL* float_fun( EnvT* e)
-  {
-    return type_fun<DFloatGDL>( e);
-  }
-  BaseGDL* double_fun( EnvT* e)
-  {
-    return type_fun<DDoubleGDL>( e);
-  }
-  // GDL_STRING function behaves different
-  BaseGDL* string_fun( EnvT* e)
-  {
-    SizeT nParam=e->NParam();
-
-    if( nParam == 0)
-      e->Throw( "Incorrect number of arguments.");
-
-    bool printKey =  e->KeywordSet( 4);
-    int parOffset = 0; 
-
-    // SA: handling special VMS-compatibility syntax, e.g.: string(1,'$(F)')
-    //     (if nor FORMAT neither PRINT defined, >1 parameter, last param is scalar string
-    //     which begins with "$(" or "(" but is not "()" then last param [minus "$"] is treated as FORMAT)
-    bool vmshack = false;
-    if (!printKey && (e->GetKW(0) == NULL) && nParam > 1) 
-    {    
-      vmshack = true;
-      BaseGDL* par = e->GetParDefined(nParam - 1);
-      if (par->Type() == GDL_STRING && par->Scalar())
-      {
-        int dollar = (*static_cast<DStringGDL*>(par))[0].compare(0,2,"$(");
-        if (dollar == 0 || ((*static_cast<DStringGDL*>(par))[0].compare(0,1,"(") == 0 && (*static_cast<DStringGDL*>(par))[0] != "()"))   
-        {    
-          e->SetKeyword("FORMAT", new DStringGDL(
-            (*static_cast<DStringGDL*>(par))[0].c_str() + (dollar == 0 ? 1 : 0) 
-          ));
-        }
-      }    
-    }    
-
-    BaseGDL* format_kw = e->GetKW( 0);
-    bool formatKey = format_kw != NULL;
-
-    if (formatKey && format_kw->Type() == GDL_STRING && (*static_cast<DStringGDL*>(format_kw))[0] == "") formatKey = false;
-
-    if( printKey || formatKey) // PRINT or FORMAT
-      {
-	stringstream os;
-
-	SizeT width = 0;
-	if( printKey) // otherwise: FORMAT -> width is ignored
-	  {
-	    // for /PRINT always a terminal width of 80 is assumed
-	    width = 80;//TermWidth();
-	  }
-	
-        if (vmshack)
-        {
-          parOffset = 1; 
-          e->ShiftParNumbering(1);
-        }
-	print_os( &os, e, parOffset, width);
-        if (vmshack) 
-        {
-          e->ShiftParNumbering(-1);
-	}
-
-	deque<DString> buf;
-	while( os.good())
-	  {
-	    string line;
-	    getline( os, line);
-	    if( os.good()) buf.push_back( line);
-	  }
-
-	SizeT bufSize = buf.size();
-	if( bufSize == 0)
-	  e->Throw( "Internal error: print buffer empty.");
-
-	if( bufSize > 1) 
-	  {
-	    DStringGDL* retVal = 
-	      new DStringGDL( dimension( bufSize), BaseGDL::NOZERO);
-
-	    for( SizeT i=0; i<bufSize; ++i)
-	      (*retVal)[ i] = buf[ i];
-
-	    return retVal;
-	  }
-	else
-	  return new DStringGDL( buf[0]);
-      }
-    else
-      {
-	if( nParam == 1) // nParam == 1 -> conversion
-	  {
-	    BaseGDL* p0 = e->GetParDefined( 0);
-            // SA: see tracker item no. 3151760 
-            if (p0->Type() == GDL_STRING && e->GlobalPar(0)) return p0;
-	    return p0->Convert2( GDL_STRING, BaseGDL::COPY);
-	  }
-	else // concatenation
-	  {
-	    DString s;
-	    for( SizeT i=0; i<nParam; ++i)
-	      {
-		BaseGDL* p = e->GetParDefined( i);
-		DStringGDL* sP = static_cast<DStringGDL*>
-		  ( p->Convert2(GDL_STRING,
-				BaseGDL::COPY_BYTE_AS_INT));
-
-		SizeT nEl = sP->N_Elements();
-		for( SizeT e=0; e<nEl; ++e)
-		  s += (*sP)[ e];
-		GDLDelete(sP);
-	      }
-	    // IDL here breaks the string into tty-width substrings
-	    return new DStringGDL( s);
-	  }
-      }
-  }
-
-  BaseGDL* fix_fun( EnvT* e)
-  {
-    DIntGDL* type = e->IfDefGetKWAs<DIntGDL>( 0);
-    if (type != NULL) {
-      int typ = (*type)[0];
-      if (typ == GDL_BYTE)
-      {
-        // SA: slow yet simple solution using GDL_BYTE->GDL_INT->GDL_BYTE conversion
-        return (e->KeywordSet(1) && e->GetPar(0)->Type() == GDL_STRING)
-          ? type_fun<DIntGDL>( e)->Convert2(GDL_BYTE, BaseGDL::CONVERT) 
-          : type_fun<DByteGDL>( e);
-      }
-      if (typ == 0 || typ == GDL_INT) return type_fun<DIntGDL>( e);
-      if (typ == GDL_UINT) return type_fun<DUIntGDL>( e);
-      if (typ == GDL_LONG) return type_fun<DLongGDL>( e);
-      if (typ == GDL_ULONG) return type_fun<DULongGDL>( e);
-      if (typ == GDL_LONG64) return type_fun<DLong64GDL>( e);
-      if (typ == GDL_ULONG64) return type_fun<DULong64GDL>( e);
-      if (typ == GDL_FLOAT) return type_fun<DFloatGDL>( e);
-      if (typ == GDL_DOUBLE) return type_fun<DDoubleGDL>( e);
-      if (typ == GDL_COMPLEX) return type_fun<DComplexGDL>( e);
-      if (typ == GDL_COMPLEXDBL) return type_fun<DComplexDblGDL>( e);
-      if (typ == GDL_STRING) 
-      {
-        // SA: calling GDL_STRING() with correct parameters
-        static int stringIx = LibFunIx("STRING");
-
-		assert( stringIx >= 0);
-		
-        EnvT* newEnv= new EnvT(e, libFunList[stringIx], NULL);
-
-		auto_ptr<EnvT> guard( newEnv);
-
-		newEnv->SetNextPar(&e->GetPar(0)); // pass as global
-        if (e->KeywordSet(1) && e->GetPar(0)->Type() == GDL_BYTE)
-          newEnv->SetKeyword("PRINT", new DIntGDL(1));
-//         e->Interpreter()->CallStack().push_back( newEnv); 
-        return static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
-      }
-      e->Throw( "Improper TYPE value.");
-    }
-    return type_fun<DIntGDL>( e);
-  }
-
-  BaseGDL* call_function( EnvT* e)
-  {
-    int nParam=e->NParam();
-    if( nParam == 0)
-     e->Throw( "No function specified.");
-    
-    DString callF;
-    e->AssureScalarPar<DStringGDL>( 0, callF);
-
-    // this is a function name -> convert to UPPERCASE
-    callF = StrUpCase( callF);
-
-    // first search library funcedures
-    int funIx=LibFunIx( callF);
-    if( funIx != -1)
-      {
-// 	e->PushNewEnv( libFunList[ funIx], 1);
-	// make the call
-// 	EnvT* newEnv = static_cast<EnvT*>(e->Interpreter()->CallStack().back());
-
-	// handle direct call functions 
-	if( libFunList[ funIx]->DirectCall())
-	{
-	  BaseGDL* directCallParameter = e->GetParDefined(1);
-	  BaseGDL* res = 
-	  static_cast<DLibFunDirect*>(libFunList[ funIx])->FunDirect()(directCallParameter, true /*isReference*/);
-	  return res;
-	}
-	else
-	{
-	EnvT* newEnv = e->NewEnv( libFunList[ funIx], 1);
-	auto_ptr<EnvT> guard( newEnv);
-	return static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
-	}
-      }
-    else
-      {
-	// no direct call here
-	
-	StackGuard<EnvStackT> guard( e->Interpreter()->CallStack());
-
-	funIx = GDLInterpreter::GetFunIx( callF);
-	
-	e->PushNewEnvUD( funList[ funIx], 1);
-	
-	// make the call
-	EnvUDT* newEnv = static_cast<EnvUDT*>(e->Interpreter()->CallStack().back());
-	return e->Interpreter()->call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
-      }
-  }
-
-  BaseGDL* call_method_function( EnvT* e)
-  {
-    StackGuard<EnvStackT> guard( e->Interpreter()->CallStack());
-
-    int nParam=e->NParam();
-    if( nParam < 2)
-      e->Throw(  "Name and object reference"
-			  " must be specified.");
-    
-    DString callP;
-    e->AssureScalarPar<DStringGDL>( 0, callP);
-
-    // this is a procedure name -> convert to UPPERCASE
-    callP = StrUpCase( callP);
-    
-    DStructGDL* oStruct = e->GetObjectPar( 1);
-
-    DFun* method= oStruct->Desc()->GetFun( callP);
-
-    if( method == NULL)
-      e->Throw( "Method not found: "+callP);
-// // // /**/
-    e->PushNewEnvUD( method, 2, &e->GetPar( 1));
-    
-    // make the call
-    return e->Interpreter()->call_fun( method->GetTree());
-  }
-
-
-
-  BaseGDL* execute( EnvT* e)
-  {
-    int nParam=e->NParam( 1);
-
-    bool quietCompile = false;
-    if( nParam == 2)
-      {
-		BaseGDL* p1 = e->GetParDefined( 1);
-
-		if( !p1->Scalar())
-		  e->Throw( "Expression must be scalar in this context: "+
-				      e->GetParString(1));
-
-		quietCompile = p1->True();
-      }
-
-    if (e->GetParDefined(0)->Rank() != 0)
-      e->Throw("Expression must be scalar in this context: "+e->GetParString(0));
-    
-    DString line;
-    e->AssureScalarPar<DStringGDL>( 0, line);
-
-    // remove current environment (own one)
-    assert( dynamic_cast<EnvUDT*>(e->Caller()) != NULL);
-    EnvUDT* caller = static_cast<EnvUDT*>(e->Caller());
-//     e->Interpreter()->CallStack().pop_back();
-
-// wrong: e is guarded, do not delete it here	
-//	delete e;
-
-    istringstream istr(line+"\n");
-
-    RefDNode theAST;
-    try {  
-      GDLLexer   lexer(istr, "", caller->CompileOpt());
-      GDLParser& parser=lexer.Parser();
-    
-      parser.interactive();
-    
-      theAST=parser.getAST();
-    }
-    catch( GDLException& ex)
-      {
-	if( !quietCompile) GDLInterpreter::ReportCompileError( ex);
-	return new DIntGDL( 0);
-      }
-    catch( ANTLRException ex)
-      {
-	if( !quietCompile) cerr << "EXECUTE: Lexer/Parser exception: " <<  
-			     ex.getMessage() << endl;
-	return new DIntGDL( 0);
-      }
-    
-    if( theAST == NULL) return new DIntGDL( 1);
-
-    RefDNode trAST;
-    try
-      {
-	GDLTreeParser treeParser( caller);
-	  
-	treeParser.interactive(theAST);
-
-	trAST=treeParser.getAST();
-      }
-    catch( GDLException& ex)
-      {
-	if( !quietCompile) GDLInterpreter::ReportCompileError( ex);
-	return new DIntGDL( 0);
-      }
-
-    catch( ANTLRException ex)
-      {
-	if( !quietCompile) cerr << "EXECUTE: Compiler exception: " <<  
-			     ex.getMessage() << endl;
-	return new DIntGDL( 0);
-      }
-      
-    if( trAST == NULL) return new DIntGDL( 1);
-
-	int nForLoopsIn = caller->NForLoops();
-    try
-      {
-		ProgNodeP progAST = ProgNode::NewProgNode( trAST);
-		auto_ptr< ProgNode> progAST_guard( progAST);
-
-		int nForLoops = ProgNode::NumberForLoops( progAST, nForLoopsIn);
-		caller->ResizeForLoops( nForLoops);
-
-		progAST->setLine( e->GetLineNumber());
-
-		RetCode retCode = caller->Interpreter()->execute( progAST);
-
-		caller->ResizeForLoops( nForLoopsIn);
-
-		if( retCode == RC_OK)
-		return new DIntGDL( 1);
-		else
-		return new DIntGDL( 0);
-      }
-    catch( GDLException& ex)
-      {
-		caller->ResizeForLoops( nForLoopsIn);
-		// are we throwing to target environment?
-// 		if( ex.GetTargetEnv() == NULL)
-			if( !quietCompile) cerr << "EXECUTE: " <<
-					ex.getMessage() << endl;
-		return new DIntGDL( 0);
-      }
-    catch( ANTLRException ex)
-      {
-		caller->ResizeForLoops( nForLoopsIn);
-		
-		if( !quietCompile) cerr << "EXECUTE: Interpreter exception: " <<
-					ex.getMessage() << endl;
-		return new DIntGDL( 0);
-      }
-
-    return new DIntGDL( 0); // control flow cannot reach here - compiler shut up
-  }
-
-  BaseGDL* assoc( EnvT* e)
-  {
-    SizeT nParam=e->NParam( 2);
-
-    DLong lun;
-    e->AssureLongScalarPar( 0, lun);
-
-    bool stdLun = check_lun( e, lun);
-    if( stdLun)
-      e->Throw( "File unit does not allow"
-		" this operation. Unit: "+i2s( lun));
-
-    DLong offset = 0;
-    if( nParam >= 3) e->AssureLongScalarPar( 2, offset);
-    
-    BaseGDL* arr = e->GetParDefined( 1);
-    
-    if( arr->StrictScalar())
-      e->Throw( "Scalar variable not allowed in this"
-		" context: "+e->GetParString(1));
-    
-    return arr->AssocVar( lun, offset);
-  }
-
-  // gdl_ naming because of weired namespace problem in MSVC
-  BaseGDL* gdl_logical_and( EnvT* e)
-  {
-    SizeT nParam=e->NParam();
-    if( nParam != 2)
-      e->Throw(
-			  "Incorrect number of arguments.");
-
-    BaseGDL* e1=e->GetParDefined( 0);//, "LOGICAL_AND");
-    BaseGDL* e2=e->GetParDefined( 1);//, "LOGICAL_AND");
-
-    ULong nEl1 = e1->N_Elements();
-    ULong nEl2 = e2->N_Elements();
-
-    Data_<SpDByte>* res;
-
-    if( e1->Scalar()) 
-      {
-	if( e1->LogTrue(0)) 
-	  {
-	    res= new Data_<SpDByte>( e2->Dim(), BaseGDL::NOZERO);
-// #pragma omp parallel if (nEl2 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl2))
-{
-// #pragma omp for
-	    for( SizeT i=0; i < nEl2; i++)
-	      (*res)[i] = e2->LogTrue( i) ? 1 : 0;
-}
-	  }
-	else
-	  {
-	    return new Data_<SpDByte>( e2->Dim());
-	  }
-      }
-    else if( e2->Scalar()) 
-      {
-	if( e2->LogTrue(0)) 
-	  {
-	    res= new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
-// #pragma omp parallel if (nEl1 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl1))
-{
-// #pragma omp for
-	    for( SizeT i=0; i < nEl1; i++)
-	      (*res)[i] = e1->LogTrue( i) ? 1 : 0;
-}
-	  }
-	else
-	  {
-	    return new Data_<SpDByte>( e1->Dim());
-	  }
-      }
-    else if( nEl2 < nEl1) 
-      {
-	res= new Data_<SpDByte>( e2->Dim(), BaseGDL::NOZERO);
-// #pragma omp parallel if (nEl2 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl2))
-{
-// #pragma omp for
-	for( SizeT i=0; i < nEl2; i++)
-	  (*res)[i] = (e1->LogTrue( i) && e2->LogTrue( i)) ? 1 : 0;
-}
-      }
-    else // ( nEl2 >= nEl1)
-      {
-	res= new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
-// #pragma omp parallel if (nEl1 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl1))
-{
-// #pragma omp for
-	for( SizeT i=0; i < nEl1; i++)
-	  (*res)[i] = (e1->LogTrue( i) && e2->LogTrue( i)) ? 1 : 0;
-}
-      }
-    return res;
-  }
-
-  // gdl_ naming because of weired namespace problem in MSVC
-  BaseGDL* gdl_logical_or( EnvT* e)
-  {
-    SizeT nParam=e->NParam();
-    if( nParam != 2)
-      e->Throw(
-			  "Incorrect number of arguments.");
-
-    BaseGDL* e1=e->GetParDefined( 0);//, "LOGICAL_OR");
-    BaseGDL* e2=e->GetParDefined( 1);//, "LOGICAL_OR");
-
-    ULong nEl1 = e1->N_Elements();
-    ULong nEl2 = e2->N_Elements();
-
-    Data_<SpDByte>* res;
-
-    if( e1->Scalar()) 
-      {
-	if( e1->LogTrue(0)) 
-	  {
-	    res= new Data_<SpDByte>( e2->Dim(), BaseGDL::NOZERO);
-// #pragma omp parallel if (nEl2 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl2))
-{
-// #pragma omp for
-	    for( SizeT i=0; i < nEl2; i++)
-	      (*res)[i] = 1;
-}
-	  }
-	else
-	  {
-	    res= new Data_<SpDByte>( e2->Dim(), BaseGDL::NOZERO);
-// #pragma omp parallel if (nEl2 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl2))
-{
-// #pragma omp for
-	    for( SizeT i=0; i < nEl2; i++)
-	      (*res)[i] = e2->LogTrue( i) ? 1 : 0;
-}
-	  }
-      }
-    else if( e2->Scalar()) 
-      {
-	if( e2->LogTrue(0)) 
-	  {
-	    res= new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
-// #pragma omp parallel if (nEl1 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl1))
-{
-// #pragma omp for
-	    for( SizeT i=0; i < nEl1; i++)
-	      (*res)[i] = 1;
-}
-	  }
-	else
-	  {
-	    res= new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
-// #pragma omp parallel if (nEl1 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl1))
-{
-// #pragma omp for
-	    for( SizeT i=0; i < nEl1; i++)
-	      (*res)[i] = e1->LogTrue( i) ? 1 : 0;
-}
-	  }
-      }
-    else if( nEl2 < nEl1) 
-      {
-	res= new Data_<SpDByte>( e2->Dim(), BaseGDL::NOZERO);
-// #pragma omp parallel if (nEl2 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl2))
-{
-// #pragma omp for
-	for( SizeT i=0; i < nEl2; i++)
-	  (*res)[i] = (e1->LogTrue( i) || e2->LogTrue( i)) ? 1 : 0;
-}
-      }
-    else // ( nEl2 >= nEl1)
-      {
-	res= new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
-// #pragma omp parallel if (nEl1 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl1))
-{
-// #pragma omp for
-	for( SizeT i=0; i < nEl1; i++)
-	  (*res)[i] = (e1->LogTrue( i) || e2->LogTrue( i)) ? 1 : 0;
-}
-      }
-    return res;
-  }
-
-  BaseGDL* logical_true( BaseGDL* e1, bool isReference)//( EnvT* e);
-  {
-    assert( e1 != NULL);
-    assert( e1->N_Elements() > 0);
-    
-
-//     SizeT nParam=e->NParam();
-//     if( nParam != 1)
-//       e->Throw(
-// 			  "Incorrect number of arguments.");
-// 
-//     BaseGDL* e1=e->GetParDefined( 0);//, "LOGICAL_TRUE");
-//     
-    ULong nEl1 = e1->N_Elements();
-
-    Data_<SpDByte>* res = new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
-// #pragma omp parallel if (nEl1 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl1))
-{
-// #pragma omp for
-    for( SizeT i=0; i < nEl1; i++)
-      (*res)[i] = e1->LogTrue( i) ? 1 : 0;
-}    
-    return res;
-  }
-
-  BaseGDL* replicate( EnvT* e)
-  {
-    SizeT nParam=e->NParam();
-    if( nParam < 2)
-      e->Throw( "Incorrect number of arguments.");
-    dimension dim;
-    arr( e, dim, 1);
-
-    BaseGDL* p0=e->GetParDefined( 0);//, "REPLICATE");
-    if( !p0->Scalar())
-      e->Throw(	"Expression must be a scalar in this context: "+
-		e->GetParString(0));
-
-    return p0->New( dim, BaseGDL::INIT);
-  }
-
-  BaseGDL* strtrim( EnvT* e)
-  {
-    SizeT nParam = e->NParam( 1);//, "STRTRIM");
-
-    BaseGDL* p0 = e->GetPar( 0);
-    if( p0 == NULL)
-      e->Throw(
-			  "Variable is undefined: "+
-			  e->GetParString(0));
-    DStringGDL* p0S = static_cast<DStringGDL*>
-      (p0->Convert2(GDL_STRING,BaseGDL::COPY));
-    
-    DLong mode = 0;
-    if( nParam == 2)
-      {
-	BaseGDL* p1 = e->GetPar( 1);
-	if( p1 == NULL)
-	  e->Throw(
-			      "Variable is undefined: "+e->GetParString(1));
-	if( !p1->Scalar())
-	  e->Throw(
-			      "Expression must be a "
-			      "scalar in this context: "+
-			      e->GetParString(1));
-	DLongGDL* p1L = static_cast<DLongGDL*>
-	  (p1->Convert2(GDL_LONG,BaseGDL::COPY));
-
-	mode = (*p1L)[ 0];
-
-	GDLDelete(p1L);
-
-	if( mode < 0 || mode > 2)
-	  {
-	    ostringstream os;
-	    p1->ToStream( os);
-	    e->Throw(
-				"Value of <"+ p1->TypeStr() +
-				"  ("+os.str()+
-				")> is out of allowed range.");
-	  }
-      }
-    
-    SizeT nEl = p0S->N_Elements();
-
-    if( mode == 2) // both
-   {
-TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
-{
-#pragma omp for
-      for( int i=0; i<nEl; ++i)
-	{
-	  unsigned long first= (*p0S)[ i].find_first_not_of(" \t");
-	  if( first == (*p0S)[ i].npos)
-	    {
-	      (*p0S)[ i] = "";
-	    }
-	  else
-	    {
-	      unsigned long last = (*p0S)[ i].find_last_not_of(" \t");
-	      (*p0S)[ i] = (*p0S)[ i].substr(first,last-first+1);
-	    }
-	}
-}
-  }
-  else if( mode == 1) // leading
-     {
-TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
-{
-#pragma omp for
-	for( int i=0; i<nEl; ++i)
-	{
-	  unsigned long first= (*p0S)[ i].find_first_not_of(" \t");
-	  if( first == (*p0S)[ i].npos)
-	    {
-	      (*p0S)[ i] = "";
-	    }
-	  else
-	    {
-	      (*p0S)[ i] = (*p0S)[ i].substr(first);
-	    }
-	}
-}
-    }
-    else // trailing
-      {
-TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
-{
-#pragma omp for
-	for( int i=0; i<nEl; ++i)
-	{
-	  unsigned long last = (*p0S)[ i].find_last_not_of(" \t");
-	  if( last == (*p0S)[ i].npos)
-	    {
-	      (*p0S)[ i] = "";
-	    }
-	  else
-	    {
-	      (*p0S)[ i] = (*p0S)[ i].substr(0,last+1);
-	    }
-	}
-}
-      }
-    return p0S;
-  }
-
-  BaseGDL* strcompress( EnvT* e)
-  {
-    e->NParam( 1);
-
-    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
-
-    bool removeAll =  e->KeywordSet(0);
-
-    DStringGDL* res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
-
-    SizeT nEl = p0S->N_Elements();
-TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
-{
-#pragma omp for
-    for( int i=0; i<nEl; ++i)
-      {
-	(*res)[ i] = StrCompress((*p0S)[ i], removeAll);
-      }
-}
-    return res;
-  }
-
-  BaseGDL* strpos( EnvT* e)
-  {
-    SizeT nParam = e->NParam( 2);//, "STRPOS");
-
-    bool reverseOffset =  e->KeywordSet(0); // REVERSE_OFFSET
-    bool reverseSearch =  e->KeywordSet(1); // REVERSE_SEARCH
-
-    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
-
-    DString searchString;
-    //     e->AssureScalarPar<DStringGDL>( 1, searchString);
-    DStringGDL* sStr = e->GetParAs<DStringGDL>( 1);
-    if( !sStr->Scalar( searchString))
-      e->Throw( "Search string must be a scalar or one element array: "+
-		e->GetParString( 1));
-
-    unsigned long pos = string::npos;
-    if( nParam > 2)
-{
-    BaseGDL* p2 = e->GetParDefined(2);
-//     if( p2 != NULL) //e->AssureLongScalarPar( 2,posDLong);
-//       {
-	const SizeT pIx = 2;
-	BaseGDL* p = e->GetParDefined( pIx);
-	DLongGDL* lp = static_cast<DLongGDL*>(p->Convert2( GDL_LONG, BaseGDL::COPY));
-	auto_ptr<DLongGDL> guard_lp( lp);
-	DLong scalar;
-	if( !lp->Scalar( scalar))
-	  throw GDLException("Parameter must be a scalar in this context: "+
-			     e->GetParString(pIx));
-	pos = scalar;
-      }
-
-    DLongGDL* res = new DLongGDL( p0S->Dim(), BaseGDL::NOZERO);
-
-    SizeT nSrcStr = p0S->N_Elements();
-TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if ((nSrcStr*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nSrcStr*10)))
-{
-#pragma omp for
-    for( long i=0; i<nSrcStr; ++i)
-      {
-	(*res)[ i] = StrPos((*p0S)[ i], searchString, pos, 
-			    reverseOffset, reverseSearch);
-      }
-}    
-    return res;
-  }
-
-  BaseGDL* strmid( EnvT* e)
-  {
-    e->NParam( 2);//, "STRMID");
-
-    bool reverse =  e->KeywordSet(0);
-
-    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
-    DLongGDL*   p1L = e->GetParAs<DLongGDL>( 1);
-
-    BaseGDL*  p2  = e->GetPar( 2);
-    DLongGDL* p2L = NULL;
-    if( p2 != NULL) p2L = e->GetParAs<DLongGDL>( 2);
-
-    DLong scVal1;
-    bool sc1 = p1L->Scalar( scVal1);
-
-    DLong scVal2 = numeric_limits<DLong>::max();
-    bool sc2 = true;
-    if( p2L != NULL) 
-      {
-	DLong scalar;
-	sc2 = p2L->Scalar( scalar);
-	scVal2 = scalar;
-      }
-
-    DLong stride;
-    if( !sc1 && !sc2)
-      {
-	stride = p1L->Dim( 0);
-	if( stride != p2L->Dim( 0))
-	  e->Throw(
-			      "Starting offset and length arguments "
-			      "have incompatible first dimension.");	  
-      }
-    else
-      {
-	// at least one scalar, p2L possibly NULL
-	if( p2L == NULL)
-	  stride = p1L->Dim( 0);
-	else
-	  stride = max( p1L->Dim( 0), p2L->Dim( 0));
-	
-	stride = (stride > 0)? stride : 1;
-      }
-
-    dimension resDim( p0S->Dim());
-    if( stride > 1)
-      resDim >> stride;
-
-    DStringGDL* res = new DStringGDL( resDim, BaseGDL::NOZERO);
-
-    SizeT nEl1 = p1L->N_Elements();
-    SizeT nEl2 = (sc2)? 1 : p2L->N_Elements();
-
-    SizeT nSrcStr = p0S->N_Elements();
-TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if ((nSrcStr*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nSrcStr*10))) default( shared)
-{
-#pragma omp for
-    for( long i=0; i<nSrcStr; ++i)
-      {
-		for( long ii=0; ii<stride; ++ii)
-		{
-			SizeT destIx = i * stride + ii;
-			DLong actFirst = (sc1)? scVal1 : (*p1L)[ destIx % nEl1];
-			DLong actLen   = (sc2)? scVal2 : (*p2L)[ destIx % nEl2];
-			if( actLen <= 0)
-				(*res)[ destIx] = "";//StrMid((*p0S)[ i], actFirst, actLen, reverse);
-			else	
-				(*res)[ destIx] = StrMid((*p0S)[ i], actFirst, actLen, reverse);
-		}
-      }
-}    
-    return res;
-  }
-
-  BaseGDL* strlowcase( BaseGDL* p0, bool isReference)//( EnvT* e)
-  {
-    assert( p0 != NULL);
-    assert( p0->N_Elements() > 0);
-
-//     e->NParam( 1);//, "STRLOWCASE");
-
-//     DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
-    DStringGDL* p0S;
-    DStringGDL* res;
-// 	auto_ptr<DStringGDL> guard;
-
-	if( p0->Type() == GDL_STRING)
-	{
-		p0S = static_cast<DStringGDL*>( p0);
-		if( !isReference)
-			res = p0S;
-		else
-			res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
-	}
-	else
-	{
-		p0S = static_cast<DStringGDL*>( p0->Convert2( GDL_STRING, BaseGDL::COPY));
-		res = p0S;
-// 	    guard.reset( p0S);
-	}
-
-//     DStringGDL* res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
-    
-    SizeT nEl = p0S->N_Elements();
-
-	if( res == p0S)
-	{
-TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
-{
-#pragma omp for
-    for( int i=0; i<nEl; ++i)
-      {
-		StrLowCaseInplace((*p0S)[ i]);
-      }
-}
-	}
-	else
-	{
-TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
-{
-#pragma omp for
-    for( int i=0; i<nEl; ++i)
-      {
-		(*res)[ i] = StrLowCase((*p0S)[ i]);
-      }
-}
-	}
-    return res;
-  }
-
-  BaseGDL* strupcase( BaseGDL* p0, bool isReference)//( EnvT* e)
-  {
-    assert( p0 != NULL);
-    assert( p0->N_Elements() > 0);
-
-//     e->NParam( 1);//, "STRLOWCASE");
-
-//     DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
-    DStringGDL* p0S;
-    DStringGDL* res;
-// 	auto_ptr<DStringGDL> guard;
-
-	if( p0->Type() == GDL_STRING)
-	{
-		p0S = static_cast<DStringGDL*>( p0);
-		if( !isReference)
-			res = p0S;
-		else
-			res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
-	}
-	else
-	{
-		p0S = static_cast<DStringGDL*>( p0->Convert2( GDL_STRING, BaseGDL::COPY));
-		res = p0S;
-// 	    guard.reset( p0S);
-	}
-
-//     DStringGDL* res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
-
-    SizeT nEl = p0S->N_Elements();
-
-	if( res == p0S)
-	{
-TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
-{
-#pragma omp for
-    for( int i=0; i<nEl; ++i)
-      {
-		StrUpCaseInplace((*p0S)[ i]);
-      }
-}
-	}
-	else
-	{
-TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
-{
-#pragma omp for
-    for( int i=0; i<nEl; ++i)
-      {
-		(*res)[ i] = StrUpCase((*p0S)[ i]);
-      }
-}
-	}
-    return res;
-  }
-
-  BaseGDL* strlen( BaseGDL* p0, bool isReference)//( EnvT* e)
-  {
-    assert( p0 != NULL);
-    assert( p0->N_Elements() > 0);
-
-//     e->NParam( 1);//, "STRLEN");
-
-    DStringGDL* p0S;
-	auto_ptr<DStringGDL> guard;
-	
-	if( p0->Type() == GDL_STRING)
-		p0S = static_cast<DStringGDL*>( p0);
-	else
-	{
-		p0S = static_cast<DStringGDL*>( p0->Convert2( GDL_STRING, BaseGDL::COPY));
-	    guard.reset( p0S);
-	}
-
-    DLongGDL* res = new DLongGDL( p0S->Dim(), BaseGDL::NOZERO);
-
-    SizeT nEl = p0S->N_Elements();
-// #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
-// #pragma omp for
-    for( SizeT i=0; i<nEl; ++i)
-      {
-		(*res)[ i] = (*p0S)[ i].length();
-      }
-}
-    return res;
-  }
-
-  BaseGDL* strjoin( EnvT* e)
-  {
-    SizeT nParam = e->NParam( 1);
-
-    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
-    SizeT nEl = p0S->N_Elements();
-
-    DString delim = "";
-    if( nParam > 1)
-      e->AssureStringScalarPar( 1, delim);
-    
-    bool single = e->KeywordSet( 0); // SINGLE
-
-    if( single)
-      {
-	DStringGDL* res = new DStringGDL( (*p0S)[0]);
-	DString&    scl = (*res)[0];
-
-	for( SizeT i=1; i<nEl; ++i)
-	  scl += delim + (*p0S)[i];
-
-	return res;
-      }
-
-    dimension resDim( p0S->Dim());
-    resDim.Purge();
-    
-    SizeT stride = resDim.Stride( 1);
-
-    resDim.Remove( 0);
-
-    DStringGDL* res = new DStringGDL( resDim, BaseGDL::NOZERO);
-    for( SizeT src=0, dst=0; src<nEl; ++dst)
-      {
-	(*res)[ dst] = (*p0S)[ src++];
-	for(SizeT l=1; l<stride; ++l)
-	  (*res)[ dst] += delim + (*p0S)[ src++];
-      }
-    
-    return res;
-  }
-
-  BaseGDL* where( EnvT* e)
-  {
-    SizeT nParam = e->NParam( 1);//, "WHERE");
-
-    BaseGDL* p0 = e->GetParDefined( 0);//, "WHERE");
-
-    SizeT nEl = p0->N_Elements();
-
-    SizeT count;
-    
-    static int nullIx = e->KeywordIx("NULL");
-    bool nullKW = e->KeywordSet(nullIx);
-
-    DLong* ixList = p0->Where( e->KeywordPresent( 0), count);
-    ArrayGuard<DLong> guard( ixList);
-    SizeT nCount = nEl - count;
-
-    if( e->KeywordPresent( 0)) // COMPLEMENT
-      {
-	if( nCount == 0)
-	  {
-	    if( nullKW)
-	      e->SetKW( 0, NullGDL::GetSingleInstance());
-	    else
-	      e->SetKW( 0, new DLongGDL( -1));
-	  }
-	else
-	  {
-	    DLongGDL* cIxList = new DLongGDL( dimension( &nCount, 1), 
-					      BaseGDL::NOZERO);
-	    
-	    SizeT cIx = nEl - 1;
-// #pragma omp parallel if (nCount >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCount))
-{
-// #pragma omp for
-	    for( SizeT i=0; i<nCount; ++i)
-	      (*cIxList)[ i] = ixList[ cIx - i];
-// 	      (*cIxList)[ i] = ixList[ --cIx];
-}
-	    e->SetKW( 0, cIxList);
-	  }
-      }
-
-    if( e->KeywordPresent( 1)) // NCOMPLEMENT
-      {
-	e->SetKW( 1, new DLongGDL( nCount));
-      }
-
-    if( nParam == 2)
-      {
-	e->SetPar( 1, new DLongGDL( count));
-      }
-
-    if( count == 0) 
-    {
-      if( nullKW)
-	return NullGDL::GetSingleInstance();
-      return new DLongGDL( -1);
-    }
-    
-    return new DLongGDL( ixList, count);
-
-    //     DLongGDL* res = new DLongGDL( dimension( &count, 1), 
-    // 				  BaseGDL::NOZERO);
-    //     for( SizeT i=0; i<count; ++i)
-    //       (*res)[ i] = ixList[ i];
-
-    //     return res;
-  }
-
-  BaseGDL* n_params( EnvT* e) 
-  {
-    EnvUDT* caller = static_cast<EnvUDT*>(e->Caller());
-    if( caller == NULL) return new DLongGDL( 0);
-    DLong nP = caller->NParam();
-    if( caller->IsObject()) 
-      return new DLongGDL( nP-1); // "self" is not counted
-    return new DLongGDL( nP);
-  }
-
-  BaseGDL* keyword_set( EnvT* e)
-  {
-    e->NParam( 1);//, "KEYWORD_SET");
-
-    BaseGDL* p0 = e->GetPar( 0);
-    if( p0 == NULL) return new DIntGDL( 0);
-    if( !p0->Scalar()) return new DIntGDL( 1);
-    if( p0->Type() == GDL_STRUCT) return new DIntGDL( 1);
-    if( p0->LogTrue()) return new DIntGDL( 1);
-    return new DIntGDL( 0);
-  }
-
-  // passing 2nd argument by value is slightly better for float and double, 
-  // but incur some overhead for the complex class.
-  template<class T> inline void AddOmitNaN(T& dest, T value)
-{
- if (isfinite(value)) 
-{
-// #pragma omp atomic
-	dest += value; 
-}
-}
-  template<class T> inline void AddOmitNaNCpx(T& dest, T value)
-  {
-// #pragma omp atomic
-    dest += T(isfinite(value.real())? value.real() : 0,
-	      isfinite(value.imag())? value.imag() : 0);
-  }
-  template<> inline void AddOmitNaN(DComplex& dest, DComplex value)
-  { AddOmitNaNCpx<DComplex>(dest, value); }
-  template<> inline void AddOmitNaN(DComplexDbl& dest, DComplexDbl value)
-  { AddOmitNaNCpx<DComplexDbl>(dest, value); }
-
-  template<class T> inline void NaN2Zero(T& value)
-  { if (!isfinite(value)) value = 0; }
-  template<class T> inline void NaN2ZeroCpx(T& value)
-  {
-    value = T(isfinite(value.real())? value.real() : 0, 
-              isfinite(value.imag())? value.imag() : 0);
-  }
-  template<> inline void NaN2Zero(DComplex& value)
-  { NaN2ZeroCpx< DComplex>(value); }
-  template<> inline void NaN2Zero(DComplexDbl& value)
-  { NaN2ZeroCpx< DComplexDbl>(value); }
-
-  // total over all elements
-  template<class T>
-  BaseGDL* total_template( T* src, bool omitNaN)
-  {
-    if (!omitNaN) return new T(src->Sum());
-    typename T::Ty sum = 0;
-    SizeT nEl = src->N_Elements();
-TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared(sum)
-{
-#pragma omp for
-    for ( int i=0; i<nEl; ++i)
-      {
-	AddOmitNaN(sum, (*src)[ i]);
-      }
-}
-    return new T(sum);
-  }
-  
-  // cumulative over all dims
-  template<typename T>
-  BaseGDL* total_cu_template( T* res, bool omitNaN)
-  {
-    SizeT nEl = res->N_Elements();
-    if (omitNaN)
-      {
-// #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-{
-// #pragma omp for
-        for( SizeT i=0; i<nEl; ++i)
-          NaN2Zero((*res)[i]);
-}
-      }
-    for( SizeT i=1,ii=0; i<nEl; ++i,++ii)
-      (*res)[i] += (*res)[ii];
-    return res;
-  }
-
-  // total over one dim
-  template< typename T>
-  BaseGDL* total_over_dim_template( T* src, 
-				    const dimension& srcDim,
-				    SizeT sumDimIx,
-                                    bool omitNaN)
-  {
-    SizeT nEl = src->N_Elements();
-    
-    // get dest dim and number of summations
-    dimension destDim = srcDim;
-    SizeT nSum = destDim.Remove( sumDimIx);
-
-    T* res = new T( destDim); // zero fields
-
-    // sumStride is also the number of linear src indexing
-    SizeT sumStride = srcDim.Stride( sumDimIx); 
-    SizeT outerStride = srcDim.Stride( sumDimIx + 1);
-    SizeT sumLimit = nSum * sumStride;
-    SizeT rIx=0;
-    for( SizeT o=0; o < nEl; o += outerStride)
-      for( SizeT i=0; i < sumStride; ++i)
-	{
-	  SizeT oi = o+i;
-	  SizeT oiLimit = sumLimit + oi;
-          if( omitNaN)
-            {
-              for( SizeT s=oi; s<oiLimit; s += sumStride)
-                AddOmitNaN((*res)[ rIx], (*src)[ s]);
-	    }
-          else
-            {
-  	      for( SizeT s=oi; s<oiLimit; s += sumStride)
-	        (*res)[ rIx] += (*src)[ s];
-            }
-	  ++rIx;
-	}
-    return res;
-  }
-
-  // cumulative over one dim
-  template< typename T>
-  BaseGDL* total_over_dim_cu_template( T* res, 
-				       SizeT sumDimIx,
-                                       bool omitNaN)
-  {
-    SizeT nEl = res->N_Elements();
-    const dimension& resDim = res->Dim();
-    if (omitNaN)
-      {
-        for( SizeT i=0; i<nEl; ++i)
-          NaN2Zero((*res)[i]);
-      }
-    SizeT cumStride = resDim.Stride( sumDimIx); 
-    SizeT outerStride = resDim.Stride( sumDimIx + 1);
-    for( SizeT o=0; o < nEl; o += outerStride)
-      {
-	SizeT cumLimit = o+outerStride;
-	for( SizeT i=o+cumStride, ii=o; i<cumLimit; ++i, ++ii)
-	  (*res)[ i] += (*res)[ ii];
-      }
-    return res;
-  }
-
-
-  BaseGDL* total( EnvT* e)
-  {
-    SizeT nParam = e->NParam( 1);//, "TOTAL");
-
-    BaseGDL* p0 = e->GetParDefined( 0);//, "TOTAL");
-
-    SizeT nEl = p0->N_Elements();
-    if( nEl == 0)
-      e->Throw( "Variable is undefined: "+e->GetParString(0));
-
-    if( p0->Type() == GDL_STRING)
-      e->Throw( "String expression not allowed "
-		"in this context: "+e->GetParString(0));
-    
-    static int cumIx = e->KeywordIx( "CUMULATIVE");
-    static int intIx = e->KeywordIx("INTEGER");
-    static int doubleIx = e->KeywordIx( "DOUBLE");
-    static int nanIx = e->KeywordIx( "NAN");
-    static int preserveIx = e->KeywordIx( "PRESERVE_TYPE");
-
-    bool cumulative = e->KeywordSet( cumIx);
-    bool intRes  = e->KeywordSet( intIx);
-    bool doubleRes  = e->KeywordSet( doubleIx);
-    bool nan        = e->KeywordSet( nanIx);
-    bool preserve   = e->KeywordSet( preserveIx);
-
-    DLong sumDim = 0;
-    if( nParam == 2)
-      e->AssureLongScalarPar( 1, sumDim);
-
-    if( sumDim == 0)
-      {
-	if( !cumulative)
-	  {
-            if (preserve) 
-            {
-              switch (p0->Type())
-              {
-                case GDL_BYTE: return total_template<DByteGDL>(static_cast<DByteGDL*>(p0), false);
-                case GDL_INT: return total_template<DIntGDL>(static_cast<DIntGDL*>(p0), false);
-                case GDL_UINT: return total_template<DUIntGDL>(static_cast<DUIntGDL*>(p0), false);
-                case GDL_LONG: return total_template<DLongGDL>(static_cast<DLongGDL*>(p0), false);
-                case GDL_ULONG: return total_template<DULongGDL>(static_cast<DULongGDL*>(p0), false);
-                case GDL_LONG64: return total_template<DLong64GDL>(static_cast<DLong64GDL*>(p0), false);
-                case GDL_ULONG64: return total_template<DULong64GDL>(static_cast<DULong64GDL*>(p0), false);
-                case GDL_FLOAT: return total_template<DFloatGDL>(static_cast<DFloatGDL*>(p0), nan);
-                case GDL_DOUBLE: return total_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0), nan);
-                case GDL_COMPLEX: return total_template<DComplexGDL>(static_cast<DComplexGDL*>(p0), nan);
-                case GDL_COMPLEXDBL: return total_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0), nan);
-                default: assert(false);
-              }
-            }
-
-	    // Integer parts by Erin Sheldon
-	    // In IDL total(), the INTEGER keyword takes precedence 
-	    if( intRes )
-	      {
-		// We use GDL_LONG64 unless the input is GDL_ULONG64
-		if ( p0->Type() == GDL_LONG64 )
-		  {
-		    return total_template<DLong64GDL>
-		      ( static_cast<DLong64GDL*>(p0), nan );
-		  }
-		if ( p0->Type() == GDL_ULONG64 )
-		  {
-		    return total_template<DULong64GDL>
-		      ( static_cast<DULong64GDL*>(p0), nan );
-		  }
-
-		// Conver to Long64
-		DLong64GDL* p0L64 = static_cast<DLong64GDL*>
-		  (p0->Convert2( GDL_LONG64, BaseGDL::COPY));
-		auto_ptr<DLong64GDL> guard( p0L64);
-		return total_template<DLong64GDL>( p0L64, nan);
-
-	      } // integer results
-
-
-	    if( p0->Type() == GDL_DOUBLE)
-	      {
-		return total_template<DDoubleGDL>
-                  ( static_cast<DDoubleGDL*>(p0), nan); 
-	      }
-	    if( p0->Type() == GDL_COMPLEXDBL)
-	      {
-		return total_template<DComplexDblGDL>
-                  ( static_cast<DComplexDblGDL*>(p0), nan); 
-	      }
-
-	    if( !doubleRes)
-	      {
-		if( p0->Type() == GDL_FLOAT)
-		  {
-		    return total_template<DFloatGDL>
-		      ( static_cast<DFloatGDL*>(p0), nan); 
-		  }
-		if( p0->Type() == GDL_COMPLEX)
-		  {
-		    return total_template<DComplexGDL>
-		      ( static_cast<DComplexGDL*>(p0), nan); 
-		  }
- 		DFloatGDL* p0F = static_cast<DFloatGDL*>
- 		  (p0->Convert2( GDL_FLOAT,BaseGDL::COPY));
- 		auto_ptr<DFloatGDL> guard( p0F);
-		return total_template<DFloatGDL>( p0F, false);
-	      }
-	    if( p0->Type() == GDL_COMPLEX)
-	      {
-		DComplexDblGDL* p0D = static_cast<DComplexDblGDL*>
-		  (p0->Convert2( GDL_COMPLEXDBL,BaseGDL::COPY));
-		auto_ptr<DComplexDblGDL> p0D_guard( p0D);
-		return total_template<DComplexDblGDL>( p0D, nan); 
-	      }
-	    
-	    DDoubleGDL* p0D = static_cast<DDoubleGDL*>
-	      (p0->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-	    auto_ptr<DDoubleGDL> p0D_guard( p0D);
-	    return total_template<DDoubleGDL>( p0D, nan);
-	  }
-	else // cumulative
-	  {
-            if (preserve) 
-            {
-              switch (p0->Type())
-              {
-                case GDL_BYTE: return total_cu_template<DByteGDL>(static_cast<DByteGDL*>(p0)->Dup(), false);
-                case GDL_INT: return total_cu_template<DIntGDL>(static_cast<DIntGDL*>(p0)->Dup(), false);
-                case GDL_UINT: return total_cu_template<DUIntGDL>(static_cast<DUIntGDL*>(p0)->Dup(), false);
-                case GDL_LONG: return total_cu_template<DLongGDL>(static_cast<DLongGDL*>(p0)->Dup(), false);
-                case GDL_ULONG: return total_cu_template<DULongGDL>(static_cast<DULongGDL*>(p0)->Dup(), false);
-                case GDL_LONG64: return total_cu_template<DLong64GDL>(static_cast<DLong64GDL*>(p0)->Dup(), false);
-                case GDL_ULONG64: return total_cu_template<DULong64GDL>(static_cast<DULong64GDL*>(p0)->Dup(), false);
-                case GDL_FLOAT: return total_cu_template<DFloatGDL>(static_cast<DFloatGDL*>(p0)->Dup(), nan);
-                case GDL_DOUBLE: return total_cu_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0)->Dup(), nan);
-                case GDL_COMPLEX: return total_cu_template<DComplexGDL>(static_cast<DComplexGDL*>(p0)->Dup(), nan);
-                case GDL_COMPLEXDBL: return total_cu_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0)->Dup(), nan);
-                default: assert(false);
-              }
-            }
-
-	    // INTEGER keyword takes precedence
-	    if( intRes )
-	      {
-		// We use GDL_LONG64 unless the input is GDL_ULONG64
-		if ( p0->Type() == GDL_LONG64 )
-		  {
-		    return total_cu_template<DLong64GDL>
-		      ( static_cast<DLong64GDL*>(p0)->Dup(), nan );
-		  }
-		if ( p0->Type() == GDL_ULONG64 )
-		  {
-		    return total_cu_template<DULong64GDL>
-		      ( static_cast<DULong64GDL*>(p0)->Dup(), nan );
-		  }
-
-		// Convert to Long64
-		return total_cu_template<DLong64GDL>
-		  ( static_cast<DLong64GDL*>
-		    (p0->Convert2( GDL_LONG64, BaseGDL::COPY)), nan);
-						     
-	      } // integer results
-
-
-	    // special case as GDL_DOUBLE type overrides /GDL_DOUBLE
-	    if( p0->Type() == GDL_DOUBLE)
-	      {
-  	        return total_cu_template< DDoubleGDL>
-		  ( static_cast<DDoubleGDL*>(p0)->Dup(), nan);
-	      }
-	    if( p0->Type() == GDL_COMPLEXDBL)
-	      {
-  	        return total_cu_template< DComplexDblGDL>
-		  ( static_cast<DComplexDblGDL*>(p0)->Dup(), nan);
-	      }
-
-
-
-	    if( !doubleRes)
-	      {
-		// special case for GDL_FLOAT has no advantage here
-		if( p0->Type() == GDL_COMPLEX)
-		  {
-		    return total_cu_template< DComplexGDL>
-                      ( static_cast<DComplexGDL*>(p0)->Dup(), nan);
-		  }
-    	        return total_cu_template< DFloatGDL>
-		  ( static_cast<DFloatGDL*>( p0->Convert2(GDL_FLOAT, 
-							  BaseGDL::COPY)), nan);
-	      }
-	    if( p0->Type() == GDL_COMPLEX)
-	      {
-		return total_cu_template< DComplexDblGDL>
-		  ( static_cast<DComplexDblGDL*>(p0->Convert2( GDL_COMPLEXDBL, 
-							       BaseGDL::COPY)), nan);
-	      }
-    	    return total_cu_template< DDoubleGDL>
-	      ( static_cast<DDoubleGDL*>(p0->Convert2( GDL_DOUBLE, 
-						       BaseGDL::COPY)), nan);
-	  }
-      }
-
-    // total over sumDim
-    dimension srcDim = p0->Dim();
-    SizeT srcRank = srcDim.Rank();
-
-    if( sumDim < 1 || sumDim > srcRank)
-      e->Throw( 
-			  "Array must have "+i2s(sumDim)+
-			  " dimensions: "+e->GetParString(0));
-
-    if( !cumulative)
-      {
-        if (preserve) 
-        {
-          switch (p0->Type())
-          {
-            case GDL_BYTE: return total_over_dim_template<DByteGDL>(static_cast<DByteGDL*>(p0), srcDim, sumDim-1, false);
-            case GDL_INT: return total_over_dim_template<DIntGDL>(static_cast<DIntGDL*>(p0), srcDim, sumDim-1, false);
-            case GDL_UINT: return total_over_dim_template<DUIntGDL>(static_cast<DUIntGDL*>(p0), srcDim, sumDim-1, false);
-            case GDL_LONG: return total_over_dim_template<DLongGDL>(static_cast<DLongGDL*>(p0), srcDim, sumDim-1, false);
-            case GDL_ULONG: return total_over_dim_template<DULongGDL>(static_cast<DULongGDL*>(p0), srcDim, sumDim-1, false);
-            case GDL_LONG64: return total_over_dim_template<DLong64GDL>(static_cast<DLong64GDL*>(p0), srcDim, sumDim-1, false);
-            case GDL_ULONG64: return total_over_dim_template<DULong64GDL>(static_cast<DULong64GDL*>(p0), srcDim, sumDim-1, false);
-            case GDL_FLOAT: return total_over_dim_template<DFloatGDL>(static_cast<DFloatGDL*>(p0), srcDim, sumDim-1, nan);
-            case GDL_DOUBLE: return total_over_dim_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0), srcDim, sumDim-1, nan);
-            case GDL_COMPLEX: return total_over_dim_template<DComplexGDL>(static_cast<DComplexGDL*>(p0), srcDim, sumDim-1, nan);
-            case GDL_COMPLEXDBL: return total_over_dim_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0), srcDim, sumDim-1, nan);
-            default: assert(false);
-          }
-        }
-
-	// INTEGER keyword takes precedence 
-	if( intRes )
-	  {
-	    // We use GDL_LONG64 unless the input is GDL_ULONG64
-	    if ( p0->Type() == GDL_LONG64 )
-	      {
-		return total_over_dim_template<DLong64GDL>
-		  ( static_cast<DLong64GDL*>(p0), srcDim, sumDim-1, nan );
-	      }
-	    if ( p0->Type() == GDL_ULONG64 )
-	      {
-		return total_over_dim_template<DULong64GDL>
-		  ( static_cast<DULong64GDL*>(p0), srcDim, sumDim-1, nan );
-	      }
-	    
-	    // Conver to Long64
-	    DLong64GDL* p0L64 = static_cast<DLong64GDL*>
-	      (p0->Convert2( GDL_LONG64, BaseGDL::COPY));
-
-	    auto_ptr<DLong64GDL> p0L64_guard( p0L64);
-	    return total_over_dim_template<DLong64GDL>
-	      ( p0L64, srcDim, sumDim-1, nan);
-	    
-	  } // integer results
-
-
-	if( p0->Type() == GDL_DOUBLE)
-	  {
-	    return total_over_dim_template< DDoubleGDL>
-	      ( static_cast<DDoubleGDL*>(p0), srcDim, sumDim-1, nan);
-	  }
-	if( p0->Type() == GDL_COMPLEXDBL)
-	  {
-	    return total_over_dim_template< DComplexDblGDL>
-	      ( static_cast<DComplexDblGDL*>(p0), srcDim, sumDim-1, nan);
-	  }
-	if( !doubleRes)
-	  {
-	    if( p0->Type() == GDL_FLOAT)
-	      {
-		return total_over_dim_template< DFloatGDL>
-		  ( static_cast<DFloatGDL*>(p0), srcDim, sumDim-1, nan);
-	      }
-	    if( p0->Type() == GDL_COMPLEX)
-	      {
-		return total_over_dim_template< DComplexGDL>
-		  ( static_cast<DComplexGDL*>(p0), srcDim, sumDim-1, nan);
-	      }
-	    // default for NOT /GDL_DOUBLE
-	    DFloatGDL* p0F = static_cast<DFloatGDL*>
-	      (p0->Convert2( GDL_FLOAT,BaseGDL::COPY));
-	    auto_ptr<DFloatGDL> p0F_guard( p0F);
-	    //	    p0F_guard.reset( p0F);
-	    return total_over_dim_template< DFloatGDL>
-	      ( p0F, srcDim, sumDim-1, false);
-	  }
-	if( p0->Type() == GDL_COMPLEX)
-	  {
-	    DComplexDblGDL* p0D = static_cast<DComplexDblGDL*>
-	      (p0->Convert2( GDL_COMPLEXDBL,BaseGDL::COPY));
-	    auto_ptr<DComplexDblGDL> p0D_guard( p0D);
-	    // 	    p0D_guard.reset( p0D);
-	    return total_over_dim_template< DComplexDblGDL>
-	      ( p0D, srcDim, sumDim-1, nan);
-	  }
-	// default for /GDL_DOUBLE
-	DDoubleGDL* p0D = static_cast<DDoubleGDL*>
-	  (p0->Convert2( GDL_DOUBLE,BaseGDL::COPY));
-	auto_ptr<DDoubleGDL> p0D_guard( p0D);
-	//p0D_guard.reset( p0D);
-	return total_over_dim_template< DDoubleGDL>( p0D, srcDim, sumDim-1,nan);
-      }
-    else // cumulative
-      {
-        if (preserve) 
-        {
-          switch (p0->Type())
-          {
-            case GDL_BYTE: return total_over_dim_cu_template<DByteGDL>(static_cast<DByteGDL*>(p0)->Dup(), sumDim-1, false);
-            case GDL_INT: return total_over_dim_cu_template<DIntGDL>(static_cast<DIntGDL*>(p0)->Dup(), sumDim-1, false);
-            case GDL_UINT: return total_over_dim_cu_template<DUIntGDL>(static_cast<DUIntGDL*>(p0)->Dup(), sumDim-1, false);
-            case GDL_LONG: return total_over_dim_cu_template<DLongGDL>(static_cast<DLongGDL*>(p0)->Dup(), sumDim-1, false);
-            case GDL_ULONG: return total_over_dim_cu_template<DULongGDL>(static_cast<DULongGDL*>(p0)->Dup(), sumDim-1, false);
-            case GDL_LONG64: return total_over_dim_cu_template<DLong64GDL>(static_cast<DLong64GDL*>(p0)->Dup(), sumDim-1, false);
-            case GDL_ULONG64: return total_over_dim_cu_template<DULong64GDL>(static_cast<DULong64GDL*>(p0)->Dup(), sumDim-1, false);
-            case GDL_FLOAT: return total_over_dim_cu_template<DFloatGDL>(static_cast<DFloatGDL*>(p0)->Dup(), sumDim-1, nan);
-            case GDL_DOUBLE: return total_over_dim_cu_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0)->Dup(), sumDim-1, nan);
-            case GDL_COMPLEX: return total_over_dim_cu_template<DComplexGDL>(static_cast<DComplexGDL*>(p0)->Dup(), sumDim-1, nan);
-            case GDL_COMPLEXDBL: return total_over_dim_cu_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0)->Dup(), sumDim-1, nan);
-            default: assert(false);
-          }
-        }
-
-	// INTEGER keyword takes precedence
-	if( intRes )
-	  {
-	    // We use GDL_LONG64 unless the input is GDL_ULONG64
-	    if ( p0->Type() == GDL_LONG64 )
-	      {
-		return total_over_dim_cu_template<DLong64GDL>
-		  ( static_cast<DLong64GDL*>(p0)->Dup(), sumDim-1, nan );
-	      }
-	    if ( p0->Type() == GDL_ULONG64 )
-	      {
-		return total_over_dim_cu_template<DULong64GDL>
-		  ( static_cast<DULong64GDL*>(p0)->Dup(), sumDim-1, nan );
-	      }
-	    
-	    // Convert to Long64
-	    return total_over_dim_cu_template<DLong64GDL>
-	      ( static_cast<DLong64GDL*>
-		(p0->Convert2( GDL_LONG64, BaseGDL::COPY)), sumDim-1, nan);
-	    
-	  } // integer results
-
-
-	if( p0->Type() == GDL_DOUBLE)
-	  {
-	    return total_over_dim_cu_template< DDoubleGDL>
-	      ( static_cast<DDoubleGDL*>(p0)->Dup(), sumDim-1, nan);
-	  }
-	if( p0->Type() == GDL_COMPLEXDBL)
-	  {
-	    return total_over_dim_cu_template< DComplexDblGDL>
-	      ( static_cast<DComplexDblGDL*>(p0)->Dup(), sumDim-1, nan);
-	  }
-	if( !doubleRes)
-	  {
-	    // special case for GDL_FLOAT has no advantage here
-	    if( p0->Type() == GDL_COMPLEX)
-	      {
-		return total_over_dim_cu_template< DComplexGDL>
-		  ( static_cast<DComplexGDL*>(p0)->Dup(), sumDim-1, nan);
-	      }
-	    // default for NOT /GDL_DOUBLE
-	    return total_over_dim_cu_template< DFloatGDL>
-	      ( static_cast<DFloatGDL*>( p0->Convert2( GDL_FLOAT, 
-						       BaseGDL::COPY)), sumDim-1, nan);
-	  }
-	if( p0->Type() == GDL_COMPLEX)
-	  {
-	    return total_over_dim_cu_template< DComplexDblGDL>
-	      ( static_cast<DComplexDblGDL*>(p0->Convert2( GDL_COMPLEXDBL,
-							   BaseGDL::COPY)), sumDim-1, nan);
-	  }
-	// default for /GDL_DOUBLE
-	return total_over_dim_cu_template< DDoubleGDL>
-	  ( static_cast<DDoubleGDL*>(p0->Convert2( GDL_DOUBLE,
-						   BaseGDL::COPY)), sumDim-1, nan);
-      }
-  }
-
-
-  // passing 2nd argument by value is slightly better for float and double, 
-  // but incur some overhead for the complex class.
-  template<class T> inline void MultOmitNaN(T& dest, T value)
-  { 
-	if (isfinite(value)) 
-	{
-// #pragma omp atomic
-		dest *= value; 
-	}
-  }
-  template<class T> inline void MultOmitNaNCpx(T& dest, T value)
-  {
-    dest *= T(isfinite(value.real())? value.real() : 1,
-	      isfinite(value.imag())? value.imag() : 1);
-  }
-  template<> inline void MultOmitNaN(DComplex& dest, DComplex value)
-  { MultOmitNaNCpx<DComplex>(dest, value); }
-  template<> inline void MultOmitNaN(DComplexDbl& dest, DComplexDbl value)
-  { MultOmitNaNCpx<DComplexDbl>(dest, value); }
-
-  template<class T> inline void Nan2One(T& value)
-  { if (!isfinite(value)) value = 1; }
-  template<class T> inline void Nan2OneCpx(T& value)
-  {
-    value = T(isfinite(value.real())? value.real() : 1, 
-              isfinite(value.imag())? value.imag() : 1);
-  }
-  template<> inline void Nan2One(DComplex& value)
-  { Nan2OneCpx< DComplex>(value); }
-  template<> inline void Nan2One(DComplexDbl& value)
-  { Nan2OneCpx< DComplexDbl>(value); }
-
-  // product over all elements
-  template<class T>
-  BaseGDL* product_template( T* src, bool omitNaN)
-  {
-    typename T::Ty sum = 1;
-    SizeT nEl = src->N_Elements();
-    if( !omitNaN) 
-	{
-TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared(sum)
-{
-#pragma omp for reduction(*:sum)
-	for ( int i=0; i<nEl; ++i)
-		{
-		sum *= (*src)[ i];
-		}
-}
-	}
-    else
-	{
-TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared(sum)
-{
-#pragma omp for reduction(*:sum)
-	for ( int i=0; i<nEl; ++i)
-		{
-		MultOmitNaN( sum, (*src)[ i]);
-		}
-}
-	}
-    return new T( sum);
-  }
-
-  template<>
-  BaseGDL* product_template( DComplexGDL* src, bool omitNaN)
-  {
-    DComplexGDL::Ty sum = 1;
-    SizeT nEl = src->N_Elements();
-    if( !omitNaN) 
-	{
-	for ( SizeT i=0; i<nEl; ++i)
-		{
-		sum *= (*src)[ i];
-		}
-	}
-    else
-	{
-	for ( SizeT i=0; i<nEl; ++i)
-		{
-		MultOmitNaN( sum, (*src)[ i]);
-		}
-	}
-    return new DComplexGDL( sum);
-  }
-  
-  template<>
-  BaseGDL* product_template( DComplexDblGDL* src, bool omitNaN)
-  {
-    DComplexDblGDL::Ty sum = 1;
-    SizeT nEl = src->N_Elements();
-    if( !omitNaN) 
-	{
-	for ( SizeT i=0; i<nEl; ++i)
-		{
-		sum *= (*src)[ i];
-		}
-	}
-    else
-	{
-	for ( SizeT i=0; i<nEl; ++i)
-		{
-		MultOmitNaN( sum, (*src)[ i]);
-		}
-	}
-    return new DComplexDblGDL( sum);
-  }
-  
-  // cumulative over all dims
-  template<typename T>
-  BaseGDL* product_cu_template( T* res, bool omitNaN)
-  {
-    SizeT nEl = res->N_Elements();
-    if( omitNaN)
-      {
-        for( SizeT i=0; i<nEl; ++i)
-          Nan2One( (*res)[i]);
-      }
-    for( SizeT i=1,ii=0; i<nEl; ++i,++ii)
-      (*res)[i] *= (*res)[ii];
-    return res;
-  }
-
-  // product over one dim
-  template< typename T>
-  BaseGDL* product_over_dim_template( T* src, 
-				      const dimension& srcDim, 
-				      SizeT sumDimIx,
-				      bool omitNaN)
-  {
-    SizeT nEl = src->N_Elements();
-    
-    // get dest dim and number of summations
-    dimension destDim = srcDim;
-    SizeT nSum = destDim.Remove( sumDimIx);
-
-    T* res = new T( destDim, BaseGDL::NOZERO);
-
-    // sumStride is also the number of linear src indexing
-    SizeT sumStride = srcDim.Stride( sumDimIx); 
-    SizeT outerStride = srcDim.Stride( sumDimIx + 1);
-    SizeT sumLimit = nSum * sumStride;
-    SizeT rIx=0;
-    for( SizeT o=0; o < nEl; o += outerStride)
-      for( SizeT i=0; i < sumStride; ++i)
-	{
-	  (*res)[ rIx] = 1;
-	  SizeT oi = o+i;
-	  SizeT oiLimit = sumLimit + oi;
-          if( omitNaN)
-            {
-              for( SizeT s=oi; s<oiLimit; s += sumStride)
-                MultOmitNaN((*res)[ rIx], (*src)[ s]);
-	    }
-          else
-            {
-  	      for( SizeT s=oi; s<oiLimit; s += sumStride)
-	        (*res)[ rIx] *= (*src)[ s];
-            }
-	  ++rIx;
-	}
-    return res;
-  }
-
-  // cumulative over one dim
-  template< typename T>
-  BaseGDL* product_over_dim_cu_template( T* res, 
-					 SizeT sumDimIx,
-					 bool omitNaN)
-  {
-    SizeT nEl = res->N_Elements();
-    const dimension& resDim = res->Dim();
-    if (omitNaN)
-      {
-        for( SizeT i=0; i<nEl; ++i)
-          Nan2One((*res)[i]);
-      }
-    SizeT cumStride = resDim.Stride( sumDimIx); 
-    SizeT outerStride = resDim.Stride( sumDimIx + 1);
-    for( SizeT o=0; o < nEl; o += outerStride)
-      {
-	SizeT cumLimit = o+outerStride;
-	for( SizeT i=o+cumStride, ii=o; i<cumLimit; ++i, ++ii)
-	  (*res)[ i] *= (*res)[ ii];
-      }
-    return res;
-  }
-
-  BaseGDL* product( EnvT* e)
-  {
-    SizeT nParam = e->NParam( 1);
-    
-    BaseGDL* p0 = e->GetParDefined( 0);
-    
-    SizeT nEl = p0->N_Elements();
-    if( nEl == 0)
-      e->Throw( "Variable is undefined: "+e->GetParString(0));
-    
-    if( p0->Type() == GDL_STRING)
-      e->Throw( "String expression not allowed "
-		"in this context: "+e->GetParString(0));
-    
-    static int cumIx = e->KeywordIx( "CUMULATIVE");
-    static int nanIx = e->KeywordIx( "NAN");
-    static int intIx = e->KeywordIx("INTEGER");
-    static int preIx = e->KeywordIx("PRESERVE_TYPE");
-    bool KwCumul     = e->KeywordSet( cumIx);
-    bool KwNaN       = e->KeywordSet( nanIx);
-    bool KwInt       = e->KeywordSet( intIx);
-    bool KwPre       = e->KeywordSet( preIx);
-    bool nanInt=false;
-    
-    DLong sumDim = 0;
-    if( nParam == 2)
-      e->AssureLongScalarPar( 1, sumDim);
-    
-    if( sumDim == 0) {
-	if( !KwCumul) {
-          if (KwPre) 
-          {
-            switch (p0->Type())
-            {
-              case GDL_BYTE: return product_template<DByteGDL>(static_cast<DByteGDL*>(p0), nanInt);
-              case GDL_INT: return product_template<DIntGDL>(static_cast<DIntGDL*>(p0), nanInt);
-              case GDL_UINT: return product_template<DUIntGDL>(static_cast<DUIntGDL*>(p0), nanInt);
-              case GDL_LONG: return product_template<DLongGDL>(static_cast<DLongGDL*>(p0), nanInt);
-              case GDL_ULONG: return product_template<DULongGDL>(static_cast<DULongGDL*>(p0), nanInt);
-              case GDL_LONG64: return product_template<DLong64GDL>(static_cast<DLong64GDL*>(p0), nanInt);
-              case GDL_ULONG64: return product_template<DULong64GDL>(static_cast<DULong64GDL*>(p0), nanInt);
-              case GDL_FLOAT: return product_template<DFloatGDL>(static_cast<DFloatGDL*>(p0), KwNaN);
-              case GDL_DOUBLE: return product_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0), KwNaN);
-              case GDL_COMPLEX: return product_template<DComplexGDL>(static_cast<DComplexGDL*>(p0), KwNaN);
-              case GDL_COMPLEXDBL: return product_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0), KwNaN);
-              default: assert(false);
-            }
-          }
-
-	  // Integer parts derivated from Total code by Erin Sheldon
-	  // In IDL PRODUCT(), the INTEGER keyword takes precedence 
-	  if (KwInt) {
-	    // We use GDL_LONG64 unless the input is GDL_ULONG64
-	    if ((p0->Type() == GDL_LONG64) && (!KwNaN)) {
-	      return product_template<DLong64GDL>
-		( static_cast<DLong64GDL*>(p0), nanInt );
-	    }
-	    if ((p0->Type() == GDL_ULONG64) && (!KwNaN)) {
-	      return product_template<DULong64GDL>
-		(static_cast<DULong64GDL*>(p0), nanInt );
-	    }
-	    
-	    // Convert to Long64
-	    DLong64GDL* p0L64 = static_cast<DLong64GDL*>
-	      (p0->Convert2( GDL_LONG64, BaseGDL::COPY));
-	    auto_ptr<DLong64GDL> guard( p0L64);
-	    if (KwNaN) {
-	      DFloatGDL* p0f = static_cast<DFloatGDL*>
-		(p0->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	      auto_ptr<DFloatGDL> guard( p0f);
-	      for( SizeT i=0; i<nEl; ++i) {
-		if (!isfinite((*p0f)[i])) (*p0L64)[i]=1;
-	      }
-	    }
-	    return product_template<DLong64GDL>( p0L64, nanInt);	      
-	  } // integer results
-	  
-	  if( p0->Type() == GDL_DOUBLE) {
-	    return product_template<DDoubleGDL>
-	      ( static_cast<DDoubleGDL*>(p0), KwNaN); 
-	  }
-	  if( p0->Type() == GDL_COMPLEXDBL) {
-	    return product_template<DComplexDblGDL>
-	      ( static_cast<DComplexDblGDL*>(p0), KwNaN); 
-	  }
-	  if( p0->Type() == GDL_COMPLEX) {
-	    DComplexDblGDL* p0D = static_cast<DComplexDblGDL*>
-	      (p0->Convert2( GDL_COMPLEXDBL,BaseGDL::COPY));
-	    auto_ptr<DComplexDblGDL> p0D_guard( p0D);
-	    //p0D_guard.reset( p0D);
-	    return product_template<DComplexDblGDL>( p0D, KwNaN); 
-	  }
-	  
-	  DDoubleGDL* p0D = static_cast<DDoubleGDL*>
-	    (p0->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-	  auto_ptr<DDoubleGDL> p0D_guard( p0D);
-	  //	    p0D_guard.reset( p0D);
-	  return product_template<DDoubleGDL>( p0D, KwNaN);
-	} 
-	else
-	  { // KwCumul
-
-            if (KwPre) 
-            {
-              switch (p0->Type())
-              {
-                case GDL_BYTE: return product_cu_template<DByteGDL>(static_cast<DByteGDL*>(p0)->Dup(), nanInt);
-                case GDL_INT: return product_cu_template<DIntGDL>(static_cast<DIntGDL*>(p0)->Dup(), nanInt);
-                case GDL_UINT: return product_cu_template<DUIntGDL>(static_cast<DUIntGDL*>(p0)->Dup(), nanInt);
-                case GDL_LONG: return product_cu_template<DLongGDL>(static_cast<DLongGDL*>(p0)->Dup(), nanInt);
-                case GDL_ULONG: return product_cu_template<DULongGDL>(static_cast<DULongGDL*>(p0)->Dup(), nanInt);
-                case GDL_LONG64: return product_cu_template<DLong64GDL>(static_cast<DLong64GDL*>(p0)->Dup(), nanInt);
-                case GDL_ULONG64: return product_cu_template<DULong64GDL>(static_cast<DULong64GDL*>(p0)->Dup(), nanInt);
-                case GDL_FLOAT: return product_cu_template<DFloatGDL>(static_cast<DFloatGDL*>(p0)->Dup(), KwNaN);
-                case GDL_DOUBLE: return product_cu_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0)->Dup(), KwNaN);
-                case GDL_COMPLEX: return product_cu_template<DComplexGDL>(static_cast<DComplexGDL*>(p0)->Dup(), KwNaN);
-                case GDL_COMPLEXDBL: return product_cu_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0)->Dup(), KwNaN);
-                default: assert(false);
-              }
-            }
-
-	    // Integer parts derivated from Total code by Erin Sheldon
-	    // In IDL PRODUCT(), the INTEGER keyword takes precedence 
-	    if (KwInt) {
-	      // We use GDL_LONG64 unless the input is GDL_ULONG64
-	      if ((p0->Type() == GDL_LONG64) && (!KwNaN)) {
-		return product_cu_template<DLong64GDL>
-		  ( static_cast<DLong64GDL*>(p0)->Dup(), nanInt);
-	      }
-	      if ((p0->Type() == GDL_ULONG64) && (!KwNaN)) {
-		return product_cu_template<DULong64GDL>
-		  ( static_cast<DULong64GDL*>(p0)->Dup(), nanInt);
-	      }
-	      // Convert to Long64
-	      DLong64GDL* p0L64 = static_cast<DLong64GDL*>
-		(p0->Convert2( GDL_LONG64, BaseGDL::COPY));
-	      auto_ptr<DLong64GDL> guard( p0L64);
-	      if (KwNaN) {
-		DFloatGDL* p0f = static_cast<DFloatGDL*>
-		  (p0->Convert2( GDL_FLOAT, BaseGDL::COPY));
-		auto_ptr<DFloatGDL> guard( p0f);
-		for( SizeT i=0; i<nEl; ++i) {
-		  if (!isfinite((*p0f)[i])) (*p0L64)[i]=1;
-		}
-	      }
-	      return product_cu_template<DLong64GDL>
-		((p0L64)->Dup(), nanInt);	      
-	    } // integer results
-	      
-	      // special case as GDL_DOUBLE type overrides /GDL_DOUBLE
-	    if (p0->Type() == GDL_DOUBLE) {
-	      return product_cu_template< DDoubleGDL>
-		( static_cast<DDoubleGDL*>(p0)->Dup(), KwNaN);
-	    }
-	    if (p0->Type() == GDL_COMPLEXDBL) {
-	      return product_cu_template< DComplexDblGDL>
-		( static_cast<DComplexDblGDL*>(p0)->Dup(), KwNaN);
-	    }
-	    if (p0->Type() == GDL_COMPLEX) {
-	      return product_cu_template< DComplexDblGDL>
-		( static_cast<DComplexDblGDL*>
-		  (p0->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY)), KwNaN);
-	    }
-	    return product_cu_template< DDoubleGDL>
-	      ( static_cast<DDoubleGDL*>
-		(p0->Convert2( GDL_DOUBLE, BaseGDL::COPY)), KwNaN);
-	  }
-    }
-    
-    // product over sumDim
-    dimension srcDim = p0->Dim();
-    SizeT srcRank = srcDim.Rank();
-    
-    if( sumDim < 1 || sumDim > srcRank)
-      e->Throw( "Array must have "+i2s(sumDim)+
-		" dimensions: "+e->GetParString(0));
-    
-    if (!KwCumul) {
-
-      if (KwPre) 
-      {
-        switch (p0->Type())
-        {
-          case GDL_BYTE: return product_over_dim_template<DByteGDL>(static_cast<DByteGDL*>(p0), srcDim, sumDim-1, nanInt);
-          case GDL_INT: return product_over_dim_template<DIntGDL>(static_cast<DIntGDL*>(p0), srcDim, sumDim-1, nanInt);
-          case GDL_UINT: return product_over_dim_template<DUIntGDL>(static_cast<DUIntGDL*>(p0), srcDim, sumDim-1, nanInt);
-          case GDL_LONG: return product_over_dim_template<DLongGDL>(static_cast<DLongGDL*>(p0), srcDim, sumDim-1, nanInt);
-          case GDL_ULONG: return product_over_dim_template<DULongGDL>(static_cast<DULongGDL*>(p0), srcDim, sumDim-1, nanInt);
-          case GDL_LONG64: return product_over_dim_template<DLong64GDL>(static_cast<DLong64GDL*>(p0), srcDim, sumDim-1, nanInt);
-          case GDL_ULONG64: return product_over_dim_template<DULong64GDL>(static_cast<DULong64GDL*>(p0), srcDim, sumDim-1, nanInt);
-          case GDL_FLOAT: return product_over_dim_template<DFloatGDL>(static_cast<DFloatGDL*>(p0), srcDim, sumDim-1, KwNaN);
-          case GDL_DOUBLE: return product_over_dim_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0), srcDim, sumDim-1, KwNaN);
-          case GDL_COMPLEX: return product_over_dim_template<DComplexGDL>(static_cast<DComplexGDL*>(p0), srcDim, sumDim-1, KwNaN);
-          case GDL_COMPLEXDBL: return product_over_dim_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0), srcDim, sumDim-1, KwNaN);
-          default: assert(false);
-        }
-      }
-
-      // Integer parts derivated from Total code by Erin Sheldon
-      // In IDL PRODUCT(), the INTEGER keyword takes precedence 
-      if (KwInt) {	  
-	// We use GDL_LONG64 unless the input is GDL_ULONG64
-	if ((p0->Type() == GDL_LONG64 ) && (!KwNaN)) {
-	  return product_over_dim_template<DLong64GDL>
-	    ( static_cast<DLong64GDL*>(p0), srcDim, sumDim-1, nanInt);
-	}
-	if ((p0->Type() == GDL_ULONG64) && (!KwNaN)) {
-	  return product_over_dim_template<DULong64GDL>
-	    ( static_cast<DULong64GDL*>(p0), srcDim, sumDim-1, nanInt);
-	}
-	
-	// Conver to Long64
-	DLong64GDL* p0L64 = static_cast<DLong64GDL*>
-	  (p0->Convert2( GDL_LONG64, BaseGDL::COPY));
-	auto_ptr<DLong64GDL> guard( p0L64);
-	if (KwNaN) {
-	  DFloatGDL* p0f = static_cast<DFloatGDL*>
-	    (p0->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	  auto_ptr<DFloatGDL> guard( p0f);
-	  for( SizeT i=0; i<nEl; ++i) {
-	    if (!isfinite((*p0f)[i])) (*p0L64)[i]=1;
-	  }
-	}
-	return product_over_dim_template<DLong64GDL>
-	  ( p0L64, srcDim, sumDim-1, nanInt);
-      } // integer results
-      
-      if( p0->Type() == GDL_DOUBLE) {
-	return product_over_dim_template< DDoubleGDL>
-	  ( static_cast<DDoubleGDL*>(p0), srcDim, sumDim-1, KwNaN);
-      }
-      if( p0->Type() == GDL_COMPLEXDBL) {
-	return product_over_dim_template< DComplexDblGDL>
-	  ( static_cast<DComplexDblGDL*>(p0), srcDim, sumDim-1, KwNaN);
-      }
-      if( p0->Type() == GDL_COMPLEX) {
-	DComplexDblGDL* p0D = static_cast<DComplexDblGDL*>
-	  (p0->Convert2( GDL_COMPLEXDBL,BaseGDL::COPY));
-	auto_ptr<DComplexDblGDL> p0D_guard( p0D);
-	//	    p0D_guard.reset( p0D);
-	return product_over_dim_template< DComplexDblGDL>
-	  ( p0D, srcDim, sumDim-1, KwNaN);
-      }
-	
-      DDoubleGDL* p0D = static_cast<DDoubleGDL*>
-	(p0->Convert2( GDL_DOUBLE,BaseGDL::COPY));
-      auto_ptr<DDoubleGDL> p0D_guard( p0D);
-      //p0D_guard.reset( p0D);
-      return product_over_dim_template< DDoubleGDL>
-	( p0D, srcDim, sumDim-1,KwNaN);
-    } 
-    else
-      { // KwCumul
-
-        if (KwPre) 
-        {
-          switch (p0->Type())
-          {
-            case GDL_BYTE: return product_over_dim_cu_template<DByteGDL>(static_cast<DByteGDL*>(p0)->Dup(), sumDim-1, nanInt);
-            case GDL_INT: return product_over_dim_cu_template<DIntGDL>(static_cast<DIntGDL*>(p0)->Dup(), sumDim-1, nanInt);
-            case GDL_UINT: return product_over_dim_cu_template<DUIntGDL>(static_cast<DUIntGDL*>(p0)->Dup(), sumDim-1, nanInt);
-            case GDL_LONG: return product_over_dim_cu_template<DLongGDL>(static_cast<DLongGDL*>(p0)->Dup(), sumDim-1, nanInt);
-            case GDL_ULONG: return product_over_dim_cu_template<DULongGDL>(static_cast<DULongGDL*>(p0)->Dup(), sumDim-1, nanInt);
-            case GDL_LONG64: return product_over_dim_cu_template<DLong64GDL>(static_cast<DLong64GDL*>(p0)->Dup(), sumDim-1, nanInt);
-            case GDL_ULONG64: return product_over_dim_cu_template<DULong64GDL>(static_cast<DULong64GDL*>(p0)->Dup(), sumDim-1, nanInt);
-            case GDL_FLOAT: return product_over_dim_cu_template<DFloatGDL>(static_cast<DFloatGDL*>(p0)->Dup(), sumDim-1, KwNaN);
-            case GDL_DOUBLE: return product_over_dim_cu_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0)->Dup(), sumDim-1, KwNaN);
-            case GDL_COMPLEX: return product_over_dim_cu_template<DComplexGDL>(static_cast<DComplexGDL*>(p0)->Dup(), sumDim-1, KwNaN);
-            case GDL_COMPLEXDBL: return product_over_dim_cu_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0)->Dup(), sumDim-1, KwNaN);
-            default: assert(false);
-          }
-        }
-
-	// Integer parts derivated from Total code by Erin Sheldon
-	// In IDL PRODUCT(), the INTEGER keyword takes precedence 
-	if (KwInt) {
-	  // We use GDL_LONG64 unless the input is GDL_ULONG64
-	  if ((p0->Type() == GDL_LONG64) && (!KwNaN)) {
-	  return product_over_dim_cu_template<DLong64GDL>
-	    ( static_cast<DLong64GDL*>(p0)->Dup(), sumDim-1, nanInt);
-	}
-	if ((p0->Type() == GDL_ULONG64 ) && (!KwNaN)) {
-	  return product_over_dim_cu_template<DULong64GDL>
-	    ( static_cast<DULong64GDL*>(p0)->Dup(), sumDim-1, nanInt);
-	}
-	  
-	// Convert to Long64
-	if (KwNaN) {
-	  DFloatGDL* p0f = static_cast<DFloatGDL*>
-	    (p0->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	  auto_ptr<DFloatGDL> guard( p0f);
-	  for( SizeT i=0; i<nEl; ++i) {
-	    if (!isfinite((*p0f)[i])) (*p0f)[i]=1;
-	  }
-	  return product_over_dim_cu_template<DLong64GDL>
-	    ( static_cast<DLong64GDL*>
-	      (p0f->Convert2( GDL_LONG64, BaseGDL::COPY)), sumDim-1, nanInt);  
-	} else {
-	  return product_over_dim_cu_template<DLong64GDL>
-	    ( static_cast<DLong64GDL*>
-	      (p0->Convert2( GDL_LONG64, BaseGDL::COPY)), sumDim-1, nanInt);
-	}
-	} // integer results
-	
-	if( p0->Type() == GDL_DOUBLE) {
-	  return product_over_dim_cu_template< DDoubleGDL>
-	    ( static_cast<DDoubleGDL*>(p0)->Dup(), sumDim-1, KwNaN);
-	}
-	if( p0->Type() == GDL_COMPLEXDBL) {
-	  return product_over_dim_cu_template< DComplexDblGDL>
-	    ( static_cast<DComplexDblGDL*>(p0)->Dup(), sumDim-1, KwNaN);
-	}
-	if( p0->Type() == GDL_COMPLEX) {
-	  return product_over_dim_cu_template< DComplexDblGDL>
-	    ( static_cast<DComplexDblGDL*>
-	      (p0->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY)), sumDim-1, KwNaN);
-	}
-      
-	return product_over_dim_cu_template< DDoubleGDL>
-	  ( static_cast<DDoubleGDL*>
-	    (p0->Convert2( GDL_DOUBLE, BaseGDL::COPY)), sumDim-1, KwNaN);
-      }
-  }
-
-  BaseGDL* array_equal( EnvT* e)
-  {
-    e->NParam( 2);//, "ARRAY_EQUAL");
-
-    BaseGDL* p0 = e->GetParDefined( 0);//, "ARRAY_EQUAL");
-    BaseGDL* p1 = e->GetParDefined( 1);//, "ARRAY_EQUAL");
-
-    if( p0 == p1) return new DByteGDL( 1);
-
-    SizeT nEl0 = p0->N_Elements();
-    SizeT nEl1 = p1->N_Elements();
-    if( nEl0 != nEl1 && nEl0 != 1 && nEl1 != 1)
-      return new DByteGDL( 0);
-    
-    auto_ptr<BaseGDL> p0_guard;
-    auto_ptr<BaseGDL> p1_guard;
-    if( p0->Type() != p1->Type())
-      {
-	if( e->KeywordSet( 0)) // NO_TYPECONV
-	  return new DByteGDL( 0);
-	else
-	  {
-	    DType aTy=p0->Type();
-	    DType bTy=p1->Type();
-	    if( DTypeOrder[aTy] >= DTypeOrder[bTy])
-	      {
-		p1 = p1->Convert2( aTy, BaseGDL::COPY);
-		p1_guard.reset( p1);
-	      }
-	    else
-	      {
-		p0 = p0->Convert2( bTy, BaseGDL::COPY);
-		p0_guard.reset( p0);
-	      }
-	  }
-      }
-    
-    if( p0->ArrayEqual( p1)) return new DByteGDL( 1);
-
-    return new DByteGDL( 0);
-  }
-
-  BaseGDL* min_fun( EnvT* e)
-  {
-    SizeT nParam = e->NParam( 1);
-    BaseGDL* searchArr = e->GetParDefined( 0);
-
-    bool omitNaN = e->KeywordSet( "NAN");
-
-    static int subIx = e->KeywordIx("SUBSCRIPT_MAX");
-    bool subMax = e->KeywordPresent(subIx);  
-    
-    static int dimIx = e->KeywordIx("DIMENSION");
-    bool dimSet = e->KeywordSet(dimIx);
-
-    static int maxIx = e->KeywordIx("MAX");
-    bool maxSet = e->KeywordPresent(maxIx);
-
-    DLong searchDim; 
-    if (dimSet) {
-      e->AssureLongScalarKW(dimIx, searchDim);
-      if (searchDim < 0 || searchDim > searchArr->Rank())
-        e->Throw("Illegal keyword value for DIMENSION");
-    }
-
-    if (dimSet && searchArr->Rank() > 1) 
-    {
-      searchDim -= 1; // user-supplied dimensions start with 1!
-
-      // here destDim is in fact the srcDim...
-      dimension destDim = searchArr->Dim();
-      SizeT searchStride = destDim.Stride(searchDim);
-      SizeT outerStride = destDim.Stride(searchDim + 1);
-      // ... and now becomes the destDim
-      SizeT nSearch = destDim.Remove(searchDim);
-      SizeT searchLimit = nSearch * searchStride;
-      SizeT nEl = searchArr->N_Elements();
-
-      // memory allocation
-      BaseGDL *maxVal, *resArr = searchArr->New(destDim, BaseGDL::NOZERO);
-      DLongGDL *minElArr, *maxElArr;
-
-      if (maxSet) 
-      {
-        e->AssureGlobalKW(maxIx); // instead of using a guard pointer
-        maxVal = searchArr->New(destDim, BaseGDL::NOZERO);
-      }
-
-      if (subMax) 
-      { 
-        e->AssureGlobalKW(subIx); // instead of using a guard pointer
-        maxElArr = new DLongGDL(destDim);
-      }
-
-      if (nParam == 2) 
-      {
-        e->AssureGlobalPar(1);    // instead of using a guard pointer
-        minElArr = new DLongGDL(destDim);
-      }
-
-      SizeT rIx = 0;
-      for (SizeT o = 0; o < nEl; o += outerStride) for (SizeT i = 0; i < searchStride; ++i)
-      {
-        searchArr->MinMax(
-          (nParam == 2 ? &((*minElArr)[rIx]) : NULL), 
-          (subMax      ? &((*maxElArr)[rIx]) : NULL), 
-          &resArr, 
-          (maxSet      ? &maxVal             : NULL), 
-          omitNaN, o + i, searchLimit + o + i, searchStride, rIx
-        );
-        rIx++;
-      }
-
-      if (nParam == 2) e->SetPar(1, minElArr);
-      if (subMax) e->SetKW(subIx, maxElArr);
-      if (maxSet) e->SetKW(maxIx, maxVal);
-
-      return resArr;
-    } 
-    else 
-    {
-      DLong minEl;
-      BaseGDL* res;
-
-      if (maxSet) // MAX keyword given
-      {
-        e->AssureGlobalKW( 0);
-        GDLDelete(e->GetKW( 0));
-        DLong maxEl;
-        searchArr->MinMax( &minEl, &maxEl, &res, &e->GetKW( 0), omitNaN);
-        if (subMax) e->SetKW(subIx, new DLongGDL(maxEl));
-      }
-      else // no MAX keyword
-      {
-        if (subMax)
-        {
-          DLong maxEl;
-          searchArr->MinMax( &minEl, &maxEl, &res, NULL, omitNaN);
-          e->SetKW(subIx, new DLongGDL(maxEl));
-        }
-        else searchArr->MinMax(&minEl, NULL, &res, NULL, omitNaN);
-      }
-    
-      // handle index
-      if (nParam == 2) e->SetPar(1, new DLongGDL( minEl));
-      else SysVar::SetC( minEl);
-      return res;
-    }
-  }
-
-  BaseGDL* max_fun( EnvT* e)
-  {
-    SizeT nParam = e->NParam( 1);
-    BaseGDL* searchArr = e->GetParDefined( 0);
-
-    bool omitNaN = e->KeywordSet( "NAN");
-
-    static int subIx = e->KeywordIx("SUBSCRIPT_MIN");
-    bool subMin = e->KeywordPresent(subIx);  
-
-    static int dimIx = e->KeywordIx("DIMENSION");
-    bool dimSet = e->KeywordSet(dimIx);
-
-    static int minIx = e->KeywordIx("MIN");
-    bool minSet = e->KeywordPresent(minIx);
-
-    DLong searchDim; 
-    if (dimSet) 
-    {
-      e->AssureLongScalarKW(dimIx, searchDim);
-      if (searchDim < 0 || searchDim > searchArr->Rank())
-        e->Throw("Illegal keyword value for DIMENSION");
-    }
-
-    if (dimSet && searchArr->Rank() > 1) 
-    {
-      searchDim -= 1; // user-supplied dimensions start with 1!
-
-      // here destDim is in fact the srcDim...
-      dimension destDim = searchArr->Dim();
-      SizeT searchStride = destDim.Stride(searchDim);
-      SizeT outerStride = destDim.Stride(searchDim + 1);
-      // ... and now becomes the destDim
-      SizeT nSearch = destDim.Remove(searchDim);
-      SizeT searchLimit = nSearch * searchStride;
-      SizeT nEl = searchArr->N_Elements();
-
-      // memory allocation
-      BaseGDL *minVal, *resArr = searchArr->New(destDim, BaseGDL::NOZERO);
-      DLongGDL *minElArr, *maxElArr;
-
-      if (minSet) 
-      {    
-        e->AssureGlobalKW(minIx); // instead of using a guard pointer
-        minVal = searchArr->New(destDim, BaseGDL::NOZERO);
-      }    
-
-      if (subMin) 
-      {    
-        e->AssureGlobalKW(subIx); // instead of using a guard pointer
-        minElArr = new DLongGDL(destDim);
-      }    
-
-      if (nParam == 2) 
-      {    
-        e->AssureGlobalPar(1);    // instead of using a guard pointer
-        maxElArr = new DLongGDL(destDim);
-      }
-
-      SizeT rIx = 0;
-      for (SizeT o = 0; o < nEl; o += outerStride) for (SizeT i = 0; i < searchStride; ++i)
-      {
-        searchArr->MinMax(
-          (subMin      ? &((*minElArr)[rIx]) : NULL),
-          (nParam == 2 ? &((*maxElArr)[rIx]) : NULL),
-          (minSet      ? &minVal             : NULL),
-          &resArr,
-          omitNaN, o + i, searchLimit + o + i, searchStride, rIx
-        );
-        rIx++;
-      }
-
-      if (nParam == 2) e->SetPar(1, maxElArr);
-      if (subMin) e->SetKW(subIx, minElArr);
-      if (minSet) e->SetKW(minIx, minVal);
-
-      return resArr;
-    }
-    else 
-    {
-      DLong maxEl;
-      BaseGDL* res;
-
-      if (minSet) // MIN keyword given
-      {
-        e->AssureGlobalKW( 0);
-        GDLDelete(e->GetKW( 0));
-        DLong minEl;
-        searchArr->MinMax( &minEl, &maxEl, &e->GetKW( 0), &res, omitNaN);
-	if (subMin) e->SetKW(subIx, new DLongGDL(minEl));
-      }
-      else // no MIN keyword
-      {
-	if (subMin)
-        {
-          DLong minEl;
-          searchArr->MinMax( &minEl, &maxEl, NULL, &res, omitNaN);
-          e->SetKW(subIx, new DLongGDL(minEl));
-        }
-	else searchArr->MinMax(NULL, &maxEl, NULL, &res, omitNaN);
-      }
-
-      // handle index
-      if (nParam == 2) e->SetPar(1, new DLongGDL( maxEl));
-      else SysVar::SetC(maxEl);
-      return res;
-    }
-  }
- 
-BaseGDL* transpose( EnvT* e)
-  {
-    SizeT nParam=e->NParam( 1); 
-
-    BaseGDL* p0 = e->GetParDefined( 0);
-    if( p0->Type() == GDL_STRUCT)
-      e->Throw("Struct expression not allowed in this context: "+
-	       e->GetParString(0));
-    
-    SizeT rank = p0->Rank();
-    if( rank == 0)
-      e->Throw( "Expression must be an array "
-		"in this context: "+ e->GetParString(0));
-    
-    if( nParam == 2) 
-      {
- 
-	BaseGDL* p1 = e->GetParDefined( 1);
-	if( p1->N_Elements() != rank)
-	  e->Throw("Incorrect number of elements in permutation.");
-
-	DUInt* perm = new DUInt[rank];
-	auto_ptr<DUInt> perm_guard( perm);
-
-	DUIntGDL* p1L = static_cast<DUIntGDL*>
-	  (p1->Convert2( GDL_UINT, BaseGDL::COPY));
-	for( SizeT i=0; i<rank; ++i) perm[i] = (*p1L)[ i];
-	GDLDelete(p1L);
-
-	// check permutation vector
-	for( SizeT i=0; i<rank; ++i) 
-	  {
-	    DUInt j;
-	    for( j=0; j<rank; ++j) if( perm[j] == i) break;
-	    if (j == rank)
-	      e->Throw( "Incorrect permutation vector.");
-	  }
-	return p0->Transpose( perm);
-      }
-
-    return p0->Transpose( NULL);
-  }
-
-
-// BaseGDL* matrix_multiply( EnvT* e)
-//   {
-//     SizeT nParam=e->NParam( 2); 
-// 
-//     BaseGDL* a = e->GetNumericArrayParDefined( 0);
-//     BaseGDL* b = e->GetNumericArrayParDefined( 1);
-//     
-//     static int aTIx = e->KeywordIx("ATRANSPOSE");
-//     bool aT = e->KeywordPresent(aTIx);
-//     static int bTIx = e->KeywordIx("BTRANSPOSE");
-//     bool bT = e->KeywordPresent(bTIx);
-//     
-//     static int strassenIx = e->KeywordIx("STRASSEN_ALGORITHM");
-//     bool strassen = e->KeywordPresent(strassenIx);
-// 
-//     
-//     if( p1->N_Elements() != rank)
-// 	  e->Throw("Incorrect number of elements in permutation.");
-// 
-// 	DUInt* perm = new DUInt[rank];
-// 	auto_ptr<DUInt> perm_guard( perm);
-// 
-// 	DUIntGDL* p1L = static_cast<DUIntGDL*>
-// 	  (p1->Convert2( GDL_UINT, BaseGDL::COPY));
-// 	for( SizeT i=0; i<rank; ++i) perm[i] = (*p1L)[ i];
-// 	delete p1L;
-// 
-// 	// check permutaion vector
-// 	for( SizeT i=0; i<rank; ++i) 
-// 	  {
-// 	    DUInt j;
-// 	    for( j=0; j<rank; ++j) if( perm[j] == i) break;
-// 	    if (j == rank)
-// 	      e->Throw( "Incorrect permutation vector.");
-// 	  }
-// 	return p0->Transpose( perm);
-//       }
-// 
-//     return a->Transpose( NULL);
-//   }
-
-  // helper function for sort_fun, recursive
-  // optimized version
-  template< typename IndexT>
-  void MergeSortOpt( BaseGDL* p0, IndexT* hhS, IndexT* h1, IndexT* h2,
-		     SizeT len) 
-  {
-    if( len <= 1) return;       
-
-    SizeT h1N = len / 2;
-    SizeT h2N = len - h1N;
-
-    // 1st half
-    MergeSortOpt(p0, hhS, h1, h2, h1N);
-
-    // 2nd half
-    IndexT* hhM = &hhS[h1N]; 
-    MergeSortOpt(p0, hhM, h1, h2, h2N);
-
-    SizeT i;
-    for(i=0; i<h1N; ++i) h1[i] = hhS[ i];
-    for(i=0; i<h2N; ++i) h2[i] = hhM[ i];
-
-    SizeT  h1Ix = 0;
-    SizeT  h2Ix = 0;
-    for( i=0; (h1Ix < h1N) && (h2Ix < h2N); ++i) 
-      {
-	// the actual comparisson
-	if( p0->Greater( h1[h1Ix], h2[h2Ix])) 
-	  hhS[ i] = h2[ h2Ix++];
-	else
-	  hhS[ i] = h1[ h1Ix++];
-      }
-    for(; h1Ix < h1N; ++i) hhS[ i] = h1[ h1Ix++];
-    for(; h2Ix < h2N; ++i) hhS[ i] = h2[ h2Ix++];
-  }
-
-  // helper function for sort_fun, recursive
-  void MergeSort( BaseGDL* p0, SizeT* hh, SizeT* h1, SizeT* h2,
-		  SizeT start, SizeT end) 
-  {
-    if( start+1 >= end) return;       
-
-    SizeT middle = (start+end) / 2;
-
-    MergeSort(p0, hh, h1, h2, start, middle);
-    MergeSort(p0, hh, h1, h2, middle, end);
-
-    SizeT h1N = middle - start;
-    SizeT h2N = end - middle;
-
-    SizeT* hhS = &hh[start];
-
-    SizeT i;
-    for(i=0; i<h1N; ++i) h1[i] = hhS[ i];
-    for(i=0; i<h2N; ++i) h2[i] = hh[middle + i];
-
-    SizeT  h1Ix = 0;
-    SizeT  h2Ix = 0;
-    for( i=0; (h1Ix < h1N) && (h2Ix < h2N); ++i) 
-      {
-	// the actual comparisson
-	if( p0->Greater( h1[h1Ix], h2[h2Ix])) 
-	  hhS[ i] = h2[ h2Ix++];
-	else
-	  hhS[ i] = h1[ h1Ix++];
-      }
-    for(; h1Ix < h1N; ++i) hhS[ i] = h1[ h1Ix++];
-    for(; h2Ix < h2N; ++i) hhS[ i] = h2[ h2Ix++];
-  }
-
-  // sort function uses MergeSort
-  BaseGDL* sort_fun( EnvT* e)
-  {
-    e->NParam( 1);
-    
-    BaseGDL* p0 = e->GetParDefined( 0);
-
-    if( p0->Type() == GDL_STRUCT)
-      e->Throw( "Struct expression not allowed in this context: "+
-		e->GetParString(0));
-    
-    static int l64Ix = e->KeywordIx( "L64");
-    bool l64 = e->KeywordSet( l64Ix);
-    
-    SizeT nEl = p0->N_Elements();
-    
-    // helper arrays
-    DLongGDL* res = new DLongGDL( dimension( nEl), BaseGDL::INDGEN);
-
-	DLong nanIx = nEl;
-    if( p0->Type() == GDL_FLOAT)
-    {
-		DFloatGDL* p0F = static_cast<DFloatGDL*>(p0);
-		for( DLong i=nEl-1; i >= 0; --i)
-		{
-			if( isnan((*p0F)[ i]) )//|| !isfinite((*p0F)[ i]))
-				{
-					--nanIx;
-					(*res)[i] = (*res)[nanIx];
-					(*res)[ nanIx] = i;
-
-// cout << "swap " << i << " with " << nanIx << endl;
-// cout << "now:     ";
-// 		for( DLong ii=0; ii < nEl; ++ii)
-// 		{
-// 		cout << (*res)[ii] << " ";		
-// 		}
-// cout  << endl;
-				}
-		}
-    }
-    else if( p0->Type() == GDL_DOUBLE)
-    {
-		DDoubleGDL* p0F = static_cast<DDoubleGDL*>(p0);
-		for( DLong i=nEl-1; i >= 0; --i)
-		{
-			if( isnan((*p0F)[ i]))// || !isfinite((*p0F)[ i]))
-				{
-					--nanIx;
-					(*res)[i] = (*res)[nanIx];
-					(*res)[ nanIx] = i;
-				}
-		}
-    }
-    else if( p0->Type() == GDL_COMPLEX)
-    {
-		DComplexGDL* p0F = static_cast<DComplexGDL*>(p0);
-		for( DLong i=nEl-1; i >= 0; --i)
-		{
-			if( isnan((*p0F)[ i].real()) || //!isfinite((*p0F)[ i].real()) ||
-			     isnan((*p0F)[ i].imag()))// || !isfinite((*p0F)[ i].imag()) )
-				{
-					--nanIx;
-					(*res)[i] = (*res)[nanIx];
-					(*res)[ nanIx] = i;
-				}
-		}
-    }
-    else if( p0->Type() == GDL_COMPLEXDBL)
-    {
-		DComplexDblGDL* p0F = static_cast<DComplexDblGDL*>(p0);
-		for( DLong i=nEl-1; i >= 0; --i)
-		{
-			if( isnan((*p0F)[ i].real()) || //!isfinite((*p0F)[ i].real()) ||
-			     isnan((*p0F)[ i].imag()))// || !isfinite((*p0F)[ i].imag()) )
-				{
-					--nanIx;
-					(*res)[i] = (*res)[nanIx];
-					(*res)[ nanIx] = i;
-				}
-		}
-    }
-
-// cout << "nEl " << nEl << " nanIx " << nanIx << endl;
-	nEl = nanIx;
-// cout << "sorting:  ";
-// 		for( DLong ii=0; ii < nEl; ++ii)
-// 		{
-// 		cout << (*res)[ii] << " ";		
-// 		}
-// cout  << endl;
-
-    DLong *hh = static_cast<DLong*>(res->DataAddr());
-
-    DLong* h1 = new DLong[ nEl/2];
-    DLong* h2 = new DLong[ (nEl+1)/2];
-    // call the sort routine
-    MergeSortOpt<DLong>( p0, hh, h1, h2, nEl);
-    delete[] h1;
-    delete[] h2;
-
-    if( l64) 
-      {
-	// leave it this way, as sorting of more than 2^31
-	// items seems not feasible in the future we might 
-	// use MergeSortOpt<DLong64>(...) for this 
-	return res->Convert2( GDL_LONG64);
-      }
-
-    return res;
-  }
-
-  // uses MergeSort
-  // 2 parts in the code: without "width" or with "width" (limited to 1D and 2D)
-  BaseGDL* median( EnvT* e) {
-    
-    BaseGDL* p0 = e->GetParDefined( 0);
-
-    if( p0->Type() == GDL_PTR)
-      e->Throw( "Pointer expression not allowed in this context: "+ e->GetParString(0));
-    if( p0->Type() == GDL_OBJ)
-      e->Throw( "Object expression not allowed in this context: "+ e->GetParString(0));
-    if( p0->Type() == GDL_STRUCT)
-      e->Throw( "Struct expression not allowed in this context: "+ e->GetParString(0));
-
-    if( p0->Rank() == 0)
-      e->Throw( "Expression must be an array in this context: "+ e->GetParString(0));
-
-    SizeT nParam = e->NParam( 1);
-    SizeT nEl = p0->N_Elements();
-    
-    // "f_nan" and "d_nan" used by both parts ...
-    static DStructGDL *Values = SysVar::Values();
-    DFloat f_nan=(*static_cast<DFloatGDL*>(Values->GetTag(Values->Desc()->TagIndex("F_NAN"), 0)))[0];
-    DDouble d_nan=(*static_cast<DDoubleGDL*>(Values->GetTag(Values->Desc()->TagIndex("D_NAN"), 0)))[0];
-    
-    // --------------------------------------------------------
-    // begin of the part 1: without "width" param
-    if( nParam == 1) {
-      
-	static int evenIx = e->KeywordIx( "EVEN");
-	
-	// TYPE
-	bool dbl = 
-          p0->Type() == GDL_DOUBLE || 
-          p0->Type() == GDL_COMPLEXDBL || 
-          e->KeywordSet(e->KeywordIx("DOUBLE"));
-	DType type = dbl ? GDL_DOUBLE : GDL_FLOAT;
-	bool noconv = (dbl && p0->Type() == GDL_DOUBLE) ||
-	  (!dbl && p0->Type() == GDL_FLOAT);
-
-	// DIMENSION keyword
-	DLong dim = 0;
-	DLong nmed = 1;
-	BaseGDL *res;
-	e->AssureLongScalarKWIfPresent( "DIMENSION", dim);
-
-	//	cout << "dim : "<< dim << endl;
-	
-	if (dim > p0->Rank())
-	  e->Throw( "Illegal keyword value for DIMENSION.");
-	
-	if (dim > 0) {
-	  DLong dims[8];
-	  DLong k = 0;
-	  for (SizeT i=0; i<p0->Rank(); ++i)
-	    if (i != (dim-1)) {
-	      nmed *= p0->Dim(i);
-	      dims[k++] = p0->Dim(i);
-	    }
-	  dimension dimRes((DLong *) dims, p0->Rank()-1);
-	  res = dbl 
-            ? static_cast<BaseGDL*>(new DDoubleGDL(dimRes, BaseGDL::NOZERO))
-            : static_cast<BaseGDL*>(new DFloatGDL(dimRes, BaseGDL::NOZERO));
-	} else {
-	  res = dbl 
-            ? static_cast<BaseGDL*>(new DDoubleGDL(1))
-            : static_cast<BaseGDL*>(new DFloatGDL(1));
-	}
-
-	// conversion of Complex types
-	if (p0->Type() == GDL_COMPLEX) p0 = p0->Convert2(GDL_FLOAT, BaseGDL::COPY);
-	if (p0->Type() == GDL_COMPLEXDBL) p0 = p0->Convert2(GDL_DOUBLE, BaseGDL::COPY);
-
-	// helper arrays
-	if (nmed > 1) nEl = p0->N_Elements() / nmed;
-	
-	//	cout << "hello2" << endl;
-
-	DLong *hh = new DLong[ nEl];
-	DLong* h1 = new DLong[ nEl/2];
-	DLong* h2 = new DLong[ (nEl+1)/2];
-
-	DLong accumStride = 1;
-	if (nmed > 1)
-	  for( DLong i=0; i<dim-1; ++i) accumStride *= p0->Dim(i);
-
-	BaseGDL *op1, *op2, *op3;
-        if (dbl) op3 = new DDoubleGDL(2);
-        else op3 = new DFloatGDL(2);
-
-	// nEl_extern is used to store "nEl" initial value
-	DLong nanIx, nEl_extern;
-	nEl_extern=nEl;
-	//	if (nmed > 1) nEl_extern = p0->N_Elements() / nmed;
-	//else nEl_extern = p0->N_Elements();
-
-	//	cout << "hello type" << p0->Type() << endl;
-	
-	// Loop over all subarray medians
-	for (SizeT k=0; k<nmed; ++k) {
-	  
-	  //	  nEl=nEl_extern;
-
-	  if (nmed == 1) {
-	    //cout << "hello inside 1D" << endl;
-	    for( DLong i=0; i<nEl; ++i) hh[i] = i;
-	    nanIx = nEl;
-
-	    if (p0->Type() == GDL_DOUBLE) {
-	      DDoubleGDL* p0F = static_cast<DDoubleGDL*>(p0);
-	      for( DLong i=nEl-1; i >= 0; --i) {
-		if( isnan((*p0F)[i])) {
-		  --nanIx;
-		  hh[i] = hh[nanIx];
-		  hh[ nanIx] = i;
-		}
-	      }
-	    }
-	    
-	    if (p0->Type() == GDL_FLOAT) {
-	      DFloatGDL* p0F = static_cast<DFloatGDL*>(p0);
-	      for( DLong i=nEl-1; i >= 0; --i) {
-		if( isnan((*p0F)[i])) {
-		  --nanIx;
-		  hh[i] = hh[nanIx];
-		  hh[ nanIx] = i;
-		}
-	      }
-	    }
-	    
-	    //cout << "nEl " << nEl << " nanIx " << nanIx << endl;
-	    nEl = nanIx;
-	  }
-	  else
-	    {
-	      nanIx = nEl;
-	      nEl=nEl_extern; 
-
-	      //	      DLong nanIx = nEl;
-	      // Starting Element
-	      DLong start = accumStride * p0->Dim(dim-1) * (k / accumStride) + 
-		(k % accumStride);
-	      for( DLong i=0; i<nEl; ++i) hh[i] = start + i * accumStride;
-	      DLong jj;
-	      nanIx = nEl;
-
-	      if (p0->Type() == GDL_FLOAT) {
-		DFloatGDL* p0F = static_cast<DFloatGDL*>(p0);
-		for( DLong i=nEl-1; i >= 0; --i) {
-		  jj=start + i * accumStride;
-		  if( isnan((*p0F)[ jj]) ) {
-		    --nanIx;
-		    hh[i] = hh[nanIx];
-		    hh[ nanIx] = i;
-		  }
-		}
-		nEl = nanIx;
-	      }
-
-	      if (p0->Type() == GDL_DOUBLE) {
-		DDoubleGDL* p0F = static_cast<DDoubleGDL*>(p0);
-		for( DLong i=nEl-1; i >= 0; --i) {
-		  jj=start + i * accumStride;
-		  if( isnan((*p0F)[ jj]) ) {
-		    --nanIx;
-		    hh[i] = hh[nanIx];
-		    hh[ nanIx] = i;
-		  }
-		}
-		//cout << "nanIx :" << nanIx << "nEl :" << nEl << endl;
-		nEl = nanIx;
-	      }
-	    }
-	  DLong medEl, medEl_1;
-
-	  // call the sort routine
-	  if (nEl > 1) {
-	    MergeSortOpt<DLong>( p0, hh, h1, h2, nEl);
-	    medEl = hh[ nEl/2];
-	    medEl_1 = hh[ nEl/2 - 1];
-	  } else {
-	    if (nEl == 1) {
-	      medEl = hh[0];
-	      medEl_1 = hh[0];
-	    } else
-	      { // normal case, more than one element, nothing to do
-		//cout << "gasp : no result ! " << endl;
-	      }
-	  }
-
-	  if (nEl <= 0) { // we have a NaN
-	    if (dbl) (*static_cast<DDoubleGDL*>(res))[k] = d_nan;
-	    else (*static_cast<DFloatGDL*>(res))[k] = f_nan;
-	  } else {
-	    //cout << k << "" << (*static_cast<DFloatGDL*>(p0))[medEl] << " " 
-	    //	 << (*static_cast<DFloatGDL*>(p0))[medEl_1] << endl;
-	    //cout << "k :" << k << endl;
-	    if( (nEl % 2) == 1 || !e->KeywordSet( evenIx)) {
-	      if (nmed == 1)
-		res = p0->NewIx(medEl)->Convert2(type, BaseGDL::CONVERT); 
-	      else {
-		if (noconv) 
-		  {
-		    if (dbl) (*static_cast<DDoubleGDL*>(res))[k] = (*static_cast<DDoubleGDL*>(p0))[medEl];
-		    else (*static_cast<DFloatGDL*>(res))[k] = (*static_cast<DFloatGDL*>(p0))[medEl];
-		  }
-		else 
-		  {
-		    op1 = p0->NewIx(medEl)->Convert2(type, BaseGDL::CONVERT);
-		    if (dbl) (*static_cast<DDoubleGDL*>(res))[k] = (*static_cast<DDoubleGDL*>(op1))[0];
-		    else (*static_cast<DFloatGDL*>(res))[k] = (*static_cast<DFloatGDL*>(op1))[0];
-		    delete(op1);
-		  }
-	      }
-	    } else {
-	      if (noconv) 
-		{
-		  if (dbl) (*static_cast<DDoubleGDL*>(res))[k] = .5 * (
-								       (*static_cast<DDoubleGDL*>(p0))[medEl] + 
-								       (*static_cast<DDoubleGDL*>(p0))[medEl_1]
-								       );
-		  else (*static_cast<DFloatGDL*>(res))[k] = .5 * (
-								  (*static_cast<DFloatGDL*>(p0))[medEl] +
-								  (*static_cast<DFloatGDL*>(p0))[medEl_1]
-								  );
-		}
-	      else
-		{
-		  op1 = p0->NewIx(medEl)->Convert2(type, BaseGDL::CONVERT); 
-		  op2 = p0->NewIx(medEl_1)->Convert2(type, BaseGDL::CONVERT);
-		  if (nmed == 1) res = op2->Add(op1)->Div(op3); // TODO: leak with res?
-		  else 
-		    {
-		      if (dbl) (*static_cast<DDoubleGDL*>(res))[k] =
-				 (*static_cast<DDoubleGDL*>((op2->Add(op1)->Div(op3))))[0];
-		      else (*static_cast<DFloatGDL*>(res))[k] =
-			     (*static_cast<DFloatGDL*>((op2->Add(op1)->Div(op3))))[0];
-		      delete(op2);
-		    }
-		  delete(op1);
-		}
-	    }
-	  }
-	}
-        delete(op3);
-	delete[] h1;
-	delete[] h2;
-	delete[] hh;
-
-	return res;
-    }
-
-    // begin of the part 2: with "width" param
-    if( nParam == 2) {
-      // with parameter Width : median filtering with no optimisation,
-      //  such as histogram algorithms.
-      // Copyright: (C) 2008 by Nicolas Galmiche
-
-      // basic checks on "vector/array" input	
-      DDoubleGDL* p0 = e->GetParAs<DDoubleGDL>( 0);	
-
-      if( p0->Rank() > 2)
-	e->Throw( "Only 1 or 2 dimensions allowed: "+ e->GetParString(0));
-      
-      // basic checks on "width" input		
-      DDoubleGDL* p1d = e->GetParAs<DDoubleGDL>(1);
- 	
-      if (p1d->N_Elements() > 1 || (*p1d)[0] <=0 ) 
-	e->Throw( "Width must be a positive scalar or 1 (positive) element array in this context: "+ e->GetParString(0));
-      DLong MaxAllowedWidth=0;
-      if (p0->Rank() == 1) MaxAllowedWidth=p0->N_Elements();
-      if (p0->Rank() == 2) {
-	MaxAllowedWidth=p0->Dim(0);
-	if (p0->Dim(1) < MaxAllowedWidth) MaxAllowedWidth=p0->Dim(1);	   
-      }
-      const int debug =0;
-      if (debug == 1) {
-	cout << "X dim " << p0->Dim(0) <<endl;
-	cout << "y dim " << p0->Dim(1) <<endl;	  
-	cout << "MaxAllowedWidth " << MaxAllowedWidth <<endl;
-      }
-	if (!isfinite( (*p1d)[0]))
-	  e->Throw("Width must be > 1, and < dimension of array (NaN or Inf)");
-	
- 	DLongGDL* p1 = e->GetParAs<DLongGDL>(1);	
-
-	DDoubleGDL *tamp = new DDoubleGDL(p0->Dim(),BaseGDL::NOZERO);
-	DDouble min=((*p0)[0]);
-     	DDouble max=min;
-    	 
-     	for (SizeT ii=0 ; ii<p0->N_Elements() ; ++ii)
-	  {(*tamp)[ii]=(*p0)[ii];
-	    if ( (*p0)[ii] < min ) min = ((*p0)[ii]);
-	    if ( (*p0)[ii] > max ) max = ((*p0)[ii]);
-	  }	
-		
-   	//---------------------------- END d'acquisistion des paramètres -------------------------------------	
-
-	
-	static int evenIx = e->KeywordIx( "EVEN");
-	static int doubleIx = e->KeywordIx( "DOUBLE");
-	static DStructGDL *Values =  SysVar::Values();                                                
-	DDouble d_nan=(*static_cast<DDoubleGDL*>(Values->GetTag(Values->Desc()->TagIndex("D_NAN"), 0)))[0];
-	DDouble d_infinity= (*static_cast<DDoubleGDL*>(Values->GetTag(Values->Desc()->TagIndex("D_INFINITY"), 0)))[0]; 
- 
-	//------------------------------ Init variables and allocation ---------------------------------------
-	SizeT width=(*p1)[0];
-	SizeT N_MaskElem= width*width;
-	SizeT larg = p0->Stride(1);
-	SizeT haut = p0->Stride(2)/larg;
-	SizeT lim= static_cast<SizeT>(round(width/2));
-	SizeT init=(lim*larg+lim);
-	
-	// we don't go further if dimension(s) versus not width OK
-
-	if (debug == 1) {cout << "ici" <<endl;}
-	
-	if ( p0->Rank() == 1) {
-	  if (larg < width || width==1 ) e->Throw( "Width must be > 1, and < width of vector");
-	} 
-	if ( p0->Rank() == 2) {	
-	  if (larg < width || haut < width || width==1) e->Throw("Width must be > 1, and < dimension of array");
-	}
-
-	// for 2D arrays, we use the algorithm described in paper
-	// from T. Huang, G. Yang, and G. Tang, “A Fast Two-Dimensional Median
-	// Filtering Algorithm,” IEEE Trans. Acoust., Speech, Signal Processing,
-	// vol. 27, no. 1, pp. 13–18, 1979.
-
-	if ( (e->GetParDefined( 0)->Type() == GDL_BYTE ||
-	      e->GetParDefined( 0)->Type() == GDL_INT  || 
-	      e->GetParDefined( 0)->Type() == GDL_UINT ||
-	      e->GetParDefined( 0)->Type() == GDL_LONG ||
-	      e->GetParDefined( 0)->Type() == GDL_ULONG ||
-	      e->GetParDefined( 0)->Type() == GDL_LONG64 ||
-	      e->GetParDefined( 0)->Type() == GDL_ULONG64) &&
-	     (haut>1))
-	  {
-	    SizeT taille=static_cast<SizeT>(abs(max)-min+1);		
-	    DDoubleGDL* Histo = new DDoubleGDL(taille,BaseGDL::NOZERO);
-	    if (width % 2 ==0)
-	      {
-		for(SizeT i=0 ; i<haut-2*lim ; ++i)				
-		  {
-		    SizeT ltmed=0;
-		    SizeT med=0;
-		    SizeT initial=init+i*larg-lim*larg-lim;
-		    for(SizeT pp=0 ; pp<taille;++pp)(*Histo)[pp]=0;	
-		    for (SizeT ii=initial ; ii <initial+ width ; ++ii)
-		      {	
-			for(SizeT yy=0;yy<width;yy++)
-			  (*Histo)[static_cast<SizeT>((*p0)[ii+yy*larg]-min)]++;
-		      }
-		    
-		    while (ltmed+(*Histo)[med]<=(N_MaskElem /2))
-		      {
-			ltmed+= static_cast<SizeT>((*Histo)[med]);
-			++med;
-		      }
-		    if (e->KeywordSet( evenIx))
-		      {
-			
-			SizeT EvenMed=med;
-			//if ((*Histo)[EvenMed]==1 || (ltmed!=0 && ltmed !=(N_MaskElem /2) -1))
-			if ((*Histo)[EvenMed]==1 || (ltmed!=0 && N_MaskElem /2- ltmed!=1) )
-			  {
-			    while ((*Histo)[EvenMed-1]==0)
-			      {  EvenMed--;}
-			    (*tamp)[init+i*larg]=((med+min)+(EvenMed-1+min))/2;
-			  }
-			else
-			  (*tamp)[init+i*larg]=med+min;
-		      }
-		    else
-		      {(*tamp)[init+i*larg]=med+min; }
-		    
-		    for(SizeT j=init+i*larg +1; j<init+(i+1)*larg-2*lim ;++ j)	
-		      {				
-			SizeT initMask=j-lim*larg-lim;			
-			for(SizeT k=0;k<2*lim;++k)			
-			  {	
-			    (*Histo)[static_cast<SizeT>((*p0)[initMask-1+k*larg]-min)]--;
-			    if ((*p0)[initMask-1+k*larg]-min<med)ltmed--;
-				 						
-			    (*Histo)[static_cast<SizeT>((*p0)[initMask+k*larg+2*lim-1]-min)]++;
-			    if ((*p0)[initMask+k*larg+2*lim-1]-min<med)ltmed++;
-			  }
-			if (ltmed>N_MaskElem /2)
-			  {
-			    while(ltmed>N_MaskElem /2)
-			      {
-				--med;
-				ltmed-=static_cast<SizeT>((*Histo)[med]);
-			      }
-			  }
-			else
-			  {
-			    while (ltmed+(*Histo)[med]<=(N_MaskElem /2))
-			      {
-				ltmed+= static_cast<SizeT>((*Histo)[med]);
-				++med;
-			      }	
-			  }
-			
-			if (e->KeywordSet( evenIx))
-			  {
-			    SizeT EvenMed=med;
-			    if ((*Histo)[EvenMed]==1 || (ltmed!=0 &&N_MaskElem /2- ltmed!=1 ))
-			      {
-				while ((*Histo)[EvenMed-1]==0)
-				  {  EvenMed--;}
-				(*tamp)[j]=((med+min)+(EvenMed-1+min))/2;
-			      }
-			    else
-			      {(*tamp)[j]=med+min; }
-			  }
-			else
-			  {(*tamp)[j]=med+min; }
-		      }
-		  } 
-	      }
-	    else
-	      {
-		for(SizeT i=0 ; i<haut-2*lim ; ++i)				
-		  {
-		    SizeT ltmed=0;
-		    SizeT med=0;
-		    SizeT initial=init+i*larg-lim*larg-lim;
-		    for(SizeT pp=0 ; pp<taille;++pp)(*Histo)[pp]=0;	
-		    for (SizeT ii=initial ; ii <initial+ width ; ++ii)
-		      {	
-			for(SizeT yy=0;yy<width;yy++)
-			  (*Histo)[static_cast<SizeT>((*p0)[ii+yy*larg]-min)]++;
-		      }
-
-		    while (ltmed+(*Histo)[med]<=(N_MaskElem /2))
-		      {
-			ltmed+= static_cast<SizeT>((*Histo)[med]);
-			++med;
-		      }
-		    (*tamp)[init+i*larg]=med+min;
-	
-		    for(SizeT j=init+i*larg +1; j<init+(i+1)*larg-2*lim ;++ j)	
-		      {	
-			
-			SizeT initMask=j-lim*larg-lim;			
-			for(SizeT k=0;k<=2*lim;++k)			
-			  {	
-			    (*Histo)[static_cast<SizeT>((*p0)[initMask-1+k*larg]-min)]--;
-			    if ((*p0)[initMask-1+k*larg]-min<med)ltmed--;
-				 						 						 		
-			    (*Histo)[static_cast<SizeT>((*p0)[initMask+k*larg+2*lim]-min)]++;
-			    if ((*p0)[initMask+k*larg+2*lim]-min<med)ltmed++;
-			  }
-			if (ltmed>N_MaskElem /2)
-			  {
-			    while(ltmed>N_MaskElem /2)
-			      {
-				--med;
-				ltmed-=static_cast<SizeT>((*Histo)[med]);
-			      }
-			  }
-			else
-			  {
-			    while (ltmed+(*Histo)[med]<=(N_MaskElem /2))
-			      {
-				ltmed+= static_cast<SizeT>((*Histo)[med]);
-				++med;
-			      }	
-			  }
-			
-			(*tamp)[j]=med+min;
-			
-		      }
-		  } 
-	      }
-	
-	  }
-	else
-	  {	
-	    DLong* hh; 
-	    DLong* h1;
-	    DLong* h2;
-	    DDoubleGDL* Mask,*Mask1D;
-	    if ( p0->Rank() != 1 )
-	      {
-		hh = new DLong[ N_MaskElem];
-    		h1 = new DLong[ N_MaskElem/2];
-		h2= new DLong[ (N_MaskElem+1)/2];
-		Mask = new DDoubleGDL(N_MaskElem,BaseGDL::NOZERO);
-		
-		for( DLong i=0; i<N_MaskElem; ++i) hh[i] = i;
-	      }
-	    else
-	      {
-		hh = new DLong[ width];
-		h1 = new DLong[ width/2];
-		h2= new DLong[(width+1)/2];
-		Mask1D = new DDoubleGDL(width,BaseGDL::NOZERO);
-		
-		for( DLong i=0; i<width; ++i) hh[i] = i;
-	      }
-	
-	    //-------------------------------- END OF VARIABLES INIT ---------------------------------------------
-
-	    //------------------------------ Median Filter Algorithms ---------------------------------------
-	
-	    if ( width % 2 ==0)
-	      {
-		if ( p0->Rank() == 1 )//------------------------  For a vector with even width -------------------
-		  {	
-		    for (SizeT col= lim ; col<larg-lim ; ++col)
-		      {	
-			SizeT ctl_NaN=0;
-			SizeT kk=0;
-			for (SizeT ind=col-lim ; ind<col+lim ; ++ind)
-			  {
-			    if( (*p0)[ind]!=d_infinity && (*p0)[ind]!=-d_infinity && isfinite((*p0)[ind])==0)
-			      ctl_NaN++;
-			    else
-			      {	
-				(*Mask1D)[kk]=(*p0)[ind];
-				kk++;
-			      }
-			  }
-			if (ctl_NaN!=0)
-			  {
-			    if(ctl_NaN==width)(*tamp)[col]= d_nan;
-			    else 
-			      {
-				DLong*	hhbis = new DLong[ width-ctl_NaN];
-				DLong*	h1bis = new DLong[ width-ctl_NaN/2];
-				DLong*	h2bis= new DLong[(width-ctl_NaN+1)/2];
-				DDoubleGDL *Mask1Dbis = new DDoubleGDL(width-ctl_NaN,BaseGDL::NOZERO);
-				for( DLong t=0; t<width-ctl_NaN; ++t) hhbis[t] = t;
-				for( DLong ii=0; ii<width-ctl_NaN; ++ii)(*Mask1Dbis)[ii]=(*Mask1D)[ii];
-				BaseGDL* besort=static_cast<BaseGDL*>(Mask1Dbis);	
-				MergeSortOpt<DLong>( besort, hhbis, h1bis, h2bis,(width - ctl_NaN));
-				if (e->KeywordSet( evenIx)&& (width - ctl_NaN) % 2 == 0)
-				  (*tamp)[col]=((*Mask1Dbis)[hhbis[ (width-ctl_NaN)/2]]+(*Mask1Dbis
-											 )[hhbis	[ (width - ctl_NaN-1)/2]])/2;
-				else
-				  (*tamp)[col]=(*Mask1Dbis)[hhbis[ (width- ctl_NaN)/2]];
-				delete[]hhbis;
-				delete[]h2bis;
-				delete[]h1bis;
-			      }
-			  }	
-			else
-			  {
-			    BaseGDL* besort=static_cast<BaseGDL*>(Mask1D);	
-			    MergeSortOpt<DLong>( besort, hh, h1, h2,width ); // call the sort routine
-
-			    if (e->KeywordSet( evenIx))
-
-			      (*tamp)[col]=((*Mask1D)[hh[ width/2]]+(*Mask1D)[hh[ (width-1)/2]])/2;
-			    else
-			      (*tamp)[col]=(*Mask1D)[hh[ width/2]];// replace value by Mask median 
-			  }
-		      }
-			
-		  }
-		else//------------------------  For an array with even width -------------------
-		  {
-		    SizeT jj;
-		    for(SizeT i=0 ; i<haut-2*lim ; ++i)		// lines to replace
-		      {
-		 	for(SizeT j=init+i*larg ; j<init+(i+1)*larg-2*lim ; ++j)// elements to replace
-			  {
-			    SizeT initMask=j-lim*larg-lim;	// left corner of mask
-			    SizeT kk=0;
-			    SizeT ctl_NaN=0;
-			    for(SizeT k=0;k<2*lim;++k)		// lines of mask
-			      {	
-								
-				for(jj=initMask+k*larg ; jj<(initMask+k*larg)+2*lim ; ++jj) // elements of mask
-				  {
-				    if( (*p0)[jj]!=d_infinity && (*p0)[jj]!=-d_infinity && isfinite((*p0)[jj])==0)
-				      ctl_NaN++;
-				    else
-				      {
-					(*Mask)[kk]=(*p0)[jj];
-					kk++;
-				      }
-				  }
-			      }
-			    if (ctl_NaN!=0)
-			      {
-				if(ctl_NaN==N_MaskElem)(*tamp)[j]= d_nan;
-				else {
-				  DLong*	hhb = new DLong[ N_MaskElem-ctl_NaN];
-				  DLong*	h1b = new DLong[ (N_MaskElem-ctl_NaN)/2];
-				  DLong*	h2b = new DLong[(N_MaskElem-ctl_NaN+1)/2];
-				  DDoubleGDL *Maskb = new DDoubleGDL(N_MaskElem-ctl_NaN,BaseGDL::NOZERO);
-				  for( DLong t=0; t<N_MaskElem-ctl_NaN; ++t) hhb[t] = t;
-				  for( DLong ii=0; ii<N_MaskElem-ctl_NaN; ++ii)(*Maskb)[ii]=(*Mask)[ii];
-				  BaseGDL* besort=static_cast<BaseGDL*>(Maskb);	
-				  MergeSortOpt<DLong>( besort, hhb, h1b, h2b,(N_MaskElem - ctl_NaN)); 
-				  if ((N_MaskElem - ctl_NaN) % 2 == 0 && e->KeywordSet( evenIx))
-				    (*tamp)[j]=((*Maskb)[hhb[ (N_MaskElem-ctl_NaN)/2]]+(*Maskb)[hhb 
-												[ (N_MaskElem - 
-												   ctl_NaN-1)/2]])/2;
-				  else
-				    (*tamp)[j]=(*Maskb)[hhb[ (N_MaskElem- ctl_NaN)/2]];
-				  delete[]hhb;
-				  delete[]h2b;
-				  delete[]h1b;
-				}
-			      }	
-			    else
-			      {
-			 	BaseGDL* besort=static_cast<BaseGDL*>(Mask);	
-			 	MergeSortOpt<DLong>( besort, hh, h1, h2, N_MaskElem); // call the sort routine
-				if (e->KeywordSet( evenIx))
-				  (*tamp)[j]=((*Mask)[hh[ N_MaskElem/2]]+(*Mask)[hh[ (N_MaskElem-1)/2]])/2;
-				else
-				  (*tamp)[j]=(*Mask)[hh[ N_MaskElem/2]];// replace value by median Mask one
-			      }
-			  }
-		      }
-		  }
-	      }
-
-	    else
-	      {
-		if ( p0->Rank() == 1 )//------------------------  For a vector with odd width -------------------
-	
-		  {	
-		    for (SizeT col= lim ; col<larg-lim ; ++col)
-		      {	
-			SizeT kk=0;
-			SizeT ctl_NaN=0;
-			for (SizeT ind=col-lim ; ind<=col+lim ; ++ind)
-			  {if( (*p0)[ind]!=d_infinity && (*p0)[ind]!=-d_infinity && isfinite((*p0)[ind])==0)
-			      ctl_NaN++;
-			    else{
-			      (*Mask1D)[kk]=(*p0)[ind];				
-			      kk++;
-			    }
-			  }
-			if (ctl_NaN!=0)
-			  {
-			    if(ctl_NaN==width)(*tamp)[col]= d_nan;
-			    else {
-			      DLong*	hhbis = new DLong[ width-ctl_NaN];
-			      DLong*	h1bis = new DLong[ width-ctl_NaN/2];
-			      DLong*	h2bis= new DLong[(width-ctl_NaN+1)/2];
-			      DDoubleGDL *Mask1Dbis = new DDoubleGDL(width-ctl_NaN,BaseGDL::NOZERO);
-			      for( DLong t=0; t<width-ctl_NaN; ++t) hhbis[t] = t;
-			      for( DLong ii=0; ii<width-ctl_NaN; ++ii)(*Mask1Dbis)[ii]=(*Mask1D)[ii];
-			      BaseGDL* besort=static_cast<BaseGDL*>(Mask1Dbis);	
-			      MergeSortOpt<DLong>( besort, hhbis, h1bis, h2bis,(width - ctl_NaN)); 
-			      if (e->KeywordSet( evenIx)&& (width - ctl_NaN) % 2 == 0)
-				(*tamp)[col]=((*Mask1Dbis)[hhbis[ (width-ctl_NaN)/2]]+(*Mask1Dbis
-										       )[hhbis	[ (width - ctl_NaN-1)/2]])/2;	
-			      else(*tamp)[col]=(*Mask1Dbis)[hhbis[ (width- ctl_NaN)/2]];
-			      delete[]hhbis;
-			      delete[]h2bis;
-			      delete[]h1bis;
-			    }
-			  }	
-			else
-			  {
-			    BaseGDL* besort=static_cast<BaseGDL*>(Mask1D);	
-			    MergeSortOpt<DLong>( besort, hh, h1, h2,width ); // call the sort routine
-			    (*tamp)[col]=(*Mask1D)[hh[ (width)/2]];	// replace value by Mask median 
-			  }
-		      }
-		
-		  }
-	
-		else //-----------------------------  For an array with odd width ---------------------------------
-		  {
-		    SizeT jj;
-		    for(SizeT i=0 ; i<haut-2*lim ; ++i)				// lines to replace
-		      {
-		
-		 	SizeT initial=init+i*larg-lim*larg-lim;
-			SizeT dd=0;SizeT ctl_NaN_init=0;
-			for(SizeT yy=0;yy<width;yy++)
-			  {	
-			    for (SizeT ii=initial+yy*larg ; ii <initial+ yy*larg+ width; ++ii)
-			      {
-					
-				if( (*p0)[ii]!=d_infinity && (*p0)[ii]!=-d_infinity && isfinite((*p0)[ii])==0)
-				  ctl_NaN_init++;
-				else
-				  (*Mask)[dd]=(*p0)[ii];
-				dd++;
-			      }
-			  }
-			SizeT kk=0;
-
-		 	for(SizeT j=init+i*larg ; j<init+(i+1)*larg-2*lim ; ++j)// elements to replace
-			  {
-			    SizeT initMask=j-lim*larg-lim;			// left corner of mask
-			    SizeT kk=0;
-			    SizeT ctl_NaN=0;
-			    for(SizeT k=0;k<=2*lim;++k)			// lines of mask
-			      {	
-								
-				for(jj=initMask+k*larg ; jj<=(initMask+k*larg)+2*lim ; ++jj) // elements of mask
-				  {
-				    if( (*p0)[jj]!=d_infinity && (*p0)[jj]!=-d_infinity && isfinite((*p0)[jj])==0)
-				      ctl_NaN++;
-						
-				    else
-				      {
-					(*Mask)[kk]=(*p0)[jj];
-					kk++;
-				      }
-				  }
-				
-			      }
-			 
-			    if (ctl_NaN!=0)
-			      {	
-				if(ctl_NaN==N_MaskElem)
-				  (*tamp)[j]= d_nan;
-				else {
-				  DLong*	hhb = new DLong[ N_MaskElem-ctl_NaN];
-				  DLong*	h1b = new DLong[ (N_MaskElem-ctl_NaN)/2];
-				  DLong*	h2b= new DLong[(N_MaskElem-ctl_NaN+1)/2];
-				  DDoubleGDL*Maskb = new DDoubleGDL(N_MaskElem-ctl_NaN,BaseGDL::NOZERO);
-				  for( DLong t=0; t<N_MaskElem-ctl_NaN; ++t) hhb[t] = t;
-				  for( DLong ii=0; ii<N_MaskElem-ctl_NaN; ++ii)(*Maskb)[ii]=(*Mask)[ii];
-				  BaseGDL* besort=static_cast<BaseGDL*>(Maskb);
-				  MergeSortOpt<DLong>( besort, hhb, h1b, h2b,(N_MaskElem - ctl_NaN));
-				  if ((N_MaskElem - ctl_NaN) % 2 == 0 && e->KeywordSet( evenIx))
-				    (*tamp)[j]=((*Maskb)[hhb[ (N_MaskElem-ctl_NaN)/2]]+(*Maskb)[hhb
-												[ (N_MaskElem - 
-												   ctl_NaN-1)/2]])/2;
-				  else(*tamp)[j]=(*Maskb)[hhb[(N_MaskElem- ctl_NaN)/2]];
-				  delete[]hhb;
-				  delete[]h2b;
-				  delete[]h1b;
-				}
-			      }	
-			    else
-			      {
-				BaseGDL* besort=static_cast<BaseGDL*>(Mask);	
-			 	MergeSortOpt<DLong>( besort, hh, h1, h2, N_MaskElem); // call the sort routine
-				(*tamp)[j]=(*Mask)[hh[ (N_MaskElem)/2]];	// replace value by Mask median 
-			      }
-			  }
-		      }
-		  }
-	      }
-	    
-	    //--------------------------- END OF MEDIAN FILTER ALOGORITHMS -----------------------------------
-
-	    delete[] h1;
-	    delete[] h2;
-	    delete[] hh;   	
-	  }
-       	if ( e->GetParDefined( 0)->Type() == GDL_DOUBLE || p0->Type() == GDL_COMPLEXDBL ||e->KeywordSet( doubleIx) )
-	  return tamp;
-	else if (e->GetParDefined( 0)->Type() == GDL_BYTE) 
-	  return tamp->Convert2(GDL_BYTE,BaseGDL::CONVERT);
-	
-	return tamp->Convert2(GDL_FLOAT,BaseGDL::CONVERT);
-	
-      }// end if
-
-  }// end of median
-
-  BaseGDL* shift_fun( EnvT* e)
-  {
-    SizeT nParam = e->NParam( 2);
-
-    BaseGDL* p0 = e->GetParDefined( 0);
-
-    SizeT nShift = nParam - 1;
-    if( nShift == 1)
-      {
-		DLong s1;
-		e->AssureLongScalarPar( 1, s1);
-
-		// IncRef[Obj] done for GDL_PTR and GDL_OBJ
-		return p0->CShift( s1);
-      }
-    
-    if( p0->Rank() != nShift)
-      e->Throw( "Incorrect number of arguments.");
-
-    DLong sIx[ MAXRANK];
-    for( SizeT i=0; i< nShift; i++)
-      e->AssureLongScalarPar( i+1, sIx[ i]);
-
-	if( p0->Type() == GDL_OBJ)
-		GDLInterpreter::IncRefObj( static_cast<DObjGDL*>(p0));
-	else if( p0->Type() == GDL_PTR)
-		GDLInterpreter::IncRef( static_cast<DPtrGDL*>(p0));
-
-	return p0->CShift( sIx);
-  }
-
-  BaseGDL* arg_present( EnvT* e)
-  {
-    e->NParam( 1);
-    
-    if( !e->GlobalPar( 0))
-      return new DIntGDL( 0);
-
-    EnvBaseT* caller = e->Caller();
-    if( caller == NULL)
-      return new DIntGDL( 0);
-
-    BaseGDL** pp0 = &e->GetPar( 0);
-    
-    int ix = caller->FindGlobalKW( pp0);
-    if( ix == -1)
-      return new DIntGDL( 0);
-
-    return new DIntGDL( 1);
-  }
-
-  BaseGDL* eof_fun( EnvT* e)
-  {
-    e->NParam( 1);
-
-    DLong lun;
-    e->AssureLongScalarPar( 0, lun);
-
-    bool stdLun = check_lun( e, lun);
-    if( stdLun)
-      return new DIntGDL( 0);
-
-    // nicer error message (Disregard if socket)
-    if ( fileUnits[ lun-1].SockNum() == -1) {
-      if( !fileUnits[ lun-1].IsOpen())
-	throw GDLIOException( e->CallingNode(), "File unit is not open: "+i2s( lun)+".");
-
-      if( fileUnits[ lun-1].Eof())
-	return new DIntGDL( 1);
-    } else {
-      // Socket
-      string *recvBuf = &fileUnits[ lun-1].RecvBuf();
-      if (recvBuf->size() == 0)
-	return new DIntGDL( 1);
-    }
-    return new DIntGDL( 0);
-  }
-
-  BaseGDL* convol( EnvT* e)
-  {
-    SizeT nParam=e->NParam( 2); 
-
-    BaseGDL* p0 = e->GetNumericParDefined( 0);
-    if( p0->Rank() == 0) 
-      e->Throw( "Expression must be an array in this context: "+
-		e->GetParString(0));
-    
-    BaseGDL* p1 = e->GetNumericParDefined( 1);
-    if( p1->Rank() == 0) 
-      e->Throw( "Expression must be an array in this context: "+
-		e->GetParString(1));
-    
-    if( p0->N_Elements() <= p1->N_Elements())
-      e->Throw( "Incompatible dimensions for Array and Kernel.");
-
-    // rank 1 for kernel works always
-    if( p1->Rank() != 1)
-      {
-	SizeT rank = p0->Rank();
-	if( rank != p1->Rank())
-	  e->Throw( "Incompatible dimensions for Array and Kernel.");
-
-	for( SizeT r=0; r<rank; ++r)
-	  if( p0->Dim( r) <= p1->Dim( r))
-	    e->Throw( "Incompatible dimensions for Array and Kernel.");
-      }
-
-    // convert kernel to array type
-    auto_ptr<BaseGDL> p1Guard;
-    if( p0->Type() == GDL_BYTE)
-      {
-	if( p1->Type() != GDL_INT)
-	  {
-	    p1 = p1->Convert2( GDL_INT, BaseGDL::COPY); 
-	    p1Guard.reset( p1);
-	  }
-      }
-    else if( p0->Type() != p1->Type())
-      {
-	p1 = p1->Convert2( p0->Type(), BaseGDL::COPY); 
-	p1Guard.reset( p1);
-      }
-
-    BaseGDL* scale;
-    auto_ptr<BaseGDL> scaleGuard;
-    if( nParam > 2)
-      {
-	scale = e->GetParDefined( 2);
-	if( scale->Rank() > 0)
-	  e->Throw( "Expression must be a scalar in this context: "+
-		    e->GetParString(2));
-
-	// p1 here handles GDL_BYTE case also
-	if( p1->Type() != scale->Type())
-	  {
-	    scale = scale->Convert2( p1->Type(),BaseGDL::COPY); 
-	    scaleGuard.reset( scale);
-	  }
-      }
-    else
-      {
-	scale = p1->New( dimension(), BaseGDL::ZERO);
-      }
-
-    bool center = true;
-    static int centerIx = e->KeywordIx( "CENTER");
-    if( e->KeywordPresent( centerIx))
-      {
-	DLong c;
-	e->AssureLongScalarKW( centerIx, c);
-	center = (c != 0);
-      }
-
-    // overrides EDGE_TRUNCATE
-    static int edge_wrapIx = e->KeywordIx( "EDGE_WRAP");
-    bool edge_wrap = e->KeywordSet( edge_wrapIx);
-    static int edge_truncateIx = e->KeywordIx( "EDGE_TRUNCATE");
-    bool edge_truncate = e->KeywordSet( edge_truncateIx);
-
-    int edgeMode = 0; 
-    if( edge_wrap)
-      edgeMode = 1;
-    else if( edge_truncate)
-      edgeMode = 2;
-
-    // p0, p1 and scale have same type
-    // p1 has rank of 1 or same rank as p0 with each dimension smaller than p0
-    // scale is a scalar
-    return p0->Convol( p1, scale, center, edgeMode);
-  }
-
-  BaseGDL* rebin_fun( EnvT* e)
-  {
-    SizeT nParam = e->NParam( 2);
-
-    BaseGDL* p0 = e->GetNumericParDefined( 0);
-
-    SizeT rank = p0->Rank();
-
-    if( rank == 0) 
-      e->Throw( "Expression must be an array in this context: "+
-		e->GetParString(0));
-    
-    SizeT resDimInit[ MAXRANK];
-
-    DLongGDL* p1 = e->GetParAs<DLongGDL>(1);
-    if (p1->Rank() > 0 && nParam > 2) 
-      e->Throw("The new dimensions must either be specified as an array or as a set of scalars.");
-    SizeT np = p1->Rank() == 0 ? nParam : p1->N_Elements() + 1;
-
-    for( SizeT p=1; p<np; ++p)
-      {
-	DLong newDim;
-	if (p1->Rank() == 0) e->AssureLongScalarPar( p, newDim);
-        else newDim = (*p1)[p - 1];
-
-	if( newDim <= 0)
-	  e->Throw( "Array dimensions must be greater than 0.");
-	
-	if( rank >= p)
-	  {
-	    SizeT oldDim = p0->Dim( p-1);
-
-	    if( newDim > oldDim)
-	      {
-		if( (newDim % oldDim) != 0)
-		  e->Throw( "Result dimensions must be integer factor "
-			    "of original dimensions.");
-	      }
-	    else
-	      {
-		if( (oldDim % newDim) != 0)
-		  e->Throw( "Result dimensions must be integer factor "
-			    "of original dimensions.");
-	      }
-	  }
-	
-	resDimInit[ p-1] = newDim; 
-      }
-
-    dimension resDim( resDimInit, np-1);
-
-    static int sampleIx = e->KeywordIx( "SAMPLE");
-    bool sample = e->KeywordSet( sampleIx);
-    
-    return p0->Rebin( resDim, sample);
-  }
-
-  BaseGDL* obj_class( EnvT* e)
-  {
-    SizeT nParam = e->NParam();
-
-    static int countIx = e->KeywordIx( "COUNT");
-    static int superIx = e->KeywordIx( "SUPERCLASS");
-
-    bool super = e->KeywordSet( superIx);
-
-    bool count = e->KeywordPresent( countIx);
-    if( count)
-      e->AssureGlobalKW( countIx);
-
-    if( nParam > 0)
-      {
-	BaseGDL* p0 = e->GetParDefined( 0);
-
-	if( p0->Type() != GDL_STRING && p0->Type() != GDL_OBJ)
-	  e->Throw( "Argument must be a scalar object reference or string: "+
-		    e->GetParString(0));
-
-	if( !p0->Scalar())
-	  e->Throw( "Expression must be a scalar or 1 element "
-		    "array in this context: "+e->GetParString(0));
-
-	DStructDesc* objDesc;
-
-	if( p0->Type() == GDL_STRING)
-	  {
-	    DString objName;
-	    e->AssureScalarPar<DStringGDL>( 0, objName);
-	    objName = StrUpCase( objName);
-
-	    objDesc = FindInStructList( structList, objName);
-	    if( objDesc == NULL)
-	      {
-		if( count)
-		  e->SetKW( countIx, new DLongGDL( 0));
-		return new DStringGDL( "");
-	      }
-	  }
-	else // GDL_OBJ
-	  {
-	    DObj objRef;
-	    e->AssureScalarPar<DObjGDL>( 0, objRef);
-
-	    if( objRef == 0)
-	      {
-		if( count)
-		  e->SetKW( countIx, new DLongGDL( 0));
-		return new DStringGDL( "");
-	      }
-
-	    DStructGDL* oStruct;
-	    try {
-	      oStruct = e->GetObjHeap( objRef);
-	    }
-	    catch ( GDLInterpreter::HeapException)
-	      { // non valid object
-		if( count)
-		  e->SetKW( countIx, new DLongGDL( 0));
-		return new DStringGDL( "");
-	      }
-
-	    objDesc = oStruct->Desc(); // cannot be NULL
-	  }
-
-	if( !super)
-	  {
-	    if( count)
-	      e->SetKW( countIx, new DLongGDL( 1));
-	    return new DStringGDL( objDesc->Name());
-	  }
-	
-	deque< string> pNames;
-	objDesc->GetParentNames( pNames);
-
-	SizeT nNames = pNames.size();
-	    
-	if( count)
-	  e->SetKW( countIx, new DLongGDL( nNames));
-
-	if( nNames == 0)
-	  {
-	    return new DStringGDL( "");
-	  }
-
-	DStringGDL* res = new DStringGDL( dimension( nNames), 
-					  BaseGDL::NOZERO);
-
-	for( SizeT i=0; i<nNames; ++i)
-	  {
-	    (*res)[i] = pNames[i];
-	  }
-	
-	return res;
-      }
-
-    if( super)
-      e->Throw( "Conflicting keywords.");
-
-    SizeT nObj = structList.size();
-
-    DStringGDL* res = new DStringGDL( dimension( nObj), 
-				      BaseGDL::NOZERO);
-
-    for( SizeT i=0; i<nObj; ++i)
-      {
-	(*res)[i] = structList[i]->Name();
-      }
-	
-    return res;
-  }
-
-  BaseGDL* obj_isa( EnvT* e)
-  {
-    SizeT nParam = e->NParam( 2);
-
-    BaseGDL* p0 = e->GetPar( 0);
-    if( p0 == NULL || p0->Type() != GDL_OBJ)
-      e->Throw( "Object reference type required in this context: "+
-		e->GetParString(0));
-
-    DString className;
-    e->AssureScalarPar<DStringGDL>( 1, className);
-    className = StrUpCase( className);
-
-    DObjGDL* pObj = static_cast<DObjGDL*>( p0);
-
-    DByteGDL* res = new DByteGDL( pObj->Dim()); // zero 
-
-    GDLInterpreter* interpreter = e->Interpreter();
-
-    SizeT nElem = pObj->N_Elements();
-    for( SizeT i=0; i<nElem; ++i)
-      {
-	if( interpreter->ObjValid( (*pObj)[ i])) 
-	  {
-	    DStructGDL* oStruct = e->GetObjHeap( (*pObj)[i]);
-	    if( oStruct->Desc()->IsParent( className))
-	      (*res)[i] = 1;
-	  }
-      }
-    
-    return res;
-  }
-
-  BaseGDL* n_tags( EnvT* e)
-  {
-    e->NParam( 1);
-
-    BaseGDL* p0 = e->GetPar( 0);
-    if( p0 == NULL)
-      return new DLongGDL( 0);
-    
-    if( p0->Type() != GDL_STRUCT)
-      return new DLongGDL( 0);
-    
-    DStructGDL* s = static_cast<DStructGDL*>( p0);
-
-    //static int lengthIx = e->KeywordIx( "DATA_LENGTH");
-    //bool length = e->KeywordSet( lengthIx);
-    
-    // we don't know now how to distinghuis the 2 following cases
-    if(e->KeywordSet("DATA_LENGTH"))
-      return new DLongGDL( s->Sizeof());
-    
-    if(e->KeywordSet("LENGTH"))
-      return new DLongGDL( s->Sizeof());
-
-    return new DLongGDL( s->Desc()->NTags());
-  }
-
-  BaseGDL* bytscl( EnvT* e)
-  {
-    SizeT nParam = e->NParam( 1);
-
-    BaseGDL* p0=e->GetNumericParDefined( 0);
-
-    static int minIx = e->KeywordIx( "MIN");
-    static int maxIx = e->KeywordIx( "MAX");
-    static int topIx = e->KeywordIx( "TOP");
-    bool omitNaN = e->KeywordPresent( 3);
-
-    DLong topL=255;
-    if( e->GetKW( topIx) != NULL)
-      e->AssureLongScalarKW( topIx, topL);
-    DByte top = static_cast<DByte>(topL);
-    DDouble dTop = static_cast<DDouble>(top);
-
-    DDouble min;
-    bool minSet = false;
-    // SA: handling 3 parameters to emulate undocumented IDL behaviour 
-    //     of translating second and third arguments to MIN and MAX, respectively
-    //     (parameters have precedence over keywords)
-    if (nParam >= 2)
-    {
-      e->AssureDoubleScalarPar(1, min);
-      minSet = true;
-    } 
-    else if (e->GetKW(minIx) != NULL)
-    {
-      e->AssureDoubleScalarKW(minIx, min);
-      minSet = true;
-    }
-
-    DDouble max;
-    bool maxSet = false;
-    if (nParam == 3)
-    {
-      e->AssureDoubleScalarPar(2, max);
-      maxSet = true;
-    }
-    else if (e->GetKW(maxIx) != NULL)
-    {
-      e->AssureDoubleScalarKW(maxIx, max);
-      maxSet = true;
-    }
-
-    DDoubleGDL* dRes = 
-      static_cast<DDoubleGDL*>(p0->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-
-    DLong maxEl, minEl;
-    if( !maxSet || !minSet)
-      dRes->MinMax( &minEl, &maxEl, NULL, NULL, omitNaN);
-    if( !minSet)
-      min = (*dRes)[ minEl];
-    if( !maxSet)
-      max = (*dRes)[ maxEl];
-
-    SizeT nEl = dRes->N_Elements();
-    for( SizeT i=0; i<nEl; ++i)
-      {
-	DDouble& d = (*dRes)[ i];
-	if( d <= min) (*dRes)[ i] = 0;
-	else if( d >= max) (*dRes)[ i] = dTop;
-	else
-        {
-          // SA: floor is used for integer types to simulate manipulation on input data types
-          if (IntType(p0->Type())) (*dRes)[ i] = floor(((dTop + 1.)*(d - min) - 1.) / (max-min));
-          // SA (?): here floor is used (instead of round) to simulate IDL behaviour
-          else (*dRes)[ i] = floor((d - min) / (max-min) * (dTop + .9999));
-        }
-      }
-
-    return dRes->Convert2( GDL_BYTE);
-  } 
-
-  BaseGDL* strtok_fun( EnvT* e)
-  {
-    SizeT nParam=e->NParam( 1);
-    
-    DString stringIn;
-    e->AssureStringScalarPar( 0, stringIn);
-
-    DString pattern = " \t";
-    if(nParam > 1) {
-      e->AssureStringScalarPar( 1, pattern);
-    }
-    
-    static int extractIx = e->KeywordIx( "EXTRACT");
-    bool extract = e->KeywordSet( extractIx);
-
-    static int lengthIx = e->KeywordIx( "LENGTH");
-    bool lengthPresent = e->KeywordPresent( lengthIx);
-
-    if( extract && lengthPresent)
-      e->Throw( "Conflicting keywords.");
-    
-    static int pre0Ix = e->KeywordIx( "PRESERVE_NULL");
-    bool pre0 = e->KeywordSet( pre0Ix);
-
-    static int regexIx = e->KeywordIx( "REGEX");
-    bool regex = e->KeywordPresent( regexIx);
-    char err_msg[MAX_REGEXPERR_LENGTH];
-    regex_t regexp;
-    
-    deque<long> tokenStart;
-    deque<long> tokenLen;
- 
-    int strLen = stringIn.length();
-
-    DString escape = "";
-    e->AssureStringScalarKWIfPresent( "ESCAPE", escape);
-    deque<long> escList;
-    long pos = 0;
-    while(pos != string::npos)
-      {
-	pos = stringIn.find_first_of( escape, pos);
-	if( pos != string::npos)
-	  {
-	    escList.push_back( pos+1); // remember escaped char
-	    pos += 2; // skip escaped char
-	  }
-      }
-    deque<long>::iterator escBeg = escList.begin();
-    deque<long>::iterator escEnd = escList.end();
-
-    long tokB = 0;
-    long tokE;
-    long nextE = 0;
-    long actLen;
-
-    // If regex then compile regex
-    if( regex) {
-      if (pattern == " \t") pattern = " "; // regcomp doesn't like "\t" JMG
-      int compRes = regcomp( &regexp, pattern.c_str(), REG_EXTENDED);
-      if (compRes) {
-	regerror(compRes, &regexp, err_msg, MAX_REGEXPERR_LENGTH);
-	e->Throw(  "Error processing regular expression: "+
-			   pattern+"\n           "+string(err_msg)+".");
-      }
-    }
-
-    for(;;)
-      {
-	regmatch_t pmatch[1];
-	if( regex) {
-	  int matchres = regexec( &regexp, stringIn.c_str()+nextE, 1, pmatch, 0);
-	  tokE = matchres? -1:pmatch[0].rm_so;
-	} else { 
-	  tokE = stringIn.find_first_of( pattern, nextE);
-	}
-
-	if( tokE == string::npos)
-	  {
-	    actLen = strLen - tokB;
-	    if( actLen > 0 || pre0)
-	      {
-		tokenStart.push_back( tokB);
-		tokenLen.push_back( actLen);
-	      }
-	    break;
-	  }
-
-	if( find( escBeg, escEnd, tokE) == escEnd) 
-	  {
-	    if (regex) actLen = tokE; else actLen = tokE - tokB;
-	    if( actLen > 0 || pre0)
-	      {
-		tokenStart.push_back( tokB);
-		tokenLen.push_back( actLen);
-	      }
-	    if (regex) tokB += pmatch[0].rm_eo; else tokB = tokE + 1;
-	  }
-	if (regex) nextE += pmatch[0].rm_eo; else nextE = tokE + 1;
-      } // for(;;)
-
-    if (regex) regfree( &regexp);
-
-    SizeT nTok = tokenStart.size();
-
-    if( !extract)
-      {    
-	if( lengthPresent) 
-	  {
-	    e->AssureGlobalKW( lengthIx);
-	    
-	    if( nTok > 0)
-	      {
-		dimension dim(nTok);
-		DLongGDL* len = new DLongGDL(dim);
-		for(int i=0; i < nTok; i++)
-		  (*len)[i] = tokenLen[i];
-
-		e->SetKW( lengthIx, len);
-	      }
-	    else
-	      {
-		e->SetKW( lengthIx, new DLongGDL( 0));
-	      }
-	  }
-	
-	if( nTok == 0) return new DLongGDL( 0);
-    
-	dimension dim(nTok);
-	DLongGDL* d = new DLongGDL(dim);
-	for(int i=0; i < nTok; i++)
-	  (*d)[i] = tokenStart[i];
-	return d; 
-      } 
-
-    // EXTRACT
-    if( nTok == 0) return new DStringGDL( "");
-
-    dimension dim(nTok);
-    DStringGDL *d = new DStringGDL(dim);
-    for(int i=0; i < nTok; i++) 
-      {
-	(*d)[i] = stringIn.substr(tokenStart[i], tokenLen[i]);	
-
-	// remove escape
-	DString& act = (*d)[i];
-	long escPos = act.find_first_of( escape, 0);
-	while( escPos != string::npos)
-	  {
-	    act = act.substr( 0, escPos)+act.substr( escPos+1);
-	    escPos = act.find_first_of( escape, escPos+1);
-	  }
-      }
-    return d;
-  }
-
-  BaseGDL* getenv_fun( EnvT* e)
-  {
-    SizeT nParam=e->NParam();
-
-    static int environmentIx = e->KeywordIx( "ENVIRONMENT" );
-    bool environment = e->KeywordSet( environmentIx );
-  
-    SizeT nEnv; 
-    DStringGDL* env;
-
-    if( environment) {
-
-      if(nParam != 0) 
-        e->Throw( "Incorrect number of arguments.");
-
-      // determine number of environment entries
-      for(nEnv = 0; environ[nEnv] != NULL  ; ++nEnv);
-
-      dimension dim( nEnv );
-      env = new DStringGDL(dim);
-
-      // copy stuff into local string array
-      for(SizeT i=0; i < nEnv ; ++i)
-        (*env)[i] = environ[i];
-
-    } else {
-
-      if(nParam != 1) 
-        e->Throw( "Incorrect number of arguments.");
-
-      DStringGDL* name = e->GetParAs<DStringGDL>(0);
-      nEnv = name->N_Elements();
-
-      env = new DStringGDL( name->Dim());
- 
-      // copy the stuff into local string only if param found
-      char *resPtr;
-      for(SizeT i=0; i < nEnv ; ++i)
-	{
-	  // handle special environment variables
-	  // GDL_TMPDIR, IDL_TMPDIR
-	  if( (*name)[i] == "GDL_TMPDIR" || (*name)[i] == "IDL_TMPDIR")
-	    {
-	      resPtr = getenv((*name)[i].c_str());
-
-	      if( resPtr != NULL)
-		(*env)[i] = resPtr;
-	      else
-		(*env)[i] = SysVar::Dir();
-
-	      AppendIfNeeded( (*env)[i], "/");
-	    }
-	  else // normal environment variables
-	    if( (resPtr = getenv((*name)[i].c_str())) ) 
-	      (*env)[i] = resPtr;
-	}
-    }
-    
-    return env;
-  }
-
-  BaseGDL* tag_names_fun( EnvT* e)
-  {
-    SizeT nParam=e->NParam();
-    DStructGDL* struc= e->GetParAs<DStructGDL>(0);
-
-    static int structureNameIx = e->KeywordIx( "STRUCTURE_NAME" );
-    bool structureName = e->KeywordSet( structureNameIx );
-    
-    DStringGDL* tagNames;
-
-    if(structureName){
-        
-      if ((*struc).Desc()->Name() != "$truct")
-	tagNames =  new DStringGDL((*struc).Desc()->Name());
-      else
-	tagNames =  new DStringGDL("");
-
-    } else {
-      SizeT nTags = (*struc).Desc()->NTags();
-    
-      tagNames = new DStringGDL(dimension(nTags));
-      for(int i=0; i < nTags; ++i)
-        (*tagNames)[i] = (*struc).Desc()->TagName(i);
-    }
-
-    return tagNames;
-  }
-
-// AC 12-Oc-2011: better version for: len=len, /Extract and /Sub
-// but it is still not perfect
-
-  BaseGDL* stregex_fun( EnvT* e)
-  {
-    SizeT nParam=e->NParam( 2);
-    
-    DStringGDL* stringExpr= e->GetParAs<DStringGDL>(0);
-    dimension dim = stringExpr->Dim();
-
-    DString pattern;
-    e->AssureStringScalarPar(1, pattern);
-    if (pattern.size() <= 0)
-      {
-	e->Throw( "Error processing regular expression: "+pattern+
-		  "\n           empty (sub)expression");
-      }
-
-    static int booleanIx = e->KeywordIx( "BOOLEAN" );
-    bool booleanKW = e->KeywordSet( booleanIx );
-
-    static int extractIx = e->KeywordIx( "EXTRACT" );
-    bool extractKW = e->KeywordSet( extractIx );
-
-    static int foldCaseIx = e->KeywordIx( "FOLD_CASE" );
-    bool foldCaseKW = e->KeywordSet( foldCaseIx );
-
-    //XXXpch: this is wrong, should check arg_present
-    static int lengthIx = e->KeywordIx( "LENGTH" );
-    bool lengthKW = e->KeywordPresent( lengthIx );
-   
-    static int subexprIx = e->KeywordIx( "SUBEXPR" );
-    bool subexprKW = e->KeywordSet( subexprIx );
- 
-    if( booleanKW && (subexprKW || extractKW || lengthKW))
-      e->Throw( "Conflicting keywords.");
-  
-    char err_msg[MAX_REGEXPERR_LENGTH];
-
-    // set the compile flags 
-    int cflags = REG_EXTENDED;
-    if (foldCaseKW)
-      cflags |= REG_ICASE;
-    if (booleanKW)
-      cflags |= REG_NOSUB;
-
-    // compile the regular expression
-    regex_t regexp;
-    int compRes = regcomp( &regexp, pattern.c_str(), cflags);
-    SizeT nSubExpr = regexp.re_nsub + 1;
-    
-    //    cout << regexp.re_nsub << endl;
-
-    if (compRes) {
-      regerror(compRes, &regexp, err_msg, MAX_REGEXPERR_LENGTH);
-      e->Throw( "Error processing regular expression: "+
-                         pattern+"\n           "+string(err_msg)+".");
-    }
-
-    BaseGDL* result;
-
-    if( booleanKW) 
-      result = new DByteGDL(dim);
-    else if( extractKW && !subexprKW)
-      {
-	//	cout << "my pb ! ? dim= " << dim << endl;
-	result = new DStringGDL(dim);
-      }
-    else if( subexprKW)
-      {
-	//	cout << "my pb 2 ? dim= " << dim << endl;
-	dimension subExprDim = dim;
- 	subExprDim >> nSubExpr; // m_schellens: commented in, needed
-	if( extractKW)
-	  result = new DStringGDL(subExprDim);
-	else
-	  result = new DLongGDL(subExprDim);
-      }
-    else 
-      result = new DLongGDL(dim); 
-
-    DLongGDL* len = NULL;
-    if( lengthKW) {
-      e->AssureGlobalKW( lengthIx);
-      if( subexprKW)
-	{
-	  dimension subExprDim = dim;
-	  subExprDim >> nSubExpr; // m_schellens: commented in, needed
-	  len = new DLongGDL(subExprDim);
-	}
-      else
-	{
-	  len = new DLongGDL(dim);
-	}
-      for( SizeT i=0; i<len->N_Elements(); ++i)
-	   (*len)[i]= -1;
-    } 
-    
-    int nmatch = 1;
-    if( subexprKW) nmatch = nSubExpr;
-
-    regmatch_t* pmatch = new regmatch_t[nSubExpr];
-    ArrayGuard<regmatch_t> pmatchGuard( pmatch);
-
-    //    cout << "dim " << dim.NDimElements() << endl;	    
-    for( SizeT s=0; s<dim.NDimElements(); ++s)
-      {
-	int eflags = 0; 
-
-	for( SizeT sE=0; sE<nSubExpr; ++sE)
-	  pmatch[sE].rm_so = -1;
-
-	// now match towards the string
-	int matchres = regexec( &regexp, (*stringExpr)[s].c_str(),  nmatch, pmatch, eflags);
-
-	// subexpressions
-	if ( extractKW && subexprKW) {
-
-	  // Loop through subexpressions & fill output array
-	  for( SizeT i = 0; i<nSubExpr; ++i) {
-	    if (pmatch[i].rm_so != -1)
-		(*static_cast<DStringGDL*>(result))[i+s*nSubExpr] =
-			(*stringExpr)[s].substr( pmatch[i].rm_so,  pmatch[i].rm_eo - pmatch[i].rm_so);
-// 			(*stringExpr)[i+s*nSubExpr].substr( pmatch[i].rm_so,  pmatch[i].rm_eo - pmatch[i].rm_so);
-	    if( lengthKW)
-	      (*len)[i+s*nSubExpr] = pmatch[i].rm_so != -1 ? pmatch[i].rm_eo - pmatch[i].rm_so : -1;
-//  	      (*len)[i+s*nSubExpr] = pmatch[i].rm_eo - pmatch[i].rm_so;
-	  }
-	}
-	else  if ( subexprKW) 
-	  {
-	    //	    cout << "je ne comprends pas v2: "<< nSubExpr << endl;
-
-	    // Loop through subexpressions & fill output array
-	    for( SizeT i = 0; i<nSubExpr; ++i) {
-	      (* static_cast<DLongGDL*>(result))[i+s*nSubExpr] =  pmatch[i].rm_so;
-	      if( lengthKW)
-		(*len)[i+s*nSubExpr] = pmatch[i].rm_so != -1 ? pmatch[i].rm_eo - pmatch[i].rm_so : -1;
-	    }
-	  }
-	else
-	  {
-	    if( booleanKW)
-	      (* static_cast<DByteGDL*>(result))[s] = (matchres == 0);
-	    else if ( extractKW) // !subExprKW
-	      {
-	      if( matchres == 0)
-		(* static_cast<DStringGDL*>(result))[s] = 
-		  (*stringExpr)[s].substr( pmatch[0].rm_so, 
-					   pmatch[0].rm_eo - pmatch[0].rm_so);
-	      }
-	    else
-	      (*static_cast<DLongGDL*>(result))[s] = matchres ? -1 : pmatch[0].rm_so;
-	  }
-
-	if( lengthKW && !subexprKW)
-	  (*len)[s] = pmatch[0].rm_eo - pmatch[0].rm_so;
-      }
-
-    regfree( &regexp);
-
-    if( lengthKW)
-      e->SetKW( lengthIx, len);    
-
-    return result;
-  }
-
-  BaseGDL* routine_info( EnvT* e)
-  {
-    SizeT nParam=e->NParam();
-
-    static int functionsIx = e->KeywordIx( "FUNCTIONS" );
-    bool functionsKW = e->KeywordSet( functionsIx );
-    static int systemIx = e->KeywordIx( "SYSTEM" );
-    bool systemKW = e->KeywordSet( systemIx );
-    static int disabledIx = e->KeywordIx( "DISABLED" );
-    bool disabledKW = e->KeywordSet( disabledIx );
-    static int parametersIx = e->KeywordIx( "PARAMETERS" );
-    bool parametersKW = e->KeywordSet( parametersIx );
-
-    if (parametersKW)
-    {
-      // sanity checks
-      if (systemKW || disabledKW) e->Throw("Conflicting keywords.");
-      if (nParam != 1) e->Throw("Incorrect number of arguments.");
-
-      // getting the routine name from the first parameter
-      DString name;
-      e->AssureScalarPar<DStringGDL>(0, name);
-      name = StrUpCase(name);
-        
-      DSubUD* routine = functionsKW 
-        ? static_cast<DSubUD*>(funList[GDLInterpreter::GetFunIx(name)])
-        : static_cast<DSubUD*>(proList[GDLInterpreter::GetProIx(name)]);
-      SizeT np = routine->NPar(), nk = routine->NKey();
-
-      // creating the output anonymous structure
-      DStructDesc* stru_desc = new DStructDesc("$truct");
-      SpDLong aLong;
-      stru_desc->AddTag("NUM_ARGS", &aLong);
-      stru_desc->AddTag("NUM_KW_ARGS", &aLong);
-      if (np > 0) 
-      {
-        SpDString aStringArr(dimension((int)np));
-        stru_desc->AddTag("ARGS", &aStringArr);
-      }
-      if (nk > 0) 
-      {
-        SpDString aStringArr(dimension((int)nk));
-        stru_desc->AddTag("KW_ARGS", &aStringArr);
-      }
-      DStructGDL* stru = new DStructGDL(stru_desc, dimension());
-
-      // filling the structure with information about the routine 
-      stru->InitTag("NUM_ARGS", DLongGDL(np));
-      stru->InitTag("NUM_KW_ARGS", DLongGDL(nk));
-      if (np > 0)
-      {
-        DStringGDL *pnames = new DStringGDL(dimension(np));
-        for (SizeT p = 0; p < np; ++p) (*pnames)[p] = routine->GetVarName(nk + p); 
-        stru->InitTag("ARGS", *pnames);
-        GDLDelete(pnames);
-      }
-      if (nk > 0)
-      {
-        DStringGDL *knames = new DStringGDL(dimension(nk));
-        for (SizeT k = 0; k < nk; ++k) (*knames)[k] = routine->GetKWName(k); 
-        stru->InitTag("KW_ARGS", *knames);
-        GDLDelete(knames);
-      }
-
-      // returning
-      return stru;
-    }
-
-    // GDL does not have disabled routines
-    if( disabledKW) return new DStringGDL("");
-
-    //    if( functionsKW || systemKW || nParam == 0)
-    //      {
-    deque<DString> subList;
-	    
-    if( functionsKW)
-      {
-	if( systemKW)
-	  {
-	    SizeT n = libFunList.size();
-	    if( n == 0) return new DStringGDL("");
-
-	    DStringGDL* res = new DStringGDL( dimension( n), BaseGDL::NOZERO);
-	    for( SizeT i = 0; i<n; ++i)
-	      (*res)[i] = libFunList[ i]->ObjectName();
-
-	    return res;
-	  }
-	else
-	  {
-	    SizeT n = funList.size();
-	    if( n == 0) return new DStringGDL("");
-	    subList.resize( n);
-		
-	    for( SizeT i = 0; i<n; ++i)
-	      subList.push_back( funList[ i]->ObjectName());
-	  }
-      }
-    else
-      {
-	if( systemKW)
-	  {
-	    SizeT n = libProList.size();
-	    if( n == 0) return new DStringGDL("");
-
-	    DStringGDL* res = new DStringGDL( dimension( n), BaseGDL::NOZERO);
-	    for( SizeT i = 0; i<n; ++i)
-	      (*res)[i] = libProList[ i]->ObjectName();
-
-	    return res;
-	  }
-	else
-	  {
-	    SizeT n = proList.size();
-	    if( n == 0) return new DStringGDL("");
-	    subList.resize( n);
-		
-	    for( SizeT i = 0; i<n; ++i)
-	      subList.push_back( proList[ i]->ObjectName());
-	  }
-      }
-	
-    sort( subList.begin(), subList.end());
-    SizeT nS = subList.size();
-
-    DStringGDL* res = new DStringGDL( dimension( nS), BaseGDL::NOZERO);
-    for( SizeT s=0; s<nS; ++s)
-      (*res)[ s] = subList[ s];
-
-    return res;
-    //      }
-  }
-
-  BaseGDL* get_kbrd( EnvT* e)
-  {
-#if defined(HAVE_LIBREADLINE)
-#include <readline/readline.h>
-      rl_prep_terminal (0);
-#endif
-      
- SizeT nParam=e->NParam();
-
-    bool doWait = true;
-    if( nParam > 0)
-      {
-	doWait = false;
-	DLong waitArg = 0;
-	e->AssureLongScalarPar( 0, waitArg);
-	if( waitArg != 0)
-	  {
-	    doWait = true;
-	  }
-      }
-
-    // https://sourceforge.net/forum/forum.php?thread_id=3292183&forum_id=338691
-    // DONE: Implement proper SCALAR parameter handling (doWait variable)
-    // which is/was not blocking in the original program. 
-    // note: multi-byte input is not supported here.
-    
-    char c='\0'; //initialize is never a bad idea...
-
-    int fd=fileno(stdin);
-#ifndef _MSC_VER
-    struct termios orig, get; 
-#endif
-    // Get terminal setup to revert to it at end. 
-#ifndef _MSC_VER
-    (void)tcgetattr(fd, &orig); 
-    // New terminal setup, non-canonical.
-    get.c_lflag = ISIG; 
-#endif
-    if (doWait)
-    {
-     // will wait for a character
-#ifndef _MSC_VER
-     get.c_cc[VTIME]=0;
-     get.c_cc[VMIN]=1;
-     (void)tcsetattr(fd, TCSANOW, &get); 
-#endif
-     cin.get(c);
-    }
-    else 
-    {
-     // will not wait, but return EOF or next character in terminal buffer if present
-#ifndef _MSC_VER
-     get.c_cc[VTIME]=0;
-     get.c_cc[VMIN]=0;
-     (void)tcsetattr(fd, TCSANOW, &get); 
-#endif
-     //the trick is *not to use C++ functions here. cin.get would wait.*
-     c=std::fgetc(stdin);
-     //and to convert EOF to null (otherwise GDL may exit if not compiled with
-     //[lib][n]curses)
-     if(c==EOF) c='\0';
-    }
-    
-    // Restore original terminal settings. 
-#ifndef _MSC_VER
-    (void)tcsetattr(fd, TCSANOW, &orig); 
-#endif
-#if defined(HAVE_LIBREADLINE)
-    rl_deprep_terminal ();
-#endif
-
-    DStringGDL* res = new DStringGDL( DString( i2s( c))); 
-
-    return res;
- 
-  }
-
-
-  BaseGDL* temporary( EnvT* e)
-  {
-    SizeT nParam=e->NParam(1);
-
-    BaseGDL** p0 = &e->GetParDefined( 0);
-
-    BaseGDL* ret = *p0;
-
-    *p0 = NULL; // make parameter undefined
-    return ret;
-  }
-
-  BaseGDL* memory( EnvT* e)
-  {
-    SizeT nParam=e->NParam( 0); 
-
-    BaseGDL* ret;
-    bool kw_l64 = e->KeywordSet(e->KeywordIx("L64"));
-    // TODO: IDL-doc mentions about automatically switching to L64 if needed
-
-    if (e->KeywordSet(e->KeywordIx("STRUCTURE")))
-    {
-      // returning structure
-      if (kw_l64) 
-      {
-        ret = new DStructGDL("IDL_MEMORY64");
-        DStructGDL* retStru = static_cast<DStructGDL*>(ret);
-        (retStru->GetTag(retStru->Desc()->TagIndex("CURRENT")))->InitFrom( DLong64GDL(MemStats::GetCurrent()));
-        (retStru->GetTag(retStru->Desc()->TagIndex("NUM_ALLOC")))->InitFrom( DLong64GDL(MemStats::GetNumAlloc()));
-        (retStru->GetTag(retStru->Desc()->TagIndex("NUM_FREE")))->InitFrom( DLong64GDL(MemStats::GetNumFree()));
-        (retStru->GetTag(retStru->Desc()->TagIndex("HIGHWATER")))->InitFrom( DLong64GDL(MemStats::GetHighWater()));
-      }
-      else 
-      {
-        ret = new DStructGDL("IDL_MEMORY");
-        DStructGDL* retStru = static_cast<DStructGDL*>(ret);
-        (retStru->GetTag(retStru->Desc()->TagIndex("CURRENT")))->InitFrom( DLongGDL(MemStats::GetCurrent()));
-        (retStru->GetTag(retStru->Desc()->TagIndex("NUM_ALLOC")))->InitFrom( DLongGDL(MemStats::GetNumAlloc()));
-        (retStru->GetTag(retStru->Desc()->TagIndex("NUM_FREE")))->InitFrom( DLongGDL(MemStats::GetNumFree()));
-        (retStru->GetTag(retStru->Desc()->TagIndex("HIGHWATER")))->InitFrom( DLongGDL(MemStats::GetHighWater()));
-      }
-    }
-    else 
-    {
-      bool kw_current = e->KeywordSet(e->KeywordIx("CURRENT"));
-      bool kw_num_alloc = e->KeywordSet(e->KeywordIx("NUM_ALLOC"));
-      bool kw_num_free = e->KeywordSet(e->KeywordIx("NUM_FREE"));
-      bool kw_highwater = e->KeywordSet(e->KeywordIx("HIGHWATER"));
-
-      // Following the IDL documentation: mutually exclusive keywords
-      // IDL behaves different, incl. segfaults with selected kw combinations
-      if (kw_current + kw_num_alloc + kw_num_free + kw_highwater > 1) 
-        e->Throw("CURRENT, NUM_ALLOC, NUM_FREE & HIGHWATER keywords"
-          " are mutually exclusive");
-
-      if (kw_current)
-      {
-        if (kw_l64) ret = new DLong64GDL(MemStats::GetCurrent());
-        else ret = new DLongGDL(MemStats::GetCurrent());
-      } 
-      else if (kw_num_alloc)
-      {
-        if (kw_l64) ret = new DLong64GDL(MemStats::GetNumAlloc());
-        else ret = new DLongGDL(MemStats::GetNumAlloc());
-      }
-      else if (kw_num_free)
-      {
-        if (kw_l64) ret = new DLong64GDL(MemStats::GetNumFree());
-        else ret = new DLongGDL(MemStats::GetNumFree());
-      }
-      else if (kw_highwater)
-      {
-        if (kw_l64) ret = new DLong64GDL(MemStats::GetHighWater());
-        else ret = new DLongGDL(MemStats::GetHighWater());
-      }
-      else 
-      {
-        // returning 4-element array 
-        if (kw_l64) 
-        {
-          ret = new DLong64GDL(dimension(4));
-          (*static_cast<DLong64GDL*>(ret))[0] = MemStats::GetCurrent();
-          (*static_cast<DLong64GDL*>(ret))[1] = MemStats::GetNumAlloc();
-          (*static_cast<DLong64GDL*>(ret))[2] = MemStats::GetNumFree();
-          (*static_cast<DLong64GDL*>(ret))[3] = MemStats::GetHighWater();
-        }
-        else 
-        {
-          ret = new DLongGDL(dimension(4));
-          (*static_cast<DLongGDL*>(ret))[0] = MemStats::GetCurrent();
-          (*static_cast<DLongGDL*>(ret))[1] = MemStats::GetNumAlloc();
-          (*static_cast<DLongGDL*>(ret))[2] = MemStats::GetNumFree();
-          (*static_cast<DLongGDL*>(ret))[3] = MemStats::GetHighWater();
-        }
-      }
-    }
-
-    return ret;
-  }
-
-  inline DByte StrCmp( const string& s1, const string& s2, DLong n)
-  {
-    if( n <= 0) return 1;
-    if( s1.substr(0,n) == s2.substr(0,n)) return 1;
-    return 0;
-  }
-  inline DByte StrCmp( const string& s1, const string& s2)
-  {
-    if( s1 == s2) return 1;
-    return 0;
-  }
-  inline DByte StrCmpFold( const string& s1, const string& s2, DLong n)
-  {
-    if( n <= 0) return 1;
-    if( StrUpCase( s1.substr(0,n)) == StrUpCase(s2.substr(0,n))) return 1;
-    return 0;
-  }
-  inline DByte StrCmpFold( const string& s1, const string& s2)
-  {
-    if( StrUpCase( s1) == StrUpCase(s2)) return 1;
-    return 0;
-  }
-
-  BaseGDL* strcmp_fun( EnvT* e)
-  {
-    SizeT nParam=e->NParam(2);
-
-    DStringGDL* s0 = static_cast<DStringGDL*>( e->GetParAs< DStringGDL>( 0));
-    DStringGDL* s1 = static_cast<DStringGDL*>( e->GetParAs< DStringGDL>( 1));
-
-    DLongGDL* l2 = NULL;
-    if( nParam > 2)
-      {
-	l2 = static_cast<DLongGDL*>( e->GetParAs< DLongGDL>( 2));
-      }
-
-    static int foldIx = e->KeywordIx( "FOLD_CASE");
-    bool fold = e->KeywordSet( foldIx );
-    
-    if( s0->Scalar() && s1->Scalar())
-      {
-	if( l2 == NULL)
-	  {
-	    if( fold)
-	      return new DByteGDL( StrCmpFold( (*s0)[0], (*s1)[0]));
-	    else
-	      return new DByteGDL( StrCmp( (*s0)[0], (*s1)[0]));
-	  }
-	else
-	  {
-	    DByteGDL* res = new DByteGDL( l2->Dim(), BaseGDL::NOZERO);
-	    SizeT nEl = l2->N_Elements();
-	    if( fold)
-	      for( SizeT i=0; i<nEl; ++i)
-		(*res)[i] = StrCmpFold( (*s0)[0], (*s1)[0], (*l2)[i]);
-	    else
-	      for( SizeT i=0; i<nEl; ++i)
-		(*res)[i] = StrCmp( (*s0)[0], (*s1)[0], (*l2)[i]);
-	    return res;
-	  }
-      }
-    else // at least one array
-      {
-	if( l2 == NULL)
-	  {
-	    if( s0->Scalar())
-	      {
-		DByteGDL* res = new DByteGDL( s1->Dim(), BaseGDL::NOZERO);
-		SizeT nEl = s1->N_Elements();
-		if( fold)
-		  for( SizeT i=0; i<nEl; ++i)
-		    (*res)[i] = StrCmpFold( (*s0)[0], (*s1)[i]);
-		else
-		  for( SizeT i=0; i<nEl; ++i)
-		    (*res)[i] = StrCmp( (*s0)[0], (*s1)[i]);
-		return res;
-	      }
-	    else if( s1->Scalar())
-	      {
-		DByteGDL* res = new DByteGDL( s0->Dim(), BaseGDL::NOZERO);
-		SizeT nEl = s0->N_Elements();
-		if( fold)
-		  for( SizeT i=0; i<nEl; ++i)
-		    (*res)[i] = StrCmpFold( (*s0)[i], (*s1)[0]);
-		else
-		  for( SizeT i=0; i<nEl; ++i)
-		    (*res)[i] = StrCmp( (*s0)[i], (*s1)[0]);
-		return res;
-	      }
-	    else // both arrays
-	      {
-		DByteGDL* res;
-		SizeT    nEl;
-		if( s0->N_Elements() <= s1->N_Elements())
-		  {
-		    res = new DByteGDL( s0->Dim(), BaseGDL::NOZERO);
-		    nEl = s0->N_Elements();
-		  }
-		else		      
-		  {
-		    res = new DByteGDL( s1->Dim(), BaseGDL::NOZERO);
-		    nEl = s1->N_Elements();
-		  }
-		if( fold)
-		  for( SizeT i=0; i<nEl; ++i)
-		    (*res)[i] = StrCmpFold( (*s0)[i], (*s1)[i]);
-		else
-		  for( SizeT i=0; i<nEl; ++i)
-		    (*res)[i] = StrCmp( (*s0)[i], (*s1)[i]);
-		return res;
-	      }
-	  }
-	else // l2 != NULL
-	  {
-	    DByteGDL* res;
-	    SizeT    nEl;
-	    bool l2Scalar = l2->Scalar();
-	    if( s0->Scalar())
-	      {
-		if( l2Scalar || s1->N_Elements() <= l2->N_Elements())
-		  {
-		    res = new DByteGDL( s1->Dim(), BaseGDL::NOZERO);
-		    nEl = s1->N_Elements();
-		  }
-		else
-		  {
-		    res = new DByteGDL( l2->Dim(), BaseGDL::NOZERO);
-		    nEl = l2->N_Elements();
-		  }
-		if( fold)
-		  for( SizeT i=0; i<nEl; ++i)
-		    (*res)[i] = StrCmpFold( (*s0)[0], (*s1)[i], (*l2)[l2Scalar?0:i]);
-		else
-		  for( SizeT i=0; i<nEl; ++i)
-		    (*res)[i] = StrCmp( (*s0)[0], (*s1)[i], (*l2)[l2Scalar?0:i]);
-		return res;
-	      }
-	    else if( s1->Scalar())
-	      {
-		if( l2Scalar || s0->N_Elements() <= l2->N_Elements())
-		  {
-		    res = new DByteGDL( s0->Dim(), BaseGDL::NOZERO);
-		    nEl = s0->N_Elements();
-		  }
-		else
-		  {
-		    res = new DByteGDL( l2->Dim(), BaseGDL::NOZERO);
-		    nEl = l2->N_Elements();
-		  }
-		if( fold)
-		  for( SizeT i=0; i<nEl; ++i)
-		    (*res)[i] = StrCmpFold( (*s0)[i], (*s1)[0], (*l2)[l2Scalar?0:i]);
-		else
-		  for( SizeT i=0; i<nEl; ++i)
-		    (*res)[i] = StrCmp( (*s0)[i], (*s1)[0], (*l2)[l2Scalar?0:i]);
-		return res;
-	      }
-	    else // s1 and s2 are arrays
-	      {
-		if( l2Scalar)
-		  if( s0->N_Elements() <= s1->N_Elements())
-		    {
-		      res = new DByteGDL( s0->Dim(), BaseGDL::NOZERO);
-		      nEl = s0->N_Elements();
-		    }
-		  else 
-		    {
-		      res = new DByteGDL( s1->Dim(), BaseGDL::NOZERO);
-		      nEl = s1->N_Elements();
-		    }
-		else 
-		  {
-		    if( s0->N_Elements() <= s1->N_Elements())
-		      if( s0->N_Elements() <= l2->N_Elements())
-			{
-			  res = new DByteGDL( s0->Dim(), BaseGDL::NOZERO);
-			  nEl = s0->N_Elements();
-			}
-		      else
-			{
-			  res = new DByteGDL( l2->Dim(), BaseGDL::NOZERO);
-			  nEl = l2->N_Elements();
-			}
-		    else
-		      if( s1->N_Elements() <= l2->N_Elements())
-			{
-			  res = new DByteGDL( s1->Dim(), BaseGDL::NOZERO);
-			  nEl = s1->N_Elements();
-			}
-		      else
-			{
-			  res = new DByteGDL( l2->Dim(), BaseGDL::NOZERO);
-			  nEl = l2->N_Elements();
-			}
-		  }
-		if( fold)
-		  for( SizeT i=0; i<nEl; ++i)
-		    (*res)[i] = StrCmpFold( (*s0)[i], (*s1)[i], (*l2)[l2Scalar?0:i]);
-		else
-		  for( SizeT i=0; i<nEl; ++i)
-		    (*res)[i] = StrCmp( (*s0)[i], (*s1)[i], (*l2)[l2Scalar?0:i]);
-		return res;
-	      }
-	  }
-      }
-  }
-
-  string TagName( EnvT* e, const string& name)
-  {
-    string n = StrUpCase( name);
-    SizeT len = n.size();
-    if( n[0] != '_' && n[0] != '!' && (n[0] < 'A' || n[0] > 'Z'))
-      e->Throw( "Illegal tag name: "+name+".");
-    for( SizeT i=1; i<len; ++i)
-      {
-	if( n[i] == ' ')
-	  n[i] = '_';
-	else 
-	  if( n[i] != '_' && n[i] != '$' && //n[0] != '!' &&
-	      (n[i] < 'A' || n[i] > 'Z') &&
-	      (n[i] < '0' || n[i] > '9'))
-	    e->Throw( "Illegal tag name: "+name+".");
-      }
-    return n;
-  }
-
-  BaseGDL* create_struct( EnvT* e)
-  {
-    static int nameIx = e->KeywordIx( "NAME" );
-    DString name = "$truct";
-    if( e->KeywordPresent( nameIx)) {
-      // Check if name exists, if not then treat as unnamed
-      if (e->GetKW( nameIx) != NULL)
-	e->AssureStringScalarKW( nameIx, name);
-    }
-
-    if( name != "$truct") // named struct
-      {
-	name = StrUpCase( name);
-	
-	SizeT nParam=e->NParam();
-
-	if( nParam == 0)
-	  {
-	    DStructDesc* desc = 
-	      e->Interpreter()->GetStruct( name, e->CallingNode());
-	   
-	    dimension dim( 1);
-	    return new DStructGDL( desc, dim);
-	  }
-
-	DStructDesc*          nStructDesc;
-	auto_ptr<DStructDesc> nStructDescGuard;
-	
-	DStructDesc* oStructDesc=
-	  FindInStructList( structList, name);
-	
-	if( oStructDesc == NULL || oStructDesc->NTags() > 0)
-	  {
-	    // not defined at all yet (-> define now)
-	    // or completely defined  (-> define now and check equality)
-	    nStructDesc= new DStructDesc( name);
-                    
-	    // guard it
-	    nStructDescGuard.reset( nStructDesc); 
-	  }
-	else
-	  {   
-	    // NTags() == 0
-	    // not completely defined (only name in list)
-	    nStructDesc= oStructDesc;
-	  }
-                
-	// the instance variable
-	// 	dimension dim( 1);
-	// 	DStructGDL* instance = new DStructGDL( nStructDesc, dim);
-	DStructGDL* instance = new DStructGDL( nStructDesc);
-	auto_ptr<DStructGDL> instance_guard(instance);
-
-	for( SizeT p=0; p<nParam; ++p)
-	  {
-	    BaseGDL* par = e->GetParDefined( p);
-	    DStructGDL* parStruct = dynamic_cast<DStructGDL*>( par);
-	    if( parStruct != NULL)
-	      {
-		// add struct
-		if( !parStruct->Scalar())
-		  e->Throw("Expression must be a scalar in this context: "+
-			   e->GetParString( p));
-		
-		DStructDesc* desc = parStruct->Desc();
-		for( SizeT t=0; t< desc->NTags(); ++t)
-		  {
-		    instance->NewTag( desc->TagName( t), 
-				      parStruct->GetTag( t)->Dup());
-		  }
-	      }
-	    else
-	      {
-		// add tag value pair
-		DStringGDL* tagNames = e->GetParAs<DStringGDL>( p);
-		SizeT nTags = tagNames->N_Elements();
-
-		SizeT tagStart = p+1;
-		SizeT tagEnd   = p+nTags;
-		if( tagEnd >= nParam)
-		  e->Throw( "Incorrect number of arguments.");
-
-		do{
-		  ++p;
-		  BaseGDL* value = e->GetParDefined( p);
-		    
-		  // add 
-		  instance->NewTag( TagName( e, (*tagNames)[ p-tagStart]),
-				    value->Dup());
-		} 
-		while( p<tagEnd);
-	      }
-	  }
-
-	if( oStructDesc != NULL)
-	  {
-	    if( oStructDesc != nStructDesc)
-	      {
-		oStructDesc->AssureIdentical(nStructDesc);
-		instance->DStructGDL::SetDesc(oStructDesc);
-		//delete nStructDesc; // auto_ptr
-	      }
-	  }
-	else
-	  {
-	    // release from guard (if not NULL)
-	    nStructDescGuard.release();
-	    // insert into struct list 
-	    structList.push_back(nStructDesc);
-	  }
-	
-	instance_guard.release();
-	return instance;
-      }
-    else 
-      { // unnamed struc
-
-	// Handle case of single structure parameter
-	SizeT nParam;
-	nParam = e->NParam(1);
-	BaseGDL* par = e->GetParDefined( 0);
-	DStructGDL* parStruct = dynamic_cast<DStructGDL*>( par);
-	if (nParam != 1 || parStruct == NULL)
-	  nParam=e->NParam(2);
-
-	DStructDesc*          nStructDesc = new DStructDesc( "$truct");
-	// instance takes care of nStructDesc since it is unnamed
-	// 	dimension dim( 1);
-	// 	DStructGDL* instance = new DStructGDL( nStructDesc, dim);
-	DStructGDL* instance = new DStructGDL( nStructDesc);
-	auto_ptr<DStructGDL> instance_guard(instance);
-
-	for( SizeT p=0; p<nParam;)
-	  {
-	    BaseGDL* par = e->GetParDefined( p);
-	    DStructGDL* parStruct = dynamic_cast<DStructGDL*>( par);
-	    if( parStruct != NULL)
-	      {
-		// add struct
-		if( !parStruct->Scalar())
-		  e->Throw("Expression must be a scalar in this context: "+
-			   e->GetParString( p));
-		
-		DStructDesc* desc = parStruct->Desc();
-		for( SizeT t=0; t< desc->NTags(); ++t)
-		  {
-		    instance->NewTag( desc->TagName( t), 
-				      parStruct->GetTag( t)->Dup());
-		  }
-		++p;
-	      }
-	    else
-	      {
-		// add tag value pair
-		DStringGDL* tagNames = e->GetParAs<DStringGDL>( p);
-		SizeT nTags = tagNames->N_Elements();
-
-		SizeT tagStart = p+1;
-		SizeT tagEnd   = p+nTags;
-		if( tagEnd >= nParam)
-		  e->Throw( "Incorrect number of arguments.");
-
-		for(++p; p<=tagEnd; ++p)
-		  {
-		    BaseGDL* value = e->GetParDefined( p);
-
-		    // add 
-		    instance->NewTag( TagName( e, (*tagNames)[ p-tagStart]),
-				      value->Dup());
-		  }
-	      }
-	  }
-	
-	instance_guard.release();
-	return instance;
-      }
-  }
-
-  BaseGDL* rotate( EnvT* e)
-  {
-    e->NParam(2);
-    BaseGDL* p0 = e->GetParDefined( 0);
-
-    if( p0->Rank() == 0)
-      e->Throw( "Expression must be an array in this context: " + e->GetParString( 0));
-
-    if( p0->Rank() != 1 && p0->Rank() != 2)
-      e->Throw( "Only 1 or 2 dimensions allowed: " + e->GetParString( 0));
-
-    if( p0->Type() == GDL_STRUCT)
-      e->Throw( "STRUCT expression not allowed in this context: "+
-		e->GetParString( 0));
-    
-    DLong dir;
-    e->AssureLongScalarPar( 1, dir);
-
-    return p0->Rotate( dir);
-  }
-
-  // SA: based on the code of rotate() (above)
-  BaseGDL* reverse( EnvT* e)
-  {
-    e->NParam(1);
-    BaseGDL* p0 = e->GetParDefined(0);
-    if (p0->Rank() == 0) return p0->Dup();
-
-    DLong dim = 1;
-    if (e->GetPar(1) != NULL) 
-      e->AssureLongScalarPar(1, dim);
-    if (p0->Rank() != 0 && (dim > p0->Rank() || dim < 1))
-      e->Throw("Subscript_index must be positive and less than or equal to number of dimensions.");
-
-    BaseGDL* ret;
-    // IDL doc states that OVERWRITE is ignored for one- or two-dim. arrays 
-    // but it seems to behave differently
-    // if (p0->Rank() > 2 && e->KeywordSet("OVERWRITE") && e->GlobalPar(0))
-    if (e->KeywordSet("OVERWRITE"))
-    {
-      p0->Reverse(dim-1);
-      bool stolen = e->StealLocalPar( 0);
-      if( !stolen) e->GetPar(0) = NULL;
-      return p0;
-    }
-    else ret = p0->DupReverse(dim - 1);
-    return ret;
-  }
-
-  // SA: parse_url based on the PHP parse_url() function code
-  //     by Jim Winstead / The PHP Group (PHP license v. 3.01)
-  //     (http://svn.php.net/viewvc/php/php-src/trunk/ext/standard/url.c)
-  //     PHP is free software available at http://www.php.net/software/
-  //
-  //     notes: 
-  //     - IDL does not support IPv6 URLs, GDL does 
-  //     - IDL includes characters after '#' in the QUERY part, GDL
-  //       just skips them and issues a warning (perhaps not needed)
-  //     - IDL preserves controll characters in URLs, GDL preserves
-  //       them as well but a warning is issued
-  //     - IDL sets 80 as a default value for PORT, even if the url has 
-  //       an ftp:// schema indicated - GDL does not have any default value
-  //     - IDL excludes the leading "/" from the path, GDL preserves it
-  //     ... these differences seem just rational for me but please do change
-  //         it if IDL-compatibility would be beneficial for any reason here
-
-  BaseGDL* parse_url(EnvT* env)
-  {
-    // sanity check for number of parameters
-    SizeT nParam = env->NParam();
-
-    // 1-nd argument : the url string
-    DString url; 
-    env->AssureScalarPar<DStringGDL>(0, url); 
-
-    // sanity check for controll characters
-    string::iterator it;
-    for (it = url.begin(); it < url.end(); it++) if (iscntrl(*it))
-    {
-      Warning("PARSE_URL: URL contains a control character");
-      break;
-    }
-
-    // creating the output anonymous structure
-    DStructDesc* urlstru_desc = new DStructDesc("$truct");
-    SpDString aString;
-    urlstru_desc->AddTag("SCHEME",   &aString);
-    static size_t ixSCHEME = 0;
-    urlstru_desc->AddTag("USERNAME", &aString);
-    urlstru_desc->AddTag("PASSWORD", &aString);
-    urlstru_desc->AddTag("HOST",     &aString);
-    urlstru_desc->AddTag("PORT",     &aString);
-    static size_t ixPORT = 4;
-    urlstru_desc->AddTag("PATH",     &aString);
-    urlstru_desc->AddTag("QUERY",    &aString);
-    DStructGDL* urlstru = new DStructGDL(urlstru_desc, dimension());
-    auto_ptr<DStructGDL> urlstru_guard(urlstru);
-          
-    // parsing the URL
-    char const *str = url.c_str();
-    size_t length = url.length();
-    char port_buf[6];
-    char const *s, *e, *p, *pp, *ue;
-		
-    s = str;
-    ue = s + length;
-
-    // parsing scheme 
-    if ((e = (const char*)memchr(s, ':', length)) && (e - s)) 
-    {
-      // validating scheme 
-      p = s;
-      while (p < e) 
-      {
-        // scheme = 1*[ lowalpha | digit | "+" | "-" | "." ]
-        if (!isalpha(*p) && !isdigit(*p) && *p != '+' && *p != '.' && *p != '-') 
-        {
-          if (e + 1 < ue) goto parse_port;
-          else goto just_path;
-        }
-        p++;
-      }
-      if (*(e + 1) == '\0') 
-      { 
-        // only scheme is available 
-        urlstru->InitTag("SCHEME", DStringGDL(string(s, (e - s))));
-        goto end;
-      }
-      // schemas without '/' (like mailto: and zlib:) 
-      if (*(e+1) != '/') 
-      {
-        // check if the data we get is a port this allows us to correctly parse things like a.com:80
-        p = e + 1;
-        while (isdigit(*p)) p++;
-	if ((*p == '\0' || *p == '/') && (p - e) < 7) goto parse_port;
-        urlstru->InitTag("SCHEME", DStringGDL(string(s, (e - s))));
-        length -= ++e - s;
-        s = e;
-        goto just_path;
-      } 
-      else 
-      {
-        urlstru->InitTag("SCHEME", DStringGDL(string(s, (e - s))));
-        if (*(e+2) == '/') 
-        {
-          s = e + 3;
-          if (!strncasecmp("file", 
-            (*static_cast<DStringGDL*>(urlstru->GetTag(ixSCHEME)))[0].c_str(), 
-            sizeof("file")
-          )) 
-          {
-            if (*(e + 3) == '/') 
-            {
-              // support windows drive letters as in: file:///c:/somedir/file.txt
-              if (*(e + 5) == ':') s = e + 4;
-              goto nohost;
-            }
-          }
-        } 
-        else 
-        {
-          if (!strncasecmp("file", 
-            (*static_cast<DStringGDL*>(urlstru->GetTag(ixSCHEME)))[0].c_str(), 
-            sizeof("file"))
-          ) 
-          {
-            s = e + 1;
-            goto nohost;
-          } 
-          else 
-          {
-            length -= ++e - s;
-            s = e;
-            goto just_path;
-          }	
-        }
-      }	
-    } 
-    else if (e) 
-    { 
-      // no scheme, look for port 
-      parse_port:
-      p = e + 1;
-      pp = p;
-      while (pp-p < 6 && isdigit(*pp)) pp++;
-      if (pp-p < 6 && (*pp == '/' || *pp == '\0')) 
-      {
-        memcpy(port_buf, p, (pp-p));
-        port_buf[pp-p] = '\0';
-        urlstru->InitTag("PORT", DStringGDL(port_buf));
-      } 
-      else goto just_path;
-    } 
-    else 
-    {
-      just_path:
-      ue = s + length;
-      goto nohost;
-    }
-    e = ue;
-    if (!(p = (const char*)memchr(s, '/', (ue - s)))) 
-    {
-      if ((p = (const char*)memchr(s, '?', (ue - s)))) e = p;
-      else if ((p = (const char*)memchr(s, '#', (ue - s)))) e = p;
-    } 
-    else e = p;
-    // check for login and password 
-    {
-      size_t pos;
-      if ((pos = string(s, e - s).find_last_of("@")) != string::npos)
-      {
-        p = s + pos;
-        if ((pp = (const char*)memchr(s, ':', (p-s)))) 
-        {
-          if ((pp-s) > 0) urlstru->InitTag("USERNAME", DStringGDL(string(s, (pp - s))));
-          pp++;
-          if (p-pp > 0) urlstru->InitTag("PASSWORD", DStringGDL(string(pp, (p - pp))));
-        } 
-        else urlstru->InitTag("USERNAME", DStringGDL(string(s, (p - s))));
-        s = p + 1;
-      }
-    }
-    // check for port 
-    if (*s == '[' && *(e-1) == ']') p = s;     // IPv6 embedded address 
-    else for(p = e; *p != ':' && p >= s; p--); // memrchr is a GNU extension 
-    if (p >= s && *p == ':') 
-    {
-      if ((*static_cast<DStringGDL*>(urlstru->GetTag(ixPORT)))[0].length() == 0) 
-      {
-        p++;
-        if (e-p > 5) env->Throw("port cannot be longer then 5 characters");
-	else if (e - p > 0) 
-        {
-          memcpy(port_buf, p, (e-p));
-          port_buf[e-p] = '\0';
-          urlstru->InitTag("PORT", DStringGDL(port_buf));
-        }
-        p--;
-      }	
-    } 
-    else p = e;
-    // check if we have a valid host, if we don't reject the string as url 
-    if ((p-s) < 1) env->Throw("invalid host");
-    urlstru->InitTag("HOST", DStringGDL(string(s, (p - s))));
-    if (e == ue) goto end;
-    s = e;
-    nohost:
-    if ((p = (const char*)memchr(s, '?', (ue - s)))) 
-    {
-      pp = strchr(s, '#');
-      if (pp && pp < p) 
-      {
-        p = pp;
-        pp = strchr(pp+2, '#');
-      }
-      if (p - s) urlstru->InitTag("PATH", DStringGDL(string(s, (p - s))));
-      if (pp) 
-      {
-        if (pp - ++p) urlstru->InitTag("QUERY", DStringGDL(string(p, (pp - p))));
-        p = pp;
-        goto label_parse;
-      } 
-      else if (++p - ue) urlstru->InitTag("QUERY", DStringGDL(string(p, (ue - p))));
-    } 
-    else if ((p = (const char*)memchr(s, '#', (ue - s)))) 
-    {
-      if (p - s) urlstru->InitTag("PATH", DStringGDL(string(s, (p - s))));
-      label_parse:
-      p++;
-      if (ue - p) Warning("PARSE_URL: URL fragment left out: #" + string(p, (ue-p)));
-    } 
-    else urlstru->InitTag("PATH", DStringGDL(string(s, (ue - s))));
-    end:
-
-    // returning the result
-    urlstru_guard.release();
-    return urlstru;
-  }
-
-  BaseGDL* locale_get(EnvT* e)
-  {
-#ifdef HAVE_LOCALE_H
-
-    // make GDL inherit the calling process locale
-    setlocale(LC_ALL, "");
-    // note doen the inherited locale
-    DStringGDL *locale = new DStringGDL(setlocale(LC_CTYPE, NULL));
-    // return to the C locale
-    setlocale(LC_ALL, "C");
-
-    return locale;
-#else
-    e->Throw("OS does not provide locale information");
-#endif
-  }
-
-  // SA: relies on the contents of the lib::command_line_args vector
-  //     defined and filled with data (pointers) in gdl.cpp
-  BaseGDL* command_line_args_fun(EnvT* e)
-  {
-#ifdef PYTHON_MODULE
-    e->Throw("no command line arguments available (GDL built as a Python module)");
-#else
-    static int countIx = e->KeywordIx("COUNT");
-    extern std::vector<char*> command_line_args; 
-
-    // setting the COUNT keyword value
-    if (e->KeywordPresent(countIx))
-    {
-      e->AssureGlobalKW(countIx);
-      e->SetKW(countIx, new DLongGDL(command_line_args.size()));
-    }
-
-    // returning empty string or an array of arguments
-    if (command_line_args.empty()) return new DStringGDL("");
-    else
-    {
-      BaseGDL* ret = new DStringGDL(dimension(command_line_args.size()));   
-      for (size_t i = 0; i < command_line_args.size(); i++)
-        (*static_cast<DStringGDL*>(ret))[i] = command_line_args[i];
-      return ret;
-    }
-#endif
-  }
-
-  // SA: relies in the uname() from libc (must be there if POSIX)
-  BaseGDL* get_login_info( EnvT* e)
-  {
-    // getting the info 
-#ifdef _MSC_VER
-    #define MAX_TCHAR_BUF 256
-
-    char login[MAX_TCHAR_BUF];
-    char info[MAX_TCHAR_BUF];
-
-    DWORD N_TCHAR = MAX_TCHAR_BUF;
-
-    #ifdef _UNICODE
-    TCHAR t_buf[MAX_TCHAR_BUF];
-    GetUserName(t_buf, &N_TCHAR);
-    WideCharToMultiByte(CP_ACP, 0, t_buf, N_TCHAR, login, N_TCHAR, NULL, NULL);
-    GetComputerName( t_buf, &N_TCHAR );
-    WideCharToMultiByte(CP_ACP, 0, t_buf, N_TCHAR, info, N_TCHAR, NULL, NULL);
-    #else
-    GetUserName(login, &N_TCHAR);
-    GetComputerName(info, &N_TCHAR);
-    #endif
-#else
-    char* login = getlogin();
-    if (login == NULL) e->Throw("Failed to get user name from the OS"); 
-    struct utsname info;
-    if (0 != uname(&info)) e->Throw("Failed to get machine name from the OS");
-#endif
-    // creating the output anonymous structure
-    DStructDesc* stru_desc = new DStructDesc("$truct");
-    SpDString aString;
-    stru_desc->AddTag("MACHINE_NAME", &aString);
-    stru_desc->AddTag("USER_NAME", &aString);
-    DStructGDL* stru = new DStructGDL(stru_desc, dimension());
-
-    // returning the info 
-    stru->InitTag("USER_NAME", DStringGDL(login));
-#ifdef _MSC_VER
-    stru->InitTag("MACHINE_NAME", DStringGDL(info));
-#else
-    stru->InitTag("MACHINE_NAME", DStringGDL(info.nodename));
-#endif
-    return stru;
-  }
-
-  // SA: base64 logic in base64.hpp, based on code by Bob Withers (consult base64.hpp)
-  BaseGDL* idl_base64(EnvT* e)
-  {
-    BaseGDL* p0 = e->GetPar(0);    
-    if (p0 != NULL)
-    { 
-      if (p0->Rank() == 0 && p0->Type() == GDL_STRING)
-      {
-        // decoding
-        string* str = &((*static_cast<DStringGDL*>(p0))[0]);
-        if (str->length() == 0) return new DByteGDL(0);
-        if (str->length() % 4 != 0) 
-          e->Throw("Input string length must be a multiple of 4");
-        unsigned int retlen = base64::decodeSize(*str);
-        if (retlen == 0 || retlen > str->length()) e->Throw("No data in the input string");
-        DByteGDL* ret = new DByteGDL(dimension(retlen));
-        if (!base64::decode(*str, (char*)&((*ret)[0]), ret->N_Elements()))
-          e->Throw("Base64 decoder failed"); 
-        return ret;
-      }
-      if (p0->Rank() >= 1 && p0->Type() == GDL_BYTE)
-      {
-        // encoding
-        return new DStringGDL(
-          base64::encode((char*)&(*static_cast<DByteGDL*>(p0))[0], p0->N_Elements())
-        );
-      } 
-    }
-    e->Throw("Expecting string or byte array as a first parameter");
-  }
-
-  BaseGDL* get_drive_list(EnvT* e)
-  {
-    if (e->KeywordPresent(0)) e->SetKW(0, new DLongGDL(0));
-    return new DStringGDL("");
-  }
-
-  // note: changes here MUST be reflected in scope_varfetch_reference() as well
-  // because DLibFun of this function is used for scope_varfetch_reference() the keyword
-  // indices must match
-  BaseGDL* scope_varfetch_value( EnvT* e) 
-  {
-    SizeT nParam=e->NParam();
-
-    EnvStackT& callStack = e->Interpreter()->CallStack();
-//     DLong curlevnum = callStack.size()-1;
-// 'e' is not on the stack
-    DLong curlevnum = callStack.size();
-
-//     static int variablesIx = e->KeywordIx( "VARIABLES" );
-    static int levelIx = e->KeywordIx( "LEVEL" );
-
-    DLongGDL* level = e->IfDefGetKWAs<DLongGDL>( levelIx);
-
-    DLong desiredlevnum = 0;
-      
-    if (level != NULL)
-      desiredlevnum = (*level)[0];
-
-    if (desiredlevnum <= 0) desiredlevnum += curlevnum;
-    if (desiredlevnum < 1) desiredlevnum = 1;
-    else if (desiredlevnum > curlevnum) desiredlevnum = curlevnum;
-
-    DSubUD* pro = static_cast<DSubUD*>(callStack[desiredlevnum-1]->GetPro());
-
-    SizeT nVar = pro->Size(); // # var in GDL for desired level 
-    int nKey = pro->NKey();
-
-    DString varName;
-
-    e->AssureScalarPar<DStringGDL>( 0, varName);
-    varName = StrUpCase( varName);
-
-    int xI = pro->FindVar( varName);
-    if (xI != -1) 
-    {
-//       BaseGDL*& par = ((EnvT*)(callStack[desiredlevnum-1]))->GetPar( xI);
-      BaseGDL*& par = callStack[desiredlevnum-1]->GetKW( xI);
-
-      if( par == NULL)
-	e->Throw( "Variable is undefined: " + varName);
-
-      return par->Dup();
-    }
-	
-    e->Throw( "Variable not found: " + varName);
-    return new DLongGDL(0); // compiler shut-up
-  }
-
-  // this routine is special, only called as an l-function (from FCALL_LIB::LEval())
-  // it MUST use an EnvT set up for scope_varfetch_value
-  BaseGDL** scope_varfetch_reference( EnvT* e) 
-  {
-    SizeT nParam=e->NParam();
-
-    EnvStackT& callStack = e->Interpreter()->CallStack();
-//     DLong curlevnum = callStack.size()-1;
-// 'e' is not on the stack
-    DLong curlevnum = callStack.size();
-
-//     static int variablesIx = e->KeywordIx( "VARIABLES" );
-    static int levelIx = e->KeywordIx( "LEVEL" );
-
-    DLongGDL* level = e->IfDefGetKWAs<DLongGDL>( levelIx);
-
-    DLong desiredlevnum = 0;
-      
-    if (level != NULL)
-      desiredlevnum = (*level)[0];
-
-    if (desiredlevnum <= 0) desiredlevnum += curlevnum;
-    if (desiredlevnum < 1) desiredlevnum = 1;
-    else if (desiredlevnum > curlevnum) desiredlevnum = curlevnum;
-
-    DSubUD* pro = static_cast<DSubUD*>(callStack[desiredlevnum-1]->GetPro());
-
-    SizeT nVar = pro->Size(); // # var in GDL for desired level 
-    int nKey = pro->NKey();
-
-    DString varName;
-
-    e->AssureScalarPar<DStringGDL>( 0, varName);
-    varName = StrUpCase( varName);
-    int xI = pro->FindVar( varName);
-    if (xI != -1) 
-    {
-//       BaseGDL*& par = ((EnvT*)(callStack[desiredlevnum-1]))->GetPar( xI);
-      BaseGDL*& par = callStack[desiredlevnum-1]->GetKW( xI);
-
-//       if( par == NULL)
-// 	e->Throw( "Variable is undefined: " + varName);
-
-      return &par;
-    }
-	
-    e->Throw( "LVariable not found: " + varName);
-    return NULL; // compiler shut-up
-  }
-  
-
-} // namespace
-
+/***************************************************************************
+                          basic_fun.cpp  -  basic GDL library function
+                             -------------------
+    begin                : July 22 2002
+    copyright            : (C) 2002 by Marc Schellens (exceptions see below)
+    email                : m_schellens@users.sf.net
+
+ strtok_fun, getenv_fun, tag_names_fun, stregex_fun:
+ (C) 2004 by Peter Messmer    
+ 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "includefirst.hpp"
+
+// get_kbrd patch
+// http://sourceforge.net/forum/forum.php?thread_id=3292183&forum_id=338691
+#ifndef _MSC_VER
+#include <termios.h> 
+#include <unistd.h> 
+#endif
+#include <limits>
+#include <string>
+#include <fstream>
+//#include <memory>
+#include <regex.h> // stregex
+
+#ifdef __APPLE__
+# include <crt_externs.h>
+# define environ (*_NSGetEnviron())
+#endif
+
+#if defined(__FreeBSD__) || defined(__sun__) || defined(__OpenBSD__)
+extern "C" char **environ;
+#endif
+
+#include "nullgdl.hpp"
+#include "datatypes.hpp"
+#include "envt.hpp"
+#include "dpro.hpp"
+#include "dinterpreter.hpp"
+#include "basic_pro.hpp"
+#include "terminfo.hpp"
+#include "typedefs.hpp"
+#include "base64.hpp"
+
+#ifdef HAVE_LOCALE_H
+# include <locale.h>
+#endif
+
+/* max regexp error message length */
+#define MAX_REGEXPERR_LENGTH 80
+
+#ifdef _MSC_VER
+#define isfinite _finite
+#define isnan _isnan
+#define round(f) floor(f+0.5)
+int strncasecmp(const char *s1, const char *s2, size_t n)
+{
+  if (n == 0)
+    return 0;
+  while (n-- != 0 && tolower(*s1) == tolower(*s2))
+    {
+      if (n == 0 || *s1 == '\0' || *s2 == '\0')
+    break;
+      s1++;
+      s2++;
+    }
+
+  return tolower(*(unsigned char *) s1) - tolower(*(unsigned char *) s2);
+}
+#else
+#include <sys/utsname.h>
+#endif
+
+namespace lib {
+
+//  using namespace std;
+  using std::isnan;
+  using namespace antlr;
+
+  // assumes all parameters from pOffs till end are dim
+  void arr( EnvT* e, dimension& dim, SizeT pOffs=0)
+  {
+
+    int nParam=e->NParam()-pOffs;
+
+    if( nParam <= 0)
+      e->Throw( "Incorrect number of arguments.");
+
+    const string BadDims="Array dimensions must be greater than 0.";
+
+
+    if( nParam == 1 ) {
+
+      BaseGDL* par = e->GetParDefined( pOffs); 
+ 	
+      SizeT newDim;
+      int ret = par->Scalar2Index( newDim);
+
+      if (ret < 0) throw GDLException(BadDims);
+
+      if( ret > 0) {  // single argument
+	if (newDim < 1) throw GDLException(BadDims);
+	dim << newDim;
+	return;
+      } 
+      if( ret == 0) { //  array argument
+	DLongGDL* ind = 
+	  static_cast<DLongGDL*>(par->Convert2(GDL_LONG, BaseGDL::COPY)); 	 
+	Guard<DLongGDL> ind_guard( ind);
+		    //e->Guard( ind);
+
+	for(SizeT i =0; i < par->N_Elements(); ++i){
+	  if  ((*ind)[i] < 1) throw GDLException(BadDims);
+	  dim << (*ind)[i];
+	}
+	return;
+      }
+      e->Throw( "arr: should never arrive here.");	
+      return;
+    }
+
+    // max number checked in interpreter
+    SizeT endIx=nParam+pOffs;
+    for( SizeT i=pOffs; i<endIx; i++)
+      {
+	BaseGDL* par=e->GetParDefined( i);
+
+	SizeT newDim;
+	int ret=par->Scalar2Index( newDim);
+	if( ret < 1 || newDim == 0) throw GDLException(BadDims);
+	dim << newDim;
+      }
+  }
+
+  BaseGDL* bytarr( EnvT* e)
+  {
+    dimension dim;
+//    try{
+      arr( e, dim);
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DByteGDL(dim, BaseGDL::NOZERO);
+      return new DByteGDL(dim);
+ //   }
+ //   catch( GDLException& ex)
+ //     {
+//	e->Throw( ex.getMessage());
+//      }
+  }
+  BaseGDL* intarr( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DIntGDL(dim, BaseGDL::NOZERO);
+      return new DIntGDL(dim);
+//     }
+//     catch( GDLException& ex)
+//       {
+// 	e->Throw( "INTARR: "+ex.getMessage());
+//       }
+  }
+  BaseGDL* uintarr( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DUIntGDL(dim, BaseGDL::NOZERO);
+      return new DUIntGDL(dim);
+//     }
+//     catch( GDLException& ex)
+//       {
+// 	e->Throw( "UINTARR: "+ex.getMessage());
+//       }
+  }
+  BaseGDL* lonarr( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DLongGDL(dim, BaseGDL::NOZERO);
+      return new DLongGDL(dim);
+/*    }
+    catch( GDLException& ex)
+      {
+	e->Throw( "LONARR: "+ex.getMessage());
+      }*/
+  }
+  BaseGDL* ulonarr( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DULongGDL(dim, BaseGDL::NOZERO);
+      return new DULongGDL(dim);
+ /*   }
+    catch( GDLException& ex)
+      {
+	e->Throw( "ULONARR: "+ex.getMessage());
+      }
+ */ 
+}
+  BaseGDL* lon64arr( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DLong64GDL(dim, BaseGDL::NOZERO);
+      return new DLong64GDL(dim);
+/*    }
+    catch( GDLException& ex)
+      {
+	e->Throw( "LON64ARR: "+ex.getMessage());
+      }*/
+  }
+  BaseGDL* ulon64arr( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DULong64GDL(dim, BaseGDL::NOZERO);
+      return new DULong64GDL(dim);
+/*  }
+    catch( GDLException& ex)
+      {
+	e->Throw( "ULON64ARR: "+ex.getMessage());
+      }*/
+  }
+  BaseGDL* fltarr( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DFloatGDL(dim, BaseGDL::NOZERO);
+      return new DFloatGDL(dim);
+   /* }
+    catch( GDLException& ex)
+      {
+	e->Throw( "FLTARR: "+ex.getMessage());
+      }
+  */}
+  BaseGDL* dblarr( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DDoubleGDL(dim, BaseGDL::NOZERO);
+      return new DDoubleGDL(dim);
+   /* }
+    catch( GDLException& ex)
+      {
+	e->Throw( "DBLARR: "+ex.getMessage());
+      }*/
+  }
+  BaseGDL* strarr( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) 
+	e->Throw( "Keyword parameters not allowed in call.");
+      return new DStringGDL(dim);
+ /*   }
+    catch( GDLException& ex)
+      {
+	e->Throw( "STRARR: "+ex.getMessage());
+      }
+ */ }
+  BaseGDL* complexarr( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      if( e->KeywordSet(0)) return new DComplexGDL(dim, BaseGDL::NOZERO);
+      return new DComplexGDL(dim);
+    /*}
+    catch( GDLException& ex)
+      {
+	e->Throw( "COMPLEXARR: "+ex.getMessage());
+      }
+ */ }
+  BaseGDL* dcomplexarr( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+
+	if( e->KeywordSet(0)) return new DComplexDblGDL(dim, BaseGDL::NOZERO);
+      return new DComplexDblGDL(dim);
+ /*   }
+    catch( GDLException& ex)
+      {
+	e->Throw( "DCOMPLEXARR: "+ex.getMessage());
+      }
+ */ }
+  BaseGDL* ptrarr( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      DPtrGDL* ret;
+
+//       if( e->KeywordSet(0))
+// 	       ret= new DPtrGDL(dim);//, BaseGDL::NOZERO);
+//       else
+//     if( e->KeywordSet(1))
+// 	ret= new DPtrGDL(dim, BaseGDL::NOZERO);
+//       else
+// 	return new DPtrGDL(dim);
+    if( !e->KeywordSet(1))
+		return new DPtrGDL(dim);
+
+	ret= new DPtrGDL(dim, BaseGDL::NOZERO);
+
+	  SizeT nEl=ret->N_Elements();
+	  SizeT sIx=e->NewHeap(nEl);
+// #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+{
+// #pragma omp for
+	  for( SizeT i=0; i<nEl; i++)
+		(*ret)[i]=sIx+i;
+}
+      return ret;
+/*    }
+    catch( GDLException& ex)
+      {
+	e->Throw( "PTRARR: "+ex.getMessage());
+      }*/
+  }
+  BaseGDL* objarr( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+// reference counting      if( e->KeywordSet(0)) return new DObjGDL(dim, BaseGDL::NOZERO);
+      return new DObjGDL(dim);
+  /*  }
+    catch( GDLException& ex)
+      {
+	e->Throw( "OBJARR: "+ex.getMessage());
+      }
+ */ }
+
+  BaseGDL* ptr_new( EnvT* e)
+  {
+    int nParam=e->NParam();
+    
+    if( nParam > 0)
+      {
+	// new ptr from undefined variable is allowed as well
+	BaseGDL* p= e->GetPar( 0);
+        if( p == NULL)
+	  {
+	    DPtr heapID= e->NewHeap();
+	    return new DPtrGDL( heapID);
+	  }
+
+	if( e->KeywordSet(0)) // NO_COPY
+	  {
+	    BaseGDL** p= &e->GetPar( 0);
+	    // 	    if( *p == NULL)
+	    // 	      e->Throw( "Parameter undefined: "+
+	    // 				  e->GetParString(0));
+
+	    DPtr heapID= e->NewHeap( 1, *p);
+	    *p=NULL;
+	    return new DPtrGDL( heapID);
+	  }
+	else
+	  {
+	    BaseGDL* p= e->GetParDefined( 0);
+
+	    DPtr heapID= e->NewHeap( 1, p->Dup());
+	    return new DPtrGDL( heapID);
+	  }
+      }
+    else
+      {
+	if( e->KeywordSet(1)) // ALLOCATE_HEAP
+	  {
+	    DPtr heapID= e->NewHeap();
+	    return new DPtrGDL( heapID);
+	  }
+	else
+	  {
+	    return new DPtrGDL( 0); // null ptr
+	  }
+      }
+  }
+
+  BaseGDL* ptr_valid( EnvT* e)
+  {
+    int nParam=e->NParam();
+    
+    if( e->KeywordPresent( 1)) // COUNT
+      {
+	e->SetKW( 1, new DLongGDL( e->Interpreter()->HeapSize()));
+      }
+
+    if( nParam == 0)
+      {
+	return e->Interpreter()->GetAllHeap();
+      } 
+
+    BaseGDL* p = e->GetPar( 0);
+    if( p == NULL)
+      {
+	return new DByteGDL( 0);
+      } 
+
+    if( e->KeywordSet( 0)) // CAST
+      {
+	DLongGDL* pL = dynamic_cast<DLongGDL*>( p);
+	Guard<DLongGDL> pL_guard;
+	if( pL == NULL)
+	  {
+	    pL = static_cast<DLongGDL*>(p->Convert2(GDL_LONG,BaseGDL::COPY)); 
+	    pL_guard.Reset( pL);
+	  }
+	
+	SizeT nEl = pL->N_Elements();
+	DPtrGDL* ret = new DPtrGDL( pL->Dim()); // zero
+	GDLInterpreter* interpreter = e->Interpreter();
+	for( SizeT i=0; i<nEl; ++i)
+	  {
+	    if( interpreter->PtrValid( (*pL)[ i])) 
+	      (*ret)[ i] = (*pL)[ i];
+	  }
+	return ret;
+      }
+
+    DPtrGDL* pPtr = dynamic_cast<DPtrGDL*>( p);
+    if( pPtr == NULL)
+      {
+	return new DByteGDL( p->Dim()); // zero
+      }
+
+    SizeT nEl = pPtr->N_Elements();
+    DByteGDL* ret = new DByteGDL( pPtr->Dim()); // zero
+    GDLInterpreter* interpreter = e->Interpreter();
+    for( SizeT i=0; i<nEl; ++i)
+      {
+	if( interpreter->PtrValid( (*pPtr)[ i])) 
+	  (*ret)[ i] = 1;
+      }
+    return ret;
+  }
+
+  BaseGDL* obj_valid( EnvT* e)
+  {
+    int nParam=e->NParam();
+    
+    if( e->KeywordPresent( 1)) // COUNT
+      {
+	e->SetKW( 1, new DLongGDL( e->Interpreter()->ObjHeapSize()));
+      }
+
+    if( nParam == 0)
+      {
+	return e->Interpreter()->GetAllObjHeap();
+      } 
+
+    BaseGDL* p = e->GetPar( 0);
+    if( p == NULL)
+      {
+	return new DByteGDL( 0);
+      } 
+
+    if( e->KeywordSet( 0)) // CAST
+      {
+	DLongGDL* pL = dynamic_cast<DLongGDL*>( p);
+	Guard<DLongGDL> pL_guard;
+	if( pL == NULL)
+	  {
+	    pL = static_cast<DLongGDL*>(p->Convert2(GDL_LONG,BaseGDL::COPY));
+	    pL_guard.Reset( pL);
+	    //	    e->Guard( pL);
+	  }
+	
+	SizeT nEl = pL->N_Elements();
+	DObjGDL* ret = new DObjGDL( pL->Dim()); // zero
+	GDLInterpreter* interpreter = e->Interpreter();
+	for( SizeT i=0; i<nEl; ++i)
+	  {
+	    if( interpreter->ObjValid( (*pL)[ i])) 
+	      (*ret)[ i] = (*pL)[ i];
+	  }
+	return ret;
+      }
+
+    DObjGDL* pObj = dynamic_cast<DObjGDL*>( p);
+    if( pObj == NULL)
+      {
+	return new DByteGDL( p->Dim()); // zero
+      }
+
+    SizeT nEl = pObj->N_Elements();
+    DByteGDL* ret = new DByteGDL( pObj->Dim()); // zero
+    GDLInterpreter* interpreter = e->Interpreter();
+    for( SizeT i=0; i<nEl; ++i)
+      {
+	if( interpreter->ObjValid( (*pObj)[ i])) 
+	  (*ret)[ i] = 1;
+      }
+    return ret;
+  }
+
+  BaseGDL* obj_new( EnvT* e)
+  {
+    StackGuard<EnvStackT> guard( e->Interpreter()->CallStack());
+    
+    int nParam=e->NParam();
+    
+    if( nParam == 0)
+      {
+	return new DObjGDL( 0);
+      }
+    
+    DString objName;
+    e->AssureScalarPar<DStringGDL>( 0, objName);
+
+    // this is a struct name -> convert to UPPERCASE
+    objName=StrUpCase(objName);
+    if( objName == "IDL_OBJECT")
+      objName = GDL_OBJECT_NAME; // replacement also done in GDLParser
+
+    DStructDesc* objDesc=e->Interpreter()->GetStruct( objName, e->CallingNode());
+
+    DStructGDL* objStruct= new DStructGDL( objDesc, dimension());
+
+    DObj objID= e->NewObjHeap( 1, objStruct); // owns objStruct
+
+    BaseGDL* newObj = new DObjGDL( objID); // the object
+
+    try {
+      // call INIT function
+      DFun* objINIT= objDesc->GetFun( "INIT");
+      if( objINIT != NULL)
+	{
+	  // morph to obj environment and push it onto the stack again
+	  e->PushNewEnvUD( objINIT, 1, &newObj);
+	
+	  BaseGDL* res=e->Interpreter()->call_fun( objINIT->GetTree());
+	
+	  if( res == NULL || (!res->Scalar()) || res->False())
+	    {
+	      GDLDelete(res);
+	      return new DObjGDL( 0);
+	    }
+	  GDLDelete(res);
+	}
+    } catch(...) {
+      e->FreeObjHeap( objID); // newObj might be changed
+      GDLDelete(newObj);
+      throw;
+    }
+
+    return newObj;
+  }
+
+  BaseGDL* bindgen( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DByteGDL(dim, BaseGDL::INDGEN);
+   /* }
+    catch( GDLException& ex)
+      {
+	e->Throw( "BINDGEN: "+ex.getMessage());
+      }
+ */ }
+  // keywords not supported yet
+  BaseGDL* indgen( EnvT* e)
+  {
+    dimension dim;
+
+    // Defaulting to GDL_INT
+    DType type = GDL_INT;
+
+    static int kwIx1 = e->KeywordIx("BYTE");
+    if (e->KeywordSet(kwIx1)){ type = GDL_BYTE; }
+
+    static int kwIx2 = e->KeywordIx("COMPLEX");
+    if (e->KeywordSet(kwIx2)){ type = GDL_COMPLEX; }
+    
+    static int kwIx3 = e->KeywordIx("DCOMPLEX");
+    if (e->KeywordSet(kwIx3)){ type = GDL_COMPLEXDBL; }
+
+    static int kwIx4 = e->KeywordIx("DOUBLE");
+    if (e->KeywordSet(kwIx4)){ type = GDL_DOUBLE; }
+
+    static int kwIx5 = e->KeywordIx("FLOAT");
+    if (e->KeywordSet(kwIx5)){ type = GDL_FLOAT; }
+    
+    static int kwIx6 = e->KeywordIx("L64");
+    if (e->KeywordSet(kwIx6)){ type = GDL_LONG64; }
+
+    static int kwIx7 = e->KeywordIx("LONG");
+    if (e->KeywordSet(kwIx7)){ type = GDL_LONG; }
+
+    static int kwIx8 = e->KeywordIx("STRING");
+    if (e->KeywordSet(kwIx8)){ type = GDL_STRING; }
+
+    static int kwIx9 = e->KeywordIx("UINT");
+    if (e->KeywordSet(kwIx9)){ type = GDL_UINT; }
+
+    static int kwIx10 = e->KeywordIx("UL64");
+    if (e->KeywordSet(kwIx10)){ type = GDL_ULONG64; }
+
+    static int kwIx11 = e->KeywordIx("ULONG");
+    if (e->KeywordSet(kwIx11)){ type = GDL_ULONG; }
+    
+    /*try
+      {*/
+	// Seeing if the user passed in a TYPE code
+	static int kwIx12 = e->KeywordIx("TYPE");
+	if ( e->KeywordPresent(kwIx12)){
+	  DLong temp_long;
+	  e->AssureLongScalarKW(kwIx12, temp_long);
+	  type = static_cast<DType>(temp_long);
+	}
+
+	arr(e, dim);
+	if (dim[0] == 0)
+	  throw GDLException( "Array dimensions must be greater than 0");
+
+	switch(type)
+	  {
+	  case GDL_INT:        return new DIntGDL(dim, BaseGDL::INDGEN);
+	  case GDL_BYTE:       return new DByteGDL(dim, BaseGDL::INDGEN);
+	  case GDL_COMPLEX:    return new DComplexGDL(dim, BaseGDL::INDGEN);
+	  case GDL_COMPLEXDBL: return new DComplexDblGDL(dim, BaseGDL::INDGEN);
+	  case GDL_DOUBLE:     return new DDoubleGDL(dim, BaseGDL::INDGEN);
+	  case GDL_FLOAT:      return new DFloatGDL(dim, BaseGDL::INDGEN);
+	  case GDL_LONG64:     return new DLong64GDL(dim, BaseGDL::INDGEN);
+	  case GDL_LONG:       return new DLongGDL(dim, BaseGDL::INDGEN);
+	  case GDL_STRING: {
+	    DULongGDL* iGen = new DULongGDL(dim, BaseGDL::INDGEN);
+	    return iGen->Convert2(GDL_STRING);
+	  }
+	  case GDL_UINT:       return new DUIntGDL(dim, BaseGDL::INDGEN);
+	  case GDL_ULONG64:    return new DULong64GDL(dim, BaseGDL::INDGEN);
+	  case GDL_ULONG:      return new DULongGDL(dim, BaseGDL::INDGEN);
+	  default:
+	    e->Throw( "Invalid type code specified.");
+	    break;
+	  }
+/*      }
+    catch( GDLException& ex)
+      {
+	e->Throw( ex.getMessage());
+      }*/
+  }
+
+  BaseGDL* uindgen( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DUIntGDL(dim, BaseGDL::INDGEN);
+   /* }
+    catch( GDLException& ex)
+      {
+	e->Throw( "UINDGEN: "+ex.getMessage());
+      }
+ */ }
+  BaseGDL* sindgen( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      DULongGDL* iGen = new DULongGDL(dim, BaseGDL::INDGEN);
+      return iGen->Convert2( GDL_STRING);
+/*    }
+    catch( GDLException& ex)
+      {
+	e->Throw( "SINDGEN: "+ex.getMessage());
+      }*/
+  }
+  BaseGDL* lindgen( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      return new DLongGDL(dim, BaseGDL::INDGEN);
+/*    }
+    catch( GDLException& ex)
+      {
+	e->Throw( "LINDGEN: "+ex.getMessage());
+      }*/
+  }
+  BaseGDL* ulindgen( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DULongGDL(dim, BaseGDL::INDGEN);
+/*    }
+    catch( GDLException& ex)
+      {
+	e->Throw( "ULINDGEN: "+ex.getMessage());
+      }*/
+  }
+  BaseGDL* l64indgen( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DLong64GDL(dim, BaseGDL::INDGEN);
+  /*  }
+    catch( GDLException& ex)
+      {
+	e->Throw( "L64INDGEN: "+ex.getMessage());
+      }*/
+  }
+  BaseGDL* ul64indgen( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DULong64GDL(dim, BaseGDL::INDGEN);
+ /*   }
+    catch( GDLException& ex)
+      {
+	e->Throw( "UL64INDGEN: "+ex.getMessage());
+      }
+ */ }
+  BaseGDL* findgen( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DFloatGDL(dim, BaseGDL::INDGEN);
+  /*  }
+    catch( GDLException& ex)
+      {
+	e->Throw( "FINDGEN: "+ex.getMessage());
+      }*/
+  }
+  BaseGDL* dindgen( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DDoubleGDL(dim, BaseGDL::INDGEN);
+  /*  }
+    catch( GDLException& ex)
+      {
+	e->Throw( "DINDGEN: "+ex.getMessage());
+      }*/
+  }
+  BaseGDL* cindgen( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DComplexGDL(dim, BaseGDL::INDGEN);
+  /*  }
+    catch( GDLException& ex)
+      {
+	e->Throw( "CINDGEN: "+ex.getMessage());
+      }*/
+  }
+  BaseGDL* dcindgen( EnvT* e)
+  {
+    dimension dim;
+//     try{
+      arr( e, dim); 
+      if (dim[0] == 0)
+	throw GDLException( "Array dimensions must be greater than 0");
+
+      return new DComplexDblGDL(dim, BaseGDL::INDGEN);
+  /*  }
+    catch( GDLException& ex)
+      {
+	e->Throw( "DCINDGEN: "+ex.getMessage());
+      }
+ */ }
+
+  // only called from CALL_FUNCTION 
+  // otherwise done directly in FCALL_LIB_N_ELEMENTSNode::Eval();
+  // (but must be defined anyway for LibInit() for correct parametrization)
+  // N_ELEMENTS is special because on error it just returns 0L
+  // (the error is just caught and dropped)
+  BaseGDL* n_elements( EnvT* e)
+  {
+    SizeT nParam=e->NParam(1);
+
+    BaseGDL* p0=e->GetPar( 0);
+
+    if( p0 == NULL) return new DLongGDL( 0);
+    return new DLongGDL( p0->N_Elements()); 
+    
+//     assert( 0);
+//     e->Throw("Internal error: lib::n_elements called.");
+//     return NULL; // get rid of compiler warning
+  }
+
+  template< typename ComplexGDL, typename Complex, typename Float>
+  BaseGDL* complex_fun_template( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 1);
+    if( nParam <= 2)
+      {
+	if( nParam == 2)
+	  {
+	    BaseGDL* p0=e->GetParDefined( 0);
+	    BaseGDL* p1=e->GetParDefined( 1);
+
+	    Float* p0Float = static_cast<Float*>
+				     (p0->Convert2( Float::t,BaseGDL::COPY));
+	    Guard<Float> p0FloatGuard(p0Float);
+	    Float* p1Float = static_cast<Float*>
+				     (p1->Convert2( Float::t,BaseGDL::COPY));
+	    Guard<Float> p1FloatGuard(p1Float);
+	    if( p0Float->Rank() == 0)
+	      {
+		ComplexGDL* res = new ComplexGDL( p1Float->Dim(), 
+						  BaseGDL::NOZERO);
+		
+		SizeT nE=p1Float->N_Elements();
+// #pragma omp parallel if (nE >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nE))
+{
+// #pragma omp for
+		for( SizeT i=0; i<nE; i++)
+		  {
+		    (*res)[i]=Complex( (*p0Float)[0], (*p1Float)[i]);
+		  }
+}
+		return res;
+	      }
+	    else if( p1Float->Rank() == 0)
+	      {
+		ComplexGDL* res = new ComplexGDL( p0Float->Dim(), 
+						  BaseGDL::NOZERO);
+		
+		SizeT nE=p0Float->N_Elements();
+// #pragma omp parallel if (nE >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nE))
+{
+// #pragma omp for
+		for( SizeT i=0; i<nE; i++)
+		  {
+		    (*res)[i]=Complex( (*p0Float)[i], (*p1Float)[0]);
+		  }
+}
+		return res;
+	      }
+	    else if( p0Float->N_Elements() >= p1Float->N_Elements())
+	      {
+		ComplexGDL* res = new ComplexGDL( p1Float->Dim(), 
+						  BaseGDL::NOZERO);
+
+		SizeT nE=p1Float->N_Elements();
+// #pragma omp parallel if (nE >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nE))
+{
+// #pragma omp for
+		for( SizeT i=0; i<nE; i++)
+		  {
+		    (*res)[i]=Complex( (*p0Float)[i], (*p1Float)[i]);
+		  }
+}
+		return res;
+	      }
+	    else
+	      {
+		ComplexGDL* res = new ComplexGDL( p0Float->Dim(), 
+						  BaseGDL::NOZERO);
+		
+		SizeT nE=p0Float->N_Elements();
+// #pragma omp parallel if (nE >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nE))
+{
+// #pragma omp for
+		for( SizeT i=0; i<nE; i++)
+		  {
+		    (*res)[i]=Complex( (*p0Float)[i], (*p1Float)[i]);
+		  }
+}
+		return res;
+	      }
+	  }
+	else
+	  {
+            // SA: see tracker item 3151760 
+	    BaseGDL* p0 = e->GetParDefined( 0);
+            if (ComplexGDL::t == p0->Type() && e->GlobalPar(0)) return p0;
+	    return p0->Convert2( ComplexGDL::t, BaseGDL::COPY);
+	  }
+      }
+    else // COMPLEX( expr, offs, dim1,..,dim8)
+      {
+	BaseGDL* p0 = e->GetParDefined( 0);
+	// *** WRONG: with offs data is converted bytewise
+	Float* p0Float = static_cast<Float*>(p0->Convert2( Float::t,BaseGDL::COPY));
+	Guard<Float> p0FloatGuard(p0Float);
+
+	DLong offs;
+	e->AssureLongScalarPar( 1, offs);
+      
+	dimension dim;
+	arr( e, dim, 2);
+
+	SizeT nElCreate=dim.NDimElements();
+	
+	SizeT nElSource=p0->N_Elements();
+      
+	if( (offs+2*nElCreate) > nElSource)
+	  e->Throw( "Specified offset to"
+		    " array is out of range: "+e->GetParString(0));
+	
+	ComplexGDL* res=new ComplexGDL( dim, BaseGDL::NOZERO);
+
+// #pragma omp parallel if (nElCreate >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nElCreate))
+{
+// #pragma omp for
+	for( SizeT i=0; i<nElCreate; i++)
+	  {
+	    SizeT srcIx=2*i+offs;
+	    (*res)[i]=Complex( (*p0Float)[srcIx], (*p0Float)[srcIx+1]);
+	  }
+}	
+	return res;
+      }
+  }
+
+BaseGDL* complex_fun( EnvT* e)
+{
+  if (e->KeywordSet("DOUBLE")) {
+    return complex_fun_template< DComplexDblGDL, DComplexDbl, DDoubleGDL>( e);
+  } else {
+    return complex_fun_template< DComplexGDL, DComplex, DFloatGDL>( e);
+  }      
+}
+BaseGDL* dcomplex_fun( EnvT* e)
+{
+  return complex_fun_template< DComplexDblGDL, DComplexDbl, DDoubleGDL>( e);
+}
+
+  template< class TargetClass>
+  BaseGDL* type_fun( EnvT* e)
+  {
+    SizeT nParam=e->NParam(1);
+
+    if( nParam == 1)
+      {
+	BaseGDL* p0=e->GetParDefined( 0);
+
+	assert( dynamic_cast< EnvUDT*>( e->Caller()) != NULL);
+
+	// type_fun( expr) just convert
+	if( static_cast< EnvUDT*>( e->Caller())->GetIOError() != NULL) 
+	  return p0->Convert2( TargetClass::t, 
+			       BaseGDL::COPY_THROWIOERROR);
+        // SA: see tracker item no. 3151760 
+        else if (TargetClass::t == p0->Type() && e->GlobalPar(0)) 
+          return p0;
+	else
+	  return p0->Convert2( TargetClass::t, BaseGDL::COPY);
+      }
+    
+    BaseGDL* p0=e->GetNumericParDefined( 0);
+
+    // GDL_BYTE( expr, offs, dim1,..,dim8)
+    DLong offs;
+    e->AssureLongScalarPar( 1, offs);
+
+    dimension dim;
+
+    if( nParam > 2)
+      arr( e, dim, 2);
+    
+    TargetClass* res=new TargetClass( dim, BaseGDL::NOZERO);
+
+    SizeT nByteCreate=res->NBytes(); // net size of new data
+      
+    SizeT nByteSource=p0->NBytes(); // net size of src
+      
+    if( offs < 0 || (offs+nByteCreate) > nByteSource)
+      {
+	GDLDelete(res);
+	e->Throw( "Specified offset to"
+		  " expression is out of range: "+e->GetParString(0));
+      }
+
+    //*** POSSIBLE ERROR because of alignment here
+    void* srcAddr = static_cast<void*>( static_cast<char*>(p0->DataAddr()) + 
+					offs);
+    void* dstAddr = static_cast<void*>(&(*res)[0]);
+    memcpy( dstAddr, srcAddr, nByteCreate);
+
+    //     char* srcAddr = reinterpret_cast<char*>(p0->DataAddr());
+    //     char* dstAddr = reinterpret_cast<char*>(&(*res)[0]);
+    //     copy( srcAddr, srcAddr+nByteCreate, dstAddr);
+
+    return res;
+  }
+
+  BaseGDL* byte_fun( EnvT* e)
+  {
+    return type_fun<DByteGDL>( e);
+  }
+  BaseGDL* uint_fun( EnvT* e)
+  {
+    return type_fun<DUIntGDL>( e);
+  }
+  BaseGDL* long_fun( EnvT* e)
+  {
+    return type_fun<DLongGDL>( e);
+  }
+  BaseGDL* ulong_fun( EnvT* e)
+  {
+    return type_fun<DULongGDL>( e);
+  }
+  BaseGDL* long64_fun( EnvT* e)
+  {
+    return type_fun<DLong64GDL>( e);
+  }
+  BaseGDL* ulong64_fun( EnvT* e)
+  {
+    return type_fun<DULong64GDL>( e);
+  }
+  BaseGDL* float_fun( EnvT* e)
+  {
+    return type_fun<DFloatGDL>( e);
+  }
+  BaseGDL* double_fun( EnvT* e)
+  {
+    return type_fun<DDoubleGDL>( e);
+  }
+  // GDL_STRING function behaves different
+  BaseGDL* string_fun( EnvT* e)
+  {
+    SizeT nParam=e->NParam();
+
+    if( nParam == 0)
+      e->Throw( "Incorrect number of arguments.");
+
+    bool printKey =  e->KeywordSet( 4);
+    int parOffset = 0; 
+
+    // SA: handling special VMS-compatibility syntax, e.g.: string(1,'$(F)')
+    //     (if nor FORMAT neither PRINT defined, >1 parameter, last param is scalar string
+    //     which begins with "$(" or "(" but is not "()" then last param [minus "$"] is treated as FORMAT)
+    bool vmshack = false;
+    if (!printKey && (e->GetKW(0) == NULL) && nParam > 1) 
+    {    
+      vmshack = true;
+      BaseGDL* par = e->GetParDefined(nParam - 1);
+      if (par->Type() == GDL_STRING && par->Scalar())
+      {
+        int dollar = (*static_cast<DStringGDL*>(par))[0].compare(0,2,"$(");
+        if (dollar == 0 || ((*static_cast<DStringGDL*>(par))[0].compare(0,1,"(") == 0 && (*static_cast<DStringGDL*>(par))[0] != "()"))   
+        {    
+          e->SetKeyword("FORMAT", new DStringGDL(
+            (*static_cast<DStringGDL*>(par))[0].c_str() + (dollar == 0 ? 1 : 0) 
+          ));
+        }
+      }    
+    }    
+
+    BaseGDL* format_kw = e->GetKW( 0);
+    bool formatKey = format_kw != NULL;
+
+    if (formatKey && format_kw->Type() == GDL_STRING && (*static_cast<DStringGDL*>(format_kw))[0] == "") formatKey = false;
+
+    if( printKey || formatKey) // PRINT or FORMAT
+      {
+	stringstream os;
+
+	SizeT width = 0;
+	if( printKey) // otherwise: FORMAT -> width is ignored
+	  {
+	    // for /PRINT always a terminal width of 80 is assumed
+	    width = 80;//TermWidth();
+	  }
+	
+        if (vmshack)
+        {
+          parOffset = 1; 
+          e->ShiftParNumbering(1);
+        }
+	print_os( &os, e, parOffset, width);
+        if (vmshack) 
+        {
+          e->ShiftParNumbering(-1);
+	}
+
+	deque<DString> buf;
+	while( os.good())
+	  {
+	    string line;
+	    getline( os, line);
+	    if( os.good()) buf.push_back( line);
+	  }
+
+	SizeT bufSize = buf.size();
+	if( bufSize == 0)
+	  e->Throw( "Internal error: print buffer empty.");
+
+	if( bufSize > 1) 
+	  {
+	    DStringGDL* retVal = 
+	      new DStringGDL( dimension( bufSize), BaseGDL::NOZERO);
+
+	    for( SizeT i=0; i<bufSize; ++i)
+	      (*retVal)[ i] = buf[ i];
+
+	    return retVal;
+	  }
+	else
+	  return new DStringGDL( buf[0]);
+      }
+    else
+      {
+	if( nParam == 1) // nParam == 1 -> conversion
+	  {
+	    BaseGDL* p0 = e->GetParDefined( 0);
+            // SA: see tracker item no. 3151760 
+            if (p0->Type() == GDL_STRING && e->GlobalPar(0)) return p0;
+	    return p0->Convert2( GDL_STRING, BaseGDL::COPY);
+	  }
+	else // concatenation
+	  {
+	    DString s;
+	    for( SizeT i=0; i<nParam; ++i)
+	      {
+		BaseGDL* p = e->GetParDefined( i);
+		DStringGDL* sP = static_cast<DStringGDL*>
+		  ( p->Convert2(GDL_STRING,
+				BaseGDL::COPY_BYTE_AS_INT));
+
+		SizeT nEl = sP->N_Elements();
+		for( SizeT e=0; e<nEl; ++e)
+		  s += (*sP)[ e];
+		GDLDelete(sP);
+	      }
+	    // IDL here breaks the string into tty-width substrings
+	    return new DStringGDL( s);
+	  }
+      }
+  }
+
+  BaseGDL* fix_fun( EnvT* e)
+  {
+    DIntGDL* type = e->IfDefGetKWAs<DIntGDL>( 0);
+    if (type != NULL) {
+      int typ = (*type)[0];
+      if (typ == GDL_BYTE)
+      {
+        // SA: slow yet simple solution using GDL_BYTE->GDL_INT->GDL_BYTE conversion
+        return (e->KeywordSet(1) && e->GetPar(0)->Type() == GDL_STRING)
+          ? type_fun<DIntGDL>( e)->Convert2(GDL_BYTE, BaseGDL::CONVERT) 
+          : type_fun<DByteGDL>( e);
+      }
+      if (typ == 0 || typ == GDL_INT) return type_fun<DIntGDL>( e);
+      if (typ == GDL_UINT) return type_fun<DUIntGDL>( e);
+      if (typ == GDL_LONG) return type_fun<DLongGDL>( e);
+      if (typ == GDL_ULONG) return type_fun<DULongGDL>( e);
+      if (typ == GDL_LONG64) return type_fun<DLong64GDL>( e);
+      if (typ == GDL_ULONG64) return type_fun<DULong64GDL>( e);
+      if (typ == GDL_FLOAT) return type_fun<DFloatGDL>( e);
+      if (typ == GDL_DOUBLE) return type_fun<DDoubleGDL>( e);
+      if (typ == GDL_COMPLEX) return type_fun<DComplexGDL>( e);
+      if (typ == GDL_COMPLEXDBL) return type_fun<DComplexDblGDL>( e);
+      if (typ == GDL_STRING) 
+      {
+        // SA: calling GDL_STRING() with correct parameters
+        static int stringIx = LibFunIx("STRING");
+
+		assert( stringIx >= 0);
+		
+        EnvT* newEnv= new EnvT(e, libFunList[stringIx], NULL);
+
+		Guard<EnvT> guard( newEnv);
+
+		newEnv->SetNextPar(&e->GetPar(0)); // pass as global
+        if (e->KeywordSet(1) && e->GetPar(0)->Type() == GDL_BYTE)
+          newEnv->SetKeyword("PRINT", new DIntGDL(1));
+//         e->Interpreter()->CallStack().push_back( newEnv); 
+        return static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
+      }
+      e->Throw( "Improper TYPE value.");
+    }
+    return type_fun<DIntGDL>( e);
+  }
+
+  BaseGDL* call_function( EnvT* e)
+  {
+    int nParam=e->NParam();
+    if( nParam == 0)
+     e->Throw( "No function specified.");
+    
+    DString callF;
+    e->AssureScalarPar<DStringGDL>( 0, callF);
+
+    // this is a function name -> convert to UPPERCASE
+    callF = StrUpCase( callF);
+
+    // first search library funcedures
+    int funIx=LibFunIx( callF);
+    if( funIx != -1)
+      {
+// 	e->PushNewEnv( libFunList[ funIx], 1);
+	// make the call
+// 	EnvT* newEnv = static_cast<EnvT*>(e->Interpreter()->CallStack().back());
+
+	// handle direct call functions 
+	if( libFunList[ funIx]->DirectCall())
+	{
+	  BaseGDL* directCallParameter = e->GetParDefined(1);
+	  BaseGDL* res = 
+	  static_cast<DLibFunDirect*>(libFunList[ funIx])->FunDirect()(directCallParameter, true /*isReference*/);
+	  return res;
+	}
+	else
+	{
+	EnvT* newEnv = e->NewEnv( libFunList[ funIx], 1);
+	Guard<EnvT> guard( newEnv);
+	return static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
+	}
+      }
+    else
+      {
+	// no direct call here
+	
+	StackGuard<EnvStackT> guard( e->Interpreter()->CallStack());
+
+	funIx = GDLInterpreter::GetFunIx( callF);
+	
+	e->PushNewEnvUD( funList[ funIx], 1);
+	
+	// make the call
+	EnvUDT* newEnv = static_cast<EnvUDT*>(e->Interpreter()->CallStack().back());
+	return e->Interpreter()->call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
+      }
+  }
+
+  BaseGDL* call_method_function( EnvT* e)
+  {
+    StackGuard<EnvStackT> guard( e->Interpreter()->CallStack());
+
+    int nParam=e->NParam();
+    if( nParam < 2)
+      e->Throw(  "Name and object reference"
+			  " must be specified.");
+    
+    DString callP;
+    e->AssureScalarPar<DStringGDL>( 0, callP);
+
+    // this is a procedure name -> convert to UPPERCASE
+    callP = StrUpCase( callP);
+    
+    DStructGDL* oStruct = e->GetObjectPar( 1);
+
+    DFun* method= oStruct->Desc()->GetFun( callP);
+
+    if( method == NULL)
+      e->Throw( "Method not found: "+callP);
+// // // /**/
+    e->PushNewEnvUD( method, 2, &e->GetPar( 1));
+    
+    // make the call
+    return e->Interpreter()->call_fun( method->GetTree());
+  }
+
+
+
+  BaseGDL* execute( EnvT* e)
+  {
+    int nParam=e->NParam( 1);
+
+    bool quietCompile = false;
+    if( nParam == 2)
+      {
+		BaseGDL* p1 = e->GetParDefined( 1);
+
+		if( !p1->Scalar())
+		  e->Throw( "Expression must be scalar in this context: "+
+				      e->GetParString(1));
+
+		quietCompile = p1->True();
+      }
+
+    if (e->GetParDefined(0)->Rank() != 0)
+      e->Throw("Expression must be scalar in this context: "+e->GetParString(0));
+    
+    DString line;
+    e->AssureScalarPar<DStringGDL>( 0, line);
+
+    // remove current environment (own one)
+    assert( dynamic_cast<EnvUDT*>(e->Caller()) != NULL);
+    EnvUDT* caller = static_cast<EnvUDT*>(e->Caller());
+//     e->Interpreter()->CallStack().pop_back();
+
+// wrong: e is guarded, do not delete it here	
+//	delete e;
+
+    istringstream istr(line+"\n");
+
+    RefDNode theAST;
+    try {  
+      GDLLexer   lexer(istr, "", caller->CompileOpt());
+      GDLParser& parser=lexer.Parser();
+    
+      parser.interactive();
+    
+      theAST=parser.getAST();
+    }
+    catch( GDLException& ex)
+      {
+	if( !quietCompile) GDLInterpreter::ReportCompileError( ex);
+	return new DIntGDL( 0);
+      }
+    catch( ANTLRException ex)
+      {
+	if( !quietCompile) cerr << "EXECUTE: Lexer/Parser exception: " <<  
+			     ex.getMessage() << endl;
+	return new DIntGDL( 0);
+      }
+    
+    if( theAST == NULL) return new DIntGDL( 1);
+
+    RefDNode trAST;
+    try
+      {
+	GDLTreeParser treeParser( caller);
+	  
+	treeParser.interactive(theAST);
+
+	trAST=treeParser.getAST();
+      }
+    catch( GDLException& ex)
+      {
+	if( !quietCompile) GDLInterpreter::ReportCompileError( ex);
+	return new DIntGDL( 0);
+      }
+
+    catch( ANTLRException ex)
+      {
+	if( !quietCompile) cerr << "EXECUTE: Compiler exception: " <<  
+			     ex.getMessage() << endl;
+	return new DIntGDL( 0);
+      }
+      
+    if( trAST == NULL) return new DIntGDL( 1);
+
+    int nForLoopsIn = caller->NForLoops();
+    try
+      {
+		ProgNodeP progAST = ProgNode::NewProgNode( trAST);
+		Guard< ProgNode> progAST_guard( progAST);
+
+		int nForLoops = ProgNode::NumberForLoops( progAST, nForLoopsIn);
+		caller->ResizeForLoops( nForLoops);
+
+		progAST->setLine( e->GetLineNumber());
+
+		RetCode retCode = caller->Interpreter()->execute( progAST);
+
+		caller->ResizeForLoops( nForLoopsIn);
+
+		if( retCode == RC_OK)
+		return new DIntGDL( 1);
+		else
+		return new DIntGDL( 0);
+      }
+    catch( GDLException& ex)
+      {
+		caller->ResizeForLoops( nForLoopsIn);
+		// are we throwing to target environment?
+// 		if( ex.GetTargetEnv() == NULL)
+			if( !quietCompile) cerr << "EXECUTE: " <<
+					ex.getMessage() << endl;
+		return new DIntGDL( 0);
+      }
+    catch( ANTLRException ex)
+      {
+		caller->ResizeForLoops( nForLoopsIn);
+		
+		if( !quietCompile) cerr << "EXECUTE: Interpreter exception: " <<
+					ex.getMessage() << endl;
+		return new DIntGDL( 0);
+      }
+
+    return new DIntGDL( 0); // control flow cannot reach here - compiler shut up
+  }
+
+  BaseGDL* assoc( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 2);
+
+    DLong lun;
+    e->AssureLongScalarPar( 0, lun);
+
+    bool stdLun = check_lun( e, lun);
+    if( stdLun)
+      e->Throw( "File unit does not allow"
+		" this operation. Unit: "+i2s( lun));
+
+    DLong offset = 0;
+    if( nParam >= 3) e->AssureLongScalarPar( 2, offset);
+    
+    BaseGDL* arr = e->GetParDefined( 1);
+    
+    if( arr->StrictScalar())
+      e->Throw( "Scalar variable not allowed in this"
+		" context: "+e->GetParString(1));
+    
+    return arr->AssocVar( lun, offset);
+  }
+
+  // gdl_ naming because of weired namespace problem in MSVC
+  BaseGDL* gdl_logical_and( EnvT* e)
+  {
+    SizeT nParam=e->NParam();
+    if( nParam != 2)
+      e->Throw(
+			  "Incorrect number of arguments.");
+
+    BaseGDL* e1=e->GetParDefined( 0);//, "LOGICAL_AND");
+    BaseGDL* e2=e->GetParDefined( 1);//, "LOGICAL_AND");
+
+    ULong nEl1 = e1->N_Elements();
+    ULong nEl2 = e2->N_Elements();
+
+    Data_<SpDByte>* res;
+
+    if( e1->Scalar()) 
+      {
+	if( e1->LogTrue(0)) 
+	  {
+	    res= new Data_<SpDByte>( e2->Dim(), BaseGDL::NOZERO);
+// #pragma omp parallel if (nEl2 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl2))
+{
+// #pragma omp for
+	    for( SizeT i=0; i < nEl2; i++)
+	      (*res)[i] = e2->LogTrue( i) ? 1 : 0;
+}
+	  }
+	else
+	  {
+	    return new Data_<SpDByte>( e2->Dim());
+	  }
+      }
+    else if( e2->Scalar()) 
+      {
+	if( e2->LogTrue(0)) 
+	  {
+	    res= new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
+// #pragma omp parallel if (nEl1 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl1))
+{
+// #pragma omp for
+	    for( SizeT i=0; i < nEl1; i++)
+	      (*res)[i] = e1->LogTrue( i) ? 1 : 0;
+}
+	  }
+	else
+	  {
+	    return new Data_<SpDByte>( e1->Dim());
+	  }
+      }
+    else if( nEl2 < nEl1) 
+      {
+	res= new Data_<SpDByte>( e2->Dim(), BaseGDL::NOZERO);
+// #pragma omp parallel if (nEl2 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl2))
+{
+// #pragma omp for
+	for( SizeT i=0; i < nEl2; i++)
+	  (*res)[i] = (e1->LogTrue( i) && e2->LogTrue( i)) ? 1 : 0;
+}
+      }
+    else // ( nEl2 >= nEl1)
+      {
+	res= new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
+// #pragma omp parallel if (nEl1 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl1))
+{
+// #pragma omp for
+	for( SizeT i=0; i < nEl1; i++)
+	  (*res)[i] = (e1->LogTrue( i) && e2->LogTrue( i)) ? 1 : 0;
+}
+      }
+    return res;
+  }
+
+  // gdl_ naming because of weired namespace problem in MSVC
+  BaseGDL* gdl_logical_or( EnvT* e)
+  {
+    SizeT nParam=e->NParam();
+    if( nParam != 2)
+      e->Throw(
+			  "Incorrect number of arguments.");
+
+    BaseGDL* e1=e->GetParDefined( 0);//, "LOGICAL_OR");
+    BaseGDL* e2=e->GetParDefined( 1);//, "LOGICAL_OR");
+
+    ULong nEl1 = e1->N_Elements();
+    ULong nEl2 = e2->N_Elements();
+
+    Data_<SpDByte>* res;
+
+    if( e1->Scalar()) 
+      {
+	if( e1->LogTrue(0)) 
+	  {
+	    res= new Data_<SpDByte>( e2->Dim(), BaseGDL::NOZERO);
+// #pragma omp parallel if (nEl2 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl2))
+{
+// #pragma omp for
+	    for( SizeT i=0; i < nEl2; i++)
+	      (*res)[i] = 1;
+}
+	  }
+	else
+	  {
+	    res= new Data_<SpDByte>( e2->Dim(), BaseGDL::NOZERO);
+// #pragma omp parallel if (nEl2 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl2))
+{
+// #pragma omp for
+	    for( SizeT i=0; i < nEl2; i++)
+	      (*res)[i] = e2->LogTrue( i) ? 1 : 0;
+}
+	  }
+      }
+    else if( e2->Scalar()) 
+      {
+	if( e2->LogTrue(0)) 
+	  {
+	    res= new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
+// #pragma omp parallel if (nEl1 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl1))
+{
+// #pragma omp for
+	    for( SizeT i=0; i < nEl1; i++)
+	      (*res)[i] = 1;
+}
+	  }
+	else
+	  {
+	    res= new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
+// #pragma omp parallel if (nEl1 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl1))
+{
+// #pragma omp for
+	    for( SizeT i=0; i < nEl1; i++)
+	      (*res)[i] = e1->LogTrue( i) ? 1 : 0;
+}
+	  }
+      }
+    else if( nEl2 < nEl1) 
+      {
+	res= new Data_<SpDByte>( e2->Dim(), BaseGDL::NOZERO);
+// #pragma omp parallel if (nEl2 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl2))
+{
+// #pragma omp for
+	for( SizeT i=0; i < nEl2; i++)
+	  (*res)[i] = (e1->LogTrue( i) || e2->LogTrue( i)) ? 1 : 0;
+}
+      }
+    else // ( nEl2 >= nEl1)
+      {
+	res= new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
+// #pragma omp parallel if (nEl1 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl1))
+{
+// #pragma omp for
+	for( SizeT i=0; i < nEl1; i++)
+	  (*res)[i] = (e1->LogTrue( i) || e2->LogTrue( i)) ? 1 : 0;
+}
+      }
+    return res;
+  }
+
+  BaseGDL* logical_true( BaseGDL* e1, bool isReference)//( EnvT* e);
+  {
+    assert( e1 != NULL);
+    assert( e1->N_Elements() > 0);
+    
+
+//     SizeT nParam=e->NParam();
+//     if( nParam != 1)
+//       e->Throw(
+// 			  "Incorrect number of arguments.");
+// 
+//     BaseGDL* e1=e->GetParDefined( 0);//, "LOGICAL_TRUE");
+//     
+    ULong nEl1 = e1->N_Elements();
+
+    Data_<SpDByte>* res = new Data_<SpDByte>( e1->Dim(), BaseGDL::NOZERO);
+// #pragma omp parallel if (nEl1 >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl1))
+{
+// #pragma omp for
+    for( SizeT i=0; i < nEl1; i++)
+      (*res)[i] = e1->LogTrue( i) ? 1 : 0;
+}    
+    return res;
+  }
+
+  BaseGDL* replicate( EnvT* e)
+  {
+    SizeT nParam=e->NParam();
+    if( nParam < 2)
+      e->Throw( "Incorrect number of arguments.");
+    dimension dim;
+    arr( e, dim, 1);
+
+    BaseGDL* p0=e->GetParDefined( 0);//, "REPLICATE");
+    if( !p0->Scalar())
+      e->Throw(	"Expression must be a scalar in this context: "+
+		e->GetParString(0));
+
+    return p0->New( dim, BaseGDL::INIT);
+  }
+
+  BaseGDL* strtrim( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 1);//, "STRTRIM");
+
+    BaseGDL* p0 = e->GetPar( 0);
+    if( p0 == NULL)
+      e->Throw(
+			  "Variable is undefined: "+
+			  e->GetParString(0));
+    DStringGDL* p0S = static_cast<DStringGDL*>
+      (p0->Convert2(GDL_STRING,BaseGDL::COPY));
+    
+    DLong mode = 0;
+    if( nParam == 2)
+      {
+	BaseGDL* p1 = e->GetPar( 1);
+	if( p1 == NULL)
+	  e->Throw(
+			      "Variable is undefined: "+e->GetParString(1));
+	if( !p1->Scalar())
+	  e->Throw(
+			      "Expression must be a "
+			      "scalar in this context: "+
+			      e->GetParString(1));
+	DLongGDL* p1L = static_cast<DLongGDL*>
+	  (p1->Convert2(GDL_LONG,BaseGDL::COPY));
+
+	mode = (*p1L)[ 0];
+
+	GDLDelete(p1L);
+
+	if( mode < 0 || mode > 2)
+	  {
+	    ostringstream os;
+	    p1->ToStream( os);
+	    e->Throw(
+				"Value of <"+ p1->TypeStr() +
+				"  ("+os.str()+
+				")> is out of allowed range.");
+	  }
+      }
+    
+    SizeT nEl = p0S->N_Elements();
+
+    if( mode == 2) // both
+   {
+TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
+{
+#pragma omp for
+      for( OMPInt i=0; i<nEl; ++i)
+	{
+	  unsigned long first= (*p0S)[ i].find_first_not_of(" \t");
+	  if( first == (*p0S)[ i].npos)
+	    {
+	      (*p0S)[ i] = "";
+	    }
+	  else
+	    {
+	      unsigned long last = (*p0S)[ i].find_last_not_of(" \t");
+	      (*p0S)[ i] = (*p0S)[ i].substr(first,last-first+1);
+	    }
+	}
+}
+  }
+  else if( mode == 1) // leading
+     {
+TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
+{
+#pragma omp for
+	for( OMPInt i=0; i<nEl; ++i)
+	{
+	  unsigned long first= (*p0S)[ i].find_first_not_of(" \t");
+	  if( first == (*p0S)[ i].npos)
+	    {
+	      (*p0S)[ i] = "";
+	    }
+	  else
+	    {
+	      (*p0S)[ i] = (*p0S)[ i].substr(first);
+	    }
+	}
+}
+    }
+    else // trailing
+      {
+TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
+{
+#pragma omp for
+	for( OMPInt i=0; i<nEl; ++i)
+	{
+	  unsigned long last = (*p0S)[ i].find_last_not_of(" \t");
+	  if( last == (*p0S)[ i].npos)
+	    {
+	      (*p0S)[ i] = "";
+	    }
+	  else
+	    {
+	      (*p0S)[ i] = (*p0S)[ i].substr(0,last+1);
+	    }
+	}
+}
+      }
+    return p0S;
+  }
+
+  BaseGDL* strcompress( EnvT* e)
+  {
+    e->NParam( 1);
+
+    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+
+    bool removeAll =  e->KeywordSet(0);
+
+    DStringGDL* res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
+
+    SizeT nEl = p0S->N_Elements();
+TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
+{
+#pragma omp for
+    for( OMPInt i=0; i<nEl; ++i)
+      {
+	(*res)[ i] = StrCompress((*p0S)[ i], removeAll);
+      }
+}
+    return res;
+  }
+
+  BaseGDL* strpos( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 2);//, "STRPOS");
+
+    bool reverseOffset =  e->KeywordSet(0); // REVERSE_OFFSET
+    bool reverseSearch =  e->KeywordSet(1); // REVERSE_SEARCH
+
+    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+
+    DString searchString;
+    //     e->AssureScalarPar<DStringGDL>( 1, searchString);
+    DStringGDL* sStr = e->GetParAs<DStringGDL>( 1);
+    if( !sStr->Scalar( searchString))
+      e->Throw( "Search string must be a scalar or one element array: "+
+		e->GetParString( 1));
+
+    unsigned long pos = string::npos;
+    if( nParam > 2)
+{
+    BaseGDL* p2 = e->GetParDefined(2);
+//     if( p2 != NULL) //e->AssureLongScalarPar( 2,posDLong);
+//       {
+	const SizeT pIx = 2;
+	BaseGDL* p = e->GetParDefined( pIx);
+	DLongGDL* lp = static_cast<DLongGDL*>(p->Convert2( GDL_LONG, BaseGDL::COPY));
+	Guard<DLongGDL> guard_lp( lp);
+	DLong scalar;
+	if( !lp->Scalar( scalar))
+	  throw GDLException("Parameter must be a scalar in this context: "+
+			     e->GetParString(pIx));
+	pos = scalar;
+      }
+
+    DLongGDL* res = new DLongGDL( p0S->Dim(), BaseGDL::NOZERO);
+
+    SizeT nSrcStr = p0S->N_Elements();
+TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if ((nSrcStr*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nSrcStr*10)))
+{
+#pragma omp for
+    for( OMPInt i=0; i<nSrcStr; ++i)
+      {
+	(*res)[ i] = StrPos((*p0S)[ i], searchString, pos, 
+			    reverseOffset, reverseSearch);
+      }
+}    
+    return res;
+  }
+
+  BaseGDL* strmid( EnvT* e)
+  {
+    e->NParam( 2);//, "STRMID");
+
+    bool reverse =  e->KeywordSet(0);
+
+    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+    DLongGDL*   p1L = e->GetParAs<DLongGDL>( 1);
+
+    BaseGDL*  p2  = e->GetPar( 2);
+    DLongGDL* p2L = NULL;
+    if( p2 != NULL) p2L = e->GetParAs<DLongGDL>( 2);
+
+    DLong scVal1;
+    bool sc1 = p1L->Scalar( scVal1);
+
+    DLong scVal2 = numeric_limits<DLong>::max();
+    bool sc2 = true;
+    if( p2L != NULL) 
+      {
+	DLong scalar;
+	sc2 = p2L->Scalar( scalar);
+	scVal2 = scalar;
+      }
+
+    DLong stride;
+    if( !sc1 && !sc2)
+      {
+	stride = p1L->Dim( 0);
+	if( stride != p2L->Dim( 0))
+	  e->Throw(
+			      "Starting offset and length arguments "
+			      "have incompatible first dimension.");	  
+      }
+    else
+      {
+	// at least one scalar, p2L possibly NULL
+	if( p2L == NULL)
+	  stride = p1L->Dim( 0);
+	else
+	  stride = max( p1L->Dim( 0), p2L->Dim( 0));
+	
+	stride = (stride > 0)? stride : 1;
+      }
+
+    dimension resDim( p0S->Dim());
+    if( stride > 1)
+      resDim >> stride;
+
+    DStringGDL* res = new DStringGDL( resDim, BaseGDL::NOZERO);
+
+    SizeT nEl1 = p1L->N_Elements();
+    SizeT nEl2 = (sc2)? 1 : p2L->N_Elements();
+
+    SizeT nSrcStr = p0S->N_Elements();
+TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if ((nSrcStr*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nSrcStr*10))) default( shared)
+{
+#pragma omp for
+    for( OMPInt i=0; i<nSrcStr; ++i)
+      {
+		for( long ii=0; ii<stride; ++ii)
+		{
+			SizeT destIx = i * stride + ii;
+			DLong actFirst = (sc1)? scVal1 : (*p1L)[ destIx % nEl1];
+			DLong actLen   = (sc2)? scVal2 : (*p2L)[ destIx % nEl2];
+			if( actLen <= 0)
+				(*res)[ destIx] = "";//StrMid((*p0S)[ i], actFirst, actLen, reverse);
+			else	
+				(*res)[ destIx] = StrMid((*p0S)[ i], actFirst, actLen, reverse);
+		}
+      }
+}    
+    return res;
+  }
+
+  BaseGDL* strlowcase( BaseGDL* p0, bool isReference)//( EnvT* e)
+  {
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
+
+//     e->NParam( 1);//, "STRLOWCASE");
+
+//     DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+    DStringGDL* p0S;
+    DStringGDL* res;
+// 	Guard<DStringGDL> guard;
+
+	if( p0->Type() == GDL_STRING)
+	{
+		p0S = static_cast<DStringGDL*>( p0);
+		if( !isReference)
+			res = p0S;
+		else
+			res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
+	}
+	else
+	{
+		p0S = static_cast<DStringGDL*>( p0->Convert2( GDL_STRING, BaseGDL::COPY));
+		res = p0S;
+// 	    guard.Reset( p0S);
+	}
+
+//     DStringGDL* res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
+    
+    SizeT nEl = p0S->N_Elements();
+
+	if( res == p0S)
+	{
+TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
+{
+#pragma omp for
+    for( OMPInt i=0; i<nEl; ++i)
+      {
+		StrLowCaseInplace((*p0S)[ i]);
+      }
+}
+	}
+	else
+	{
+TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
+{
+#pragma omp for
+    for( OMPInt i=0; i<nEl; ++i)
+      {
+		(*res)[ i] = StrLowCase((*p0S)[ i]);
+      }
+}
+	}
+    return res;
+  }
+
+  BaseGDL* strupcase( BaseGDL* p0, bool isReference)//( EnvT* e)
+  {
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
+
+//     e->NParam( 1);//, "STRLOWCASE");
+
+//     DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+    DStringGDL* p0S;
+    DStringGDL* res;
+// 	Guard<DStringGDL> guard;
+
+	if( p0->Type() == GDL_STRING)
+	{
+		p0S = static_cast<DStringGDL*>( p0);
+		if( !isReference)
+			res = p0S;
+		else
+			res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
+	}
+	else
+	{
+		p0S = static_cast<DStringGDL*>( p0->Convert2( GDL_STRING, BaseGDL::COPY));
+		res = p0S;
+// 	    guard.Reset( p0S);
+	}
+
+//     DStringGDL* res = new DStringGDL( p0S->Dim(), BaseGDL::NOZERO);
+
+    SizeT nEl = p0S->N_Elements();
+
+	if( res == p0S)
+	{
+TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
+{
+#pragma omp for
+    for( OMPInt i=0; i<nEl; ++i)
+      {
+		StrUpCaseInplace((*p0S)[ i]);
+      }
+}
+	}
+	else
+	{
+TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if ((nEl*10) >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= (nEl*10)))
+{
+#pragma omp for
+    for( OMPInt i=0; i<nEl; ++i)
+      {
+		(*res)[ i] = StrUpCase((*p0S)[ i]);
+      }
+}
+	}
+    return res;
+  }
+
+  BaseGDL* strlen( BaseGDL* p0, bool isReference)//( EnvT* e)
+  {
+    assert( p0 != NULL);
+    assert( p0->N_Elements() > 0);
+
+//     e->NParam( 1);//, "STRLEN");
+
+    DStringGDL* p0S;
+	Guard<DStringGDL> guard;
+	
+	if( p0->Type() == GDL_STRING)
+		p0S = static_cast<DStringGDL*>( p0);
+	else
+	{
+		p0S = static_cast<DStringGDL*>( p0->Convert2( GDL_STRING, BaseGDL::COPY));
+	    guard.Reset( p0S);
+	}
+
+    DLongGDL* res = new DLongGDL( p0S->Dim(), BaseGDL::NOZERO);
+
+    SizeT nEl = p0S->N_Elements();
+// #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+{
+// #pragma omp for
+    for( SizeT i=0; i<nEl; ++i)
+      {
+		(*res)[ i] = (*p0S)[ i].length();
+      }
+}
+    return res;
+  }
+
+  BaseGDL* strjoin( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 1);
+
+    DStringGDL* p0S = e->GetParAs<DStringGDL>( 0);
+    SizeT nEl = p0S->N_Elements();
+
+    DString delim = "";
+    if( nParam > 1)
+      e->AssureStringScalarPar( 1, delim);
+    
+    bool single = e->KeywordSet( 0); // SINGLE
+
+    if( single)
+      {
+	DStringGDL* res = new DStringGDL( (*p0S)[0]);
+	DString&    scl = (*res)[0];
+
+	for( SizeT i=1; i<nEl; ++i)
+	  scl += delim + (*p0S)[i];
+
+	return res;
+      }
+
+    dimension resDim( p0S->Dim());
+    resDim.Purge();
+    
+    SizeT stride = resDim.Stride( 1);
+
+    resDim.Remove( 0);
+
+    DStringGDL* res = new DStringGDL( resDim, BaseGDL::NOZERO);
+    for( SizeT src=0, dst=0; src<nEl; ++dst)
+      {
+	(*res)[ dst] = (*p0S)[ src++];
+	for(SizeT l=1; l<stride; ++l)
+	  (*res)[ dst] += delim + (*p0S)[ src++];
+      }
+    
+    return res;
+  }
+
+  BaseGDL* where( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 1);//, "WHERE");
+
+    BaseGDL* p0 = e->GetParDefined( 0);//, "WHERE");
+
+    SizeT nEl = p0->N_Elements();
+
+    SizeT count;
+    
+    static int nullIx = e->KeywordIx("NULL");
+    bool nullKW = e->KeywordSet(nullIx);
+
+    DLong* ixList = p0->Where( e->KeywordPresent( 0), count);
+    ArrayGuard<DLong> guard( ixList);
+    SizeT nCount = nEl - count;
+
+    if( e->KeywordPresent( 0)) // COMPLEMENT
+      {
+	if( nCount == 0)
+	  {
+	    if( nullKW)
+	      e->SetKW( 0, NullGDL::GetSingleInstance());
+	    else
+	      e->SetKW( 0, new DLongGDL( -1));
+	  }
+	else
+	  {
+	    DLongGDL* cIxList = new DLongGDL( dimension( &nCount, 1), 
+					      BaseGDL::NOZERO);
+	    
+	    SizeT cIx = nEl - 1;
+// #pragma omp parallel if (nCount >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nCount))
+{
+// #pragma omp for
+	    for( SizeT i=0; i<nCount; ++i)
+	      (*cIxList)[ i] = ixList[ cIx - i];
+// 	      (*cIxList)[ i] = ixList[ --cIx];
+}
+	    e->SetKW( 0, cIxList);
+	  }
+      }
+
+    if( e->KeywordPresent( 1)) // NCOMPLEMENT
+      {
+	e->SetKW( 1, new DLongGDL( nCount));
+      }
+
+    if( nParam == 2)
+      {
+	e->SetPar( 1, new DLongGDL( count));
+      }
+
+    if( count == 0) 
+    {
+      if( nullKW)
+	return NullGDL::GetSingleInstance();
+      return new DLongGDL( -1);
+    }
+    
+    return new DLongGDL( ixList, count);
+
+    //     DLongGDL* res = new DLongGDL( dimension( &count, 1), 
+    // 				  BaseGDL::NOZERO);
+    //     for( SizeT i=0; i<count; ++i)
+    //       (*res)[ i] = ixList[ i];
+
+    //     return res;
+  }
+
+  BaseGDL* n_params( EnvT* e) 
+  {
+    EnvUDT* caller = static_cast<EnvUDT*>(e->Caller());
+    if( caller == NULL) return new DLongGDL( 0);
+    DLong nP = caller->NParam();
+    if( caller->IsObject()) 
+      return new DLongGDL( nP-1); // "self" is not counted
+    return new DLongGDL( nP);
+  }
+
+  BaseGDL* keyword_set( EnvT* e)
+  {
+    e->NParam( 1);//, "KEYWORD_SET");
+
+    BaseGDL* p0 = e->GetPar( 0);
+    if( p0 == NULL) return new DIntGDL( 0);
+    if( !p0->Scalar()) return new DIntGDL( 1);
+    if( p0->Type() == GDL_STRUCT) return new DIntGDL( 1);
+    if( p0->LogTrue()) return new DIntGDL( 1);
+    return new DIntGDL( 0);
+  }
+
+  // passing 2nd argument by value is slightly better for float and double, 
+  // but incur some overhead for the complex class.
+  template<class T> inline void AddOmitNaN(T& dest, T value)
+{
+ if (isfinite(value)) 
+{
+// #pragma omp atomic
+	dest += value; 
+}
+}
+  template<class T> inline void AddOmitNaNCpx(T& dest, T value)
+  {
+// #pragma omp atomic
+    dest += T(isfinite(value.real())? value.real() : 0,
+	      isfinite(value.imag())? value.imag() : 0);
+  }
+  template<> inline void AddOmitNaN(DComplex& dest, DComplex value)
+  { AddOmitNaNCpx<DComplex>(dest, value); }
+  template<> inline void AddOmitNaN(DComplexDbl& dest, DComplexDbl value)
+  { AddOmitNaNCpx<DComplexDbl>(dest, value); }
+
+  template<class T> inline void NaN2Zero(T& value)
+  { if (!isfinite(value)) value = 0; }
+  template<class T> inline void NaN2ZeroCpx(T& value)
+  {
+    value = T(isfinite(value.real())? value.real() : 0, 
+              isfinite(value.imag())? value.imag() : 0);
+  }
+  template<> inline void NaN2Zero(DComplex& value)
+  { NaN2ZeroCpx< DComplex>(value); }
+  template<> inline void NaN2Zero(DComplexDbl& value)
+  { NaN2ZeroCpx< DComplexDbl>(value); }
+
+  // total over all elements
+  template<class T>
+  BaseGDL* total_template( T* src, bool omitNaN)
+  {
+    if (!omitNaN) return new T(src->Sum());
+    typename T::Ty sum = 0;
+    SizeT nEl = src->N_Elements();
+TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared(sum)
+{
+#pragma omp for
+    for ( OMPInt i=0; i<nEl; ++i)
+      {
+	AddOmitNaN(sum, (*src)[ i]);
+      }
+}
+    return new T(sum);
+  }
+  
+  // cumulative over all dims
+  template<typename T>
+  BaseGDL* total_cu_template( T* res, bool omitNaN)
+  {
+    SizeT nEl = res->N_Elements();
+    if (omitNaN)
+      {
+// #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+{
+// #pragma omp for
+        for( SizeT i=0; i<nEl; ++i)
+          NaN2Zero((*res)[i]);
+}
+      }
+    for( SizeT i=1,ii=0; i<nEl; ++i,++ii)
+      (*res)[i] += (*res)[ii];
+    return res;
+  }
+
+  // total over one dim
+  template< typename T>
+  BaseGDL* total_over_dim_template( T* src, 
+				    const dimension& srcDim,
+				    SizeT sumDimIx,
+                                    bool omitNaN)
+  {
+    SizeT nEl = src->N_Elements();
+    
+    // get dest dim and number of summations
+    dimension destDim = srcDim;
+    SizeT nSum = destDim.Remove( sumDimIx);
+
+    T* res = new T( destDim); // zero fields
+
+    // sumStride is also the number of linear src indexing
+    SizeT sumStride = srcDim.Stride( sumDimIx); 
+    SizeT outerStride = srcDim.Stride( sumDimIx + 1);
+    SizeT sumLimit = nSum * sumStride;
+    SizeT rIx=0;
+    for( SizeT o=0; o < nEl; o += outerStride)
+      for( SizeT i=0; i < sumStride; ++i)
+	{
+	  SizeT oi = o+i;
+	  SizeT oiLimit = sumLimit + oi;
+          if( omitNaN)
+            {
+              for( SizeT s=oi; s<oiLimit; s += sumStride)
+                AddOmitNaN((*res)[ rIx], (*src)[ s]);
+	    }
+          else
+            {
+  	      for( SizeT s=oi; s<oiLimit; s += sumStride)
+	        (*res)[ rIx] += (*src)[ s];
+            }
+	  ++rIx;
+	}
+    return res;
+  }
+
+  // cumulative over one dim
+  template< typename T>
+  BaseGDL* total_over_dim_cu_template( T* res, 
+				       SizeT sumDimIx,
+                                       bool omitNaN)
+  {
+    SizeT nEl = res->N_Elements();
+    const dimension& resDim = res->Dim();
+    if (omitNaN)
+      {
+        for( SizeT i=0; i<nEl; ++i)
+          NaN2Zero((*res)[i]);
+      }
+    SizeT cumStride = resDim.Stride( sumDimIx); 
+    SizeT outerStride = resDim.Stride( sumDimIx + 1);
+    for( SizeT o=0; o < nEl; o += outerStride)
+      {
+	SizeT cumLimit = o+outerStride;
+	for( SizeT i=o+cumStride, ii=o; i<cumLimit; ++i, ++ii)
+	  (*res)[ i] += (*res)[ ii];
+      }
+    return res;
+  }
+
+
+  BaseGDL* total( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 1);//, "TOTAL");
+
+    BaseGDL* p0 = e->GetParDefined( 0);//, "TOTAL");
+
+    SizeT nEl = p0->N_Elements();
+    if( nEl == 0)
+      e->Throw( "Variable is undefined: "+e->GetParString(0));
+
+    if( p0->Type() == GDL_STRING)
+      e->Throw( "String expression not allowed "
+		"in this context: "+e->GetParString(0));
+    
+    static int cumIx = e->KeywordIx( "CUMULATIVE");
+    static int intIx = e->KeywordIx("INTEGER");
+    static int doubleIx = e->KeywordIx( "DOUBLE");
+    static int nanIx = e->KeywordIx( "NAN");
+    static int preserveIx = e->KeywordIx( "PRESERVE_TYPE");
+
+    bool cumulative = e->KeywordSet( cumIx);
+    bool intRes  = e->KeywordSet( intIx);
+    bool doubleRes  = e->KeywordSet( doubleIx);
+    bool nan        = e->KeywordSet( nanIx);
+    bool preserve   = e->KeywordSet( preserveIx);
+
+    DLong sumDim = 0;
+    if( nParam == 2)
+      e->AssureLongScalarPar( 1, sumDim);
+
+    if( sumDim == 0)
+      {
+	if( !cumulative)
+	  {
+            if (preserve) 
+            {
+              switch (p0->Type())
+              {
+                case GDL_BYTE: return total_template<DByteGDL>(static_cast<DByteGDL*>(p0), false);
+                case GDL_INT: return total_template<DIntGDL>(static_cast<DIntGDL*>(p0), false);
+                case GDL_UINT: return total_template<DUIntGDL>(static_cast<DUIntGDL*>(p0), false);
+                case GDL_LONG: return total_template<DLongGDL>(static_cast<DLongGDL*>(p0), false);
+                case GDL_ULONG: return total_template<DULongGDL>(static_cast<DULongGDL*>(p0), false);
+                case GDL_LONG64: return total_template<DLong64GDL>(static_cast<DLong64GDL*>(p0), false);
+                case GDL_ULONG64: return total_template<DULong64GDL>(static_cast<DULong64GDL*>(p0), false);
+                case GDL_FLOAT: return total_template<DFloatGDL>(static_cast<DFloatGDL*>(p0), nan);
+                case GDL_DOUBLE: return total_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0), nan);
+                case GDL_COMPLEX: return total_template<DComplexGDL>(static_cast<DComplexGDL*>(p0), nan);
+                case GDL_COMPLEXDBL: return total_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0), nan);
+                default: assert(false);
+              }
+            }
+
+	    // Integer parts by Erin Sheldon
+	    // In IDL total(), the INTEGER keyword takes precedence 
+	    if( intRes )
+	      {
+		// We use GDL_LONG64 unless the input is GDL_ULONG64
+		if ( p0->Type() == GDL_LONG64 )
+		  {
+		    return total_template<DLong64GDL>
+		      ( static_cast<DLong64GDL*>(p0), nan );
+		  }
+		if ( p0->Type() == GDL_ULONG64 )
+		  {
+		    return total_template<DULong64GDL>
+		      ( static_cast<DULong64GDL*>(p0), nan );
+		  }
+
+		// Conver to Long64
+		DLong64GDL* p0L64 = static_cast<DLong64GDL*>
+		  (p0->Convert2( GDL_LONG64, BaseGDL::COPY));
+		Guard<DLong64GDL> guard( p0L64);
+		return total_template<DLong64GDL>( p0L64, nan);
+
+	      } // integer results
+
+
+	    if( p0->Type() == GDL_DOUBLE)
+	      {
+		return total_template<DDoubleGDL>
+                  ( static_cast<DDoubleGDL*>(p0), nan); 
+	      }
+	    if( p0->Type() == GDL_COMPLEXDBL)
+	      {
+		return total_template<DComplexDblGDL>
+                  ( static_cast<DComplexDblGDL*>(p0), nan); 
+	      }
+
+	    if( !doubleRes)
+	      {
+		if( p0->Type() == GDL_FLOAT)
+		  {
+		    return total_template<DFloatGDL>
+		      ( static_cast<DFloatGDL*>(p0), nan); 
+		  }
+		if( p0->Type() == GDL_COMPLEX)
+		  {
+		    return total_template<DComplexGDL>
+		      ( static_cast<DComplexGDL*>(p0), nan); 
+		  }
+ 		DFloatGDL* p0F = static_cast<DFloatGDL*>
+ 		  (p0->Convert2( GDL_FLOAT,BaseGDL::COPY));
+ 		Guard<DFloatGDL> guard( p0F);
+		return total_template<DFloatGDL>( p0F, false);
+	      }
+	    if( p0->Type() == GDL_COMPLEX)
+	      {
+		DComplexDblGDL* p0D = static_cast<DComplexDblGDL*>
+		  (p0->Convert2( GDL_COMPLEXDBL,BaseGDL::COPY));
+		Guard<DComplexDblGDL> p0D_guard( p0D);
+		return total_template<DComplexDblGDL>( p0D, nan); 
+	      }
+	    
+	    DDoubleGDL* p0D = static_cast<DDoubleGDL*>
+	      (p0->Convert2( GDL_DOUBLE, BaseGDL::COPY));
+	    Guard<DDoubleGDL> p0D_guard( p0D);
+	    return total_template<DDoubleGDL>( p0D, nan);
+	  }
+	else // cumulative
+	  {
+            if (preserve) 
+            {
+              switch (p0->Type())
+              {
+                case GDL_BYTE: return total_cu_template<DByteGDL>(static_cast<DByteGDL*>(p0)->Dup(), false);
+                case GDL_INT: return total_cu_template<DIntGDL>(static_cast<DIntGDL*>(p0)->Dup(), false);
+                case GDL_UINT: return total_cu_template<DUIntGDL>(static_cast<DUIntGDL*>(p0)->Dup(), false);
+                case GDL_LONG: return total_cu_template<DLongGDL>(static_cast<DLongGDL*>(p0)->Dup(), false);
+                case GDL_ULONG: return total_cu_template<DULongGDL>(static_cast<DULongGDL*>(p0)->Dup(), false);
+                case GDL_LONG64: return total_cu_template<DLong64GDL>(static_cast<DLong64GDL*>(p0)->Dup(), false);
+                case GDL_ULONG64: return total_cu_template<DULong64GDL>(static_cast<DULong64GDL*>(p0)->Dup(), false);
+                case GDL_FLOAT: return total_cu_template<DFloatGDL>(static_cast<DFloatGDL*>(p0)->Dup(), nan);
+                case GDL_DOUBLE: return total_cu_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0)->Dup(), nan);
+                case GDL_COMPLEX: return total_cu_template<DComplexGDL>(static_cast<DComplexGDL*>(p0)->Dup(), nan);
+                case GDL_COMPLEXDBL: return total_cu_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0)->Dup(), nan);
+                default: assert(false);
+              }
+            }
+
+	    // INTEGER keyword takes precedence
+	    if( intRes )
+	      {
+		// We use GDL_LONG64 unless the input is GDL_ULONG64
+		if ( p0->Type() == GDL_LONG64 )
+		  {
+		    return total_cu_template<DLong64GDL>
+		      ( static_cast<DLong64GDL*>(p0)->Dup(), nan );
+		  }
+		if ( p0->Type() == GDL_ULONG64 )
+		  {
+		    return total_cu_template<DULong64GDL>
+		      ( static_cast<DULong64GDL*>(p0)->Dup(), nan );
+		  }
+
+		// Convert to Long64
+		return total_cu_template<DLong64GDL>
+		  ( static_cast<DLong64GDL*>
+		    (p0->Convert2( GDL_LONG64, BaseGDL::COPY)), nan);
+						     
+	      } // integer results
+
+
+	    // special case as GDL_DOUBLE type overrides /GDL_DOUBLE
+	    if( p0->Type() == GDL_DOUBLE)
+	      {
+  	        return total_cu_template< DDoubleGDL>
+		  ( static_cast<DDoubleGDL*>(p0)->Dup(), nan);
+	      }
+	    if( p0->Type() == GDL_COMPLEXDBL)
+	      {
+  	        return total_cu_template< DComplexDblGDL>
+		  ( static_cast<DComplexDblGDL*>(p0)->Dup(), nan);
+	      }
+
+
+
+	    if( !doubleRes)
+	      {
+		// special case for GDL_FLOAT has no advantage here
+		if( p0->Type() == GDL_COMPLEX)
+		  {
+		    return total_cu_template< DComplexGDL>
+                      ( static_cast<DComplexGDL*>(p0)->Dup(), nan);
+		  }
+    	        return total_cu_template< DFloatGDL>
+		  ( static_cast<DFloatGDL*>( p0->Convert2(GDL_FLOAT, 
+							  BaseGDL::COPY)), nan);
+	      }
+	    if( p0->Type() == GDL_COMPLEX)
+	      {
+		return total_cu_template< DComplexDblGDL>
+		  ( static_cast<DComplexDblGDL*>(p0->Convert2( GDL_COMPLEXDBL, 
+							       BaseGDL::COPY)), nan);
+	      }
+    	    return total_cu_template< DDoubleGDL>
+	      ( static_cast<DDoubleGDL*>(p0->Convert2( GDL_DOUBLE, 
+						       BaseGDL::COPY)), nan);
+	  }
+      }
+
+    // total over sumDim
+    dimension srcDim = p0->Dim();
+    SizeT srcRank = srcDim.Rank();
+
+    if( sumDim < 1 || sumDim > srcRank)
+      e->Throw( 
+			  "Array must have "+i2s(sumDim)+
+			  " dimensions: "+e->GetParString(0));
+
+    if( !cumulative)
+      {
+        if (preserve) 
+        {
+          switch (p0->Type())
+          {
+            case GDL_BYTE: return total_over_dim_template<DByteGDL>(static_cast<DByteGDL*>(p0), srcDim, sumDim-1, false);
+            case GDL_INT: return total_over_dim_template<DIntGDL>(static_cast<DIntGDL*>(p0), srcDim, sumDim-1, false);
+            case GDL_UINT: return total_over_dim_template<DUIntGDL>(static_cast<DUIntGDL*>(p0), srcDim, sumDim-1, false);
+            case GDL_LONG: return total_over_dim_template<DLongGDL>(static_cast<DLongGDL*>(p0), srcDim, sumDim-1, false);
+            case GDL_ULONG: return total_over_dim_template<DULongGDL>(static_cast<DULongGDL*>(p0), srcDim, sumDim-1, false);
+            case GDL_LONG64: return total_over_dim_template<DLong64GDL>(static_cast<DLong64GDL*>(p0), srcDim, sumDim-1, false);
+            case GDL_ULONG64: return total_over_dim_template<DULong64GDL>(static_cast<DULong64GDL*>(p0), srcDim, sumDim-1, false);
+            case GDL_FLOAT: return total_over_dim_template<DFloatGDL>(static_cast<DFloatGDL*>(p0), srcDim, sumDim-1, nan);
+            case GDL_DOUBLE: return total_over_dim_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0), srcDim, sumDim-1, nan);
+            case GDL_COMPLEX: return total_over_dim_template<DComplexGDL>(static_cast<DComplexGDL*>(p0), srcDim, sumDim-1, nan);
+            case GDL_COMPLEXDBL: return total_over_dim_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0), srcDim, sumDim-1, nan);
+            default: assert(false);
+          }
+        }
+
+	// INTEGER keyword takes precedence 
+	if( intRes )
+	  {
+	    // We use GDL_LONG64 unless the input is GDL_ULONG64
+	    if ( p0->Type() == GDL_LONG64 )
+	      {
+		return total_over_dim_template<DLong64GDL>
+		  ( static_cast<DLong64GDL*>(p0), srcDim, sumDim-1, nan );
+	      }
+	    if ( p0->Type() == GDL_ULONG64 )
+	      {
+		return total_over_dim_template<DULong64GDL>
+		  ( static_cast<DULong64GDL*>(p0), srcDim, sumDim-1, nan );
+	      }
+	    
+	    // Conver to Long64
+	    DLong64GDL* p0L64 = static_cast<DLong64GDL*>
+	      (p0->Convert2( GDL_LONG64, BaseGDL::COPY));
+
+	    Guard<DLong64GDL> p0L64_guard( p0L64);
+	    return total_over_dim_template<DLong64GDL>
+	      ( p0L64, srcDim, sumDim-1, nan);
+	    
+	  } // integer results
+
+
+	if( p0->Type() == GDL_DOUBLE)
+	  {
+	    return total_over_dim_template< DDoubleGDL>
+	      ( static_cast<DDoubleGDL*>(p0), srcDim, sumDim-1, nan);
+	  }
+	if( p0->Type() == GDL_COMPLEXDBL)
+	  {
+	    return total_over_dim_template< DComplexDblGDL>
+	      ( static_cast<DComplexDblGDL*>(p0), srcDim, sumDim-1, nan);
+	  }
+	if( !doubleRes)
+	  {
+	    if( p0->Type() == GDL_FLOAT)
+	      {
+		return total_over_dim_template< DFloatGDL>
+		  ( static_cast<DFloatGDL*>(p0), srcDim, sumDim-1, nan);
+	      }
+	    if( p0->Type() == GDL_COMPLEX)
+	      {
+		return total_over_dim_template< DComplexGDL>
+		  ( static_cast<DComplexGDL*>(p0), srcDim, sumDim-1, nan);
+	      }
+	    // default for NOT /GDL_DOUBLE
+	    DFloatGDL* p0F = static_cast<DFloatGDL*>
+	      (p0->Convert2( GDL_FLOAT,BaseGDL::COPY));
+	    Guard<DFloatGDL> p0F_guard( p0F);
+	    //	    p0F_guard.Reset( p0F);
+	    return total_over_dim_template< DFloatGDL>
+	      ( p0F, srcDim, sumDim-1, false);
+	  }
+	if( p0->Type() == GDL_COMPLEX)
+	  {
+	    DComplexDblGDL* p0D = static_cast<DComplexDblGDL*>
+	      (p0->Convert2( GDL_COMPLEXDBL,BaseGDL::COPY));
+	    Guard<DComplexDblGDL> p0D_guard( p0D);
+	    // 	    p0D_guard.Reset( p0D);
+	    return total_over_dim_template< DComplexDblGDL>
+	      ( p0D, srcDim, sumDim-1, nan);
+	  }
+	// default for /GDL_DOUBLE
+	DDoubleGDL* p0D = static_cast<DDoubleGDL*>
+	  (p0->Convert2( GDL_DOUBLE,BaseGDL::COPY));
+	Guard<DDoubleGDL> p0D_guard( p0D);
+	//p0D_guard.Reset( p0D);
+	return total_over_dim_template< DDoubleGDL>( p0D, srcDim, sumDim-1,nan);
+      }
+    else // cumulative
+      {
+        if (preserve) 
+        {
+          switch (p0->Type())
+          {
+            case GDL_BYTE: return total_over_dim_cu_template<DByteGDL>(static_cast<DByteGDL*>(p0)->Dup(), sumDim-1, false);
+            case GDL_INT: return total_over_dim_cu_template<DIntGDL>(static_cast<DIntGDL*>(p0)->Dup(), sumDim-1, false);
+            case GDL_UINT: return total_over_dim_cu_template<DUIntGDL>(static_cast<DUIntGDL*>(p0)->Dup(), sumDim-1, false);
+            case GDL_LONG: return total_over_dim_cu_template<DLongGDL>(static_cast<DLongGDL*>(p0)->Dup(), sumDim-1, false);
+            case GDL_ULONG: return total_over_dim_cu_template<DULongGDL>(static_cast<DULongGDL*>(p0)->Dup(), sumDim-1, false);
+            case GDL_LONG64: return total_over_dim_cu_template<DLong64GDL>(static_cast<DLong64GDL*>(p0)->Dup(), sumDim-1, false);
+            case GDL_ULONG64: return total_over_dim_cu_template<DULong64GDL>(static_cast<DULong64GDL*>(p0)->Dup(), sumDim-1, false);
+            case GDL_FLOAT: return total_over_dim_cu_template<DFloatGDL>(static_cast<DFloatGDL*>(p0)->Dup(), sumDim-1, nan);
+            case GDL_DOUBLE: return total_over_dim_cu_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0)->Dup(), sumDim-1, nan);
+            case GDL_COMPLEX: return total_over_dim_cu_template<DComplexGDL>(static_cast<DComplexGDL*>(p0)->Dup(), sumDim-1, nan);
+            case GDL_COMPLEXDBL: return total_over_dim_cu_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0)->Dup(), sumDim-1, nan);
+            default: assert(false);
+          }
+        }
+
+	// INTEGER keyword takes precedence
+	if( intRes )
+	  {
+	    // We use GDL_LONG64 unless the input is GDL_ULONG64
+	    if ( p0->Type() == GDL_LONG64 )
+	      {
+		return total_over_dim_cu_template<DLong64GDL>
+		  ( static_cast<DLong64GDL*>(p0)->Dup(), sumDim-1, nan );
+	      }
+	    if ( p0->Type() == GDL_ULONG64 )
+	      {
+		return total_over_dim_cu_template<DULong64GDL>
+		  ( static_cast<DULong64GDL*>(p0)->Dup(), sumDim-1, nan );
+	      }
+	    
+	    // Convert to Long64
+	    return total_over_dim_cu_template<DLong64GDL>
+	      ( static_cast<DLong64GDL*>
+		(p0->Convert2( GDL_LONG64, BaseGDL::COPY)), sumDim-1, nan);
+	    
+	  } // integer results
+
+
+	if( p0->Type() == GDL_DOUBLE)
+	  {
+	    return total_over_dim_cu_template< DDoubleGDL>
+	      ( static_cast<DDoubleGDL*>(p0)->Dup(), sumDim-1, nan);
+	  }
+	if( p0->Type() == GDL_COMPLEXDBL)
+	  {
+	    return total_over_dim_cu_template< DComplexDblGDL>
+	      ( static_cast<DComplexDblGDL*>(p0)->Dup(), sumDim-1, nan);
+	  }
+	if( !doubleRes)
+	  {
+	    // special case for GDL_FLOAT has no advantage here
+	    if( p0->Type() == GDL_COMPLEX)
+	      {
+		return total_over_dim_cu_template< DComplexGDL>
+		  ( static_cast<DComplexGDL*>(p0)->Dup(), sumDim-1, nan);
+	      }
+	    // default for NOT /GDL_DOUBLE
+	    return total_over_dim_cu_template< DFloatGDL>
+	      ( static_cast<DFloatGDL*>( p0->Convert2( GDL_FLOAT, 
+						       BaseGDL::COPY)), sumDim-1, nan);
+	  }
+	if( p0->Type() == GDL_COMPLEX)
+	  {
+	    return total_over_dim_cu_template< DComplexDblGDL>
+	      ( static_cast<DComplexDblGDL*>(p0->Convert2( GDL_COMPLEXDBL,
+							   BaseGDL::COPY)), sumDim-1, nan);
+	  }
+	// default for /GDL_DOUBLE
+	return total_over_dim_cu_template< DDoubleGDL>
+	  ( static_cast<DDoubleGDL*>(p0->Convert2( GDL_DOUBLE,
+						   BaseGDL::COPY)), sumDim-1, nan);
+      }
+  }
+
+
+  // passing 2nd argument by value is slightly better for float and double, 
+  // but incur some overhead for the complex class.
+  template<class T> inline void MultOmitNaN(T& dest, T value)
+  { 
+	if (isfinite(value)) 
+	{
+// #pragma omp atomic
+		dest *= value; 
+	}
+  }
+  template<class T> inline void MultOmitNaNCpx(T& dest, T value)
+  {
+    dest *= T(isfinite(value.real())? value.real() : 1,
+	      isfinite(value.imag())? value.imag() : 1);
+  }
+  template<> inline void MultOmitNaN(DComplex& dest, DComplex value)
+  { MultOmitNaNCpx<DComplex>(dest, value); }
+  template<> inline void MultOmitNaN(DComplexDbl& dest, DComplexDbl value)
+  { MultOmitNaNCpx<DComplexDbl>(dest, value); }
+
+  template<class T> inline void Nan2One(T& value)
+  { if (!isfinite(value)) value = 1; }
+  template<class T> inline void Nan2OneCpx(T& value)
+  {
+    value = T(isfinite(value.real())? value.real() : 1, 
+              isfinite(value.imag())? value.imag() : 1);
+  }
+  template<> inline void Nan2One(DComplex& value)
+  { Nan2OneCpx< DComplex>(value); }
+  template<> inline void Nan2One(DComplexDbl& value)
+  { Nan2OneCpx< DComplexDbl>(value); }
+
+  // product over all elements
+  template<class T>
+  BaseGDL* product_template( T* src, bool omitNaN)
+  {
+    typename T::Ty sum = 1;
+    SizeT nEl = src->N_Elements();
+    if( !omitNaN) 
+	{
+TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared(sum)
+{
+#pragma omp for reduction(*:sum)
+	for ( OMPInt i=0; i<nEl; ++i)
+		{
+		sum *= (*src)[ i];
+		}
+}
+	}
+    else
+	{
+TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared(sum)
+{
+#pragma omp for reduction(*:sum)
+	for ( OMPInt i=0; i<nEl; ++i)
+		{
+		MultOmitNaN( sum, (*src)[ i]);
+		}
+}
+	}
+    return new T( sum);
+  }
+
+  template<>
+  BaseGDL* product_template( DComplexGDL* src, bool omitNaN)
+  {
+    DComplexGDL::Ty sum = 1;
+    SizeT nEl = src->N_Elements();
+    if( !omitNaN) 
+	{
+	for ( SizeT i=0; i<nEl; ++i)
+		{
+		sum *= (*src)[ i];
+		}
+	}
+    else
+	{
+	for ( SizeT i=0; i<nEl; ++i)
+		{
+		MultOmitNaN( sum, (*src)[ i]);
+		}
+	}
+    return new DComplexGDL( sum);
+  }
+  
+  template<>
+  BaseGDL* product_template( DComplexDblGDL* src, bool omitNaN)
+  {
+    DComplexDblGDL::Ty sum = 1;
+    SizeT nEl = src->N_Elements();
+    if( !omitNaN) 
+	{
+	for ( SizeT i=0; i<nEl; ++i)
+		{
+		sum *= (*src)[ i];
+		}
+	}
+    else
+	{
+	for ( SizeT i=0; i<nEl; ++i)
+		{
+		MultOmitNaN( sum, (*src)[ i]);
+		}
+	}
+    return new DComplexDblGDL( sum);
+  }
+  
+  // cumulative over all dims
+  template<typename T>
+  BaseGDL* product_cu_template( T* res, bool omitNaN)
+  {
+    SizeT nEl = res->N_Elements();
+    if( omitNaN)
+      {
+        for( SizeT i=0; i<nEl; ++i)
+          Nan2One( (*res)[i]);
+      }
+    for( SizeT i=1,ii=0; i<nEl; ++i,++ii)
+      (*res)[i] *= (*res)[ii];
+    return res;
+  }
+
+  // product over one dim
+  template< typename T>
+  BaseGDL* product_over_dim_template( T* src, 
+				      const dimension& srcDim, 
+				      SizeT sumDimIx,
+				      bool omitNaN)
+  {
+    SizeT nEl = src->N_Elements();
+    
+    // get dest dim and number of summations
+    dimension destDim = srcDim;
+    SizeT nSum = destDim.Remove( sumDimIx);
+
+    T* res = new T( destDim, BaseGDL::NOZERO);
+
+    // sumStride is also the number of linear src indexing
+    SizeT sumStride = srcDim.Stride( sumDimIx); 
+    SizeT outerStride = srcDim.Stride( sumDimIx + 1);
+    SizeT sumLimit = nSum * sumStride;
+    SizeT rIx=0;
+    for( SizeT o=0; o < nEl; o += outerStride)
+      for( SizeT i=0; i < sumStride; ++i)
+	{
+	  (*res)[ rIx] = 1;
+	  SizeT oi = o+i;
+	  SizeT oiLimit = sumLimit + oi;
+          if( omitNaN)
+            {
+              for( SizeT s=oi; s<oiLimit; s += sumStride)
+                MultOmitNaN((*res)[ rIx], (*src)[ s]);
+	    }
+          else
+            {
+  	      for( SizeT s=oi; s<oiLimit; s += sumStride)
+	        (*res)[ rIx] *= (*src)[ s];
+            }
+	  ++rIx;
+	}
+    return res;
+  }
+
+  // cumulative over one dim
+  template< typename T>
+  BaseGDL* product_over_dim_cu_template( T* res, 
+					 SizeT sumDimIx,
+					 bool omitNaN)
+  {
+    SizeT nEl = res->N_Elements();
+    const dimension& resDim = res->Dim();
+    if (omitNaN)
+      {
+        for( SizeT i=0; i<nEl; ++i)
+          Nan2One((*res)[i]);
+      }
+    SizeT cumStride = resDim.Stride( sumDimIx); 
+    SizeT outerStride = resDim.Stride( sumDimIx + 1);
+    for( SizeT o=0; o < nEl; o += outerStride)
+      {
+	SizeT cumLimit = o+outerStride;
+	for( SizeT i=o+cumStride, ii=o; i<cumLimit; ++i, ++ii)
+	  (*res)[ i] *= (*res)[ ii];
+      }
+    return res;
+  }
+
+  BaseGDL* product( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 1);
+    
+    BaseGDL* p0 = e->GetParDefined( 0);
+    
+    SizeT nEl = p0->N_Elements();
+    if( nEl == 0)
+      e->Throw( "Variable is undefined: "+e->GetParString(0));
+    
+    if( p0->Type() == GDL_STRING)
+      e->Throw( "String expression not allowed "
+		"in this context: "+e->GetParString(0));
+    
+    static int cumIx = e->KeywordIx( "CUMULATIVE");
+    static int nanIx = e->KeywordIx( "NAN");
+    static int intIx = e->KeywordIx("INTEGER");
+    static int preIx = e->KeywordIx("PRESERVE_TYPE");
+    bool KwCumul     = e->KeywordSet( cumIx);
+    bool KwNaN       = e->KeywordSet( nanIx);
+    bool KwInt       = e->KeywordSet( intIx);
+    bool KwPre       = e->KeywordSet( preIx);
+    bool nanInt=false;
+    
+    DLong sumDim = 0;
+    if( nParam == 2)
+      e->AssureLongScalarPar( 1, sumDim);
+    
+    if( sumDim == 0) {
+	if( !KwCumul) {
+          if (KwPre) 
+          {
+            switch (p0->Type())
+            {
+              case GDL_BYTE: return product_template<DByteGDL>(static_cast<DByteGDL*>(p0), nanInt);
+              case GDL_INT: return product_template<DIntGDL>(static_cast<DIntGDL*>(p0), nanInt);
+              case GDL_UINT: return product_template<DUIntGDL>(static_cast<DUIntGDL*>(p0), nanInt);
+              case GDL_LONG: return product_template<DLongGDL>(static_cast<DLongGDL*>(p0), nanInt);
+              case GDL_ULONG: return product_template<DULongGDL>(static_cast<DULongGDL*>(p0), nanInt);
+              case GDL_LONG64: return product_template<DLong64GDL>(static_cast<DLong64GDL*>(p0), nanInt);
+              case GDL_ULONG64: return product_template<DULong64GDL>(static_cast<DULong64GDL*>(p0), nanInt);
+              case GDL_FLOAT: return product_template<DFloatGDL>(static_cast<DFloatGDL*>(p0), KwNaN);
+              case GDL_DOUBLE: return product_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0), KwNaN);
+              case GDL_COMPLEX: return product_template<DComplexGDL>(static_cast<DComplexGDL*>(p0), KwNaN);
+              case GDL_COMPLEXDBL: return product_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0), KwNaN);
+              default: assert(false);
+            }
+          }
+
+	  // Integer parts derivated from Total code by Erin Sheldon
+	  // In IDL PRODUCT(), the INTEGER keyword takes precedence 
+	  if (KwInt) {
+	    // We use GDL_LONG64 unless the input is GDL_ULONG64
+	    if ((p0->Type() == GDL_LONG64) && (!KwNaN)) {
+	      return product_template<DLong64GDL>
+		( static_cast<DLong64GDL*>(p0), nanInt );
+	    }
+	    if ((p0->Type() == GDL_ULONG64) && (!KwNaN)) {
+	      return product_template<DULong64GDL>
+		(static_cast<DULong64GDL*>(p0), nanInt );
+	    }
+	    
+	    // Convert to Long64
+	    DLong64GDL* p0L64 = static_cast<DLong64GDL*>
+	      (p0->Convert2( GDL_LONG64, BaseGDL::COPY));
+	    Guard<DLong64GDL> guard( p0L64);
+	    if (KwNaN) {
+	      DFloatGDL* p0f = static_cast<DFloatGDL*>
+		(p0->Convert2( GDL_FLOAT, BaseGDL::COPY));
+	      Guard<DFloatGDL> guard( p0f);
+	      for( SizeT i=0; i<nEl; ++i) {
+		if (!isfinite((*p0f)[i])) (*p0L64)[i]=1;
+	      }
+	    }
+	    return product_template<DLong64GDL>( p0L64, nanInt);	      
+	  } // integer results
+	  
+	  if( p0->Type() == GDL_DOUBLE) {
+	    return product_template<DDoubleGDL>
+	      ( static_cast<DDoubleGDL*>(p0), KwNaN); 
+	  }
+	  if( p0->Type() == GDL_COMPLEXDBL) {
+	    return product_template<DComplexDblGDL>
+	      ( static_cast<DComplexDblGDL*>(p0), KwNaN); 
+	  }
+	  if( p0->Type() == GDL_COMPLEX) {
+	    DComplexDblGDL* p0D = static_cast<DComplexDblGDL*>
+	      (p0->Convert2( GDL_COMPLEXDBL,BaseGDL::COPY));
+	    Guard<DComplexDblGDL> p0D_guard( p0D);
+	    //p0D_guard.Reset( p0D);
+	    return product_template<DComplexDblGDL>( p0D, KwNaN); 
+	  }
+	  
+	  DDoubleGDL* p0D = static_cast<DDoubleGDL*>
+	    (p0->Convert2( GDL_DOUBLE, BaseGDL::COPY));
+	  Guard<DDoubleGDL> p0D_guard( p0D);
+	  //	    p0D_guard.Reset( p0D);
+	  return product_template<DDoubleGDL>( p0D, KwNaN);
+	} 
+	else
+	  { // KwCumul
+
+            if (KwPre) 
+            {
+              switch (p0->Type())
+              {
+                case GDL_BYTE: return product_cu_template<DByteGDL>(static_cast<DByteGDL*>(p0)->Dup(), nanInt);
+                case GDL_INT: return product_cu_template<DIntGDL>(static_cast<DIntGDL*>(p0)->Dup(), nanInt);
+                case GDL_UINT: return product_cu_template<DUIntGDL>(static_cast<DUIntGDL*>(p0)->Dup(), nanInt);
+                case GDL_LONG: return product_cu_template<DLongGDL>(static_cast<DLongGDL*>(p0)->Dup(), nanInt);
+                case GDL_ULONG: return product_cu_template<DULongGDL>(static_cast<DULongGDL*>(p0)->Dup(), nanInt);
+                case GDL_LONG64: return product_cu_template<DLong64GDL>(static_cast<DLong64GDL*>(p0)->Dup(), nanInt);
+                case GDL_ULONG64: return product_cu_template<DULong64GDL>(static_cast<DULong64GDL*>(p0)->Dup(), nanInt);
+                case GDL_FLOAT: return product_cu_template<DFloatGDL>(static_cast<DFloatGDL*>(p0)->Dup(), KwNaN);
+                case GDL_DOUBLE: return product_cu_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0)->Dup(), KwNaN);
+                case GDL_COMPLEX: return product_cu_template<DComplexGDL>(static_cast<DComplexGDL*>(p0)->Dup(), KwNaN);
+                case GDL_COMPLEXDBL: return product_cu_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0)->Dup(), KwNaN);
+                default: assert(false);
+              }
+            }
+
+	    // Integer parts derivated from Total code by Erin Sheldon
+	    // In IDL PRODUCT(), the INTEGER keyword takes precedence 
+	    if (KwInt) {
+	      // We use GDL_LONG64 unless the input is GDL_ULONG64
+	      if ((p0->Type() == GDL_LONG64) && (!KwNaN)) {
+		return product_cu_template<DLong64GDL>
+		  ( static_cast<DLong64GDL*>(p0)->Dup(), nanInt);
+	      }
+	      if ((p0->Type() == GDL_ULONG64) && (!KwNaN)) {
+		return product_cu_template<DULong64GDL>
+		  ( static_cast<DULong64GDL*>(p0)->Dup(), nanInt);
+	      }
+	      // Convert to Long64
+	      DLong64GDL* p0L64 = static_cast<DLong64GDL*>
+		(p0->Convert2( GDL_LONG64, BaseGDL::COPY));
+	      Guard<DLong64GDL> guard( p0L64);
+	      if (KwNaN) {
+		DFloatGDL* p0f = static_cast<DFloatGDL*>
+		  (p0->Convert2( GDL_FLOAT, BaseGDL::COPY));
+		Guard<DFloatGDL> guard( p0f);
+		for( SizeT i=0; i<nEl; ++i) {
+		  if (!isfinite((*p0f)[i])) (*p0L64)[i]=1;
+		}
+	      }
+	      return product_cu_template<DLong64GDL>
+		((p0L64)->Dup(), nanInt);	      
+	    } // integer results
+	      
+	      // special case as GDL_DOUBLE type overrides /GDL_DOUBLE
+	    if (p0->Type() == GDL_DOUBLE) {
+	      return product_cu_template< DDoubleGDL>
+		( static_cast<DDoubleGDL*>(p0)->Dup(), KwNaN);
+	    }
+	    if (p0->Type() == GDL_COMPLEXDBL) {
+	      return product_cu_template< DComplexDblGDL>
+		( static_cast<DComplexDblGDL*>(p0)->Dup(), KwNaN);
+	    }
+	    if (p0->Type() == GDL_COMPLEX) {
+	      return product_cu_template< DComplexDblGDL>
+		( static_cast<DComplexDblGDL*>
+		  (p0->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY)), KwNaN);
+	    }
+	    return product_cu_template< DDoubleGDL>
+	      ( static_cast<DDoubleGDL*>
+		(p0->Convert2( GDL_DOUBLE, BaseGDL::COPY)), KwNaN);
+	  }
+    }
+    
+    // product over sumDim
+    dimension srcDim = p0->Dim();
+    SizeT srcRank = srcDim.Rank();
+    
+    if( sumDim < 1 || sumDim > srcRank)
+      e->Throw( "Array must have "+i2s(sumDim)+
+		" dimensions: "+e->GetParString(0));
+    
+    if (!KwCumul) {
+
+      if (KwPre) 
+      {
+        switch (p0->Type())
+        {
+          case GDL_BYTE: return product_over_dim_template<DByteGDL>(static_cast<DByteGDL*>(p0), srcDim, sumDim-1, nanInt);
+          case GDL_INT: return product_over_dim_template<DIntGDL>(static_cast<DIntGDL*>(p0), srcDim, sumDim-1, nanInt);
+          case GDL_UINT: return product_over_dim_template<DUIntGDL>(static_cast<DUIntGDL*>(p0), srcDim, sumDim-1, nanInt);
+          case GDL_LONG: return product_over_dim_template<DLongGDL>(static_cast<DLongGDL*>(p0), srcDim, sumDim-1, nanInt);
+          case GDL_ULONG: return product_over_dim_template<DULongGDL>(static_cast<DULongGDL*>(p0), srcDim, sumDim-1, nanInt);
+          case GDL_LONG64: return product_over_dim_template<DLong64GDL>(static_cast<DLong64GDL*>(p0), srcDim, sumDim-1, nanInt);
+          case GDL_ULONG64: return product_over_dim_template<DULong64GDL>(static_cast<DULong64GDL*>(p0), srcDim, sumDim-1, nanInt);
+          case GDL_FLOAT: return product_over_dim_template<DFloatGDL>(static_cast<DFloatGDL*>(p0), srcDim, sumDim-1, KwNaN);
+          case GDL_DOUBLE: return product_over_dim_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0), srcDim, sumDim-1, KwNaN);
+          case GDL_COMPLEX: return product_over_dim_template<DComplexGDL>(static_cast<DComplexGDL*>(p0), srcDim, sumDim-1, KwNaN);
+          case GDL_COMPLEXDBL: return product_over_dim_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0), srcDim, sumDim-1, KwNaN);
+          default: assert(false);
+        }
+      }
+
+      // Integer parts derivated from Total code by Erin Sheldon
+      // In IDL PRODUCT(), the INTEGER keyword takes precedence 
+      if (KwInt) {	  
+	// We use GDL_LONG64 unless the input is GDL_ULONG64
+	if ((p0->Type() == GDL_LONG64 ) && (!KwNaN)) {
+	  return product_over_dim_template<DLong64GDL>
+	    ( static_cast<DLong64GDL*>(p0), srcDim, sumDim-1, nanInt);
+	}
+	if ((p0->Type() == GDL_ULONG64) && (!KwNaN)) {
+	  return product_over_dim_template<DULong64GDL>
+	    ( static_cast<DULong64GDL*>(p0), srcDim, sumDim-1, nanInt);
+	}
+	
+	// Conver to Long64
+	DLong64GDL* p0L64 = static_cast<DLong64GDL*>
+	  (p0->Convert2( GDL_LONG64, BaseGDL::COPY));
+	Guard<DLong64GDL> guard( p0L64);
+	if (KwNaN) {
+	  DFloatGDL* p0f = static_cast<DFloatGDL*>
+	    (p0->Convert2( GDL_FLOAT, BaseGDL::COPY));
+	  Guard<DFloatGDL> guard( p0f);
+	  for( SizeT i=0; i<nEl; ++i) {
+	    if (!isfinite((*p0f)[i])) (*p0L64)[i]=1;
+	  }
+	}
+	return product_over_dim_template<DLong64GDL>
+	  ( p0L64, srcDim, sumDim-1, nanInt);
+      } // integer results
+      
+      if( p0->Type() == GDL_DOUBLE) {
+	return product_over_dim_template< DDoubleGDL>
+	  ( static_cast<DDoubleGDL*>(p0), srcDim, sumDim-1, KwNaN);
+      }
+      if( p0->Type() == GDL_COMPLEXDBL) {
+	return product_over_dim_template< DComplexDblGDL>
+	  ( static_cast<DComplexDblGDL*>(p0), srcDim, sumDim-1, KwNaN);
+      }
+      if( p0->Type() == GDL_COMPLEX) {
+	DComplexDblGDL* p0D = static_cast<DComplexDblGDL*>
+	  (p0->Convert2( GDL_COMPLEXDBL,BaseGDL::COPY));
+	Guard<DComplexDblGDL> p0D_guard( p0D);
+	//	    p0D_guard.Reset( p0D);
+	return product_over_dim_template< DComplexDblGDL>
+	  ( p0D, srcDim, sumDim-1, KwNaN);
+      }
+	
+      DDoubleGDL* p0D = static_cast<DDoubleGDL*>
+	(p0->Convert2( GDL_DOUBLE,BaseGDL::COPY));
+      Guard<DDoubleGDL> p0D_guard( p0D);
+      //p0D_guard.Reset( p0D);
+      return product_over_dim_template< DDoubleGDL>
+	( p0D, srcDim, sumDim-1,KwNaN);
+    } 
+    else
+      { // KwCumul
+
+        if (KwPre) 
+        {
+          switch (p0->Type())
+          {
+            case GDL_BYTE: return product_over_dim_cu_template<DByteGDL>(static_cast<DByteGDL*>(p0)->Dup(), sumDim-1, nanInt);
+            case GDL_INT: return product_over_dim_cu_template<DIntGDL>(static_cast<DIntGDL*>(p0)->Dup(), sumDim-1, nanInt);
+            case GDL_UINT: return product_over_dim_cu_template<DUIntGDL>(static_cast<DUIntGDL*>(p0)->Dup(), sumDim-1, nanInt);
+            case GDL_LONG: return product_over_dim_cu_template<DLongGDL>(static_cast<DLongGDL*>(p0)->Dup(), sumDim-1, nanInt);
+            case GDL_ULONG: return product_over_dim_cu_template<DULongGDL>(static_cast<DULongGDL*>(p0)->Dup(), sumDim-1, nanInt);
+            case GDL_LONG64: return product_over_dim_cu_template<DLong64GDL>(static_cast<DLong64GDL*>(p0)->Dup(), sumDim-1, nanInt);
+            case GDL_ULONG64: return product_over_dim_cu_template<DULong64GDL>(static_cast<DULong64GDL*>(p0)->Dup(), sumDim-1, nanInt);
+            case GDL_FLOAT: return product_over_dim_cu_template<DFloatGDL>(static_cast<DFloatGDL*>(p0)->Dup(), sumDim-1, KwNaN);
+            case GDL_DOUBLE: return product_over_dim_cu_template<DDoubleGDL>(static_cast<DDoubleGDL*>(p0)->Dup(), sumDim-1, KwNaN);
+            case GDL_COMPLEX: return product_over_dim_cu_template<DComplexGDL>(static_cast<DComplexGDL*>(p0)->Dup(), sumDim-1, KwNaN);
+            case GDL_COMPLEXDBL: return product_over_dim_cu_template<DComplexDblGDL>(static_cast<DComplexDblGDL*>(p0)->Dup(), sumDim-1, KwNaN);
+            default: assert(false);
+          }
+        }
+
+	// Integer parts derivated from Total code by Erin Sheldon
+	// In IDL PRODUCT(), the INTEGER keyword takes precedence 
+	if (KwInt) {
+	  // We use GDL_LONG64 unless the input is GDL_ULONG64
+	  if ((p0->Type() == GDL_LONG64) && (!KwNaN)) {
+	  return product_over_dim_cu_template<DLong64GDL>
+	    ( static_cast<DLong64GDL*>(p0)->Dup(), sumDim-1, nanInt);
+	}
+	if ((p0->Type() == GDL_ULONG64 ) && (!KwNaN)) {
+	  return product_over_dim_cu_template<DULong64GDL>
+	    ( static_cast<DULong64GDL*>(p0)->Dup(), sumDim-1, nanInt);
+	}
+	  
+	// Convert to Long64
+	if (KwNaN) {
+	  DFloatGDL* p0f = static_cast<DFloatGDL*>
+	    (p0->Convert2( GDL_FLOAT, BaseGDL::COPY));
+	  Guard<DFloatGDL> guard( p0f);
+	  for( SizeT i=0; i<nEl; ++i) {
+	    if (!isfinite((*p0f)[i])) (*p0f)[i]=1;
+	  }
+	  return product_over_dim_cu_template<DLong64GDL>
+	    ( static_cast<DLong64GDL*>
+	      (p0f->Convert2( GDL_LONG64, BaseGDL::COPY)), sumDim-1, nanInt);  
+	} else {
+	  return product_over_dim_cu_template<DLong64GDL>
+	    ( static_cast<DLong64GDL*>
+	      (p0->Convert2( GDL_LONG64, BaseGDL::COPY)), sumDim-1, nanInt);
+	}
+	} // integer results
+	
+	if( p0->Type() == GDL_DOUBLE) {
+	  return product_over_dim_cu_template< DDoubleGDL>
+	    ( static_cast<DDoubleGDL*>(p0)->Dup(), sumDim-1, KwNaN);
+	}
+	if( p0->Type() == GDL_COMPLEXDBL) {
+	  return product_over_dim_cu_template< DComplexDblGDL>
+	    ( static_cast<DComplexDblGDL*>(p0)->Dup(), sumDim-1, KwNaN);
+	}
+	if( p0->Type() == GDL_COMPLEX) {
+	  return product_over_dim_cu_template< DComplexDblGDL>
+	    ( static_cast<DComplexDblGDL*>
+	      (p0->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY)), sumDim-1, KwNaN);
+	}
+      
+	return product_over_dim_cu_template< DDoubleGDL>
+	  ( static_cast<DDoubleGDL*>
+	    (p0->Convert2( GDL_DOUBLE, BaseGDL::COPY)), sumDim-1, KwNaN);
+      }
+  }
+
+  BaseGDL* array_equal( EnvT* e)
+  {
+    e->NParam( 2);//, "ARRAY_EQUAL");
+
+    BaseGDL* p0 = e->GetParDefined( 0);//, "ARRAY_EQUAL");
+    BaseGDL* p1 = e->GetParDefined( 1);//, "ARRAY_EQUAL");
+
+    if( p0 == p1) return new DByteGDL( 1);
+
+    SizeT nEl0 = p0->N_Elements();
+    SizeT nEl1 = p1->N_Elements();
+    if( nEl0 != nEl1 && nEl0 != 1 && nEl1 != 1)
+      return new DByteGDL( 0);
+    
+    Guard<BaseGDL> p0_guard;
+    Guard<BaseGDL> p1_guard;
+    if( p0->Type() != p1->Type())
+      {
+	if( e->KeywordSet( 0)) // NO_TYPECONV
+	  return new DByteGDL( 0);
+	else
+	  {
+	    DType aTy=p0->Type();
+	    DType bTy=p1->Type();
+	    if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+	      {
+		p1 = p1->Convert2( aTy, BaseGDL::COPY);
+		p1_guard.Reset( p1);
+	      }
+	    else
+	      {
+		p0 = p0->Convert2( bTy, BaseGDL::COPY);
+		p0_guard.Reset( p0);
+	      }
+	  }
+      }
+    
+    if( p0->ArrayEqual( p1)) return new DByteGDL( 1);
+
+    return new DByteGDL( 0);
+  }
+
+  BaseGDL* min_fun( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 1);
+    BaseGDL* searchArr = e->GetParDefined( 0);
+
+    bool omitNaN = e->KeywordSet( "NAN");
+
+    static int subIx = e->KeywordIx("SUBSCRIPT_MAX");
+    bool subMax = e->KeywordPresent(subIx);  
+    
+    static int dimIx = e->KeywordIx("DIMENSION");
+    bool dimSet = e->KeywordSet(dimIx);
+
+    static int maxIx = e->KeywordIx("MAX");
+    bool maxSet = e->KeywordPresent(maxIx);
+
+    DLong searchDim; 
+    if (dimSet) {
+      e->AssureLongScalarKW(dimIx, searchDim);
+      if (searchDim < 0 || searchDim > searchArr->Rank())
+        e->Throw("Illegal keyword value for DIMENSION");
+    }
+
+    if (dimSet && searchArr->Rank() > 1) 
+    {
+      searchDim -= 1; // user-supplied dimensions start with 1!
+
+      // here destDim is in fact the srcDim...
+      dimension destDim = searchArr->Dim();
+      SizeT searchStride = destDim.Stride(searchDim);
+      SizeT outerStride = destDim.Stride(searchDim + 1);
+      // ... and now becomes the destDim
+      SizeT nSearch = destDim.Remove(searchDim);
+      SizeT searchLimit = nSearch * searchStride;
+      SizeT nEl = searchArr->N_Elements();
+
+      // memory allocation
+      BaseGDL *maxVal, *resArr = searchArr->New(destDim, BaseGDL::NOZERO);
+      DLongGDL *minElArr, *maxElArr;
+
+      if (maxSet) 
+      {
+        e->AssureGlobalKW(maxIx); // instead of using a guard pointer
+        maxVal = searchArr->New(destDim, BaseGDL::NOZERO);
+      }
+
+      if (subMax) 
+      { 
+        e->AssureGlobalKW(subIx); // instead of using a guard pointer
+        maxElArr = new DLongGDL(destDim);
+      }
+
+      if (nParam == 2) 
+      {
+        e->AssureGlobalPar(1);    // instead of using a guard pointer
+        minElArr = new DLongGDL(destDim);
+      }
+
+      SizeT rIx = 0;
+      for (SizeT o = 0; o < nEl; o += outerStride) for (SizeT i = 0; i < searchStride; ++i)
+      {
+        searchArr->MinMax(
+          (nParam == 2 ? &((*minElArr)[rIx]) : NULL), 
+          (subMax      ? &((*maxElArr)[rIx]) : NULL), 
+          &resArr, 
+          (maxSet      ? &maxVal             : NULL), 
+          omitNaN, o + i, searchLimit + o + i, searchStride, rIx
+        );
+        rIx++;
+      }
+
+      if (nParam == 2) e->SetPar(1, minElArr);
+      if (subMax) e->SetKW(subIx, maxElArr);
+      if (maxSet) e->SetKW(maxIx, maxVal);
+
+      return resArr;
+    } 
+    else 
+    {
+      DLong minEl;
+      BaseGDL* res;
+
+      if (maxSet) // MAX keyword given
+      {
+        e->AssureGlobalKW( 0);
+        GDLDelete(e->GetKW( 0));
+        DLong maxEl;
+        searchArr->MinMax( &minEl, &maxEl, &res, &e->GetKW( 0), omitNaN);
+        if (subMax) e->SetKW(subIx, new DLongGDL(maxEl));
+      }
+      else // no MAX keyword
+      {
+        if (subMax)
+        {
+          DLong maxEl;
+          searchArr->MinMax( &minEl, &maxEl, &res, NULL, omitNaN);
+          e->SetKW(subIx, new DLongGDL(maxEl));
+        }
+        else searchArr->MinMax(&minEl, NULL, &res, NULL, omitNaN);
+      }
+    
+      // handle index
+      if (nParam == 2) e->SetPar(1, new DLongGDL( minEl));
+      else SysVar::SetC( minEl);
+      return res;
+    }
+  }
+
+  BaseGDL* max_fun( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 1);
+    BaseGDL* searchArr = e->GetParDefined( 0);
+
+    bool omitNaN = e->KeywordSet( "NAN");
+
+    static int subIx = e->KeywordIx("SUBSCRIPT_MIN");
+    bool subMin = e->KeywordPresent(subIx);  
+
+    static int dimIx = e->KeywordIx("DIMENSION");
+    bool dimSet = e->KeywordSet(dimIx);
+
+    static int minIx = e->KeywordIx("MIN");
+    bool minSet = e->KeywordPresent(minIx);
+
+    DLong searchDim; 
+    if (dimSet) 
+    {
+      e->AssureLongScalarKW(dimIx, searchDim);
+      if (searchDim < 0 || searchDim > searchArr->Rank())
+        e->Throw("Illegal keyword value for DIMENSION");
+    }
+
+    if (dimSet && searchArr->Rank() > 1) 
+    {
+      searchDim -= 1; // user-supplied dimensions start with 1!
+
+      // here destDim is in fact the srcDim...
+      dimension destDim = searchArr->Dim();
+      SizeT searchStride = destDim.Stride(searchDim);
+      SizeT outerStride = destDim.Stride(searchDim + 1);
+      // ... and now becomes the destDim
+      SizeT nSearch = destDim.Remove(searchDim);
+      SizeT searchLimit = nSearch * searchStride;
+      SizeT nEl = searchArr->N_Elements();
+
+      // memory allocation
+      BaseGDL *minVal, *resArr = searchArr->New(destDim, BaseGDL::NOZERO);
+      DLongGDL *minElArr, *maxElArr;
+
+      if (minSet) 
+      {    
+        e->AssureGlobalKW(minIx); // instead of using a guard pointer
+        minVal = searchArr->New(destDim, BaseGDL::NOZERO);
+      }    
+
+      if (subMin) 
+      {    
+        e->AssureGlobalKW(subIx); // instead of using a guard pointer
+        minElArr = new DLongGDL(destDim);
+      }    
+
+      if (nParam == 2) 
+      {    
+        e->AssureGlobalPar(1);    // instead of using a guard pointer
+        maxElArr = new DLongGDL(destDim);
+      }
+
+      SizeT rIx = 0;
+      for (SizeT o = 0; o < nEl; o += outerStride) for (SizeT i = 0; i < searchStride; ++i)
+      {
+        searchArr->MinMax(
+          (subMin      ? &((*minElArr)[rIx]) : NULL),
+          (nParam == 2 ? &((*maxElArr)[rIx]) : NULL),
+          (minSet      ? &minVal             : NULL),
+          &resArr,
+          omitNaN, o + i, searchLimit + o + i, searchStride, rIx
+        );
+        rIx++;
+      }
+
+      if (nParam == 2) e->SetPar(1, maxElArr);
+      if (subMin) e->SetKW(subIx, minElArr);
+      if (minSet) e->SetKW(minIx, minVal);
+
+      return resArr;
+    }
+    else 
+    {
+      DLong maxEl;
+      BaseGDL* res;
+
+      if (minSet) // MIN keyword given
+      {
+        e->AssureGlobalKW( 0);
+        GDLDelete(e->GetKW( 0));
+        DLong minEl;
+        searchArr->MinMax( &minEl, &maxEl, &e->GetKW( 0), &res, omitNaN);
+	if (subMin) e->SetKW(subIx, new DLongGDL(minEl));
+      }
+      else // no MIN keyword
+      {
+	if (subMin)
+        {
+          DLong minEl;
+          searchArr->MinMax( &minEl, &maxEl, NULL, &res, omitNaN);
+          e->SetKW(subIx, new DLongGDL(minEl));
+        }
+	else searchArr->MinMax(NULL, &maxEl, NULL, &res, omitNaN);
+      }
+
+      // handle index
+      if (nParam == 2) e->SetPar(1, new DLongGDL( maxEl));
+      else SysVar::SetC(maxEl);
+      return res;
+    }
+  }
+ 
+BaseGDL* transpose( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 1); 
+
+    BaseGDL* p0 = e->GetParDefined( 0);
+    if( p0->Type() == GDL_STRUCT)
+      e->Throw("Struct expression not allowed in this context: "+
+	       e->GetParString(0));
+    
+    SizeT rank = p0->Rank();
+    if( rank == 0)
+      e->Throw( "Expression must be an array "
+		"in this context: "+ e->GetParString(0));
+    
+    if( nParam == 2) 
+      {
+ 
+	BaseGDL* p1 = e->GetParDefined( 1);
+	if( p1->N_Elements() != rank)
+	  e->Throw("Incorrect number of elements in permutation.");
+
+	DUInt* perm = new DUInt[rank];
+	Guard<DUInt> perm_guard( perm);
+
+	DUIntGDL* p1L = static_cast<DUIntGDL*>
+	  (p1->Convert2( GDL_UINT, BaseGDL::COPY));
+	for( SizeT i=0; i<rank; ++i) perm[i] = (*p1L)[ i];
+	GDLDelete(p1L);
+
+	// check permutation vector
+	for( SizeT i=0; i<rank; ++i) 
+	  {
+	    DUInt j;
+	    for( j=0; j<rank; ++j) if( perm[j] == i) break;
+	    if (j == rank)
+	      e->Throw( "Incorrect permutation vector.");
+	  }
+	return p0->Transpose( perm);
+      }
+
+    return p0->Transpose( NULL);
+  }
+
+
+// BaseGDL* matrix_multiply( EnvT* e)
+//   {
+//     SizeT nParam=e->NParam( 2); 
+// 
+//     BaseGDL* a = e->GetNumericArrayParDefined( 0);
+//     BaseGDL* b = e->GetNumericArrayParDefined( 1);
+//     
+//     static int aTIx = e->KeywordIx("ATRANSPOSE");
+//     bool aT = e->KeywordPresent(aTIx);
+//     static int bTIx = e->KeywordIx("BTRANSPOSE");
+//     bool bT = e->KeywordPresent(bTIx);
+//     
+//     static int strassenIx = e->KeywordIx("STRASSEN_ALGORITHM");
+//     bool strassen = e->KeywordPresent(strassenIx);
+// 
+//     
+//     if( p1->N_Elements() != rank)
+// 	  e->Throw("Incorrect number of elements in permutation.");
+// 
+// 	DUInt* perm = new DUInt[rank];
+// 	Guard<DUInt> perm_guard( perm);
+// 
+// 	DUIntGDL* p1L = static_cast<DUIntGDL*>
+// 	  (p1->Convert2( GDL_UINT, BaseGDL::COPY));
+// 	for( SizeT i=0; i<rank; ++i) perm[i] = (*p1L)[ i];
+// 	delete p1L;
+// 
+// 	// check permutaion vector
+// 	for( SizeT i=0; i<rank; ++i) 
+// 	  {
+// 	    DUInt j;
+// 	    for( j=0; j<rank; ++j) if( perm[j] == i) break;
+// 	    if (j == rank)
+// 	      e->Throw( "Incorrect permutation vector.");
+// 	  }
+// 	return p0->Transpose( perm);
+//       }
+// 
+//     return a->Transpose( NULL);
+//   }
+
+  // helper function for sort_fun, recursive
+  // optimized version
+  template< typename IndexT>
+  void MergeSortOpt( BaseGDL* p0, IndexT* hhS, IndexT* h1, IndexT* h2,
+		     SizeT len) 
+  {
+    if( len <= 1) return;       
+
+    SizeT h1N = len / 2;
+    SizeT h2N = len - h1N;
+
+    // 1st half
+    MergeSortOpt(p0, hhS, h1, h2, h1N);
+
+    // 2nd half
+    IndexT* hhM = &hhS[h1N]; 
+    MergeSortOpt(p0, hhM, h1, h2, h2N);
+
+    SizeT i;
+    for(i=0; i<h1N; ++i) h1[i] = hhS[ i];
+    for(i=0; i<h2N; ++i) h2[i] = hhM[ i];
+
+    SizeT  h1Ix = 0;
+    SizeT  h2Ix = 0;
+    for( i=0; (h1Ix < h1N) && (h2Ix < h2N); ++i) 
+      {
+	// the actual comparisson
+	if( p0->Greater( h1[h1Ix], h2[h2Ix])) 
+	  hhS[ i] = h2[ h2Ix++];
+	else
+	  hhS[ i] = h1[ h1Ix++];
+      }
+    for(; h1Ix < h1N; ++i) hhS[ i] = h1[ h1Ix++];
+    for(; h2Ix < h2N; ++i) hhS[ i] = h2[ h2Ix++];
+  }
+
+  // helper function for sort_fun, recursive
+  void MergeSort( BaseGDL* p0, SizeT* hh, SizeT* h1, SizeT* h2,
+		  SizeT start, SizeT end) 
+  {
+    if( start+1 >= end) return;       
+
+    SizeT middle = (start+end) / 2;
+
+    MergeSort(p0, hh, h1, h2, start, middle);
+    MergeSort(p0, hh, h1, h2, middle, end);
+
+    SizeT h1N = middle - start;
+    SizeT h2N = end - middle;
+
+    SizeT* hhS = &hh[start];
+
+    SizeT i;
+    for(i=0; i<h1N; ++i) h1[i] = hhS[ i];
+    for(i=0; i<h2N; ++i) h2[i] = hh[middle + i];
+
+    SizeT  h1Ix = 0;
+    SizeT  h2Ix = 0;
+    for( i=0; (h1Ix < h1N) && (h2Ix < h2N); ++i) 
+      {
+	// the actual comparisson
+	if( p0->Greater( h1[h1Ix], h2[h2Ix])) 
+	  hhS[ i] = h2[ h2Ix++];
+	else
+	  hhS[ i] = h1[ h1Ix++];
+      }
+    for(; h1Ix < h1N; ++i) hhS[ i] = h1[ h1Ix++];
+    for(; h2Ix < h2N; ++i) hhS[ i] = h2[ h2Ix++];
+  }
+
+  // sort function uses MergeSort
+  BaseGDL* sort_fun( EnvT* e)
+  {
+    e->NParam( 1);
+    
+    BaseGDL* p0 = e->GetParDefined( 0);
+
+    if( p0->Type() == GDL_STRUCT)
+      e->Throw( "Struct expression not allowed in this context: "+
+		e->GetParString(0));
+    
+    static int l64Ix = e->KeywordIx( "L64");
+    bool l64 = e->KeywordSet( l64Ix);
+    
+    SizeT nEl = p0->N_Elements();
+    
+    // helper arrays
+    DLongGDL* res = new DLongGDL( dimension( nEl), BaseGDL::INDGEN);
+
+	DLong nanIx = nEl;
+    if( p0->Type() == GDL_FLOAT)
+    {
+		DFloatGDL* p0F = static_cast<DFloatGDL*>(p0);
+		for( DLong i=nEl-1; i >= 0; --i)
+		{
+			if( isnan((*p0F)[ i]) )//|| !isfinite((*p0F)[ i]))
+				{
+					--nanIx;
+					(*res)[i] = (*res)[nanIx];
+					(*res)[ nanIx] = i;
+
+// cout << "swap " << i << " with " << nanIx << endl;
+// cout << "now:     ";
+// 		for( DLong ii=0; ii < nEl; ++ii)
+// 		{
+// 		cout << (*res)[ii] << " ";		
+// 		}
+// cout  << endl;
+				}
+		}
+    }
+    else if( p0->Type() == GDL_DOUBLE)
+    {
+		DDoubleGDL* p0F = static_cast<DDoubleGDL*>(p0);
+		for( DLong i=nEl-1; i >= 0; --i)
+		{
+			if( isnan((*p0F)[ i]))// || !isfinite((*p0F)[ i]))
+				{
+					--nanIx;
+					(*res)[i] = (*res)[nanIx];
+					(*res)[ nanIx] = i;
+				}
+		}
+    }
+    else if( p0->Type() == GDL_COMPLEX)
+    {
+		DComplexGDL* p0F = static_cast<DComplexGDL*>(p0);
+		for( DLong i=nEl-1; i >= 0; --i)
+		{
+			if( isnan((*p0F)[ i].real()) || //!isfinite((*p0F)[ i].real()) ||
+			     isnan((*p0F)[ i].imag()))// || !isfinite((*p0F)[ i].imag()) )
+				{
+					--nanIx;
+					(*res)[i] = (*res)[nanIx];
+					(*res)[ nanIx] = i;
+				}
+		}
+    }
+    else if( p0->Type() == GDL_COMPLEXDBL)
+    {
+		DComplexDblGDL* p0F = static_cast<DComplexDblGDL*>(p0);
+		for( DLong i=nEl-1; i >= 0; --i)
+		{
+			if( isnan((*p0F)[ i].real()) || //!isfinite((*p0F)[ i].real()) ||
+			     isnan((*p0F)[ i].imag()))// || !isfinite((*p0F)[ i].imag()) )
+				{
+					--nanIx;
+					(*res)[i] = (*res)[nanIx];
+					(*res)[ nanIx] = i;
+				}
+		}
+    }
+
+// cout << "nEl " << nEl << " nanIx " << nanIx << endl;
+	nEl = nanIx;
+// cout << "sorting:  ";
+// 		for( DLong ii=0; ii < nEl; ++ii)
+// 		{
+// 		cout << (*res)[ii] << " ";		
+// 		}
+// cout  << endl;
+
+    DLong *hh = static_cast<DLong*>(res->DataAddr());
+
+    DLong* h1 = new DLong[ nEl/2];
+    DLong* h2 = new DLong[ (nEl+1)/2];
+    // call the sort routine
+    MergeSortOpt<DLong>( p0, hh, h1, h2, nEl);
+    delete[] h1;
+    delete[] h2;
+
+    if( l64) 
+      {
+	// leave it this way, as sorting of more than 2^31
+	// items seems not feasible in the future we might 
+	// use MergeSortOpt<DLong64>(...) for this 
+	return res->Convert2( GDL_LONG64);
+      }
+
+    return res;
+  }
+
+  // uses MergeSort
+  // 2 parts in the code: without "width" or with "width" (limited to 1D and 2D)
+  BaseGDL* median( EnvT* e) {
+    
+    BaseGDL* p0 = e->GetParDefined( 0);
+
+    if( p0->Type() == GDL_PTR)
+      e->Throw( "Pointer expression not allowed in this context: "+ e->GetParString(0));
+    if( p0->Type() == GDL_OBJ)
+      e->Throw( "Object expression not allowed in this context: "+ e->GetParString(0));
+    if( p0->Type() == GDL_STRUCT)
+      e->Throw( "Struct expression not allowed in this context: "+ e->GetParString(0));
+
+    if( p0->Rank() == 0)
+      e->Throw( "Expression must be an array in this context: "+ e->GetParString(0));
+
+    SizeT nParam = e->NParam( 1);
+    SizeT nEl = p0->N_Elements();
+    
+    // "f_nan" and "d_nan" used by both parts ...
+    static DStructGDL *Values = SysVar::Values();
+    DFloat f_nan=(*static_cast<DFloatGDL*>(Values->GetTag(Values->Desc()->TagIndex("F_NAN"), 0)))[0];
+    DDouble d_nan=(*static_cast<DDoubleGDL*>(Values->GetTag(Values->Desc()->TagIndex("D_NAN"), 0)))[0];
+    
+    // --------------------------------------------------------
+    // begin of the part 1: without "width" param
+    if( nParam == 1) {
+      
+	static int evenIx = e->KeywordIx( "EVEN");
+	
+	// TYPE
+	bool dbl = 
+          p0->Type() == GDL_DOUBLE || 
+          p0->Type() == GDL_COMPLEXDBL || 
+          e->KeywordSet(e->KeywordIx("DOUBLE"));
+	DType type = dbl ? GDL_DOUBLE : GDL_FLOAT;
+	bool noconv = (dbl && p0->Type() == GDL_DOUBLE) ||
+	  (!dbl && p0->Type() == GDL_FLOAT);
+
+	// DIMENSION keyword
+	DLong dim = 0;
+	DLong nmed = 1;
+	BaseGDL *res;
+	e->AssureLongScalarKWIfPresent( "DIMENSION", dim);
+
+	//	cout << "dim : "<< dim << endl;
+	
+	if (dim > p0->Rank())
+	  e->Throw( "Illegal keyword value for DIMENSION.");
+	
+	if (dim > 0) {
+	  DLong dims[8];
+	  DLong k = 0;
+	  for (SizeT i=0; i<p0->Rank(); ++i)
+	    if (i != (dim-1)) {
+	      nmed *= p0->Dim(i);
+	      dims[k++] = p0->Dim(i);
+	    }
+	  dimension dimRes((DLong *) dims, p0->Rank()-1);
+	  res = dbl 
+            ? static_cast<BaseGDL*>(new DDoubleGDL(dimRes, BaseGDL::NOZERO))
+            : static_cast<BaseGDL*>(new DFloatGDL(dimRes, BaseGDL::NOZERO));
+	} else {
+	  res = dbl 
+            ? static_cast<BaseGDL*>(new DDoubleGDL(1))
+            : static_cast<BaseGDL*>(new DFloatGDL(1));
+	}
+
+	// conversion of Complex types
+	if (p0->Type() == GDL_COMPLEX) p0 = p0->Convert2(GDL_FLOAT, BaseGDL::COPY);
+	if (p0->Type() == GDL_COMPLEXDBL) p0 = p0->Convert2(GDL_DOUBLE, BaseGDL::COPY);
+
+	// helper arrays
+	if (nmed > 1) nEl = p0->N_Elements() / nmed;
+	
+	//	cout << "hello2" << endl;
+
+	DLong *hh = new DLong[ nEl];
+	DLong* h1 = new DLong[ nEl/2];
+	DLong* h2 = new DLong[ (nEl+1)/2];
+
+	DLong accumStride = 1;
+	if (nmed > 1)
+	  for( DLong i=0; i<dim-1; ++i) accumStride *= p0->Dim(i);
+
+	BaseGDL *op1, *op2, *op3;
+        if (dbl) op3 = new DDoubleGDL(2);
+        else op3 = new DFloatGDL(2);
+
+	// nEl_extern is used to store "nEl" initial value
+	DLong nanIx, nEl_extern;
+	nEl_extern=nEl;
+	//	if (nmed > 1) nEl_extern = p0->N_Elements() / nmed;
+	//else nEl_extern = p0->N_Elements();
+
+	//	cout << "hello type" << p0->Type() << endl;
+	
+	// Loop over all subarray medians
+	for (SizeT k=0; k<nmed; ++k) {
+	  
+	  //	  nEl=nEl_extern;
+
+	  if (nmed == 1) {
+	    //cout << "hello inside 1D" << endl;
+	    for( DLong i=0; i<nEl; ++i) hh[i] = i;
+	    nanIx = nEl;
+
+	    if (p0->Type() == GDL_DOUBLE) {
+	      DDoubleGDL* p0F = static_cast<DDoubleGDL*>(p0);
+	      for( DLong i=nEl-1; i >= 0; --i) {
+		if( isnan((*p0F)[i])) {
+		  --nanIx;
+		  hh[i] = hh[nanIx];
+		  hh[ nanIx] = i;
+		}
+	      }
+	    }
+	    
+	    if (p0->Type() == GDL_FLOAT) {
+	      DFloatGDL* p0F = static_cast<DFloatGDL*>(p0);
+	      for( DLong i=nEl-1; i >= 0; --i) {
+		if( isnan((*p0F)[i])) {
+		  --nanIx;
+		  hh[i] = hh[nanIx];
+		  hh[ nanIx] = i;
+		}
+	      }
+	    }
+	    
+	    //cout << "nEl " << nEl << " nanIx " << nanIx << endl;
+	    nEl = nanIx;
+	  }
+	  else
+	    {
+	      nanIx = nEl;
+	      nEl=nEl_extern; 
+
+	      //	      DLong nanIx = nEl;
+	      // Starting Element
+	      DLong start = accumStride * p0->Dim(dim-1) * (k / accumStride) + 
+		(k % accumStride);
+	      for( DLong i=0; i<nEl; ++i) hh[i] = start + i * accumStride;
+	      DLong jj;
+	      nanIx = nEl;
+
+	      if (p0->Type() == GDL_FLOAT) {
+		DFloatGDL* p0F = static_cast<DFloatGDL*>(p0);
+		for( DLong i=nEl-1; i >= 0; --i) {
+		  jj=start + i * accumStride;
+		  if( isnan((*p0F)[ jj]) ) {
+		    --nanIx;
+		    hh[i] = hh[nanIx];
+		    hh[ nanIx] = i;
+		  }
+		}
+		nEl = nanIx;
+	      }
+
+	      if (p0->Type() == GDL_DOUBLE) {
+		DDoubleGDL* p0F = static_cast<DDoubleGDL*>(p0);
+		for( DLong i=nEl-1; i >= 0; --i) {
+		  jj=start + i * accumStride;
+		  if( isnan((*p0F)[ jj]) ) {
+		    --nanIx;
+		    hh[i] = hh[nanIx];
+		    hh[ nanIx] = i;
+		  }
+		}
+		//cout << "nanIx :" << nanIx << "nEl :" << nEl << endl;
+		nEl = nanIx;
+	      }
+	    }
+	  DLong medEl, medEl_1;
+
+	  // call the sort routine
+	  if (nEl > 1) {
+	    MergeSortOpt<DLong>( p0, hh, h1, h2, nEl);
+	    medEl = hh[ nEl/2];
+	    medEl_1 = hh[ nEl/2 - 1];
+	  } else {
+	    if (nEl == 1) {
+	      medEl = hh[0];
+	      medEl_1 = hh[0];
+	    } else
+	      { // normal case, more than one element, nothing to do
+		//cout << "gasp : no result ! " << endl;
+	      }
+	  }
+
+	  if (nEl <= 0) { // we have a NaN
+	    if (dbl) (*static_cast<DDoubleGDL*>(res))[k] = d_nan;
+	    else (*static_cast<DFloatGDL*>(res))[k] = f_nan;
+	  } else {
+	    //cout << k << "" << (*static_cast<DFloatGDL*>(p0))[medEl] << " " 
+	    //	 << (*static_cast<DFloatGDL*>(p0))[medEl_1] << endl;
+	    //cout << "k :" << k << endl;
+	    if( (nEl % 2) == 1 || !e->KeywordSet( evenIx)) {
+	      if (nmed == 1)
+		res = p0->NewIx(medEl)->Convert2(type, BaseGDL::CONVERT); 
+	      else {
+		if (noconv) 
+		  {
+		    if (dbl) (*static_cast<DDoubleGDL*>(res))[k] = (*static_cast<DDoubleGDL*>(p0))[medEl];
+		    else (*static_cast<DFloatGDL*>(res))[k] = (*static_cast<DFloatGDL*>(p0))[medEl];
+		  }
+		else 
+		  {
+		    op1 = p0->NewIx(medEl)->Convert2(type, BaseGDL::CONVERT);
+		    if (dbl) (*static_cast<DDoubleGDL*>(res))[k] = (*static_cast<DDoubleGDL*>(op1))[0];
+		    else (*static_cast<DFloatGDL*>(res))[k] = (*static_cast<DFloatGDL*>(op1))[0];
+		    delete(op1);
+		  }
+	      }
+	    } else {
+	      if (noconv) 
+		{
+		  if (dbl) (*static_cast<DDoubleGDL*>(res))[k] = .5 * (
+								       (*static_cast<DDoubleGDL*>(p0))[medEl] + 
+								       (*static_cast<DDoubleGDL*>(p0))[medEl_1]
+								       );
+		  else (*static_cast<DFloatGDL*>(res))[k] = .5 * (
+								  (*static_cast<DFloatGDL*>(p0))[medEl] +
+								  (*static_cast<DFloatGDL*>(p0))[medEl_1]
+								  );
+		}
+	      else
+		{
+		  op1 = p0->NewIx(medEl)->Convert2(type, BaseGDL::CONVERT); 
+		  op2 = p0->NewIx(medEl_1)->Convert2(type, BaseGDL::CONVERT);
+		  if (nmed == 1) res = op2->Add(op1)->Div(op3); // TODO: leak with res?
+		  else 
+		    {
+		      if (dbl) (*static_cast<DDoubleGDL*>(res))[k] =
+				 (*static_cast<DDoubleGDL*>((op2->Add(op1)->Div(op3))))[0];
+		      else (*static_cast<DFloatGDL*>(res))[k] =
+			     (*static_cast<DFloatGDL*>((op2->Add(op1)->Div(op3))))[0];
+		      delete(op2);
+		    }
+		  delete(op1);
+		}
+	    }
+	  }
+	}
+        delete(op3);
+	delete[] h1;
+	delete[] h2;
+	delete[] hh;
+
+	return res;
+    }
+
+    // begin of the part 2: with "width" param
+    if( nParam == 2) {
+      // with parameter Width : median filtering with no optimisation,
+      //  such as histogram algorithms.
+      // Copyright: (C) 2008 by Nicolas Galmiche
+
+      // basic checks on "vector/array" input	
+      DDoubleGDL* p0 = e->GetParAs<DDoubleGDL>( 0);	
+
+      if( p0->Rank() > 2)
+	e->Throw( "Only 1 or 2 dimensions allowed: "+ e->GetParString(0));
+      
+      // basic checks on "width" input		
+      DDoubleGDL* p1d = e->GetParAs<DDoubleGDL>(1);
+ 	
+      if (p1d->N_Elements() > 1 || (*p1d)[0] <=0 ) 
+	e->Throw( "Width must be a positive scalar or 1 (positive) element array in this context: "+ e->GetParString(0));
+      DLong MaxAllowedWidth=0;
+      if (p0->Rank() == 1) MaxAllowedWidth=p0->N_Elements();
+      if (p0->Rank() == 2) {
+	MaxAllowedWidth=p0->Dim(0);
+	if (p0->Dim(1) < MaxAllowedWidth) MaxAllowedWidth=p0->Dim(1);	   
+      }
+      const int debug =0;
+      if (debug == 1) {
+	cout << "X dim " << p0->Dim(0) <<endl;
+	cout << "y dim " << p0->Dim(1) <<endl;	  
+	cout << "MaxAllowedWidth " << MaxAllowedWidth <<endl;
+      }
+	if (!isfinite( (*p1d)[0]))
+	  e->Throw("Width must be > 1, and < dimension of array (NaN or Inf)");
+	
+ 	DLongGDL* p1 = e->GetParAs<DLongGDL>(1);	
+
+	DDoubleGDL *tamp = new DDoubleGDL(p0->Dim(),BaseGDL::NOZERO);
+	DDouble min=((*p0)[0]);
+     	DDouble max=min;
+    	 
+     	for (SizeT ii=0 ; ii<p0->N_Elements() ; ++ii)
+	  {(*tamp)[ii]=(*p0)[ii];
+	    if ( (*p0)[ii] < min ) min = ((*p0)[ii]);
+	    if ( (*p0)[ii] > max ) max = ((*p0)[ii]);
+	  }	
+		
+   	//---------------------------- END d'acquisistion des paramètres -------------------------------------	
+
+	
+	static int evenIx = e->KeywordIx( "EVEN");
+	static int doubleIx = e->KeywordIx( "DOUBLE");
+	static DStructGDL *Values =  SysVar::Values();                                                
+	DDouble d_nan=(*static_cast<DDoubleGDL*>(Values->GetTag(Values->Desc()->TagIndex("D_NAN"), 0)))[0];
+	DDouble d_infinity= (*static_cast<DDoubleGDL*>(Values->GetTag(Values->Desc()->TagIndex("D_INFINITY"), 0)))[0]; 
+ 
+	//------------------------------ Init variables and allocation ---------------------------------------
+	SizeT width=(*p1)[0];
+	SizeT N_MaskElem= width*width;
+	SizeT larg = p0->Stride(1);
+	SizeT haut = p0->Stride(2)/larg;
+	SizeT lim= static_cast<SizeT>(round(width/2));
+	SizeT init=(lim*larg+lim);
+	
+	// we don't go further if dimension(s) versus not width OK
+
+	if (debug == 1) {cout << "ici" <<endl;}
+	
+	if ( p0->Rank() == 1) {
+	  if (larg < width || width==1 ) e->Throw( "Width must be > 1, and < width of vector");
+	} 
+	if ( p0->Rank() == 2) {	
+	  if (larg < width || haut < width || width==1) e->Throw("Width must be > 1, and < dimension of array");
+	}
+
+	// for 2D arrays, we use the algorithm described in paper
+	// from T. Huang, G. Yang, and G. Tang, “A Fast Two-Dimensional Median
+	// Filtering Algorithm,” IEEE Trans. Acoust., Speech, Signal Processing,
+	// vol. 27, no. 1, pp. 13–18, 1979.
+
+	if ( (e->GetParDefined( 0)->Type() == GDL_BYTE ||
+	      e->GetParDefined( 0)->Type() == GDL_INT  || 
+	      e->GetParDefined( 0)->Type() == GDL_UINT ||
+	      e->GetParDefined( 0)->Type() == GDL_LONG ||
+	      e->GetParDefined( 0)->Type() == GDL_ULONG ||
+	      e->GetParDefined( 0)->Type() == GDL_LONG64 ||
+	      e->GetParDefined( 0)->Type() == GDL_ULONG64) &&
+	     (haut>1))
+	  {
+	    SizeT taille=static_cast<SizeT>(abs(max)-min+1);		
+	    DDoubleGDL* Histo = new DDoubleGDL(taille,BaseGDL::NOZERO);
+	    if (width % 2 ==0)
+	      {
+		for(SizeT i=0 ; i<haut-2*lim ; ++i)				
+		  {
+		    SizeT ltmed=0;
+		    SizeT med=0;
+		    SizeT initial=init+i*larg-lim*larg-lim;
+		    for(SizeT pp=0 ; pp<taille;++pp)(*Histo)[pp]=0;	
+		    for (SizeT ii=initial ; ii <initial+ width ; ++ii)
+		      {	
+			for(SizeT yy=0;yy<width;yy++)
+			  (*Histo)[static_cast<SizeT>((*p0)[ii+yy*larg]-min)]++;
+		      }
+		    
+		    while (ltmed+(*Histo)[med]<=(N_MaskElem /2))
+		      {
+			ltmed+= static_cast<SizeT>((*Histo)[med]);
+			++med;
+		      }
+		    if (e->KeywordSet( evenIx))
+		      {
+			
+			SizeT EvenMed=med;
+			//if ((*Histo)[EvenMed]==1 || (ltmed!=0 && ltmed !=(N_MaskElem /2) -1))
+			if ((*Histo)[EvenMed]==1 || (ltmed!=0 && N_MaskElem /2- ltmed!=1) )
+			  {
+			    while ((*Histo)[EvenMed-1]==0)
+			      {  EvenMed--;}
+			    (*tamp)[init+i*larg]=((med+min)+(EvenMed-1+min))/2;
+			  }
+			else
+			  (*tamp)[init+i*larg]=med+min;
+		      }
+		    else
+		      {(*tamp)[init+i*larg]=med+min; }
+		    
+		    for(SizeT j=init+i*larg +1; j<init+(i+1)*larg-2*lim ;++ j)	
+		      {				
+			SizeT initMask=j-lim*larg-lim;			
+			for(SizeT k=0;k<2*lim;++k)			
+			  {	
+			    (*Histo)[static_cast<SizeT>((*p0)[initMask-1+k*larg]-min)]--;
+			    if ((*p0)[initMask-1+k*larg]-min<med)ltmed--;
+				 						
+			    (*Histo)[static_cast<SizeT>((*p0)[initMask+k*larg+2*lim-1]-min)]++;
+			    if ((*p0)[initMask+k*larg+2*lim-1]-min<med)ltmed++;
+			  }
+			if (ltmed>N_MaskElem /2)
+			  {
+			    while(ltmed>N_MaskElem /2)
+			      {
+				--med;
+				ltmed-=static_cast<SizeT>((*Histo)[med]);
+			      }
+			  }
+			else
+			  {
+			    while (ltmed+(*Histo)[med]<=(N_MaskElem /2))
+			      {
+				ltmed+= static_cast<SizeT>((*Histo)[med]);
+				++med;
+			      }	
+			  }
+			
+			if (e->KeywordSet( evenIx))
+			  {
+			    SizeT EvenMed=med;
+			    if ((*Histo)[EvenMed]==1 || (ltmed!=0 &&N_MaskElem /2- ltmed!=1 ))
+			      {
+				while ((*Histo)[EvenMed-1]==0)
+				  {  EvenMed--;}
+				(*tamp)[j]=((med+min)+(EvenMed-1+min))/2;
+			      }
+			    else
+			      {(*tamp)[j]=med+min; }
+			  }
+			else
+			  {(*tamp)[j]=med+min; }
+		      }
+		  } 
+	      }
+	    else
+	      {
+		for(SizeT i=0 ; i<haut-2*lim ; ++i)				
+		  {
+		    SizeT ltmed=0;
+		    SizeT med=0;
+		    SizeT initial=init+i*larg-lim*larg-lim;
+		    for(SizeT pp=0 ; pp<taille;++pp)(*Histo)[pp]=0;	
+		    for (SizeT ii=initial ; ii <initial+ width ; ++ii)
+		      {	
+			for(SizeT yy=0;yy<width;yy++)
+			  (*Histo)[static_cast<SizeT>((*p0)[ii+yy*larg]-min)]++;
+		      }
+
+		    while (ltmed+(*Histo)[med]<=(N_MaskElem /2))
+		      {
+			ltmed+= static_cast<SizeT>((*Histo)[med]);
+			++med;
+		      }
+		    (*tamp)[init+i*larg]=med+min;
+	
+		    for(SizeT j=init+i*larg +1; j<init+(i+1)*larg-2*lim ;++ j)	
+		      {	
+			
+			SizeT initMask=j-lim*larg-lim;			
+			for(SizeT k=0;k<=2*lim;++k)			
+			  {	
+			    (*Histo)[static_cast<SizeT>((*p0)[initMask-1+k*larg]-min)]--;
+			    if ((*p0)[initMask-1+k*larg]-min<med)ltmed--;
+				 						 						 		
+			    (*Histo)[static_cast<SizeT>((*p0)[initMask+k*larg+2*lim]-min)]++;
+			    if ((*p0)[initMask+k*larg+2*lim]-min<med)ltmed++;
+			  }
+			if (ltmed>N_MaskElem /2)
+			  {
+			    while(ltmed>N_MaskElem /2)
+			      {
+				--med;
+				ltmed-=static_cast<SizeT>((*Histo)[med]);
+			      }
+			  }
+			else
+			  {
+			    while (ltmed+(*Histo)[med]<=(N_MaskElem /2))
+			      {
+				ltmed+= static_cast<SizeT>((*Histo)[med]);
+				++med;
+			      }	
+			  }
+			
+			(*tamp)[j]=med+min;
+			
+		      }
+		  } 
+	      }
+	
+	  }
+	else
+	  {	
+	    DLong* hh; 
+	    DLong* h1;
+	    DLong* h2;
+	    DDoubleGDL* Mask,*Mask1D;
+	    if ( p0->Rank() != 1 )
+	      {
+		hh = new DLong[ N_MaskElem];
+    		h1 = new DLong[ N_MaskElem/2];
+		h2= new DLong[ (N_MaskElem+1)/2];
+		Mask = new DDoubleGDL(N_MaskElem,BaseGDL::NOZERO);
+		
+		for( DLong i=0; i<N_MaskElem; ++i) hh[i] = i;
+	      }
+	    else
+	      {
+		hh = new DLong[ width];
+		h1 = new DLong[ width/2];
+		h2= new DLong[(width+1)/2];
+		Mask1D = new DDoubleGDL(width,BaseGDL::NOZERO);
+		
+		for( DLong i=0; i<width; ++i) hh[i] = i;
+	      }
+	
+	    //-------------------------------- END OF VARIABLES INIT ---------------------------------------------
+
+	    //------------------------------ Median Filter Algorithms ---------------------------------------
+	
+	    if ( width % 2 ==0)
+	      {
+		if ( p0->Rank() == 1 )//------------------------  For a vector with even width -------------------
+		  {	
+		    for (SizeT col= lim ; col<larg-lim ; ++col)
+		      {	
+			SizeT ctl_NaN=0;
+			SizeT kk=0;
+			for (SizeT ind=col-lim ; ind<col+lim ; ++ind)
+			  {
+			    if( (*p0)[ind]!=d_infinity && (*p0)[ind]!=-d_infinity && isfinite((*p0)[ind])==0)
+			      ctl_NaN++;
+			    else
+			      {	
+				(*Mask1D)[kk]=(*p0)[ind];
+				kk++;
+			      }
+			  }
+			if (ctl_NaN!=0)
+			  {
+			    if(ctl_NaN==width)(*tamp)[col]= d_nan;
+			    else 
+			      {
+				DLong*	hhbis = new DLong[ width-ctl_NaN];
+				DLong*	h1bis = new DLong[ width-ctl_NaN/2];
+				DLong*	h2bis= new DLong[(width-ctl_NaN+1)/2];
+				DDoubleGDL *Mask1Dbis = new DDoubleGDL(width-ctl_NaN,BaseGDL::NOZERO);
+				for( DLong t=0; t<width-ctl_NaN; ++t) hhbis[t] = t;
+				for( DLong ii=0; ii<width-ctl_NaN; ++ii)(*Mask1Dbis)[ii]=(*Mask1D)[ii];
+				BaseGDL* besort=static_cast<BaseGDL*>(Mask1Dbis);	
+				MergeSortOpt<DLong>( besort, hhbis, h1bis, h2bis,(width - ctl_NaN));
+				if (e->KeywordSet( evenIx)&& (width - ctl_NaN) % 2 == 0)
+				  (*tamp)[col]=((*Mask1Dbis)[hhbis[ (width-ctl_NaN)/2]]+(*Mask1Dbis
+											 )[hhbis	[ (width - ctl_NaN-1)/2]])/2;
+				else
+				  (*tamp)[col]=(*Mask1Dbis)[hhbis[ (width- ctl_NaN)/2]];
+				delete[]hhbis;
+				delete[]h2bis;
+				delete[]h1bis;
+			      }
+			  }	
+			else
+			  {
+			    BaseGDL* besort=static_cast<BaseGDL*>(Mask1D);	
+			    MergeSortOpt<DLong>( besort, hh, h1, h2,width ); // call the sort routine
+
+			    if (e->KeywordSet( evenIx))
+
+			      (*tamp)[col]=((*Mask1D)[hh[ width/2]]+(*Mask1D)[hh[ (width-1)/2]])/2;
+			    else
+			      (*tamp)[col]=(*Mask1D)[hh[ width/2]];// replace value by Mask median 
+			  }
+		      }
+			
+		  }
+		else//------------------------  For an array with even width -------------------
+		  {
+		    SizeT jj;
+		    for(SizeT i=0 ; i<haut-2*lim ; ++i)		// lines to replace
+		      {
+		 	for(SizeT j=init+i*larg ; j<init+(i+1)*larg-2*lim ; ++j)// elements to replace
+			  {
+			    SizeT initMask=j-lim*larg-lim;	// left corner of mask
+			    SizeT kk=0;
+			    SizeT ctl_NaN=0;
+			    for(SizeT k=0;k<2*lim;++k)		// lines of mask
+			      {	
+								
+				for(jj=initMask+k*larg ; jj<(initMask+k*larg)+2*lim ; ++jj) // elements of mask
+				  {
+				    if( (*p0)[jj]!=d_infinity && (*p0)[jj]!=-d_infinity && isfinite((*p0)[jj])==0)
+				      ctl_NaN++;
+				    else
+				      {
+					(*Mask)[kk]=(*p0)[jj];
+					kk++;
+				      }
+				  }
+			      }
+			    if (ctl_NaN!=0)
+			      {
+				if(ctl_NaN==N_MaskElem)(*tamp)[j]= d_nan;
+				else {
+				  DLong*	hhb = new DLong[ N_MaskElem-ctl_NaN];
+				  DLong*	h1b = new DLong[ (N_MaskElem-ctl_NaN)/2];
+				  DLong*	h2b = new DLong[(N_MaskElem-ctl_NaN+1)/2];
+				  DDoubleGDL *Maskb = new DDoubleGDL(N_MaskElem-ctl_NaN,BaseGDL::NOZERO);
+				  for( DLong t=0; t<N_MaskElem-ctl_NaN; ++t) hhb[t] = t;
+				  for( DLong ii=0; ii<N_MaskElem-ctl_NaN; ++ii)(*Maskb)[ii]=(*Mask)[ii];
+				  BaseGDL* besort=static_cast<BaseGDL*>(Maskb);	
+				  MergeSortOpt<DLong>( besort, hhb, h1b, h2b,(N_MaskElem - ctl_NaN)); 
+				  if ((N_MaskElem - ctl_NaN) % 2 == 0 && e->KeywordSet( evenIx))
+				    (*tamp)[j]=((*Maskb)[hhb[ (N_MaskElem-ctl_NaN)/2]]+(*Maskb)[hhb 
+												[ (N_MaskElem - 
+												   ctl_NaN-1)/2]])/2;
+				  else
+				    (*tamp)[j]=(*Maskb)[hhb[ (N_MaskElem- ctl_NaN)/2]];
+				  delete[]hhb;
+				  delete[]h2b;
+				  delete[]h1b;
+				}
+			      }	
+			    else
+			      {
+			 	BaseGDL* besort=static_cast<BaseGDL*>(Mask);	
+			 	MergeSortOpt<DLong>( besort, hh, h1, h2, N_MaskElem); // call the sort routine
+				if (e->KeywordSet( evenIx))
+				  (*tamp)[j]=((*Mask)[hh[ N_MaskElem/2]]+(*Mask)[hh[ (N_MaskElem-1)/2]])/2;
+				else
+				  (*tamp)[j]=(*Mask)[hh[ N_MaskElem/2]];// replace value by median Mask one
+			      }
+			  }
+		      }
+		  }
+	      }
+
+	    else
+	      {
+		if ( p0->Rank() == 1 )//------------------------  For a vector with odd width -------------------
+	
+		  {	
+		    for (SizeT col= lim ; col<larg-lim ; ++col)
+		      {	
+			SizeT kk=0;
+			SizeT ctl_NaN=0;
+			for (SizeT ind=col-lim ; ind<=col+lim ; ++ind)
+			  {if( (*p0)[ind]!=d_infinity && (*p0)[ind]!=-d_infinity && isfinite((*p0)[ind])==0)
+			      ctl_NaN++;
+			    else{
+			      (*Mask1D)[kk]=(*p0)[ind];				
+			      kk++;
+			    }
+			  }
+			if (ctl_NaN!=0)
+			  {
+			    if(ctl_NaN==width)(*tamp)[col]= d_nan;
+			    else {
+			      DLong*	hhbis = new DLong[ width-ctl_NaN];
+			      DLong*	h1bis = new DLong[ width-ctl_NaN/2];
+			      DLong*	h2bis= new DLong[(width-ctl_NaN+1)/2];
+			      DDoubleGDL *Mask1Dbis = new DDoubleGDL(width-ctl_NaN,BaseGDL::NOZERO);
+			      for( DLong t=0; t<width-ctl_NaN; ++t) hhbis[t] = t;
+			      for( DLong ii=0; ii<width-ctl_NaN; ++ii)(*Mask1Dbis)[ii]=(*Mask1D)[ii];
+			      BaseGDL* besort=static_cast<BaseGDL*>(Mask1Dbis);	
+			      MergeSortOpt<DLong>( besort, hhbis, h1bis, h2bis,(width - ctl_NaN)); 
+			      if (e->KeywordSet( evenIx)&& (width - ctl_NaN) % 2 == 0)
+				(*tamp)[col]=((*Mask1Dbis)[hhbis[ (width-ctl_NaN)/2]]+(*Mask1Dbis
+										       )[hhbis	[ (width - ctl_NaN-1)/2]])/2;	
+			      else(*tamp)[col]=(*Mask1Dbis)[hhbis[ (width- ctl_NaN)/2]];
+			      delete[]hhbis;
+			      delete[]h2bis;
+			      delete[]h1bis;
+			    }
+			  }	
+			else
+			  {
+			    BaseGDL* besort=static_cast<BaseGDL*>(Mask1D);	
+			    MergeSortOpt<DLong>( besort, hh, h1, h2,width ); // call the sort routine
+			    (*tamp)[col]=(*Mask1D)[hh[ (width)/2]];	// replace value by Mask median 
+			  }
+		      }
+		
+		  }
+	
+		else //-----------------------------  For an array with odd width ---------------------------------
+		  {
+		    SizeT jj;
+		    for(SizeT i=0 ; i<haut-2*lim ; ++i)				// lines to replace
+		      {
+		
+		 	SizeT initial=init+i*larg-lim*larg-lim;
+			SizeT dd=0;SizeT ctl_NaN_init=0;
+			for(SizeT yy=0;yy<width;yy++)
+			  {	
+			    for (SizeT ii=initial+yy*larg ; ii <initial+ yy*larg+ width; ++ii)
+			      {
+					
+				if( (*p0)[ii]!=d_infinity && (*p0)[ii]!=-d_infinity && isfinite((*p0)[ii])==0)
+				  ctl_NaN_init++;
+				else
+				  (*Mask)[dd]=(*p0)[ii];
+				dd++;
+			      }
+			  }
+			SizeT kk=0;
+
+		 	for(SizeT j=init+i*larg ; j<init+(i+1)*larg-2*lim ; ++j)// elements to replace
+			  {
+			    SizeT initMask=j-lim*larg-lim;			// left corner of mask
+			    SizeT kk=0;
+			    SizeT ctl_NaN=0;
+			    for(SizeT k=0;k<=2*lim;++k)			// lines of mask
+			      {	
+								
+				for(jj=initMask+k*larg ; jj<=(initMask+k*larg)+2*lim ; ++jj) // elements of mask
+				  {
+				    if( (*p0)[jj]!=d_infinity && (*p0)[jj]!=-d_infinity && isfinite((*p0)[jj])==0)
+				      ctl_NaN++;
+						
+				    else
+				      {
+					(*Mask)[kk]=(*p0)[jj];
+					kk++;
+				      }
+				  }
+				
+			      }
+			 
+			    if (ctl_NaN!=0)
+			      {	
+				if(ctl_NaN==N_MaskElem)
+				  (*tamp)[j]= d_nan;
+				else {
+				  DLong*	hhb = new DLong[ N_MaskElem-ctl_NaN];
+				  DLong*	h1b = new DLong[ (N_MaskElem-ctl_NaN)/2];
+				  DLong*	h2b= new DLong[(N_MaskElem-ctl_NaN+1)/2];
+				  DDoubleGDL*Maskb = new DDoubleGDL(N_MaskElem-ctl_NaN,BaseGDL::NOZERO);
+				  for( DLong t=0; t<N_MaskElem-ctl_NaN; ++t) hhb[t] = t;
+				  for( DLong ii=0; ii<N_MaskElem-ctl_NaN; ++ii)(*Maskb)[ii]=(*Mask)[ii];
+				  BaseGDL* besort=static_cast<BaseGDL*>(Maskb);
+				  MergeSortOpt<DLong>( besort, hhb, h1b, h2b,(N_MaskElem - ctl_NaN));
+				  if ((N_MaskElem - ctl_NaN) % 2 == 0 && e->KeywordSet( evenIx))
+				    (*tamp)[j]=((*Maskb)[hhb[ (N_MaskElem-ctl_NaN)/2]]+(*Maskb)[hhb
+												[ (N_MaskElem - 
+												   ctl_NaN-1)/2]])/2;
+				  else(*tamp)[j]=(*Maskb)[hhb[(N_MaskElem- ctl_NaN)/2]];
+				  delete[]hhb;
+				  delete[]h2b;
+				  delete[]h1b;
+				}
+			      }	
+			    else
+			      {
+				BaseGDL* besort=static_cast<BaseGDL*>(Mask);	
+			 	MergeSortOpt<DLong>( besort, hh, h1, h2, N_MaskElem); // call the sort routine
+				(*tamp)[j]=(*Mask)[hh[ (N_MaskElem)/2]];	// replace value by Mask median 
+			      }
+			  }
+		      }
+		  }
+	      }
+	    
+	    //--------------------------- END OF MEDIAN FILTER ALOGORITHMS -----------------------------------
+
+	    delete[] h1;
+	    delete[] h2;
+	    delete[] hh;   	
+	  }
+       	if ( e->GetParDefined( 0)->Type() == GDL_DOUBLE || p0->Type() == GDL_COMPLEXDBL ||e->KeywordSet( doubleIx) )
+	  return tamp;
+	else if (e->GetParDefined( 0)->Type() == GDL_BYTE) 
+	  return tamp->Convert2(GDL_BYTE,BaseGDL::CONVERT);
+	
+	return tamp->Convert2(GDL_FLOAT,BaseGDL::CONVERT);
+	
+      }// end if
+
+  }// end of median
+
+  BaseGDL* shift_fun( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 2);
+
+    BaseGDL* p0 = e->GetParDefined( 0);
+
+    SizeT nShift = nParam - 1;
+    if( nShift == 1)
+      {
+		DLong s1;
+		e->AssureLongScalarPar( 1, s1);
+
+		// IncRef[Obj] done for GDL_PTR and GDL_OBJ
+		return p0->CShift( s1);
+      }
+    
+    if( p0->Rank() != nShift)
+      e->Throw( "Incorrect number of arguments.");
+
+    DLong sIx[ MAXRANK];
+    for( SizeT i=0; i< nShift; i++)
+      e->AssureLongScalarPar( i+1, sIx[ i]);
+
+	if( p0->Type() == GDL_OBJ)
+		GDLInterpreter::IncRefObj( static_cast<DObjGDL*>(p0));
+	else if( p0->Type() == GDL_PTR)
+		GDLInterpreter::IncRef( static_cast<DPtrGDL*>(p0));
+
+	return p0->CShift( sIx);
+  }
+
+  BaseGDL* arg_present( EnvT* e)
+  {
+    e->NParam( 1);
+    
+    if( !e->GlobalPar( 0))
+      return new DIntGDL( 0);
+
+    EnvBaseT* caller = e->Caller();
+    if( caller == NULL)
+      return new DIntGDL( 0);
+
+    BaseGDL** pp0 = &e->GetPar( 0);
+    
+    int ix = caller->FindGlobalKW( pp0);
+    if( ix == -1)
+      return new DIntGDL( 0);
+
+    return new DIntGDL( 1);
+  }
+
+  BaseGDL* eof_fun( EnvT* e)
+  {
+    e->NParam( 1);
+
+    DLong lun;
+    e->AssureLongScalarPar( 0, lun);
+
+    bool stdLun = check_lun( e, lun);
+    if( stdLun)
+      return new DIntGDL( 0);
+
+    // nicer error message (Disregard if socket)
+    if ( fileUnits[ lun-1].SockNum() == -1) {
+      if( !fileUnits[ lun-1].IsOpen())
+	throw GDLIOException( e->CallingNode(), "File unit is not open: "+i2s( lun)+".");
+
+      if( fileUnits[ lun-1].Eof())
+	return new DIntGDL( 1);
+    } else {
+      // Socket
+      string *recvBuf = &fileUnits[ lun-1].RecvBuf();
+      if (recvBuf->size() == 0)
+	return new DIntGDL( 1);
+    }
+    return new DIntGDL( 0);
+  }
+
+  BaseGDL* convol( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 2); 
+
+    BaseGDL* p0 = e->GetNumericParDefined( 0);
+    if( p0->Rank() == 0) 
+      e->Throw( "Expression must be an array in this context: "+
+		e->GetParString(0));
+    
+    BaseGDL* p1 = e->GetNumericParDefined( 1);
+    if( p1->Rank() == 0) 
+      e->Throw( "Expression must be an array in this context: "+
+		e->GetParString(1));
+    
+    if( p0->N_Elements() <= p1->N_Elements())
+      e->Throw( "Incompatible dimensions for Array and Kernel.");
+
+    // rank 1 for kernel works always
+    if( p1->Rank() != 1)
+      {
+	SizeT rank = p0->Rank();
+	if( rank != p1->Rank())
+	  e->Throw( "Incompatible dimensions for Array and Kernel.");
+
+	for( SizeT r=0; r<rank; ++r)
+	  if( p0->Dim( r) <= p1->Dim( r))
+	    e->Throw( "Incompatible dimensions for Array and Kernel.");
+      }
+
+    // convert kernel to array type
+    Guard<BaseGDL> p1Guard;
+    if( p0->Type() == GDL_BYTE)
+      {
+	if( p1->Type() != GDL_INT)
+	  {
+	    p1 = p1->Convert2( GDL_INT, BaseGDL::COPY); 
+	    p1Guard.Reset( p1);
+	  }
+      }
+    else if( p0->Type() != p1->Type())
+      {
+	p1 = p1->Convert2( p0->Type(), BaseGDL::COPY); 
+	p1Guard.Reset( p1);
+      }
+
+    BaseGDL* scale;
+    Guard<BaseGDL> scaleGuard;
+    if( nParam > 2)
+      {
+	scale = e->GetParDefined( 2);
+	if( scale->Rank() > 0)
+	  e->Throw( "Expression must be a scalar in this context: "+
+		    e->GetParString(2));
+
+	// p1 here handles GDL_BYTE case also
+	if( p1->Type() != scale->Type())
+	  {
+	    scale = scale->Convert2( p1->Type(),BaseGDL::COPY); 
+	    scaleGuard.Reset( scale);
+	  }
+      }
+    else
+      {
+	scale = p1->New( dimension(), BaseGDL::ZERO);
+      }
+
+    bool center = true;
+    static int centerIx = e->KeywordIx( "CENTER");
+    if( e->KeywordPresent( centerIx))
+      {
+	DLong c;
+	e->AssureLongScalarKW( centerIx, c);
+	center = (c != 0);
+      }
+
+    // overrides EDGE_TRUNCATE
+    static int edge_wrapIx = e->KeywordIx( "EDGE_WRAP");
+    bool edge_wrap = e->KeywordSet( edge_wrapIx);
+    static int edge_truncateIx = e->KeywordIx( "EDGE_TRUNCATE");
+    bool edge_truncate = e->KeywordSet( edge_truncateIx);
+
+    int edgeMode = 0; 
+    if( edge_wrap)
+      edgeMode = 1;
+    else if( edge_truncate)
+      edgeMode = 2;
+
+    // p0, p1 and scale have same type
+    // p1 has rank of 1 or same rank as p0 with each dimension smaller than p0
+    // scale is a scalar
+    return p0->Convol( p1, scale, center, edgeMode);
+  }
+
+  BaseGDL* rebin_fun( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 2);
+
+    BaseGDL* p0 = e->GetNumericParDefined( 0);
+
+    SizeT rank = p0->Rank();
+
+    if( rank == 0) 
+      e->Throw( "Expression must be an array in this context: "+
+		e->GetParString(0));
+    
+    SizeT resDimInit[ MAXRANK];
+
+    DLongGDL* p1 = e->GetParAs<DLongGDL>(1);
+    if (p1->Rank() > 0 && nParam > 2) 
+      e->Throw("The new dimensions must either be specified as an array or as a set of scalars.");
+    SizeT np = p1->Rank() == 0 ? nParam : p1->N_Elements() + 1;
+
+    for( SizeT p=1; p<np; ++p)
+      {
+	DLong newDim;
+	if (p1->Rank() == 0) e->AssureLongScalarPar( p, newDim);
+        else newDim = (*p1)[p - 1];
+
+	if( newDim <= 0)
+	  e->Throw( "Array dimensions must be greater than 0.");
+	
+	if( rank >= p)
+	  {
+	    SizeT oldDim = p0->Dim( p-1);
+
+	    if( newDim > oldDim)
+	      {
+		if( (newDim % oldDim) != 0)
+		  e->Throw( "Result dimensions must be integer factor "
+			    "of original dimensions.");
+	      }
+	    else
+	      {
+		if( (oldDim % newDim) != 0)
+		  e->Throw( "Result dimensions must be integer factor "
+			    "of original dimensions.");
+	      }
+	  }
+	
+	resDimInit[ p-1] = newDim; 
+      }
+
+    dimension resDim( resDimInit, np-1);
+
+    static int sampleIx = e->KeywordIx( "SAMPLE");
+    bool sample = e->KeywordSet( sampleIx);
+    
+    return p0->Rebin( resDim, sample);
+  }
+
+  BaseGDL* obj_class( EnvT* e)
+  {
+    SizeT nParam = e->NParam();
+
+    static int countIx = e->KeywordIx( "COUNT");
+    static int superIx = e->KeywordIx( "SUPERCLASS");
+
+    bool super = e->KeywordSet( superIx);
+
+    bool count = e->KeywordPresent( countIx);
+    if( count)
+      e->AssureGlobalKW( countIx);
+
+    if( nParam > 0)
+      {
+	BaseGDL* p0 = e->GetParDefined( 0);
+
+	if( p0->Type() != GDL_STRING && p0->Type() != GDL_OBJ)
+	  e->Throw( "Argument must be a scalar object reference or string: "+
+		    e->GetParString(0));
+
+	if( !p0->Scalar())
+	  e->Throw( "Expression must be a scalar or 1 element "
+		    "array in this context: "+e->GetParString(0));
+
+	DStructDesc* objDesc;
+
+	if( p0->Type() == GDL_STRING)
+	  {
+	    DString objName;
+	    e->AssureScalarPar<DStringGDL>( 0, objName);
+	    objName = StrUpCase( objName);
+
+	    objDesc = FindInStructList( structList, objName);
+	    if( objDesc == NULL)
+	      {
+		if( count)
+		  e->SetKW( countIx, new DLongGDL( 0));
+		return new DStringGDL( "");
+	      }
+	  }
+	else // GDL_OBJ
+	  {
+	    DObj objRef;
+	    e->AssureScalarPar<DObjGDL>( 0, objRef);
+
+	    if( objRef == 0)
+	      {
+		if( count)
+		  e->SetKW( countIx, new DLongGDL( 0));
+		return new DStringGDL( "");
+	      }
+
+	    DStructGDL* oStruct;
+	    try {
+	      oStruct = e->GetObjHeap( objRef);
+	    }
+	    catch ( GDLInterpreter::HeapException)
+	      { // non valid object
+		if( count)
+		  e->SetKW( countIx, new DLongGDL( 0));
+		return new DStringGDL( "");
+	      }
+
+	    objDesc = oStruct->Desc(); // cannot be NULL
+	  }
+
+	if( !super)
+	  {
+	    if( count)
+	      e->SetKW( countIx, new DLongGDL( 1));
+	    return new DStringGDL( objDesc->Name());
+	  }
+	
+	deque< string> pNames;
+	objDesc->GetParentNames( pNames);
+
+	SizeT nNames = pNames.size();
+	    
+	if( count)
+	  e->SetKW( countIx, new DLongGDL( nNames));
+
+	if( nNames == 0)
+	  {
+	    return new DStringGDL( "");
+	  }
+
+	DStringGDL* res = new DStringGDL( dimension( nNames), 
+					  BaseGDL::NOZERO);
+
+	for( SizeT i=0; i<nNames; ++i)
+	  {
+	    (*res)[i] = pNames[i];
+	  }
+	
+	return res;
+      }
+
+    if( super)
+      e->Throw( "Conflicting keywords.");
+
+    SizeT nObj = structList.size();
+
+    DStringGDL* res = new DStringGDL( dimension( nObj), 
+				      BaseGDL::NOZERO);
+
+    for( SizeT i=0; i<nObj; ++i)
+      {
+	(*res)[i] = structList[i]->Name();
+      }
+	
+    return res;
+  }
+
+  BaseGDL* obj_isa( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 2);
+
+    BaseGDL* p0 = e->GetPar( 0);
+    if( p0 == NULL || p0->Type() != GDL_OBJ)
+      e->Throw( "Object reference type required in this context: "+
+		e->GetParString(0));
+
+    DString className;
+    e->AssureScalarPar<DStringGDL>( 1, className);
+    className = StrUpCase( className);
+
+    DObjGDL* pObj = static_cast<DObjGDL*>( p0);
+
+    DByteGDL* res = new DByteGDL( pObj->Dim()); // zero 
+
+    GDLInterpreter* interpreter = e->Interpreter();
+
+    SizeT nElem = pObj->N_Elements();
+    for( SizeT i=0; i<nElem; ++i)
+      {
+	if( interpreter->ObjValid( (*pObj)[ i])) 
+	  {
+	    DStructGDL* oStruct = e->GetObjHeap( (*pObj)[i]);
+	    if( oStruct->Desc()->IsParent( className))
+	      (*res)[i] = 1;
+	  }
+      }
+    
+    return res;
+  }
+
+  BaseGDL* n_tags( EnvT* e)
+  {
+    e->NParam( 1);
+
+    BaseGDL* p0 = e->GetPar( 0);
+    if( p0 == NULL)
+      return new DLongGDL( 0);
+    
+    if( p0->Type() != GDL_STRUCT)
+      return new DLongGDL( 0);
+    
+    DStructGDL* s = static_cast<DStructGDL*>( p0);
+
+    //static int lengthIx = e->KeywordIx( "DATA_LENGTH");
+    //bool length = e->KeywordSet( lengthIx);
+    
+    // we don't know now how to distinghuis the 2 following cases
+    if(e->KeywordSet("DATA_LENGTH"))
+      return new DLongGDL( s->Sizeof());
+    
+    if(e->KeywordSet("LENGTH"))
+      return new DLongGDL( s->Sizeof());
+
+    return new DLongGDL( s->Desc()->NTags());
+  }
+
+  BaseGDL* bytscl( EnvT* e)
+  {
+    SizeT nParam = e->NParam( 1);
+
+    BaseGDL* p0=e->GetNumericParDefined( 0);
+
+    static int minIx = e->KeywordIx( "MIN");
+    static int maxIx = e->KeywordIx( "MAX");
+    static int topIx = e->KeywordIx( "TOP");
+    bool omitNaN = e->KeywordPresent( 3);
+
+    DLong topL=255;
+    if( e->GetKW( topIx) != NULL)
+      e->AssureLongScalarKW( topIx, topL);
+    if (topL > 255) topL=255; // Bug corrected!
+    DByte top = static_cast<DByte>(topL);
+    DDouble dTop = static_cast<DDouble>(top);
+
+    DDouble min;
+    bool minSet = false;
+    // SA: handling 3 parameters to emulate undocumented IDL behaviour 
+    //     of translating second and third arguments to MIN and MAX, respectively
+    //     (parameters have precedence over keywords)
+    if (nParam >= 2)
+    {
+      e->AssureDoubleScalarPar(1, min);
+      minSet = true;
+    } 
+    else if (e->GetKW(minIx) != NULL)
+    {
+      e->AssureDoubleScalarKW(minIx, min);
+      minSet = true;
+    }
+
+    DDouble max;
+    bool maxSet = false;
+    if (nParam == 3)
+    {
+      e->AssureDoubleScalarPar(2, max);
+      maxSet = true;
+    }
+    else if (e->GetKW(maxIx) != NULL)
+    {
+      e->AssureDoubleScalarKW(maxIx, max);
+      maxSet = true;
+    }
+
+    DDoubleGDL* dRes = 
+      static_cast<DDoubleGDL*>(p0->Convert2( GDL_DOUBLE, BaseGDL::COPY));
+
+    DLong maxEl, minEl;
+    if( !maxSet || !minSet)
+      dRes->MinMax( &minEl, &maxEl, NULL, NULL, omitNaN);
+    if( !minSet)
+      min = (*dRes)[ minEl];
+    if( !maxSet)
+      max = (*dRes)[ maxEl];
+
+    SizeT nEl = dRes->N_Elements();
+    for( SizeT i=0; i<nEl; ++i)
+      {
+	DDouble& d = (*dRes)[ i];
+	if( d <= min) (*dRes)[ i] = 0;
+	else if( d >= max) (*dRes)[ i] = dTop;
+	else
+        {
+          // SA: floor is used for integer types to simulate manipulation on input data types
+          if (IntType(p0->Type())) (*dRes)[ i] = floor(((dTop + 1.)*(d - min) - 1.) / (max-min));
+          // SA (?): here floor is used (instead of round) to simulate IDL behaviour
+          else (*dRes)[ i] = floor((d - min) / (max-min) * (dTop + .9999));
+        }
+    }
+
+    return dRes->Convert2( GDL_BYTE);
+  } 
+
+  BaseGDL* strtok_fun( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 1);
+    
+    DString stringIn;
+    e->AssureStringScalarPar( 0, stringIn);
+
+    DString pattern = " \t";
+    if(nParam > 1) {
+      e->AssureStringScalarPar( 1, pattern);
+    }
+    
+    static int extractIx = e->KeywordIx( "EXTRACT");
+    bool extract = e->KeywordSet( extractIx);
+
+    static int lengthIx = e->KeywordIx( "LENGTH");
+    bool lengthPresent = e->KeywordPresent( lengthIx);
+
+    if( extract && lengthPresent)
+      e->Throw( "Conflicting keywords.");
+    
+    static int pre0Ix = e->KeywordIx( "PRESERVE_NULL");
+    bool pre0 = e->KeywordSet( pre0Ix);
+
+    static int regexIx = e->KeywordIx( "REGEX");
+    bool regex = e->KeywordPresent( regexIx);
+    char err_msg[MAX_REGEXPERR_LENGTH];
+    regex_t regexp;
+    
+    deque<long> tokenStart;
+    deque<long> tokenLen;
+ 
+    int strLen = stringIn.length();
+
+    DString escape = "";
+    e->AssureStringScalarKWIfPresent( "ESCAPE", escape);
+    deque<long> escList;
+    long pos = 0;
+    while(pos != string::npos)
+      {
+	pos = stringIn.find_first_of( escape, pos);
+	if( pos != string::npos)
+	  {
+	    escList.push_back( pos+1); // remember escaped char
+	    pos += 2; // skip escaped char
+	  }
+      }
+    deque<long>::iterator escBeg = escList.begin();
+    deque<long>::iterator escEnd = escList.end();
+
+    long tokB = 0;
+    long tokE;
+    long nextE = 0;
+    long actLen;
+
+    // If regex then compile regex
+    if( regex) {
+      if (pattern == " \t") pattern = " "; // regcomp doesn't like "\t" JMG
+      int compRes = regcomp( &regexp, pattern.c_str(), REG_EXTENDED);
+      if (compRes) {
+	regerror(compRes, &regexp, err_msg, MAX_REGEXPERR_LENGTH);
+	e->Throw(  "Error processing regular expression: "+
+			   pattern+"\n           "+string(err_msg)+".");
+      }
+    }
+
+    for(;;)
+      {
+	regmatch_t pmatch[1];
+	if( regex) {
+	  int matchres = regexec( &regexp, stringIn.c_str()+nextE, 1, pmatch, 0);
+	  tokE = matchres? -1:pmatch[0].rm_so;
+	} else { 
+	  tokE = stringIn.find_first_of( pattern, nextE);
+	}
+
+	if( tokE == string::npos)
+	  {
+	    actLen = strLen - tokB;
+	    if( actLen > 0 || pre0)
+	      {
+		tokenStart.push_back( tokB);
+		tokenLen.push_back( actLen);
+	      }
+	    break;
+	  }
+
+	if( find( escBeg, escEnd, tokE) == escEnd) 
+	  {
+	    if (regex) actLen = tokE; else actLen = tokE - tokB;
+	    if( actLen > 0 || pre0)
+	      {
+		tokenStart.push_back( tokB);
+		tokenLen.push_back( actLen);
+	      }
+	    if (regex) tokB += pmatch[0].rm_eo; else tokB = tokE + 1;
+	  }
+	if (regex) nextE += pmatch[0].rm_eo; else nextE = tokE + 1;
+      } // for(;;)
+
+    if (regex) regfree( &regexp);
+
+    SizeT nTok = tokenStart.size();
+
+    if( !extract)
+      {    
+	if( lengthPresent) 
+	  {
+	    e->AssureGlobalKW( lengthIx);
+	    
+	    if( nTok > 0)
+	      {
+		dimension dim(nTok);
+		DLongGDL* len = new DLongGDL(dim);
+		for(int i=0; i < nTok; i++)
+		  (*len)[i] = tokenLen[i];
+
+		e->SetKW( lengthIx, len);
+	      }
+	    else
+	      {
+		e->SetKW( lengthIx, new DLongGDL( 0));
+	      }
+	  }
+	
+	if( nTok == 0) return new DLongGDL( 0);
+    
+	dimension dim(nTok);
+	DLongGDL* d = new DLongGDL(dim);
+	for(int i=0; i < nTok; i++)
+	  (*d)[i] = tokenStart[i];
+	return d; 
+      } 
+
+    // EXTRACT
+    if( nTok == 0) return new DStringGDL( "");
+
+    dimension dim(nTok);
+    DStringGDL *d = new DStringGDL(dim);
+    for(int i=0; i < nTok; i++) 
+      {
+	(*d)[i] = stringIn.substr(tokenStart[i], tokenLen[i]);	
+
+	// remove escape
+	DString& act = (*d)[i];
+	long escPos = act.find_first_of( escape, 0);
+	while( escPos != string::npos)
+	  {
+	    act = act.substr( 0, escPos)+act.substr( escPos+1);
+	    escPos = act.find_first_of( escape, escPos+1);
+	  }
+      }
+    return d;
+  }
+
+  BaseGDL* getenv_fun( EnvT* e)
+  {
+    SizeT nParam=e->NParam();
+
+    static int environmentIx = e->KeywordIx( "ENVIRONMENT" );
+    bool environment = e->KeywordSet( environmentIx );
+  
+    SizeT nEnv; 
+    DStringGDL* env;
+
+    if( environment) {
+
+      if(nParam != 0) 
+        e->Throw( "Incorrect number of arguments.");
+
+      // determine number of environment entries
+      for(nEnv = 0; environ[nEnv] != NULL  ; ++nEnv);
+
+      dimension dim( nEnv );
+      env = new DStringGDL(dim);
+
+      // copy stuff into local string array
+      for(SizeT i=0; i < nEnv ; ++i)
+        (*env)[i] = environ[i];
+
+    } else {
+
+      if(nParam != 1) 
+        e->Throw( "Incorrect number of arguments.");
+
+      DStringGDL* name = e->GetParAs<DStringGDL>(0);
+      nEnv = name->N_Elements();
+
+      env = new DStringGDL( name->Dim());
+ 
+      // copy the stuff into local string only if param found
+      char *resPtr;
+      for(SizeT i=0; i < nEnv ; ++i)
+	{
+	  // handle special environment variables
+	  // GDL_TMPDIR, IDL_TMPDIR
+	  if( (*name)[i] == "GDL_TMPDIR" || (*name)[i] == "IDL_TMPDIR")
+	    {
+	      resPtr = getenv((*name)[i].c_str());
+
+	      if( resPtr != NULL)
+		(*env)[i] = resPtr;
+	      else
+		(*env)[i] = SysVar::Dir();
+
+	      AppendIfNeeded( (*env)[i], "/");
+	    }
+	  else // normal environment variables
+	    if( (resPtr = getenv((*name)[i].c_str())) ) 
+	      (*env)[i] = resPtr;
+	}
+    }
+    
+    return env;
+  }
+
+  BaseGDL* tag_names_fun( EnvT* e)
+  {
+    SizeT nParam=e->NParam();
+    DStructGDL* struc= e->GetParAs<DStructGDL>(0);
+
+    static int structureNameIx = e->KeywordIx( "STRUCTURE_NAME" );
+    bool structureName = e->KeywordSet( structureNameIx );
+    
+    DStringGDL* tagNames;
+
+    if(structureName){
+        
+      if ((*struc).Desc()->Name() != "$truct")
+	tagNames =  new DStringGDL((*struc).Desc()->Name());
+      else
+	tagNames =  new DStringGDL("");
+
+    } else {
+      SizeT nTags = (*struc).Desc()->NTags();
+    
+      tagNames = new DStringGDL(dimension(nTags));
+      for(int i=0; i < nTags; ++i)
+        (*tagNames)[i] = (*struc).Desc()->TagName(i);
+    }
+
+    return tagNames;
+  }
+
+// AC 12-Oc-2011: better version for: len=len, /Extract and /Sub
+// but it is still not perfect
+
+  BaseGDL* stregex_fun( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 2);
+    
+    DStringGDL* stringExpr= e->GetParAs<DStringGDL>(0);
+    dimension dim = stringExpr->Dim();
+
+    DString pattern;
+    e->AssureStringScalarPar(1, pattern);
+    if (pattern.size() <= 0)
+      {
+	e->Throw( "Error processing regular expression: "+pattern+
+		  "\n           empty (sub)expression");
+      }
+
+    static int booleanIx = e->KeywordIx( "BOOLEAN" );
+    bool booleanKW = e->KeywordSet( booleanIx );
+
+    static int extractIx = e->KeywordIx( "EXTRACT" );
+    bool extractKW = e->KeywordSet( extractIx );
+
+    static int foldCaseIx = e->KeywordIx( "FOLD_CASE" );
+    bool foldCaseKW = e->KeywordSet( foldCaseIx );
+
+    //XXXpch: this is wrong, should check arg_present
+    static int lengthIx = e->KeywordIx( "LENGTH" );
+    bool lengthKW = e->KeywordPresent( lengthIx );
+   
+    static int subexprIx = e->KeywordIx( "SUBEXPR" );
+    bool subexprKW = e->KeywordSet( subexprIx );
+ 
+    if( booleanKW && (subexprKW || extractKW || lengthKW))
+      e->Throw( "Conflicting keywords.");
+  
+    char err_msg[MAX_REGEXPERR_LENGTH];
+
+    // set the compile flags 
+    int cflags = REG_EXTENDED;
+    if (foldCaseKW)
+      cflags |= REG_ICASE;
+    if (booleanKW)
+      cflags |= REG_NOSUB;
+
+    // compile the regular expression
+    regex_t regexp;
+    int compRes = regcomp( &regexp, pattern.c_str(), cflags);
+    SizeT nSubExpr = regexp.re_nsub + 1;
+    
+    //    cout << regexp.re_nsub << endl;
+
+    if (compRes) {
+      regerror(compRes, &regexp, err_msg, MAX_REGEXPERR_LENGTH);
+      e->Throw( "Error processing regular expression: "+
+                         pattern+"\n           "+string(err_msg)+".");
+    }
+
+    BaseGDL* result;
+
+    if( booleanKW) 
+      result = new DByteGDL(dim);
+    else if( extractKW && !subexprKW)
+      {
+	//	cout << "my pb ! ? dim= " << dim << endl;
+	result = new DStringGDL(dim);
+      }
+    else if( subexprKW)
+      {
+	//	cout << "my pb 2 ? dim= " << dim << endl;
+	dimension subExprDim = dim;
+ 	subExprDim >> nSubExpr; // m_schellens: commented in, needed
+	if( extractKW)
+	  result = new DStringGDL(subExprDim);
+	else
+	  result = new DLongGDL(subExprDim);
+      }
+    else 
+      result = new DLongGDL(dim); 
+
+    DLongGDL* len = NULL;
+    if( lengthKW) {
+      e->AssureGlobalKW( lengthIx);
+      if( subexprKW)
+	{
+	  dimension subExprDim = dim;
+	  subExprDim >> nSubExpr; // m_schellens: commented in, needed
+	  len = new DLongGDL(subExprDim);
+	}
+      else
+	{
+	  len = new DLongGDL(dim);
+	}
+      for( SizeT i=0; i<len->N_Elements(); ++i)
+	   (*len)[i]= -1;
+    } 
+    
+    int nmatch = 1;
+    if( subexprKW) nmatch = nSubExpr;
+
+    regmatch_t* pmatch = new regmatch_t[nSubExpr];
+    ArrayGuard<regmatch_t> pmatchGuard( pmatch);
+
+    //    cout << "dim " << dim.NDimElements() << endl;	    
+    for( SizeT s=0; s<dim.NDimElements(); ++s)
+      {
+	int eflags = 0; 
+
+	for( SizeT sE=0; sE<nSubExpr; ++sE)
+	  pmatch[sE].rm_so = -1;
+
+	// now match towards the string
+	int matchres = regexec( &regexp, (*stringExpr)[s].c_str(),  nmatch, pmatch, eflags);
+
+	// subexpressions
+	if ( extractKW && subexprKW) {
+
+	  // Loop through subexpressions & fill output array
+	  for( SizeT i = 0; i<nSubExpr; ++i) {
+	    if (pmatch[i].rm_so != -1)
+		(*static_cast<DStringGDL*>(result))[i+s*nSubExpr] =
+			(*stringExpr)[s].substr( pmatch[i].rm_so,  pmatch[i].rm_eo - pmatch[i].rm_so);
+// 			(*stringExpr)[i+s*nSubExpr].substr( pmatch[i].rm_so,  pmatch[i].rm_eo - pmatch[i].rm_so);
+	    if( lengthKW)
+	      (*len)[i+s*nSubExpr] = pmatch[i].rm_so != -1 ? pmatch[i].rm_eo - pmatch[i].rm_so : -1;
+//  	      (*len)[i+s*nSubExpr] = pmatch[i].rm_eo - pmatch[i].rm_so;
+	  }
+	}
+	else  if ( subexprKW) 
+	  {
+	    //	    cout << "je ne comprends pas v2: "<< nSubExpr << endl;
+
+	    // Loop through subexpressions & fill output array
+	    for( SizeT i = 0; i<nSubExpr; ++i) {
+	      (* static_cast<DLongGDL*>(result))[i+s*nSubExpr] =  pmatch[i].rm_so;
+	      if( lengthKW)
+		(*len)[i+s*nSubExpr] = pmatch[i].rm_so != -1 ? pmatch[i].rm_eo - pmatch[i].rm_so : -1;
+	    }
+	  }
+	else
+	  {
+	    if( booleanKW)
+	      (* static_cast<DByteGDL*>(result))[s] = (matchres == 0);
+	    else if ( extractKW) // !subExprKW
+	      {
+	      if( matchres == 0)
+		(* static_cast<DStringGDL*>(result))[s] = 
+		  (*stringExpr)[s].substr( pmatch[0].rm_so, 
+					   pmatch[0].rm_eo - pmatch[0].rm_so);
+	      }
+	    else
+	      (*static_cast<DLongGDL*>(result))[s] = matchres ? -1 : pmatch[0].rm_so;
+	  }
+
+	if( lengthKW && !subexprKW)
+	  (*len)[s] = pmatch[0].rm_eo - pmatch[0].rm_so;
+      }
+
+    regfree( &regexp);
+
+    if( lengthKW)
+      e->SetKW( lengthIx, len);    
+
+    return result;
+  }
+
+  BaseGDL* routine_info( EnvT* e)
+  {
+    SizeT nParam=e->NParam();
+    if (nParam > 1) e->Throw("Incorrect number of arguments.");
+
+    static int functionsIx = e->KeywordIx( "FUNCTIONS" );
+    bool functionsKW = e->KeywordSet( functionsIx );
+    static int systemIx = e->KeywordIx( "SYSTEM" );
+    bool systemKW = e->KeywordSet( systemIx );
+    static int disabledIx = e->KeywordIx( "DISABLED" );
+    bool disabledKW = e->KeywordSet( disabledIx );
+    static int parametersIx = e->KeywordIx( "PARAMETERS" );
+    bool parametersKW = e->KeywordSet( parametersIx );
+    static int sourceIx = e->KeywordIx( "SOURCE" );
+    bool sourceKW = e->KeywordSet(sourceIx );
+
+    if (sourceKW) {
+
+      // sanity checks
+      if (systemKW) e->Throw("Conflicting keywords.");
+
+      // we are not ready to manage the case when no param is provide (routine name)
+      if (nParam == 0) e->Throw("This case is not ready");
+
+      // it seems that the code inside "CREATE_STRUCTURE()" (see here below)
+      // shall be a base to do it (notes by AC, May 16, 2013)
+      
+      /*if (functionsKW) {
+	if (funList.size() == 0) {
+	return new DStringGDL("");
+	} else {
+      */
+
+      // getting the routine name from the first parameter (must be a singleton)
+      DString raw_name, name;
+      e->AssureScalarPar<DStringGDL>(0, raw_name);
+      name = StrUpCase(raw_name);
+      
+      string FullFileName;
+      bool found=false;
+
+      //      SizeT n = funList.size();
+      //cout << funList.size() << endl;
+      //cout << proList.size() << endl;
+
+      // looking in the compiled functions (if /function keyword provided)
+      // or in the compiled procedures
+      if (functionsKW) {
+	for(FunListT::iterator i=funList.begin(); i != funList.end(); ++i) {
+	  if ((*i)->ObjectName() == name) {
+	    found=true;
+	    FullFileName=(*i)->GetFilename();
+	    break;
+	  }
+	}
+	if (!found) e->Throw("% Attempt to call undefined/not compiled function: '"+raw_name+"'");	
+      } else {
+	for(ProListT::iterator i=proList.begin(); i != proList.end(); ++i) {
+	  if ((*i)->ObjectName() == name) {
+	    found=true;
+	    FullFileName=(*i)->GetFilename();
+	    break;
+	  }
+	}
+	if (!found) e->Throw("% Attempt to call undefined/not compiled procedure: '"+raw_name+"'");
+      }
+      
+      // creating the output anonymous structure
+      DStructDesc* stru_desc = new DStructDesc("$truct");
+      SpDString aString;
+      stru_desc->AddTag("NAME", &aString);
+      stru_desc->AddTag("PATH", &aString);
+      
+      DStructGDL* stru = new DStructGDL(stru_desc, dimension());
+      // filling the structure with information about the routine 
+      stru->InitTag("NAME", DStringGDL(name));
+      stru->InitTag("PATH", DStringGDL(FullFileName));
+
+      return stru;
+
+    }
+
+    if (parametersKW)
+    {
+      // sanity checks
+      if (systemKW || disabledKW) e->Throw("Conflicting keywords.");
+
+      // getting the routine name from the first parameter
+      DString name;
+      e->AssureScalarPar<DStringGDL>(0, name);
+      name = StrUpCase(name);
+        
+      DSubUD* routine = functionsKW 
+        ? static_cast<DSubUD*>(funList[GDLInterpreter::GetFunIx(name)])
+        : static_cast<DSubUD*>(proList[GDLInterpreter::GetProIx(name)]);
+      SizeT np = routine->NPar(), nk = routine->NKey();
+
+      // creating the output anonymous structure
+      DStructDesc* stru_desc = new DStructDesc("$truct");
+      SpDLong aLong;
+      stru_desc->AddTag("NUM_ARGS", &aLong);
+      stru_desc->AddTag("NUM_KW_ARGS", &aLong);
+      if (np > 0) 
+      {
+        SpDString aStringArr(dimension((int)np));
+        stru_desc->AddTag("ARGS", &aStringArr);
+      }
+      if (nk > 0) 
+      {
+        SpDString aStringArr(dimension((int)nk));
+        stru_desc->AddTag("KW_ARGS", &aStringArr);
+      }
+      DStructGDL* stru = new DStructGDL(stru_desc, dimension());
+
+      // filling the structure with information about the routine 
+      stru->InitTag("NUM_ARGS", DLongGDL(np));
+      stru->InitTag("NUM_KW_ARGS", DLongGDL(nk));
+      if (np > 0)
+      {
+        DStringGDL *pnames = new DStringGDL(dimension(np));
+        for (SizeT p = 0; p < np; ++p) (*pnames)[p] = routine->GetVarName(nk + p); 
+        stru->InitTag("ARGS", *pnames);
+        GDLDelete(pnames);
+      }
+      if (nk > 0)
+      {
+        DStringGDL *knames = new DStringGDL(dimension(nk));
+        for (SizeT k = 0; k < nk; ++k) (*knames)[k] = routine->GetKWName(k); 
+        stru->InitTag("KW_ARGS", *knames);
+        GDLDelete(knames);
+      }
+
+      // returning
+      return stru;
+    }
+
+    // GDL does not have disabled routines
+    if( disabledKW) return new DStringGDL("");
+
+    //    if( functionsKW || systemKW || nParam == 0)
+    //      {
+    deque<DString> subList;
+	    
+    if( functionsKW)
+      {
+	if( systemKW)
+	  {
+	    SizeT n = libFunList.size();
+	    if( n == 0) return new DStringGDL("");
+
+	    DStringGDL* res = new DStringGDL( dimension( n), BaseGDL::NOZERO);
+	    for( SizeT i = 0; i<n; ++i)
+	      (*res)[i] = libFunList[ i]->ObjectName();
+
+	    return res;
+	  }
+	else
+	  {
+	    SizeT n = funList.size();
+	    if( n == 0) return new DStringGDL("");
+	    subList.resize( n);
+		
+	    for( SizeT i = 0; i<n; ++i)
+	      subList.push_back( funList[ i]->ObjectName());
+	  }
+      }
+    else
+      {
+	if( systemKW)
+	  {
+	    SizeT n = libProList.size();
+	    if( n == 0) return new DStringGDL("");
+
+	    DStringGDL* res = new DStringGDL( dimension( n), BaseGDL::NOZERO);
+	    for( SizeT i = 0; i<n; ++i)
+	      (*res)[i] = libProList[ i]->ObjectName();
+
+	    return res;
+	  }
+	else
+	  {
+	    SizeT n = proList.size();
+	    if( n == 0) return new DStringGDL("");
+	    subList.resize( n);
+		
+	    for( SizeT i = 0; i<n; ++i)
+	      subList.push_back( proList[ i]->ObjectName());
+	  }
+      }
+	
+    sort( subList.begin(), subList.end());
+    SizeT nS = subList.size();
+
+    DStringGDL* res = new DStringGDL( dimension( nS), BaseGDL::NOZERO);
+    for( SizeT s=0; s<nS; ++s)
+      (*res)[ s] = subList[ s];
+
+    return res;
+    //      }
+  }
+
+  BaseGDL* get_kbrd( EnvT* e)
+  {
+#if defined(HAVE_LIBREADLINE)
+#include <readline/readline.h>
+      rl_prep_terminal (0);
+#endif
+      
+ SizeT nParam=e->NParam();
+
+    bool doWait = true;
+    if( nParam > 0)
+      {
+	doWait = false;
+	DLong waitArg = 0;
+	e->AssureLongScalarPar( 0, waitArg);
+	if( waitArg != 0)
+	  {
+	    doWait = true;
+	  }
+      }
+
+    // https://sourceforge.net/forum/forum.php?thread_id=3292183&forum_id=338691
+    // DONE: Implement proper SCALAR parameter handling (doWait variable)
+    // which is/was not blocking in the original program. 
+    // note: multi-byte input is not supported here.
+    
+    char c='\0'; //initialize is never a bad idea...
+
+    int fd=fileno(stdin);
+#ifndef _MSC_VER
+    struct termios orig, get; 
+#endif
+    // Get terminal setup to revert to it at end. 
+#ifndef _MSC_VER
+    (void)tcgetattr(fd, &orig); 
+    // New terminal setup, non-canonical.
+    get.c_lflag = ISIG; 
+#endif
+    if (doWait)
+    {
+     // will wait for a character
+#ifndef _MSC_VER
+     get.c_cc[VTIME]=0;
+     get.c_cc[VMIN]=1;
+     (void)tcsetattr(fd, TCSANOW, &get); 
+#endif
+     cin.get(c);
+    }
+    else 
+    {
+     // will not wait, but return EOF or next character in terminal buffer if present
+#ifndef _MSC_VER
+     get.c_cc[VTIME]=0;
+     get.c_cc[VMIN]=0;
+     (void)tcsetattr(fd, TCSANOW, &get); 
+#endif
+     //the trick is *not to use C++ functions here. cin.get would wait.*
+     c=std::fgetc(stdin);
+     //and to convert EOF to null (otherwise GDL may exit if not compiled with
+     //[lib][n]curses)
+     if(c==EOF) c='\0';
+    }
+    
+    // Restore original terminal settings. 
+#ifndef _MSC_VER
+    (void)tcsetattr(fd, TCSANOW, &orig); 
+#endif
+#if defined(HAVE_LIBREADLINE)
+    rl_deprep_terminal ();
+#endif
+
+    DStringGDL* res = new DStringGDL( DString( i2s( c))); 
+
+    return res;
+ 
+  }
+
+
+  BaseGDL* temporary( EnvT* e)
+  {
+    SizeT nParam=e->NParam(1);
+
+    BaseGDL** p0 = &e->GetParDefined( 0);
+
+    BaseGDL* ret = *p0;
+
+    *p0 = NULL; // make parameter undefined
+    return ret;
+  }
+
+  BaseGDL* memory( EnvT* e)
+  {
+    SizeT nParam=e->NParam( 0); 
+
+    BaseGDL* ret;
+    bool kw_l64 = e->KeywordSet(e->KeywordIx("L64"));
+    // TODO: IDL-doc mentions about automatically switching to L64 if needed
+
+    if (e->KeywordSet(e->KeywordIx("STRUCTURE")))
+    {
+      // returning structure
+      if (kw_l64) 
+      {
+        ret = new DStructGDL("IDL_MEMORY64");
+        DStructGDL* retStru = static_cast<DStructGDL*>(ret);
+        (retStru->GetTag(retStru->Desc()->TagIndex("CURRENT")))->InitFrom( DLong64GDL(MemStats::GetCurrent()));
+        (retStru->GetTag(retStru->Desc()->TagIndex("NUM_ALLOC")))->InitFrom( DLong64GDL(MemStats::GetNumAlloc()));
+        (retStru->GetTag(retStru->Desc()->TagIndex("NUM_FREE")))->InitFrom( DLong64GDL(MemStats::GetNumFree()));
+        (retStru->GetTag(retStru->Desc()->TagIndex("HIGHWATER")))->InitFrom( DLong64GDL(MemStats::GetHighWater()));
+      }
+      else 
+      {
+        ret = new DStructGDL("IDL_MEMORY");
+        DStructGDL* retStru = static_cast<DStructGDL*>(ret);
+        (retStru->GetTag(retStru->Desc()->TagIndex("CURRENT")))->InitFrom( DLongGDL(MemStats::GetCurrent()));
+        (retStru->GetTag(retStru->Desc()->TagIndex("NUM_ALLOC")))->InitFrom( DLongGDL(MemStats::GetNumAlloc()));
+        (retStru->GetTag(retStru->Desc()->TagIndex("NUM_FREE")))->InitFrom( DLongGDL(MemStats::GetNumFree()));
+        (retStru->GetTag(retStru->Desc()->TagIndex("HIGHWATER")))->InitFrom( DLongGDL(MemStats::GetHighWater()));
+      }
+    }
+    else 
+    {
+      bool kw_current = e->KeywordSet(e->KeywordIx("CURRENT"));
+      bool kw_num_alloc = e->KeywordSet(e->KeywordIx("NUM_ALLOC"));
+      bool kw_num_free = e->KeywordSet(e->KeywordIx("NUM_FREE"));
+      bool kw_highwater = e->KeywordSet(e->KeywordIx("HIGHWATER"));
+
+      // Following the IDL documentation: mutually exclusive keywords
+      // IDL behaves different, incl. segfaults with selected kw combinations
+      if (kw_current + kw_num_alloc + kw_num_free + kw_highwater > 1) 
+        e->Throw("CURRENT, NUM_ALLOC, NUM_FREE & HIGHWATER keywords"
+          " are mutually exclusive");
+
+      if (kw_current)
+      {
+        if (kw_l64) ret = new DLong64GDL(MemStats::GetCurrent());
+        else ret = new DLongGDL(MemStats::GetCurrent());
+      } 
+      else if (kw_num_alloc)
+      {
+        if (kw_l64) ret = new DLong64GDL(MemStats::GetNumAlloc());
+        else ret = new DLongGDL(MemStats::GetNumAlloc());
+      }
+      else if (kw_num_free)
+      {
+        if (kw_l64) ret = new DLong64GDL(MemStats::GetNumFree());
+        else ret = new DLongGDL(MemStats::GetNumFree());
+      }
+      else if (kw_highwater)
+      {
+        if (kw_l64) ret = new DLong64GDL(MemStats::GetHighWater());
+        else ret = new DLongGDL(MemStats::GetHighWater());
+      }
+      else 
+      {
+        // returning 4-element array 
+        if (kw_l64) 
+        {
+          ret = new DLong64GDL(dimension(4));
+          (*static_cast<DLong64GDL*>(ret))[0] = MemStats::GetCurrent();
+          (*static_cast<DLong64GDL*>(ret))[1] = MemStats::GetNumAlloc();
+          (*static_cast<DLong64GDL*>(ret))[2] = MemStats::GetNumFree();
+          (*static_cast<DLong64GDL*>(ret))[3] = MemStats::GetHighWater();
+        }
+        else 
+        {
+          ret = new DLongGDL(dimension(4));
+          (*static_cast<DLongGDL*>(ret))[0] = MemStats::GetCurrent();
+          (*static_cast<DLongGDL*>(ret))[1] = MemStats::GetNumAlloc();
+          (*static_cast<DLongGDL*>(ret))[2] = MemStats::GetNumFree();
+          (*static_cast<DLongGDL*>(ret))[3] = MemStats::GetHighWater();
+        }
+      }
+    }
+
+    return ret;
+  }
+
+  inline DByte StrCmp( const string& s1, const string& s2, DLong n)
+  {
+    if( n <= 0) return 1;
+    if( s1.substr(0,n) == s2.substr(0,n)) return 1;
+    return 0;
+  }
+  inline DByte StrCmp( const string& s1, const string& s2)
+  {
+    if( s1 == s2) return 1;
+    return 0;
+  }
+  inline DByte StrCmpFold( const string& s1, const string& s2, DLong n)
+  {
+    if( n <= 0) return 1;
+    if( StrUpCase( s1.substr(0,n)) == StrUpCase(s2.substr(0,n))) return 1;
+    return 0;
+  }
+  inline DByte StrCmpFold( const string& s1, const string& s2)
+  {
+    if( StrUpCase( s1) == StrUpCase(s2)) return 1;
+    return 0;
+  }
+
+  BaseGDL* strcmp_fun( EnvT* e)
+  {
+    SizeT nParam=e->NParam(2);
+
+    DStringGDL* s0 = static_cast<DStringGDL*>( e->GetParAs< DStringGDL>( 0));
+    DStringGDL* s1 = static_cast<DStringGDL*>( e->GetParAs< DStringGDL>( 1));
+
+    DLongGDL* l2 = NULL;
+    if( nParam > 2)
+      {
+	l2 = static_cast<DLongGDL*>( e->GetParAs< DLongGDL>( 2));
+      }
+
+    static int foldIx = e->KeywordIx( "FOLD_CASE");
+    bool fold = e->KeywordSet( foldIx );
+    
+    if( s0->Scalar() && s1->Scalar())
+      {
+	if( l2 == NULL)
+	  {
+	    if( fold)
+	      return new DByteGDL( StrCmpFold( (*s0)[0], (*s1)[0]));
+	    else
+	      return new DByteGDL( StrCmp( (*s0)[0], (*s1)[0]));
+	  }
+	else
+	  {
+	    DByteGDL* res = new DByteGDL( l2->Dim(), BaseGDL::NOZERO);
+	    SizeT nEl = l2->N_Elements();
+	    if( fold)
+	      for( SizeT i=0; i<nEl; ++i)
+		(*res)[i] = StrCmpFold( (*s0)[0], (*s1)[0], (*l2)[i]);
+	    else
+	      for( SizeT i=0; i<nEl; ++i)
+		(*res)[i] = StrCmp( (*s0)[0], (*s1)[0], (*l2)[i]);
+	    return res;
+	  }
+      }
+    else // at least one array
+      {
+	if( l2 == NULL)
+	  {
+	    if( s0->Scalar())
+	      {
+		DByteGDL* res = new DByteGDL( s1->Dim(), BaseGDL::NOZERO);
+		SizeT nEl = s1->N_Elements();
+		if( fold)
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmpFold( (*s0)[0], (*s1)[i]);
+		else
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmp( (*s0)[0], (*s1)[i]);
+		return res;
+	      }
+	    else if( s1->Scalar())
+	      {
+		DByteGDL* res = new DByteGDL( s0->Dim(), BaseGDL::NOZERO);
+		SizeT nEl = s0->N_Elements();
+		if( fold)
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmpFold( (*s0)[i], (*s1)[0]);
+		else
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmp( (*s0)[i], (*s1)[0]);
+		return res;
+	      }
+	    else // both arrays
+	      {
+		DByteGDL* res;
+		SizeT    nEl;
+		if( s0->N_Elements() <= s1->N_Elements())
+		  {
+		    res = new DByteGDL( s0->Dim(), BaseGDL::NOZERO);
+		    nEl = s0->N_Elements();
+		  }
+		else		      
+		  {
+		    res = new DByteGDL( s1->Dim(), BaseGDL::NOZERO);
+		    nEl = s1->N_Elements();
+		  }
+		if( fold)
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmpFold( (*s0)[i], (*s1)[i]);
+		else
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmp( (*s0)[i], (*s1)[i]);
+		return res;
+	      }
+	  }
+	else // l2 != NULL
+	  {
+	    DByteGDL* res;
+	    SizeT    nEl;
+	    bool l2Scalar = l2->Scalar();
+	    if( s0->Scalar())
+	      {
+		if( l2Scalar || s1->N_Elements() <= l2->N_Elements())
+		  {
+		    res = new DByteGDL( s1->Dim(), BaseGDL::NOZERO);
+		    nEl = s1->N_Elements();
+		  }
+		else
+		  {
+		    res = new DByteGDL( l2->Dim(), BaseGDL::NOZERO);
+		    nEl = l2->N_Elements();
+		  }
+		if( fold)
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmpFold( (*s0)[0], (*s1)[i], (*l2)[l2Scalar?0:i]);
+		else
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmp( (*s0)[0], (*s1)[i], (*l2)[l2Scalar?0:i]);
+		return res;
+	      }
+	    else if( s1->Scalar())
+	      {
+		if( l2Scalar || s0->N_Elements() <= l2->N_Elements())
+		  {
+		    res = new DByteGDL( s0->Dim(), BaseGDL::NOZERO);
+		    nEl = s0->N_Elements();
+		  }
+		else
+		  {
+		    res = new DByteGDL( l2->Dim(), BaseGDL::NOZERO);
+		    nEl = l2->N_Elements();
+		  }
+		if( fold)
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmpFold( (*s0)[i], (*s1)[0], (*l2)[l2Scalar?0:i]);
+		else
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmp( (*s0)[i], (*s1)[0], (*l2)[l2Scalar?0:i]);
+		return res;
+	      }
+	    else // s1 and s2 are arrays
+	      {
+		if( l2Scalar)
+		  if( s0->N_Elements() <= s1->N_Elements())
+		    {
+		      res = new DByteGDL( s0->Dim(), BaseGDL::NOZERO);
+		      nEl = s0->N_Elements();
+		    }
+		  else 
+		    {
+		      res = new DByteGDL( s1->Dim(), BaseGDL::NOZERO);
+		      nEl = s1->N_Elements();
+		    }
+		else 
+		  {
+		    if( s0->N_Elements() <= s1->N_Elements())
+		      if( s0->N_Elements() <= l2->N_Elements())
+			{
+			  res = new DByteGDL( s0->Dim(), BaseGDL::NOZERO);
+			  nEl = s0->N_Elements();
+			}
+		      else
+			{
+			  res = new DByteGDL( l2->Dim(), BaseGDL::NOZERO);
+			  nEl = l2->N_Elements();
+			}
+		    else
+		      if( s1->N_Elements() <= l2->N_Elements())
+			{
+			  res = new DByteGDL( s1->Dim(), BaseGDL::NOZERO);
+			  nEl = s1->N_Elements();
+			}
+		      else
+			{
+			  res = new DByteGDL( l2->Dim(), BaseGDL::NOZERO);
+			  nEl = l2->N_Elements();
+			}
+		  }
+		if( fold)
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmpFold( (*s0)[i], (*s1)[i], (*l2)[l2Scalar?0:i]);
+		else
+		  for( SizeT i=0; i<nEl; ++i)
+		    (*res)[i] = StrCmp( (*s0)[i], (*s1)[i], (*l2)[l2Scalar?0:i]);
+		return res;
+	      }
+	  }
+      }
+  }
+
+  string TagName( EnvT* e, const string& name)
+  {
+    string n = StrUpCase( name);
+    SizeT len = n.size();
+    if( n[0] != '_' && n[0] != '!' && (n[0] < 'A' || n[0] > 'Z'))
+      e->Throw( "Illegal tag name: "+name+".");
+    for( SizeT i=1; i<len; ++i)
+      {
+	if( n[i] == ' ')
+	  n[i] = '_';
+	else 
+	  if( n[i] != '_' && n[i] != '$' && //n[0] != '!' &&
+	      (n[i] < 'A' || n[i] > 'Z') &&
+	      (n[i] < '0' || n[i] > '9'))
+	    e->Throw( "Illegal tag name: "+name+".");
+      }
+    return n;
+  }
+
+  BaseGDL* create_struct( EnvT* e)
+  {
+    static int nameIx = e->KeywordIx( "NAME" );
+    DString name = "$truct";
+    if( e->KeywordPresent( nameIx)) {
+      // Check if name exists, if not then treat as unnamed
+      if (e->GetKW( nameIx) != NULL)
+	e->AssureStringScalarKW( nameIx, name);
+    }
+
+    if( name != "$truct") // named struct
+      {
+	name = StrUpCase( name);
+	
+	SizeT nParam=e->NParam();
+
+	if( nParam == 0)
+	  {
+	    DStructDesc* desc = 
+	      e->Interpreter()->GetStruct( name, e->CallingNode());
+	   
+	    dimension dim( 1);
+	    return new DStructGDL( desc, dim);
+	  }
+
+	DStructDesc*          nStructDesc;
+	Guard<DStructDesc> nStructDescGuard;
+	
+	DStructDesc* oStructDesc=
+	  FindInStructList( structList, name);
+	
+	if( oStructDesc == NULL || oStructDesc->NTags() > 0)
+	  {
+	    // not defined at all yet (-> define now)
+	    // or completely defined  (-> define now and check equality)
+	    nStructDesc= new DStructDesc( name);
+                    
+	    // guard it
+	    nStructDescGuard.Reset( nStructDesc); 
+	  }
+	else
+	  {   
+	    // NTags() == 0
+	    // not completely defined (only name in list)
+	    nStructDesc= oStructDesc;
+	  }
+                
+	// the instance variable
+	// 	dimension dim( 1);
+	// 	DStructGDL* instance = new DStructGDL( nStructDesc, dim);
+	DStructGDL* instance = new DStructGDL( nStructDesc);
+	Guard<DStructGDL> instance_guard(instance);
+
+	for( SizeT p=0; p<nParam; ++p)
+	  {
+	    BaseGDL* par = e->GetParDefined( p);
+	    DStructGDL* parStruct = dynamic_cast<DStructGDL*>( par);
+	    if( parStruct != NULL)
+	      {
+		// add struct
+		if( !parStruct->Scalar())
+		  e->Throw("Expression must be a scalar in this context: "+
+			   e->GetParString( p));
+		
+		DStructDesc* desc = parStruct->Desc();
+		for( SizeT t=0; t< desc->NTags(); ++t)
+		  {
+		    instance->NewTag( desc->TagName( t), 
+				      parStruct->GetTag( t)->Dup());
+		  }
+	      }
+	    else
+	      {
+		// add tag value pair
+		DStringGDL* tagNames = e->GetParAs<DStringGDL>( p);
+		SizeT nTags = tagNames->N_Elements();
+
+		SizeT tagStart = p+1;
+		SizeT tagEnd   = p+nTags;
+		if( tagEnd >= nParam)
+		  e->Throw( "Incorrect number of arguments.");
+
+		do{
+		  ++p;
+		  BaseGDL* value = e->GetParDefined( p);
+		    
+		  // add 
+		  instance->NewTag( TagName( e, (*tagNames)[ p-tagStart]),
+				    value->Dup());
+		} 
+		while( p<tagEnd);
+	      }
+	  }
+
+	if( oStructDesc != NULL)
+	  {
+	    if( oStructDesc != nStructDesc)
+	      {
+		oStructDesc->AssureIdentical(nStructDesc);
+		instance->DStructGDL::SetDesc(oStructDesc);
+		//delete nStructDesc; // auto_ptr
+	      }
+	  }
+	else
+	  {
+	    // release from guard (if not NULL)
+	    nStructDescGuard.release();
+	    // insert into struct list 
+	    structList.push_back(nStructDesc);
+	  }
+	
+	instance_guard.release();
+	return instance;
+      }
+    else 
+      { // unnamed struc
+
+	// Handle case of single structure parameter
+	SizeT nParam;
+	nParam = e->NParam(1);
+	BaseGDL* par = e->GetParDefined( 0);
+	DStructGDL* parStruct = dynamic_cast<DStructGDL*>( par);
+	if (nParam != 1 || parStruct == NULL)
+	  nParam=e->NParam(2);
+
+	DStructDesc*          nStructDesc = new DStructDesc( "$truct");
+	// instance takes care of nStructDesc since it is unnamed
+	// 	dimension dim( 1);
+	// 	DStructGDL* instance = new DStructGDL( nStructDesc, dim);
+	DStructGDL* instance = new DStructGDL( nStructDesc);
+	Guard<DStructGDL> instance_guard(instance);
+
+	for( SizeT p=0; p<nParam;)
+	  {
+	    BaseGDL* par = e->GetParDefined( p);
+	    DStructGDL* parStruct = dynamic_cast<DStructGDL*>( par);
+	    if( parStruct != NULL)
+	      {
+		// add struct
+		if( !parStruct->Scalar())
+		  e->Throw("Expression must be a scalar in this context: "+
+			   e->GetParString( p));
+		
+		DStructDesc* desc = parStruct->Desc();
+		for( SizeT t=0; t< desc->NTags(); ++t)
+		  {
+		    instance->NewTag( desc->TagName( t), 
+				      parStruct->GetTag( t)->Dup());
+		  }
+		++p;
+	      }
+	    else
+	      {
+		// add tag value pair
+		DStringGDL* tagNames = e->GetParAs<DStringGDL>( p);
+		SizeT nTags = tagNames->N_Elements();
+
+		SizeT tagStart = p+1;
+		SizeT tagEnd   = p+nTags;
+		if( tagEnd >= nParam)
+		  e->Throw( "Incorrect number of arguments.");
+
+		for(++p; p<=tagEnd; ++p)
+		  {
+		    BaseGDL* value = e->GetParDefined( p);
+
+		    // add 
+		    instance->NewTag( TagName( e, (*tagNames)[ p-tagStart]),
+				      value->Dup());
+		  }
+	      }
+	  }
+	
+	instance_guard.release();
+	return instance;
+      }
+  }
+
+  BaseGDL* rotate( EnvT* e)
+  {
+    e->NParam(2);
+    BaseGDL* p0 = e->GetParDefined( 0);
+
+    if( p0->Rank() == 0)
+      e->Throw( "Expression must be an array in this context: " + e->GetParString( 0));
+
+    if( p0->Rank() != 1 && p0->Rank() != 2)
+      e->Throw( "Only 1 or 2 dimensions allowed: " + e->GetParString( 0));
+
+    if( p0->Type() == GDL_STRUCT)
+      e->Throw( "STRUCT expression not allowed in this context: "+
+		e->GetParString( 0));
+    
+    DLong dir;
+    e->AssureLongScalarPar( 1, dir);
+
+    return p0->Rotate( dir);
+  }
+
+  // SA: based on the code of rotate() (above)
+  BaseGDL* reverse( EnvT* e)
+  {
+    e->NParam(1);
+    BaseGDL* p0 = e->GetParDefined(0);
+    if (p0->Rank() == 0) return p0->Dup();
+
+    DLong dim = 1;
+    if (e->GetPar(1) != NULL) 
+      e->AssureLongScalarPar(1, dim);
+    if (p0->Rank() != 0 && (dim > p0->Rank() || dim < 1))
+      e->Throw("Subscript_index must be positive and less than or equal to number of dimensions.");
+
+    BaseGDL* ret;
+    // IDL doc states that OVERWRITE is ignored for one- or two-dim. arrays 
+    // but it seems to behave differently
+    // if (p0->Rank() > 2 && e->KeywordSet("OVERWRITE") && e->GlobalPar(0))
+    if (e->KeywordSet("OVERWRITE"))
+    {
+      p0->Reverse(dim-1);
+      bool stolen = e->StealLocalPar( 0);
+      if( !stolen) e->GetPar(0) = NULL;
+      return p0;
+    }
+    else ret = p0->DupReverse(dim - 1);
+    return ret;
+  }
+
+  // SA: parse_url based on the PHP parse_url() function code
+  //     by Jim Winstead / The PHP Group (PHP license v. 3.01)
+  //     (http://svn.php.net/viewvc/php/php-src/trunk/ext/standard/url.c)
+  //     PHP is free software available at http://www.php.net/software/
+  //
+  //     notes: 
+  //     - IDL does not support IPv6 URLs, GDL does 
+  //     - IDL includes characters after '#' in the QUERY part, GDL
+  //       just skips them and issues a warning (perhaps not needed)
+  //     - IDL preserves controll characters in URLs, GDL preserves
+  //       them as well but a warning is issued
+  //     - IDL sets 80 as a default value for PORT, even if the url has 
+  //       an ftp:// schema indicated - GDL does not have any default value
+  //     - IDL excludes the leading "/" from the path, GDL preserves it
+  //     ... these differences seem just rational for me but please do change
+  //         it if IDL-compatibility would be beneficial for any reason here
+
+  BaseGDL* parse_url(EnvT* env)
+  {
+    // sanity check for number of parameters
+    SizeT nParam = env->NParam();
+
+    // 1-nd argument : the url string
+    DString url; 
+    env->AssureScalarPar<DStringGDL>(0, url); 
+
+    // sanity check for controll characters
+    string::iterator it;
+    for (it = url.begin(); it < url.end(); it++) if (iscntrl(*it))
+    {
+      Warning("PARSE_URL: URL contains a control character");
+      break;
+    }
+
+    // creating the output anonymous structure
+    DStructDesc* urlstru_desc = new DStructDesc("$truct");
+    SpDString aString;
+    urlstru_desc->AddTag("SCHEME",   &aString);
+    static size_t ixSCHEME = 0;
+    urlstru_desc->AddTag("USERNAME", &aString);
+    urlstru_desc->AddTag("PASSWORD", &aString);
+    urlstru_desc->AddTag("HOST",     &aString);
+    urlstru_desc->AddTag("PORT",     &aString);
+    static size_t ixPORT = 4;
+    urlstru_desc->AddTag("PATH",     &aString);
+    urlstru_desc->AddTag("QUERY",    &aString);
+    DStructGDL* urlstru = new DStructGDL(urlstru_desc, dimension());
+    Guard<DStructGDL> urlstru_guard(urlstru);
+          
+    // parsing the URL
+    char const *str = url.c_str();
+    size_t length = url.length();
+    char port_buf[6];
+    char const *s, *e, *p, *pp, *ue;
+		
+    s = str;
+    ue = s + length;
+
+    // parsing scheme 
+    if ((e = (const char*)memchr(s, ':', length)) && (e - s)) 
+    {
+      // validating scheme 
+      p = s;
+      while (p < e) 
+      {
+        // scheme = 1*[ lowalpha | digit | "+" | "-" | "." ]
+        if (!isalpha(*p) && !isdigit(*p) && *p != '+' && *p != '.' && *p != '-') 
+        {
+          if (e + 1 < ue) goto parse_port;
+          else goto just_path;
+        }
+        p++;
+      }
+      if (*(e + 1) == '\0') 
+      { 
+        // only scheme is available 
+        urlstru->InitTag("SCHEME", DStringGDL(string(s, (e - s))));
+        goto end;
+      }
+      // schemas without '/' (like mailto: and zlib:) 
+      if (*(e+1) != '/') 
+      {
+        // check if the data we get is a port this allows us to correctly parse things like a.com:80
+        p = e + 1;
+        while (isdigit(*p)) p++;
+	if ((*p == '\0' || *p == '/') && (p - e) < 7) goto parse_port;
+        urlstru->InitTag("SCHEME", DStringGDL(string(s, (e - s))));
+        length -= ++e - s;
+        s = e;
+        goto just_path;
+      } 
+      else 
+      {
+        urlstru->InitTag("SCHEME", DStringGDL(string(s, (e - s))));
+        if (*(e+2) == '/') 
+        {
+          s = e + 3;
+          if (!strncasecmp("file", 
+            (*static_cast<DStringGDL*>(urlstru->GetTag(ixSCHEME)))[0].c_str(), 
+            sizeof("file")
+          )) 
+          {
+            if (*(e + 3) == '/') 
+            {
+              // support windows drive letters as in: file:///c:/somedir/file.txt
+              if (*(e + 5) == ':') s = e + 4;
+              goto nohost;
+            }
+          }
+        } 
+        else 
+        {
+          if (!strncasecmp("file", 
+            (*static_cast<DStringGDL*>(urlstru->GetTag(ixSCHEME)))[0].c_str(), 
+            sizeof("file"))
+          ) 
+          {
+            s = e + 1;
+            goto nohost;
+          } 
+          else 
+          {
+            length -= ++e - s;
+            s = e;
+            goto just_path;
+          }	
+        }
+      }	
+    } 
+    else if (e) 
+    { 
+      // no scheme, look for port 
+      parse_port:
+      p = e + 1;
+      pp = p;
+      while (pp-p < 6 && isdigit(*pp)) pp++;
+      if (pp-p < 6 && (*pp == '/' || *pp == '\0')) 
+      {
+        memcpy(port_buf, p, (pp-p));
+        port_buf[pp-p] = '\0';
+        urlstru->InitTag("PORT", DStringGDL(port_buf));
+      } 
+      else goto just_path;
+    } 
+    else 
+    {
+      just_path:
+      ue = s + length;
+      goto nohost;
+    }
+    e = ue;
+    if (!(p = (const char*)memchr(s, '/', (ue - s)))) 
+    {
+      if ((p = (const char*)memchr(s, '?', (ue - s)))) e = p;
+      else if ((p = (const char*)memchr(s, '#', (ue - s)))) e = p;
+    } 
+    else e = p;
+    // check for login and password 
+    {
+      size_t pos;
+      if ((pos = string(s, e - s).find_last_of("@")) != string::npos)
+      {
+        p = s + pos;
+        if ((pp = (const char*)memchr(s, ':', (p-s)))) 
+        {
+          if ((pp-s) > 0) urlstru->InitTag("USERNAME", DStringGDL(string(s, (pp - s))));
+          pp++;
+          if (p-pp > 0) urlstru->InitTag("PASSWORD", DStringGDL(string(pp, (p - pp))));
+        } 
+        else urlstru->InitTag("USERNAME", DStringGDL(string(s, (p - s))));
+        s = p + 1;
+      }
+    }
+    // check for port 
+    if (*s == '[' && *(e-1) == ']') p = s;     // IPv6 embedded address 
+    else for(p = e; *p != ':' && p >= s; p--); // memrchr is a GNU extension 
+    if (p >= s && *p == ':') 
+    {
+      if ((*static_cast<DStringGDL*>(urlstru->GetTag(ixPORT)))[0].length() == 0) 
+      {
+        p++;
+        if (e-p > 5) env->Throw("port cannot be longer then 5 characters");
+	else if (e - p > 0) 
+        {
+          memcpy(port_buf, p, (e-p));
+          port_buf[e-p] = '\0';
+          urlstru->InitTag("PORT", DStringGDL(port_buf));
+        }
+        p--;
+      }	
+    } 
+    else p = e;
+    // check if we have a valid host, if we don't reject the string as url 
+    if ((p-s) < 1) env->Throw("invalid host");
+    urlstru->InitTag("HOST", DStringGDL(string(s, (p - s))));
+    if (e == ue) goto end;
+    s = e;
+    nohost:
+    if ((p = (const char*)memchr(s, '?', (ue - s)))) 
+    {
+      pp = strchr(s, '#');
+      if (pp && pp < p) 
+      {
+        p = pp;
+        pp = strchr(pp+2, '#');
+      }
+      if (p - s) urlstru->InitTag("PATH", DStringGDL(string(s, (p - s))));
+      if (pp) 
+      {
+        if (pp - ++p) urlstru->InitTag("QUERY", DStringGDL(string(p, (pp - p))));
+        p = pp;
+        goto label_parse;
+      } 
+      else if (++p - ue) urlstru->InitTag("QUERY", DStringGDL(string(p, (ue - p))));
+    } 
+    else if ((p = (const char*)memchr(s, '#', (ue - s)))) 
+    {
+      if (p - s) urlstru->InitTag("PATH", DStringGDL(string(s, (p - s))));
+      label_parse:
+      p++;
+      if (ue - p) Warning("PARSE_URL: URL fragment left out: #" + string(p, (ue-p)));
+    } 
+    else urlstru->InitTag("PATH", DStringGDL(string(s, (ue - s))));
+    end:
+
+    // returning the result
+    urlstru_guard.release();
+    return urlstru;
+  }
+
+  BaseGDL* locale_get(EnvT* e)
+  {
+#ifdef HAVE_LOCALE_H
+
+    // make GDL inherit the calling process locale
+    setlocale(LC_ALL, "");
+    // note doen the inherited locale
+    DStringGDL *locale = new DStringGDL(setlocale(LC_CTYPE, NULL));
+    // return to the C locale
+    setlocale(LC_ALL, "C");
+
+    return locale;
+#else
+    e->Throw("OS does not provide locale information");
+#endif
+  }
+
+  // SA: relies on the contents of the lib::command_line_args vector
+  //     defined and filled with data (pointers) in gdl.cpp
+  BaseGDL* command_line_args_fun(EnvT* e)
+  {
+#ifdef PYTHON_MODULE
+    e->Throw("no command line arguments available (GDL built as a Python module)");
+#else
+    static int countIx = e->KeywordIx("COUNT");
+    extern std::vector<char*> command_line_args; 
+
+    // setting the COUNT keyword value
+    if (e->KeywordPresent(countIx))
+    {
+      e->AssureGlobalKW(countIx);
+      e->SetKW(countIx, new DLongGDL(command_line_args.size()));
+    }
+
+    // returning empty string or an array of arguments
+    if (command_line_args.empty()) return new DStringGDL("");
+    else
+    {
+      BaseGDL* ret = new DStringGDL(dimension(command_line_args.size()));   
+      for (size_t i = 0; i < command_line_args.size(); i++)
+        (*static_cast<DStringGDL*>(ret))[i] = command_line_args[i];
+      return ret;
+    }
+#endif
+  }
+
+  // SA: relies in the uname() from libc (must be there if POSIX)
+  BaseGDL* get_login_info( EnvT* e)
+  {
+    // getting the info 
+#ifdef _MSC_VER
+    #define MAX_TCHAR_BUF 256
+
+    char login[MAX_TCHAR_BUF];
+    char info[MAX_TCHAR_BUF];
+
+    DWORD N_TCHAR = MAX_TCHAR_BUF;
+
+    #ifdef _UNICODE
+    TCHAR t_buf[MAX_TCHAR_BUF];
+    GetUserName(t_buf, &N_TCHAR);
+    WideCharToMultiByte(CP_ACP, 0, t_buf, N_TCHAR, login, N_TCHAR, NULL, NULL);
+    GetComputerName( t_buf, &N_TCHAR );
+    WideCharToMultiByte(CP_ACP, 0, t_buf, N_TCHAR, info, N_TCHAR, NULL, NULL);
+    #else
+    GetUserName(login, &N_TCHAR);
+    GetComputerName(info, &N_TCHAR);
+    #endif
+#else
+    char* login = getlogin();
+    if (login == NULL) e->Throw("Failed to get user name from the OS"); 
+    struct utsname info;
+    if (0 != uname(&info)) e->Throw("Failed to get machine name from the OS");
+#endif
+    // creating the output anonymous structure
+    DStructDesc* stru_desc = new DStructDesc("$truct");
+    SpDString aString;
+    stru_desc->AddTag("MACHINE_NAME", &aString);
+    stru_desc->AddTag("USER_NAME", &aString);
+    DStructGDL* stru = new DStructGDL(stru_desc, dimension());
+
+    // returning the info 
+    stru->InitTag("USER_NAME", DStringGDL(login));
+#ifdef _MSC_VER
+    stru->InitTag("MACHINE_NAME", DStringGDL(info));
+#else
+    stru->InitTag("MACHINE_NAME", DStringGDL(info.nodename));
+#endif
+    return stru;
+  }
+
+  // SA: base64 logic in base64.hpp, based on code by Bob Withers (consult base64.hpp)
+  BaseGDL* idl_base64(EnvT* e)
+  {
+    BaseGDL* p0 = e->GetPar(0);    
+    if (p0 != NULL)
+    { 
+      if (p0->Rank() == 0 && p0->Type() == GDL_STRING)
+      {
+        // decoding
+        string* str = &((*static_cast<DStringGDL*>(p0))[0]);
+        if (str->length() == 0) return new DByteGDL(0);
+        if (str->length() % 4 != 0) 
+          e->Throw("Input string length must be a multiple of 4");
+        unsigned int retlen = base64::decodeSize(*str);
+        if (retlen == 0 || retlen > str->length()) e->Throw("No data in the input string");
+        DByteGDL* ret = new DByteGDL(dimension(retlen));
+        if (!base64::decode(*str, (char*)&((*ret)[0]), ret->N_Elements()))
+          e->Throw("Base64 decoder failed"); 
+        return ret;
+      }
+      if (p0->Rank() >= 1 && p0->Type() == GDL_BYTE)
+      {
+        // encoding
+        return new DStringGDL(
+          base64::encode((char*)&(*static_cast<DByteGDL*>(p0))[0], p0->N_Elements())
+        );
+      } 
+    }
+    e->Throw("Expecting string or byte array as a first parameter");
+  }
+
+  BaseGDL* get_drive_list(EnvT* e)
+  {
+    if (e->KeywordPresent(0)) e->SetKW(0, new DLongGDL(0));
+    return new DStringGDL("");
+  }
+
+  // note: changes here MUST be reflected in scope_varfetch_reference() as well
+  // because DLibFun of this function is used for scope_varfetch_reference() the keyword
+  // indices must match
+  BaseGDL* scope_varfetch_value( EnvT* e) 
+  {
+    SizeT nParam=e->NParam();
+
+    EnvStackT& callStack = e->Interpreter()->CallStack();
+//     DLong curlevnum = callStack.size()-1;
+// 'e' is not on the stack
+    DLong curlevnum = callStack.size();
+
+//     static int variablesIx = e->KeywordIx( "VARIABLES" );
+    static int levelIx = e->KeywordIx( "LEVEL" );
+
+    DLongGDL* level = e->IfDefGetKWAs<DLongGDL>( levelIx);
+
+    DLong desiredlevnum = 0;
+      
+    if (level != NULL)
+      desiredlevnum = (*level)[0];
+
+    if (desiredlevnum <= 0) desiredlevnum += curlevnum;
+    if (desiredlevnum < 1) desiredlevnum = 1;
+    else if (desiredlevnum > curlevnum) desiredlevnum = curlevnum;
+
+    DSubUD* pro = static_cast<DSubUD*>(callStack[desiredlevnum-1]->GetPro());
+
+    SizeT nVar = pro->Size(); // # var in GDL for desired level 
+    int nKey = pro->NKey();
+
+    DString varName;
+
+    e->AssureScalarPar<DStringGDL>( 0, varName);
+    varName = StrUpCase( varName);
+
+    int xI = pro->FindVar( varName);
+    if (xI != -1) 
+    {
+//       BaseGDL*& par = ((EnvT*)(callStack[desiredlevnum-1]))->GetPar( xI);
+      BaseGDL*& par = callStack[desiredlevnum-1]->GetKW( xI);
+
+      if( par == NULL)
+	e->Throw( "Variable is undefined: " + varName);
+
+      return par->Dup();
+    }
+	
+    e->Throw( "Variable not found: " + varName);
+    return new DLongGDL(0); // compiler shut-up
+  }
+
+  // this routine is special, only called as an l-function (from FCALL_LIB::LEval())
+  // it MUST use an EnvT set up for scope_varfetch_value
+  BaseGDL** scope_varfetch_reference( EnvT* e) 
+  {
+    SizeT nParam=e->NParam();
+
+    EnvStackT& callStack = e->Interpreter()->CallStack();
+//     DLong curlevnum = callStack.size()-1;
+// 'e' is not on the stack
+    DLong curlevnum = callStack.size();
+
+//     static int variablesIx = e->KeywordIx( "VARIABLES" );
+    static int levelIx = e->KeywordIx( "LEVEL" );
+
+    DLongGDL* level = e->IfDefGetKWAs<DLongGDL>( levelIx);
+
+    DLong desiredlevnum = 0;
+      
+    if (level != NULL)
+      desiredlevnum = (*level)[0];
+
+    if (desiredlevnum <= 0) desiredlevnum += curlevnum;
+    if (desiredlevnum < 1) desiredlevnum = 1;
+    else if (desiredlevnum > curlevnum) desiredlevnum = curlevnum;
+
+    DSubUD* pro = static_cast<DSubUD*>(callStack[desiredlevnum-1]->GetPro());
+
+    SizeT nVar = pro->Size(); // # var in GDL for desired level 
+    int nKey = pro->NKey();
+
+    DString varName;
+
+    e->AssureScalarPar<DStringGDL>( 0, varName);
+    varName = StrUpCase( varName);
+    int xI = pro->FindVar( varName);
+    if (xI != -1) 
+    {
+//       BaseGDL*& par = ((EnvT*)(callStack[desiredlevnum-1]))->GetPar( xI);
+      BaseGDL*& par = callStack[desiredlevnum-1]->GetKW( xI);
+
+//       if( par == NULL)
+// 	e->Throw( "Variable is undefined: " + varName);
+
+      return &par;
+    }
+	
+    e->Throw( "LVariable not found: " + varName);
+    return NULL; // compiler shut-up
+  }
+  
+
+} // namespace
+
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/basic_fun_jmg.cpp gdl/src/basic_fun_jmg.cpp
--- gdl-0.9.3/src/basic_fun_jmg.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/basic_fun_jmg.cpp	2013-03-25 10:36:38.154970793 -0600
@@ -329,7 +329,7 @@
     e->AssureLongScalarKWIfPresent( typeIx, type);
 
     DLongGDL* dimKey=NULL;
-    auto_ptr<DLongGDL> dimKey_guard;
+    Guard<DLongGDL> dimKey_guard;
 
     static int sizeix = e->KeywordIx( "SIZE"); 
     static int dimensionix = e->KeywordIx( "DIMENSION"); 
@@ -344,7 +344,7 @@
 	  {
 	    dimension dim(l_dimension->N_Elements(),1);
 	    dimKey=new DLongGDL(dim, BaseGDL::NOZERO);
-	    dimKey_guard.reset( dimKey); //e->Guard( dimKey);
+	    dimKey_guard.Reset( dimKey); //e->Guard( dimKey);
 	    for (int i=0;i<l_dimension->N_Elements();++i)
 	      (*dimKey)[i]=(*l_dimension)[i];
 	  }
@@ -361,7 +361,7 @@
 	  {
 	    dimension dim((*l_size)[0],1);
 	    dimKey=new DLongGDL(dim, BaseGDL::NOZERO);
-	    dimKey_guard.reset( dimKey); //e->Guard( dimKey);
+	    dimKey_guard.Reset( dimKey); //e->Guard( dimKey);
 	    //	    e->Guard( dimKey);
 	    for (int i=1;i<=(*l_size)[0];++i)
 	      (*dimKey)[i-1]=(*l_size)[i];
@@ -387,7 +387,7 @@
 
     static int valueix = e->KeywordIx( "VALUE"); 
     BaseGDL* value = e->GetKW( valueix);
-    auto_ptr<BaseGDL> value_guard;
+    Guard<BaseGDL> value_guard;
     if( value != NULL)
       {
 	if( !value->Scalar())
@@ -398,7 +398,7 @@
 	else
 	  {
 	    value = value->Convert2( static_cast<DType>(type), BaseGDL::COPY);
-	    value_guard.reset(value);//e->Guard( value);
+	    value_guard.Reset(value);//e->Guard( value);
 	  }
       }
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/basic_op_add.cpp gdl/src/basic_op_add.cpp
--- gdl-0.9.3/src/basic_op_add.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/basic_op_add.cpp	2013-03-25 10:36:38.164970747 -0600
@@ -0,0 +1,423 @@
+/***************************************************************************
+                          basic_op_add.cpp  -  GDL add (+) operators
+                             -------------------
+    begin                : July 22 2002
+    copyright            : (C) 2002 by Marc Schellens
+    email                : m_schellens@users.sf.net
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+// to be included from datatypes.cpp
+#ifdef INCLUDE_BASIC_OP_CPP
+
+// // header in datatypes.hpp
+// 
+// //#include "datatypes.hpp"
+// //#include "dstructgdl.hpp"
+// //#include "arrayindex.hpp"
+// 
+// //#include <csignal>
+// #include "sigfpehandler.hpp"
+// 
+// #ifdef _OPENMP
+// #include <omp.h>
+// #endif
+// 
+// #include "typetraits.hpp"
+// 
+// using namespace std;
+
+
+// ************************
+// Add
+// ************************
+
+// also see Add...New operators (in basic_op_new.cpp)
+
+// Adds right to itself, //C deletes right
+// right must always have more or same number of elements
+template<class Sp>
+BaseGDL* Data_<Sp>::Add( BaseGDL* r)
+{
+  
+  
+  Data_* right=static_cast<Data_*>(r);
+
+  // ULong rEl=right->N_Elements();
+  ULong nEl=N_Elements();
+  // assert( rEl);
+  assert( nEl);
+  if( nEl == 1)
+    {
+      (*this)[0] += (*right)[0];
+      return this;
+    }
+#ifdef USE_EIGEN
+
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRight(&(*right)[0], nEl);
+	mThis += mRight;
+	return this;
+#else
+
+  TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+    {
+#pragma omp for
+      for( OMPInt i=0; i < nEl; ++i)
+	(*this)[i] += (*right)[i];
+    }  //C delete right;
+  return this;
+#endif
+  
+}
+template<class Sp>
+BaseGDL* Data_<Sp>::AddInv( BaseGDL* r)
+{
+  assert( this->Type() != GDL_OBJ); // should never be called via this
+  return Add( r); // this needs to be modified
+}
+template<>
+BaseGDL* Data_<SpDString>::AddInv( BaseGDL* r)
+{
+  Data_* right=static_cast<Data_*>(r);
+
+  // ULong rEl=right->N_Elements();
+  ULong nEl=N_Elements();
+  // assert( rEl);
+  assert( nEl);
+  if( nEl == 1)
+    {
+      (*this)[0] = (*right)[0] + (*this)[0];
+      return this;
+    }
+  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
+  TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+    {
+#pragma omp for
+      for( OMPInt i=0; i < nEl; ++i)
+	(*this)[i] = (*right)[i] + (*this)[i];
+    }  //C delete right;
+  return this;
+}
+// invalid types
+template<>
+BaseGDL* Data_<SpDPtr>::Add( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+  return this;
+}
+template<>
+BaseGDL* Data_<SpDObj>::Add( BaseGDL* r)
+{
+  // overload here
+  Data_* self;
+  DFun* plusOverload;
+  
+  ProgNodeP callingNode = interpreter->GetRetTree();
+
+  if( !Scalar())
+  {
+    if( r->Type() == GDL_OBJ && r->Scalar())
+    {
+      self = static_cast<Data_*>( r);
+      plusOverload = static_cast<DFun*>(GDLInterpreter::GetObjHeapOperator( (*self)[0], OOPlus));
+      if( plusOverload == NULL)
+      {
+	throw GDLException( callingNode, "Cannot apply not overloaded operator to datatype OBJECT.", true, false);
+      }
+    }
+    else
+      {
+	throw GDLException( callingNode, "Cannot apply operation to non-scalar datatype OBJECT.", true, false);
+      }
+  }
+  else
+  {
+    // Scalar()
+    self = static_cast<Data_*>( this);
+    plusOverload = static_cast<DFun*>(GDLInterpreter::GetObjHeapOperator( (*self)[0], OOPlus));
+    if( plusOverload == NULL)
+    {
+      if( r->Type() == GDL_OBJ && r->Scalar())
+      {
+	self = static_cast<Data_*>( r);
+	plusOverload = static_cast<DFun*>(GDLInterpreter::GetObjHeapOperator( (*self)[0], OOPlus));
+	if( plusOverload == NULL)
+	{
+	  throw GDLException(callingNode,"Cannot apply not overloaded operator to datatype OBJECT.",true, false);  
+	} 
+      }
+      else
+      {
+	throw GDLException( callingNode, "Cannot apply not overloaded operator to datatype OBJECT.", true, false);
+      }
+    }
+  }
+
+  assert( self->Scalar());
+  assert( plusOverload != NULL);
+
+  // hidden SELF is counted as well
+  int nParSub = plusOverload->NPar();
+  assert( nParSub >= 1); // SELF
+  if( nParSub < 3) // (SELF), LEFT, RIGHT
+  {
+    throw GDLException( callingNode, plusOverload->ObjectName() +
+		    ": Incorrect number of arguments.",
+		    false, false);
+  }
+  EnvUDT* newEnv;
+  Guard<BaseGDL> selfGuard;
+  BaseGDL* thisP;
+  // Dup() here is not optimal
+  // avoid at least for internal overload routines (which do/must not change SELF or r)
+  bool internalDSubUD = plusOverload->GetTree()->IsWrappedNode();  
+  if( internalDSubUD)  
+  {
+    thisP = this;
+    newEnv= new EnvUDT( callingNode, plusOverload, &self);
+    newEnv->SetNextParUnchecked( &thisP); // LEFT  parameter, as reference to prevent cleanup in newEnv
+    newEnv->SetNextParUnchecked( &r); // RVALUE  parameter, as reference to prevent cleanup in newEnv
+  }
+  else
+  {
+    self = self->Dup();
+    selfGuard.Init( self);
+    newEnv= new EnvUDT( callingNode, plusOverload, &self);
+    newEnv->SetNextParUnchecked( this->Dup()); // LEFT  parameter, as value
+    newEnv->SetNextParUnchecked( r->Dup()); // RIGHT parameter, as value
+  }
+
+  
+  // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+  StackGuard<EnvStackT> guard(interpreter->CallStack());
+
+  interpreter->CallStack().push_back( newEnv); 
+  
+  // make the call
+  BaseGDL* res=interpreter->call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
+
+  if( !internalDSubUD && self != selfGuard.Get())
+  {
+    // always put out warning first, in case of a later crash
+    Warning( "WARNING: " + plusOverload->ObjectName() + 
+	  ": Assignment to SELF detected (GDL session still ok).");
+    // assignment to SELF -> self was deleted and points to new variable
+    // which it owns
+    selfGuard.Release();
+    if( static_cast<BaseGDL*>(self) != NullGDL::GetSingleInstance())
+      selfGuard.Reset(self);
+  }
+  return res;
+}
+// difference from above: Order of parameters in call
+template<>
+BaseGDL* Data_<SpDObj>::AddInv( BaseGDL* r)
+{
+  if( r->Type() == GDL_OBJ && r->Scalar())
+  {
+    return r->Add( this); // for right order of parameters
+  }
+    
+  // overload here
+  Data_* self;
+  DFun* plusOverload;
+  
+  ProgNodeP callingNode = interpreter->GetRetTree();
+
+  if( !Scalar())
+  {
+    throw GDLException( callingNode, "Cannot apply operation to non-scalar datatype OBJECT.", true, false);
+  }
+  else
+  {
+    // Scalar()
+    self = static_cast<Data_*>( this);
+    plusOverload = static_cast<DFun*>(GDLInterpreter::GetObjHeapOperator( (*self)[0], OOPlus));
+    if( plusOverload == NULL)
+    {
+	throw GDLException( callingNode, "Cannot apply not overloaded operator to datatype OBJECT.", true, false);
+    }
+  }
+
+  assert( self->Scalar());
+  assert( plusOverload != NULL);
+
+  // hidden SELF is counted as well
+  int nParSub = plusOverload->NPar();
+  assert( nParSub >= 1); // SELF
+  if( nParSub < 3) // (SELF), LEFT, RIGHT
+  {
+    throw GDLException( callingNode, plusOverload->ObjectName() +
+		    ": Incorrect number of arguments.",
+		    false, false);
+  }
+  EnvUDT* newEnv;
+  Guard<BaseGDL> selfGuard;
+  BaseGDL* thisP;
+  // Dup() here is not optimal
+  // avoid at least for internal overload routines (which do/must not change SELF or r)
+  bool internalDSubUD = plusOverload->GetTree()->IsWrappedNode();  
+  if( internalDSubUD)  
+  {
+    thisP = this;
+    newEnv= new EnvUDT( callingNode, plusOverload, &self);
+    // order different to Add
+    newEnv->SetNextParUnchecked( &r); // RVALUE  parameter, as reference to prevent cleanup in newEnv
+    newEnv->SetNextParUnchecked( &thisP); // LEFT  parameter, as reference to prevent cleanup in newEnv
+  }
+  else
+  {
+    self = self->Dup();
+    selfGuard.Init( self);
+    newEnv= new EnvUDT( callingNode, plusOverload, &self);
+    // order different to Add
+    newEnv->SetNextParUnchecked( r->Dup()); // RIGHT parameter, as value
+    newEnv->SetNextParUnchecked( this->Dup()); // LEFT  parameter, as value
+  }
+
+  
+  // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+  StackGuard<EnvStackT> guard(interpreter->CallStack());
+
+  interpreter->CallStack().push_back( newEnv); 
+  
+  // make the call
+  BaseGDL* res=interpreter->call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
+
+  if( !internalDSubUD && self != selfGuard.Get())
+  {
+    // always put out warning first, in case of a later crash
+    Warning( "WARNING: " + plusOverload->ObjectName() + 
+	  ": Assignment to SELF detected (GDL session still ok).");
+    // assignment to SELF -> self was deleted and points to new variable
+    // which it owns
+    selfGuard.Release();
+    if( static_cast<BaseGDL*>(self) != NullGDL::GetSingleInstance())
+      selfGuard.Reset(self);
+  }
+  return res;
+}
+
+template<class Sp>
+BaseGDL* Data_<Sp>::AddS( BaseGDL* r)
+{
+  Data_* right=static_cast<Data_*>(r);
+
+  ULong nEl=N_Elements();
+  assert( nEl);
+  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
+  if( nEl == 1)
+    {
+      (*this)[0] += (*right)[0];
+      return this;
+    }
+  Ty s = (*right)[0];
+  // right->Scalar(s);
+  //  dd += s;
+#ifdef USE_EIGEN
+
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+	mThis += s;
+	return this;
+#else
+  TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+    {
+#pragma omp for
+      for( OMPInt i=0; i < nEl; ++i)
+	(*this)[i] += s;
+    }  //C delete right;
+  return this;
+#endif
+  
+}
+template<>
+BaseGDL* Data_<SpDString>::AddS( BaseGDL* r)
+{
+  Data_* right=static_cast<Data_*>(r);
+
+  ULong nEl=N_Elements();
+  assert( nEl);
+  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
+  if( nEl == 1)
+    {
+      (*this)[0] += (*right)[0];
+      return this;
+    }
+  Ty s = (*right)[0];
+  // right->Scalar(s);
+  //  dd += s;
+  TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+    {
+#pragma omp for
+      for( OMPInt i=0; i < nEl; ++i)
+	(*this)[i] += s;
+    }  //C delete right;
+  return this;
+}
+
+template<class Sp>
+BaseGDL* Data_<Sp>::AddInvS( BaseGDL* r)
+{
+  return AddS( r);
+}
+template<>
+BaseGDL* Data_<SpDString>::AddInvS( BaseGDL* r)
+{
+  Data_* right=static_cast<Data_*>(r);
+
+  ULong nEl=N_Elements();
+  assert( nEl);
+  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
+  if( nEl == 1)
+    {
+      (*this)[0] = (*right)[0] + (*this)[0] ;
+      return this;
+    }
+  Ty s = (*right)[0];
+  // right->Scalar(s);
+  TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+    {
+#pragma omp for
+      for( OMPInt i=0; i < nEl; ++i)
+	(*this)[i] = s + (*this)[i];
+    }  //C delete right;
+  return this;
+  
+}
+
+// invalid types
+template<>
+BaseGDL* Data_<SpDPtr>::AddS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+  return this;
+}
+template<>
+BaseGDL* Data_<SpDObj>::AddS( BaseGDL* r)
+{
+  return Add( r);
+}
+template<>
+BaseGDL* Data_<SpDObj>::AddInvS( BaseGDL* r)
+{
+  return AddInv( r);
+}
+
+
+//#include "instantiate_templates.hpp"
+
+#endif
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/basic_op.cpp gdl/src/basic_op.cpp
--- gdl-0.9.3/src/basic_op.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/basic_op.cpp	2013-05-16 12:36:33.138858195 -0600
@@ -31,11 +31,20 @@
 #include <omp.h>
 #endif
 
-#include "strassenmatrix.hpp"
+// #include "strassenmatrix.hpp"
 #include "typetraits.hpp"
 
 using namespace std;
 
+#if defined(USE_EIGEN)
+using namespace Eigen;
+#endif
+
+#include "basic_op_add.cpp"
+#include "basic_op_sub.cpp"
+#include "basic_op_mult.cpp"
+#include "basic_op_div.cpp"
+
 // Not operation
 // for integers
 template<class Sp>
@@ -53,11 +62,12 @@
   //  if( !nEl) throw GDLException("Variable is undefined.");  
   TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
+  {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
-	(*this)[i] = ~(*this)[i];
-    }  return this;
+    for( OMPInt i=0; i < nEl; ++i)
+      (*this)[i] = ~(*this)[i];
+  }  
+  return this;
 }
 // others
 template<>
@@ -76,7 +86,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = ((*this)[i] == 0.0f)? 1.0f : 0.0f;
     }  return this;
 }
@@ -95,14 +105,14 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = ((*this)[i] == 0.0)? 1.0 : 0.0;
     }  return this;
 }
 template<>
 Data_<SpDString>* Data_<SpDString>::NotOp()
 {
-  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
+  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
   return this;
 }
 template<>
@@ -117,21 +127,16 @@
   throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
   return this;
 }
-DStructGDL* DStructGDL::NotOp()
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
 template<>
 Data_<SpDPtr>* Data_<SpDPtr>::NotOp()
 {
-  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
   return this;
 }
 template<>
 Data_<SpDObj>* Data_<SpDObj>::NotOp()
 {
-  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
+  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
   return this;
 }
 
@@ -153,7 +158,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = -(*this)[i];
     }  return this;
 }
@@ -167,11 +172,6 @@
   //  this is deleted by convert2!!! 
   return static_cast<BaseGDL*>( newThis->UMinus());
 }
-BaseGDL* DStructGDL::UMinus()
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
 template<>
 BaseGDL* Data_<SpDPtr>::UMinus()
 {
@@ -205,7 +205,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = ((*this)[i] == 0)? 1 : 0;
     }  return res;
 }
@@ -226,7 +226,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = ((*this)[i] == 0.0f)? 1 : 0;
     }  return res;
 }
@@ -247,7 +247,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = ((*this)[i] == 0.0)? 1 : 0;
     }  return res;
 }
@@ -267,7 +267,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = ((*this)[i] == "")? 1 : 0;
     }  return res;
 }
@@ -287,7 +287,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = ((*this)[i].real() == 0.0 && (*this)[i].imag() == 0.0)? 1 : 0;
     }  return res;
 }
@@ -307,7 +307,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = ((*this)[i].real() == 0.0 && (*this)[i].imag() == 0.0)? 1 : 0;
     }  return res;
 }
@@ -329,7 +329,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i]--;
     }}
 template<class Sp>
@@ -347,7 +347,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i]++;
     }}
 // float
@@ -367,7 +367,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] -= 1.0;
     }}
 template<>
@@ -386,7 +386,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] += 1.0;
     }}
 // double
@@ -406,7 +406,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] -= 1.0;
     }}
 template<>
@@ -425,7 +425,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] += 1.0;
     }}
 // complex
@@ -445,7 +445,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] -= 1.0;
     }}
 template<>
@@ -464,7 +464,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] += 1.0;
     }}
 template<>
@@ -483,7 +483,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] -= 1.0;
     }}
 template<>
@@ -502,7 +502,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] += 1.0;
     }}
 // forbidden types
@@ -571,7 +571,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*this)[i] == s);
 	}    }
   else if( StrictScalar(s)) 
@@ -586,7 +586,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] == s);
 	}    }
   else if( rEl < nEl) 
@@ -596,7 +596,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] == (*this)[i]);
 	}    }
   else // ( rEl >= nEl)
@@ -611,7 +611,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*right)[i] == (*this)[i]);
 	}    }
   //C delete right;
@@ -726,7 +726,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*this)[i] == s);
 	}    }
   else if( StrictScalar(s)) 
@@ -741,7 +741,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] == s);
 	}    }
   else if( rEl < nEl) 
@@ -751,7 +751,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] == (*this)[i]);
 	}    }
   else // ( rEl >= nEl)
@@ -766,7 +766,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*right)[i] == (*this)[i]);
 	}    }
   //C delete right;
@@ -774,11 +774,6 @@
   return res;
 }
 // invalid types
-BaseGDL* DStructGDL::EqOp( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 // template<>
 // Data_<SpDByte>* Data_<SpDPtr>::EqOp( BaseGDL* r)
 // {
@@ -821,7 +816,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*this)[i] != s);
 	}    }
   else if( StrictScalar(s)) 
@@ -836,7 +831,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] != s);
 	}    }
   else if( rEl < nEl) 
@@ -846,7 +841,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] != (*this)[i]);
 	}    }
   else // ( rEl >= nEl)
@@ -861,7 +856,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*right)[i] != (*this)[i]);
 	}    }
   //C delete right;
@@ -976,7 +971,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*this)[i] != s);
 	}    }
   else if( StrictScalar(s)) 
@@ -991,7 +986,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] != s);
 	}    }
   else if( rEl < nEl) 
@@ -1001,7 +996,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] != (*this)[i]);
 	}    }
   else // ( rEl >= nEl)
@@ -1016,7 +1011,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*right)[i] != (*this)[i]);
 	}    }
   //C delete right;
@@ -1025,11 +1020,6 @@
 }
 
 // invalid types
-BaseGDL* DStructGDL::NeOp( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 // template<>
 // Data_<SpDByte>* Data_<SpDPtr>::NeOp( BaseGDL* r)
 // {
@@ -1071,7 +1061,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*this)[i] <= s);
 	}    }
   else if( StrictScalar(s)) 
@@ -1086,7 +1076,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] >= s);
 	}    }
   else if( rEl < nEl) 
@@ -1096,7 +1086,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] >= (*this)[i]);
 	}    }
   else // ( rEl >= nEl)
@@ -1111,7 +1101,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*right)[i] >= (*this)[i]);
 	}    }
   //C delete right;
@@ -1119,11 +1109,6 @@
   return res;
 }
 // invalid types
-BaseGDL* DStructGDL::LeOp( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 BaseGDL* Data_<SpDPtr>::LeOp( BaseGDL* r)
 {
@@ -1177,7 +1162,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*this)[i] < s);
 	}    }
   else if( StrictScalar(s)) 
@@ -1192,7 +1177,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] > s);
 	}    }
   else if( rEl < nEl) 
@@ -1202,7 +1187,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] > (*this)[i]);
 	}    }
   else // ( rEl >= nEl)
@@ -1217,7 +1202,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*right)[i] > (*this)[i]);
 	}    }
   //C delete right;
@@ -1225,11 +1210,6 @@
   return res;
 }
 // invalid types
-BaseGDL* DStructGDL::LtOp( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 BaseGDL* Data_<SpDPtr>::LtOp( BaseGDL* r)
 {
@@ -1283,7 +1263,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*this)[i] >= s);
 	}    }
   else if( StrictScalar(s)) 
@@ -1298,7 +1278,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] <= s);
 	}    }
   else if( rEl < nEl) 
@@ -1308,7 +1288,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] <= (*this)[i]);
 	}    }
   else // ( rEl >= nEl)
@@ -1323,7 +1303,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*right)[i] <= (*this)[i]);
 	}    }
   //C delete right;
@@ -1331,11 +1311,6 @@
   return res;
 }
 // invalid types
-BaseGDL* DStructGDL::GeOp( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 BaseGDL* Data_<SpDPtr>::GeOp( BaseGDL* r)
 {
@@ -1389,7 +1364,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*this)[i] > s);
 	}    }
   else if( StrictScalar(s)) 
@@ -1404,7 +1379,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] < s);
 	}    }
   else if( rEl < nEl) 
@@ -1414,7 +1389,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] < (*this)[i]);
 	}    }
   else // ( rEl >= nEl)
@@ -1429,7 +1404,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*right)[i] < (*this)[i]);
 	}    }
   //C delete right;
@@ -1437,11 +1412,6 @@
   return res;
 }
 // invalid types
-BaseGDL* DStructGDL::GtOp( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 BaseGDL* Data_<SpDPtr>::GtOp( BaseGDL* r)
 {
@@ -1466,11 +1436,148 @@
   throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
   return NULL;
 }
+
+//#undef USE_EIGEN
 // MatrixOp
-// returns *this # *r, //C deletes itself and right
+// returns *this # *r, //C does not delete itself and right
 template<class Sp>
-Data_<Sp>* Data_<Sp>::MatrixOp( BaseGDL* r, bool transpose, bool transposeResult, bool strassen)
+Data_<Sp>* Data_<Sp>::MatrixOp( BaseGDL* r, bool atranspose, bool btranspose)
 {
+#ifdef USE_EIGEN
+    bool at = atranspose;
+    bool bt = btranspose;
+
+    Data_*  par1 = static_cast<Data_*>(r);
+
+    long NbCol0, NbRow0, NbCol1, NbRow1;//, NbCol2, NbRow2;
+    SizeT rank0 = this->Rank();
+    SizeT rank1 = par1->Rank();
+    if (rank0 == 2)
+      {
+	NbCol0 = this->Dim(0);
+	NbRow0 = this->Dim(1);
+      } 
+    else if (rank0 > 2)
+      {
+	throw GDLException("Array must have 1 or 2 dimensions",true,false);  
+      }
+    else // rank0 0 or 1
+      {
+	NbCol0 = this->Dim(0);
+	if( NbCol0 == 0) NbCol0=1;
+	NbRow0 = 1;
+      }
+      
+    if (rank1 == 2)
+      {
+	NbCol1 = par1->Dim(0);
+	NbRow1 = par1->Dim(1);
+      } 
+    else if (rank1 > 2)
+      {
+	throw GDLException("Array must have 1 or 2 dimensions",true,false);  
+      }
+    else // rank1 0 or 1
+      {
+	NbCol1 = par1->Dim(0);
+	if( NbCol1 == 0) NbCol1=1;
+	NbRow1 = 1;
+      }
+    // NbCol0, NbRow0, NbCol1, NbRow1 are properly set now
+
+    // vector cases (possible degeneration)
+    if( rank0 <= 1 || rank1 <=1)  
+    {
+      if( rank0 <= 1 && rank1 <=1)  
+      {
+	// [NbCol0,1]#[NbCol1,1] -> just transpose b (if a is not transposed)
+	if( !at) // && !bt
+	  bt = true;
+      } 
+      else if( rank0 <= 1) // rank1 == 2
+      {
+	// [NbCol0,1]#[NbCol1,NbRow1]
+	if( !at && (!bt && NbCol1 != 1) || (bt && NbRow1 != 1))
+	  at = true;
+      }
+      else // if( rank1 <= 1) // rank0 == 2
+      {
+	// [NbCol0,NbRow0]#[NbCol1,1]
+	if( !bt && (!at && NbRow0 == 1) || (at && NbCol0 == 1))
+	  bt = true;
+      } 
+    } 
+    
+    Map<Matrix<Ty,-1,-1>,Aligned> m0(&(*this)[0], NbCol0, NbRow0);
+    Map<Matrix<Ty,-1,-1>,Aligned> m1(&(*par1)[0], NbCol1, NbRow1);
+
+    if (at && bt)
+      {
+	if(  /*(at &&  bt) &&*/ (NbCol0 != NbRow1))
+	  {
+	    throw GDLException("Operands of matrix multiply have incompatible dimensions.atbt",true,false);  
+// 	    e->Throw("Operands of matrix multiply have incompatible dimensions: " + e->GetParString(0) + ", " + e->GetParString(1) + ".");
+	  }
+	long& NbCol2 = NbRow0 ;
+	long& NbRow2 = NbCol1 ;
+	dimension dim(NbCol2, NbRow2);
+	
+	Data_* res = new Data_(dim, BaseGDL::NOZERO);
+	// no guarding necessary: eigen only throws on memory allocation
+
+	Map<Matrix<Ty,-1,-1>,Aligned> m2(&(*res)[0], NbCol2, NbRow2);
+	m2.noalias() = m0.transpose() * m1.transpose();
+	return res;
+      } 
+    else if (bt)
+      {
+	if( /*(!at &&  bt) &&*/ (NbRow0 != NbRow1))
+	  {
+	    throw GDLException("Operands of matrix multiply have incompatible dimensions.bt",true,false);  
+// 	    e->Throw("Operands of matrix multiply have incompatible dimensions: " + e->GetParString(0) + ", " + e->GetParString(1) + ".");
+	  }
+	long& NbCol2 = NbCol0;
+	long& NbRow2 = NbCol1;
+	dimension dim(NbCol2, NbRow2);
+
+	Data_* res = new Data_(dim, BaseGDL::NOZERO);
+	Map<Matrix<Ty,-1,-1>,Aligned> m2(&(*res)[0], NbCol2, NbRow2);
+	m2.noalias() = m0 * m1.transpose();
+	return res;
+      } else if (at)
+      {
+	if( /*(at && !bt) &&*/ (NbCol0 != NbCol1))
+	  {
+	    throw GDLException("Operands of matrix multiply have incompatible dimensions.at",true,false);  
+// 	    e->Throw("Operands of matrix multiply have incompatible dimensions: " + e->GetParString(0) + ", " + e->GetParString(1) + ".");
+	  }
+	long& NbCol2 = NbRow0;
+	long& NbRow2 = NbRow1;
+	dimension dim(NbCol2, NbRow2);
+
+	Data_* res = new Data_(dim, BaseGDL::NOZERO);
+	Map<Matrix<Ty,-1,-1>,Aligned> m2(&(*res)[0], NbCol2, NbRow2);
+	m2.noalias() = m0.transpose() * m1;
+	return res;
+      } else
+      {
+	if( /*(!at && !bt) &&*/ (NbRow0 != NbCol1))
+	  {
+	    throw GDLException("Operands of matrix multiply have incompatible dimensions._",true,false);  
+// 	    e->Throw("Operands of matrix multiply have incompatible dimensions: " + e->GetParString(0) + ", " + e->GetParString(1) + ".");
+	  }
+	long& NbCol2 = NbCol0;
+	long& NbRow2 = NbRow1;
+	dimension dim(NbCol2, NbRow2);
+
+	Data_* res = new Data_(dim, BaseGDL::NOZERO);
+	Map<Matrix<Ty,-1,-1>,Aligned> m2(&(*res)[0], NbCol2, NbRow2);
+	m2.noalias() = m0*m1;
+	return res;
+      }
+
+#else
+
   Data_* right=static_cast<Data_*>(r);
 
   //   ULong rEl=right->N_Elements();
@@ -1478,7 +1585,7 @@
   //   assert( rEl);
   //   assert( nEl);
   //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-
+  
   Data_* res;
 
   if( this->dim.Rank() <= 1 && right->dim.Rank() <= 1)
@@ -1503,8 +1610,8 @@
 #pragma omp parallel if (nOp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nOp)) default(shared)
 	{
 #pragma omp for 
-	  for( int colA=0; colA < nCol; colA++)   // res dim 0
-	    for( SizeT rowB=0; rowB < nRow; rowB++) // res dim 1
+	  for( OMPInt colA=0; colA < nCol; colA++)   // res dim 0
+	    for( OMPInt rowB=0; rowB < nRow; rowB++) // res dim 1
 	      (*res)[ rowB * nCol + colA] += (*this)[colA] * (*right)[rowB];
 	}
     }
@@ -1514,70 +1621,87 @@
       // [n] # [n,m] -> [1,m] ([n] -> [1,n])
 
       // right op 1st
-      SizeT nRow=transpose ? right->dim[0] : right->dim[1];
+      SizeT nRow=btranspose ? right->dim[0] : right->dim[1];
       if( nRow == 0) nRow=1;
 
       // loop dim
-      SizeT nRowEl=transpose ? right->dim[1] : right->dim[0];
+      SizeT nRowEl=btranspose ? right->dim[1] : right->dim[0];
       if( nRowEl == 0) nRowEl=1;
 
       // result dim
       SizeT nCol, nColEl;
-      if( this->dim.Rank() <= 1)
-	{
-	  nColEl=this->dim[0];
-	  if( nColEl == 0) // scalar
-	    {
-	      nColEl=1;
-	      nCol  =1;
-	    }
-	  else if( nRowEl == 1)
-	    {
-	      nCol   = nColEl;
-	      nColEl = 1;
-	    }
-	  else
-	    {
-	      nCol = 1;
-	    }
-	}
+      if( !atranspose)
+      {
+	if( this->dim.Rank() <= 1)
+	  {
+	    nColEl=this->dim[0];
+	    if( nColEl == 0) // scalar
+	      {
+		nColEl=1;
+		nCol  =1;
+	      }
+	    else if( nRowEl == 1)
+	      {
+		nCol   = nColEl;
+		nColEl = 1;
+	      }
+	    else
+	      {
+		nCol = 1;
+	      }
+	  }
+	else
+	  { 
+	    nCol=this->dim[0];
+	    nColEl=this->dim[1];
+	    assert( nColEl > 0); // rank is two -> cannot be zero
+	    //	  if( nColEl == 0) nColEl=1;
+	  }
+      }
       else
-	{ 
-	  nCol=this->dim[0];
-	  nColEl=this->dim[1];
-	  assert( nColEl > 0); // rank is two -> cannot be zero
-	  //	  if( nColEl == 0) nColEl=1;
-	}
-      
-      //       cout << "nColEl, nRowEl: " << nColEl << " " << nRowEl << endl;
-      //       cout << "nCol, nRow:     " << nCol << " " << nRow << endl;
-
-      //      SizeT nRowEl=right->dim[0];
+      {
+	if( this->dim.Rank() <= 1)
+	  {
+	    nColEl=this->dim[0];
+	    if( nColEl == 0) // scalar
+	      {
+		nColEl=1;
+		nCol  =1;
+	      }
+	    else if( nRowEl == 1)
+	      {
+		nCol   = nColEl;
+		nColEl = 1;
+	      }
+	    else
+	      {
+		nCol = 1;
+	      }
+	  }
+	else
+	  { 
+	    nCol=this->dim[1];
+	    nColEl=this->dim[0];
+	    assert( nColEl > 0); // rank is two -> cannot be zero
+	    //	  if( nColEl == 0) nColEl=1;
+	  }
+      }
+	
       if( nColEl != nRowEl)
 	throw GDLException("Operands of matrix multiply have"
 			   " incompatible dimensions.",true,false);  
 
-      if( transposeResult)
-	{
-	  if( nCol > 1)
-	    res=New(dimension( nRow, nCol),BaseGDL::NOZERO);
-	  else
-	    res=New(dimension(nRow),BaseGDL::NOZERO);
-	}
+      if( nRow > 1)
+	res=New(dimension(nCol,nRow),BaseGDL::NOZERO);
       else
-	{
-	  if( nRow > 1)
-	    res=New(dimension(nCol,nRow),BaseGDL::NOZERO);
-	  else
-	    res=New(dimension(nCol),BaseGDL::NOZERO);
-	}
+	res=New(dimension(nCol),BaseGDL::NOZERO);
      
       SizeT rIxEnd = nRow * nColEl;
       //#ifdef _OPENMP 
       SizeT nOp = rIxEnd * nCol;
 
 #ifdef USE_STRASSEN_MATRIXMULTIPLICATION
-      if( !transpose && !transposeResult && strassen)
+      if( !btranspose && !atranspose && strassen)
 	//if( nOp > 1000000)
 	{
 	  SizeT maxDim;
@@ -1594,8 +1718,6 @@
 	    SizeT mSz = 2;
 	    while (mSz < maxDim) mSz <<= 1;
 
-	    // 	      Ty* buf = new Ty[ 3 * mSz * mSz];
-
 	    SM1<Ty>( mSz, nCol, nColEl, nRow,
 		     static_cast<Ty*>(right->DataAddr()),
 		     static_cast<Ty*>(this->DataAddr()),
@@ -1608,29 +1730,21 @@
 	}
 #endif
 
-      //  for( SizeT j=0; j < nCol; ++j) // res dim 0
-      // 	for( SizeT i=0; i < rIxEnd; i++) // res dim 1
-      // 	    for( SizeT k=0; k < nColEl; ++k)
-      // 	       (*res)[ (i * nCol) + j] += (*right)[ (i*nColEl)+k] * (*this)[ k*nCol+j];
-
-
-      //#endif
-
-      if( !transposeResult) // normal
+      if( !atranspose) // normal
 	{
-	  if( !transpose) // normal
+	  if( !btranspose) // normal
 	    {
 	      TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nOp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nOp)) default(shared)
 		{
 #pragma omp for
-		  for( int colA=0; colA < nCol; ++colA) // res dim 0
-		    for( SizeT rIx=0, rowBnCol=0; rIx < rIxEnd;
+		  for( OMPInt colA=0; colA < nCol; ++colA) // res dim 0
+		    for( OMPInt rIx=0, rowBnCol=0; rIx < rIxEnd;
 			 rIx += nColEl, rowBnCol += nCol) // res dim 1
 		      {
 			Ty& resEl = (*res)[ rowBnCol + colA];
 			resEl = 0;//(*this)[ colA] * (*right)[ rIx]; // initialization
-			for( SizeT i=0; i < nColEl; ++i)
+			for( OMPInt i=0; i < nColEl; ++i)
 			  resEl += (*this)[ i*nCol+colA] * (*right)[ rIx+i];
 		      }
 		}
@@ -1641,33 +1755,35 @@
 #pragma omp parallel if (nOp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nOp)) default(shared)
 		{
 #pragma omp for
-		  for( int colA=0; colA < nCol; ++colA) // res dim 0
-		    for( SizeT rIx=0, rowBnCol=0; rIx < nRow; ++rIx, rowBnCol += nCol) // res dim 1
+		  for( OMPInt colA=0; colA < nCol; ++colA) // res dim 0
+		    for( OMPInt rIx=0, rowBnCol=0; rIx < nRow; ++rIx, rowBnCol += nCol) // res dim 1
 		      {
 			Ty& resEl = (*res)[ rowBnCol + colA];
 			resEl = 0;//(*this)[ colA] * (*right)[ rIx]; // initialization
-			for( SizeT i=0; i < nColEl; ++i)
+			for( OMPInt i=0; i < nColEl; ++i)
 			  resEl += (*this)[ i*nCol+colA] * (*right)[ rIx + i * nRow];
 		      }
 		}
 	    }
 	}
-      else // transposeResult
+      else // atranspose
 	{
-	  if( !transpose) // normal
+	  if( !btranspose) // normal
 	    {
 	      TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nOp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nOp)) default(shared)
 		{
 #pragma omp for
-		  for( int colA=0; colA < nCol; ++colA) // res dim 0
-		    for( SizeT rIx=0, rowBnCol=0; rIx < rIxEnd;
+		  for( OMPInt colA=0; colA < nCol; ++colA) // res dim 0
+		    for( OMPInt rIx=0, rowBnCol=0; rIx < rIxEnd;
 			 rIx += nColEl, ++rowBnCol) // res dim 1
 		      {
-			Ty& resEl = (*res)[ rowBnCol + colA * nRow];
+			Ty& resEl = (*res)[ rowBnCol * nCol + colA];
+// 			Ty& resEl = (*res)[ rowBnCol + colA * nRow];
 			resEl = 0;//(*this)[ colA] * (*right)[ rIx]; // initialization
-			for( SizeT i=0; i < nColEl; ++i)
-			  resEl += (*this)[ i*nCol+colA] * (*right)[ rIx+i];
+			for( OMPInt i=0; i < nColEl; ++i)
+			  resEl += (*this)[ i+colA*nColEl] * (*right)[ rIx+i];
+// 			  resEl += (*this)[ i*nCol+colA] * (*right)[ rIx+i];
 		      }
 		}
 	    }
@@ -1677,13 +1793,15 @@
 #pragma omp parallel if (nOp >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nOp)) default(shared)
 		{
 #pragma omp for
-		  for( int colA=0; colA < nCol; ++colA) // res dim 0
-		    for( SizeT rIx=0; rIx < nRow; ++rIx) // res dim 1
+		  for( OMPInt colA=0; colA < nCol; ++colA) // res dim 0
+		    for( OMPInt rIx=0; rIx < nRow; ++rIx) // res dim 1
 		      {
-			Ty& resEl = (*res)[ rIx + colA * nRow];
+			Ty& resEl = (*res)[ rIx *nCol + colA];
+// 			Ty& resEl = (*res)[ rIx + colA * nRow];
 			resEl = 0;//(*this)[ colA] * (*right)[ rIx]; // initialization
-			for( SizeT i=0; i < nColEl; ++i)
-			  resEl += (*this)[ i*nCol+colA] * (*right)[ rIx + i * nRow];
+			for( OMPInt i=0; i < nColEl; ++i)
+			  resEl += (*this)[ i+colA*nColEl] * (*right)[ rIx + i * nRow];
+// 			  resEl += (*this)[ i*nCol+colA] * (*right)[ rIx + i * nRow];
 		      }
 		}
 	    }
@@ -1691,9 +1809,8 @@
 
 
     }
-  //C delete right;
-  //C delete this;
   return res;
+#endif // #elseif USE_EIGEN 
 }
 
 
@@ -1701,25 +1818,20 @@
 
 
 // invalid types
-DStructGDL* DStructGDL::MatrixOp( BaseGDL* r, bool t, bool tr, bool s)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
-Data_<SpDString>* Data_<SpDString>::MatrixOp( BaseGDL* r, bool t, bool tr,  bool s)
+Data_<SpDString>* Data_<SpDString>::MatrixOp( BaseGDL* r, bool atranspose, bool btranspose)
 {
   throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
   return this;
 }
 template<>
-Data_<SpDPtr>* Data_<SpDPtr>::MatrixOp( BaseGDL* r, bool t, bool tr,  bool s)
+Data_<SpDPtr>* Data_<SpDPtr>::MatrixOp( BaseGDL* r, bool atranspose, bool btranspose)
 {
   throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
   return NULL;
 }
 template<>
-Data_<SpDObj>* Data_<SpDObj>::MatrixOp( BaseGDL* r, bool t, bool tr,  bool s)
+Data_<SpDObj>* Data_<SpDObj>::MatrixOp( BaseGDL* r, bool atranspose, bool btranspose)
 {
   throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
   return NULL;
@@ -1733,6 +1845,7 @@
 // for integers
 template<class Sp>
 Data_<Sp>* Data_<Sp>::AndOp( BaseGDL* r)
+// GDL_DEFINE_INTEGER_FUNCTION( Data_<Sp>*) AndOp( BaseGDL* r)
 {
   Data_* right=static_cast<Data_*>(r);
 
@@ -1751,7 +1864,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = (*this)[i] & (*right)[i]; // & Ty(1);
     }  //C delete right;
   return this;
@@ -1781,7 +1894,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*right)[i] == zero) (*this)[i]=zero;
       //     if( (*this)[i] == zero || (*right)[i] == zero) (*this)[i]=zero;
     }  //C delete right;
@@ -1805,12 +1918,12 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*this)[i] != zero) (*this)[i] = (*right)[i];
     }  //C delete right;
   return this;
 }
-// for doubles
+// // for doubles
 template<>
 Data_<SpDDouble>* Data_<SpDDouble>::AndOp( BaseGDL* r)
 {
@@ -1829,7 +1942,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*right)[i] == zero) (*this)[i]=zero;
       //     if( (*this)[i] == zero || (*right)[i] == zero) (*this)[i]=zero;
     }  //C delete right;
@@ -1853,42 +1966,36 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*this)[i] != zero) (*this)[i] = (*right)[i];
     }  //C delete right;
   return this;
 }
 // invalid types
-DStructGDL* DStructGDL::AndOp( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-DStructGDL* DStructGDL::AndOpInv( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-// template<>
-// DStructGDL* DStructGDL::AndOpInv( BaseGDL* r)
+// GDL_DEFINE_COMPLEX_FUNCTION( Data_<Sp>*) AndOp( BaseGDL* r)
 // {
-//  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-//  return this;
+//   throw GDLException("Cannot apply operation to datatype "+Sp::str+".",true,false);  
+//   return this;
 // }
 template<>
-Data_<SpDString>* Data_<SpDString>::AndOp( BaseGDL* r)
+Data_<SpDComplex>* Data_<SpDComplex>::AndOp( BaseGDL* r)
 {
-  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
+  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
   return this;
 }
 template<>
-Data_<SpDComplex>* Data_<SpDComplex>::AndOp( BaseGDL* r)
+Data_<SpDComplexDbl>* Data_<SpDComplexDbl>::AndOp( BaseGDL* r)
 {
   throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
   return this;
 }
+// GDL_DEFINE_OTHER_FUNCTION( Data_<Sp>*) AndOp( BaseGDL* r)
+// {
+//   throw GDLException("Cannot apply operation to datatype "+Sp::str+".",true,false);  
+//   return this;
+// }
 template<>
-Data_<SpDComplexDbl>* Data_<SpDComplexDbl>::AndOp( BaseGDL* r)
+Data_<SpDString>* Data_<SpDString>::AndOp( BaseGDL* r)
 {
   throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
   return this;
@@ -1918,9 +2025,9 @@
   return this;
 }
 // template<>
-// Data_<SpDPtr>* Data_<SpDPtr>::AndOpInv( BaseGDL* r)
+// Data_<SpDObj>* Data_<SpDObj>::AndOpInv( BaseGDL* r)
 // {
-//  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+//  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
 //  return this;
 // }
 template<class Sp>
@@ -1945,7 +2052,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared(s)
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] &= s;
     }
   return this;
@@ -2008,7 +2115,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    if( (*this)[i] != zero) (*this)[i] = s;
 	}}
   return this;
@@ -2064,28 +2171,12 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    if( (*this)[i] != zero) (*this)[i] = s;
 	}}
   return this;
 }
 // invalid types
-DStructGDL* DStructGDL::AndOpS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-DStructGDL* DStructGDL::AndOpInvS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-// template<>
-// DStructGDL* DStructGDL::AndOpInv( BaseGDL* r)
-// {
-//  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-//  return this;
-// }
 template<>
 Data_<SpDString>* Data_<SpDString>::AndOpS( BaseGDL* r)
 {
@@ -2147,7 +2238,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = (*this)[i] | (*right)[i]; // | Ty(1);
     }
   //C delete right;
@@ -2179,7 +2270,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*this)[i] == zero) (*this)[i]=(*right)[i];
     }  //C delete right;
   return this;
@@ -2203,7 +2294,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*right)[i] != zero) (*this)[i] = (*right)[i];
     }  //C delete right;
   return this;
@@ -2228,7 +2319,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*this)[i] == zero) (*this)[i]= (*right)[i];
     }  //C delete right;
   return this;
@@ -2252,22 +2343,12 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*right)[i] != zero) (*this)[i] = (*right)[i];
     }  //C delete right;
   return this;
 }
 // invalid types
-DStructGDL* DStructGDL::OrOp( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-DStructGDL* DStructGDL::OrOpInv( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::OrOp( BaseGDL* r)
 {
@@ -2322,7 +2403,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = (*this)[i] | s;
     }  //C delete right;
   return this;
@@ -2355,7 +2436,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    if( (*this)[i] == zero) (*this)[i] = s;
 	}}  //C delete right;
   return this;
@@ -2395,7 +2476,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    if( (*this)[i] == zero) (*this)[i] = s;
 	}}  //C delete right;
   return this;
@@ -2429,22 +2510,12 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    if( (*this)[i] != zero) (*this)[i] = s;
 	}}  //C delete right;
   return this;
 }
 // invalid types
-DStructGDL* DStructGDL::OrOpS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-DStructGDL* DStructGDL::OrOpInvS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::OrOpS( BaseGDL* r)
 {
@@ -2505,7 +2576,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i < nEl; ++i)
+	      for( OMPInt i=0; i < nEl; ++i)
 		(*this)[i] ^= s;
 	    }}
     }
@@ -2515,7 +2586,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*this)[i] ^= (*right)[i];
 	}    }
   //C delete right;
@@ -2534,11 +2605,6 @@
   throw GDLException("Cannot apply operation to datatype DOUBLE.",true,false);  
   return this;
 }
-DStructGDL* DStructGDL::XorOp( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::XorOp( BaseGDL* r)
 {
@@ -2587,7 +2653,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] ^= s;
       //     (*this)[i] = (*this)[i] ^ s;
     }  //C delete right;
@@ -2609,11 +2675,6 @@
   return this;
 }
 // invalid types
-DStructGDL* DStructGDL::XorOpS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::XorOpS( BaseGDL* r)
 {
@@ -2645,1354 +2706,233 @@
   return this;
 }
 
-// Add
-// Adds right to itself, //C deletes right
+// LtMark
+// LtMarks right to itself, //C deletes right
 // right must always have more or same number of elements
 template<class Sp>
-BaseGDL* Data_<Sp>::Add( BaseGDL* r)
+Data_<Sp>* Data_<Sp>::LtMark( BaseGDL* r)
 {
   Data_* right=static_cast<Data_*>(r);
 
-  // ULong rEl=right->N_Elements();
+  //  ULong rEl=right->N_Elements();
   ULong nEl=N_Elements();
-  // assert( rEl);
+  //  assert( rEl);
   assert( nEl);
+  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
   if( nEl == 1)
     {
-      (*this)[0] += (*right)[0];
+      if( (*this)[0] > (*right)[0]) (*this)[0]=(*right)[0];
       return this;
     }
-
   TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
-	(*this)[i] += (*right)[i];
+      for( OMPInt i=0; i < nEl; ++i)
+	if( (*this)[i] > (*right)[i]) (*this)[i]=(*right)[i];
     }  //C delete right;
   return this;
 }
-template<class Sp>
-BaseGDL* Data_<Sp>::AddInv( BaseGDL* r)
+// invalid types
+template<>
+Data_<SpDString>* Data_<SpDString>::LtMark( BaseGDL* r)
 {
-  assert( this->Type() != GDL_OBJ); // should never be called via this
-  return Add( r);
+  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDComplex>* Data_<SpDComplex>::LtMark( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
+  return this;
+}
+template<>
+Data_<SpDComplexDbl>* Data_<SpDComplexDbl>::LtMark( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
+  return this;
+}
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::LtMark( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+  return this;
 }
 template<>
-BaseGDL* Data_<SpDString>::AddInv( BaseGDL* r)
+Data_<SpDObj>* Data_<SpDObj>::LtMark( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
+  return this;
+}
+template<class Sp>
+Data_<Sp>* Data_<Sp>::LtMarkS( BaseGDL* r)
 {
   Data_* right=static_cast<Data_*>(r);
-
-  // ULong rEl=right->N_Elements();
+  
   ULong nEl=N_Elements();
-  // assert( rEl);
   assert( nEl);
   if( nEl == 1)
     {
-      (*this)[0] = (*right)[0] + (*this)[0];
+      if( (*this)[0] > (*right)[0]) (*this)[0]=(*right)[0];
       return this;
     }
-  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
+  Ty s = (*right)[0];
+  // right->Scalar(s);
   TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
-	(*this)[i] = (*right)[i] + (*this)[i];
+      for( OMPInt i=0; i < nEl; ++i)
+	if( (*this)[i] > s) (*this)[i]=s;
     }  //C delete right;
   return this;
 }
 // invalid types
-DStructGDL* DStructGDL::Add( BaseGDL* r)
+template<>
+Data_<SpDString>* Data_<SpDString>::LtMarkS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDComplex>* Data_<SpDComplex>::LtMarkS( BaseGDL* r)
 {
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
   return this;
 }
-DStructGDL* DStructGDL::AddInv( BaseGDL* r)
+template<>
+Data_<SpDComplexDbl>* Data_<SpDComplexDbl>::LtMarkS( BaseGDL* r)
 {
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
   return this;
 }
 template<>
-BaseGDL* Data_<SpDPtr>::Add( BaseGDL* r)
+Data_<SpDPtr>* Data_<SpDPtr>::LtMarkS( BaseGDL* r)
 {
   throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
   return this;
 }
 template<>
-BaseGDL* Data_<SpDObj>::Add( BaseGDL* r)
+Data_<SpDObj>* Data_<SpDObj>::LtMarkS( BaseGDL* r)
 {
-  // overload here
-  Data_* self;
-  DFun* plusOverload;
-  
-  ProgNodeP callingNode = interpreter->GetRetTree();
-
-  if( !Scalar())
-  {
-    if( r->Type() == GDL_OBJ && r->Scalar())
-    {
-      self = static_cast<Data_*>( r);
-      plusOverload = static_cast<DFun*>(GDLInterpreter::GetObjHeapOperator( (*self)[0], OOPlus));
-      if( plusOverload == NULL)
-      {
-	throw GDLException( callingNode, "Cannot apply not overloaded operator to datatype OBJECT.", true, false);
-      }
-    }
-    else
-      {
-	throw GDLException( callingNode, "Cannot apply operation to non-scalar datatype OBJECT.", true, false);
-      }
-  }
-  else
-  {
-    // Scalar()
-    self = static_cast<Data_*>( this);
-    plusOverload = static_cast<DFun*>(GDLInterpreter::GetObjHeapOperator( (*self)[0], OOPlus));
-    if( plusOverload == NULL)
-    {
-      if( r->Type() == GDL_OBJ && r->Scalar())
-      {
-	self = static_cast<Data_*>( r);
-	plusOverload = static_cast<DFun*>(GDLInterpreter::GetObjHeapOperator( (*self)[0], OOPlus));
-	if( plusOverload == NULL)
-	{
-	  throw GDLException(callingNode,"Cannot apply not overloaded operator to datatype OBJECT.",true, false);  
-	} 
-      }
-      else
-      {
-	throw GDLException( callingNode, "Cannot apply not overloaded operator to datatype OBJECT.", true, false);
-      }
-    }
-  }
-
-  assert( self->Scalar());
-  assert( plusOverload != NULL);
-
-  // hidden SELF is counted as well
-  int nParSub = plusOverload->NPar();
-  assert( nParSub >= 1); // SELF
-  if( nParSub < 3) // (SELF), LEFT, RIGHT
-  {
-    throw GDLException( callingNode, plusOverload->ObjectName() +
-		    ": Incorrect number of arguments.",
-		    false, false);
-  }
-  EnvUDT* newEnv;
-  Guard<BaseGDL> selfGuard;
-  BaseGDL* thisP;
-  // Dup() here is not optimal
-  // avoid at least for internal overload routines (which do/must not change SELF or r)
-  bool internalDSubUD = plusOverload->GetTree()->IsWrappedNode();  
-  if( internalDSubUD)  
-  {
-    thisP = this;
-    newEnv= new EnvUDT( callingNode, plusOverload, &self);
-    newEnv->SetNextParUnchecked( &thisP); // LEFT  parameter, as reference to prevent cleanup in newEnv
-    newEnv->SetNextParUnchecked( &r); // RVALUE  parameter, as reference to prevent cleanup in newEnv
-  }
-  else
-  {
-    self = self->Dup();
-    selfGuard.Init( self);
-    newEnv= new EnvUDT( callingNode, plusOverload, &self);
-    newEnv->SetNextParUnchecked( this->Dup()); // LEFT  parameter, as value
-    newEnv->SetNextParUnchecked( r->Dup()); // RIGHT parameter, as value
-  }
-
-  
-  // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
-  StackGuard<EnvStackT> guard(interpreter->CallStack());
-
-  interpreter->CallStack().push_back( newEnv); 
-  
-  // make the call
-  BaseGDL* res=interpreter->call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
-
-  if( !internalDSubUD && self != selfGuard.Get())
-  {
-    // always put out warning first, in case of a later crash
-    Warning( "WARNING: " + plusOverload->ObjectName() + 
-	  ": Assignment to SELF detected (GDL session still ok).");
-    // assignment to SELF -> self was deleted and points to new variable
-    // which it owns
-    selfGuard.Release();
-    if( static_cast<BaseGDL*>(self) != NullGDL::GetSingleInstance())
-      selfGuard.Reset(self);
-  }
-  return res;
-}
-// difference from above: Order of parameters in call
-template<>
-BaseGDL* Data_<SpDObj>::AddInv( BaseGDL* r)
-{
-  if( r->Type() == GDL_OBJ && r->Scalar())
-  {
-    return r->Add( this); // for right order of parameters
-  }
-    
-  // overload here
-  Data_* self;
-  DFun* plusOverload;
-  
-  ProgNodeP callingNode = interpreter->GetRetTree();
-
-  if( !Scalar())
-  {
-    throw GDLException( callingNode, "Cannot apply operation to non-scalar datatype OBJECT.", true, false);
-  }
-  else
-  {
-    // Scalar()
-    self = static_cast<Data_*>( this);
-    plusOverload = static_cast<DFun*>(GDLInterpreter::GetObjHeapOperator( (*self)[0], OOPlus));
-    if( plusOverload == NULL)
-    {
-	throw GDLException( callingNode, "Cannot apply not overloaded operator to datatype OBJECT.", true, false);
-    }
-  }
-
-  assert( self->Scalar());
-  assert( plusOverload != NULL);
-
-  // hidden SELF is counted as well
-  int nParSub = plusOverload->NPar();
-  assert( nParSub >= 1); // SELF
-  if( nParSub < 3) // (SELF), LEFT, RIGHT
-  {
-    throw GDLException( callingNode, plusOverload->ObjectName() +
-		    ": Incorrect number of arguments.",
-		    false, false);
-  }
-  EnvUDT* newEnv;
-  Guard<BaseGDL> selfGuard;
-  BaseGDL* thisP;
-  // Dup() here is not optimal
-  // avoid at least for internal overload routines (which do/must not change SELF or r)
-  bool internalDSubUD = plusOverload->GetTree()->IsWrappedNode();  
-  if( internalDSubUD)  
-  {
-    thisP = this;
-    newEnv= new EnvUDT( callingNode, plusOverload, &self);
-    // order different to Add
-    newEnv->SetNextParUnchecked( &r); // RVALUE  parameter, as reference to prevent cleanup in newEnv
-    newEnv->SetNextParUnchecked( &thisP); // LEFT  parameter, as reference to prevent cleanup in newEnv
-  }
-  else
-  {
-    self = self->Dup();
-    selfGuard.Init( self);
-    newEnv= new EnvUDT( callingNode, plusOverload, &self);
-    // order different to Add
-    newEnv->SetNextParUnchecked( r->Dup()); // RIGHT parameter, as value
-    newEnv->SetNextParUnchecked( this->Dup()); // LEFT  parameter, as value
-  }
-
-  
-  // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
-  StackGuard<EnvStackT> guard(interpreter->CallStack());
-
-  interpreter->CallStack().push_back( newEnv); 
-  
-  // make the call
-  BaseGDL* res=interpreter->call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
-
-  if( !internalDSubUD && self != selfGuard.Get())
-  {
-    // always put out warning first, in case of a later crash
-    Warning( "WARNING: " + plusOverload->ObjectName() + 
-	  ": Assignment to SELF detected (GDL session still ok).");
-    // assignment to SELF -> self was deleted and points to new variable
-    // which it owns
-    selfGuard.Release();
-    if( static_cast<BaseGDL*>(self) != NullGDL::GetSingleInstance())
-      selfGuard.Reset(self);
-  }
-  return res;
-}
-
-template<class Sp>
-BaseGDL* Data_<Sp>::AddS( BaseGDL* r)
-{
-  Data_* right=static_cast<Data_*>(r);
-
-  ULong nEl=N_Elements();
-  assert( nEl);
-  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-  if( nEl == 1)
-    {
-      (*this)[0] += (*right)[0];
-      return this;
-    }
-  Ty s = (*right)[0];
-  // right->Scalar(s);
-  //  dd += s;
-  TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-#pragma omp for
-      for( int i=0; i < nEl; ++i)
-	(*this)[i] += s;
-    }  //C delete right;
-  return this;
-}
-template<class Sp>
-BaseGDL* Data_<Sp>::AddInvS( BaseGDL* r)
-{
-  return AddS( r);
-}
-template<>
-BaseGDL* Data_<SpDString>::AddInvS( BaseGDL* r)
-{
-  Data_* right=static_cast<Data_*>(r);
-
-  ULong nEl=N_Elements();
-  assert( nEl);
-  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-  if( nEl == 1)
-    {
-      (*this)[0] = (*right)[0] + (*this)[0] ;
-      return this;
-    }
-  Ty s = (*right)[0];
-  // right->Scalar(s);
-  TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-#pragma omp for
-      for( int i=0; i < nEl; ++i)
-	(*this)[i] = s + (*this)[i];
-    }  //C delete right;
-  return this;
-}
-
-// invalid types
-DStructGDL* DStructGDL::AddS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-DStructGDL* DStructGDL::AddInvS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-template<>
-BaseGDL* Data_<SpDPtr>::AddS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
-  return this;
-}
-template<>
-BaseGDL* Data_<SpDObj>::AddS( BaseGDL* r)
-{
-  return Add( r);
-}
-template<>
-BaseGDL* Data_<SpDObj>::AddInvS( BaseGDL* r)
-{
-  return AddInv( r);
-}
-
-// Sub
-// substraction: left=left-right
-template<class Sp>
-BaseGDL* Data_<Sp>::Sub( BaseGDL* r)
-{
-  Data_* right=static_cast<Data_*>(r);
-
-  ULong rEl=right->N_Elements();
-  ULong nEl=N_Elements();
-  assert( rEl);
-  assert( nEl);
-  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-  if( nEl == rEl)
-    dd -= right->dd;
-  else
-    {
-      TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-	{
-#pragma omp for
-	  for( int i=0; i < nEl; ++i)
-	    (*this)[i] -= (*right)[i];
-	}}  //C delete right;
-  return this;
-}
-// inverse substraction: left=right-left
-template<class Sp>
-BaseGDL* Data_<Sp>::SubInv( BaseGDL* r)
-{
-  Data_* right=static_cast<Data_*>(r);
-
-  ULong rEl=right->N_Elements();
-  ULong nEl=N_Elements();
-  assert( rEl);
-  assert( nEl);
-  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-  /*  if( nEl == rEl)
-      dd = right->dd - dd;
-      else*/
-  if( nEl == 1)
-    {
-      (*this)[0] = (*right)[0] - (*this)[0];
-      return this;
-    }
-  TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-#pragma omp for
-      for( int i=0; i < nEl; ++i)
-	(*this)[i] = (*right)[i] - (*this)[i];
-    }  //C delete right;
-  return this;
-}
-// invalid types
-DStructGDL* DStructGDL::Sub( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-DStructGDL* DStructGDL::SubInv( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-template<>
-BaseGDL* Data_<SpDString>::Sub( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
-  return this;
-}
-template<>
-BaseGDL* Data_<SpDString>::SubInv( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
-  return this;
-}
-template<>
-BaseGDL* Data_<SpDPtr>::Sub( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
-  return this;
-}
-template<>
-BaseGDL* Data_<SpDPtr>::SubInv( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
-  return this;
-}
-template<>
-BaseGDL* Data_<SpDObj>::Sub( BaseGDL* r)
-{
-  // overload here
-  Data_* self;
-  DFun* plusOverload;
-  
-  ProgNodeP callingNode = interpreter->GetRetTree();
-
-  if( !Scalar())
-  {
-    if( r->Type() == GDL_OBJ && r->Scalar())
-    {
-      self = static_cast<Data_*>( r);
-      plusOverload = static_cast<DFun*>(GDLInterpreter::GetObjHeapOperator( (*self)[0], OOMinus));
-      if( plusOverload == NULL)
-      {
-	throw GDLException( callingNode, "Cannot apply not overloaded operator to datatype OBJECT.", true, false);
-      }
-    }
-    else
-      {
-	throw GDLException( callingNode, "Cannot apply operation to non-scalar datatype OBJECT.", true, false);
-      }
-  }
-  else
-  {
-    // Scalar()
-    self = static_cast<Data_*>( this);
-    plusOverload = static_cast<DFun*>(GDLInterpreter::GetObjHeapOperator( (*self)[0], OOMinus));
-    if( plusOverload == NULL)
-    {
-      if( r->Type() == GDL_OBJ && r->Scalar())
-      {
-	self = static_cast<Data_*>( r);
-	plusOverload = static_cast<DFun*>(GDLInterpreter::GetObjHeapOperator( (*self)[0], OOMinus));
-	if( plusOverload == NULL)
-	{
-	  throw GDLException(callingNode,"Cannot apply not overloaded operator to datatype OBJECT.",true, false);  
-	} 
-      }
-      else
-      {
-	throw GDLException( callingNode, "Cannot apply not overloaded operator to datatype OBJECT.", true, false);
-      }
-    }
-  }
-
-  assert( self->Scalar());
-  assert( plusOverload != NULL);
-
-  // hidden SELF is counted as well
-  int nParSub = plusOverload->NPar();
-  assert( nParSub >= 1); // SELF
-  if( nParSub < 3) // (SELF), LEFT, RIGHT
-  {
-    throw GDLException( callingNode, plusOverload->ObjectName() +
-		    ": Incorrect number of arguments.",
-		    false, false);
-  }
-  EnvUDT* newEnv;
-  Guard<BaseGDL> selfGuard;
-  BaseGDL* thisP;
-  // Dup() here is not optimal
-  // avoid at least for internal overload routines (which do/must not change SELF or r)
-  bool internalDSubUD = plusOverload->GetTree()->IsWrappedNode();  
-  if( internalDSubUD)  
-  {
-    thisP = this;
-    newEnv= new EnvUDT( callingNode, plusOverload, &self);
-    newEnv->SetNextParUnchecked( &thisP); // LEFT  parameter, as reference to prevent cleanup in newEnv
-    newEnv->SetNextParUnchecked( &r); // RVALUE  parameter, as reference to prevent cleanup in newEnv
-  }
-  else
-  {
-    self = self->Dup();
-    selfGuard.Init( self);
-    newEnv= new EnvUDT( callingNode, plusOverload, &self);
-    newEnv->SetNextParUnchecked( this->Dup()); // LEFT  parameter, as value
-    newEnv->SetNextParUnchecked( r->Dup()); // RIGHT parameter, as value
-  }
-
-  
-  // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
-  StackGuard<EnvStackT> guard(interpreter->CallStack());
-
-  interpreter->CallStack().push_back( newEnv); 
-  
-  // make the call
-  BaseGDL* res=interpreter->call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
-
-  if( !internalDSubUD && self != selfGuard.Get())
-  {
-    // always put out warning first, in case of a later crash
-    Warning( "WARNING: " + plusOverload->ObjectName() + 
-	  ": Assignment to SELF detected (GDL session still ok).");
-    // assignment to SELF -> self was deleted and points to new variable
-    // which it owns
-    selfGuard.Release();
-    if( static_cast<BaseGDL*>(self) != NullGDL::GetSingleInstance())
-      selfGuard.Reset(self);
-  }
-  return res;
-}
-template<>
-BaseGDL* Data_<SpDObj>::SubInv( BaseGDL* r)
-{
-  if( r->Type() == GDL_OBJ && r->Scalar())
-  {
-    return r->Sub( this); // for right order of parameters
-  }
-    
-  // overload here
-  Data_* self;
-  DFun* plusOverload;
-  
-  ProgNodeP callingNode = interpreter->GetRetTree();
-
-  if( !Scalar())
-  {
-    throw GDLException( callingNode, "Cannot apply operation to non-scalar datatype OBJECT.", true, false);
-  }
-  else
-  {
-    // Scalar()
-    self = static_cast<Data_*>( this);
-    plusOverload = static_cast<DFun*>(GDLInterpreter::GetObjHeapOperator( (*self)[0], OOMinus));
-    if( plusOverload == NULL)
-    {
-	throw GDLException( callingNode, "Cannot apply not overloaded operator to datatype OBJECT.", true, false);
-    }
-  }
-
-  assert( self->Scalar());
-  assert( plusOverload != NULL);
-
-  // hidden SELF is counted as well
-  int nParSub = plusOverload->NPar();
-  assert( nParSub >= 1); // SELF
-  if( nParSub < 3) // (SELF), LEFT, RIGHT
-  {
-    throw GDLException( callingNode, plusOverload->ObjectName() +
-		    ": Incorrect number of arguments.",
-		    false, false);
-  }
-  EnvUDT* newEnv;
-  Guard<BaseGDL> selfGuard;
-  BaseGDL* thisP;
-  // Dup() here is not optimal
-  // avoid at least for internal overload routines (which do/must not change SELF or r)
-  bool internalDSubUD = plusOverload->GetTree()->IsWrappedNode();  
-  if( internalDSubUD)  
-  {
-    thisP = this;
-    newEnv= new EnvUDT( callingNode, plusOverload, &self);
-    // order different to Add
-    newEnv->SetNextParUnchecked( &r); // RVALUE  parameter, as reference to prevent cleanup in newEnv
-    newEnv->SetNextParUnchecked( &thisP); // LEFT  parameter, as reference to prevent cleanup in newEnv
-  }
-  else
-  {
-    self = self->Dup();
-    selfGuard.Init( self);
-    newEnv= new EnvUDT( callingNode, plusOverload, &self);
-    // order different to Add
-    newEnv->SetNextParUnchecked( r->Dup()); // RIGHT parameter, as value
-    newEnv->SetNextParUnchecked( this->Dup()); // LEFT  parameter, as value
-  }
-
-  
-  // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
-  StackGuard<EnvStackT> guard(interpreter->CallStack());
-
-  interpreter->CallStack().push_back( newEnv); 
-  
-  // make the call
-  BaseGDL* res=interpreter->call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
-
-  if( !internalDSubUD && self != selfGuard.Get())
-  {
-    // always put out warning first, in case of a later crash
-    Warning( "WARNING: " + plusOverload->ObjectName() + 
-	  ": Assignment to SELF detected (GDL session still ok).");
-    // assignment to SELF -> self was deleted and points to new variable
-    // which it owns
-    selfGuard.Release();
-    if( static_cast<BaseGDL*>(self) != NullGDL::GetSingleInstance())
-      selfGuard.Reset(self);
-  }
-  return res;
-}
-template<class Sp>
-Data_<Sp>* Data_<Sp>::SubS( BaseGDL* r)
-{
-  Data_* right=static_cast<Data_*>(r);
-
-  ULong nEl=N_Elements();
-  assert( nEl);
-  if( nEl == 1)
-    {
-      (*this)[0] -= (*right)[0];
-      return this;
-    }
-  
-  Ty s = (*right)[0];
-  // right->Scalar(s); 
-  //  dd -= s;
-  TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-#pragma omp for
-      for( int i=0; i < nEl; ++i)
-	(*this)[i] -= s;
-    }  //C delete right;
-  return this;
-}
-// inverse substraction: left=right-left
-template<class Sp>
-Data_<Sp>* Data_<Sp>::SubInvS( BaseGDL* r)
-{
-  Data_* right=static_cast<Data_*>(r);
-
-  ULong nEl=N_Elements();
-  assert( nEl);
-
-  if( nEl == 1)
-    {
-      (*this)[0] = (*right)[0] - (*this)[0];
-      return this;
-    }
-  
-  Ty s = (*right)[0];
-  // right->Scalar(s); 
-  //  dd = s - dd;
-  TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-#pragma omp for
-      for( int i=0; i < nEl; ++i)
-	(*this)[i] = s - (*this)[i];
-    }  //C delete right;
-  return this;
-}
-// invalid types
-DStructGDL* DStructGDL::SubS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-DStructGDL* DStructGDL::SubInvS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDString>* Data_<SpDString>::SubS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDString>* Data_<SpDString>::SubInvS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDPtr>* Data_<SpDPtr>::SubS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDPtr>* Data_<SpDPtr>::SubInvS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDObj>* Data_<SpDObj>::SubS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDObj>* Data_<SpDObj>::SubInvS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
-  return this;
-}
-
-// LtMark
-// LtMarks right to itself, //C deletes right
-// right must always have more or same number of elements
-template<class Sp>
-Data_<Sp>* Data_<Sp>::LtMark( BaseGDL* r)
-{
-  Data_* right=static_cast<Data_*>(r);
-
-  //  ULong rEl=right->N_Elements();
-  ULong nEl=N_Elements();
-  //  assert( rEl);
-  assert( nEl);
-  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-  if( nEl == 1)
-    {
-      if( (*this)[0] > (*right)[0]) (*this)[0]=(*right)[0];
-      return this;
-    }
-  TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-#pragma omp for
-      for( int i=0; i < nEl; ++i)
-	if( (*this)[i] > (*right)[i]) (*this)[i]=(*right)[i];
-    }  //C delete right;
-  return this;
-}
-// invalid types
-DStructGDL* DStructGDL::LtMark( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDString>* Data_<SpDString>::LtMark( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDComplex>* Data_<SpDComplex>::LtMark( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
-  return this;
-}
-template<>
-Data_<SpDComplexDbl>* Data_<SpDComplexDbl>::LtMark( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
-  return this;
-}
-template<>
-Data_<SpDPtr>* Data_<SpDPtr>::LtMark( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDObj>* Data_<SpDObj>::LtMark( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
-  return this;
-}
-template<class Sp>
-Data_<Sp>* Data_<Sp>::LtMarkS( BaseGDL* r)
-{
-  Data_* right=static_cast<Data_*>(r);
-  
-  ULong nEl=N_Elements();
-  assert( nEl);
-  if( nEl == 1)
-    {
-      if( (*this)[0] > (*right)[0]) (*this)[0]=(*right)[0];
-      return this;
-    }
-  Ty s = (*right)[0];
-  // right->Scalar(s);
-  TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-#pragma omp for
-      for( int i=0; i < nEl; ++i)
-	if( (*this)[i] > s) (*this)[i]=s;
-    }  //C delete right;
-  return this;
-}
-// invalid types
-DStructGDL* DStructGDL::LtMarkS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDString>* Data_<SpDString>::LtMarkS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDComplex>* Data_<SpDComplex>::LtMarkS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
-  return this;
-}
-template<>
-Data_<SpDComplexDbl>* Data_<SpDComplexDbl>::LtMarkS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
-  return this;
-}
-template<>
-Data_<SpDPtr>* Data_<SpDPtr>::LtMarkS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDObj>* Data_<SpDObj>::LtMarkS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
-  return this;
-}
-// GtMark
-// GtMarks right to itself, //C deletes right
-// right must always have more or same number of elements
-template<class Sp>
-Data_<Sp>* Data_<Sp>::GtMark( BaseGDL* r)
-{
-  Data_* right=static_cast<Data_*>(r);
-
-  //  ULong rEl=right->N_Elements();
-  ULong nEl=N_Elements();
-  // assert( rEl);
-  assert( nEl);
-  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-  if( nEl == 1)
-    {
-      if( (*this)[0] < (*right)[0]) (*this)[0]=(*right)[0];
-      return this;
-    }
-  TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-#pragma omp for
-      for( int i=0; i < nEl; ++i)
-	if( (*this)[i] < (*right)[i]) (*this)[i]=(*right)[i];
-    }  //C delete right;
-  return this;
-}
-// invalid types
-DStructGDL* DStructGDL::GtMark( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDString>* Data_<SpDString>::GtMark( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDComplex>* Data_<SpDComplex>::GtMark( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
-  return this;
-}
-template<>
-Data_<SpDComplexDbl>* Data_<SpDComplexDbl>::GtMark( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
-  return this;
-}
-template<>
-Data_<SpDPtr>* Data_<SpDPtr>::GtMark( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDObj>* Data_<SpDObj>::GtMark( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
-  return this;
-}
-template<class Sp>
-Data_<Sp>* Data_<Sp>::GtMarkS( BaseGDL* r)
-{
-  Data_* right=static_cast<Data_*>(r);
-
-  ULong nEl=N_Elements();
-  assert( nEl);
-  if( nEl == 1)
-    {
-      if( (*this)[0] < (*right)[0]) (*this)[0]=(*right)[0];
-      return this;
-    }
-
-  Ty s = (*right)[0];
-  // right->Scalar(s);
-  TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-#pragma omp for
-      for( int i=0; i < nEl; ++i)
-	if( (*this)[i] < s) (*this)[i]=s;
-    }  //C delete right;
-  return this;
-}
-// invalid types
-DStructGDL* DStructGDL::GtMarkS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDString>* Data_<SpDString>::GtMarkS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDComplex>* Data_<SpDComplex>::GtMarkS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
-  return this;
-}
-template<>
-Data_<SpDComplexDbl>* Data_<SpDComplexDbl>::GtMarkS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
-  return this;
-}
-template<>
-Data_<SpDPtr>* Data_<SpDPtr>::GtMarkS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDObj>* Data_<SpDObj>::GtMarkS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
-  return this;
-}
-
-// Mult
-// Mults right to itself, //C deletes right
-// right must always have more or same number of elements
-template<class Sp>
-Data_<Sp>* Data_<Sp>::Mult( BaseGDL* r)
-{
-  Data_* right=static_cast<Data_*>(r);
-
-  //  ULong rEl=right->N_Elements();
-  ULong nEl=N_Elements();
-  // assert( rEl);
-  assert( nEl);
-  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-  if( nEl == 1)
-    {
-      (*this)[0] *= (*right)[0];
-      return this;
-    }
-  TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-#pragma omp for
-      for( int i=0; i < nEl; ++i)
-	(*this)[i] *= (*right)[i];
-    }  //C delete right;
-  return this;
-}
-// invalid types
-DStructGDL* DStructGDL::Mult( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDString>* Data_<SpDString>::Mult( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDPtr>* Data_<SpDPtr>::Mult( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDObj>* Data_<SpDObj>::Mult( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
-  return this;
-}
-
-template<class Sp>
-Data_<Sp>* Data_<Sp>::MultS( BaseGDL* r)
-{
-  Data_* right=static_cast<Data_*>(r);
+  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
+  return this;
+}
+// GtMark
+// GtMarks right to itself, //C deletes right
+// right must always have more or same number of elements
+template<class Sp>
+Data_<Sp>* Data_<Sp>::GtMark( BaseGDL* r)
+{
+  Data_* right=static_cast<Data_*>(r);
 
+  //  ULong rEl=right->N_Elements();
   ULong nEl=N_Elements();
+  // assert( rEl);
   assert( nEl);
+  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
   if( nEl == 1)
     {
-      (*this)[0] *= (*right)[0];
+      if( (*this)[0] < (*right)[0]) (*this)[0]=(*right)[0];
       return this;
     }
-  Ty s = (*right)[0];
-  // right->Scalar(s);
-  //  dd *= s;
   TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
-	(*this)[i] *= s;
+      for( OMPInt i=0; i < nEl; ++i)
+	if( (*this)[i] < (*right)[i]) (*this)[i]=(*right)[i];
     }  //C delete right;
   return this;
 }
 // invalid types
-DStructGDL* DStructGDL::MultS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDString>* Data_<SpDString>::MultS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDPtr>* Data_<SpDPtr>::MultS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDObj>* Data_<SpDObj>::MultS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
-  return this;
-}
-
-// Div
-// division: left=left/right
-template<class Sp>
-Data_<Sp>* Data_<Sp>::Div( BaseGDL* r)
-{
-  Data_* right=static_cast<Data_*>(r);
-
-  //  ULong rEl=right->N_Elements();
-  ULong nEl=N_Elements();
-  //  assert( rEl);
-  assert( nEl);
-  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-
-  SizeT i = 0;
-
-  if( sigsetjmp( sigFPEJmpBuf, 1) == 0)
-    {
-      // TODO: Check if we can use OpenMP here (is longjmp allowed?)
-      //             if yes: need to run the full loop after the longjmp
-      for( /*SizeT i=0*/; i < nEl; ++i)
-	(*this)[i] /= (*right)[i];
-      //C delete right;
-      return this;
-    }
-  else
-    {
-      TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-	{
-	  //       bool zeroEncountered = false; // until zero operation is already done.
-#pragma omp for
-	  for( int ix=i; ix < nEl; ++ix)
-	    /*	if( !zeroEncountered)
-		{
-		if( (*right)[ix] == this->zero)
-		zeroEncountered = true;
-		}
-		else*/
-	    if( (*right)[ix] != this->zero) (*this)[ix] /= (*right)[ix];
-	}      //C delete right;
-      return this;
-    }
-}
-// inverse division: left=right/left
-template<class Sp>
-Data_<Sp>* Data_<Sp>::DivInv( BaseGDL* r)
-{
-  Data_* right=static_cast<Data_*>(r);
-
-  //  ULong rEl=right->N_Elements();
-  ULong nEl=N_Elements();
-  //  assert( rEl);
-  assert( nEl);
-
-  SizeT i = 0;
-
-  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-  if( sigsetjmp( sigFPEJmpBuf, 1) == 0)
-    {
-      for( /*SizeT i=0*/; i < nEl; ++i)
-	(*this)[i] = (*right)[i] / (*this)[i];
-      //C delete right;
-      return this;
-    }
-  else
-    {
-      TRACEOMP( __FILE__, __LINE__)
-#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-	{
-	  //       bool zeroEncountered = false; // until zero operation is already done.
-#pragma omp for
-	  for( int ix=i; ix < nEl; ++ix)
-	    /*	if( !zeroEncountered)
-		{
-		if( (*this)[ix] == this->zero)
-		{
-		zeroEncountered = true;
-		(*this)[ ix] = (*right)[i];
-		}
-		}
-		else*/
-	    if( (*this)[ix] != this->zero) 
-	      (*this)[ix] = (*right)[ix] / (*this)[ix]; 
-	    else
-	      (*this)[ix] = (*right)[ix];
-	}      //C delete right;
-      return this;
-    }
-}
-// invalid types
-DStructGDL* DStructGDL::Div( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-DStructGDL* DStructGDL::DivInv( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
 template<>
-Data_<SpDString>* Data_<SpDString>::Div( BaseGDL* r)
+Data_<SpDString>* Data_<SpDString>::GtMark( BaseGDL* r)
 {
   throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
   return this;
 }
 template<>
-Data_<SpDString>* Data_<SpDString>::DivInv( BaseGDL* r)
+Data_<SpDComplex>* Data_<SpDComplex>::GtMark( BaseGDL* r)
 {
-  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
+  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
   return this;
 }
 template<>
-Data_<SpDPtr>* Data_<SpDPtr>::Div( BaseGDL* r)
+Data_<SpDComplexDbl>* Data_<SpDComplexDbl>::GtMark( BaseGDL* r)
 {
-  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
   return this;
 }
 template<>
-Data_<SpDPtr>* Data_<SpDPtr>::DivInv( BaseGDL* r)
+Data_<SpDPtr>* Data_<SpDPtr>::GtMark( BaseGDL* r)
 {
   throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
   return this;
 }
 template<>
-Data_<SpDObj>* Data_<SpDObj>::Div( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDObj>* Data_<SpDObj>::DivInv( BaseGDL* r)
+Data_<SpDObj>* Data_<SpDObj>::GtMark( BaseGDL* r)
 {
   throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
   return this;
 }
 template<class Sp>
-Data_<Sp>* Data_<Sp>::DivS( BaseGDL* r)
+Data_<Sp>* Data_<Sp>::GtMarkS( BaseGDL* r)
 {
   Data_* right=static_cast<Data_*>(r);
 
   ULong nEl=N_Elements();
   assert( nEl);
-  Ty s = (*right)[0];
-
-  // remember: this is a template (must work for several types)
-  // due to error handling the actual devision by 0
-  // has to be done 
-  // but if not 0, we save the expensive error handling
-  if( s != this->zero)
-    {
-      for(SizeT i=0; i < nEl; ++i)
-      {
-	(*this)[i] /= s;
-      }
-      return this;
-    }
-  if( sigsetjmp( sigFPEJmpBuf, 1) == 0)
+  if( nEl == 1)
     {
-      for(SizeT i=0; i < nEl; ++i)
-      {
-	(*this)[i] /= s;
-      }
+      if( (*this)[0] < (*right)[0]) (*this)[0]=(*right)[0];
       return this;
     }
-  return this;
-}
 
-// inverse division: left=right/left
-template<class Sp>
-Data_<Sp>* Data_<Sp>::DivInvS( BaseGDL* r)
-{
-  Data_* right=static_cast<Data_*>(r);
-
-  ULong nEl=N_Elements();
-  assert( nEl);
-  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
-
-  // remember: this is a template (must work for several types)
-  // due to error handling the actual devision by 0
-  // has to be done 
-  // but if not 0, we save the expensive error handling
-  if( nEl == 1 && (*this)[0] != this->zero) 
-  {
-    (*this)[0] = (*right)[0] / (*this)[0]; 
-    return this;
-  }
-  
   Ty s = (*right)[0];
-  SizeT i=0;
-  if( sigsetjmp( sigFPEJmpBuf, 1) == 0)
-    {
-      // right->Scalar(s); 
-      for( /*SizeT i=0*/; i < nEl; ++i)
-	(*this)[i] = s / (*this)[i];
-      //C delete right;
-      return this;
-    }
-  else
+  // right->Scalar(s);
+  TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
-//      TRACEOMP( __FILE__, __LINE__)
-// #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-// 	{
-// 	  //       bool zeroEncountered = false;
-// #pragma omp for
-	  // right->Scalar(s); 
-	  for( SizeT ix=i; ix < nEl; ++ix)
-	    /*	if( !zeroEncountered)
-		{
-		if( (*this)[ix] == this->zero)
-		{
-		zeroEncountered = true;
-		(*this)[ix] = s;
-		}
-		}
-		else*/
-	    if( (*this)[ix] != this->zero) 
-	      (*this)[ix] = s / (*this)[ix]; 
-	    else 
-	      (*this)[ix] = s;
-// 	}      //C delete right;
-      return this;
-    }
-}
-// invalid types
-DStructGDL* DStructGDL::DivS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-DStructGDL* DStructGDL::DivInvS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+#pragma omp for
+      for( OMPInt i=0; i < nEl; ++i)
+	if( (*this)[i] < s) (*this)[i]=s;
+    }  //C delete right;
   return this;
 }
+// invalid types
 template<>
-Data_<SpDString>* Data_<SpDString>::DivS( BaseGDL* r)
+Data_<SpDString>* Data_<SpDString>::GtMarkS( BaseGDL* r)
 {
   throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
   return this;
 }
 template<>
-Data_<SpDString>* Data_<SpDString>::DivInvS( BaseGDL* r)
+Data_<SpDComplex>* Data_<SpDComplex>::GtMarkS( BaseGDL* r)
 {
-  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
+  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
   return this;
 }
 template<>
-Data_<SpDPtr>* Data_<SpDPtr>::DivS( BaseGDL* r)
+Data_<SpDComplexDbl>* Data_<SpDComplexDbl>::GtMarkS( BaseGDL* r)
 {
-  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
   return this;
 }
 template<>
-Data_<SpDPtr>* Data_<SpDPtr>::DivInvS( BaseGDL* r)
+Data_<SpDPtr>* Data_<SpDPtr>::GtMarkS( BaseGDL* r)
 {
   throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
   return this;
 }
 template<>
-Data_<SpDObj>* Data_<SpDObj>::DivS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
-  return this;
-}
-template<>
-Data_<SpDObj>* Data_<SpDObj>::DivInvS( BaseGDL* r)
+Data_<SpDObj>* Data_<SpDObj>::GtMarkS( BaseGDL* r)
 {
   throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
   return this;
 }
 
+
 // Mod
 // modulo division: left=left % right
 template<class Sp>
@@ -4021,7 +2961,7 @@
 	{
 	  //       bool zeroEncountered = false;
 #pragma omp for
-	  for( int ix=i; ix < nEl; ++ix)
+	  for( OMPInt ix=i; ix < nEl; ++ix)
 	    /*	if( !zeroEncountered)
 		{
 		if( (*right)[i] == this->zero)
@@ -4066,7 +3006,7 @@
 	{
 	  //       bool zeroEncountered = false;
 #pragma omp for
-	  for( int ix=i; ix < nEl; ++ix)
+	  for( OMPInt ix=i; ix < nEl; ++ix)
 	    /*	if( !zeroEncountered)
 		{
 		if( (*this)[ix] == this->zero)
@@ -4105,7 +3045,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = Modulo((*this)[i],(*right)[i]);
     }  //C delete right;
   return this;
@@ -4125,7 +3065,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = Modulo((*right)[i],(*this)[i]);
     }  //C delete right;
   return this;
@@ -4152,7 +3092,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = DModulo((*this)[i],(*right)[i]);
     }  //C delete right;
   return this;
@@ -4172,22 +3112,12 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = DModulo((*right)[i],(*this)[i]);
     }  //C delete right;
   return this;
 }
 // invalid types
-DStructGDL* DStructGDL::Mod( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-DStructGDL* DStructGDL::ModInv( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::Mod( BaseGDL* r)
 {
@@ -4336,7 +3266,7 @@
 #pragma omp for
 	  //       bool zeroEncountered = false;
 	  // right->Scalar(s); 
-	  for( int ix=i; ix < nEl; ++ix)
+	  for( OMPInt ix=i; ix < nEl; ++ix)
 	    /*	if( !zeroEncountered)
 		{
 		if( (*this)[ix] == this->zero)
@@ -4368,7 +3298,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = Modulo((*this)[i],s);
     }  //C delete right;
   return this;
@@ -4388,7 +3318,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = Modulo(s,(*this)[i]);
     }  //C delete right;
   return this;
@@ -4406,7 +3336,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = DModulo((*this)[i],s);
     }  //C delete right;
   return this;
@@ -4425,22 +3355,12 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = DModulo(s,(*this)[i]);
     }  //C delete right;
   return this;
 }
 // invalid types
-DStructGDL* DStructGDL::ModS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-DStructGDL* DStructGDL::ModInvS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::ModS( BaseGDL* r)
 
@@ -4545,7 +3465,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = pow( (*this)[i], (*right)[i]); // valarray
     }  //C delete right;
   return this;
@@ -4568,7 +3488,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = pow( (*right)[i], (*this)[i]);
     }  //C delete right;
   return this;
@@ -4594,7 +3514,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
       {
 #pragma omp for
-	for( int i=0; i < nEl; ++i)
+	for( OMPInt i=0; i < nEl; ++i)
 	  (*this)[i] = pow( (*this)[i], (*right)[i]);
       }    }
   return this;
@@ -4607,11 +3527,6 @@
   assert( 0);
   return this;
 }
-DStructGDL* DStructGDL::PowInt( BaseGDL* r)
-{
-  assert( 0);
-  return this;
-}
 // floats power of value with GDL_LONG: left=left ^ right
 template<>
 Data_<SpDFloat>* Data_<SpDFloat>::PowInt( BaseGDL* r)
@@ -4629,7 +3544,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*this)[i] = pow( (*this)[i], r0);
 	}      return this;
     }
@@ -4641,7 +3556,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[ i] = pow( s0, (*right)[ i]);
 	}      return res;
     }
@@ -4651,7 +3566,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*this)[i] = pow( (*this)[i], (*right)[i]);
 	}      return this;
     }
@@ -4662,7 +3577,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = pow( (*this)[i], (*right)[i]);
 	}      return res;
     }
@@ -4684,7 +3599,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*this)[i] = pow( (*this)[i], r0);
 	}      return this;
     }
@@ -4696,7 +3611,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[ i] = pow( s0, (*right)[ i]);
 	}      return res;
     }
@@ -4706,7 +3621,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*this)[i] = pow( (*this)[i], (*right)[i]);
 	}      return this;
     }
@@ -4717,7 +3632,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = pow( (*this)[i], (*right)[i]);
 	}      return res;
     }
@@ -4742,7 +3657,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = pow( (*right)[i], (*this)[i]);
     }  //C delete right;
   return this;
@@ -4767,7 +3682,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = pow( (*this)[i], (*right)[i]);
     }  //C delete right;
   return this;
@@ -4792,7 +3707,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = pow( (*right)[i], (*this)[i]);
     }  //C delete right;
   return this;
@@ -4821,7 +3736,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		(*this)[ i] = pow( (*this)[ i], s);
 	    }	  //C delete right;
 	  return this;
@@ -4840,7 +3755,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		    {
 #pragma omp for
-		      for( int i=0; i<rEl; ++i)
+		      for( OMPInt i=0; i<rEl; ++i)
 			(*res)[ i] = pow( s, (*right)[ i]);
 		    }		  //C delete right;
 		  return res;
@@ -4850,7 +3765,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 		{
 #pragma omp for
-		  for( int i=0; i<nEl; ++i)
+		  for( OMPInt i=0; i<nEl; ++i)
 		    (*this)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      return this;
@@ -4863,7 +3778,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		{
 #pragma omp for
-		  for( int i=0; i<rEl; ++i)
+		  for( OMPInt i=0; i<rEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      //C delete this;
@@ -4885,7 +3800,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		(*this)[ i] = pow( (*this)[ i], s);
 	    }	  //C delete right;
 	  return this;
@@ -4904,7 +3819,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		    {
 #pragma omp for
-		      for( int i=0; i<rEl; ++i)
+		      for( OMPInt i=0; i<rEl; ++i)
 			(*res)[ i] = pow( s, (*right)[ i]);
 		    }		  //C delete right;
 		  return res;
@@ -4914,7 +3829,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 		{
 #pragma omp for
-		  for( int i=0; i<nEl; ++i)
+		  for( OMPInt i=0; i<nEl; ++i)
 		    (*this)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      return this;
@@ -4927,7 +3842,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		{
 #pragma omp for
-		  for( int i=0; i<rEl; ++i)
+		  for( OMPInt i=0; i<rEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      //C delete this;
@@ -4955,7 +3870,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = pow( (*this)[i], (*right)[i]);
     }
 #endif
@@ -4986,7 +3901,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = pow( (*right)[i], (*this)[i]);
 #endif
     }  //C delete right;
@@ -5016,7 +3931,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		(*this)[ i] = pow( (*this)[ i], s);
 	    }	  //C delete right;
 	  return this;
@@ -5035,7 +3950,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		    {
 #pragma omp for
-		      for( int i=0; i<rEl; ++i)
+		      for( OMPInt i=0; i<rEl; ++i)
 			(*res)[ i] = pow( s, (*right)[ i]);
 		    }		  //C delete right;
 		  return res;
@@ -5045,7 +3960,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 		{
 #pragma omp for
-		  for( int i=0; i<nEl; ++i)
+		  for( OMPInt i=0; i<nEl; ++i)
 		    (*this)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      return this;
@@ -5058,7 +3973,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		{
 #pragma omp for
-		  for( int i=0; i<rEl; ++i)
+		  for( OMPInt i=0; i<rEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      //C delete this;
@@ -5082,7 +3997,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		(*this)[ i] = pow( (*this)[ i], s);
 	    }	  //C delete right;
 	  return this;
@@ -5101,7 +4016,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		    {
 #pragma omp for
-		      for( int i=0; i<rEl; ++i)
+		      for( OMPInt i=0; i<rEl; ++i)
 			(*res)[ i] = pow( s, (*right)[ i]);
 		    }		  //C delete right;
 		  return res;
@@ -5111,7 +4026,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 		{
 #pragma omp for
-		  for( int i=0; i<nEl; ++i)
+		  for( OMPInt i=0; i<nEl; ++i)
 		    (*this)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      return this;
@@ -5124,7 +4039,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		{
 #pragma omp for
-		  for( int i=0; i<rEl; ++i)
+		  for( OMPInt i=0; i<rEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      //C delete this;
@@ -5152,7 +4067,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = pow( (*this)[i], (*right)[i]);
     }
 #endif
@@ -5183,7 +4098,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = pow( (*right)[i], (*this)[i]);
     }
 #endif
@@ -5191,16 +4106,6 @@
   return this;
 }
 // invalid types
-DStructGDL* DStructGDL::Pow( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-DStructGDL* DStructGDL::PowInv( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::Pow( BaseGDL* r)
 {
@@ -5252,7 +4157,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = pow( (*this)[i], s); 
     }
   //C delete right;
@@ -5274,7 +4179,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*this)[i] = pow( s, (*this)[i]);
     }  //C delete right;
   return this;
@@ -5293,7 +4198,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)	
+      for( OMPInt i=0; i<nEl; ++i)	
 	dd[ i] = pow( dd[ i], s); // valarray
     }  //C delete right;
   return this;
@@ -5312,7 +4217,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)	
+      for( OMPInt i=0; i<nEl; ++i)	
 	dd[ i] = pow( s, dd[ i]); // valarray
     }  //C delete right;
   return this;
@@ -5331,7 +4236,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)	
+      for( OMPInt i=0; i<nEl; ++i)	
 	dd[ i] = pow( dd[ i], s); // valarray
     }  //C delete right;
   return this;
@@ -5350,7 +4255,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)	
+      for( OMPInt i=0; i<nEl; ++i)	
 	dd[ i] = pow( s, dd[ i]); // valarray
     }  //C delete right;
   return this;
@@ -5379,7 +4284,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		(*this)[ i] = pow( (*this)[ i], s);
 	    }	  //C delete right;
 	  return this;
@@ -5398,7 +4303,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		    {
 #pragma omp for
-		      for( int i=0; i<rEl; ++i)
+		      for( OMPInt i=0; i<rEl; ++i)
 			(*res)[ i] = pow( s, (*right)[ i]);
 		    }		  //C delete right;
 		  return res;
@@ -5408,7 +4313,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 		{
 #pragma omp for
-		  for( int i=0; i<nEl; ++i)
+		  for( OMPInt i=0; i<nEl; ++i)
 		    (*this)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      return this;
@@ -5421,7 +4326,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		{
 #pragma omp for
-		  for( int i=0; i<rEl; ++i)
+		  for( OMPInt i=0; i<rEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      //C delete this;
@@ -5443,7 +4348,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		(*this)[ i] = pow( (*this)[ i], s);
 	    }	  //C delete right;
 	  return this;
@@ -5462,7 +4367,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		    {
 #pragma omp for
-		      for( int i=0; i<rEl; ++i)
+		      for( OMPInt i=0; i<rEl; ++i)
 			(*res)[ i] = pow( s, (*right)[ i]);
 		    }		  //C delete right;
 		  return res;
@@ -5472,7 +4377,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 		{
 #pragma omp for
-		  for( int i=0; i<nEl; ++i)
+		  for( OMPInt i=0; i<nEl; ++i)
 		    (*this)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      return this;
@@ -5485,7 +4390,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		{
 #pragma omp for
-		  for( int i=0; i<rEl; ++i)
+		  for( OMPInt i=0; i<rEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      //C delete this;
@@ -5506,7 +4411,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	(*this)[ i] = pow( (*this)[ i], s);
     }
   //#else
@@ -5534,7 +4439,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	(*this)[ i] = pow( s, (*this)[ i]);
     }
   //#else
@@ -5559,7 +4464,7 @@
 
       DDouble s;
 
-      // note: changes here have to be reflected in POWNCNode::Eval() (dnode.cpp)
+      // note: changes here have to be reflected in POWNCNode::Eval() (prognodeexpr.cpp)
       // (concerning when a new variable is created vs. using this)
       if( right->StrictScalar(s)) 
 	{
@@ -5567,7 +4472,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		(*this)[ i] = pow( (*this)[ i], s);
 	    }	  //C delete right;
 	  return this;
@@ -5586,7 +4491,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		    {
 #pragma omp for
-		      for( int i=0; i<rEl; ++i)
+		      for( OMPInt i=0; i<rEl; ++i)
 			(*res)[ i] = pow( s, (*right)[ i]);
 		    }		  //C delete right;
 		  return res;
@@ -5596,7 +4501,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 		{
 #pragma omp for
-		  for( int i=0; i<nEl; ++i)
+		  for( OMPInt i=0; i<nEl; ++i)
 		    (*this)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      return this;
@@ -5609,7 +4514,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		{
 #pragma omp for
-		  for( int i=0; i<rEl; ++i)
+		  for( OMPInt i=0; i<rEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      //C delete this;
@@ -5633,7 +4538,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		(*this)[ i] = pow( (*this)[ i], s);
 	    }	  //C delete right;
 	  return this;
@@ -5652,7 +4557,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		    {
 #pragma omp for
-		      for( int i=0; i<rEl; ++i)
+		      for( OMPInt i=0; i<rEl; ++i)
 			(*res)[ i] = pow( s, (*right)[ i]);
 		    }		  //C delete right;
 		  return res;
@@ -5662,7 +4567,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 		{
 #pragma omp for
-		  for( int i=0; i<nEl; ++i)
+		  for( OMPInt i=0; i<nEl; ++i)
 		    (*this)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      return this;
@@ -5675,7 +4580,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		{
 #pragma omp for
-		  for( int i=0; i<rEl; ++i)
+		  for( OMPInt i=0; i<rEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      //C delete this;
@@ -5696,7 +4601,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	(*this)[ i] = pow( (*this)[ i], s);
     }
   //#else
@@ -5721,7 +4626,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	(*this)[ i] = pow( s, (*this)[ i]);
     }
   //#else
@@ -5731,16 +4636,6 @@
   return this;
 }
 // invalid types
-DStructGDL* DStructGDL::PowS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
-DStructGDL* DStructGDL::PowInvS( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return this;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::PowS( BaseGDL* r)
 {
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/basic_op_div.cpp gdl/src/basic_op_div.cpp
--- gdl-0.9.3/src/basic_op_div.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/basic_op_div.cpp	2013-03-25 10:36:38.167970733 -0600
@@ -0,0 +1,292 @@
+/***************************************************************************
+                          basic_op_div.cpp  -  GDL div (/) operators
+                             -------------------
+    begin                : July 22 2002
+    copyright            : (C) 2002 by Marc Schellens
+    email                : m_schellens@users.sf.net
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+// to be included from datatypes.cpp
+#ifdef INCLUDE_BASIC_OP_CPP
+
+// // header in datatypes.hpp
+// 
+// //#include "datatypes.hpp"
+// //#include "dstructgdl.hpp"
+// //#include "arrayindex.hpp"
+// 
+// //#include <csignal>
+// #include "sigfpehandler.hpp"
+// 
+// #ifdef _OPENMP
+// #include <omp.h>
+// #endif
+// 
+// #include "typetraits.hpp"
+// 
+// using namespace std;
+
+// Div
+// division: left=left/right
+template<class Sp>
+Data_<Sp>* Data_<Sp>::Div( BaseGDL* r)
+{
+  Data_* right=static_cast<Data_*>(r);
+
+  //  ULong rEl=right->N_Elements();
+  ULong nEl=N_Elements();
+  //  assert( rEl);
+  assert( nEl);
+  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
+
+  SizeT i = 0;
+
+  if( sigsetjmp( sigFPEJmpBuf, 1) == 0)
+    {
+      // TODO: Check if we can use OpenMP here (is longjmp allowed?)
+      //             if yes: need to run the full loop after the longjmp
+      for( /*SizeT i=0*/; i < nEl; ++i)
+	(*this)[i] /= (*right)[i];
+      //C delete right;
+      return this;
+    }
+  else
+    {
+      TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+	{
+	  //       bool zeroEncountered = false; // until zero operation is already done.
+#pragma omp for
+	  for( OMPInt ix=i; ix < nEl; ++ix)
+	    /*	if( !zeroEncountered)
+		{
+		if( (*right)[ix] == this->zero)
+		zeroEncountered = true;
+		}
+		else*/
+	    if( (*right)[ix] != this->zero) (*this)[ix] /= (*right)[ix];
+	}      //C delete right;
+      return this;
+    }
+}
+// inverse division: left=right/left
+template<class Sp>
+Data_<Sp>* Data_<Sp>::DivInv( BaseGDL* r)
+{
+  Data_* right=static_cast<Data_*>(r);
+
+  //  ULong rEl=right->N_Elements();
+  ULong nEl=N_Elements();
+  //  assert( rEl);
+  assert( nEl);
+
+  SizeT i = 0;
+
+  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
+  if( sigsetjmp( sigFPEJmpBuf, 1) == 0)
+    {
+      for( /*SizeT i=0*/; i < nEl; ++i)
+	(*this)[i] = (*right)[i] / (*this)[i];
+      //C delete right;
+      return this;
+    }
+  else
+    {
+      TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+	{
+	  //       bool zeroEncountered = false; // until zero operation is already done.
+#pragma omp for
+	  for( OMPInt ix=i; ix < nEl; ++ix)
+	    /*	if( !zeroEncountered)
+		{
+		if( (*this)[ix] == this->zero)
+		{
+		zeroEncountered = true;
+		(*this)[ ix] = (*right)[i];
+		}
+		}
+		else*/
+	    if( (*this)[ix] != this->zero) 
+	      (*this)[ix] = (*right)[ix] / (*this)[ix]; 
+	    else
+	      (*this)[ix] = (*right)[ix];
+	}      //C delete right;
+      return this;
+    }
+}
+// invalid types
+template<>
+Data_<SpDString>* Data_<SpDString>::Div( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDString>* Data_<SpDString>::DivInv( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::Div( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::DivInv( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDObj>* Data_<SpDObj>::Div( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDObj>* Data_<SpDObj>::DivInv( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
+  return this;
+}
+template<class Sp>
+Data_<Sp>* Data_<Sp>::DivS( BaseGDL* r)
+{
+  Data_* right=static_cast<Data_*>(r);
+
+  ULong nEl=N_Elements();
+  assert( nEl);
+  Ty s = (*right)[0];
+
+  // remember: this is a template (must work for several types)
+  // due to error handling the actual devision by 0
+  // has to be done 
+  // but if not 0, we save the expensive error handling
+  if( s != this->zero)
+    {
+      for(SizeT i=0; i < nEl; ++i)
+      {
+	(*this)[i] /= s;
+      }
+      return this;
+    }
+  if( sigsetjmp( sigFPEJmpBuf, 1) == 0)
+    {
+      for(SizeT i=0; i < nEl; ++i)
+      {
+	(*this)[i] /= s;
+      }
+      return this;
+    }
+  return this;
+}
+
+// inverse division: left=right/left
+template<class Sp>
+Data_<Sp>* Data_<Sp>::DivInvS( BaseGDL* r)
+{
+  Data_* right=static_cast<Data_*>(r);
+
+  ULong nEl=N_Elements();
+  assert( nEl);
+  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
+
+  // remember: this is a template (must work for several types)
+  // due to error handling the actual devision by 0
+  // has to be done 
+  // but if not 0, we save the expensive error handling
+  if( nEl == 1 && (*this)[0] != this->zero) 
+  {
+    (*this)[0] = (*right)[0] / (*this)[0]; 
+    return this;
+  }
+  
+  Ty s = (*right)[0];
+  SizeT i=0;
+  if( sigsetjmp( sigFPEJmpBuf, 1) == 0)
+    {
+      // right->Scalar(s); 
+      for( /*SizeT i=0*/; i < nEl; ++i)
+	(*this)[i] = s / (*this)[i];
+      //C delete right;
+      return this;
+    }
+  else
+    {
+//      TRACEOMP( __FILE__, __LINE__)
+// #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+// 	{
+// 	  //       bool zeroEncountered = false;
+// #pragma omp for
+	  // right->Scalar(s); 
+	  for( SizeT ix=i; ix < nEl; ++ix)
+	    /*	if( !zeroEncountered)
+		{
+		if( (*this)[ix] == this->zero)
+		{
+		zeroEncountered = true;
+		(*this)[ix] = s;
+		}
+		}
+		else*/
+	    if( (*this)[ix] != this->zero) 
+	      (*this)[ix] = s / (*this)[ix]; 
+	    else 
+	      (*this)[ix] = s;
+// 	}      //C delete right;
+      return this;
+    }
+}
+// invalid types
+template<>
+Data_<SpDString>* Data_<SpDString>::DivS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDString>* Data_<SpDString>::DivInvS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::DivS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::DivInvS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDObj>* Data_<SpDObj>::DivS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDObj>* Data_<SpDObj>::DivInvS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
+  return this;
+}
+
+
+
+#endif
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/basic_op_mult.cpp gdl/src/basic_op_mult.cpp
--- gdl-0.9.3/src/basic_op_mult.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/basic_op_mult.cpp	2013-03-25 10:36:38.172970710 -0600
@@ -0,0 +1,146 @@
+/***************************************************************************
+                          basic_op_mult.cpp  -  GDL mult (*) operators
+                             -------------------
+    begin                : July 22 2002
+    copyright            : (C) 2002 by Marc Schellens
+    email                : m_schellens@users.sf.net
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+// to be included from datatypes.cpp
+#ifdef INCLUDE_BASIC_OP_CPP
+
+// // header in datatypes.hpp
+// 
+// //#include "datatypes.hpp"
+// //#include "dstructgdl.hpp"
+// //#include "arrayindex.hpp"
+// 
+// //#include <csignal>
+// #include "sigfpehandler.hpp"
+// 
+// #ifdef _OPENMP
+// #include <omp.h>
+// #endif
+// 
+// #include "typetraits.hpp"
+// 
+// using namespace std;
+
+// Mult
+// Mults right to itself, //C deletes right
+// right must always have more or same number of elements
+template<class Sp>
+Data_<Sp>* Data_<Sp>::Mult( BaseGDL* r)
+{
+  Data_* right=static_cast<Data_*>(r);
+
+  //  ULong rEl=right->N_Elements();
+  ULong nEl=N_Elements();
+  // assert( rEl);
+  assert( nEl);
+  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
+  if( nEl == 1)
+    {
+      (*this)[0] *= (*right)[0];
+      return this;
+    }
+#ifdef USE_EIGEN
+
+  Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+  Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRight(&(*right)[0], nEl);
+  mThis *= mRight;
+  return this;
+#else
+  TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+    {
+#pragma omp for
+      for( OMPInt i=0; i < nEl; ++i)
+	(*this)[i] *= (*right)[i];
+    }  //C delete right;
+  return this;
+#endif
+  
+}
+// invalid types
+template<>
+Data_<SpDString>* Data_<SpDString>::Mult( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::Mult( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDObj>* Data_<SpDObj>::Mult( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
+  return this;
+}
+
+template<class Sp>
+Data_<Sp>* Data_<Sp>::MultS( BaseGDL* r)
+{
+  Data_* right=static_cast<Data_*>(r);
+
+  ULong nEl=N_Elements();
+  assert( nEl);
+  if( nEl == 1)
+    {
+      (*this)[0] *= (*right)[0];
+      return this;
+    }
+  Ty s = (*right)[0];
+  // right->Scalar(s);
+  //  dd *= s;
+#ifdef USE_EIGEN
+
+  Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+  mThis *= s;
+  return this;
+#else
+  TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+    {
+#pragma omp for
+      for( OMPInt i=0; i < nEl; ++i)
+	(*this)[i] *= s;
+    }  //C delete right;
+  return this;
+#endif
+  
+}
+// invalid types
+template<>
+Data_<SpDString>* Data_<SpDString>::MultS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::MultS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDObj>* Data_<SpDObj>::MultS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
+  return this;
+}
+
+#endif
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/basic_op_new.cpp gdl/src/basic_op_new.cpp
--- gdl-0.9.3/src/basic_op_new.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/basic_op_new.cpp	2013-03-25 10:36:38.182970663 -0600
@@ -54,7 +54,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = (*this)[i] & (*right)[i]; // & Ty(1);
     }
   return res;
@@ -86,7 +86,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for ( int i=0; i < nEl; ++i )
+      for ( OMPInt i=0; i < nEl; ++i )
 	if ( (*right)[i] == zero ) (*res)[i] = zero; else (*res)[i] = (*this)[i];
     }
   return res;
@@ -110,7 +110,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*this)[i] != zero) (*res)[i] = (*right)[i]; else (*res)[i] = zero; 
     }
   return res;
@@ -135,7 +135,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if ( (*right)[i] == zero ) (*res)[i] = zero; else (*res)[i] = (*this)[i];
     }
   return res;
@@ -159,22 +159,12 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*this)[i] != zero) (*res)[i] = (*right)[i]; else (*res)[i] = zero;
     }
   return res;
 }
 // invalid types
-DStructGDL* DStructGDL::AndOpNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
-DStructGDL* DStructGDL::AndOpInvNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::AndOpNew( BaseGDL* r)
 {
@@ -245,7 +235,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared(s)
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = (*this)[i] & s;
     }
   return res;
@@ -291,7 +281,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    if( (*this)[i] != zero) (*res)[i] = s; else (*res)[i] = zero;
 	}
 	return res;
@@ -332,29 +322,13 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    if( (*this)[i] != zero) (*res)[i] = s; else (*res)[i] = zero;
 	}
 	return res;
     }
 }
 // invalid types
-DStructGDL* DStructGDL::AndOpSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
-DStructGDL* DStructGDL::AndOpInvSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
-// template<>
-// DStructGDL* DStructGDL::AndOpInvNew( BaseGDL* r)
-// {
-//  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-//  return res;
-// }
 template<>
 Data_<SpDString>* Data_<SpDString>::AndOpSNew( BaseGDL* r)
 {
@@ -418,7 +392,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = (*this)[i] | (*right)[i]; // | Ty(1);
     }
   //C delete right;
@@ -451,7 +425,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*this)[i] == zero) (*res)[i] = (*right)[i]; else (*res)[i] = (*this)[i];
     }  //C delete right;
   return res;
@@ -475,7 +449,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*right)[i] != zero) (*res)[i] = (*right)[i]; else (*res)[i] = (*this)[i];
     }  //C delete right;
   return res;
@@ -501,7 +475,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*this)[i] == zero) (*res)[i] = (*right)[i]; else (*res)[i] = (*this)[i];
     }  //C delete right;
   return res;
@@ -525,22 +499,12 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*right)[i] != zero) (*res)[i] = (*right)[i]; else (*res)[i] = (*this)[i];
     }  //C delete right;
   return res;
 }
 // invalid types
-DStructGDL* DStructGDL::OrOpNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
-DStructGDL* DStructGDL::OrOpInvNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::OrOpNew( BaseGDL* r)
 {
@@ -595,7 +559,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = (*this)[i] | s;
     }  //C delete right;
   return res;
@@ -628,7 +592,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    if( (*this)[i] == zero) (*res)[i] = s; else (*res)[i] = (*this)[i];
 	}
 	return res;
@@ -664,7 +628,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    if( (*this)[i] != zero) (*res)[i] = s; else (*res)[i] = zero;
 	}
 	return res;
@@ -691,7 +655,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    if( (*this)[i] == zero) (*res)[i] = s; else (*res)[i] = (*this)[i];
 	}
 	return res;
@@ -725,23 +689,13 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    if( (*this)[i] != zero) (*res)[i] = s; else (*res)[i] = zero;
 	}
 	return res;
     } 
 }
 // invalid types
-DStructGDL* DStructGDL::OrOpSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
-DStructGDL* DStructGDL::OrOpInvSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::OrOpSNew( BaseGDL* r)
 {
@@ -805,7 +759,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-		for( int i=0; i < nEl; ++i)
+		for( OMPInt i=0; i < nEl; ++i)
 			(*res)[i] = (*this)[i] ^ s;
 	}
 	return res;
@@ -817,7 +771,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
  		(*res)[i] = (*this)[i] ^ (*right)[i];
 	}
 	return res;
@@ -836,11 +790,6 @@
   throw GDLException("Cannot apply operation to datatype DOUBLE.",true,false);  
   return NULL;
 }
-DStructGDL* DStructGDL::XorOpNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::XorOpNew( BaseGDL* r)
 {
@@ -893,7 +842,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = (*this)[i] ^ s;
     }
   return res;
@@ -914,11 +863,6 @@
   return NULL;
 }
 // invalid types
-DStructGDL* DStructGDL::XorOpSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::XorOpSNew( BaseGDL* r)
 {
@@ -970,14 +914,24 @@
       return res;
     }
 
+#ifdef USE_EIGEN
+
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRight(&(*right)[0], nEl);
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRes(&(*res)[0], nEl);
+	mRes = mThis + mRight;
+	return res;
+#else
+    
   TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = (*this)[i] + (*right)[i];
     }  //C delete right;
   return res;
+#endif
 }
 
 template<class Sp>
@@ -1005,23 +959,13 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = (*right)[i] + (*this)[i];
     }  //C delete right;
   return res;
 }
 
 // invalid types
-DStructGDL* DStructGDL::AddNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
-DStructGDL* DStructGDL::AddInvNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 BaseGDL* Data_<SpDPtr>::AddNew( BaseGDL* r)
 {
@@ -1055,14 +999,24 @@
       return res;
     }
   Ty s = (*right)[0];
+#ifdef USE_EIGEN
+
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRes(&(*res)[0], nEl);
+	mRes = mThis + s;
+	return res;
+#else
+    
   TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = (*this)[i] + s;
     }  //C delete right;
   return res;
+#endif
+  
 }
 template<class Sp>
 BaseGDL* Data_<Sp>::AddInvSNew( BaseGDL* r)
@@ -1086,23 +1040,13 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = s + (*this)[i];
     }  //C delete right;
   return res;
 }
 
 // invalid types
-DStructGDL* DStructGDL::AddSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
-DStructGDL* DStructGDL::AddInvSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 BaseGDL* Data_<SpDPtr>::AddSNew( BaseGDL* r)
 {
@@ -1145,25 +1089,44 @@
   Ty s;
   if( right->StrictScalar(s)) 
     {
+#ifdef USE_EIGEN
+
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRes(&(*res)[0], nEl);
+	mRes = mThis - s;
+	return res;
+#else
       TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = (*this)[i] - s;
 	}
+  return res;
+#endif
+      
     }
   else 
     {
+#ifdef USE_EIGEN
+
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRight(&(*right)[0], nEl);
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRes(&(*res)[0], nEl);
+	mRes = mThis - mRight;
+	return res;
+#else
       TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = (*this)[i] - (*right)[i];
 	}
-    }
   return res;
+#endif
+    }
 }
 // inverse substraction: left=right-left
 template<class Sp>
@@ -1181,26 +1144,25 @@
       (*res)[0] = (*right)[0] - (*this)[0];
       return res;
     }
+#ifdef USE_EIGEN
+
+  Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+  Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRight(&(*right)[0], nEl);
+  Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRes(&(*res)[0], nEl);
+  mRes = mRight - mThis;
+  return res;
+#else
   TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = (*right)[i] - (*this)[i];
     }  
   return res;
+#endif  
 }
 // invalid types
-DStructGDL* DStructGDL::SubNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
-DStructGDL* DStructGDL::SubInvNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 BaseGDL* Data_<SpDString>::SubNew( BaseGDL* r)
 {
@@ -1253,15 +1215,24 @@
     }
   
   Ty s = (*right)[0];
+#ifdef USE_EIGEN
+
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRes(&(*res)[0], nEl);
+	mRes = mThis - s;
+	return res;
+#else
   
   TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = (*this)[i] - s;
     }
   return res;
+#endif
+  
 }
 // inverse substraction: left=right-left
 template<class Sp>
@@ -1282,26 +1253,25 @@
   Ty s = (*right)[0];
   // right->Scalar(s); 
   //  dd = s - dd;
+#ifdef USE_EIGEN
+
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRes(&(*res)[0], nEl);
+	mRes = s - mThis;
+	return res;
+#else
   TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = s - (*this)[i];
     }
   return res;
+#endif
+  
 }
 // invalid types
-DStructGDL* DStructGDL::SubSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
-DStructGDL* DStructGDL::SubInvSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 BaseGDL* Data_<SpDString>::SubSNew( BaseGDL* r)
 {
@@ -1359,17 +1329,12 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*this)[i] > (*right)[i]) (*res)[i] = (*right)[i]; else (*res)[i] = (*this)[i];
     }  //C delete right;
   return res;
 }
 // invalid types
-DStructGDL* DStructGDL::LtMarkNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::LtMarkNew( BaseGDL* r)
 {
@@ -1421,17 +1386,12 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*this)[i] > s) (*res)[i] = s; else (*res)[i] = (*this)[i];
     }  //C delete right;
   return res;
 }
 // invalid types
-DStructGDL* DStructGDL::LtMarkSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::LtMarkSNew( BaseGDL* r)
 {
@@ -1485,17 +1445,12 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*this)[i] < (*right)[i]) (*res)[i] = (*right)[i]; else (*res)[i] = (*this)[i];
     }  //C delete right;
   return res;
 }
 // invalid types
-DStructGDL* DStructGDL::GtMarkNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::GtMarkNew( BaseGDL* r)
 {
@@ -1547,17 +1502,12 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	if( (*this)[i] < s) (*res)[i] = s; else (*res)[i] = (*this)[i];
     }  ;
   return res;
 }
 // invalid types
-DStructGDL* DStructGDL::GtMarkSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::GtMarkSNew( BaseGDL* r)
 {
@@ -1609,21 +1559,26 @@
       (*res)[0] = (*this)[0] * (*right)[0];
       return res;
     }
+#ifdef USE_EIGEN
+
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRight(&(*right)[0], nEl);
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRes(&(*res)[0], nEl);
+	mRes = mThis * mRight;
+	return res;
+#else
   TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = (*this)[i] * (*right)[i];
     }  //C delete right;
   return res;
+#endif
+  
 }
 // invalid types
-DStructGDL* DStructGDL::MultNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::MultNew( BaseGDL* r)
 {
@@ -1659,21 +1614,25 @@
       return res;
     }
   Ty s = ( *right ) [0];
+#ifdef USE_EIGEN
+
+	Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRes(&(*res)[0], nEl);
+	mRes = mThis * s;
+	return res;
+#else
   TRACEOMP ( __FILE__, __LINE__ )
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for ( int i=0; i < nEl; ++i )
+      for ( OMPInt i=0; i < nEl; ++i )
 	(*res ) [i] = (*this )[i] * s;
     }
   return res;
+#endif
+  
 }
 // invalid types
-DStructGDL* DStructGDL::MultSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::MultSNew( BaseGDL* r)
 {
@@ -1724,7 +1683,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int ix=i; ix < nEl; ++ix)
+	  for( OMPInt ix=i; ix < nEl; ++ix)
 	    if( (*right)[ix] != this->zero)
 	    	(*res)[ix] = (*this)[ix] / (*right)[ix];
 	    else	
@@ -1759,7 +1718,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int ix=i; ix < nEl; ++ix)
+	  for( OMPInt ix=i; ix < nEl; ++ix)
 	    if( (*this)[ix] != this->zero)
 	      (*res)[ix] = (*right)[ix] / (*this)[ix];
 	    else
@@ -1769,16 +1728,6 @@
     }
 }
 // invalid types
-DStructGDL* DStructGDL::DivNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
-DStructGDL* DStructGDL::DivInvNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::DivNew( BaseGDL* r)
 {
@@ -1878,7 +1827,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int ix=i; ix < nEl; ++ix)
+	  for( OMPInt ix=i; ix < nEl; ++ix)
 	    if( (*this)[ix] != this->zero)
 	      (*res)[ix] = s / (*this)[ix];
 	    else 
@@ -1888,16 +1837,6 @@
     }
 }
 // invalid types
-DStructGDL* DStructGDL::DivSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
-DStructGDL* DStructGDL::DivInvSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::DivSNew( BaseGDL* r)
 {
@@ -1963,7 +1902,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int ix=i; ix < nEl; ++ix)
+	  for( OMPInt ix=i; ix < nEl; ++ix)
 	    if( (*right)[ix] != this->zero)
 	      (*res)[ix] = (*this)[ix] % (*right)[ix];
 	    else
@@ -1996,7 +1935,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int ix=i; ix < nEl; ++ix)
+	  for( OMPInt ix=i; ix < nEl; ++ix)
 	    if( (*this)[ix] != this->zero)
 	      (*res)[ix] = (*right)[ix] % (*this)[ix];
 	    else
@@ -2032,7 +1971,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
    {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = Modulo((*this)[i],(*right)[i]);
   }  
   return res;
@@ -2058,7 +1997,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = Modulo((*right)[i],(*this)[i]);
     }  
   return res;
@@ -2090,7 +2029,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = Modulo((*this)[i],(*right)[i]);
     }
   return res;
@@ -2116,22 +2055,12 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = Modulo((*right)[i],(*this)[i]);
     }  
   return res;
 }
 // invalid types
-DStructGDL* DStructGDL::ModNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
-DStructGDL* DStructGDL::ModInvNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::ModNew( BaseGDL* r)
 {
@@ -2260,7 +2189,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int ix=i; ix < nEl; ++ix)
+	  for( OMPInt ix=i; ix < nEl; ++ix)
 	    if( (*this)[ix] != this->zero)
 	      (*res)[ix] = s % (*this)[ix];
 	    else 
@@ -2289,7 +2218,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = Modulo((*this)[i],s);
     }  
   return res;
@@ -2315,7 +2244,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = Modulo(s,(*this)[i]);
     }
   return res;
@@ -2340,7 +2269,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = Modulo((*this)[i],s);
     }  
   return res;
@@ -2366,22 +2295,12 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = Modulo(s,(*this)[i]);
     }
   return res;
 }
 // invalid types
-DStructGDL* DStructGDL::ModSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
-DStructGDL* DStructGDL::ModInvSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::ModSNew( BaseGDL* r)
 
@@ -2491,7 +2410,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = pow( (*this)[i], (*right)[i]); // valarray
     }  //C delete right;
   return res;
@@ -2515,7 +2434,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = pow( (*right)[i], (*this)[i]);
     }
   return res;
@@ -2529,12 +2448,6 @@
   throw GDLException("Internal error: Data_::PowIntNew called.",true,false);
   return NULL;
 }
-DStructGDL* DStructGDL::PowIntNew( BaseGDL* r)
-{
-  assert( 0);
-  throw GDLException("Internal error: DStructGDL::PowIntNew called.",true,false);  
-  return NULL;
-}
 // floats power of value with GDL_LONG: left=left ^ right
 template<>
 Data_<SpDFloat>* Data_<SpDFloat>::PowIntNew( BaseGDL* r)
@@ -2553,7 +2466,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = pow( (*this)[i], r0);
 	}      return res;
     }
@@ -2565,7 +2478,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[ i] = pow( s0, (*right)[ i]);
 	}      return res;
     }
@@ -2576,7 +2489,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = pow( (*this)[i], (*right)[i]);
 	}      return res;
     }
@@ -2587,7 +2500,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = pow( (*this)[i], (*right)[i]);
 	}      return res;
     }
@@ -2598,7 +2511,7 @@
   DLongGDL* right=static_cast<DLongGDL*>(r);
 
   ULong rEl=right->N_Elements();
-  ULong nEl=N_Elements(); Data_* res = NewResult();
+  ULong nEl=N_Elements();
   assert( rEl);
   assert( nEl);
   if( r->StrictScalar())
@@ -2609,7 +2522,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = pow( (*this)[i], r0);
 	}      return res;
     }
@@ -2621,7 +2534,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[ i] = pow( s0, (*right)[ i]);
 	}      return res;
     }
@@ -2632,7 +2545,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = pow( (*this)[i], (*right)[i]);
 	}      return res;
     }
@@ -2643,7 +2556,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = pow( (*this)[i], (*right)[i]);
 	}      return res;
     }
@@ -2667,7 +2580,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	for( int i=0; i < nEl; ++i)
+	for( OMPInt i=0; i < nEl; ++i)
 	  (*res)[i] = pow( (*this)[i], (*right)[i]);
 	}
   return res;
@@ -2690,7 +2603,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = pow( (*right)[i], (*this)[i]);
     }  //C delete right;
   return res;
@@ -2713,7 +2626,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	for( int i=0; i < nEl; ++i)
+	for( OMPInt i=0; i < nEl; ++i)
 	  (*res)[i] = pow( (*this)[i], (*right)[i]);
 	}
   return res;
@@ -2737,7 +2650,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = pow( (*right)[i], (*this)[i]);
     }  //C delete right;
   return res;
@@ -2768,7 +2681,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		(*res)[ i] = pow( (*this)[ i], s);
 	    }	  //C delete right;
 	  return res;
@@ -2787,7 +2700,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		    {
 #pragma omp for
-		      for( int i=0; i<rEl; ++i)
+		      for( OMPInt i=0; i<rEl; ++i)
 			(*res)[ i] = pow( s, (*right)[ i]);
 		    }		  //C delete right;
 		  return res;
@@ -2799,7 +2712,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 		{
 #pragma omp for
-		  for( int i=0; i<nEl; ++i)
+		  for( OMPInt i=0; i<nEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      return res;
@@ -2812,7 +2725,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		{
 #pragma omp for
-		  for( int i=0; i<rEl; ++i)
+		  for( OMPInt i=0; i<rEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      //C delete this;
@@ -2836,7 +2749,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		(*res)[ i] = pow( (*this)[ i], s);
 	    }	  //C delete right;
 	  return res;
@@ -2855,7 +2768,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		    {
 #pragma omp for
-		      for( int i=0; i<rEl; ++i)
+		      for( OMPInt i=0; i<rEl; ++i)
 			(*res)[ i] = pow( s, (*right)[ i]);
 		    }		  //C delete right;
 		  return res;
@@ -2867,7 +2780,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 		{
 #pragma omp for
-		  for( int i=0; i<nEl; ++i)
+		  for( OMPInt i=0; i<nEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      return res;
@@ -2880,7 +2793,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		{
 #pragma omp for
-		  for( int i=0; i<rEl; ++i)
+		  for( OMPInt i=0; i<rEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      //C delete this;
@@ -2904,7 +2817,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    (*res)[ i] = pow( (*this)[ i], s);
 	}
 	return res;
@@ -2917,7 +2830,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = pow( (*this)[i], (*right)[i]);
 	}
 	return res;
@@ -2937,7 +2850,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = pow( (*right)[i], (*this)[i]);
     }
   return res;
@@ -2967,7 +2880,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		(*res)[ i] = pow( (*this)[ i], s);
 	    }
 	  return res;
@@ -2986,7 +2899,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		    {
 #pragma omp for
-		      for( int i=0; i<rEl; ++i)
+		      for( OMPInt i=0; i<rEl; ++i)
 			(*res)[ i] = pow( s, (*right)[ i]);
 		    }
 		  return res;
@@ -2998,7 +2911,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 		{
 #pragma omp for
-		  for( int i=0; i<nEl; ++i)
+		  for( OMPInt i=0; i<nEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}
 	      return res;
@@ -3011,7 +2924,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		{
 #pragma omp for
-		  for( int i=0; i<rEl; ++i)
+		  for( OMPInt i=0; i<rEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}
 	      return res;
@@ -3034,7 +2947,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		(*res)[ i] = pow( (*this)[ i], s);
 	    }
 	  return res;
@@ -3053,7 +2966,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		    {
 #pragma omp for
-		      for( int i=0; i<rEl; ++i)
+		      for( OMPInt i=0; i<rEl; ++i)
 			(*res)[ i] = pow( s, (*right)[ i]);
 		    }
 		  return res;
@@ -3065,7 +2978,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 		{
 #pragma omp for
-		  for( int i=0; i<nEl; ++i)
+		  for( OMPInt i=0; i<nEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      return res;
@@ -3078,7 +2991,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		{
 #pragma omp for
-		  for( int i=0; i<rEl; ++i)
+		  for( OMPInt i=0; i<rEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}
 	      return res;
@@ -3097,7 +3010,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    (*res)[ i] = pow( (*this)[ i], s);
 	}
 	return res;
@@ -3110,7 +3023,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = pow( (*this)[i], (*right)[i]);
 	}
 	return res;
@@ -3131,22 +3044,12 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = pow( (*right)[i], (*this)[i]);
     }
   return res;
 }
 // invalid types
-DStructGDL* DStructGDL::PowNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
-DStructGDL* DStructGDL::PowInvNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::PowNew( BaseGDL* r)
 {
@@ -3203,7 +3106,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = pow( (*this)[i], s);
     }
   //C delete right;
@@ -3228,7 +3131,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i < nEl; ++i)
+      for( OMPInt i=0; i < nEl; ++i)
 	(*res)[i] = pow( s, (*this)[i]);
     }  //C delete right;
   return res;
@@ -3257,7 +3160,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		(*res)[i] =  pow( (*this)[ i], s);
 	    }
 	  return res;
@@ -3276,7 +3179,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		    {
 #pragma omp for
-		      for( int i=0; i<rEl; ++i)
+		      for( OMPInt i=0; i<rEl; ++i)
 			(*res)[ i] = pow( s, (*right)[ i]);
 		    }
 		  return res;
@@ -3287,7 +3190,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 		{
 #pragma omp for
-		  for( int i=0; i<nEl; ++i)
+		  for( OMPInt i=0; i<nEl; ++i)
 		    (*res)[i] =  pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      return res;
@@ -3300,7 +3203,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		{
 #pragma omp for
-		  for( int i=0; i<rEl; ++i)
+		  for( OMPInt i=0; i<rEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      //C delete this;
@@ -3323,7 +3226,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		(*res)[i] =  pow( (*this)[ i], s);
 	    }	  //C delete right;
 	  return res;
@@ -3342,7 +3245,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		    {
 #pragma omp for
-		      for( int i=0; i<rEl; ++i)
+		      for( OMPInt i=0; i<rEl; ++i)
 			(*res)[ i] = pow( s, (*right)[ i]);
 		    }		  //C delete right;
 		  return res;
@@ -3353,7 +3256,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 		{
 #pragma omp for
-		  for( int i=0; i<nEl; ++i)
+		  for( OMPInt i=0; i<nEl; ++i)
 		    (*res)[i] =  pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      return res;
@@ -3366,7 +3269,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		{
 #pragma omp for
-		  for( int i=0; i<rEl; ++i)
+		  for( OMPInt i=0; i<rEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}
 	      return res;
@@ -3383,7 +3286,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	(*res)[i] =  pow( (*this)[ i], s);
     }
 
@@ -3408,7 +3311,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	(*res)[i] =  pow( s, (*this)[ i]);
     }
   return res;
@@ -3438,7 +3341,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		(*res)[i] =  pow( (*this)[ i], s);
 	    }	  
 	  return res;
@@ -3457,7 +3360,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		    {
 #pragma omp for
-		      for( int i=0; i<rEl; ++i)
+		      for( OMPInt i=0; i<rEl; ++i)
 			(*res)[ i] = pow( s, (*right)[ i]);
 		    }		
 		  return res;
@@ -3468,7 +3371,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 		{
 #pragma omp for
-		  for( int i=0; i<nEl; ++i)
+		  for( OMPInt i=0; i<nEl; ++i)
 		    (*res)[i] =  pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      return res;
@@ -3481,7 +3384,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		{
 #pragma omp for
-		  for( int i=0; i<rEl; ++i)
+		  for( OMPInt i=0; i<rEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	     
 	      return res;
@@ -3505,7 +3408,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		(*res)[i] =  pow( (*this)[ i], s);
 	    }	  
 	  return res;
@@ -3524,7 +3427,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		    {
 #pragma omp for
-		      for( int i=0; i<rEl; ++i)
+		      for( OMPInt i=0; i<rEl; ++i)
 			(*res)[ i] = pow( s, (*right)[ i]);
 		    }		  
 		  return res;
@@ -3535,7 +3438,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 		{
 #pragma omp for
-		  for( int i=0; i<nEl; ++i)
+		  for( OMPInt i=0; i<nEl; ++i)
 		    (*res)[i] =  pow( (*this)[ i], (*right)[ i]);
 		}	      //C delete right;
 	      return res;
@@ -3548,7 +3451,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl)) 
 		{
 #pragma omp for
-		  for( int i=0; i<rEl; ++i)
+		  for( OMPInt i=0; i<rEl; ++i)
 		    (*res)[ i] = pow( (*this)[ i], (*right)[ i]);
 		}	      
 	      return res;
@@ -3563,7 +3466,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	(*res)[i] =  pow( (*this)[ i], s);
     }
   return res;
@@ -3582,22 +3485,12 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	(*res)[i] =  pow( s, (*this)[ i]);
     }
   return res;
 }
 // invalid types
-DStructGDL* DStructGDL::PowSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
-DStructGDL* DStructGDL::PowInvSNew( BaseGDL* r)
-{
-  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
-  return NULL;
-}
 template<>
 Data_<SpDString>* Data_<SpDString>::PowSNew( BaseGDL* r)
 {
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/basic_op_sub.cpp gdl/src/basic_op_sub.cpp
--- gdl-0.9.3/src/basic_op_sub.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/basic_op_sub.cpp	2013-03-25 10:36:38.185970650 -0600
@@ -0,0 +1,439 @@
+/***************************************************************************
+                          basic_op_sub.cpp  -  GDL sub (-) operators
+                             -------------------
+    begin                : July 22 2002
+    copyright            : (C) 2002 by Marc Schellens
+    email                : m_schellens@users.sf.net
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+// to be included from datatypes.cpp
+#ifdef INCLUDE_BASIC_OP_CPP
+
+// // header in datatypes.hpp
+// 
+// //#include "datatypes.hpp"
+// //#include "dstructgdl.hpp"
+// //#include "arrayindex.hpp"
+// 
+// //#include <csignal>
+// #include "sigfpehandler.hpp"
+// 
+// #ifdef _OPENMP
+// #include <omp.h>
+// #endif
+// 
+// #include "typetraits.hpp"
+// 
+// using namespace std;
+
+
+// Sub
+// substraction: left=left-right
+template<class Sp>
+BaseGDL* Data_<Sp>::Sub( BaseGDL* r)
+{
+  Data_* right=static_cast<Data_*>(r);
+
+  ULong rEl=right->N_Elements();
+  ULong nEl=N_Elements();
+  assert( rEl);
+  assert( nEl);
+  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
+  if( nEl == 1)
+    {
+      (*this)[0] -= (*right)[0];
+      return this;
+    }
+#ifdef USE_EIGEN
+
+  Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+  Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRight(&(*right)[0], nEl);
+  mThis -= mRight;
+  return this;
+#else
+
+  if( nEl == rEl)
+    dd -= right->dd;
+  else
+    {
+      TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+	{
+#pragma omp for
+	  for( OMPInt i=0; i < nEl; ++i)
+	    (*this)[i] -= (*right)[i];
+	}}  //C delete right;
+  return this;
+#endif
+  
+}
+// inverse substraction: left=right-left
+template<class Sp>
+BaseGDL* Data_<Sp>::SubInv( BaseGDL* r)
+{
+  Data_* right=static_cast<Data_*>(r);
+
+  ULong rEl=right->N_Elements();
+  ULong nEl=N_Elements();
+  assert( rEl);
+  assert( nEl);
+  //  if( !rEl || !nEl) throw GDLException("Variable is undefined.");  
+  /*  if( nEl == rEl)
+      dd = right->dd - dd;
+      else*/
+  if( nEl == 1)
+    {
+      (*this)[0] = (*right)[0] - (*this)[0];
+      return this;
+    }
+#ifdef USE_EIGEN
+
+  Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+  Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRight(&(*right)[0], nEl);
+  mThis = mRight - mThis;
+  return this;
+#else
+  TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+    {
+#pragma omp for
+      for( OMPInt i=0; i < nEl; ++i)
+	(*this)[i] = (*right)[i] - (*this)[i];
+    }  //C delete right;
+  return this;
+#endif
+  
+}
+// invalid types
+template<>
+BaseGDL* Data_<SpDString>::Sub( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
+  return this;
+}
+template<>
+BaseGDL* Data_<SpDString>::SubInv( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
+  return this;
+}
+template<>
+BaseGDL* Data_<SpDPtr>::Sub( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+  return this;
+}
+template<>
+BaseGDL* Data_<SpDPtr>::SubInv( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+  return this;
+}
+template<>
+BaseGDL* Data_<SpDObj>::Sub( BaseGDL* r)
+{
+  // overload here
+  Data_* self;
+  DFun* plusOverload;
+  
+  ProgNodeP callingNode = interpreter->GetRetTree();
+
+  if( !Scalar())
+  {
+    if( r->Type() == GDL_OBJ && r->Scalar())
+    {
+      self = static_cast<Data_*>( r);
+      plusOverload = static_cast<DFun*>(GDLInterpreter::GetObjHeapOperator( (*self)[0], OOMinus));
+      if( plusOverload == NULL)
+      {
+	throw GDLException( callingNode, "Cannot apply not overloaded operator to datatype OBJECT.", true, false);
+      }
+    }
+    else
+      {
+	throw GDLException( callingNode, "Cannot apply operation to non-scalar datatype OBJECT.", true, false);
+      }
+  }
+  else
+  {
+    // Scalar()
+    self = static_cast<Data_*>( this);
+    plusOverload = static_cast<DFun*>(GDLInterpreter::GetObjHeapOperator( (*self)[0], OOMinus));
+    if( plusOverload == NULL)
+    {
+      if( r->Type() == GDL_OBJ && r->Scalar())
+      {
+	self = static_cast<Data_*>( r);
+	plusOverload = static_cast<DFun*>(GDLInterpreter::GetObjHeapOperator( (*self)[0], OOMinus));
+	if( plusOverload == NULL)
+	{
+	  throw GDLException(callingNode,"Cannot apply not overloaded operator to datatype OBJECT.",true, false);  
+	} 
+      }
+      else
+      {
+	throw GDLException( callingNode, "Cannot apply not overloaded operator to datatype OBJECT.", true, false);
+      }
+    }
+  }
+
+  assert( self->Scalar());
+  assert( plusOverload != NULL);
+
+  // hidden SELF is counted as well
+  int nParSub = plusOverload->NPar();
+  assert( nParSub >= 1); // SELF
+  if( nParSub < 3) // (SELF), LEFT, RIGHT
+  {
+    throw GDLException( callingNode, plusOverload->ObjectName() +
+		    ": Incorrect number of arguments.",
+		    false, false);
+  }
+  EnvUDT* newEnv;
+  Guard<BaseGDL> selfGuard;
+  BaseGDL* thisP;
+  // Dup() here is not optimal
+  // avoid at least for internal overload routines (which do/must not change SELF or r)
+  bool internalDSubUD = plusOverload->GetTree()->IsWrappedNode();  
+  if( internalDSubUD)  
+  {
+    thisP = this;
+    newEnv= new EnvUDT( callingNode, plusOverload, &self);
+    newEnv->SetNextParUnchecked( &thisP); // LEFT  parameter, as reference to prevent cleanup in newEnv
+    newEnv->SetNextParUnchecked( &r); // RVALUE  parameter, as reference to prevent cleanup in newEnv
+  }
+  else
+  {
+    self = self->Dup();
+    selfGuard.Init( self);
+    newEnv= new EnvUDT( callingNode, plusOverload, &self);
+    newEnv->SetNextParUnchecked( this->Dup()); // LEFT  parameter, as value
+    newEnv->SetNextParUnchecked( r->Dup()); // RIGHT parameter, as value
+  }
+
+  
+  // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+  StackGuard<EnvStackT> guard(interpreter->CallStack());
+
+  interpreter->CallStack().push_back( newEnv); 
+  
+  // make the call
+  BaseGDL* res=interpreter->call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
+
+  if( !internalDSubUD && self != selfGuard.Get())
+  {
+    // always put out warning first, in case of a later crash
+    Warning( "WARNING: " + plusOverload->ObjectName() + 
+	  ": Assignment to SELF detected (GDL session still ok).");
+    // assignment to SELF -> self was deleted and points to new variable
+    // which it owns
+    selfGuard.Release();
+    if( static_cast<BaseGDL*>(self) != NullGDL::GetSingleInstance())
+      selfGuard.Reset(self);
+  }
+  return res;
+}
+template<>
+BaseGDL* Data_<SpDObj>::SubInv( BaseGDL* r)
+{
+  if( r->Type() == GDL_OBJ && r->Scalar())
+  {
+    return r->Sub( this); // for right order of parameters
+  }
+    
+  // overload here
+  Data_* self;
+  DFun* plusOverload;
+  
+  ProgNodeP callingNode = interpreter->GetRetTree();
+
+  if( !Scalar())
+  {
+    throw GDLException( callingNode, "Cannot apply operation to non-scalar datatype OBJECT.", true, false);
+  }
+  else
+  {
+    // Scalar()
+    self = static_cast<Data_*>( this);
+    plusOverload = static_cast<DFun*>(GDLInterpreter::GetObjHeapOperator( (*self)[0], OOMinus));
+    if( plusOverload == NULL)
+    {
+	throw GDLException( callingNode, "Cannot apply not overloaded operator to datatype OBJECT.", true, false);
+    }
+  }
+
+  assert( self->Scalar());
+  assert( plusOverload != NULL);
+
+  // hidden SELF is counted as well
+  int nParSub = plusOverload->NPar();
+  assert( nParSub >= 1); // SELF
+  if( nParSub < 3) // (SELF), LEFT, RIGHT
+  {
+    throw GDLException( callingNode, plusOverload->ObjectName() +
+		    ": Incorrect number of arguments.",
+		    false, false);
+  }
+  EnvUDT* newEnv;
+  Guard<BaseGDL> selfGuard;
+  BaseGDL* thisP;
+  // Dup() here is not optimal
+  // avoid at least for internal overload routines (which do/must not change SELF or r)
+  bool internalDSubUD = plusOverload->GetTree()->IsWrappedNode();  
+  if( internalDSubUD)  
+  {
+    thisP = this;
+    newEnv= new EnvUDT( callingNode, plusOverload, &self);
+    // order different to Add
+    newEnv->SetNextParUnchecked( &r); // RVALUE  parameter, as reference to prevent cleanup in newEnv
+    newEnv->SetNextParUnchecked( &thisP); // LEFT  parameter, as reference to prevent cleanup in newEnv
+  }
+  else
+  {
+    self = self->Dup();
+    selfGuard.Init( self);
+    newEnv= new EnvUDT( callingNode, plusOverload, &self);
+    // order different to Add
+    newEnv->SetNextParUnchecked( r->Dup()); // RIGHT parameter, as value
+    newEnv->SetNextParUnchecked( this->Dup()); // LEFT  parameter, as value
+  }
+
+  
+  // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
+  StackGuard<EnvStackT> guard(interpreter->CallStack());
+
+  interpreter->CallStack().push_back( newEnv); 
+  
+  // make the call
+  BaseGDL* res=interpreter->call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
+
+  if( !internalDSubUD && self != selfGuard.Get())
+  {
+    // always put out warning first, in case of a later crash
+    Warning( "WARNING: " + plusOverload->ObjectName() + 
+	  ": Assignment to SELF detected (GDL session still ok).");
+    // assignment to SELF -> self was deleted and points to new variable
+    // which it owns
+    selfGuard.Release();
+    if( static_cast<BaseGDL*>(self) != NullGDL::GetSingleInstance())
+      selfGuard.Reset(self);
+  }
+  return res;
+}
+template<class Sp>
+Data_<Sp>* Data_<Sp>::SubS( BaseGDL* r)
+{
+  Data_* right=static_cast<Data_*>(r);
+
+  ULong nEl=N_Elements();
+  assert( nEl);
+  if( nEl == 1)
+    {
+      (*this)[0] -= (*right)[0];
+      return this;
+    }
+  
+  Ty s = (*right)[0];
+  // right->Scalar(s); 
+  //  dd -= s;
+#ifdef USE_EIGEN
+
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+	mThis -= s;
+	return this;
+#else
+  TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+    {
+#pragma omp for
+      for( OMPInt i=0; i < nEl; ++i)
+	(*this)[i] -= s;
+    }  //C delete right;
+  return this;
+#endif
+  
+}
+// inverse substraction: left=right-left
+template<class Sp>
+Data_<Sp>* Data_<Sp>::SubInvS( BaseGDL* r)
+{
+  Data_* right=static_cast<Data_*>(r);
+
+  ULong nEl=N_Elements();
+  assert( nEl);
+
+  if( nEl == 1)
+    {
+      (*this)[0] = (*right)[0] - (*this)[0];
+      return this;
+    }
+  
+  Ty s = (*right)[0];
+  // right->Scalar(s); 
+  //  dd = s - dd;
+#ifdef USE_EIGEN
+
+        Eigen::Map<Eigen::Array<Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mThis(&(*this)[0], nEl);
+	mThis = s - mThis;
+	return this;
+#else
+  TRACEOMP( __FILE__, __LINE__)
+#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+    {
+#pragma omp for
+      for( OMPInt i=0; i < nEl; ++i)
+	(*this)[i] = s - (*this)[i];
+    }  //C delete right;
+  return this;
+#endif
+  
+}
+// invalid types
+template<>
+Data_<SpDString>* Data_<SpDString>::SubS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDString>* Data_<SpDString>::SubInvS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRING.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::SubS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDPtr>* Data_<SpDPtr>::SubInvS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype PTR.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDObj>* Data_<SpDObj>::SubS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
+  return this;
+}
+template<>
+Data_<SpDObj>* Data_<SpDObj>::SubInvS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype OBJECT.",true,false);  
+  return this;
+}
+
+
+#endif
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/basic_pro.cpp gdl/src/basic_pro.cpp
--- gdl-0.9.3/src/basic_pro.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/basic_pro.cpp	2013-05-16 12:36:33.146858167 -0600
@@ -241,6 +241,51 @@
   {
     bool kw = false;
 
+    static int sourceFilesKWIx = e->KeywordIx("SOURCE_FILES");
+    bool sourceFilesKW = e->KeywordPresent( sourceFilesKWIx);
+    if( sourceFilesKW)
+    {
+	deque<string> sourceFiles;
+
+	for(FunListT::iterator i=funList.begin(); i != funList.end(); ++i)
+	{
+	    string funFile = (*i)->GetFilename();
+	    bool alreadyInList = false;
+	    for(deque<string>::iterator i2=sourceFiles.begin(); i2 != sourceFiles.end(); ++i2)
+	    {
+		if( funFile == *i2)
+		{
+		  alreadyInList = true;
+		  break;
+		}
+	    }
+	    if( !alreadyInList)
+	      sourceFiles.push_back(funFile);
+	}
+	for(ProListT::iterator i=proList.begin(); i != proList.end(); ++i)
+	{
+	    string proFile = (*i)->GetFilename();
+	    bool alreadyInList = false;
+	    for(deque<string>::iterator i2=sourceFiles.begin(); i2 != sourceFiles.end(); ++i2)
+	    {
+		if( proFile == *i2)
+		{
+		  alreadyInList = true;
+		  break;
+		}
+	    }
+	    if( !alreadyInList)
+	      sourceFiles.push_back(proFile);
+	}
+	// sourceFiles now contains a uniqe list of all file names.
+	sort( sourceFiles.begin(), sourceFiles.end());
+
+      	SizeT nSourceFiles = sourceFiles.size();
+	cout << "Source files (" << nSourceFiles <<"):" << endl;
+	for( SizeT i = 0; i<nSourceFiles; ++i)
+	  cout << sourceFiles[ i] << endl;
+    }
+    
     static int callsKWIx = e->KeywordIx("CALLS");
     bool callsKW = e->KeywordPresent( callsKWIx);
     if( callsKW)
@@ -325,7 +370,7 @@
       }
 
     // internal library functions
-    bool kwLibInternal = e->KeywordSet( "LIB_GDL_INTERNAL"); 
+    bool kwLibInternal = e->KeywordSet( "INTERNAL_LIB_GDL"); 
     if( kwLibInternal)
       {
 	kw = true;
@@ -1032,7 +1077,7 @@
 	// make the call
 // 	EnvT* newEnv = static_cast<EnvT*>(e->Interpreter()->CallStack().back());
 	EnvT* newEnv = e->NewEnv( libProList[ proIx], 1);
-	auto_ptr<EnvT> guard( newEnv);
+	Guard<EnvT> guard( newEnv);
 	static_cast<DLibPro*>(newEnv->GetPro())->Pro()(newEnv);
       }
     else
@@ -1218,14 +1263,14 @@
 	" Unit: "+i2s( lun)+", File: "+fileUnits[ lun-1].Name();
       
       if( !errorKeyword)
-	throw GDLIOException( e->CallingNode(), errorMsg);
+	throw GDLIOException( ex.ErrorCode(), e->CallingNode(), errorMsg);
       
       BaseGDL** err = &e->GetKW( errorIx);
       
-      GDLDelete((*err)); 
+      GDLDelete(*err); 
 //    if( *err != e->Caller()->Object()) delete (*err); 
       
-      *err = new DLongGDL( 1);
+      *err = new DLongGDL( ex.ErrorCode());
       return;
     }
 
@@ -1677,11 +1722,11 @@
 
   void catch_pro( EnvT* e)
   {
-    static bool warned = false;
-    if (!warned) {
-      Warning("CATCH: feature not implemented yet (FIXME!).");
-      warned = true;
-    }
+//     static bool warned = false;
+//     if (!warned) {
+//       Warning("CATCH: feature not implemented yet (FIXME!).");
+//       warned = true;
+//     }
     e->Catch();
   }
 
@@ -1709,7 +1754,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-    for( int i=0; i<nEl; ++i)
+    for( OMPInt i=0; i<nEl; ++i)
 	StrPut((*dest)[ i], source, pos);
 }
   }
@@ -1827,8 +1872,6 @@
   {
     SizeT nParam = e->NParam();
 
-    if( nParam == 0) return;
-
     static int continueIx = e->KeywordIx( "CONTINUE");
     static int infoIx = e->KeywordIx( "INFORMATIONAL");
     static int ioerrorIx = e->KeywordIx( "IOERROR");
@@ -1845,6 +1888,34 @@
     bool noprint = e->KeywordSet( noprintIx);
     bool reset = e->KeywordSet( resetIx);
 
+    if( reset)
+    {
+      DStructGDL* errorState = SysVar::Error_State();
+      static unsigned nameTag = errorState->Desc()->TagIndex( "NAME");
+      static unsigned blockTag = errorState->Desc()->TagIndex( "BLOCK");
+      static unsigned codeTag = errorState->Desc()->TagIndex( "CODE");
+      static unsigned rangeTag = errorState->Desc()->TagIndex( "RANGE");
+      static unsigned sys_code_typeTag = errorState->Desc()->TagIndex( "SYS_CODE_TYPE");
+      static unsigned msgTag = errorState->Desc()->TagIndex( "MSG");
+      static unsigned sys_msgTag = errorState->Desc()->TagIndex( "SYS_MSG");
+      static unsigned msg_prefixTag = errorState->Desc()->TagIndex( "MSG_PREFIX");
+
+      (*static_cast<DStringGDL*>( errorState->GetTag( nameTag)))[0] = "IDL_M_SUCCESS";
+      (*static_cast<DStringGDL*>( errorState->GetTag( blockTag)))[0] = "IDL_MBLK_CORE";
+      (*static_cast<DLongGDL*>( errorState->GetTag( codeTag)))[0] = 0;
+      (*static_cast<DLongGDL*>( errorState->GetTag( rangeTag)))[0] = 0;
+      (*static_cast<DLongGDL*>( errorState->GetTag( rangeTag)))[1] = 0;
+      (*static_cast<DStringGDL*>( errorState->GetTag( sys_code_typeTag)))[0] = "";
+      (*static_cast<DStringGDL*>( errorState->GetTag( msgTag)))[0] = "";
+      (*static_cast<DStringGDL*>( errorState->GetTag( sys_msgTag)))[0] = "";
+      (*static_cast<DStringGDL*>( errorState->GetTag( msg_prefixTag)))[0] = "% ";
+      
+      SysVar::SetErr_String( "");     
+      SysVar::SetErrError( 0);
+    }
+    
+    if( nParam == 0) return;
+
     DString msg;
     e->AssureScalarPar<DStringGDL>( 0, msg);
 
@@ -1854,10 +1925,13 @@
     if( !info)
       {
 	DStructGDL* errorState = SysVar::Error_State();
+	static unsigned codeTag = errorState->Desc()->TagIndex( "CODE");
+	(*static_cast<DLongGDL*>( errorState->GetTag( codeTag)))[0] = 0;
 	static unsigned msgTag = errorState->Desc()->TagIndex( "MSG");
 	(*static_cast<DStringGDL*>( errorState->GetTag( msgTag)))[0] = msg;
 	
 	SysVar::SetErr_String( msg);
+	SysVar::SetErrError( -1);
       }
 	
     if( noprint)
@@ -1998,47 +2072,6 @@
 	  swapSz = 4;
 
  	byteorderDo( e, par, swapSz, p);
-
-/*	if( par->Type() == GDL_STRING)
-	  e->Throw( "STRING type not allowed in this context: "+e->GetParString(p));		    
-	if( par->Type() == GDL_OBJ)
-	  e->Throw( "Object type not allowed in this context: "+e->GetParString(p));		    
-	if( par->Type() == GDL_PTR)
-	  e->Throw( "PTR type not allowed in this context: "+e->GetParString(p));		    
-	if( par->Type() == GDL_STRUCT)
-	{
-		if( static_cast<DStructGDL*>( par)->Desc()->ContainsStringPtrObject())
-		  e->Throw( "Structs must not contain PTR, OBJECT or STRING tags: "+e->GetParString(p));		    
-
-		if( par->N_Elements() == 1)
-			{
-				DStructGDL* dS = static_cast<DStructGDL*>(par);
-				for( SizeT t=0; t<dS->NTags(); ++t)
-				{
-					BaseGDL* actTag = dS->GetTag( t);
-				}
-			}
-	}
-	//  e->Throw( "PTR type not allowed in this context: "+e->GetParString(p));		    
-	
-	SizeT nBytes = par->NBytes();
-	if( nBytes % swapSz != 0)
-	  e->Throw( "Operand's size must be a multiple of swap "
-		    "datum size: " + e->GetParString(p));		    
-	    
-	SizeT nSwap = nBytes / swapSz;
-
-	char* addr = static_cast<char*>(par->DataAddr());
-
-	for( SizeT i=0; i<nSwap; ++i)
-	  {
-	    for( SizeT s=0; s < (swapSz/2); ++s)
-	      {
-		char tmp = *(addr+i*swapSz+s);
-		*(addr+i*swapSz+s) = *(addr+i*swapSz+swapSz-1-s);
-		*(addr+i*swapSz+swapSz-1-s) = tmp;
-	      }
-	  }*/
       }
   }
 
@@ -2440,7 +2473,7 @@
 		    e->GetParString(2));
 	
 	SizeT d1;
-	int ret = p2->Scalar2index( d1);
+	int ret = p2->Scalar2Index( d1);
 	if( d1 < 1 || d1 > p0->Rank())
 	  e->Throw( "D1 (3rd) argument is out of range: "+
 		    e->GetParString(2));
@@ -2461,7 +2494,7 @@
 	    if( !p4->StrictScalar())
 	      e->Throw( "Expression must be a scalar in this context: "+
 		        e->GetParString(4));
-	    ret = p4->Scalar2index( d2);
+	    ret = p4->Scalar2Index( d2);
 	    if( d2 < 1 || d2 > p0->Rank())
 	      e->Throw( "D5 (5th) argument is out of range: "+
 		        e->GetParString(4));
@@ -2470,7 +2503,7 @@
 	  }
 
 // 	ArrayIndexVectorT* ixList = new ArrayIndexVectorT();
-// 	auto_ptr< ArrayIndexVectorT> ixList_guard( ixList);
+// 	Guard< ArrayIndexVectorT> ixList_guard( ixList);
 	ArrayIndexVectorT ixList; 
 // 	BaseGDL* loc1 = p3->Dup();
 // 	loc1->SetDim (dimension( loc1->N_Elements()));
@@ -2484,7 +2517,7 @@
 	    ixList.push_back( new CArrayIndexScalar( (*p3)[ i]));//p3->NewIx(i)));
 	ArrayIndexListT* ixL;
 	MakeArrayIndex( &ixList, &ixL);
-	auto_ptr< ArrayIndexListT> ixL_guard( ixL);
+	Guard< ArrayIndexListT> ixL_guard( ixL);
 	ixL->AssignAt( p0, p1);
 	return;
       }
Only in gdl-0.9.3/src: .#basic_pro.cpp.1.103
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/basic_pro_jmg.cpp gdl/src/basic_pro_jmg.cpp
--- gdl-0.9.3/src/basic_pro_jmg.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/basic_pro_jmg.cpp	2013-03-21 14:04:04.286825597 -0600
@@ -386,7 +386,7 @@
 		);
 	    }
 
-	    if (IsNumericType[pType]) {
+	    if (NumericType(pType)) {
 		if (par->Sizeof() > sizeof(void*)) {
 		    e->Throw("Parameter is larger than pointer: "
 			     + e->GetParString(i)
@@ -407,7 +407,7 @@
 	    argv[i-2] = (void*) par;
 	}
 	else {					// By reference (default)
-	    if (IsNumericType[pType] || pType == GDL_PTR || pType == GDL_OBJ ) {
+	    if (NumericType(pType) || pType == GDL_PTR || pType == GDL_OBJ ) {
 		argv[i-2] = (void*) par->DataAddr();
 	    }
 	    else if (pType == GDL_STRING) {
@@ -606,7 +606,7 @@
 		SizeT sizeOf;
 		void* source;
 		int   doFree = 0;
-		if (IsNumericType[pType] || pType == GDL_PTR || pType == GDL_OBJ) {
+		if (NumericType(pType) || pType == GDL_PTR || pType == GDL_OBJ) {
 		    source = (void*) member->DataAddr();
 		    length = member->NBytes();
 		    sizeOf = member->Sizeof();
@@ -658,7 +658,7 @@
 		SizeT length;
 		SizeT sizeOf;
 		void* dest;
-		if (IsNumericType[pType]) {
+		if (NumericType(pType)) {
 		    sizeOf = member->Sizeof();
 		}
 		else {
@@ -670,7 +670,7 @@
 		    p += space;
 		}
 
-		if (IsNumericType[pType] || pType == GDL_PTR || pType == GDL_OBJ) {
+		if (NumericType(pType) || pType == GDL_PTR || pType == GDL_OBJ) {
 		    length = member->NBytes();
 		    dest   = (void*) member->DataAddr();
 		    memcpy(dest, p, length);
@@ -709,7 +709,7 @@
 	for (SizeT iTag=0; iTag < nTags; iTag++) {
 	    BaseGDL* member = s->GetTag(iTag);
 	    DType    pType  = member->Type();
-	    if (IsNumericType[pType] || pType == GDL_PTR || pType == GDL_OBJ) {
+	    if (NumericType(pType) || pType == GDL_PTR || pType == GDL_OBJ) {
 		totalSize += member->NBytes();
 		sizeOf    =  member->Sizeof();
 	    }
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/CFMTLexer.cpp gdl/src/CFMTLexer.cpp
--- gdl-0.9.3/src/CFMTLexer.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/CFMTLexer.cpp	2013-03-21 14:04:03.940827197 -0600
@@ -1,6 +1,7 @@
 /* $ANTLR 2.7.7 (20110618): "cformat.g" -> "CFMTLexer.cpp"$ */
 
 #include "includefirst.hpp"
+#include <cstdlib>
 
 #include "CFMTLexer.hpp"
 #include <antlr/CharBuffer.hpp>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/cformat.g gdl/src/cformat.g
--- gdl-0.9.3/src/cformat.g	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/cformat.g	2013-03-21 14:04:04.287825593 -0600
@@ -17,6 +17,7 @@
 
 header "pre_include_cpp" {
 #include "includefirst.hpp"
+#include <cstdlib>
 }
 
 header {
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/CMakeLists.txt gdl/src/CMakeLists.txt
--- gdl-0.9.3/src/CMakeLists.txt	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/CMakeLists.txt	2013-05-16 12:36:32.958858842 -0600
@@ -199,6 +199,7 @@
 plotting_plot.cpp
 plotting_plots.cpp
 plotting_polyfill.cpp
+plotting_shade_surf.cpp
 plotting_surface.cpp
 plotting_windows.cpp
 plotting_xyouts.cpp
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/convert2.cpp gdl/src/convert2.cpp
--- gdl-0.9.3/src/convert2.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/convert2.cpp	2013-03-21 14:04:04.289825584 -0600
@@ -447,7 +447,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=i2s((*this)[i],8);
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -617,7 +617,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=i2s((*this)[i],8);
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -790,7 +790,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=i2s((*this)[i],12);
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -963,7 +963,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=i2s((*this)[i],12);
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -1034,7 +1034,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
 	  (*dest)[i]=Real2DByte<float>((*this)[i]); 
 }	//(*dest)[i]=Real2DByte((*this)[i]); 
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -1055,7 +1055,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=Real2Int<DInt,float>((*this)[i]); 
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -1096,7 +1096,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=Real2Int<DLong,float>((*this)[i]); 
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -1139,7 +1139,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=Real2Int<DLong64,float>((*this)[i]); 
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -1187,7 +1187,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=float2string((*this)[i]);
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -1259,7 +1259,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
 	  (*dest)[i]=Real2DByte<double>((*this)[i]); 
 	  //(*dest)[i]=Double2DByte((*this)[i]); 
 }
@@ -1282,7 +1282,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=Real2Int<DInt,double>((*this)[i]); 
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -1325,7 +1325,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=Real2Int<DLong,double>((*this)[i]); 
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -1368,7 +1368,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=Real2Int<DLong64,double>((*this)[i]); 
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -1416,7 +1416,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) 
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=double2string((*this)[i]);
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -1502,7 +1502,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
 	  {
 	    SizeT basePtr = i*maxLen;
 
@@ -1521,7 +1521,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared( errorFlag, mode)
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  {
       	    const char* cStart=(*this)[i].c_str();
       	    char* cEnd;
@@ -1550,7 +1550,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared( errorFlag, mode)
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  {
       	    const char* cStart=(*this)[i].c_str();
       	    char* cEnd;
@@ -1579,7 +1579,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared( errorFlag, mode)
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  {
       	    const char* cStart=(*this)[i].c_str();
       	    char* cEnd;
@@ -1608,7 +1608,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared( errorFlag, mode)
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  {
       	    const char* cStart=(*this)[i].c_str();
       	    char* cEnd;
@@ -1637,7 +1637,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared( errorFlag, mode)
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  {
       	    const char* cStart=(*this)[i].c_str();
       	    char* cEnd;
@@ -1666,7 +1666,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared( errorFlag, mode)
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  {
       	    const char* cStart=(*this)[i].c_str();
       	    char* cEnd;
@@ -1695,7 +1695,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared( errorFlag, mode)
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  {
       	    const char* cStart=(*this)[i].c_str();
       	    char* cEnd;
@@ -1724,7 +1724,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared( errorFlag, mode)
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  {
       	    const char* cStart=(*this)[i].c_str();
 	    char* cEnd;
@@ -1754,7 +1754,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared( errorFlag, mode)
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  {
       	    const char* cStart=(*this)[i].c_str();
       	    char* cEnd;
@@ -1784,7 +1784,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl)) shared( errorFlag, mode)
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  {
       	    const char* cStart=(*this)[i].c_str();
       	    char* cEnd;
@@ -1846,7 +1846,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=Real2DByte<float>(real((*this)[i])); 
 }	//(*dest)[i]=Real2DByte(real((*this)[i])); 
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -1868,7 +1868,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-    	for( int i=0; i < nEl; ++i)
+    	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=Real2Int<DInt,float>(real((*this)[i])); 
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -1911,7 +1911,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=Real2Int<DLong,float>(real((*this)[i])); 
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -1954,7 +1954,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=Real2Int<DLong64,float>(real((*this)[i])); 
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -2030,7 +2030,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]="("+i2s(real((*this)[i]))+","+i2s(imag((*this)[i]))+")";
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -2090,7 +2090,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=Real2DByte<double>(real((*this)[i])); 
 }      	  //(*dest)[i]=Double2DByte(real((*this)[i])); 
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -2112,7 +2112,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=Real2Int<DInt,double>(real((*this)[i])); 
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -2155,7 +2155,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=Real2Int<DLong,double>(real((*this)[i])); 
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -2198,7 +2198,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=Real2Int<DLong64,double>(real((*this)[i])); 
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
 }
@@ -2274,7 +2274,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]="("+i2s(real((*this)[i]))+","+i2s(imag((*this)[i]))+")";
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -2445,7 +2445,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=i2s((*this)[i],22);
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
@@ -2617,7 +2617,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-      	for( int i=0; i < nEl; ++i)
+      	for( OMPInt i=0; i < nEl; ++i)
       	  (*dest)[i]=i2s((*this)[i],22);
 }
 	if( (mode & BaseGDL::CONVERT) != 0) delete this;
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/convol.opt.cpp gdl/src/convol.opt.cpp
--- gdl-0.9.3/src/convol.opt.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/convol.opt.cpp	2004-12-09 08:10:19.000000000 -0700
@@ -0,0 +1,682 @@
+/***************************************************************************
+                          convol.cpp  -  convol function
+                             -------------------
+    begin                : Sep 19 2004
+    copyright            : (C) 2004 by Marc Schellens
+    email                : m_schellens@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+// optimized version
+
+// to be included from datatypes.cpp (twice)
+#ifdef INCLUDE_CONVOL_CPP
+
+#ifndef CONVOL_COMMON__
+#define CONVOL_COMMON__
+
+// common used functions
+
+#endif //#define CONVOL_COMMON__
+
+#ifdef CONVOL_BYTE__
+template<>
+BaseGDL* Data_<SpDByte>::Convol( BaseGDL* kIn, BaseGDL* scaleIn, 
+				 bool center, int edgeMode)
+{
+  Data_<SpDInt>* kernel = static_cast<Data_<SpDInt>*>( kIn);
+  DInt scale = (*static_cast<Data_<SpDInt>*>( scaleIn))[0];
+  // the result to be returned
+  Data_* res = New( dim, BaseGDL::ZERO);
+  DInt* ker = static_cast<DInt*>( kernel->DataAddr());
+#else
+template<class Sp>
+BaseGDL* Data_<Sp>::Convol( BaseGDL* kIn, BaseGDL* scaleIn, 
+			    bool center, int edgeMode)
+{
+  Data_* kernel = static_cast<Data_*>( kIn);
+  Ty scale = static_cast<Data_*>( scaleIn)->dd[0];
+  // the result to be returned
+  Data_* res = New( dim, BaseGDL::ZERO);
+  Ty* ker = &kernel->dd[0];
+#endif
+  if( scale == zero) scale = 1;
+
+  SizeT nA = N_Elements();
+  SizeT nK = kernel->N_Elements();
+
+  // general case (look at kernel rank == 1 later)
+  SizeT nDim = Rank(); // number of dimension to run over
+
+  SizeT kStride[MAXRANK+1];
+  kernel->Dim().Stride( kStride, nDim);
+
+  // setup kIxArr[ nDim * nK] the offset array
+  // this handles center
+  long* kIxArr = new long[ nDim * nK];
+  ArrayGuard<long> kIxArrGuard( kIxArr); // guard it
+  for( SizeT k=0; k<nK; ++k)
+    {
+      kIxArr[ k * nDim + 0] = -(k % kernel->Dim( 0));
+      if( center) kIxArr[ k * nDim + 0] = -(kIxArr[ k * nDim + 0] + 
+					    kernel->Dim( 0) / 2);
+      for( SizeT kSp=1; kSp<nDim; ++kSp)
+	{
+	  SizeT kDim = kernel->Dim( kSp);
+	  if( kDim == 0) kDim = 1;
+	  kIxArr[ k * nDim + kSp] = -((k / kStride[kSp]) % kDim);
+	  if( center) kIxArr[ k * nDim + kSp] = -(kIxArr[ k * nDim + kSp] + 
+						  kDim / 2);
+	}
+    }
+
+  SizeT  aStride[ MAXRANK + 1];
+  dim.Stride( aStride, nDim);
+
+  long  aInitIx[ MAXRANK+1];
+  for( SizeT aSp=0; aSp<=nDim; ++aSp) aInitIx[ aSp] = 0;
+
+  bool  regArr[ MAXRANK];
+
+  long  aBeg[ MAXRANK];
+  long  aEnd[ MAXRANK];
+  for( SizeT aSp=0; aSp<nDim; ++aSp) 
+    {
+      aBeg[ aSp] = (center) ? kernel->Dim(aSp)/2 : kernel->Dim(aSp)-1; // >= 
+      regArr[ aSp] = !aBeg[ aSp];
+      aEnd[ aSp] = (center) ? dim[aSp]-(kernel->Dim(aSp)-1)/2 : dim[aSp]; // <
+      // cout << "aEnd[" << aSp << "]=" << aEnd[ aSp] << endl;
+    }
+
+  Ty* ddP = &dd[0];
+
+  // some loop constants
+  SizeT dim0 = dim[0];
+  SizeT dim0_1 = dim0 - 1;
+  SizeT dim0_aEnd0 = dim0 - aEnd[0];
+  SizeT kDim0 = kernel->Dim( 0);
+  SizeT	kDim0_nDim = kDim0 * nDim;
+
+  // for all result elements
+  for( SizeT a=0; a<nA; ++aInitIx[1])
+    {
+      bool regular = true;
+      for( SizeT aSp=1; aSp<nDim;)
+	{
+	  if( aInitIx[ aSp] < dim[ aSp])
+	    {
+	      regArr[ aSp] = 
+		aInitIx[aSp] >= aBeg[aSp] && aInitIx[aSp] < aEnd[ aSp];
+
+	      if( regular)
+		for(; aSp<nDim; ++aSp)
+		  if( !regArr[ aSp])
+		    {
+		      regular = false; 
+		      break;
+		    }
+	      break;
+	    }
+
+	  aInitIx[ aSp] = 0;
+	  regArr[ aSp] = !aBeg[ aSp];
+	  if( aBeg[ aSp]) regular = false; 
+	  
+	  ++aInitIx[ ++aSp];
+	}
+
+      if( regular)
+	{
+	  if( edgeMode == 1) //edge_wrap
+	    {
+	      // 0-dim beginning
+	      for( long aInitIx0 = 0; aInitIx0 < aBeg[0]; ++aInitIx0, ++a)
+		{
+#ifdef CONVOL_BYTE__
+		  DInt res_a = 0;
+#else
+		  Ty& res_a = (*res)[ a];
+#endif
+		  long m_aInitIx0 = -aInitIx0;
+		  long* kIx = kIxArr;
+		  for( SizeT k=0; k<nK; ++k)
+		    {
+		      SizeT aLonIx;
+		      if( kIx[0] < m_aInitIx0)
+			aLonIx = aInitIx0 + kIx[0] + dim0;
+		      else
+			aLonIx = aInitIx0 + kIx[0];
+
+		      for( SizeT rSp=1; rSp<nDim; ++rSp)
+			aLonIx += (aInitIx[ rSp] + kIx[ rSp]) * aStride[ rSp];
+
+		      res_a += ddP[ aLonIx] * ker[ k]; 
+
+		      kIx += nDim;
+		    }
+
+		  res_a /= scale;
+
+#ifdef CONVOL_BYTE__
+		  if( res_a > 0) 
+		    if( res_a < 255)
+		      (*res)[ a] = res_a;
+		    else
+		      (*res)[ a] = 255;
+		  else
+		    (*res)[ a] = 0;
+#endif
+		}
+	    }
+	  else if( edgeMode == 2) //edge_truncate
+	    {
+	      // 0-dim beginning
+	      for( long aInitIx0 = 0; aInitIx0 < aBeg[0]; ++aInitIx0, ++a)
+		{
+#ifdef CONVOL_BYTE__
+		  DInt res_a = 0;
+#else
+		  Ty& res_a = (*res)[ a];
+#endif
+		  long m_aInitIx0 = -aInitIx0;
+		  long* kIx = kIxArr;
+		  for( SizeT k=0; k<nK; ++k)
+		    {
+		      SizeT aLonIx;
+		      if( kIx[0] < m_aInitIx0)
+			aLonIx = 0;
+		      else
+			aLonIx = aInitIx0 + kIx[0];
+
+		      for( SizeT rSp=1; rSp<nDim; ++rSp)
+			aLonIx += (aInitIx[ rSp] + kIx[ rSp]) * aStride[ rSp];
+
+		      res_a += ddP[ aLonIx] * ker[ k]; 
+		  
+		      kIx += nDim;
+		    }
+
+		  res_a /= scale;
+
+#ifdef CONVOL_BYTE__
+		  if( res_a > 0) 
+		    if( res_a < 255)
+		      (*res)[ a] = res_a;
+		    else
+		      (*res)[ a] = 255;
+		  else
+		    (*res)[ a] = 0;
+#endif
+		}
+	    }
+	  else { a += aBeg[0];} // update a
+
+//   	  // 0-dim regular 
+// 	  for( long aInitIx0 = aBeg[0]; aInitIx0 < aEnd[0]; ++aInitIx0, ++a)
+// 	    {
+// #ifdef CONVOL_BYTE__
+// 	      DInt res_a = 0;
+// #else
+// 	      Ty& res_a = (*res)[ a];
+// #endif
+// 	      long* kIx = kIxArr;
+// 	      for( SizeT k=0; k<nK; ++k)
+// 		{
+// 		  SizeT aLonIx = aInitIx0 + kIx[0];
+// 		  for( SizeT rSp=1; rSp<nDim; ++rSp)
+// 		    aLonIx += (aInitIx[ rSp] + kIx[ rSp]) * aStride[ rSp];
+
+// 		  res_a += ddP[ aLonIx] * ker[ k]; 
+		  
+// 		  kIx += nDim;
+// 		}
+
+// 	      res_a /= scale;
+
+// #ifdef CONVOL_BYTE__
+// 	      if( res_a > 0) 
+// 		if( res_a < 255)
+// 		  (*res)[ a] = res_a;
+// 		else
+// 		  (*res)[ a] = 255;
+// 	      else
+// 		(*res)[ a] = 0;
+// #endif
+// 	    }
+
+
+  	  // 0-dim regular 
+	  if( center)
+	    {
+	  for( long aInitIx0 = aBeg[0]; aInitIx0 < aEnd[0]; ++aInitIx0, ++a)
+	    {
+#ifdef CONVOL_BYTE__
+	      DInt res_a = 0;
+#else
+	      Ty& res_a = (*res)[ a];
+#endif
+
+	      long* kIx = kIxArr;
+	      for( SizeT k=0; k<nK; k+=kDim0)
+		{
+		  SizeT aLonIx = aInitIx0 + kIx[0];
+		  for( SizeT rSp=1; rSp<nDim; ++rSp)
+		    aLonIx += (aInitIx[ rSp] + kIx[ rSp]) * aStride[ rSp];
+
+		  for( SizeT k0=0; k0<kDim0; ++k0)
+		    res_a += ddP[ aLonIx+k0] * ker[ k+k0]; 
+
+		  kIx += kDim0_nDim;
+		}
+
+	      res_a /= scale;
+
+#ifdef CONVOL_BYTE__
+	      if( res_a > 0) 
+		if( res_a < 255)
+		  (*res)[ a] = res_a;
+		else
+		  (*res)[ a] = 255;
+	      else
+		(*res)[ a] = 0;
+#endif
+	    }
+	    }
+	  else
+	    {
+	  for( long aInitIx0 = aBeg[0]; aInitIx0 < aEnd[0]; ++aInitIx0, ++a)
+	    {
+#ifdef CONVOL_BYTE__
+	      DInt res_a = 0;
+#else
+	      Ty& res_a = (*res)[ a];
+#endif
+
+	      long* kIx = kIxArr;
+	      for( SizeT k=0; k<nK; k+=kDim0)
+		{
+		  SizeT aLonIx = aInitIx0 + kIx[0];
+		  for( SizeT rSp=1; rSp<nDim; ++rSp)
+		    aLonIx += (aInitIx[ rSp] + kIx[ rSp]) * aStride[ rSp];
+
+		  for( SizeT k0=0; k0<kDim0; ++k0)
+		    res_a += ddP[ aLonIx-k0] * ker[ k+k0]; 
+
+		  kIx += kDim0_nDim;
+		}
+
+	      res_a /= scale;
+
+#ifdef CONVOL_BYTE__
+	      if( res_a > 0) 
+		if( res_a < 255)
+		  (*res)[ a] = res_a;
+		else
+		  (*res)[ a] = 255;
+	      else
+		(*res)[ a] = 0;
+#endif
+	    }
+	    }
+
+
+
+	  if( edgeMode == 1) //edge_wrap
+	    {
+	      // 0-dim end
+	      for( long aInitIx0 = aEnd[0]; aInitIx0 < dim0; ++aInitIx0, ++a)
+		{
+#ifdef CONVOL_BYTE__
+		  DInt res_a = 0;
+#else
+		  Ty& res_a = (*res)[ a];
+#endif
+		  long* kIx = kIxArr;
+		  for( SizeT k=0; k<nK; ++k)
+		    {
+		      SizeT aLonIx = aInitIx0 + kIx[0];
+		      if( aLonIx >= dim0) aLonIx -= dim0;
+		      for( SizeT rSp=1; rSp<nDim; ++rSp)
+			aLonIx += (aInitIx[ rSp] + kIx[ rSp]) * aStride[ rSp];
+
+		      res_a += ddP[ aLonIx] * ker[ k]; 
+		  
+		      kIx += nDim;
+		    }
+
+		  res_a /= scale;
+
+#ifdef CONVOL_BYTE__
+		  if( res_a > 0) 
+		    if( res_a < 255)
+		      (*res)[ a] = res_a;
+		    else
+		      (*res)[ a] = 255;
+		  else
+		    (*res)[ a] = 0;
+#endif
+		}
+
+	    }
+	  else if( edgeMode == 2) //edge_truncate
+	    {
+	      // 0-dim end
+	      for( long aInitIx0 = aEnd[0]; aInitIx0 < dim0; ++aInitIx0, ++a)
+		{
+#ifdef CONVOL_BYTE__
+		  DInt res_a = 0;
+#else
+		  Ty& res_a = (*res)[ a];
+#endif
+		  long* kIx = kIxArr;
+		  for( SizeT k=0; k<nK; ++k)
+		    {
+		      SizeT aLonIx = aInitIx0 + kIx[0];
+		      if( aLonIx >= dim0) aLonIx = dim0_1;
+		      for( SizeT rSp=1; rSp<nDim; ++rSp)
+			aLonIx += (aInitIx[ rSp] + kIx[ rSp]) * aStride[ rSp];
+
+		      res_a += ddP[ aLonIx] * ker[ k]; 
+		  
+		      kIx += nDim;
+		    }
+
+		  res_a /= scale;
+
+#ifdef CONVOL_BYTE__
+		  if( res_a > 0) 
+		    if( res_a < 255)
+		      (*res)[ a] = res_a;
+		    else
+		      (*res)[ a] = 255;
+		  else
+		    (*res)[ a] = 0;
+#endif
+		}
+	    }
+	  else { a += dim0_aEnd0;} // update a
+	} // if( regular) // (dim 1-n)
+      else
+	{ // necessary because of update of 'a'
+
+	  // non-regular in dim 1-n
+	  if( edgeMode == 1) //edge_wrap
+	    {
+	      // 0-dim beginning
+	      for( long aInitIx0 = 0; aInitIx0 < aBeg[0]; ++aInitIx0, ++a)
+		{
+#ifdef CONVOL_BYTE__
+		  DInt res_a = 0;
+#else
+		  Ty& res_a = (*res)[ a];
+#endif
+		  long m_aInitIx0 = -aInitIx0;
+		  long* kIx = kIxArr;
+		  for( SizeT k=0; k<nK; ++k)
+		    {
+		      SizeT aLonIx;
+		      if( kIx[0] < m_aInitIx0)
+			aLonIx = aInitIx0 + kIx[0] + dim0;
+		      else
+			aLonIx = aInitIx0 + kIx[0];
+
+		      for( SizeT rSp=1; rSp<nDim; ++rSp)
+			{
+			  long aIx = aInitIx[ rSp] + kIx[ rSp];
+			  if( aIx < 0)
+			    aIx += dim[ rSp];
+			  else if( aIx >= dim[ rSp])
+			    aIx -= dim[ rSp];
+			  
+			  aLonIx += aIx * aStride[ rSp];
+			}
+
+		      res_a += ddP[ aLonIx] * ker[ k]; 
+		  
+		      kIx += nDim;
+		    }
+
+		  res_a /= scale;
+
+#ifdef CONVOL_BYTE__
+		  if( res_a > 0) 
+		    if( res_a < 255)
+		      (*res)[ a] = res_a;
+		    else
+		      (*res)[ a] = 255;
+		  else
+		    (*res)[ a] = 0;
+#endif
+		}
+	      // 0-dim regular 
+	      for( long aInitIx0 = aBeg[0]; aInitIx0 < aEnd[0]; ++aInitIx0, ++a)
+		{
+#ifdef CONVOL_BYTE__
+		  DInt res_a = 0;
+#else
+		  Ty& res_a = (*res)[ a];
+#endif
+		  long* kIx = kIxArr;
+		  for( SizeT k=0; k<nK; ++k)
+		    {
+		      SizeT aLonIx = (aInitIx0 + kIx[0]);
+		      for( SizeT rSp=1; rSp<nDim; ++rSp)
+			{
+			  long aIx = aInitIx[ rSp] + kIx[ rSp];
+			  if( aIx < 0)
+			    aIx += dim[ rSp];
+			  else if( aIx >= dim[ rSp])
+			    aIx -= dim[ rSp];
+			  
+			  aLonIx += aIx * aStride[ rSp];
+			}
+
+		      res_a += ddP[ aLonIx] * ker[ k]; 
+		  
+		      kIx += nDim;
+		    }
+
+		  res_a /= scale;
+
+#ifdef CONVOL_BYTE__
+		  if( res_a > 0) 
+		    if( res_a < 255)
+		      (*res)[ a] = res_a;
+		    else
+		      (*res)[ a] = 255;
+		  else
+		    (*res)[ a] = 0;
+#endif
+		}
+	      // 0-dim end
+	      for( long aInitIx0 = aEnd[0]; aInitIx0 < dim0; ++aInitIx0, ++a)
+		{
+#ifdef CONVOL_BYTE__
+		  DInt res_a = 0;
+#else
+		  Ty& res_a = (*res)[ a];
+#endif
+		  long* kIx = kIxArr;
+		  for( SizeT k=0; k<nK; ++k)
+		    {
+		      SizeT aLonIx = aInitIx0 + kIx[0];
+		      if( aLonIx >= dim0) aLonIx -= dim0;
+		      for( SizeT rSp=1; rSp<nDim; ++rSp)
+			{
+			  long aIx = aInitIx[ rSp] + kIx[ rSp];
+			  if( aIx < 0)
+			    aIx += dim[ rSp];
+			  else if( aIx >= dim[ rSp])
+			    aIx -= dim[ rSp];
+		
+			  aLonIx += aIx * aStride[ rSp];
+			}
+
+		      res_a += ddP[ aLonIx] * ker[ k]; 
+		  
+		      kIx += nDim;
+		    }
+
+		  res_a /= scale;
+
+#ifdef CONVOL_BYTE__
+		  if( res_a > 0) 
+		    if( res_a < 255)
+		      (*res)[ a] = res_a;
+		    else
+		      (*res)[ a] = 255;
+		  else
+		    (*res)[ a] = 0;
+#endif
+		}
+
+	    }
+	  else if( edgeMode == 2) //edge_truncate
+	    {
+	      // 0-dim beginning
+	      for( long aInitIx0 = 0; aInitIx0 < aBeg[0]; ++aInitIx0, ++a)
+		{
+#ifdef CONVOL_BYTE__
+		  DInt res_a = 0;
+#else
+		  Ty& res_a = (*res)[ a];
+#endif
+		  long m_aInitIx0 = -aInitIx0;
+		  long* kIx = kIxArr;
+		  for( SizeT k=0; k<nK; ++k)
+		    {
+		      SizeT aLonIx;
+		      if( kIx[0] < m_aInitIx0)
+			aLonIx = 0;
+		      else
+			aLonIx = aInitIx0 + kIx[0];
+		      for( SizeT rSp=1; rSp<nDim; ++rSp)
+			{
+			  long aIx = aInitIx[ rSp] + kIx[ rSp];
+			  if( aIx < 0)
+			    aIx = 0;
+			  else if( aIx >= dim[ rSp])
+			    aIx = dim[ rSp] - 1;
+		
+			  aLonIx += aIx * aStride[ rSp];
+			}
+
+		      res_a += ddP[ aLonIx] * ker[ k]; 
+		  
+		      kIx += nDim;
+		    }
+
+		  res_a /= scale;
+
+#ifdef CONVOL_BYTE__
+		  if( res_a > 0) 
+		    if( res_a < 255)
+		      (*res)[ a] = res_a;
+		    else
+		      (*res)[ a] = 255;
+		  else
+		    (*res)[ a] = 0;
+#endif
+		}
+	      // 0-dim regular 
+	      for( long aInitIx0 = aBeg[0]; aInitIx0 < aEnd[0]; ++aInitIx0, ++a)
+		{
+#ifdef CONVOL_BYTE__
+		  DInt res_a = 0;
+#else
+		  Ty& res_a = (*res)[ a];
+#endif
+		  long* kIx = kIxArr;
+		  for( SizeT k=0; k<nK; ++k)
+		    {
+		      SizeT aLonIx = (aInitIx0 + kIx[0]);
+		      for( SizeT rSp=1; rSp<nDim; ++rSp)
+			{
+			  long aIx = aInitIx[ rSp] + kIx[ rSp];
+			  if( aIx < 0)
+			    aIx = 0;
+			  else if( aIx >= dim[ rSp])
+			    aIx = dim[ rSp] - 1;
+		
+			  aLonIx += aIx * aStride[ rSp];
+			}
+
+		      res_a += ddP[ aLonIx] * ker[ k]; 
+		  
+		      kIx += nDim;
+		    }
+
+		  res_a /= scale;
+
+#ifdef CONVOL_BYTE__
+		  if( res_a > 0) 
+		    if( res_a < 255)
+		      (*res)[ a] = res_a;
+		    else
+		      (*res)[ a] = 255;
+		  else
+		    (*res)[ a] = 0;
+#endif
+		}
+	      // 0-dim end
+	      for( long aInitIx0 = aEnd[0]; aInitIx0 < dim0; ++aInitIx0, ++a)
+		{
+#ifdef CONVOL_BYTE__
+		  DInt res_a = 0;
+#else
+		  Ty& res_a = (*res)[ a];
+#endif
+		  long* kIx = kIxArr;
+		  for( SizeT k=0; k<nK; ++k)
+		    {
+		      SizeT aLonIx = aInitIx0 + kIx[0];
+		      if( aLonIx >= dim0)
+			aLonIx = dim0_1;
+
+		      for( SizeT rSp=1; rSp<nDim; ++rSp)
+			{
+			  long aIx = aInitIx[ rSp] + kIx[ rSp];
+			  if( aIx < 0)
+			    aIx = 0;
+			  else if( aIx >= dim[ rSp])
+			    aIx = dim[ rSp] - 1;
+		
+			  aLonIx += aIx * aStride[ rSp];
+			}
+
+		      res_a += ddP[ aLonIx] * ker[ k]; 
+		  
+		      kIx += nDim;
+		    }
+
+		  res_a /= scale;
+
+#ifdef CONVOL_BYTE__
+		  if( res_a > 0) 
+		    if( res_a < 255)
+		      (*res)[ a] = res_a;
+		    else
+		      (*res)[ a] = 255;
+		  else
+		    (*res)[ a] = 0;
+#endif
+		}
+	    }
+	  else { a += dim0;} // update a
+
+	} // if( regular) else
+    } // for(...)
+
+  return res;
+}
+
+#endif // #ifdef INCLUDE_CONVOL_CPP
+
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/convol.sav.cpp gdl/src/convol.sav.cpp
--- gdl-0.9.3/src/convol.sav.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/convol.sav.cpp	2004-12-09 08:10:19.000000000 -0700
@@ -0,0 +1,221 @@
+/***************************************************************************
+                          convol.cpp  -  convol function
+                             -------------------
+    begin                : Apr 19 2004
+    copyright            : (C) 2004 by Marc Schellens
+    email                : m_schellens@users.sourceforge.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+// this version is simplyfied, but much shorter and easier to understand 
+// than the optimized version
+
+// to be included from datatypes.cpp (twice)
+#ifdef INCLUDE_CONVOL_CPP
+
+#ifndef CONVOL_COMMON__
+#define CONVOL_COMMON__
+
+// common used functions
+
+#endif //#define CONVOL_COMMON__
+
+#ifdef CONVOL_BYTE__
+template<>
+BaseGDL* Data_<SpDByte>::Convol( BaseGDL* kIn, BaseGDL* scaleIn, 
+				 bool center, int edgeMode)
+{
+  Data_<SpDInt>* kernel = static_cast<Data_<SpDInt>*>( kIn);
+  DInt scale = (*static_cast<Data_<SpDInt>*>( scaleIn))[0];
+  // the result to be returned
+  Data_* res = New( dim, BaseGDL::NOZERO);
+  DInt* ker = static_cast<DInt*>( kernel->DataAddr());
+#else
+template<class Sp>
+BaseGDL* Data_<Sp>::Convol( BaseGDL* kIn, BaseGDL* scaleIn, 
+			    bool center, int edgeMode)
+{
+  Data_* kernel = static_cast<Data_*>( kIn);
+  Ty scale = static_cast<Data_*>( scaleIn)->dd[0];
+  // the result to be returned
+  Data_* res = New( dim, BaseGDL::ZERO);
+  Ty* ker = &kernel->dd[0];
+#endif
+  if( scale == zero) scale = 1;
+
+  SizeT nA = N_Elements();
+  SizeT nK = kernel->N_Elements();
+
+  // general case (look at kernel rank == 1 later)
+  SizeT nDim = Rank(); // number of dimension to run over
+
+  SizeT kStride[MAXRANK+1];
+  kernel->Dim().Stride( kStride, nDim);
+
+  // setup kIxArr[ nDim * nK] the offset array
+  // this handles center
+  long* kIxArr = new long[ nDim * nK];
+  long* kIxEnd = &kIxArr[ (nK-1) * nDim];
+  ArrayGuard<long> kIxArrGuard( kIxArr); // guard it
+  for( SizeT k=0; k<nK; ++k)
+    {
+      kIxArr[ k * nDim + 0] = -(k % kernel->Dim( 0));
+      if( center) kIxArr[ k * nDim + 0] = -(kIxArr[ k * nDim + 0] + 
+					    kernel->Dim( 0) / 2);
+      for( SizeT kSp=1; kSp<nDim; ++kSp)
+	{
+	  SizeT kDim = kernel->Dim( kSp);
+	  if( kDim == 0) kDim = 1;
+	  kIxArr[ k * nDim + kSp] = -((k / kStride[kSp]) % kDim);
+	  if( center) kIxArr[ k * nDim + kSp] = -(kIxArr[ k * nDim + kSp] + 
+						  kDim / 2);
+	}
+    }
+
+  SizeT  aStride[ MAXRANK + 1];
+  dim.Stride( aStride, nDim);
+
+  long  aInitIx[ MAXRANK+1];
+  for( SizeT aSp=0; aSp<=nDim; ++aSp) aInitIx[ aSp] = 0;
+
+  bool  regArr[ MAXRANK];
+
+  long  aBeg[ MAXRANK];
+  long  aEnd[ MAXRANK];
+  for( SizeT aSp=0; aSp<nDim; ++aSp) 
+    {
+      aBeg[ aSp] = (center) ? kernel->Dim(aSp)/2 : kernel->Dim(aSp)-1; // >= 
+      regArr[ aSp] = !aBeg[ aSp];
+      aEnd[ aSp] = (center) ? dim[aSp]-(kernel->Dim(aSp)-1)/2 : dim[aSp]; // <
+    }
+
+  Ty* ddP = &dd[0];
+
+  // for all result elements
+  for( SizeT a=0; a<nA; ++a, ++aInitIx[0])
+    {
+      bool regular = true;
+      for( SizeT aSp=0; aSp<nDim;)
+	{
+	  if( aInitIx[ aSp] < dim[ aSp])
+	    {
+	      regArr[ aSp] = 
+		aInitIx[aSp] >= aBeg[aSp] && aInitIx[aSp] < aEnd[ aSp];
+
+	      if( regular)
+		for(; aSp<nDim; ++aSp)
+		  if( !regArr[ aSp])
+		    {
+		      regular = false; 
+			break;
+		    }
+	      break;
+	    }
+
+	  aInitIx[ aSp] = 0;
+	  regArr[ aSp] = !aBeg[ aSp];
+	  if( aBeg[ aSp]) regular = false; 
+	  
+	  ++aInitIx[ ++aSp];
+	}
+
+#ifdef CONVOL_BYTE__
+      DInt res_a = 0;
+#else
+      Ty& res_a = (*res)[ a];
+#endif
+      if( regular)
+	{
+	  long* kIx = kIxArr;
+	  for( SizeT k=0; k<nK; ++k)
+	    {
+	      SizeT aLonIx = (aInitIx[ 0] + kIx[ 0]) * aStride[ 0];
+	      for( SizeT rSp=1; rSp<nDim; ++rSp)
+		aLonIx += (aInitIx[ rSp] + kIx[ rSp]) * aStride[ rSp];
+
+	      res_a += ddP[ aLonIx] * ker[ k]; 
+
+	      kIx += nDim;
+	    }
+
+	  res_a /= scale;
+	}
+      else if( edgeMode == 1) //edge_wrap
+	{
+	  long* kIx = kIxArr;
+	  for( SizeT k=0; k<nK; ++k)
+	    {
+	      SizeT aLonIx=0;
+	      for( SizeT rSp=0; rSp<nDim; ++rSp)
+		{
+		  long aIx = aInitIx[ rSp] + kIx[ rSp];
+		  if( aIx < 0)
+		    aIx += dim[ rSp];
+		  else if( aIx >= dim[ rSp])
+		    aIx -= dim[ rSp];
+		
+		  aLonIx += aIx * aStride[ rSp];
+		}
+
+	      //	      res_a += dd[ aLonIx] * (*kernel)[ k]; 
+	      res_a += ddP[ aLonIx] * ker[ k]; 
+
+	      // advance kIx
+	      kIx += nDim;
+	    }
+
+	  res_a /= scale;
+	}
+      else if( edgeMode == 2) //edge_truncate
+	{
+	  long* kIx = kIxArr;
+	  for( SizeT k=0; k<nK; ++k)
+	    {
+	      // kIx[ nDim] -> nDim index of  k'th element
+
+	      SizeT aLonIx=0;
+	      for( SizeT rSp=0; rSp<nDim; ++rSp)
+		{
+		  long aIx = aInitIx[ rSp] + kIx[ rSp];
+		  if( aIx < 0)
+		    aIx = 0;
+		  else if( aIx >= dim[ rSp])
+		    aIx = dim[ rSp] - 1;
+		
+		  aLonIx += aIx * aStride[ rSp];
+		}
+
+	      //	      res_a += dd[ aLonIx] * (*kernel)[ k]; 
+	      res_a += ddP[ aLonIx] * ker[ k]; 
+
+	      // advance kIx
+	      kIx += nDim;
+	    }
+
+	  res_a /= scale;
+	}
+
+#ifdef CONVOL_BYTE__
+      if( res_a > 0) 
+	if( res_a < 255)
+	  (*res)[ a] = res_a;
+	else
+	  (*res)[ a] = 255;
+      else
+	(*res)[ a] = 0;
+#endif
+    }
+
+  return res;
+}
+
+#endif // #ifdef INCLUDE_CONVOL_CPP
+
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/datatypes.cpp gdl/src/datatypes.cpp
--- gdl-0.9.3/src/datatypes.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/datatypes.cpp	2013-05-16 12:36:33.160858116 -0600
@@ -41,11 +41,20 @@
 #ifdef __cplusplus
 extern "C" {
 #endif
-#define      isnan( x )         ( ( sizeof ( x ) == sizeof(double) ) ?  \
-				  __isnand ( x ) :			\
-				  ( sizeof ( x ) == sizeof( float) ) ?	\
-				  __isnanf ( x ) :			\
-				  __isnan  ( x ) )
+// #define      isnan( x )         ( ( sizeof ( x ) == sizeof(double) ) ?  \
+// 				  __isnand ( x ) :			\
+// 				  ( sizeof ( x ) == sizeof( float) ) ?	\
+// 				  __isnanf ( x ) :			\
+// 				  __isnan  ( x ) )
+namespace std {
+
+  template <typename T>
+  bool isnan( T x) { return ( ( sizeof ( x ) == sizeof(double) ) ?  
+				  __isnand ( x ) :			
+				  ( sizeof ( x ) == sizeof( float) ) ?	
+				  __isnanf ( x ) :			
+				  __isnan  ( x ) );}
+}
 #ifdef __cplusplus
 }
 #endif
@@ -53,9 +62,13 @@
 
 #ifdef _MSC_VER
 #define isfinite _finite
+#define std__isnan isnan
+#else
+#define std__isnan std::isnan
 #endif
 
-using namespace std;
+//using namespace std;
+//using std::isnan;
 
 // this (ugly) including of other sourcefiles has to be done, because
 // on Mac OS X a template instantiation request (see bottom of file)
@@ -98,6 +111,19 @@
 #define isinfinite _isinfinite
 #endif
 
+
+#ifdef TESTTG
+
+#include "test_template_grouping.cpp"
+template<class Sp>
+void Data_<Sp>::TestTemplateGrouping()              
+{ 
+//   Ty ty = Test1();
+  bool b = Test2();
+}
+
+#endif
+
 template<class Sp>
 deque< void*> Data_<Sp>::freeList;
 
@@ -249,11 +275,23 @@
   const size_t newSize = multiAlloc - 1;
 
   freeList.resize( newSize);
-  char* res = static_cast< char*>( malloc( sizeof( Data_) * multiAlloc)); // one more than newSize
+
+#ifdef USE_EIGEN  
+  // we need this allocation here as well (as in typedefs.hpp), because GDLArray needs to be aligned
+  const int alignmentInBytes = 16; // set to multiple of 16 >= sizeof( char*)
+  const size_t realSizeOfType = sizeof( Data_);
+  const SizeT exceed = realSizeOfType % alignmentInBytes;
+  const size_t sizeOfType = realSizeOfType + (alignmentInBytes - exceed);
+  char* res = static_cast< char*>( Eigen::internal::aligned_malloc( sizeOfType * multiAlloc)); // one more than newSize
+#else
+  const size_t sizeOfType = sizeof( Data_);
+  char* res = static_cast< char*>( malloc( sizeOfType * multiAlloc)); // one more than newSize
+#endif
+  
   for( size_t i=0; i<newSize; ++i)
     {
       freeList[ i] = res;
-      res += sizeof( Data_);
+      res += sizeOfType;
     } 
 
   // the one more
@@ -488,6 +526,7 @@
 //   }
 
 
+  
 template<class Sp>
 BaseGDL* Data_<Sp>::Log()              
 { 
@@ -1384,7 +1423,7 @@
 {
   // SA: based on total_over_dim_template()
   //   static Data_* tmp = new Data_(dimension(1), BaseGDL::NOZERO);
-  //auto_ptr<Data_> tmp_guard(tmp);
+  //Guard<Data_> tmp_guard(tmp);
   SizeT nEl = N_Elements();
   SizeT revStride = this->dim.Stride(dim); 
   SizeT outerStride = this->dim.Stride(dim + 1);
@@ -1411,7 +1450,7 @@
 {
   // SA: based on total_over_dim_template()
   Data_* res = new Data_(this->dim, BaseGDL::NOZERO);
-  auto_ptr<Data_> res_guard(res);
+  Guard<Data_> res_guard(res);
   SizeT nEl = N_Elements();
   SizeT revStride = this->dim.Stride(dim); 
   SizeT outerStride = this->dim.Stride(dim + 1);
@@ -1439,7 +1478,7 @@
 {
   // SA: based on total_over_dim_template()
   Data_* res = new Data_(this->dim, BaseGDL::NOZERO);
-  auto_ptr<Data_> res_guard(res);
+  Guard<Data_> res_guard(res);
   SizeT nEl = N_Elements();
   SizeT revStride = this->dim.Stride(dim); 
   SizeT outerStride = this->dim.Stride(dim + 1);
@@ -1467,7 +1506,7 @@
 {
   // SA: based on total_over_dim_template()
   Data_* res = new Data_(this->dim, BaseGDL::NOZERO);
-  auto_ptr<Data_> res_guard(res);
+  Guard<Data_> res_guard(res);
   SizeT nEl = N_Elements();
   SizeT revStride = this->dim.Stride(dim); 
   SizeT outerStride = this->dim.Stride(dim + 1);
@@ -1774,106 +1813,141 @@
   /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
     #pragma omp for*/
-  for( int i = 0; i<nEl; ++i) (*this)[ i] = Sp::zero;
+  for( SizeT i = 0; i<nEl; ++i) (*this)[ i] = Sp::zero;
 }//}
 
 // first time initialization (construction)
 template< class Sp>
 void Data_<Sp>::Construct() 
-{}
-template<>
-void Data_<SpDPtr>::Construct() 
 {
+  // note that this is not possible in cases where an operation 
+  // (here: 'new' which is ok) isn't defined for any POD
+  // (although this code never executes and should be optimized away anyway)
+  const bool isPOD = Sp::IS_POD;   
+  // do nothing for POD
+  if( !isPOD)
+  {
   SizeT nEl = dd.size(); 
   //  for( SizeT i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty;
   /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
     #pragma omp for*/
-  for( int i = 0; i<nEl; ++i) dd[ i] = 0;
-}//}
+  for( SizeT i = 0; i<nEl; ++i) new (&(dd[ i])) Ty;
+  }
+}
 template<>
-void Data_<SpDObj>::Construct()
+void Data_<SpDPtr>::Construct() 
 {
   SizeT nEl = dd.size(); 
   //  for( SizeT i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty;
   /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
     #pragma omp for*/
-  for( int i = 0; i<nEl; ++i) dd[ i] = 0;
+  for( SizeT i = 0; i<nEl; ++i) dd[ i] = 0;
 }//}
-// non POD - use placement new
 template<>
-void Data_< SpDString>::Construct() 
-{ 
+void Data_<SpDObj>::Construct()
+{
   SizeT nEl = dd.size(); 
   //  for( SizeT i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty;
   /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
     #pragma omp for*/
-  for( int i = 0; i<nEl; ++i) new (&(dd[ i])) Ty;
-}//}
-template<>
-void Data_< SpDComplex>::Construct() 
-{ 
-  SizeT nEl = dd.size(); 
-  /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-    #pragma omp for*/
-  for( int i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty;
-}//}
-template<>
-void Data_< SpDComplexDbl>::Construct() 
-{ 
-  SizeT nEl = dd.size(); 
-  /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-    #pragma omp for*/
-  for( int i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty;
+  for( SizeT i = 0; i<nEl; ++i) dd[ i] = 0;
 }//}
+// // non POD - use placement new
+// template<>
+// void Data_< SpDString>::Construct() 
+// { 
+//   SizeT nEl = dd.size(); 
+//   //  for( SizeT i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty;
+//   /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+//     {
+//     #pragma omp for*/
+//   for( SizeT i = 0; i<nEl; ++i) new (&(dd[ i])) Ty;
+// }//}
+// template<>
+// void Data_< SpDComplex>::Construct() 
+// { 
+//   SizeT nEl = dd.size(); 
+//   /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+//     {
+//     #pragma omp for*/
+//   for( SizeT i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty;
+// }//}
+// template<>
+// void Data_< SpDComplexDbl>::Construct() 
+// { 
+//   SizeT nEl = dd.size(); 
+//   /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+//     {
+//     #pragma omp for*/
+//   for( SizeT i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty;
+// }//}
 
 // construction and initalization to zero
 template< class Sp>
 void Data_<Sp>::ConstructTo0() 
 { 
+  if( Sp::IS_POD)
+  {
   SizeT nEl = dd.size(); 
   /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
     #pragma omp for*/
-  for( int i = 0; i<nEl; ++i) (*this)[ i] = Sp::zero;
-}//}
-// non POD - use placement new
-template<>
-void Data_< SpDString>::ConstructTo0() 
-{ 
-  SizeT nEl = dd.size(); 
-  /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-    #pragma omp for*/
-  for( int i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty( zero);
-}//}
-template<>
-void Data_< SpDComplex>::ConstructTo0() 
-{ 
-  SizeT nEl = dd.size(); 
-  /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-    #pragma omp for*/
-  for( int i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty( zero);
-}//}
-template<>
-void Data_< SpDComplexDbl>::ConstructTo0() 
-{ 
+  for( SizeT i = 0; i<nEl; ++i) (*this)[ i] = Sp::zero;
+  }
+  else
+  {
   SizeT nEl = dd.size(); 
   /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
     #pragma omp for*/
-  for( int i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty( zero);
+  for( SizeT i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty( Sp::zero);
+  }
 }//}
+// // non POD - use placement new
+// template<>
+// void Data_< SpDString>::ConstructTo0() 
+// { 
+//   SizeT nEl = dd.size(); 
+//   /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+//     {
+//     #pragma omp for*/
+//   for( int i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty( zero);
+// }//}
+// template<>
+// void Data_< SpDComplex>::ConstructTo0() 
+// { 
+//   SizeT nEl = dd.size(); 
+//   /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+//     {
+//     #pragma omp for*/
+//   for( int i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty( zero);
+// }//}
+// template<>
+// void Data_< SpDComplexDbl>::ConstructTo0() 
+// { 
+//   SizeT nEl = dd.size(); 
+//   /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+//     {
+//     #pragma omp for*/
+//   for( int i = 0; i<nEl; ++i) new (&(*this)[ i]) Ty( zero);
+// }//}
 
 template< class Sp>
 void Data_<Sp>::Destruct() 
 { 
   // no destruction for POD
+  if( !Sp::IS_POD)
+  {
+  SizeT nEl = dd.size(); 
+  /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+    {
+    #pragma omp for*/
+  for( SizeT i = 0; i<nEl; ++i) 
+    (*this)[ i].~Ty();    
+  }
 }
 template<>
 void Data_< SpDPtr>::Destruct()
@@ -1885,36 +1959,36 @@
 {
   GDLInterpreter::DecRefObj( this);
 }
-template<>
-void Data_< SpDString>::Destruct() 
-{
-  SizeT nEl = dd.size(); 
-  /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-    #pragma omp for*/
-  for( int i = 0; i<nEl; ++i) 
-    (*this)[ i].~DString();
-}//}
-template<>
-void Data_< SpDComplex>::Destruct() 
-{
-  SizeT nEl = dd.size(); 
-  /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-    #pragma omp for*/
-  for( int i = 0; i<nEl; ++i) 
-    (*this)[ i].~DComplex();
-}//}
-template<>
-void Data_< SpDComplexDbl>::Destruct() 
-{
-  SizeT nEl = dd.size(); 
-  /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-    {
-    #pragma omp for*/
-  for( int i = 0; i<nEl; ++i) 
-    (*this)[ i].~DComplexDbl();
-}//}
+// template<>
+// void Data_< SpDString>::Destruct() 
+// {
+//   SizeT nEl = dd.size(); 
+//   /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+//     {
+//     #pragma omp for*/
+//   for( SizeT i = 0; i<nEl; ++i) 
+//     (*this)[ i].~DString();
+// }//}
+// template<>
+// void Data_< SpDComplex>::Destruct() 
+// {
+//   SizeT nEl = dd.size(); 
+//   /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+//     {
+//     #pragma omp for*/
+//   for( SizeT i = 0; i<nEl; ++i) 
+//     (*this)[ i].~DComplex();
+// }//}
+// template<>
+// void Data_< SpDComplexDbl>::Destruct() 
+// {
+//   SizeT nEl = dd.size(); 
+//   /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
+//     {
+//     #pragma omp for*/
+//   for( SizeT i = 0; i<nEl; ++i) 
+//     (*this)[ i].~DComplexDbl();
+// }//}
 
 template< class Sp>
 BaseGDL* Data_<Sp>::SetBuffer( const void* b)
@@ -1944,7 +2018,7 @@
       /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 	#pragma omp for*/
-      for( int i=0; i<nEl; ++i) (*res)[ i] = (*this)[ 0]; // set all to scalar
+      for( SizeT i=0; i<nEl; ++i) (*res)[ i] = (*this)[ 0]; // set all to scalar
       //}
       return res;
     }
@@ -2044,7 +2118,7 @@
 // }
 
 
-// Scalar2index
+// Scalar2Index
 // used by the interpreter
 // -2  < 0 array
 // -1  < 0 scalar
@@ -2052,7 +2126,7 @@
 // 1   scalar
 // 2   one-element array
 template<class Sp> 
-int Data_<Sp>::Scalar2index( SizeT& st) const
+int Data_<Sp>::Scalar2Index( SizeT& st) const
 {
   if( dd.size() != 1) return 0;
 
@@ -2086,7 +2160,7 @@
 }
 
 template<> 
-int Data_<SpDComplex>::Scalar2index( SizeT& st) const
+int Data_<SpDComplex>::Scalar2Index( SizeT& st) const
 {
   if( dd.size() != 1) return 0;
   float r=real((*this)[0]);
@@ -2107,7 +2181,7 @@
 }
 
 template<>
-int Data_<SpDComplexDbl>::Scalar2index( SizeT& st) const
+int Data_<SpDComplexDbl>::Scalar2Index( SizeT& st) const
 {
   if( dd.size() != 1) return 0;
   double r=real((*this)[0]);
@@ -2129,7 +2203,7 @@
 
 
 template<> 
-int Data_<SpDString>::Scalar2index( SizeT& st) const
+int Data_<SpDString>::Scalar2Index( SizeT& st) const
 {
   if( dd.size() != 1) return 0;
 
@@ -2169,19 +2243,9 @@
   return 1;
 }
 
-int DStructGDL::Scalar2index( SizeT& st) const
-{
-  throw GDLException("STRUCT expression not allowed in this context.");
-  return 0; // get rid of warning
-}
-int DStructGDL::Scalar2RangeT( RangeT& st) const
-{
-  throw GDLException("STRUCT expression not allowed in this context.");
-  return 0; // get rid of warning
-}
 
 template<> 
-int Data_<SpDPtr>::Scalar2index( SizeT& st) const
+int Data_<SpDPtr>::Scalar2Index( SizeT& st) const
 {
   throw GDLException("PTR expression not allowed in this context.");
   return 0; // get rid of warning
@@ -2194,7 +2258,7 @@
 }
 
 template<> 
-int Data_<SpDObj>::Scalar2index( SizeT& st) const
+int Data_<SpDObj>::Scalar2Index( SizeT& st) const
 {
   throw GDLException("Object expression not allowed in this context.");
   return 0; // get rid of warning
@@ -2277,11 +2341,6 @@
     }
   return ix;
 }
-RangeT DStructGDL::LoopIndex() const
-{
-  throw GDLException("STRUCT expression not allowed in this context.");
-  return 0; // get rid of warning
-}
 
 template<> 
 RangeT Data_<SpDPtr>::LoopIndex() const
@@ -2464,12 +2523,6 @@
   return 0;
 } 
 
-int DStructGDL::Sgn() // -1,0,1
-{
-  throw GDLException("Struct expression not allowed in this context.");
-  return 0;
-} 
-
 template<>
 int Data_<SpDPtr>::Sgn() // -1,0,1
 {
@@ -2564,12 +2617,6 @@
   return false;
 }
 
-bool DStructGDL::EqualNoDelete( const BaseGDL* r) const
-{
-  throw GDLException("Struct expression not allowed in this context.");
-  return false;
-}
-
 // For array_equal r must be of same type
 template<class Sp>
 bool Data_<Sp>::ArrayEqual( BaseGDL* rIn)
@@ -2833,7 +2880,7 @@
 	{
 	  Data_* rConv = static_cast<Data_*>(srcIn->Convert2( this->Type(), BaseGDL::COPY_BYTE_AS_INT));
 	  //      Data_* rConv = static_cast<Data_*>(srcIn->Convert2( this->Type(), BaseGDL::COPY));
-	  auto_ptr<Data_> conv_guard( rConv);
+	  Guard<Data_> conv_guard( rConv);
 	  (*this)[ix] = (*rConv)[0];
 	}
       else
@@ -2845,7 +2892,7 @@
     {
       Data_* rConv = static_cast<Data_*>(srcIn->Convert2( this->Type(), BaseGDL::COPY_BYTE_AS_INT));
       //       Data_* rConv = static_cast<Data_*>(srcIn->Convert2( this->Type(), BaseGDL::COPY));
-      auto_ptr<Data_> conv_guard( rConv);
+      Guard<Data_> conv_guard( rConv);
       (*this)[ixR] = (*rConv)[0];
     }
   else
@@ -4050,7 +4097,7 @@
 	i = start;
 	int flag = 1;
 	while (flag == 1) {
-	  if (!isnan((*this)[i]) && isfinite((*this)[i])) flag = 0;
+	  if (!std__isnan((*this)[i]) && isfinite((*this)[i])) flag = 0;
 	  if (i + step >= stop) flag = 0;
 	  i += step;
 	}
@@ -4060,7 +4107,7 @@
         
       for (i = i_min; i < stop; i += step) {
 	if (omitNaN) {
-	  if (isnan((*this)[i]) || !isfinite((*this)[i])) continue;
+	  if (std__isnan((*this)[i]) || !isfinite((*this)[i])) continue;
 	}
         if ((*this)[i] > maxV) maxV = (*this)[maxEl = i];
       }
@@ -4082,7 +4129,7 @@
 	i = start;
 	int flag = 1;
 	while (flag == 1) {
-	  if (!isnan((*this)[i]) && isfinite((*this)[i])) flag = 0;
+	  if (!std__isnan((*this)[i]) && isfinite((*this)[i])) flag = 0;
 	  if (i + step >= stop) flag = 0;
 	  i += step;
 	}
@@ -4092,7 +4139,7 @@
    
       for (i = i_min; i < stop; i+= step) {
 	if (omitNaN) {
-	  if (isnan((*this)[i]) || !isfinite((*this)[i])) continue;
+	  if (std__isnan((*this)[i]) || !isfinite((*this)[i])) continue;
 	} 
 	if ((*this)[i] < minV) minV = (*this)[minEl = i];
       }
@@ -4114,7 +4161,7 @@
     i = start;
     int flag = 1;
     while (flag == 1) {
-      if (!isnan((*this)[i]) && isfinite((*this)[i])) flag = 0;
+      if (!std__isnan((*this)[i]) && isfinite((*this)[i])) flag = 0;
       if (i + step >= stop) flag = 0;
       i += step;
     }
@@ -4124,7 +4171,7 @@
 
   for (i = i_min; i < stop; i+= step) {
     if (omitNaN){
-      if (isnan((*this)[i]) || !isfinite((*this)[i])) continue;
+      if (std__isnan((*this)[i]) || !isfinite((*this)[i])) continue;
     }
     if ((*this)[i] > maxV) maxV = (*this)[maxEl = i];
     else if( (*this)[i] < minV) minV = (*this)[minEl = i];
@@ -4163,7 +4210,7 @@
 	i = start;
 	int flag = 1;
 	while (flag == 1) {
-	  if (!isnan((*this)[i]) && isfinite((*this)[i])) flag = 0;
+	  if (!std__isnan((*this)[i]) && isfinite((*this)[i])) flag = 0;
 	  if (i + step >= stop) flag = 0;
 	  i += step;
 	}
@@ -4173,7 +4220,7 @@
         
       for (i = i_min; i < stop; i += step) {
 	if (omitNaN) {
-	  if (isnan((*this)[i]) || !isfinite((*this)[i])) continue;
+	  if (std__isnan((*this)[i]) || !isfinite((*this)[i])) continue;
 	}
 	if ((*this)[i] > maxV) maxV = (*this)[maxEl = i];
       }
@@ -4195,7 +4242,7 @@
 	i = start;
 	int flag = 1;
 	while (flag == 1) {
-	  if (!isnan((*this)[i]) && isfinite((*this)[i])) flag = 0;
+	  if (!std__isnan((*this)[i]) && isfinite((*this)[i])) flag = 0;
 	  if (i + step >= stop) flag = 0;
 	  i += step;
 	}
@@ -4205,7 +4252,7 @@
    
       for (i = i_min; i < stop; i += step) {
 	if (omitNaN) {
-	  if (isnan((*this)[i]) || !isfinite((*this)[i])) continue;
+	  if (std__isnan((*this)[i]) || !isfinite((*this)[i])) continue;
 	} 
 	if ((*this)[i] < minV) minV = (*this)[minEl = i];
       }
@@ -4227,7 +4274,7 @@
     i = start;
     int flag = 1;
     while (flag == 1) {
-      if (!isnan((*this)[i]) && isfinite((*this)[i])) flag = 0;
+      if (!std__isnan((*this)[i]) && isfinite((*this)[i])) flag = 0;
       if (i + step >= stop) flag = 0;
       i += step;
     }
@@ -4237,7 +4284,7 @@
 
   for (i = i_min; i < stop; i+= step) {
     if (omitNaN){
-      if (isnan((*this)[i]) || !isfinite((*this)[i])) continue;
+      if (std__isnan((*this)[i]) || !isfinite((*this)[i])) continue;
     }
     if ((*this)[i] > maxV) maxV = (*this)[maxEl = i];
     else if( (*this)[i] < minV) minV = (*this)[minEl = i];
@@ -4449,7 +4496,7 @@
 	i = start;
 	int flag = 1;
 	while (flag == 1) {
-	  if (!isnan((*this)[i].real()) && isfinite((*this)[i].real())) flag = 0;
+	  if (!std__isnan((*this)[i].real()) && isfinite((*this)[i].real())) flag = 0;
 	  if (i + step >= stop) flag = 0;
 	  i += step;
 	}
@@ -4459,7 +4506,7 @@
         
       for (i = i_min; i < stop; i += step) {
 	if (omitNaN) {
-	  if (isnan((*this)[i].real()) || !isfinite((*this)[i].real())) continue;
+	  if (std__isnan((*this)[i].real()) || !isfinite((*this)[i].real())) continue;
 	}
 	if ((*this)[i].real() > maxV) maxV = (*this)[maxEl = i].real();
       }
@@ -4481,7 +4528,7 @@
 	i = start;
 	int flag = 1;
 	while (flag == 1) {
-	  if (!isnan((*this)[i].real()) && isfinite((*this)[i].real())) flag = 0;
+	  if (!std__isnan((*this)[i].real()) && isfinite((*this)[i].real())) flag = 0;
 	  if (i + step >= stop) flag = 0;
 	  i += step;
 	}
@@ -4491,7 +4538,7 @@
    
       for (i = i_min; i < stop; i += step) {
 	if (omitNaN) {
-	  if (isnan((*this)[i].real()) || !isfinite((*this)[i].real())) continue;
+	  if (std__isnan((*this)[i].real()) || !isfinite((*this)[i].real())) continue;
 	} 
 	if ((*this)[i].real() < minV) minV = (*this)[minEl = i].real();
       }
@@ -4513,7 +4560,7 @@
     i = start;
     int flag = 1;
     while (flag == 1) {
-      if (!isnan((*this)[i].real()) && isfinite((*this)[i].real())) flag = 0;
+      if (!std__isnan((*this)[i].real()) && isfinite((*this)[i].real())) flag = 0;
       if (i + step >= stop) flag = 0;
       i += step;
     }
@@ -4523,7 +4570,7 @@
 
   for (i = i_min; i < stop; i += step) {
     if (omitNaN){
-      if (isnan((*this)[i].real()) || !isfinite((*this)[i].real())) continue;
+      if (std__isnan((*this)[i].real()) || !isfinite((*this)[i].real())) continue;
     }
     if ((*this)[i].real() > maxV) maxV = (*this)[maxEl = i].real();
     else if( (*this)[i].real() < minV) minV = (*this)[minEl = i].real();
@@ -4544,12 +4591,6 @@
 
 }
 
-void DStructGDL::MinMax( DLong* minE, DLong* maxE, 
-			 BaseGDL** minVal, BaseGDL** maxVal, bool omitNaN,
-			 SizeT start, SizeT stop, SizeT step, DLong valIx)
-{
-  throw GDLException("Struct expression not allowed in this context.");
-}
 
 template<>
 BaseGDL* Data_<SpDString>::Convol( BaseGDL* kIn, BaseGDL* scaleIn, 
@@ -5129,11 +5170,11 @@
 {
   Data_* srcT = dynamic_cast<Data_*>( src);
 
-  auto_ptr< Data_> srcTGuard;
+  Guard< Data_> srcTGuard;
   if( srcT == NULL) 
     {
       srcT = static_cast<Data_*>( src->Convert2( Data_::t, BaseGDL::COPY));
-      srcTGuard.reset( srcT);
+      srcTGuard.Reset( srcT);
     }
 
   /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
@@ -5228,7 +5269,7 @@
   SizeT nElem = ix->N_Elements();
 
   Data_* res = New( ix->Dim(), BaseGDL::NOZERO);
-  auto_ptr<Data_> guard( res);
+  Guard<Data_> guard( res);
 
   SizeT upper = dd.size() - 1;
   Ty    upperVal = (*this)[ upper];
@@ -5279,7 +5320,7 @@
 SizeT Data_<SpDInt>::GetAsIndexStrict( SizeT i) const
 {
   if( (*this)[i] < 0)
-    throw GDLException(NULL,"Array used to subscript array "
+    throw GDLException(-1,NULL,"Array used to subscript array "
 		       "contains out of range (<0) subscript (at index: " + i2s(i) + ").",true,false);
   return (*this)[i];
 }	
@@ -5294,7 +5335,7 @@
 SizeT Data_<SpDLong>::GetAsIndexStrict( SizeT i) const
 {
   if( (*this)[i] < 0)
-    throw GDLException(NULL,"Array used to subscript array "
+    throw GDLException(-1,NULL,"Array used to subscript array "
 		       "contains out of range (<0) subscript (at index: " + i2s(i) + ").",true,false);
   return (*this)[i];
 }	
@@ -5309,7 +5350,7 @@
 SizeT Data_<SpDLong64>::GetAsIndexStrict( SizeT i) const
 {
   if( (*this)[i] < 0)
-    throw GDLException(NULL,"Array used to subscript array "
+    throw GDLException(-1,NULL,"Array used to subscript array "
 		       "contains out of range (<0) subscript (at index: " + i2s(i) + ").",true,false);
   return (*this)[i];
 }	
@@ -5324,7 +5365,7 @@
 SizeT Data_<SpDFloat>::GetAsIndexStrict( SizeT i) const
 {
   if( (*this)[i] <= -1.0)
-    throw GDLException(NULL,"Array used to subscript array "
+    throw GDLException(-1,NULL,"Array used to subscript array "
 		       "contains out of range (<0) subscript (at index: " + i2s(i) + ").",true,false);
   if( (*this)[i] <= 0.0)
     return 0;
@@ -5341,7 +5382,7 @@
 SizeT Data_<SpDDouble>::GetAsIndexStrict( SizeT i) const
 {
   if( (*this)[i] <= -1.0)
-    throw GDLException(NULL,"Array used to subscript array "
+    throw GDLException(-1,NULL,"Array used to subscript array "
 		       "contains out of range (<0) subscript (at index: " + i2s(i) + ").",true,false);
   if( (*this)[i] <= 0.0)
     return 0;
@@ -5374,7 +5415,7 @@
       return 0;
     }
   if( l < 0)
-    throw GDLException(NULL,"Array used to subscript array "
+    throw GDLException(-1,NULL,"Array used to subscript array "
 		       "contains out of range (<0) subscript.",true,false);
   return l;
 }	
@@ -5390,7 +5431,7 @@
 SizeT Data_<SpDComplex>::GetAsIndexStrict( SizeT i) const
 {
   if( real((*this)[i]) <= -1.0)
-    throw GDLException(NULL,"Array used to subscript array "
+    throw GDLException(-1,NULL,"Array used to subscript array "
 		       "contains out of range (<0) subscript (at index: " + i2s(i) + ").",true,false);
   if( real((*this)[i]) <= 0.0)
     return 0;
@@ -5407,7 +5448,7 @@
 SizeT Data_<SpDComplexDbl>::GetAsIndexStrict( SizeT i) const
 {
   if( real((*this)[i]) <= -1.0)
-    throw GDLException(NULL,"Array used to subscript array "
+    throw GDLException(-1,NULL,"Array used to subscript array "
 		       "contains out of range (<0) subscript (at index: " + i2s(i) + ").",true,false);
   if( real((*this)[i]) <= 0.0)
     return 0;
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/datatypes.hpp gdl/src/datatypes.hpp
--- gdl-0.9.3/src/datatypes.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/datatypes.hpp	2013-05-16 12:36:33.163858106 -0600
@@ -28,6 +28,7 @@
 //#include <complex>
 #include <deque>
 
+// #include <type_traits>
 #include "typedefs.hpp"
 #include "basegdl.hpp"
 #include "typetraits.hpp"
@@ -37,11 +38,28 @@
 #pragma interface
 #endif
 
+
+// for each group we need one definition
+// usage: GDL_DEFINE_INTEGER_FUNCTION(retType) fName( arg list) { definition}
+#define GDL_DEFINE_INTEGER_FUNCTION( retType ) template<typename Sp>template< typename U> typename U::template IfInteger< retType >::type Data_<Sp>::
+#define GDL_DEFINE_FLOAT_FUNCTION( retType ) template<typename Sp>template< typename U> typename U::template IfFloat< retType >::type Data_<Sp>::
+#define GDL_DEFINE_COMPLEX_FUNCTION( retType ) template<typename Sp>template< typename U> typename U::template IfComplex< retType >::type Data_<Sp>::
+#define GDL_DEFINE_OTHER_FUNCTION( retType ) template<typename Sp>template< typename U> typename U::template IfOther< retType >::type Data_<Sp>::
+
 const size_t multiAlloc = 256;
 
 template<class Sp>
 class Data_: public Sp
 {
+
+// save some typing. Declares function "fName" for all four groups (with return type "retType")
+#define GDL_DECLARE_FUNCTION( retType, fName, ... ) \
+template< typename U = Sp > typename U::template IfInteger< retType >::type fName( __VA_ARGS__); \
+template< typename U = Sp > typename U::template IfFloat< retType >::type fName( __VA_ARGS__); \
+template< typename U = Sp > typename U::template IfComplex< retType >::type fName( __VA_ARGS__); \
+template< typename U = Sp > typename U::template IfOther< retType >::type fName( __VA_ARGS__)
+
+
 public:
   typedef typename Sp::Ty    Ty;
   typedef Sp                 Traits;
@@ -53,7 +71,41 @@
 #endif
 
   typedef typename Sp::DataT DataT;
+#ifdef USE_EIGEN  
+  EIGEN_ALIGN16 DataT        dd; // the data
+#else
   DataT                      dd; // the data
+#endif
+
+public:
+
+// #define TESTTG // TEST TEMPLATE GROUPING
+
+#ifdef TESTTG
+
+void TestTemplateGrouping();
+
+// #define GDL_TEMPLATE_Integer( retType ) template< typename U = Sp > typename U::template IfInteger< retType >::type 
+// #define GDL_TEMPLATE_IntegerDef( retType ) template<typename Sp>template< typename U> typename U::template IfInteger< retType >::type Data_<Sp>::
+
+
+GDL_DECLARE_FUNCTION(bool,Test2);
+
+// template< typename U = Sp >  
+//typename U::template IfInteger<bool>::type 
+// GDL_TEMPLATE_Integer(bool) Test2();
+// template< typename U = Sp >  
+// typename U::template IfFloat<bool>::type 
+// Test2();
+// template< typename U = Sp >  
+// typename U::template IfComplex<bool>::type 
+// Test2();
+// template< typename U = Sp >  
+// typename U::template IfOther<bool>::type 
+// Test2();
+
+#endif
+
 
 public:
 	// memory management optimization
@@ -141,7 +193,7 @@
   void Clear();
   void Construct();     // construction (for DStructGDL)
   void ConstructTo0();  // construction (for DStructGDL)
-  void Destruct(); // destruction (for DStructGDL)
+  void Destruct();      // destruction (for DStructGDL)
 
   BaseGDL* SetBuffer( const void* b);
   void SetBufferSize( SizeT s);
@@ -153,7 +205,7 @@
   std::istream& FromStream(std::istream& i);
  
   // used by the interpreter
-  int Scalar2index( SizeT& st) const;
+  int Scalar2Index( SizeT& st) const;
   int Scalar2RangeT( RangeT& st) const;
   RangeT LoopIndex() const;
 
@@ -255,13 +307,23 @@
   // operators
   BaseGDL* UMinus(); // UMinus for SpDString returns float
   Data_*   NotOp();
+// GDL_DECLARE_FUNCTION( Data_*, AndOp, BaseGDL* r);
   Data_*   AndOp( BaseGDL* r);
   Data_*   AndOpInv( BaseGDL* r);
   Data_*   OrOp( BaseGDL* r);
   Data_*   OrOpInv( BaseGDL* r);
   Data_*   XorOp( BaseGDL* r);
+
   BaseGDL* Add( BaseGDL* r);
   BaseGDL* AddInv( BaseGDL* r);
+  BaseGDL* AddS( BaseGDL* r);
+  BaseGDL* AddInvS( BaseGDL* r);
+
+  BaseGDL* AddNew( BaseGDL* r);      // implemented
+  BaseGDL* AddInvNew( BaseGDL* r);      // implemented
+  BaseGDL* AddSNew( BaseGDL* r);         // implemented
+  BaseGDL* AddInvSNew( BaseGDL* r);    // implemented
+
 //   Data_*   AddNew( BaseGDL* r);
 //   Data_*   AddInvNew( BaseGDL* r);
   BaseGDL*   Sub( BaseGDL* r);
@@ -278,7 +340,8 @@
   Data_*   PowInv( BaseGDL* r);
   Data_*   PowInt( BaseGDL* r);      
 //   Data_*   PowIntNew( BaseGDL* r);   
-  Data_*   MatrixOp( BaseGDL* r, bool transpose, bool transposeResult, bool strassen);
+  
+  Data_*   MatrixOp( BaseGDL* r, bool atranspose, bool btranspose);
 
   // operators with scalar
   Data_*   AndOpS( BaseGDL* r);
@@ -286,8 +349,6 @@
   Data_*   OrOpS( BaseGDL* r);
   Data_*   OrOpInvS( BaseGDL* r);
   Data_*   XorOpS( BaseGDL* r);
-  BaseGDL*   AddS( BaseGDL* r);
-  BaseGDL*   AddInvS( BaseGDL* r);
 //   Data_*   AddSNew( BaseGDL* r);
 //   Data_*   AddInvSNew( BaseGDL* r);
   Data_*   SubS( BaseGDL* r);
@@ -315,8 +376,6 @@
 //   Data_* GeOpNew( BaseGDL* r);
 //   Data_* LtOpNew( BaseGDL* r);
 //   Data_* GtOpNew( BaseGDL* r);
-  BaseGDL* AddNew( BaseGDL* r);      // implemented
-  BaseGDL* AddInvNew( BaseGDL* r);      // implemented
   BaseGDL* SubNew( BaseGDL* r);
   BaseGDL* SubInvNew( BaseGDL* r);
   Data_* LtMarkNew( BaseGDL* r);
@@ -336,8 +395,6 @@
   Data_* OrOpSNew( BaseGDL* r);
   Data_* OrOpInvSNew( BaseGDL* r);
   Data_* XorOpSNew( BaseGDL* r);
-  BaseGDL* AddSNew( BaseGDL* r);         // implemented
-  BaseGDL* AddInvSNew( BaseGDL* r);    // implemented
   BaseGDL* SubSNew( BaseGDL* r);
   BaseGDL* SubInvSNew( BaseGDL* r);
   Data_* LtMarkSNew( BaseGDL* r);
@@ -425,6 +482,10 @@
   // used for concatenation, called from CatArray
   // assumes that everything is checked (see CatInfo)
   void CatInsert( const Data_* srcArr, const SizeT atDim, SizeT& at);
+
+  // only to be used here
+#undef GDL_DECLARE_FUNCTION
+
 };
 
 // template<> Data_<SpDPtr>::Data_(const Ty& d_);
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/datatypesref.cpp gdl/src/datatypesref.cpp
--- gdl-0.9.3/src/datatypesref.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/datatypesref.cpp	2013-03-25 10:36:38.237970409 -0600
@@ -31,7 +31,7 @@
       /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 	#pragma omp for*/
-      for( int i=0; i<nEl; ++i) (*res)[ i] = (*this)[ 0]; // set all to scalar
+      for( OMPInt i=0; i<nEl; ++i) (*res)[ i] = (*this)[ 0]; // set all to scalar
       //}
       GDLInterpreter::AddRef((*this)[ 0], nEl);
       
@@ -51,7 +51,7 @@
       /*#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 	#pragma omp for*/
-      for( int i=0; i<nEl; ++i) (*res)[ i] = (*this)[ 0]; // set all to scalar
+      for( OMPInt i=0; i<nEl; ++i) (*res)[ i] = (*this)[ 0]; // set all to scalar
       //}
       GDLInterpreter::AddRefObj((*this)[ 0], nEl);
       
@@ -1159,11 +1159,11 @@
 {
   Data_* srcT = dynamic_cast<Data_*>( src);
 
-  auto_ptr< Data_> srcTGuard;
+  Guard< Data_> srcTGuard;
   if( srcT == NULL)
     {
       srcT = static_cast<Data_*>( src->Convert2( Data_::t, BaseGDL::COPY));
-      srcTGuard.reset( srcT);
+      srcTGuard.Reset( srcT);
     }
 
   //#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
@@ -1184,11 +1184,11 @@
 {
   Data_* srcT = dynamic_cast<Data_*>( src);
 
-  auto_ptr< Data_> srcTGuard;
+  Guard< Data_> srcTGuard;
   if( srcT == NULL)
     {
       srcT = static_cast<Data_*>( src->Convert2( Data_::t, BaseGDL::COPY));
-      srcTGuard.reset( srcT);
+      srcTGuard.Reset( srcT);
     }
 
   //#pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
@@ -1459,7 +1459,7 @@
   SizeT nElem = ix->N_Elements();
 
   Data_* res = New( ix->Dim(), BaseGDL::NOZERO);
-  auto_ptr<Data_> guard( res);
+  Guard<Data_> guard( res);
 
   SizeT upper = dd.size() - 1;
   Ty    upperVal = (*this)[ upper];
@@ -1497,7 +1497,7 @@
   SizeT nElem = ix->N_Elements();
 
   Data_* res = New( ix->Dim(), BaseGDL::NOZERO);
-  auto_ptr<Data_> guard( res);
+  Guard<Data_> guard( res);
 
   SizeT upper = dd.size() - 1;
   Ty    upperVal = (*this)[ upper];
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/dcompiler.cpp gdl/src/dcompiler.cpp
--- gdl-0.9.3/src/dcompiler.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/dcompiler.cpp	2013-03-25 10:36:38.244970376 -0600
@@ -410,7 +410,7 @@
 
     // must be compiled here
     ARRAYDEFNode* c = new ARRAYDEFNode( n);
-    auto_ptr< ARRAYDEFNode> guard( c);
+    Guard< ARRAYDEFNode> guard( c);
     assert( c->ConstantArray());
 
 //   cout << "ProgNodeP:" << endl;
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/deviceps.hpp gdl/src/deviceps.hpp
--- gdl-0.9.3/src/deviceps.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/deviceps.hpp	2013-05-16 12:36:33.191858005 -0600
@@ -16,12 +16,15 @@
  ***************************************************************************/
 
 #ifndef DEVICEPS_HPP_
-#  define DEVICEPS_HPP_
+#define DEVICEPS_HPP_
+
+#include "gdlpsstream.hpp"
+#include "plotting.hpp" // get_axis_crange for TV()
+#include "initsysvar.hpp"
+#include <gsl/gsl_const_mksa.h> // GSL_CONST_MKSA_INCH
+
+#include "objects.hpp"
 
-#  include "gdlpsstream.hpp"
-#  include "plotting.hpp" // get_axis_crange for TV()
-#  include "initsysvar.hpp"
-#  include <gsl/gsl_const_mksa.h> // GSL_CONST_MKSA_INCH
 
 #  ifdef USE_PSLIB
 #    include <stdio.h> // tmpnam
@@ -35,6 +38,14 @@
 #    define SETOPT setopt
 #  endif
 
+#ifdef _MSC_VER
+#define cm2in (.01 / GSL_CONST_MKSA_INCH); // This is not good, but works
+#define dpi 72.0 //in dpi;
+#else
+  static const float cm2in = .01 / GSL_CONST_MKSA_INCH;
+  static const PLFLT dpi = 72.0 ; //in dpi;
+#endif
+
 class DevicePS: public Graphics
 {
   std::string      fileName;
@@ -49,12 +60,7 @@
   bool             encapsulated;
   float	           scale;
 
-  static const int dpi = 72;
-#ifdef _MSC_VER
-#define cm2in (.01 / GSL_CONST_MKSA_INCH); // This is not good, but works
-#else
-  static const float cm2in = .01 / GSL_CONST_MKSA_INCH;
-#endif
+  GDLStream  *psUnit;
 
   void InitStream()
   {
@@ -66,56 +72,74 @@
 
     if( nx <= 0) nx = 1;
     if( ny <= 0) ny = 1;
-
-    actStream = new GDLPSStream( nx, ny, SysVar::GetPFont(), encapsulated);
+    actStream = new GDLPSStream( nx, ny, (int)SysVar::GetPFont(), encapsulated, color);
 
     actStream->sfnam( fileName.c_str());
 
+    // trying to solve bug report 3611898
+    // AC 29-Avril-2013: the way I found to link GDLPSStream* and GDLStream*
+    DLong lun=GetLUN();
+    psUnit = &fileUnits[ lun-1];
+    psUnit->Open(fileName,fstream::out,false,false,false,
+		 defaultStreamWidth,false,false);
+    (*static_cast<DLongGDL*>( dStruct->GetTag(dStruct->Desc()->TagIndex("UNIT"))))[0]=lun;
+
     // zeroing offsets (xleng and yleng are the default ones but they need to be specified 
     // for the offsets to be taken into account by spage(), works with plplot >= 5.9.9)
-    actStream->spage(dpi, dpi, 540, 720, 0, 0);
+    actStream->spage(dpi, dpi, 540, 720, 32, 32); //plplot default: portrait!
 
     // as setting the offsets and sizes with plPlot is (extremely) tricky, and some of these setting
     // are hardcoded into plplot (like EPS header, and offsets in older versions of plplot)
     // here we only specify the aspect ratio - size an offset are handled by pslib when device,/close is called
-//     char as[32];
-//     sprintf(as, "%f", XPageSize / YPageSize);
-//     actStream->SETOPT( "a", as);
-    std::string as = i2s( XPageSize / YPageSize);
-    actStream->SETOPT( "a", as.c_str());
 
+    // patch 3611949 by Joanna, 29 Avril 2013
+    PLFLT pageRatio=XPageSize/YPageSize;
+    std::string as = i2s( pageRatio);
+    actStream->SETOPT( "a", as.c_str());
+    
     // plot orientation
-    actStream->sori(orient_portrait ? 1 : 2);
-
+    //std::cout  << "orientation : " << orient_portrait<< std::endl;
+    
+    actStream->sdiori(orient_portrait ? 1 : 2);
+    
     // no pause on destruction
     actStream->spause( false);
 
     // extended fonts
     actStream->fontld( 1);
-
-    // set color map
+    
+    // avoid to set color map 0 -- makes plplot very slow (?)
     PLINT r[ctSize], g[ctSize], b[ctSize];
     actCT.Get( r, g, b);
-    //    actStream->scmap0( r, g, b, ctSize); 
-    actStream->scmap1( r, g, b, ctSize); 
-    actStream->scolbg(255,255,255); // white background
-
+//    actStream->scmap0( r, g, b, ctSize);
+    actStream->scmap1( r, g, b, ctSize);
     // default: black+white (IDL behaviour)
-    //actStream->scolor( color); // has no effect
-    if (color == 0) 
-      actStream->SETOPT( "drvopt","text=0,color=0"); 
-    else 
-      actStream->SETOPT( "drvopt","text=0,color=1");
-    color=0;
+    if (color == 0)
+    {
+      actStream->SETOPT( "drvopt","text=0,color=0");
+    }
+    else
+    {
+      actStream->SETOPT( "drvopt","text=0,color=1"); //need to pass all options with the same 'setopt' command.
+    }
+    actStream->scolbg(255,255,255); // start with a white background
 
     actStream->Init();
     
+    // need to be called initially. permit to fix things
+    actStream->ssub(1,1);
+    actStream->adv(0);
     // load font
     actStream->font( 1);
+    actStream->vpor(0,1,0,1);
+    actStream->wind(0,1,0,1);
     actStream->DefaultCharSize();
+   //in case these are not initalized, here is a good place to do it.
+    if (actStream->updatePageInfo()==true)
+    {
+        actStream->GetPlplotDefaultCharSize(); //initializes everything in fact..
 
-    //    (*pMulti)[ 0] = 0;
-    actStream->adv(0);
+    }
   }
     
 private:
@@ -123,7 +147,7 @@
   {
 #  ifndef USE_PSLIB
     Warning("Warning: pslib support is mandatory for the PostScript driver to handle the following");
-    Warning("         keywords: [X,Y]SIZE, [X,Y]OFFSET, SCALE_FACTOR, LANDSCAPE, PORTRAIT, ENCAPSULATED");
+    Warning("         keywords:  [X,Y]OFFSET, SCALE_FACTOR, ENCAPSULATED");
 #  else
     PSDoc *ps = PS_new(); 
     GDLGuard<PSDoc> psGuard( ps, PS_delete);
@@ -163,13 +187,45 @@
       tmp = (login == NULL ? "?" : login) + string("@") + uts.nodename;
       PS_set_info(ps, "Author", tmp.c_str());
     }
+    //bug: PSLIB does not return the correct boundingbox, it forgets offx and offy. Try to get it
+    //back (using pslib own code!)!
+        char *bb;
+        FILE *feps;
+        char buffer[1024]; //largely sufficient
+        int nbytes;
+        feps=fopen(fileName.c_str(), "r");
+        nbytes=fread(buffer,sizeof(char),1023,feps);
+        fclose(feps);
+        buffer[1023]=0;
+	bb = strstr(buffer, "%%BoundingBox:");
+        float offx, offy, width, height;
+	if(bb) {
+            bb += 15;
+            sscanf(bb, "%f %f %f %f", &offx, &offy, &width, &height);
+	} else {
+            offx=0;
+            offy=0;
+            width=500;
+            height=500; //silly values, will be replaced afterwards hopefully.
+        }
 
     // TODO
     //psfont = PS_findfont(ps, "Helvetica", "", 0); 
     //PS_setfont(ps, psfont, 8.0); 
 
+      char bbstr [20], offstr [20];
+      int bbXSize, bbYSize;
     {
-      PS_begin_page(ps, XPageSize * cm2in * dpi, YPageSize * cm2in * dpi);
+
+      int bbXoff = XOffset*cm2in*dpi;
+      int bbYoff = YOffset*cm2in*dpi;
+      bbXSize = orient_portrait ? bbXoff + XPageSize*cm2in*dpi*scale : bbXoff + YPageSize*cm2in*dpi*scale;
+      bbYSize = orient_portrait ? bbYoff + YPageSize*cm2in*dpi*scale : bbYoff + XPageSize*cm2in*dpi*scale;
+      sprintf(bbstr,"%i %i %i %i",bbXoff,bbYoff,bbXSize,bbYSize);
+      sprintf(offstr,"%i %i",bbXoff,bbYoff);
+    
+      PS_set_info(ps,"BoundingBox",bbstr);
+      PS_begin_page(ps, bbXSize, bbYSize);
       {
         int psimage = PS_open_image_file(ps, "eps", fileName.c_str(), NULL, 0);
         if (psimage == 0)
@@ -177,14 +233,14 @@
           Warning("Warning: pslib failed to load plPlot output file.");
           goto cleanup;
         }
-
-        float scl = orient_portrait
-          ? (XPageSize * cm2in * dpi) / (PS_get_value(ps, "imagewidth", (float) psimage))
-          : (YPageSize * cm2in * dpi) / (PS_get_value(ps, "imagewidth", (float) psimage));
+	
+        float scl = 0.98*min((bbXSize-bbXoff) / (width-offx), (bbYSize-bbYoff) / (height-offy) );
+	int margx = ((bbXSize-bbXoff) - scl*(width-offx))/2;
+	int margy = ((bbYSize-bbYoff) - scl*(height-offy))/2;
         PS_place_image(ps, psimage, 
-          XOffset * cm2in * dpi,
-          YOffset * cm2in * dpi, 
-          scale * scl
+		       bbXoff-offx*scl + margx,
+		       bbYoff-offy*scl + margy,
+		       scl
         );
         PS_close_image(ps, psimage); 
       }
@@ -192,7 +248,7 @@
       PS_close(ps);
     }
     
-    // write contents to fileName
+    // Replace PageBoundingBox and CropBox and write contents to fileName
     {
       rewind(fp);
       FILE *fp_plplot = fopen(fileName.c_str(), "w");
@@ -202,12 +258,50 @@
         Warning("Warning: failed to open plPlot-generated file");
         goto cleanup;
       }
-      const size_t buflen=4096;
-      unsigned char buff[buflen];
+
+      // When multiple pages are supported, PageBoundingBox and the cropbox
+      // will appear more than once. Then this section will need to be redone.
+
+      // Edit: change the two 0's after the PageBoundingBox
+      string pbstr=string("%%PageBoundingBox: ")+offstr;
+      // edits will be in the first 12288 bytes; add the length of offstr-3
+      const size_t buflen=12288 + pbstr.length()-22;
+      //const size_t buflen=4096;
+      char buff[buflen];
+
+      //do the first read:
+      size_t cnt = fread(&buff, 1, 12288, fp);
+      string sbuff;
+      sbuff = string(buff);
+
+      // find the PageBoundingBox statement
+      size_t pos = sbuff.find("%%PageBoundingBox: 0 0");
+      if (pos != string::npos) {
+	sbuff.replace(pos,22,pbstr); // will change the size of sbuff by offstr-3
+	cnt = cnt + pbstr.length()-22;
+      }
+
+      // PSlib outputs pdfmarks which resize the PDF to the size of the boundingbox
+      // this is nice, but not IDL behaviour (and anyway, the two 0's are wrong)
+      char mychar[60];
+      sprintf(mychar,"[ /CropBox [0 0 %i.00 %i.00] /PAGE pdfmark",bbXSize,bbYSize);
+      string pdfstr=string(mychar); 
+      string pdfrepl(pdfstr.length(),' ');
+      pos = sbuff.find(pdfstr);
+      if (pos != string::npos) {sbuff.replace(pos,pdfstr.length(),pdfrepl);} // will not change size of sbuff
+
+      // write the first buflen to file
+      strcpy(buff,sbuff.c_str());
+      if (fwrite(&buff, 1, buflen, fp_plplot) < buflen)
+        {
+          Warning("Warning: failed to overwrite the plPlot-generated file with pslib output");
+        }
+
+      // read the rest of fp and write to file
       while (true)
       {
-        size_t cnt = fread(&buff, 1, buflen, fp);
-        if (!cnt) break;
+       cnt = fread(&buff, 1, buflen, fp);
+         if (!cnt) break;
         if (fwrite(&buff, 1, cnt, fp_plplot) < cnt)
         {
           Warning("Warning: failed to overwrite the plPlot-generated file with pslib output");
@@ -228,7 +322,8 @@
 
 public:
   DevicePS(): Graphics(), fileName( "gdl.ps"), actStream( NULL), color(0), 
-    decomposed( 0), encapsulated(false), scale(1.)
+    decomposed( 0), encapsulated(false), scale(1.), XPageSize(17.78), YPageSize(12.7),
+    XOffset(0.0),YOffset(0.0)
   {
     name = "PS";
 
@@ -239,22 +334,22 @@
 
     dStruct = new DStructGDL( "!DEVICE");
     dStruct->InitTag("NAME",       DStringGDL( name)); 
-    dStruct->InitTag("X_SIZE",     DLongGDL( 17780)); 
-    dStruct->InitTag("Y_SIZE",     DLongGDL( 12700)); 
-    dStruct->InitTag("X_VSIZE",    DLongGDL( 640)); 
-    dStruct->InitTag("Y_VSIZE",    DLongGDL( 512)); 
-    dStruct->InitTag("X_CH_SIZE",  DLongGDL( 0)); 
-    dStruct->InitTag("Y_CH_SIZE",  DLongGDL( 0)); 
-    dStruct->InitTag("X_PX_CM",    DFloatGDL( 1000.0)); 
+    dStruct->InitTag("X_SIZE",     DLongGDL( XPageSize*scale*1000)); //29700/1000=29.7 cm
+    dStruct->InitTag("Y_SIZE",     DLongGDL( YPageSize*scale*1000));
+    dStruct->InitTag("X_VSIZE",    DLongGDL( XPageSize*scale*1000));
+    dStruct->InitTag("Y_VSIZE",    DLongGDL( YPageSize*scale*1000));
+    dStruct->InitTag("X_CH_SIZE",  DLongGDL( 360));
+    dStruct->InitTag("Y_CH_SIZE",  DLongGDL( 360));
+    dStruct->InitTag("X_PX_CM",    DFloatGDL( 1000.0)); //1000 pix/cm
     dStruct->InitTag("Y_PX_CM",    DFloatGDL( 1000.0)); 
     dStruct->InitTag("N_COLORS",   DLongGDL( 256)); 
     dStruct->InitTag("TABLE_SIZE", DLongGDL( 256)); 
-    dStruct->InitTag("FILL_DIST",  DLongGDL( 0)); 
+    dStruct->InitTag("FILL_DIST",  DLongGDL( 1));
     dStruct->InitTag("WINDOW",     DLongGDL( -1)); 
     dStruct->InitTag("UNIT",       DLongGDL( 0)); 
     dStruct->InitTag("FLAGS",      DLongGDL( 266807)); 
     dStruct->InitTag("ORIGIN",     origin); 
-    dStruct->InitTag("ZOOM",       zoom); 
+    dStruct->InitTag("ZOOM",       zoom);
 
     SetPortrait();
 
@@ -297,6 +392,14 @@
 
   bool CloseFile()
   {
+
+    // trying to solve bug report 3611898
+    // this is needed to decrement Lun number ...
+    (*static_cast<DLongGDL*>( dStruct->GetTag(dStruct->Desc()->TagIndex("UNIT"))))[0]=0;
+    psUnit->Close();
+    psUnit->Free();
+    psUnit=NULL;
+
     if (actStream != NULL)
     {
       delete actStream;
@@ -325,6 +428,10 @@
       = DLong(floor(0.5+
         xs * (*static_cast<DFloatGDL*>(dStruct->GetTag(dStruct->Desc()->TagIndex("X_PX_CM"))))[0]
       ));
+   (*static_cast<DLongGDL*>(dStruct->GetTag(dStruct->Desc()->TagIndex("X_VSIZE"))))[0]
+      = DLong(floor(0.5+
+        xs * (*static_cast<DFloatGDL*>(dStruct->GetTag(dStruct->Desc()->TagIndex("X_PX_CM"))))[0]
+      ));
     return true;
   }
 
@@ -335,32 +442,36 @@
       = DLong(floor(0.5+
         ys * (*static_cast<DFloatGDL*>(dStruct->GetTag(dStruct->Desc()->TagIndex("Y_PX_CM"))))[0]
       ));
+    (*static_cast<DLongGDL*>(dStruct->GetTag(dStruct->Desc()->TagIndex("Y_VSIZE"))))[0]
+      = DLong(floor(0.5+
+        ys * (*static_cast<DFloatGDL*>(dStruct->GetTag(dStruct->Desc()->TagIndex("Y_PX_CM"))))[0]
+      ));
     return true;
   }
 
-  bool SetColor()
+  bool SetColor(const long hascolor)
   {
-    color=1;
+    if (hascolor==1) color=1; else color=0;
     return true;
   }
 
   bool SetPortrait()
   {
     orient_portrait = true;
-    XPageSize = 7 * 100. * GSL_CONST_MKSA_INCH;
-    YPageSize = 5 * 100. * GSL_CONST_MKSA_INCH; 
-    XOffset = .75 * 100. * GSL_CONST_MKSA_INCH; 
-    YOffset = 3 * 100. * GSL_CONST_MKSA_INCH; // TODO: this is different from IDL docs
+//    XPageSize = 7 * 100. * GSL_CONST_MKSA_INCH;
+//    YPageSize = 5 * 100. * GSL_CONST_MKSA_INCH;
+//    XOffset = .75 * 100. * GSL_CONST_MKSA_INCH;
+//    YOffset = 3 * 100. * GSL_CONST_MKSA_INCH; // TODO: this is different from IDL docs
     return true;
   }
 
   bool SetLandscape()
   {
     orient_portrait = false;
-    XPageSize = 10 * 100. * GSL_CONST_MKSA_INCH; 
-    YPageSize = 7 * 100. * GSL_CONST_MKSA_INCH; 
-    XOffset = .5 * 100. * GSL_CONST_MKSA_INCH; 
-    YOffset = .75 * 100. * GSL_CONST_MKSA_INCH;
+//    XPageSize = 10 * 100. * GSL_CONST_MKSA_INCH;
+//    YPageSize = 7 * 100. * GSL_CONST_MKSA_INCH;
+//    XOffset = .5 * 100. * GSL_CONST_MKSA_INCH;
+//    YOffset = .75 * 100. * GSL_CONST_MKSA_INCH;
     return true;
   }
 
@@ -372,7 +483,6 @@
 
   bool SetEncapsulated(bool val)
   {
-    // TODO ?: change XPageSize, YPageSize, XOffset, YOffset
     encapsulated = val;
     return true;
   }
@@ -404,8 +514,8 @@
     DDouble xmin, ymin;
     {
       DDouble null;
-      lib::get_axis_crange("X", xmin, null);
-      lib::get_axis_crange("Y", ymin, null);
+      lib::gdlGetCurrentAxisRange("X", xmin, null);
+      lib::gdlGetCurrentAxisRange("Y", ymin, null);
     }
     if (nParam == 2) {
       e->AssureLongScalarPar( 1, pos);
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/devicesvg.hpp gdl/src/devicesvg.hpp
--- gdl-0.9.3/src/devicesvg.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/devicesvg.hpp	2013-05-16 12:36:33.193857998 -0600
@@ -55,22 +55,30 @@
     // we want color
     actStream->scolor( 1);
 
-    // set color map
+    // avoid to set color map 0 -- makes plplot very slow (?)
     PLINT r[ctSize], g[ctSize], b[ctSize];
     actCT.Get( r, g, b);
-    //    actStream->scmap0( r, g, b, ctSize); 
-    actStream->scmap1( r, g, b, ctSize); 
+//    actStream->scmap0( r, g, b, ctSize);
+    actStream->scmap1( r, g, b, ctSize);
 
     actStream->SETOPT( "drvopt","text_clipping=1"); // clear drvopt
 
     actStream->Init();
     
+    // need to be called initially. permit to fix things
+    actStream->ssub(1,1);
+    actStream->adv(0);
     // load font
     actStream->font( 1);
+    actStream->vpor(0,1,0,1);
+    actStream->wind(0,1,0,1);
     actStream->DefaultCharSize();
+   //in case these are not initalized, here is a good place to do it.
+    if (actStream->updatePageInfo()==true)
+    {
+        actStream->GetPlplotDefaultCharSize(); //initializes everything in fact..
 
-    //    (*pMulti)[ 0] = 0;
-    actStream->adv(0);
+    }
   }
 
 public:
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/devicewin.hpp gdl/src/devicewin.hpp
--- gdl-0.9.3/src/devicewin.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/devicewin.hpp	2013-02-25 17:04:24.739180520 -0700
@@ -237,16 +237,20 @@
     winList[ wIx]->scmap1( r, g, b, ctSize); 
 
     winList[ wIx]->Init();
-    
+    // need to be called initially. permit to fix things
+    winList[ wIx]->ssub(1,1);
+    winList[ wIx]->adv(0);
     // load font
     winList[ wIx]->font( 1);
-    //actStream->DefaultCharSize();
-
-    //    (*pMulti)[ 0] = nx*ny;
-
-    // need to be called initially
-    winList[ wIx]->adv(0);
+    winList[ wIx]->vpor(0,1,0,1);
+    winList[ wIx]->wind(0,1,0,1);
+//    winList[ wIx]->DefaultCharSize();
+    //in case these are not initalized, here is a good place to do it.
+    if (winList[ wIx]->updatePageInfo()==true)
+    {
+        winList[ wIx]->GetPlplotDefaultCharSize(); //initializes everything in fact..
 
+    }
     // sets actWin and updates !D
     SetActWin( wIx);
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/devicex.hpp gdl/src/devicex.hpp
--- gdl-0.9.3/src/devicex.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/devicex.hpp	2013-05-16 12:36:33.201857969 -0600
@@ -25,8 +25,6 @@
 #include <vector>
 #include <cstring>
 
-//#include <plplot/plstream.h>
-#include <plplot/plplotP.h>
 #include <plplot/drivers.h>
 
 #include "gdlxstream.hpp"
@@ -55,12 +53,11 @@
   int decomposed; // false -> use color table
 
 
-  void plimage_gdl(unsigned char *idata, PLINT nx, PLINT ny, 
+  void plimage_gdl(PLStream* pls, unsigned char *idata, PLINT nx, PLINT ny, 
 		   DLong tru, DLong chan)
   {
-    PLINT ix, iy, xm, ym;
-
-    XwDev *dev = (XwDev *) plsc->dev;
+    PLINT ix, iy;
+    XwDev *dev = (XwDev *) pls->dev;
     XwDisplay *xwd = (XwDisplay *) dev->xwd;
     XImage *ximg = NULL, *ximg_pixmap = NULL;
 
@@ -68,13 +65,14 @@
 
     int (*oldErrorHandler)(Display*, XErrorEvent*);
 
-    if (plsc->level < 3) {
-      plabort("plimage: window must be set up first");
+    //the following 2 tests cannot happen i think. I keep them for safety.
+    if (pls->level < 3) {
+      std::cerr<<"plimage: window must be set up first"<<std::endl; //plabort() not available anymore!
       return ;
     }
 
     if (nx <= 0 || ny <= 0) {
-      plabort("plimage: nx and ny must be positive");
+      std::cerr<<"plimage: nx and ny must be positive"<<std::endl;
       return;
     }
 
@@ -114,16 +112,19 @@
 
       ncolors = 256;
 
-#if PL_RGB_COLOR == -1
-      free_mem(xwd->cmap1);
-      xwd->cmap1 = (XColor *) calloc(ncolors, (size_t) sizeof(XColor));
-#endif
+//#if PL_RGB_COLOR == -1 //was (always?) set by plplotP.h which we do not use anymore. 
+      if (xwd->ncol1 != ncolors)
+      {
+        free_mem(xwd->cmap1);
+        xwd->cmap1 = (XColor *) calloc(ncolors, (size_t) sizeof(XColor));
+      }
+//#endif
 
       for( SizeT i = 0; i < ncolors; i++ ) {
 
-	xwd->cmap1[i].red   = ToXColor(plsc->cmap1[i].r);
-	xwd->cmap1[i].green = ToXColor(plsc->cmap1[i].g);
-	xwd->cmap1[i].blue  = ToXColor(plsc->cmap1[i].b);
+	xwd->cmap1[i].red   = ToXColor(pls->cmap1[i].r);
+	xwd->cmap1[i].green = ToXColor(pls->cmap1[i].g);
+	xwd->cmap1[i].blue  = ToXColor(pls->cmap1[i].b);
 	xwd->cmap1[i].flags = DoRed | DoGreen | DoBlue;
 	
 	if ( XAllocColor( xwd->display, xwd->map, &xwd->cmap1[i]) == 0)
@@ -132,8 +133,8 @@
       xwd->ncol1 = ncolors;
     }
 
-    PLINT xoff = (PLINT) (plsc->wpxoff/32767 * dev->width  + 1);
-    PLINT yoff = (PLINT) (plsc->wpyoff/24575 * dev->height + 1);
+    PLINT xoff = (PLINT) (pls->wpxoff/32767 * dev->width  + 1);
+    PLINT yoff = (PLINT) (pls->wpyoff/24575 * dev->height + 1);
     PLINT kx, ky;
 
     XColor curcolor;
@@ -233,7 +234,8 @@
       {
 	long xsize,ysize,xoff,yoff;
 	winList[ wIx]->GetGeometry( xsize, ysize, xoff, yoff);
-
+    PLStream* pls;
+    plgpls( &pls);
 	// window size and pos
 // 	PLFLT xp; PLFLT yp; 
 // 	PLINT xleng; PLINT yleng;
@@ -246,7 +248,7 @@
 
         // number of colors (based on the color depth from PLPlot)
         (*static_cast<DLongGDL*>( dStruct->GetTag( n_colorsTag)))[0] = 
-          1 << (((static_cast<XwDisplay*>((static_cast<XwDev*>(plsc->dev))->xwd))->depth));
+          1 << (((static_cast<XwDisplay*>((static_cast<XwDev*>(pls->dev))->xwd))->depth));
       }	
 
     // window number
@@ -424,7 +426,7 @@
     PLFLT xp; PLFLT yp; 
     PLINT xleng; PLINT yleng;
     PLINT xoff; PLINT yoff;
-    winList[ wIx]->gpage( xp, yp, xleng, yleng, xoff, yoff);
+    winList[ wIx]->plstream::gpage( xp, yp, xleng, yleng, xoff, yoff);
 
     int debug=0;
     if (debug) cout <<xp<<" "<<yp<<" "<<xleng<<" "<<yleng<<" "<<xoff<<" "<<yoff<<endl;
@@ -434,12 +436,25 @@
 
     xleng = xSize;
     yleng = ySize;
-    xoff  = xPos;
-    yoff  = yMaxSize-(yPos+ySize);
+
+    bool noPos=(xPos==-1 && yPos==-1);
+    xPos=max(0,xPos);
+    yPos=max(0,yPos);
+    static PLINT Quadx[4]={xMaxSize-xSize,0,0,xMaxSize-xSize};
+    static PLINT Quady[4]={0,0,yMaxSize-ySize,yMaxSize-ySize};
+    if (noPos)
+    { //no init given, use 4 quadrants:
+        xoff = Quadx[wIx%4];
+        yoff = Quady[wIx%4];
+    } else {
+      xoff  = xPos==0?xMaxSize-xSize:xPos;
+      yoff  = yPos==0?yPos:yMaxSize-(yPos+ySize);
+    }
     if (yoff <= 0) yoff=1;
     
     if (debug) cout <<xp<<" "<<yp<<" "<<xleng<<" "<<yleng<<" "<<xoff<<" "<<yoff<<endl;
-
+    xp=max(xp,1.0);
+    yp=max(yp,1.0);
     winList[ wIx]->spage( xp, yp, xleng, yleng, xoff, yoff);
 
     // no pause on win destruction
@@ -460,23 +475,28 @@
     // we use our own window handling
     winList[ wIx]->SETOPT( "drvopt","usepth=0");
 
-    // set color map
+    // avoid to set color map 0 -- makes plplot very slow (?)
     PLINT r[ctSize], g[ctSize], b[ctSize];
     actCT.Get( r, g, b);
-    //    winList[ wIx]->scmap0( r, g, b, ctSize); 
-    winList[ wIx]->scmap1( r, g, b, ctSize); 
+//    winList[ wIx]->scmap0( r, g, b, ctSize);
+    winList[ wIx]->scmap1( r, g, b, ctSize);
 
     winList[ wIx]->Init();
     
+    // need to be called initially. permit to fix things
+    winList[ wIx]->ssub(1,1);
+    winList[ wIx]->adv(0);
     // load font
     winList[ wIx]->font( 1);
+    winList[ wIx]->vpor(0,1,0,1);
+    winList[ wIx]->wind(0,1,0,1);
     winList[ wIx]->DefaultCharSize();
+    //in case these are not initalized, here is a good place to do it.
+    if (winList[ wIx]->updatePageInfo()==true)
+    {
+        winList[ wIx]->GetPlplotDefaultCharSize(); //initializes everything in fact..
 
-    //    (*pMulti)[ 0] = nx*ny;
-
-    // need to be called initially
-    winList[ wIx]->adv(0);
-
+    }
     // sets actWin and updates !D
     SetActWin( wIx);
 
@@ -561,7 +581,7 @@
 	DString title = "GDL 0";
         DLong xSize, ySize;
         DefaultXYSize(&xSize, &ySize);
-	bool success = WOpen( 0, title, xSize, ySize, 0, 0);
+	bool success = WOpen( 0, title, xSize, ySize, -1, -1);
 	if( !success)
 	  return NULL;
 	if( actWin == -1)
@@ -603,6 +623,107 @@
     if( decomposed) return 1;
     return 0;
   }
+  
+  int OperateCG(XGCValues *gcValues, unsigned long valuemask, bool write) 
+  {
+    PLStream* pls;
+    plgpls( &pls);
+    XwDev *dev = (XwDev *) pls->dev;
+    if( dev == NULL || dev->xwd == NULL)
+    {
+      Graphics* actDevice = Graphics::GetDevice();
+      GDLGStream* newStream = actDevice->GetStream();
+      plgpls( &pls);
+      dev = (XwDev *) pls->dev;
+      if( dev == NULL) 
+      {
+        std::cerr<<"Device not open."<<std::endl;
+        return 0;
+      }
+    }
+    XwDisplay *xwd = (XwDisplay *) dev->xwd;
+    if (write)
+    {
+      XChangeGC(xwd->display, dev->gc, valuemask, gcValues);
+    }
+    else
+    {
+      XGetGCValues(xwd->display, dev->gc, valuemask, gcValues);
+    }
+    return 1;
+  }
+  bool SetGraphicsFunction( DLong value)                
+  { 
+    XGCValues gcValues;
+    gcValues.function   = max(0,min(value,15));
+    if (OperateCG(&gcValues, GCFunction, true)) return true;
+    else return false;
+  }
+  DLong GetGraphicsFunction()                
+  {
+    XGCValues gcValues;
+    if (OperateCG(&gcValues, GCFunction, false)) return (DLong)gcValues.function;
+    else return -1;
+  }
+  bool CursorStandard(int cursorNumber)
+  {
+    PLStream* pls;
+    plgpls( &pls);
+    int num=max(0,min(XC_num_glyphs-1,cursorNumber));
+    XwDev *dev = (XwDev *) pls->dev;
+    if( dev == NULL || dev->xwd == NULL)
+    {
+      Graphics* actDevice = Graphics::GetDevice();
+      GDLGStream* newStream = actDevice->GetStream();
+      plgpls( &pls);
+      dev = (XwDev *) pls->dev;
+      if( dev == NULL)
+      {
+        std::cerr<<"Device not open."<<std::endl;
+        return 0;
+      }
+    }
+    XwDisplay *xwd = (XwDisplay *) dev->xwd;
+    XDefineCursor(xwd->display,dev->window,XCreateFontCursor(xwd->display,num));
+    return true;
+  }
+  bool CursorCrosshair()
+  {
+    return CursorStandard(XC_crosshair);
+  }
+  bool UnsetFocus()
+  {
+    PLStream* pls;
+    plgpls( &pls);
+    XwDev *dev = (XwDev *) pls->dev;
+    if( dev == NULL) return false;
+    XwDisplay *xwd = (XwDisplay *) dev->xwd;
+    XWMHints gestw;
+    gestw.input = FALSE;
+    gestw.flags = InputHint;
+    XSetWMHints(xwd->display, dev->window, &gestw);
+    return true;
+  }
+  bool EnableBackingStore(bool enable)
+   {
+    PLStream* pls;
+    plgpls( &pls);
+    XwDev *dev = (XwDev *) pls->dev;
+    if( dev == NULL) return false;
+    XwDisplay *xwd = (XwDisplay *) dev->xwd;
+ 	XSetWindowAttributes attr;
+    if (enable)
+    {
+	 attr.backing_store = Always;
+    }
+    else
+    {
+	 attr.backing_store = NotUseful;
+    }
+    XChangeWindowAttributes(xwd->display, dev->window,CWBackingStore,&attr);
+    return true;
+  }
+
 
   int MaxWin() { ProcessDeleted(); return winList.size();}
   int ActWin() { ProcessDeleted(); return actWin;}
@@ -621,13 +742,15 @@
     //BadMatch error, and if you read the XGetImage doc you'll see that such errors are prone to happen
     //as soon as part of the window is obscured.
     int (*oldErrorHandler)(Display*, XErrorEvent*);
-
-    XwDev *dev = (XwDev *) plsc->dev;
+    PLStream* pls;
+    plgpls( &pls);
+    XwDev *dev = (XwDev *) pls->dev;
     if( dev == NULL || dev->xwd == NULL)
     {
       GDLGStream* newStream = actDevice->GetStream();
       //already done: newStream->Init();
-      dev = (XwDev *) plsc->dev;
+      plgpls( &pls);
+      dev = (XwDev *) pls->dev;
       if( dev == NULL) e->Throw( "Device not open.");
     }
 
@@ -812,6 +935,7 @@
     //    Graphics* actDevice = Graphics::GetDevice();
 
     SizeT nParam=e->NParam( 1); 
+    PLStream* pls;
 
     GDLGStream* actStream = GetStream();
     if( actStream == NULL)
@@ -822,8 +946,8 @@
 
     //    actStream->NextPlot( false);
     actStream->NoSub();
-
-    XwDev *dev = (XwDev *) plsc->dev;
+    plgpls( &pls);
+    XwDev *dev = (XwDev *) pls->dev;
     XwDisplay *xwd = (XwDisplay *) dev->xwd;
 
     int xSize, ySize, xPos, yPos;
@@ -843,7 +967,7 @@
     //DByteGDL* p0B = e->GetParAs<DByteGDL>( 0);
     DByteGDL* p0B;
     p0B =static_cast<DByteGDL*>(p0->Convert2(GDL_BYTE,BaseGDL::COPY));
-    e->Guard( p0B);
+    e->DeleteAtExit( p0B);
     
     int width, height;
     DLong tru=0;
@@ -943,9 +1067,9 @@
     if (channel < 0 || channel > 3)
       e->Throw("Value of Channel is out of allowed range.");
 
-    std::auto_ptr<BaseGDL> chan_guard;
+    Guard<BaseGDL> chan_guard;
     if (channel == 0) {
-      plimage_gdl(&(*p0B)[0], width, height, tru, channel);
+      plimage_gdl(pls, &(*p0B)[0], width, height, tru, channel);
     } else if (rank == 3) {
       // Rank == 3 w/channel
       SizeT dims[2];
@@ -957,11 +1081,11 @@
 	(*p0B_chan)[i/3] = (*p0B)[i];
       }
       // Send just single channel
-      plimage_gdl(&(*p0B_chan)[0], width, height, tru, channel);
-      chan_guard.reset( p0B_chan); // delete upon exit
+      plimage_gdl(pls, &(*p0B_chan)[0], width, height, tru, channel);
+      chan_guard.Init( p0B_chan); // delete upon exit
     } else if (rank == 2) {
       // Rank = 2 w/channel
-      plimage_gdl(&(*p0B)[0], width, height, tru, channel);
+      plimage_gdl(pls, &(*p0B)[0], width, height, tru, channel);
     }
   }
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/devicez.hpp gdl/src/devicez.hpp
--- gdl-0.9.3/src/devicez.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/devicez.hpp	2013-02-25 17:04:24.746180492 -0700
@@ -27,20 +27,20 @@
 #define SETOPT setopt
 #endif
 
-#ifdef _MSC_VER
-/* replacement of Unix rint() for Windows */
-static int rint (double x)
-{
-char *buf;
-int i,dec,sig;
-
-buf = _fcvt(x, 0, &dec, &sig);
-i = atoi(buf);
-if(sig == 1) {
-i = i * -1;
-}
-return(i);
-}
+#ifdef _MSC_VER
+/* replacement of Unix rint() for Windows */
+static int rint (double x)
+{
+char *buf;
+int i,dec,sig;
+
+buf = _fcvt(x, 0, &dec, &sig);
+i = atoi(buf);
+if(sig == 1) {
+i = i * -1;
+}
+return(i);
+}
 #endif
 
 class DeviceZ: public Graphics
@@ -154,13 +154,20 @@
     actStream->SETOPT( "drvopt","text=0"); // clear drvopt
 
     actStream->Init();
-    
+   // need to be called initially. permit to fix things
+    actStream->ssub(1,1);
+    actStream->adv(0);
     // load font
     actStream->font( 1);
+    actStream->vpor(0,1,0,1);
+    actStream->wind(0,1,0,1);
     actStream->DefaultCharSize();
+   //in case these are not initalized, here is a good place to do it.
+    if (actStream->updatePageInfo()==true)
+    {
+        actStream->GetPlplotDefaultCharSize(); //initializes everything in fact..
 
-    //    (*pMulti)[ 0] = 0;
-    actStream->adv(0);
+    }
   }
 
 public:
@@ -316,8 +323,8 @@
       }
     }
 
-    //    actStream->vpor( 0, 1.0, 0, 1.0);
-    // actStream->wind( 1-xLL, xsize-xLL, 1-yLL, ysize-yLL);
+    actStream->vpor( 0, 1.0, 0, 1.0);
+    actStream->wind( 1-xLL, xsize-xLL, 1-yLL, ysize-yLL);
 
     DByteGDL* p0B = e->GetParAs<DByteGDL>( 0);
     SizeT rank = p0B->Rank();
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/dinterpreter.cpp gdl/src/dinterpreter.cpp
--- gdl-0.9.3/src/dinterpreter.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/dinterpreter.cpp	2013-05-16 12:36:33.207857947 -0600
@@ -113,14 +113,14 @@
   return static_cast<DInterpreter*>( this)->InnerInterpreterLoop(lineOffset);
 }
 
-DStructGDL* GDLInterpreter::ObjectStruct( BaseGDL* self, ProgNodeP mp)
+DStructGDL* GDLInterpreter::ObjectStruct( DObjGDL* self, ProgNodeP mp)
 {
-  DType selfType = self->Type();
-  if( selfType != GDL_OBJ) 
-    throw GDLException( mp, "Object reference type"
-			" required in this context: "+Name(self));
+//   DType selfType = self->Type();
+//   if( selfType != GDL_OBJ) 
+//     throw GDLException( mp, "Object reference type"
+// 			" required in this context: "+Name(self));
 
-  DObjGDL* obj=static_cast<DObjGDL*>(self);
+  DObjGDL* obj=self;//static_cast<DObjGDL*>(self);
 
   SizeT o;
   if( !obj->Scalar( o))
@@ -143,22 +143,200 @@
   return oStructGDL;
 }
 
-DStructGDL* GDLInterpreter::ObjectStructCheckAccess( BaseGDL* self, ProgNodeP mp)
-{
-  DStructGDL* oStruct = ObjectStruct( self, mp);
-  
-  // check accessibility
-  DStructDesc* desc = oStruct->Desc();
-  if( !desc->IsParent( callStack.back()->GetPro()->Object()))
-    {
-      throw GDLException( mp, "Object of type "+desc->Name()+
-			  " is not accessible within "+
-			  callStack.back()->GetProName() + ": "+Name(self));
-    }
-  
-  return oStruct;
+void GDLInterpreter::SetRootL( ProgNodeP tt, DotAccessDescT* aD, BaseGDL* r, ArrayIndexListT* aL) 
+{ 
+  if( r->Type() == GDL_STRUCT)
+  {
+      if( r->IsAssoc())
+	  {
+	      ArrayIndexListGuard guard( aL);
+	      throw GDLException( tt, "File expression not allowed "
+				  "in this context: "+Name(r),true,false);
+	  }
+      DStructGDL* structR=static_cast<DStructGDL*>(r);
+      aD->ADRoot(structR, aL); 
+  }
+  else
+  {
+      if( r->Type() != GDL_OBJ)
+	  {
+	      throw GDLException( tt, "Expression must be a"
+				  " STRUCT in this context: "+Name(r),
+				  true,false);
+	  }
+
+      ArrayIndexListGuard guard( aL);
+
+      DStructGDL* oStruct = ObjectStruct( static_cast<DObjGDL*>(r), tt);
+      DStructDesc* desc = oStruct->Desc();
+
+      bool isObj = callStack.back()->IsObject();
+
+      if( desc->IsParent( GDL_OBJECT_NAME))
+	  {
+	    SizeT sss = 0;
+	    SizeT ooo = 0;
+	    if( isObj)
+	    {
+	      static_cast<DObjGDL*>(r)->Scalar( ooo); // checked in ObjectStruct
+
+	      BaseGDL* self = callStack.back()->GetKW(callStack.back()->GetPro()->NKey()); // SELF
+
+	      assert( dynamic_cast<DObjGDL*>(self) != NULL);
+
+	      if( !static_cast<DObjGDL*>(self)->Scalar( sss))
+		  throw GDLException( tt, "Internal error: SELF Object reference"
+				    " must be scalar in this context: "+Name(self));
+
+	      assert( sss != 0);
+	    }
+
+	    if( !isObj || (sss != ooo))
+	    {
+	      // call SetProperty
+		  throw GDLException( tt, "Calling SetProperty not yet implemented: "+Name(r));
+	      //return;
+	    }
+	  }
+
+      if( isObj) // member access to object?
+	  {
+	      if( !desc->IsParent( callStack.back()->GetPro()->Object()))
+		  {
+		      throw GDLException( tt, "Object of type "+desc->Name()+
+					  " is not accessible within "+
+					  callStack.back()->GetProName() + 
+					  ": "+Name(r));
+		  }
+	      // DStructGDL* oStruct = 
+	      //        ObjectStructCheckAccess( static_cast<DObjGDL*>(r), tt);
+
+	      // oStruct cannot be "Assoc_"
+	      aD->ADRoot( oStruct, guard.release()); 
+	  }
+      else
+	  {
+	      throw GDLException( tt, "Expression must be a"
+				  " STRUCT in this context: "+Name(r),
+				  true,false);
+	  }
+  }
+}
+
+void GDLInterpreter::SetRootR( ProgNodeP tt, DotAccessDescT* aD, BaseGDL* r, ArrayIndexListT* aL) 
+{ 
+// check here for object and get struct
+if( r->Type() == GDL_STRUCT)
+  {
+      if( r->IsAssoc())
+	  {
+	      ArrayIndexListGuard guard( aL);
+	      throw GDLException( tt, "File expression not allowed "
+				  "in this context: "+Name(r),true,false);
+	  }
+      DStructGDL* structR=static_cast<DStructGDL*>(r);
+      aD->ADRoot( structR, aL); 
+  }
+else
+  {
+      if( r->Type() != GDL_OBJ)
+	  {
+	      throw GDLException( tt, "Expression must be a"
+				  " STRUCT in this context: "+Name(r),
+				  true,false);
+	  }
+
+      ArrayIndexListGuard guard( aL);
+
+      DStructGDL* oStruct = ObjectStruct( static_cast<DObjGDL*>(r), tt);
+      DStructDesc* desc = oStruct->Desc();
+
+      bool isObj = callStack.back()->IsObject();
+
+      if( desc->IsParent( GDL_OBJECT_NAME))
+	  {
+	    SizeT sss = 0;
+	    SizeT ooo = 0;
+	    if( isObj)
+	    {
+	      static_cast<DObjGDL*>(r)->Scalar( ooo); // checked in ObjectStruct
+
+	      BaseGDL* self = callStack.back()->GetKW(callStack.back()->GetPro()->NKey()); // SELF
+
+	      assert( dynamic_cast<DObjGDL*>(self) != NULL);
+
+	      if( !static_cast<DObjGDL*>(self)->Scalar( sss))
+		  throw GDLException( tt, "Internal error: SELF Object reference"
+				    " must be scalar in this context: "+Name(self));
+
+	      assert( sss != 0);
+	    }
+
+	    if( !isObj || (sss != ooo))
+	    {
+	      // call GetProperty
+	      throw GDLException( tt, "Calling GetProperty not yet implemented: "+Name(r));
+
+	      //aD->ADRootGetProperty( oStruct, guard.release()); 
+	      return;
+	    }
+	  }
+
+      if( isObj)
+	  {
+	      if( !desc->IsParent( callStack.back()->GetPro()->Object()))
+		  {
+		      throw GDLException( tt, "Object of type "+desc->Name()+
+					  " is not accessible within "+
+					  callStack.back()->GetProName() + 
+					  ": "+Name(r));
+		  }
+	      // DStructGDL* oStruct = 
+	      //     ObjectStructCheckAccess( static_cast<DObjGDL*>(r), tt);
+
+	      if( aD->IsOwner()) delete r; 
+	      aD->SetOwner( false); // object struct, not owned
+	      
+	      aD->ADRoot( oStruct, guard.release()); 
+	  }
+      else
+	  {
+	      throw GDLException( tt, "Expression must be a"
+				  " STRUCT in this context: "+Name(r),true,false);
+	  }
+  }
 }
 
+// DStructDesc* GDLInterpreter::GDLObjectDesc( DStructGDL* oStruct, ProgNodeP mp)
+// {
+//   //DStructGDL* oStruct = ObjectStruct( self, mp);
+//   
+//   // check accessibility
+//   DStructDesc* desc = oStruct->Desc();
+//   if( !desc->IsParent( GDL_OBJECT_NAME))
+//     {
+//       return NULL;
+//     }
+//   
+//   return desc;
+// }
+// 
+// void GDLInterpreter::ObjectStructCheckAccess( DStructGDL* oStruct, ProgNodeP mp)
+// {
+//   //DStructGDL* oStruct = ObjectStruct( self, mp);
+//   
+//   // check accessibility
+//   DStructDesc* desc = oStruct->Desc();
+//   if( !desc->IsParent( callStack.back()->GetPro()->Object()))
+//     {
+//       throw GDLException( mp, "Object of type "+desc->Name()+
+// 			  " is not accessible within "+
+// 			  callStack.back()->GetProName() + ": "+Name(self));
+//     }
+//   
+//   //return oStruct;
+// }
+
 // searches and compiles procedure (searchForPro == true) or function (searchForPro == false)  'pro'
 bool GDLInterpreter::SearchCompilePro(const string& pro, bool searchForPro) 
 {
@@ -771,6 +949,20 @@
       return ExecuteCommand( line.substr(1));
     }
 
+  // command
+  if( firstChar == "?") 
+    {
+      // later, we will have to check whether we have X11/Display or not
+      // on some computing nodes on supercomputers, this is de-activated.
+      if (line.substr(1).length() > 0) {
+	line=line.substr(1);
+	StrTrim(line);
+	line="online_help, '"+line+"'"; //'
+      } else {
+	line="online_help";
+      }
+    }
+  
   // shell command
   if( firstChar == "$") 
     {
@@ -805,7 +997,7 @@
 
   RefDNode theAST;
   try { 
-    auto_ptr<GDLLexer> lexer;
+    Guard<GDLLexer> lexer;
 
     // LineContinuation LC
     // conactenate the strings and insert \n
@@ -815,17 +1007,17 @@
     int lCNum = 0;
     for(;;) 
       {
-	lexer.reset( new GDLLexer(executeLine, "", callStack.back()->CompileOpt()));
+	lexer.Reset( new GDLLexer(executeLine, "", callStack.back()->CompileOpt()));
 	try {
 	  // works, but ugly -> depends from parser detecting an error
 	  // (which it always will due to missing END_U token in case of LC)
  	  //lexer->Parser().SetCompileOpt(callStack.back()->CompileOpt());
- 	  lexer->Parser().interactive();
+ 	  lexer.Get()->Parser().interactive();
 	  break; // no error -> everything ok
 	}
 	catch( GDLException& e)
 	  {
-	    int lCNew = lexer->LineContinuation();
+	    int lCNew = lexer.Get()->LineContinuation();
 	    if( lCNew == lCNum)
 // 	      throw; // no LC -> real error
 	{
@@ -868,7 +1060,7 @@
       } 
     
     //    lexer->Parser().interactive();
-    theAST = lexer->Parser().getAST();
+    theAST = lexer.Get()->Parser().getAST();
 
   }
   catch( GDLException& e)
@@ -946,7 +1138,7 @@
       cerr << "Compiler exception: " <<  e.getMessage() << endl;
       return CC_OK;
     }
-  auto_ptr< ProgNode> progAST_guard( progAST);
+  Guard< ProgNode> progAST_guard( progAST);
 
   try
     {
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/dpro.hpp gdl/src/dpro.hpp
--- gdl-0.9.3/src/dpro.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/dpro.hpp	2013-03-21 14:04:04.302825523 -0600
@@ -115,14 +115,14 @@
   // N=size(key)
   // K=size(var)-nPar-N
   IDList              key;    // keyword names (IDList: typedefs.hpp)
-                              // (KEYWORD_NAME=keyword_value)
+			      // (KEYWORD_NAME=keyword_value)
   int                 nPar;   // number of parameters (-1 = infinite)
   int                 nParMin;  // minimum number of parameters (-1 = infinite)
 
   ExtraType           extra;
   int                 extraIx; // index of extra keyword
 
-  IDList  warnKey;    // keyword names to accept but warn
+  IDList              warnKey;    // keyword names to accept but warn
   // (IDList: typedefs.hpp)
 
 public:
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/dstructdesc.hpp gdl/src/dstructdesc.hpp
--- gdl-0.9.3/src/dstructdesc.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/dstructdesc.hpp	2013-03-21 14:04:04.303825519 -0600
@@ -18,6 +18,8 @@
 #ifndef DSTRUCTDESC_HPP_
 #define DSTRUCTDESC_HPP_
 
+#include "includefirst.hpp" // USE_EIGEN3
+
 #include <vector>
 #include <deque>
 #include <string>
@@ -43,11 +45,16 @@
   // and DStringGDL (considers actual string sizes)
   SizeT nBytes = tags.back()->NBytes();
 
-  // alignment
-  const int sizeOfPtr = sizeof( char*);
-  SizeT exceed = nBytes % sizeOfPtr;
+  // alignment 
+#ifdef USE_EIGEN3
+  assert( sizeof( char*) <= 16); 
+  const int alignmentInBytes = 16; // set to multiple of 16 >= sizeof( char*)
+#else
+  const int alignmentInBytes = sizeof( char*);
+#endif
+  SizeT exceed = nBytes % alignmentInBytes;
   if( exceed > 0)
-	nBytes += sizeOfPtr - exceed;
+	nBytes += alignmentInBytes - exceed;
 
   // valid tagOffset (used by NBytes())
   tagOffset.push_back( tagOffset.back() + nBytes);
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/dstructgdl.cpp gdl/src/dstructgdl.cpp
--- gdl-0.9.3/src/dstructgdl.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/dstructgdl.cpp	2013-05-16 12:36:33.213857926 -0600
@@ -923,3 +923,523 @@
   return aD.ADResolve();
 }
 
+// basic_op_add.cpp
+DStructGDL* DStructGDL::Add( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::AddInv( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::AddS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::AddInvS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+// basic_op_sub.cpp
+DStructGDL* DStructGDL::Sub( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::SubInv( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::SubS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::SubInvS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+
+// datatypes.cpp
+int DStructGDL::Scalar2Index( SizeT& st) const
+{
+  throw GDLException("STRUCT expression not allowed in this context.");
+  return 0; // get rid of warning
+}
+int DStructGDL::Scalar2RangeT( RangeT& st) const
+{
+  throw GDLException("STRUCT expression not allowed in this context.");
+  return 0; // get rid of warning
+}
+RangeT DStructGDL::LoopIndex() const
+{
+  throw GDLException("STRUCT expression not allowed in this context.");
+  return 0; // get rid of warning
+}
+int DStructGDL::Sgn() // -1,0,1
+{
+  throw GDLException("Struct expression not allowed in this context.");
+  return 0;
+} 
+
+bool DStructGDL::EqualNoDelete( const BaseGDL* r) const
+{
+  throw GDLException("Struct expression not allowed in this context.");
+  return false;
+}
+
+void DStructGDL::MinMax( DLong* minE, DLong* maxE, 
+			 BaseGDL** minVal, BaseGDL** maxVal, bool omitNaN,
+			 SizeT start, SizeT stop, SizeT step, DLong valIx)
+{
+  throw GDLException("Struct expression not allowed in this context.");
+}
+
+
+// basic_op_mult.cpp
+DStructGDL* DStructGDL::Mult( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::MultS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+// basic_op_div.cpp
+DStructGDL* DStructGDL::Div( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::DivInv( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::DivS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::DivInvS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+// basic_op_new.cpp
+DStructGDL* DStructGDL::AndOpNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::AndOpInvNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::AndOpSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::AndOpInvSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::OrOpNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::OrOpInvNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+
+DStructGDL* DStructGDL::OrOpSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::OrOpInvSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::XorOpNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::XorOpSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+DStructGDL* DStructGDL::AddNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::AddInvNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+DStructGDL* DStructGDL::AddSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::AddInvSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+DStructGDL* DStructGDL::SubNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::SubInvNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+DStructGDL* DStructGDL::SubSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::SubInvSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+DStructGDL* DStructGDL::LtMarkNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+DStructGDL* DStructGDL::LtMarkSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+
+DStructGDL* DStructGDL::GtMarkNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+DStructGDL* DStructGDL::GtMarkSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+
+DStructGDL* DStructGDL::MultNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+
+DStructGDL* DStructGDL::MultSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+DStructGDL* DStructGDL::DivNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::DivInvNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+DStructGDL* DStructGDL::DivSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::DivInvSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+DStructGDL* DStructGDL::ModNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::ModInvNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::ModSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::ModInvSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::PowIntNew( BaseGDL* r)
+{
+  assert( 0);
+  throw GDLException("Internal error: DStructGDL::PowIntNew called.",true,false);  
+  return NULL;
+}
+
+DStructGDL* DStructGDL::PowNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::PowInvNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+DStructGDL* DStructGDL::PowSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+DStructGDL* DStructGDL::PowInvSNew( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+
+// basic_op.cpp
+DStructGDL* DStructGDL::NotOp()
+{
+  throw GDLException("Cannot apply operation to datatype "+str+".",true,false);  
+  return this;
+}
+
+BaseGDL* DStructGDL::UMinus()
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+BaseGDL* DStructGDL::EqOp( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+BaseGDL* DStructGDL::NeOp( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+BaseGDL* DStructGDL::LeOp( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+BaseGDL* DStructGDL::LtOp( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+BaseGDL* DStructGDL::GeOp( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+BaseGDL* DStructGDL::GtOp( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+DStructGDL* DStructGDL::MatrixOp( BaseGDL* r, bool atranspose, bool btranspose)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return NULL;
+}
+
+DStructGDL* DStructGDL::AndOp( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::AndOpInv( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+DStructGDL* DStructGDL::AndOpS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::AndOpInvS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+DStructGDL* DStructGDL::OrOp( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::OrOpInv( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+
+DStructGDL* DStructGDL::OrOpS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::OrOpInvS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+
+
+DStructGDL* DStructGDL::XorOp( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+
+
+
+DStructGDL* DStructGDL::XorOpS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+DStructGDL* DStructGDL::LtMark( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+
+DStructGDL* DStructGDL::LtMarkS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+DStructGDL* DStructGDL::GtMark( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+
+DStructGDL* DStructGDL::GtMarkS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+
+DStructGDL* DStructGDL::Mod( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::ModInv( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+DStructGDL* DStructGDL::ModS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::ModInvS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+
+DStructGDL* DStructGDL::PowInt( BaseGDL* r)
+{
+  assert( 0);
+  return this;
+}
+
+DStructGDL* DStructGDL::PowS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::PowInvS( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::Pow( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+DStructGDL* DStructGDL::PowInv( BaseGDL* r)
+{
+  throw GDLException("Cannot apply operation to datatype STRUCT.",true,false);  
+  return this;
+}
+
+
+
+
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/dstructgdl.hpp gdl/src/dstructgdl.hpp
--- gdl-0.9.3/src/dstructgdl.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/dstructgdl.hpp	2013-05-16 12:36:33.219857904 -0600
@@ -43,7 +43,11 @@
   
   //public:
   std::deque<BaseGDL*> typeVar;   // for accessing data
-  DataT                dd;        // the data
+#ifdef USE_EIGEN  
+  EIGEN_ALIGN16 DataT        dd; // the data
+#else
+  DataT                      dd; // the data
+#endif
     
   void InitTypeVar( SizeT t)
   {
@@ -436,7 +440,7 @@
   // members
   // used by the interpreter
   // throws (datatypes.cpp)
-  int Scalar2index( SizeT& st) const;
+  int Scalar2Index( SizeT& st) const;
   int Scalar2RangeT( RangeT& st) const;
   RangeT LoopIndex() const;
 
@@ -565,7 +569,7 @@
   DStructGDL*   Pow( BaseGDL* r);
   DStructGDL*   PowInv( BaseGDL* r);
   DStructGDL*   PowInt( BaseGDL* r);
-  DStructGDL*   MatrixOp( BaseGDL* r,bool,bool,bool);
+  DStructGDL*   MatrixOp( BaseGDL* r, bool atranspose, bool btranspose);
 
 
   DStructGDL*   AndOpS( BaseGDL* r);
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/envt.cpp gdl/src/envt.cpp
--- gdl-0.9.3/src/envt.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/envt.cpp	2013-03-25 10:36:38.305970094 -0600
@@ -19,12 +19,12 @@
 
 #include <iomanip>
 
+#include "envt.hpp"
 #include "objects.hpp"
 #include "dinterpreter.hpp"
-#include "envt.hpp"
 #include "basic_pro.hpp"
 
-#include <assert.h> // always as last
+#include <cassert> // always as last
 
 using namespace std;
 
@@ -166,8 +166,13 @@
   lastJump( -1)
 {
   obj = true;
+
+  DType selfType = self->Type();
+  if( selfType != GDL_OBJ) 
+    throw GDLException( cN, "Object reference type"
+			" required in this context: "+interpreter->Name(self));
   
-  DStructGDL* oStructGDL = interpreter->ObjectStruct( self, cN);
+  DStructGDL* oStructGDL = interpreter->ObjectStruct( static_cast<DObjGDL*>(self), cN);
 
   const string& mp = cN->getText();
 
@@ -219,7 +224,12 @@
 {
   obj = true;
 
-  DStructGDL* oStructGDL = interpreter->ObjectStruct( self, cN);
+  DType selfType = self->Type();
+  if( selfType != GDL_OBJ) 
+    throw GDLException( cN, "Object reference type"
+			" required in this context: "+interpreter->Name(self));
+  
+  DStructGDL* oStructGDL = interpreter->ObjectStruct( static_cast<DObjGDL*>(self), cN);
 
   const string& mp = cN->getText();
 
@@ -417,6 +427,7 @@
 	  }
 }
 
+typedef std::vector<DObj> VectorDObj;
 void EnvT::HeapGC( bool doPtr, bool doObj, bool verbose)
 {
   // within CLEANUP method HEAP_GC could be called again
@@ -474,8 +485,8 @@
     if( doObj)
       {
 	std::vector<DObj>* heap = interpreter->GetAllObjHeapSTL();
-	auto_ptr< std::vector<DObj> > heap_guard( heap);
-	    SizeT nH = heap->size();//N_Elements();
+	Guard< std::vector<DObj> > heap_guard( heap);
+	SizeT nH = heap->size();//N_Elements();
 	if( nH > 0 && (*heap)[0] != 0)
 	  {
 	    for( SizeT h=0; h<nH; ++h)
@@ -502,7 +513,7 @@
     if( doPtr)
       {
 	std::vector<DPtr>* heap = interpreter->GetAllHeapSTL();
-	auto_ptr< std::vector<DPtr> > heap_guard( heap);
+	Guard< std::vector<DPtr> > heap_guard( heap);
 	    SizeT nH = heap->size();
 	if( nH > 0 && (*heap)[0] != 0)
 	  {
@@ -571,7 +582,7 @@
 		  if( objCLEANUP != NULL)
 		  {
 		    BaseGDL* actObjGDL = new DObjGDL( actID);
-		    auto_ptr<BaseGDL> actObjGDL_guard( actObjGDL);
+		    Guard<BaseGDL> actObjGDL_guard( actObjGDL);
 		    GDLInterpreter::IncRefObj( actID); // set refcount to 1
 	    
 		    PushNewEmptyEnvUD( objCLEANUP, &actObjGDL);
@@ -625,7 +636,7 @@
 			if( objCLEANUP != NULL)
 				{
 				BaseGDL* actObjGDL = new DObjGDL( actID);
-				auto_ptr<BaseGDL> actObjGDL_guard( actObjGDL);
+				Guard<BaseGDL> actObjGDL_guard( actObjGDL);
 				GDLInterpreter::IncRefObj( actID);
 			
 				PushNewEnvUD( objCLEANUP, 1, &actObjGDL);
@@ -1103,6 +1114,12 @@
   return pro->FindKey( k);
 }
 
+bool EnvT::KeywordPresent( const std::string& kw)
+{
+  int ix = KeywordIx( kw);
+  return (env[ix] != NULL);
+}
+
 const string EnvBaseT::GetString( SizeT ix)
   {
     const string unnamed("<INTERNAL_VAR>");
@@ -1386,7 +1403,7 @@
 {
   BaseGDL* p = GetParDefined( pIx);
   DLong64GDL* lp = static_cast<DLong64GDL*>(p->Convert2( GDL_LONG64, BaseGDL::COPY));
-  auto_ptr<DLong64GDL> guard_lp( lp);
+  Guard<DLong64GDL> guard_lp( lp);
   if( !lp->Scalar( scalar))
     Throw("Parameter must be a scalar in this context: "+
 		       GetParString(pIx));
@@ -1395,7 +1412,7 @@
 {
   BaseGDL* p = GetParDefined( pIx);
   DLongGDL* lp = static_cast<DLongGDL*>(p->Convert2( GDL_LONG, BaseGDL::COPY));
-  auto_ptr<DLongGDL> guard_lp( lp);
+  Guard<DLongGDL> guard_lp( lp);
   if( !lp->Scalar( scalar))
     Throw("Parameter must be a scalar in this context: "+
 		       GetParString(pIx));
@@ -1436,7 +1453,7 @@
   
   DLongGDL* lp= static_cast<DLongGDL*>(p->Convert2( GDL_LONG, BaseGDL::COPY));
   
-  auto_ptr<DLongGDL> guard_lp( lp);
+  Guard<DLongGDL> guard_lp( lp);
 
   if( !lp->Scalar( scalar))
     Throw("Expression must be a scalar in this context: "+
@@ -1447,7 +1464,7 @@
 {
   BaseGDL* p = GetParDefined( pIx);
   DDoubleGDL* lp = static_cast<DDoubleGDL*>(p->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-  auto_ptr<DDoubleGDL> guard_lp( lp);
+  Guard<DDoubleGDL> guard_lp( lp);
   if( !lp->Scalar( scalar))
     Throw("Parameter must be a scalar in this context: "+
 		       GetParString(pIx));
@@ -1478,7 +1495,7 @@
   
   DDoubleGDL* lp= static_cast<DDoubleGDL*>(p->Convert2( GDL_DOUBLE, BaseGDL::COPY));
   
-  auto_ptr<DDoubleGDL> guard_lp( lp);
+  Guard<DDoubleGDL> guard_lp( lp);
 
   if( !lp->Scalar( scalar))
     Throw("Expression must be a scalar in this context: "+
@@ -1490,7 +1507,7 @@
 {
   BaseGDL* p = GetParDefined( pIx);
   DFloatGDL* lp = static_cast<DFloatGDL*>(p->Convert2( GDL_FLOAT, BaseGDL::COPY));
-  auto_ptr<DFloatGDL> guard_lp( lp);
+  Guard<DFloatGDL> guard_lp( lp);
   if( !lp->Scalar( scalar))
     Throw("Parameter must be a scalar in this context: "+
 		       GetParString(pIx));
@@ -1521,7 +1538,7 @@
   
   DFloatGDL* lp= static_cast<DFloatGDL*>(p->Convert2( GDL_FLOAT, BaseGDL::COPY));
   
-  auto_ptr<DFloatGDL> guard_lp( lp);
+  Guard<DFloatGDL> guard_lp( lp);
 
   if( !lp->Scalar( scalar))
     Throw("Expression must be a scalar in this context: "+
@@ -1533,7 +1550,7 @@
 {
   BaseGDL* p = GetParDefined( pIx);
   DStringGDL* lp = static_cast<DStringGDL*>(p->Convert2( GDL_STRING, BaseGDL::COPY));
-  auto_ptr<DStringGDL> guard_lp( lp);
+  Guard<DStringGDL> guard_lp( lp);
   if( !lp->Scalar( scalar))
     Throw("Parameter must be a scalar in this context: "+
 		       GetParString(pIx));
@@ -1562,7 +1579,7 @@
     Throw("Expression undefined: "+GetString(eIx));
   
   DStringGDL* lp= static_cast<DStringGDL*>(p->Convert2( GDL_STRING, BaseGDL::COPY));
-  auto_ptr<DStringGDL> guard_lp( lp);
+  Guard<DStringGDL> guard_lp( lp);
 
   if( !lp->Scalar( scalar))
     Throw("Expression must be a scalar in this context: "+
@@ -1572,7 +1589,7 @@
 void EnvT::SetKW( SizeT ix, BaseGDL* newVal)
 {
   // can't use Guard here as data has to be released
-  auto_ptr<BaseGDL> guard( newVal);
+  Guard<BaseGDL> guard( newVal);
   AssureGlobalKW( ix);
   GDLDelete(GetKW( ix));
   GetKW( ix) = guard.release();
@@ -1580,7 +1597,7 @@
 void EnvT::SetPar( SizeT ix, BaseGDL* newVal)
 {
   // can't use Guard here as data has to be released
-  auto_ptr<BaseGDL> guard( newVal);
+  Guard<BaseGDL> guard( newVal);
   AssureGlobalPar( ix);
   GDLDelete(GetPar( ix));
   GetPar( ix) = guard.release();
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/envt.hpp gdl/src/envt.hpp
--- gdl-0.9.3/src/envt.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/envt.hpp	2013-03-25 10:36:38.307970085 -0600
@@ -62,7 +62,7 @@
   // upon library routines exit (normal or on error)
   // elimates the need of auto_ptr and in some places later destruction is needed
   
-  void Guard( BaseGDL* toGuard)
+  void DeleteAtExit( BaseGDL* toGuard)
     {
 // 		if( toDestroy == NULL)
 // 			toDestroy = new ContainerT();
@@ -343,7 +343,7 @@
 		return;
     }
     // this should never happen (or only in extreme rarely cases)
-    // hence the performance will go down
+    // the performance will go down
     // s > defaultLength
     T* newArr = new T[ s]; // ctor called
 	if( eArr != reinterpret_cast<T*>(buf))
@@ -368,8 +368,8 @@
 // T operator[]( SizeT i) const { assert( i<sz);  return eArr[i];}
 T& operator[]( SizeT i) { assert( i<sz);  return eArr[i];}
 SizeT size() const { return sz;}
-iterator begin()  { return &eArr[0];}
-iterator end()  { return &eArr[sz];}
+iterator begin() const { return &eArr[0];}
+iterator end() const { return &eArr[sz];}
 bool empty() const { return sz == 0;}
 T& front() { return eArr[0];}
 const T& front() const { return eArr[0];}
@@ -423,6 +423,9 @@
 
   DLong GetOnError() const { return onError;}
 
+  ProgNodeP GetCatchNode() const { return catchNode;} 
+  BaseGDL** GetCatchVar() const { return catchVar;} 
+
   SizeT NJump() const { return nJump;}
   int   LastJump() const { return lastJump;}
   ProgNodeP GotoTarget( int ix)
@@ -588,7 +591,7 @@
 //     T* res = dynamic_cast<T*>( p);
 //     if( res != NULL) return res;
     T* res = static_cast<T*>( p->Convert2( T::t, BaseGDL::COPY));
-    Guard( res);
+    this->DeleteAtExit( res);
     return res;
   }
   // same as before for keywords
@@ -603,7 +606,7 @@
 //     T* res = dynamic_cast<T*>( p);
 //     if( res != NULL) return res;
     T* res = static_cast<T*>( p->Convert2( T::t, BaseGDL::COPY));
-    Guard( res);
+    this->DeleteAtExit( res);
     return res;
   }
 
@@ -618,7 +621,7 @@
 //     T* res = dynamic_cast<T*>( p);
 //     if( res != NULL) return res;
     T* res = static_cast<T*>( p->Convert2( T::t, BaseGDL::COPY));
-    Guard( res);
+    this->DeleteAtExit( res);
     return res;
   }
   // same as before for keywords
@@ -632,7 +635,7 @@
 //     T* res = dynamic_cast<T*>( p);
 //     if( res != NULL) return res;
     T* res = static_cast<T*>( p->Convert2( T::t, BaseGDL::COPY));
-    Guard( res);
+    this->DeleteAtExit( res);
     return res;
   }
 
@@ -661,7 +664,8 @@
   // this one together with a static int holding the index is faster
   // (after the first call)
   bool KeywordSet( SizeT ix);
-
+  // GD added -- possibly very wrong?
+  bool KeywordPresent( const std::string& kw);
   bool KeywordPresent( SizeT ix)
   { return EnvBaseT::KeywordPresent( ix);}
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/fftw.cpp gdl/src/fftw.cpp
--- gdl-0.9.3/src/fftw.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/fftw.cpp	2013-03-25 10:36:38.308970080 -0600
@@ -77,7 +77,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-	for( int i=0; i<nEl; ++i) {
+	for( OMPInt i=0; i<nEl; ++i) {
 	  out[i][0] /= nEl;
 	  out[i][1] /= nEl;
 	}
@@ -108,7 +108,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 {
 #pragma omp for
-	for( int i=0; i<nEl; ++i) {
+	for( OMPInt i=0; i<nEl; ++i) {
 	  out_f[i][0] /= nEl;
 	  out_f[i][1] /= nEl;
 	}
@@ -176,11 +176,11 @@
 
       DComplexDblGDL *p0C;
 
-      auto_ptr<BaseGDL> guard_p0C;
+      Guard<BaseGDL> guard_p0C;
 
       if( p0->Type() != GDL_COMPLEXDBL) {
 	p0C = static_cast<DComplexDblGDL*>(p0->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY));
-        guard_p0C.reset(p0C); 
+        guard_p0C.Init(p0C); 
       } else
       {
 	  if( overwrite)
@@ -209,7 +209,7 @@
 
       DComplexGDL* p0C = static_cast<DComplexGDL*>
 	(p0->Convert2( GDL_COMPLEX, BaseGDL::COPY));
-      auto_ptr<BaseGDL> guard_p0C( p0C); 
+      Guard<BaseGDL> guard_p0C( p0C); 
       return fftw_template< DComplexGDL> (p0C, nEl, dbl, overwrite, direct);
 
     }
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/gdlarray.hpp gdl/src/gdlarray.hpp
--- gdl-0.9.3/src/gdlarray.hpp	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/gdlarray.hpp	2013-03-25 10:36:38.327969992 -0600
@@ -0,0 +1,322 @@
+/***************************************************************************
+                          gdlarray.hpp  -  basic typedefs
+                             -------------------
+    begin                : July 22 2002
+    copyright            : (C) 2002 by Marc Schellens
+    email                : m_schellens@users.sf.net
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef GDLARRAY_HPP_
+#define GDLARRAY_HPP_
+
+// #define GDLARRAY_CACHE
+#undef GDLARRAY_CACHE
+
+//#define GDLARRAY_DEBUG
+#undef GDLARRAY_DEBUG
+
+// for complex (of POD)
+const bool TreatPODComplexAsPOD = true;
+
+template <typename T, bool IsPOD>
+class GDLArray
+{
+private:
+	enum GDLArrayConstants
+	{
+		smallArraySize = 27,
+		maxCache = 1000 * 1000 // ComplexDbl is 16 bytes
+	};
+		
+	typedef T Ty;
+
+#ifdef USE_EIGEN  
+  EIGEN_ALIGN16 char scalarBuf[ smallArraySize * sizeof(Ty)];
+#else
+  char scalarBuf[ smallArraySize * sizeof(Ty)];
+#endif
+  
+  Ty* InitScalar()
+  {
+    assert( sz <= smallArraySize);
+    if( IsPOD)
+    {
+      return reinterpret_cast<Ty*>(scalarBuf);
+    }
+    else
+    {
+      Ty* b = reinterpret_cast<Ty*>(scalarBuf); 
+      for( int i = 0; i<sz; ++i) 
+	new (&(b[ i])) Ty();
+      return b;
+    }
+  }
+
+#ifdef GDLARRAY_CACHE
+#error "GDLARRAY_CACHE defined"
+  static SizeT cacheSize;
+  static Ty* cache;
+  static Ty* Cached( SizeT newSize);
+#endif
+  
+  Ty*   buf;
+  SizeT sz;
+
+  Ty* New( SizeT s)
+  {
+// better align all data, also POD    
+// as compound types might benefit from it as well
+#ifdef USE_EIGEN 
+    return Eigen::internal::aligned_new<Ty>( s);
+#else
+    return new Ty[ s];
+#endif
+  }
+    
+public:
+  GDLArray() throw() : buf( NULL), sz( 0) {}
+  
+#ifndef GDLARRAY_CACHE
+
+  ~GDLArray() throw()
+  {
+  if( IsPOD)
+    {
+#ifdef USE_EIGEN  
+    if( buf != reinterpret_cast<Ty*>(scalarBuf)) 
+	Eigen::internal::aligned_delete( buf, sz);
+#else
+    if( buf != reinterpret_cast<Ty*>(scalarBuf)) 
+	delete[] buf; // buf == NULL also possible
+#endif
+    // no cleanup of "buf" here
+    }
+  else
+    {
+#ifdef USE_EIGEN  
+    if( buf != reinterpret_cast<Ty*>(scalarBuf)) 
+	Eigen::internal::aligned_delete( buf, sz);
+    else
+      for( int i = 0; i<sz; ++i) 
+	buf[i].~Ty();
+#else
+    if( buf != reinterpret_cast<Ty*>(scalarBuf)) 
+	delete[] buf; // buf == NULL also possible
+    else
+      for( int i = 0; i<sz; ++i) 
+	buf[i].~Ty();
+#endif
+    }
+  }
+
+  GDLArray( const GDLArray& cp) : sz( cp.size())
+  {
+    if( IsPOD)
+    {
+      try {
+	  buf = (cp.size() > smallArraySize) ? New(cp.size()) /*New T[ cp.size()]*/ : InitScalar();
+      } catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than available"); }
+
+      std::memcpy(buf,cp.buf,sz*sizeof(T));
+    }
+    else
+    {
+      try {
+	buf = (cp.size() > smallArraySize) ? New(cp.size()) /*new Ty[ cp.size()]*/ : InitScalar();
+      } catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than available"); }
+      for( SizeT i=0; i<sz; ++i)
+	buf[ i] = cp.buf[ i];
+    }
+  }
+
+  GDLArray( SizeT s, bool dummy) : sz( s)
+  {
+    try {
+      buf = (s > smallArraySize) ? New(s) /*T[ s]*/ : InitScalar();
+    } catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than available"); }
+  }
+  
+  GDLArray( T val, SizeT s) : sz( s)
+  {
+    try {
+	    buf = (s > smallArraySize) ? New(s) /*T[ s]*/ : InitScalar();
+    } catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than available"); }
+
+    for( SizeT i=0; i<sz; ++i)
+      buf[ i] = val;
+  }
+  
+  GDLArray( const T* arr, SizeT s) : sz( s)
+  {
+    if( IsPOD)
+    {
+      try
+      {
+	      buf = ( s > smallArraySize ) ? New(s) /*T[ s]*/: InitScalar();
+      }
+      catch ( std::bad_alloc& ) { ThrowGDLException ( "Array requires more memory than available" ); }
+
+      std::memcpy(buf,arr,sz*sizeof(T));
+    }
+    else
+    {    
+      try {
+	buf = (s > smallArraySize) ? New(s) /*new Ty[ s]*/: InitScalar();
+      } catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than available"); }
+      for( SizeT i=0; i<sz; ++i)
+	buf[ i] = arr[ i];
+      }
+  }
+
+#else // GDLARRAY_CACHE
+
+  // use definition in datatypes.cpp
+  GDLArray( const GDLArray& cp) ;
+  GDLArray( SizeT s, bool b) ;
+  GDLArray( T val, SizeT s) ;
+  GDLArray( const T* arr, SizeT s) ;
+  ~GDLArray() throw();
+
+#endif // GDLARRAY_CACHE
+  
+  // scalar
+  explicit GDLArray( const T& s) throw() : sz( 1)
+  { 
+    if( IsPOD)
+    {
+      buf = reinterpret_cast<Ty*>(scalarBuf);
+      buf[0] = s;    
+    }
+    else
+    {
+      Ty* b = reinterpret_cast<Ty*>(scalarBuf); 
+      new (&(b[ 0])) Ty( s);
+      buf = b;
+    }
+  }
+
+  T& operator[]( SizeT ix) throw()
+  {
+    // if( ix >= sz) 
+    assert( ix < sz);
+    return buf[ ix];
+  }
+  const T& operator[]( SizeT ix) const throw()
+  {
+//     if( ix >= sz) // debug 
+      assert( ix < sz);
+    return buf[ ix];
+  }
+
+// private: // disable
+// only used (indirect) by DStructGDL::DStructGDL(const DStructGDL& d_)
+void InitFrom( const GDLArray& right )
+{
+  assert( &right != this);
+  assert ( sz == right.size() );
+  if( IsPOD)
+  {
+    std::memcpy(buf,right.buf,sz*sizeof(Ty));
+  }
+  else
+  {
+    for ( SizeT i=0; i<sz; ++i )
+	buf[ i] = right.buf[ i];
+  }    
+}
+
+GDLArray& operator= ( const GDLArray& right )
+{
+  assert( this != &right);
+  assert( sz == right.size());
+  if( IsPOD)
+  {
+    std::memcpy(buf,right.buf,sz*sizeof(Ty));
+  }
+  else
+  {
+    for ( SizeT i=0; i<sz; ++i )
+      buf[ i] = right.buf[ i];
+    return *this;
+  }
+}
+
+  GDLArray& operator+=( const GDLArray& right) throw()
+  {
+    for( SizeT i=0; i<sz; ++i)
+      buf[ i] += right.buf[ i];
+    return *this;
+  }
+  GDLArray& operator-=( const GDLArray& right) throw()
+  {
+    for( SizeT i=0; i<sz; ++i)
+      buf[ i] -= right.buf[ i];
+    return *this;
+  }
+
+  GDLArray& operator+=( const T& right) throw()
+  {
+    for( SizeT i=0; i<sz; ++i)
+      buf[ i] += right;
+    return *this;
+  }
+  GDLArray& operator-=( const T& right) throw()
+  {
+    for( SizeT i=0; i<sz; ++i)
+      buf[ i] -= right;
+    return *this;
+  }
+
+  void SetBuffer( T* b) throw()
+  {
+    buf = b;
+  }
+  T* GetBuffer() throw()
+  {
+    return buf;
+  }
+  void SetBufferSize( SizeT s) throw()
+  {
+    sz = s;
+  }
+
+  SizeT size() const throw()
+  {
+    return sz;
+  }
+
+  void SetSize( SizeT newSz ) // only used in DStructGDL::DStructGDL( const string& name_) (dstructgdl.cpp)
+  {
+    assert ( sz == 0);
+    sz = newSz;
+    if ( sz > smallArraySize )
+    {
+      try
+      {
+	buf = New(sz) /*new T[ newSz]*/;
+      }
+      catch ( std::bad_alloc& )
+      {
+	ThrowGDLException ( "Array requires more memory than available" );
+      }
+    }
+    else
+    {
+      // default constructed instances have buf == NULL and size == 0
+      // make sure buf is set corectly if such instances are resized
+      buf = InitScalar();
+    }
+  }
+  
+}; // GDLArray
+
+#endif
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/gdlc.g gdl/src/gdlc.g
--- gdl-0.9.3/src/gdlc.g	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/gdlc.g	2013-05-16 12:36:33.244857815 -0600
@@ -1501,6 +1501,43 @@
         { #assign_expr = #([ASSIGN,":="], #assign_expr);}
     ;
 
+// arrayexpr_mfcall_last
+//     : (IDENTIFIER^ arrayindex_list) 
+// 	;
+
+// only used for production in primary_expr
+arrayexpr_mfcall!
+{
+    RefDNode dot;
+    RefDNode tag;
+    int nDot;
+}
+	: a1:array_expr_1st 
+        (   // this rule is only for prodction // (tag_access_keeplast)=>
+            nDot=t1:tag_access_keeplast
+            { 
+                if( --nDot > 0)
+                    {
+                        dot=#[DOT,"DOT_A_MF"];
+                        dot->SetNDot( nDot);    
+                        dot->SetLine( #a1->getLine());
+                        tag = #(dot, #a1, #t1);
+                    }
+           }		
+        )
+        id:IDENTIFIER al:arrayindex_list
+        {
+            if( nDot > 0)
+                #arrayexpr_mfcall = #([ARRAYEXPR_MFCALL,"arrayexpr_mfcall"], #tag, #id, #al);
+            else
+                #arrayexpr_mfcall = #([ARRAYEXPR_MFCALL,"arrayexpr_mfcall"], #a1, #id, #al);
+        }
+    | ASTERIX deref_arrayexpr_mfcall:arrayexpr_mfcall
+        { #arrayexpr_mfcall = 
+			#([DEREF,"deref"], #deref_arrayexpr_mfcall);}
+	;
+
+
 // only here a function call is ok also (all other places must be an array)
 primary_expr 
 {
@@ -1518,11 +1555,13 @@
         // ambiguity (arrayexpr or mfcall)
         (deref_dot_expr_keeplast 
             (IDENTIFIER LBRACE expr (COMMA expr)* RBRACE))=>
-        d2:deref_dot_expr_keeplast 
-            // here it is impossible to decide about function call
-            // as we do not know the object type/struct tag
-            IDENTIFIER arrayindex_list 
-            { #primary_expr = #([ARRAYEXPR_MFCALL,"arrayexpr_mfcall"], #primary_expr);}
+
+        arrayexpr_mfcall
+        // d2:deref_dot_expr_keeplast 
+        //     // here it is impossible to decide about function call
+        //     // as we do not know the object type/struct tag
+        //     IDENTIFIER arrayindex_list 
+        //     { #primary_expr = #([ARRAYEXPR_MFCALL,"arrayexpr_mfcall"], #primary_expr);}
     | 
         // not the above -> unambigous mfcall (or unambigous array expr handled below)
         (deref_dot_expr_keeplast formal_function_call)=> 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/gdlc.i.g gdl/src/gdlc.i.g
--- gdl-0.9.3/src/gdlc.i.g	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/gdlc.i.g	2013-05-16 12:36:33.249857797 -0600
@@ -169,8 +169,11 @@
     static int GetFunIx( const std::string& subName);
     static int GetProIx( ProgNodeP);//const std::string& subName);
     static int GetProIx( const std::string& subName);
-    DStructGDL* ObjectStruct( BaseGDL* self, ProgNodeP mp);
-    DStructGDL* ObjectStructCheckAccess( BaseGDL* self, ProgNodeP mp);
+    DStructGDL* ObjectStruct( DObjGDL* self, ProgNodeP mp);
+    void SetRootR( ProgNodeP tt, DotAccessDescT* aD, BaseGDL* r, ArrayIndexListT* aL);
+    void SetRootL( ProgNodeP tt, DotAccessDescT* aD, BaseGDL* r, ArrayIndexListT* aL);
+    // DStructGDL* ObjectStructCheckAccess( DObjGDL* self, ProgNodeP mp);
+    // DStructDesc* GDLObjectDesc( DObjGDL* self, ProgNodeP mp);
 
     // code in: dinterpreter.cpp
     static void SetFunIx( ProgNodeP f); // triggers read/compile
@@ -645,6 +648,9 @@
         return "<(ptr to undefined expression not found on the heap)>";
     }
 
+
+
+
     // compiler (lexer, parser, treeparser) def in dinterpreter.cpp
     static void ReportCompileError( GDLException& e, const std::string& file = "");
 
@@ -1103,24 +1109,72 @@
         // .CONTINUE does not work)
         _retTree = last; 
 
-        if( dynamic_cast< GDLIOException*>( &e) != NULL)
+        // set !ERROR_STATE sys var 
+        static DStructDesc* errorStateDesc = SysVar::Error_State()->Desc();
+        static unsigned nameTag = errorStateDesc->TagIndex( "NAME");
+        static unsigned codeTag = errorStateDesc->TagIndex( "CODE");
+        static unsigned msgTag = errorStateDesc->TagIndex( "MSG");
+
+        if( e.IsIOException())
             {
+                assert( dynamic_cast< GDLIOException*>( &e) != NULL);
                 // set the jump target - also logs the jump
                 ProgNodeP onIOErr = 
                     static_cast<EnvUDT*>(callStack.back())->GetIOError();
                 if( onIOErr != NULL)
                     {
-                        SysVar::SetErr_String( e.getMessage());
+        DStructGDL* errorState = SysVar::Error_State();
+        (*static_cast<DStringGDL*>( errorState->GetTag( nameTag)))[0] = 
+            "IDL_M_FAILURE";
+        (*static_cast<DLongGDL*>( errorState->GetTag( codeTag)))[0] = 
+            e.ErrorCode();
+        SysVar::SetErrError( e.ErrorCode());
+        (*static_cast<DStringGDL*>( errorState->GetTag( msgTag)))[0] = 
+            e.getMessage();
+        SysVar::SetErr_String( e.getMessage());
 
                         _retTree = onIOErr;
                         return RC_OK;
                     }
             }
 
+        // handle CATCH
+        ProgNodeP catchNode = callStack.back()->GetCatchNode();
+        if( catchNode != NULL)
+            {
+        DStructGDL* errorState = SysVar::Error_State();
+        (*static_cast<DStringGDL*>( errorState->GetTag( nameTag)))[0] = 
+            "IDL_M_FAILURE";
+        (*static_cast<DLongGDL*>( errorState->GetTag( codeTag)))[0] = 
+            e.ErrorCode();
+        SysVar::SetErrError( e.ErrorCode());
+        (*static_cast<DStringGDL*>( errorState->GetTag( msgTag)))[0] = 
+            e.getMessage();
+        SysVar::SetErr_String( e.getMessage());
+
+                BaseGDL** catchVar = callStack.back()->GetCatchVar();
+                GDLDelete(*catchVar);
+                *catchVar = new DLongGDL( e.ErrorCode());
+                _retTree = catchNode;
+                return RC_OK;
+            }
+
         EnvUDT* targetEnv = e.GetTargetEnv();
         if( targetEnv == NULL)
         {
             // initial exception, set target env
+            
+        // set !ERROR_STATE here
+        DStructGDL* errorState = SysVar::Error_State();
+        (*static_cast<DStringGDL*>( errorState->GetTag( nameTag)))[0] = 
+            "IDL_M_FAILURE";
+        (*static_cast<DLongGDL*>( errorState->GetTag( codeTag)))[0] = 
+            e.ErrorCode();
+        SysVar::SetErrError( e.ErrorCode());
+        (*static_cast<DStringGDL*>( errorState->GetTag( msgTag)))[0] = 
+            e.getMessage();
+        SysVar::SetErr_String( e.getMessage());
+
             // look if ON_ERROR is set somewhere
             for( EnvStackT::reverse_iterator i = callStack.rbegin();
                 i != callStack.rend(); ++i)
@@ -1259,7 +1313,7 @@
 
     assert( actEnv != NULL);
 
-    auto_ptr<BaseGDL> e1_guard;
+    Guard<BaseGDL> e1_guard;
     BaseGDL* e1;
     ProgNodeP evalExpr = _t->getFirstChild();
     if( NonCopyNode( evalExpr->getType()))
@@ -1276,7 +1330,7 @@
             if( !callStack.back()->Contains( e1)) 
                 {
                     //                if( actEnv != NULL)
-                    actEnv->Guard( e1); 
+                    actEnv->DeleteAtExit( e1); 
                     //                else
                     //                    e1_guard.reset( e1);
                 }
@@ -1286,7 +1340,7 @@
             e1 = evalExpr->Eval();
 
             //      if( actEnv != NULL)
-            actEnv->Guard( e1); 
+            actEnv->DeleteAtExit( e1); 
             //      else
             //          e1_guard.reset(e1);
         }
@@ -1330,7 +1384,7 @@
     : res=l_deref
     | #(QUESTION e1=expr
             { 
-                auto_ptr<BaseGDL> e1_guard(e1);
+                Guard<BaseGDL> e1_guard(e1);
                 if( e1->True())
                 {
                     res=l_ret_expr(_t);
@@ -1367,16 +1421,16 @@
     | // here ASSIGN and ASSIGN_REPLACE are identical
       #(ASSIGN // can it occur at all?
             { 
-                auto_ptr<BaseGDL> r_guard;
+                Guard<BaseGDL> r_guard;
             } 
             ( e1=tmp_expr
                 {
-                    r_guard.reset( e1);
+                    r_guard.Init( e1);
                 }
             | e1=lib_function_call
                 {
                     if( !callStack.back()->Contains( e1)) 
-                        r_guard.reset( e1);
+                        r_guard.Init( e1);
                 }
             )
             res=l_ret_expr
@@ -1391,16 +1445,16 @@
         )
     | #(ASSIGN_ARRAYEXPR_MFCALL // here as return value of l_function
             { 
-                auto_ptr<BaseGDL> r_guard;
+                Guard<BaseGDL> r_guard;
             } 
             ( e1=tmp_expr
                 {
-                    r_guard.reset( e1);
+                    r_guard.Init( e1);
                 }
             | e1=lib_function_call
                 {
                     if( !callStack.back()->Contains( e1)) 
-                        r_guard.reset( e1);
+                        r_guard.Init( e1);
                 }
             )
             res=l_arrayexpr_mfcall_as_mfcall
@@ -1415,16 +1469,16 @@
         )
     | #(ASSIGN_REPLACE 
             { 
-                auto_ptr<BaseGDL> r_guard;
+                Guard<BaseGDL> r_guard;
             } 
             ( e1=tmp_expr
                 {
-                    r_guard.reset( e1);
+                    r_guard.Init( e1);
                 }
             | e1=lib_function_call
                 {
                     if( !callStack.back()->Contains( e1)) 
-                        r_guard.reset( e1);
+                        r_guard.Init( e1);
                 }
             )
             res=l_ret_expr
@@ -1567,31 +1621,31 @@
     : #(dot:DOT 
             { 
                 SizeT nDot=dot->nDot;
-                auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+                Guard<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
             } 
-            l_dot_array_expr[ aD.get()] 
-            (tag_array_expr[ aD.get()] /* nDot times*/ )+ 
+            l_dot_array_expr[ aD.Get()] 
+            (tag_array_expr[ aD.Get()] /* nDot times*/ )+ 
         )         
         {
             if( dec_inc == DECSTATEMENT) 
             {
-                aD->Dec(); 
+                aD.Get()->Dec(); 
                 res = NULL;
             }
             else if( dec_inc == INCSTATEMENT)
             {
-                aD->Inc();
+                aD.Get()->Inc();
                 res = NULL;
             }
             else
             {
-                if( dec_inc == DEC) aD->Dec(); //*** aD->Assign( dec_inc);
-                else if( dec_inc == INC) aD->Inc();
+                if( dec_inc == DEC) aD.Get()->Dec(); //*** aD->Assign( dec_inc);
+                else if( dec_inc == INC) aD.Get()->Inc();
 //                
-                res=aD->ADResolve();
+                res=aD.Get()->ADResolve();
                 
-                if( dec_inc == POSTDEC) aD->Dec();
-                else if( dec_inc == POSTINC) aD->Inc();
+                if( dec_inc == POSTDEC) aD.Get()->Dec();
+                else if( dec_inc == POSTINC) aD.Get()->Inc();
             }
         }
     ;
@@ -1604,7 +1658,7 @@
 }
     : #(QUESTION e1=expr
             { 
-                auto_ptr<BaseGDL> e1_guard(e1);
+                Guard<BaseGDL> e1_guard(e1);
 
                 if( e1->True())
                 {
@@ -1619,7 +1673,7 @@
         ) // trinary operator
     | #(ASSIGN 
             { 
-                auto_ptr<BaseGDL> r_guard;
+                Guard<BaseGDL> r_guard;
             } 
 //             ( e1=tmp_expr
 //                 {
@@ -1632,11 +1686,11 @@
 //                 }
 //             )
             ( e1=indexable_expr
-            | e1=indexable_tmp_expr { r_guard.reset( e1);}
+            | e1=indexable_tmp_expr { r_guard.Init( e1);}
             | e1=lib_function_call
                 {
                     if( !callStack.back()->Contains( e1)) 
-                        r_guard.reset( e1); // guard if no global data
+                        r_guard.Init( e1); // guard if no global data
                 }
             )
             { 
@@ -1652,14 +1706,14 @@
         )
     | #(ASSIGN_ARRAYEXPR_MFCALL
             { 
-                auto_ptr<BaseGDL> r_guard;
+                Guard<BaseGDL> r_guard;
             } 
             ( e1=indexable_expr
-            | e1=indexable_tmp_expr { r_guard.reset( e1);}
+            | e1=indexable_tmp_expr { r_guard.Init( e1);}
             | e1=lib_function_call
                 {
                     if( !callStack.back()->Contains( e1)) 
-                        r_guard.reset( e1); // guard if no global data
+                        r_guard.Init( e1); // guard if no global data
                 }
             )
             { 
@@ -1677,7 +1731,7 @@
                     {
                         delete *tmp;
 
-                        if( r_guard.get() == e1)
+                        if( r_guard.Get() == e1)
                             *tmp = r_guard.release();
                         else          
                             *tmp = e1->Dup();
@@ -1703,16 +1757,16 @@
         )
     | #(ASSIGN_REPLACE 
             { 
-                auto_ptr<BaseGDL> r_guard;
+                Guard<BaseGDL> r_guard;
             } 
             ( e1=tmp_expr
                 {
-                    r_guard.reset( e1);
+                    r_guard.Init( e1);
                 }
             | e1=lib_function_call
                 {
                     if( !callStack.back()->Contains( e1)) 
-                        r_guard.reset( e1);
+                        r_guard.Init( e1);
                 }
             )
             { 
@@ -1731,7 +1785,7 @@
             {
                 delete *tmp;
 
-                if( r_guard.get() == e1)
+                if( r_guard.Get() == e1)
                   *tmp = r_guard.release();
                 else  
                   *tmp = e1->Dup();
@@ -1753,7 +1807,7 @@
         //BaseGDL** e = l_arrayexpr_mfcall_as_mfcall( _t);
         self=expr mp2:IDENTIFIER
         {  
-                auto_ptr<BaseGDL> self_guard(self);
+                Guard<BaseGDL> self_guard(self);
         
                 EnvUDT* newEnv;
 
@@ -1867,44 +1921,15 @@
 {
     ArrayIndexListT* aL;
     BaseGDL**        rP;
-    //DStructGDL*      structR;
-    ArrayIndexListGuard guard;
 	
 	if( _t->getType() == ARRAYEXPR)
 	{
 		rP=l_indexable_expr(_t->getFirstChild());
 		aL=arrayindex_list(_retTree);
-		guard.reset(aL);
 
 		_retTree = _t->getNextSibling();
         
-		// check here for object and get struct
-//		structR=dynamic_cast<DStructGDL*>(*rP);
-//		if( structR == NULL)
-		if( (*rP)->Type() != GDL_STRUCT)
-            {
-                bool isObj = callStack.back()->IsObject();
-                if( isObj)
-                    {
-                        DStructGDL* oStruct = ObjectStructCheckAccess( *rP, _t);
-                        // oStruct cannot be "Assoc_"
-                        aD->ADRoot( oStruct, guard.release()); 
-                    }
-                else
-                    {
-                        throw GDLException( _t, "Expression must be a"
-                                            " STRUCT in this context: "+Name(*rP),
-                                            true,false);
-                    }
-            }
-		else 
-            {
-                DStructGDL* structR=static_cast<DStructGDL*>(*rP);
-                if( (*rP)->IsAssoc())
-                    throw GDLException( _t, "File expression not allowed "
-                                        "in this context: "+Name(*rP),true,false);
-                aD->ADRoot( structR, guard.release() /* aL */); 
-            }
+        SetRootL( _t, aD, *rP, aL); 
 	}
     else
 	// case ARRAYEXPR_MFCALL:
@@ -1919,37 +1944,8 @@
 	// case VARPTR:
 	{
 		rP=l_indexable_expr(_t);
-		//_t = _retTree; _retTree set ok
-        
-		// check here for object and get struct
-		//structR = dynamic_cast<DStructGDL*>(*rP);
-		//if( structR == NULL)
-		if( (*rP)->Type() != GDL_STRUCT)
-            {
-                bool isObj = callStack.back()->IsObject();
-                if( isObj) // member access to object?
-                    {
-                        DStructGDL* oStruct = ObjectStructCheckAccess( *rP, _t);
-                        // oStruct cannot be "Assoc_"
-                        aD->ADRoot( oStruct); 
-                    }
-                else
-                    {
-                        throw GDLException( _t, "Expression must be a"
-                                            " STRUCT in this context: "+Name(*rP),
-                                            true,false);
-                    }
-            }
-		else
-            {
-                DStructGDL* structR=static_cast<DStructGDL*>(*rP);
-                if( (*rP)->IsAssoc())
-                    {
-                        throw GDLException( _t, "File expression not allowed "
-                                            "in this context: "+Name(*rP),true,false);
-                    }
-                aD->ADRoot(structR); 
-            }
+
+        SetRootL( _t, aD, *rP, NULL); 
 	}
     return;
 //	_retTree = _t;
@@ -1975,7 +1971,7 @@
   //     _t = _t->getFirstChild();
   //     e1=expr(_t);
   //     _t = _retTree;
-  //     auto_ptr<BaseGDL> e1_guard(e1);
+  //     Guard<BaseGDL> e1_guard(e1);
   //     if( e1->True())
   //     {
   //         res=l_expr(_t, right);
@@ -2024,7 +2020,7 @@
   //     res=l_sys_var(_t);
   //     // _t = _retTree; // ok
       
-  //     auto_ptr<BaseGDL> conv_guard; //( rConv);
+  //     Guard<BaseGDL> conv_guard; //( rConv);
   //     BaseGDL* rConv = right;
   //     if( !(*res)->EqType( right))
   //     {
@@ -2082,7 +2078,7 @@
   //       _t = _t->getFirstChild();
         
   //       SizeT nDot = tIn->nDot;
-  //       auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+  //       Guard<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
         
   //       l_dot_array_expr(_t, aD.get());
   //       _t = _retTree;
@@ -2560,10 +2556,10 @@
 		_t = _t->getFirstChild();
 		e=expr(_t);
 		
-		auto_ptr<BaseGDL> e_guard(e);
+		Guard<BaseGDL> e_guard(e);
 		
 		SizeT tagIx;
-		int ret=e->Scalar2index(tagIx);
+		int ret=e->Scalar2Index(tagIx);
 		if( ret < 1) // this is a return code, not the index
             throw GDLException( tIn, "Expression must be a scalar"
                                 " >= 0 in this context: "+Name(e),true,false);
@@ -2584,23 +2580,23 @@
     return;
 }
     : #(EXPR e=expr
-            {
-                auto_ptr<BaseGDL> e_guard(e);
+            // {
+            //     Guard<BaseGDL> e_guard(e);
                 
-                SizeT tagIx;
-                int ret=e->Scalar2index(tagIx);
-                if( ret < 1) // this is a return code, not the index
-                throw GDLException( _t, "Expression must be a scalar"
-                    " >= 0 in this context: "+Name(e),true,false);
+            //     SizeT tagIx;
+            //     int ret=e->Scalar2index(tagIx);
+            //     if( ret < 1) // this is a return code, not the index
+            //     throw GDLException( _t, "Expression must be a scalar"
+            //         " >= 0 in this context: "+Name(e),true,false);
                 
-                aD->ADAdd( tagIx);
-            }
+            //     aD->ADAdd( tagIx);
+            // }
         )                       
     | i:IDENTIFIER
-        {
-            std::string tagName=i->getText();
-            aD->ADAdd( tagName);
-        }
+        // {
+        //     std::string tagName=i->getText();
+        //     aD->ADAdd( tagName);
+        // }
     ;
 
 // for l and r expr
@@ -2630,8 +2626,8 @@
 	//_retTree = _t;
     return;
 }
-	: #(ARRAYEXPR tag_expr[ aD] aL=arrayindex_list { aD->ADAddIx(aL);} )
-    | tag_expr[ aD] { aD->ADAddIx(NULL);} 
+	: #(ARRAYEXPR tag_expr[ aD] aL=arrayindex_list /*{ aD->ADAddIx(aL);}*/ )
+    | tag_expr[ aD] //{ aD->ADAddIx(NULL);} 
     ;
 
 r_dot_indexable_expr [DotAccessDescT* aD] returns [BaseGDL* res] // 1st
@@ -2679,95 +2675,18 @@
 {
     BaseGDL*         r;
     ArrayIndexListT* aL;
-    ArrayIndexListGuard guard;
 }
 // NOTE: r is owned by aD or a l_... (r must not be deleted here)
     : #(ARRAYEXPR r=r_dot_indexable_expr[ aD] 
-            aL=arrayindex_list { guard.reset(aL);} )   
+            aL=arrayindex_list /*{ guard.reset(aL);}*/ )   
         {
             // check here for object and get struct
-            if( r->Type() != GDL_STRUCT)
-            {
-                // if( r->Type() != GDL_OBJ)
-                //     {
-                //         // check for Get/SetProperty
-                //         throw GDLException( _t, "Expression must be a"
-                //                             " STRUCT in this context: "+
-                //                             Name(r),true,false);
-                //     }
-                bool isObj = callStack.back()->IsObject();
-                if( isObj)
-                {
-                    DStructGDL* oStruct = ObjectStructCheckAccess( r, _t);
-                    
-//                    DStructGDL* obj = oStruct->Index( aL);
-
-                    if( aD->IsOwner()) delete r; 
-                    aD->SetOwner( false); // object struct, not owned
-                    
-                    aD->ADRoot( oStruct, guard.release()); 
-//                    aD->ADRoot( obj); 
-
-//                     BaseGDL* obj = r->Index( aL);
-//                     auto_ptr<BaseGDL> objGuard( obj); // new object -> guard
-                    
-//                     DStructGDL* oStruct = ObjectStructCheckAccess( obj, _t);
-
-//                     // oStruct cannot be "Assoc_"
-//                     if( aD->IsOwner()) delete r; 
-//                     aD->SetOwner( false); // object structs are never owned
-//                     aD->ADRoot( oStruct); 
-                }
-                else
-                {
-                    throw GDLException( _t, "Expression must be a"
-                        " STRUCT in this context: "+Name(r),true,false);
-                }
-            }
-            else
-            {
-                if( r->IsAssoc())
-                throw GDLException( _t, "File expression not allowed "
-                    "in this context: "+Name(r),true,false);
-                
-                DStructGDL* structR=static_cast<DStructGDL*>(r);
-                aD->ADRoot( structR, guard.release()); 
-            }
+            SetRootR( _t, aD, r, aL); 
         }
     | r=r_dot_indexable_expr[ aD]
         {
             // check here for object and get struct
-            // structR = dynamic_cast<DStructGDL*>(r);
-            // if( structR == NULL)
-            if( r->Type() != GDL_STRUCT)
-            {
-                bool isObj = callStack.back()->IsObject();
-                if( isObj) // member access to object?
-                {
-                    DStructGDL* oStruct = ObjectStructCheckAccess( r, _t);
-
-                    // oStruct cannot be "Assoc_"
-                    if( aD->IsOwner()) delete r;
-                    aD->SetOwner( false); // object structs are never owned
-                    aD->ADRoot( oStruct); 
-                }
-                else
-                {
-                    throw GDLException( _t, "Expression must be a"
-                        " STRUCT in this context: "+Name(r),true,false);
-                }
-            }
-            else
-            {
-                if( r->IsAssoc())
-                {
-                    throw GDLException( _t, "File expression not allowed "
-                        "in this context: "+Name(r),true,false);
-                }
-                
-                DStructGDL* structR=static_cast<DStructGDL*>(r);
-                aD->ADRoot(structR); 
-            }
+            SetRootR( _t, aD, r, NULL); 
         }
     ;
 
@@ -3187,7 +3106,7 @@
         self=expr mp2:IDENTIFIER
 
         {  
-            auto_ptr<BaseGDL> self_guard(self);
+            Guard<BaseGDL> self_guard(self);
         
             try {
                 newEnv=new EnvUDT( self, mp2, "", true);
@@ -3218,10 +3137,10 @@
         #(dot:DOT  // struct assignment
             { 
                 SizeT nDot=dot->nDot;
-                auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+                Guard<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
             } 
-            l_dot_array_expr[ aD.get()] 
-            (tag_array_expr[ aD.get()] /* nDot times*/ )+ 
+            l_dot_array_expr[ aD.Get()] 
+            (tag_array_expr[ aD.Get()] /* nDot times*/ )+ 
         )
         {
             if( right == NULL)
@@ -3229,7 +3148,7 @@
                                 "Struct expression not allowed in this context.",
                                 true,false);
             
-            aD->ADAssign( right);
+            aD.Get()->ADAssign( right);
 
             res=NULL;
 
@@ -3245,10 +3164,10 @@
             #(dot:DOT  // struct assignment
             { 
                 SizeT nDot=dot->nDot;
-                auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+                Guard<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
             } 
-            l_dot_array_expr[ aD.get()] 
-            (tag_array_expr[ aD.get()] /* nDot times*/ )+ 
+            l_dot_array_expr[ aD.Get()] 
+            (tag_array_expr[ aD.Get()] /* nDot times*/ )+ 
             )         
         )
         {
@@ -3257,7 +3176,7 @@
                                 "Struct expression not allowed in this context.",
                                 true,false);
             
-            aD->ADAssign( right);
+            aD.Get()->ADAssign( right);
 
             res=NULL;
         }
@@ -3278,7 +3197,7 @@
  
                 self=expr mp2:IDENTIFIER
                 {  
-                    auto_ptr<BaseGDL> self_guard(self);
+                    Guard<BaseGDL> self_guard(self);
                     
                     newEnv=new EnvUDT( self, mp2, "", true);
 
@@ -3332,7 +3251,7 @@
 // needed because N_ELEMENTS must handle undefined variables different
 parameter_def_n_elements [EnvBaseT* actEnv] 
 {
-    auto_ptr<EnvBaseT> guard(actEnv); 
+    Guard<EnvBaseT> guard(actEnv); 
     _retTree = _t;
 //     bool interruptEnableIn = interruptEnable;
     if( _retTree != NULL)
@@ -3403,7 +3322,7 @@
 parameter_def [EnvBaseT* actEnv] 
 {
     // as actEnv is not on the stack guard it here
-    auto_ptr<EnvBaseT> guard(actEnv); 
+    Guard<EnvBaseT> guard(actEnv); 
 
     EnvBaseT* callerEnv = callStack.back();
     EnvBaseT* oldNewEnv = callerEnv->GetNewEnv();
@@ -3468,7 +3387,7 @@
 // for library subroutines, their number of parameters is already checked in the compiler
 parameter_def_nocheck [EnvBaseT* actEnv] 
 {
-    auto_ptr<EnvBaseT> guard(actEnv); 
+    Guard<EnvBaseT> guard(actEnv); 
 
     EnvBaseT* callerEnv = callStack.back();
     EnvBaseT* oldNewEnv = callerEnv->GetNewEnv();
Only in gdl-0.9.3/src: gdlc.tree.g.ARRAYEXPR_FN
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/gdlexception.cpp gdl/src/gdlexception.cpp
--- gdl-0.9.3/src/gdlexception.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/gdlexception.cpp	2013-02-25 17:04:24.809180235 -0700
@@ -37,12 +37,40 @@
 return "";
 }
 
+GDLException::GDLException(DLong eC, const string& s, bool pre, bool decorate): 
+  ANTLRException(s),
+  errorNode(static_cast<RefDNode>(antlr::nullAST)),
+  errorNodeP( NULL),
+  errorCode(eC),
+  line( 0), col( 0), prefix( pre),
+  ioException( false),
+  targetEnv( NULL)
+{
+if(decorate && interpreter!=NULL && interpreter->CallStack().size()>0) 
+{
+  EnvBaseT* e = interpreter->CallStack().back();
+  errorNodeP = e->CallingNode();
+  msg = e->GetProName();
+  if( msg != "$MAIN$") msg +=  ": "+ s; else msg = s;
+}
+else
+{
+  msg = s;
+}
+  // note: This is for cases, when form a destructor is thrown
+  // in these cases, program aborts
+#ifdef GDL_DEBUG
+   cerr << s << endl;
+#endif
+}
 GDLException::GDLException(const string& s, bool pre, bool decorate): 
   ANTLRException(s),
   errorNode(static_cast<RefDNode>(antlr::nullAST)),
   errorNodeP( NULL),
+  errorCode(-1),
   line( 0), col( 0), prefix( pre),
-		  targetEnv( NULL)
+  ioException( false),
+  targetEnv( NULL)
 {
 if(decorate && interpreter!=NULL && interpreter->CallStack().size()>0) 
 {
@@ -66,8 +94,34 @@
   ANTLRException(s), 
   errorNode(eN),
   errorNodeP( NULL),
+  errorCode(-1),
   line( 0), col( 0), prefix( true),
-		  targetEnv( NULL)
+  ioException( false),
+  targetEnv( NULL)
+{
+if(interpreter!=NULL && interpreter->CallStack().size()>0) 
+{
+  EnvBaseT* e = interpreter->CallStack().back();
+  errorNodeP = e->CallingNode();
+  msg = e->GetProName();
+  if( msg != "$MAIN$") msg +=  ": "+ s; else msg = s;
+}
+else
+{
+  msg = s;
+}
+#ifdef GDL_DEBUG
+   cerr << s << endl;
+#endif
+}
+GDLException::GDLException(DLong eC, const RefDNode eN, const string& s): 
+  ANTLRException(s), 
+  errorNode(eN),
+  errorNodeP( NULL),
+  errorCode(eC),
+  line( 0), col( 0), prefix( true),
+  ioException( false),
+  targetEnv( NULL)
 {
 if(interpreter!=NULL && interpreter->CallStack().size()>0) 
 {
@@ -89,8 +143,10 @@
   ANTLRException(s), 
   errorNode(static_cast<RefDNode>(antlr::nullAST)),
   errorNodeP( eN),
+  errorCode(-1),
   line( 0), col( 0), prefix( true),
-		  targetEnv( NULL)
+  ioException( false),
+  targetEnv( NULL)
 {
 if( overWriteNode && interpreter!=NULL && interpreter->CallStack().size()>0) 
 {
@@ -111,25 +167,78 @@
    cerr << s << endl;
 #endif
 }
+GDLException::GDLException(DLong eC, const ProgNodeP eN, const string& s, bool decorate, bool overWriteNode): 
+  ANTLRException(s), 
+  errorNode(static_cast<RefDNode>(antlr::nullAST)),
+  errorNodeP( eN),
+  errorCode(eC),
+  line( 0), col( 0), prefix( true),
+  ioException( false),
+  targetEnv( NULL)
+{
+  if( overWriteNode && interpreter!=NULL && interpreter->CallStack().size()>0) 
+  {
+    EnvBaseT* e = interpreter->CallStack().back();
+    errorNodeP = e->CallingNode();
+  }
+  if( decorate && interpreter!=NULL && interpreter->CallStack().size()>0)
+  {
+    EnvBaseT* e = interpreter->CallStack().back();
+    msg = e->GetProName();
+    if( msg != "$MAIN$") msg +=  ": "+ s; else msg = s;
+  }
+  else
+  {
+    msg = s;
+  }
+#ifdef GDL_DEBUG
+   cerr << s << endl;
+#endif
+}
 
 GDLException::GDLException(SizeT l, SizeT c, const string& s): 
   ANTLRException(s),
   errorNode(static_cast<RefDNode>(antlr::nullAST)),
   errorNodeP( NULL),
+  errorCode(-1),
   line( l), col( c), prefix( true),
-		  targetEnv( NULL)
+  ioException( false),
+  targetEnv( NULL)
 {
-if(interpreter!=NULL && interpreter->CallStack().size()>0) 
-{
-  EnvBaseT* e = interpreter->CallStack().back();
-  errorNodeP = e->CallingNode();
-  msg = e->GetProName();
-  if( msg != "$MAIN$") msg +=  ": "+ s; else msg = s;
+  if(interpreter!=NULL && interpreter->CallStack().size()>0) 
+  {
+    EnvBaseT* e = interpreter->CallStack().back();
+    errorNodeP = e->CallingNode();
+    msg = e->GetProName();
+    if( msg != "$MAIN$") msg +=  ": "+ s; else msg = s;
+  }
+  else
+  {
+    msg = s;
+  }
+#ifdef GDL_DEBUG
+   cerr << s << endl;
+#endif
 }
-else
+GDLException::GDLException(DLong eC, SizeT l, SizeT c, const string& s): 
+  ANTLRException(s),
+  errorNode(static_cast<RefDNode>(antlr::nullAST)),
+  errorNodeP( NULL),
+  errorCode(eC),
+  line( l), col( c), prefix( true),
+  targetEnv( NULL)
 {
-  msg = s;
-}
+  if(interpreter!=NULL && interpreter->CallStack().size()>0) 
+  {
+    EnvBaseT* e = interpreter->CallStack().back();
+    errorNodeP = e->CallingNode();
+    msg = e->GetProName();
+    if( msg != "$MAIN$") msg +=  ": "+ s; else msg = s;
+  }
+  else
+  {
+    msg = s;
+  }
 #ifdef GDL_DEBUG
    cerr << s << endl;
 #endif
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/gdlexception.hpp gdl/src/gdlexception.hpp
--- gdl-0.9.3/src/gdlexception.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/gdlexception.hpp	2013-02-25 17:04:24.810180231 -0700
@@ -33,14 +33,18 @@
 {
   static DInterpreter* interpreter;
 
-std::string msg;
+  std::string msg;
 
   RefDNode  errorNode;
   ProgNodeP errorNodeP;
+  DLong     errorCode;
   SizeT line;
   SizeT col;
   bool prefix;
-
+protected:
+  bool ioException;
+ 
+private:  
   EnvUDT* targetEnv; // where to stop (depending on ON_ERROR)
 
 public:
@@ -54,7 +58,17 @@
   GDLException(): ANTLRException(), 
     errorNode(static_cast<RefDNode>(antlr::nullAST)),
 		  errorNodeP( NULL),
+		  errorCode(-1),
+		  line( 0), col( 0), prefix( true),
+		  ioException( false),
+		  targetEnv( NULL)
+  {}
+  GDLException( DLong eC): ANTLRException(), 
+    errorNode(static_cast<RefDNode>(antlr::nullAST)),
+		  errorNodeP( NULL),
+		  errorCode(eC),
 		  line( 0), col( 0), prefix( true),
+		  ioException( false),
 		  targetEnv( NULL)
   {}
   GDLException(const std::string& s, bool pre = true, bool decorate=true);
@@ -62,13 +76,19 @@
   GDLException(const ProgNodeP eN, const std::string& s, bool decorate=true, bool overWriteNode=true);
   GDLException(SizeT l, SizeT c, const std::string& s);
 
-  ~GDLException() throw() {}
+  GDLException(DLong eC, const std::string& s, bool pre = true, bool decorate=true);
+  GDLException(DLong eC, const RefDNode eN, const std::string& s);
+  GDLException(DLong eC, const ProgNodeP eN, const std::string& s, bool decorate=true, bool overWriteNode=true);
+  GDLException(DLong eC, SizeT l, SizeT c, const std::string& s);
 
-std::string toString() const
-	{
-		return msg;
-	}
+  ~GDLException() throw() {}
 
+  DLong ErrorCode() const { return errorCode;}
+  
+  std::string toString() const
+  {
+	  return msg;
+  }
 
   SizeT getLine() const 
   { 
@@ -104,6 +124,8 @@
   {
     return targetEnv;
   }
+
+  bool IsIOException() const { return ioException;}
 };
 
 // for ON_IOERROR
@@ -112,16 +134,27 @@
 public:
   GDLIOException(): 
     GDLException()
-  {}
+  { ioException = true;}
 
   GDLIOException(const std::string& s, bool pre = true):
     GDLException( s, pre)
-  {}
+  { ioException = true;}
     
   GDLIOException(const ProgNodeP eN, const std::string& s):
     GDLException( eN, s)
-  {}
+  { ioException = true;}
 
+  GDLIOException(DLong eC): 
+    GDLException(eC)
+  { ioException = true;}
+
+  GDLIOException(DLong eC,const std::string& s, bool pre = true):
+    GDLException( eC, s, pre)
+  { ioException = true;}
+    
+  GDLIOException(DLong eC,const ProgNodeP eN, const std::string& s):
+    GDLException( eC, eN, s)
+  { ioException = true;}
 };
 
 // warnings ignore !QUIET
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/gdlgstream.cpp gdl/src/gdlgstream.cpp
--- gdl-0.9.3/src/gdlgstream.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/gdlgstream.cpp	2013-03-21 14:04:04.308825496 -0600
@@ -103,12 +103,15 @@
     SysVar::D()->GetTag(SysVar::D()->Desc()->TagIndex("NAME"), 0)
   ))[0];
 
-  if (name == "X") plstream::schr( 1.5, 1.0);
-  else if (name == "PS") plstream::schr( 3.5, 1.0);
-  else plstream::schr( 0, 1.0);
+  if (name == "PS" || name=="SVG") schr( 3.5, 1.0);
+  else schr(1.5, 1.0);
+  (*static_cast<DLongGDL*>(SysVar::D()->GetTag(SysVar::D()->Desc()->TagIndex("X_CH_SIZE"), 0)))[0]=
+  theCurrentChar.dsx;
+  (*static_cast<DLongGDL*>(SysVar::D()->GetTag(SysVar::D()->Desc()->TagIndex("Y_CH_SIZE"), 0)))[0]=
+  theCurrentChar.dsy;
 }
 
-void GDLGStream::NextPlot( bool erase)
+void GDLGStream::NextPlot( bool erase )
 {
   DLongGDL* pMulti = SysVar::GetPMulti();
 
@@ -121,65 +124,81 @@
   nx = (nx>0)?nx:1;
   ny = (ny>0)?ny:1;
   nz = (nz>0)?nz:1;
-
-  plstream::ssub( nx, ny); // changes charsize
-
-  if( (*pMulti)[ 0] <= 0 || (*pMulti)[ 0] == nx*ny)
-    //  if( (*pMulti)[ 0] <= 0)
+  if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"NextPlot(erase=%d)\n",erase);
+  // set subpage numbers in X and Y
+//  plstream::ssub( nx, ny ); // ssub does not change charsize it seems
+  ssub( nx, ny ); 
+  DLong pMod = (*pMulti)[0] % (nx*ny);
+
+//  if( (*pMulti)[0] <= 0 || (*pMulti)[0] == nx*ny) // clear and restart to first subpage
+  if( pMod == 0 ) // clear and restart to first subpage
+  {
+    if( erase )
     {
-      if( erase)
-	{
-	  eop();           // overridden (for Z-buffer)  
-	  plstream::bop(); // changes charsize
-	}
-
-      plstream::adv(1);
-      (*pMulti)[ 0] = nx*ny*nz-1;
+      eop();           // overridden (for Z-buffer)
+      plstream::bop(); // changes charsize
     }
+
+//    plstream::adv(1); //advance to first subpage
+    adv(1); //advance to first subpage
+    (*pMulti)[0] = nx*ny*nz-1; //set PMULTI[0] to this page
+  }
   else
+  {
+    if( dir == 0 )
     {
-      DLong pMod = (*pMulti)[ 0] % (nx*ny);
-      if( dir == 0)
-      {
-	plstream::adv(nx*ny - pMod + 1);
-      }
-      else
-	{
-	  int p = nx*ny - pMod;
-	  int pp = p*nx % (nx*ny) + p/ny + 1;
-	  plstream::adv(pp);
-	}
-
-      if( erase) 
-      {
-        --(*pMulti)[ 0];
-      }
+//      plstream::adv(nx*ny - pMod + 1);
+      adv(nx*ny - pMod + 1);
     }
-
-  // restore charsize
-  DefaultCharSize();
+    else
+    {
+      int p = nx*ny - pMod;
+      int pp = p*nx % (nx*ny) + p/ny + 1;
+//      plstream::adv(pp);
+      adv(pp);
+    }
+    if( erase )
+    {
+      --(*pMulti)[0];
+    }
+  }
+  // restore charsize to default for newpage
+  sizeChar(1.0);
 }
 
 void GDLGStream::NoSub()
 {
-  plstream::ssub( 1, 1); // changes charsize
-  plstream::adv( 0);
-  DefaultCharSize();
+  if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"NoSub()\n");
+  ssub( 1, 1); // changes charsize ?
+//plstream::adv( 0);
+  adv( 0);
+//  DefaultCharSize();
 }
 
-// default is a wrapper for gpage()
+// default is a wrapper for gpage(). Is overriden by, e.g., X driver.
 void GDLGStream::GetGeometry( long& xSize, long& ySize, long& xoff, long& yoff)
 {
-  
+  if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"GDLGStream::GetGeometry()\n");
   PLFLT xp; PLFLT yp; 
   PLINT xleng; PLINT yleng;
   PLINT plxoff; PLINT plyoff;
-  gpage( xp, yp, xleng, yleng, plxoff, plyoff);
+  plstream::gpage( xp, yp, xleng, yleng, plxoff, plyoff); //for X-Window, wrapper give sizes from X11, not plplot which seems bugged.
   
   xSize = xleng;
   ySize = yleng;
   xoff = plxoff;
   yoff = plyoff;
+  if (xSize<1.0||ySize<1) //plplot gives back crazy values! z-buffer for example!
+  {
+    PLFLT xmin,xmax,ymin,ymax;
+    plstream::gspa(xmin,xmax,ymin,ymax); //subpage in mm
+    xSize=min(1.0,xmax-xmin);
+    ySize=min(1.0,ymax-ymin);
+    xoff=0.0;
+    yoff=0.0;
+  }
+  if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"    found (%ld %ld %ld %ld)\n", xSize, ySize, xoff, yoff);
+
 }
 
 // SA: embedded font attributes handling (IDL to plPlot syntax translation)
@@ -760,3 +779,74 @@
 {
   plptex(x,y,dx,dy,just,TranslateFormatCodes(text));
 }
+
+void GDLGStream::schr( PLFLT def, PLFLT scale )
+{
+  if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"schr(%f,%f)\n",def,scale);
+  plstream::schr(def, scale);
+  CurrentCharSize(scale);
+}
+
+void GDLGStream::sizeChar( PLFLT scale )
+{
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"SizeChar(%f)\n",scale);
+  plstream::schr(theDefaultChar.mmsy, scale);
+//  plstream::schr(0, scale);
+  CurrentCharSize(scale);
+}
+
+void GDLGStream::vpor(PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax )
+{
+  if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"vpor(): requesting x[%f:%f],y[%f:%f] (normalized, subpage)\n",xmin,xmax,ymin,ymax);
+  plstream::vpor(xmin, xmax, ymin, ymax);
+  theBox.nx1=xmin;
+  theBox.nx2=xmax;
+  theBox.ny1=ymin;
+  theBox.ny2=ymax;
+  PLFLT x1,x2,y1,y2;
+  plstream::gvpd(x1,x2,y1,y2); //retrieve NORMALIZED DEVICE coordinates of viewport
+  theBox.ndx1=x1;
+  theBox.ndx2=x2;
+  theBox.ndy1=y1;
+  theBox.ndy2=y2;
+  theBox.ondx=x1;
+  theBox.ondy=y1;
+  theBox.sndx=x2-x1;
+  theBox.sndy=y2-y1;
+
+  theBox.initialized=true;
+  if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"vpor(): got x[%f:%f],x[%f:%f] (normalized, device)\n",theBox.ndx1,theBox.ndx2,theBox.ndy1,theBox.ndy2);
+  syncPageInfo();
+}
+
+void GDLGStream::wind( PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax )
+{
+  if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"wind(): setting x[%f:%f],y[%f:%f] (world) \n",xmin,xmax,ymin,ymax);
+  plstream::wind(xmin, xmax, ymin, ymax);
+  theBox.wx1=xmin;
+  theBox.wx2=xmax;
+  theBox.wy1=ymin;
+  theBox.wy2=ymax;
+  updateBoxDeviceCoords();
+  UpdateCurrentCharWorldSize();
+}
+
+void GDLGStream::ssub(PLINT nx, PLINT ny)
+{
+  plstream::ssub( nx, ny ); // does not appear to change charsize.
+  // set subpage numbers in X and Y
+  thePage.nbPages=nx*ny;
+  thePage.nx=nx;
+  thePage.ny=ny;
+  if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"ssub() %dx%d pages\n",nx,ny);
+  thePage.curPage=1;
+  syncPageInfo();
+}
+
+void GDLGStream::adv(PLINT page)
+{
+  plstream::adv(page);
+  if (page==0) {thePage.curPage++;} else {thePage.curPage=page;}
+  if (thePage.curPage > thePage.nbPages) thePage.curPage=1;
+  if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"adv() now at page %d\n",thePage.curPage);
+}
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/gdlgstream.hpp gdl/src/gdlgstream.hpp
--- gdl-0.9.3/src/gdlgstream.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/gdlgstream.hpp	2013-05-16 12:36:33.263857746 -0600
@@ -18,6 +18,9 @@
 #ifndef GDLGSTREAM_HPP_
 #define GDLGSTREAM_HPP_
 
+//debug aid. Put to 1 to debug
+#define GDL_DEBUG_PLSTREAM 0
+
 #include <plplot/plstream.h>
 #include <plplot/plstrm.h>
 #ifndef HAVE_X
@@ -25,6 +28,9 @@
 #  include <plplot/plxwd.h>
 #endif
 #include <plplot/plplot.h>
+#if PLPLOT_PRIVATE_NOT_HIDDEN
+#include <plplot/plplotP.h>
+#endif
 #include <string>
 #include <iostream>
 #include "typedefs.hpp"
@@ -34,21 +40,124 @@
 #include <algorithm>
 #endif
 
+#define MMTOINCH 0.03937
+
 using namespace std;
 
+// Graphic Structures:
+  typedef struct _P_GRAPHICS {
+    DLong background;
+    DFloat charSize;
+    DFloat charThick;
+    DLong clip[6];
+    DLong color;
+    DLong font;
+    DLong lineStyle;
+    DLong multi[5];
+    DLong noClip;
+    DLong noErase;
+    DLong nsum;
+    DFloat position[4];
+    DLong psym;
+    DFloat region[4];
+    DString subTitle;
+    DFloat symSize;
+    DDouble t[4][4];
+    DLong t3d;
+    DFloat thick;
+    DString title;
+    DFloat ticklen;
+    DLong channel;
+  } pstruct ;
+
+  typedef struct GDL_BOX {
+    bool initialized;
+    PLFLT wx1; //world coord of x min
+    PLFLT wx2;
+    PLFLT wy1;
+    PLFLT wy2;
+    PLFLT nx1; //normalized position in subpage
+    PLFLT nx2;
+    PLFLT ny1;
+    PLFLT ny2;
+    PLFLT ndx1; //normalized device position
+    PLFLT ndx2;
+    PLFLT ndy1;
+    PLFLT ndy2;
+    PLFLT ondx; //offset x of box in device coords
+    PLFLT ondy; // in y
+    PLFLT sndx; //size of box, x , device
+    PLFLT sndy;
+    PLFLT dx1; //position in device coords (e.g. pixels)
+    PLFLT dx2;
+    PLFLT dy1;
+    PLFLT dy2;
+    PLFLT pageWorldCoordinates[4];
+    PLFLT subPageWorldCoordinates[4];
+  } gdlbox ;
+
+  typedef struct GDL_SUBPAGE {
+    PLFLT dxsize; //subpage x size device units
+    PLFLT dysize; //subpage y size device units
+    PLFLT dxoff; // subpage x offset
+    PLFLT dyoff; // subpage y offset
+  } gdlsubpage ;
+
+  typedef struct GDL_PAGE {
+    PLFLT xdpmm; // x resolution Dots per mm
+    PLFLT ydpmm; // y resolution Dots per mm
+    PLFLT length; //x length (device coordinates)
+    PLFLT height; //y lenght
+    PLFLT plxoff; // x offset
+    PLFLT plyoff; // y iffset
+    PLFLT xsizemm; // size in mm, x
+    PLFLT ysizemm;
+    PLINT curPage; //current Page
+    PLINT nbPages; //nx*ny
+    PLINT nx;
+    PLINT ny;
+    gdlsubpage subpage;
+  } gdlpage ;
+
+  typedef struct GDL_CHARINFO {
+    PLFLT scale;
+    PLFLT ndsx; // size of char in normalized device units, x direction
+    PLFLT ndsy; // idem y
+    PLFLT dsx; // size of char in device units, x direction
+    PLFLT dsy; // idem y
+    DDouble mmsx; //in mm
+    DDouble mmsy; //
+    PLFLT wsx;  //in current world coordinates
+    PLFLT wsy;
+  } gdlCharInfo;
+
 class GDLGStream: public plstream
 {
   void init(); // prevent plstream::init from being called directly
-	
+private:
+    gdlpage pageLayout;
+    gdlbox boxLayout;
+    
 protected:
   bool valid;
+  gdlCharInfo theCurrentChar;
+  gdlCharInfo theDefaultChar;
+  int gdlDefaultCharInitialized;
+  gdlbox theBox;
+  gdlpage thePage;
+  PLStream* Mypls;
 
 public:
-  GDLGStream( int nx, int ny, const char *driver, const char *file=NULL)
+
+   GDLGStream( int nx, int ny, const char *driver, const char *file=NULL)
     : plstream( nx, ny, driver, file), valid( true)
   {
     if (!checkPlplotDriver(driver))
       ThrowGDLException(std::string("PLplot installation lacks the requested driver: ") + driver);
+    gdlDefaultCharInitialized=0;
+    thePage.nbPages=0;
+    theBox.initialized=false;
+     plgpls( &Mypls);
   }
 
   virtual ~GDLGStream()
@@ -122,11 +231,418 @@
   virtual void Lower()        {}
   virtual void Iconic()        {}
   virtual void DeIconic()        {}
+  virtual bool GetGin(PLGraphicsIn *gin, int mode) {return 0;}
+  virtual void WarpPointer(DLong x, DLong y){}
+  virtual void Flush() {}
   virtual void Clear()         {}
   virtual void Clear( DLong bColor)          {}
 
   bool Valid() { return valid;}
+  bool validWorldBox()
+  {
+      if( theBox.wx1==0&&theBox.wx2==0 || theBox.wy1==0&&theBox.wy2==0 ) return false; else return true;
+  }
+  bool validNormdBox()
+  {
+      if( theBox.nx1==0&&theBox.nx2==0 || theBox.ny1==0&&theBox.ny2==0 ) return false; else return true;
+  }
+  inline PLFLT charScale(){return theCurrentChar.scale;}
+  inline PLFLT nCharLength(){return theCurrentChar.ndsx;}
+  inline PLFLT nCharHeight(){return theCurrentChar.ndsy;}
+  inline PLFLT dCharLength(){return theCurrentChar.dsx;}
+  inline PLFLT dCharHeight(){return theCurrentChar.dsy;}
+  inline PLFLT wCharLength(){return theCurrentChar.wsx;}
+  inline PLFLT wCharHeight(){return theCurrentChar.wsy;}
+  inline DDouble mmCharLength(){return theCurrentChar.mmsx;}
+  inline DDouble mmCharHeight(){return theCurrentChar.mmsy;}
+  inline PLFLT xResolution(){return thePage.xdpmm;}
+  inline PLFLT yResolution(){return thePage.ydpmm;}
+  inline PLFLT mmxPageSize(){return thePage.xsizemm;} //size in mm
+  inline PLFLT mmyPageSize(){return thePage.ysizemm;}
+  inline PLFLT boxnXSize(){return theBox.sndx;}
+  inline PLFLT boxnYSize(){return theBox.sndy;}
+  inline PLFLT xPageSize(){return thePage.length;} //size in units (alternate:{return Mypls->xlength;})
+  inline PLFLT yPageSize(){return thePage.height;} //alternate: {return Mypls->ylength;}
+  inline PLFLT xSubPageSize(){return thePage.subpage.dxsize;} //size in units
+  inline PLFLT ySubPageSize(){return thePage.subpage.dysize;}
+
+  // bunch of conversion functions that should be used in the future now that Mypls is here!
+  // device coords to physical coords (x,y)
+  inline PLFLT d2px(PLFLT x){ return ( Mypls->phyxmi + Mypls->phyxlen * x  );}
+  inline PLFLT d2py(PLFLT y){ return ( Mypls->phyymi + Mypls->phyylen * y  );}
+  inline void device2physical(PLFLT devx, PLFLT devy, PLFLT &physx, PLFLT &physy)
+  { physx=d2px(devx); physy=d2py(devy);}
+  // device to mm
+  inline PLFLT d2mx(PLFLT x){ return (PLFLT) ( x * ( Mypls->phyxma - Mypls->phyxmi ) / Mypls->xpmm ) ;}
+  inline PLFLT d2my(PLFLT y){ return (PLFLT) ( y * ( Mypls->phyyma - Mypls->phyymi ) / Mypls->ypmm ) ;}
+  inline void device2mm(PLFLT devx, PLFLT devy, PLFLT &mmx, PLFLT &mmy)
+  { mmx=d2mx(devx); mmy=d2my(devy);}
+  //device to world
+  inline PLFLT d2wx(PLFLT x){return (PLFLT) ( (x- Mypls->wdxoff) / Mypls->wdxscl );}
+  inline PLFLT d2wy(PLFLT y){return (PLFLT) ( (y- Mypls->wdyoff) / Mypls->wdyscl );}
+  inline void device2world(PLFLT devx, PLFLT devy, PLFLT &wx, PLFLT &wy)
+  { wx=d2wx(devx); wy=d2wy(devy);}
+  // device coords to subpage coords
+  inline PLFLT d2spx(PLFLT x){ return (PLFLT) ( ( x - Mypls->spdxmi ) / ( Mypls->spdxma - Mypls->spdxmi ) ) ;}
+  inline PLFLT d2spy(PLFLT y){ return (PLFLT) ( ( y - Mypls->spdymi ) / ( Mypls->spdyma - Mypls->spdymi ) ) ;}
+  inline void device2subpage(PLFLT devx, PLFLT devy, PLFLT &spx, PLFLT &spy)
+  { spx=d2spx(devx); spy=d2spy(devy);}
+
+  // millimeters to physical coords (x,y)
+  inline PLFLT m2px(PLFLT x){ return ( Mypls->phyxmi + Mypls->xpmm * x  );}
+  inline PLFLT m2py(PLFLT y){ return ( Mypls->phyymi + Mypls->ypmm * y  );}
+  inline void mm2physical(PLFLT mmx, PLFLT mmy, PLFLT &physx, PLFLT &physy)
+  { physx=m2px(mmx); physy=m2py(mmy);}
+  // mm to device
+  inline PLFLT m2dx(PLFLT x){ return (PLFLT) ( ( x * Mypls->xpmm ) / abs( Mypls->phyxma - Mypls->phyxmi ));}
+  inline PLFLT m2dy(PLFLT y){ return (PLFLT) ( ( y * Mypls->ypmm ) / abs( Mypls->phyyma - Mypls->phyymi ));}
+  inline void mm2device(PLFLT mmx, PLFLT mmy, PLFLT &devx, PLFLT &devy)
+  { devx=m2dx(mmx); devy=m2dy(mmy);}
+  // mm to world
+  inline PLFLT m2wx(PLFLT x){ x=m2dx(x); return d2wx(x);}
+  inline PLFLT m2wy(PLFLT y){ y=m2dy(y); return d2wy(y);}
+  inline void mm2world(PLFLT mmx, PLFLT mmy, PLFLT &wx, PLFLT &wy)
+  { wx=m2wx(mmx); wy=m2wy(mmy);}
+  // mm to subpage coord
+  inline PLFLT m2spx(PLFLT x){ x=m2dx(x); return d2spx(x);}
+  inline PLFLT m2spy(PLFLT y){ y=m2dy(y); return d2spy(y);}
+  inline void mm2subpage(PLFLT mmx, PLFLT mmy, PLFLT &spx, PLFLT &spy)
+  { spx=m2spx(mmx); spy=m2spy(mmy);}
+
+  // world to physical coords
+  inline PLFLT w2px(PLFLT x){ return ( Mypls->wpxoff + Mypls->wpxscl * x  );}
+  inline PLFLT w2py(PLFLT y){ return ( Mypls->wpyoff + Mypls->wpyscl * y  );}
+  inline void world2physical(PLFLT wx, PLFLT wy, PLFLT &physx, PLFLT &physy)
+  { physx=m2px(wx); physy=m2py(wy);}
+  // world to device
+  inline PLFLT w2dx(PLFLT x){ return (PLFLT) ( Mypls->wdxoff + Mypls->wdxscl * x );}
+  inline PLFLT w2dy(PLFLT y){ return (PLFLT) ( Mypls->wdyoff + Mypls->wdyscl * y );}
+  inline void world2device(PLFLT wx, PLFLT wy, PLFLT &devx, PLFLT &devy)
+  { devx=w2dx(wx); devy=w2dy(wy);}
+  //world to mm
+  inline PLFLT w2mx(PLFLT x){ return (PLFLT) ( Mypls->wmxoff + Mypls->wmxscl * x );}
+  inline PLFLT w2my(PLFLT y){ return (PLFLT) ( Mypls->wmyoff + Mypls->wmyscl * y );}
+  inline void world2mm(PLFLT wx, PLFLT wy, PLFLT &mmx, PLFLT &mmy)
+  { mmx=w2mx(wx); mmy=w2my(wy);}
+  //world to subpage coord
+  inline PLFLT w2spx(PLFLT x){ x=w2dx(x) ; return d2spx(x);}
+  inline PLFLT w2spy(PLFLT y){ y=w2dy(y) ; return d2spy(y);}
+  inline void world2subpage(PLFLT wx, PLFLT wy, PLFLT &spx, PLFLT &spy)
+  { spx=w2spx(wx); spy=w2my(spy);}
+
+  // physical to device
+  inline PLFLT p2dx(PLFLT x){ return (PLFLT) ( ( x - Mypls->phyxmi ) / (double) Mypls->phyxlen );}
+  inline PLFLT p2dy(PLFLT y){ return (PLFLT) ( ( y - Mypls->phyymi ) / (double) Mypls->phyylen );}
+  inline void physical2device(PLFLT physx, PLFLT physy, PLFLT &devx, PLFLT &devy)
+  { devx=p2dx(physx); devy=p2dy(physy);}
+  //physical to world
+  //physical to mm
+  //physical to subpage coord
+
+  // subpage coords to device coords
+  inline PLFLT sp2dx(PLFLT x){ return (PLFLT) ( Mypls->spdxmi + ( Mypls->spdxma - Mypls->spdxmi ) * x ) ;}
+  inline PLFLT sp2dy(PLFLT y){ return (PLFLT) ( Mypls->spdymi + ( Mypls->spdyma - Mypls->spdymi ) * y ) ;}
+  inline void subpage2device(PLFLT spx, PLFLT spy, PLFLT &devx, PLFLT &devy)
+  { devx=sp2dx(spx); devy=sp2dy(spy);}
+  //subpage to world
+  //subpage to mm
+  //subpage to physical
+
+#if PLPLOT_PRIVATE_NOT_HIDDEN
+  //use simple internal function
+  PLFLT gdlGetmmStringLength(const char *string)
+  {
+    return plstrl(string);
+  }
+#else
+  //use trick to extract desired value hidden in pllegend!
+  PLFLT gdlGetmmStringLength(const char *string)
+  {
+    if ( Mypls->has_string_length )
+    {
+        Mypls->get_string_length = 1;
+        c_plmtex( "t", 0.0, 0.0, 0.0, string );
+        Mypls->get_string_length = 0;
+        return (PLFLT) m2dx(Mypls->string_length);
+    }
+    //else use only possibility without using Private function plstrl(): pllegend!
+    PLFLT text_scale = Mypls->chrht / Mypls->chrdef;
+    PLFLT xwmin_save, xwmax_save, ywmin_save, ywmax_save;
+    plgvpw(&xwmin_save, &xwmax_save, &ywmin_save, &ywmax_save);
+    PLFLT xdmin_save, xdmax_save, ydmin_save, ydmax_save;
+    xdmin_save = ( Mypls->vpdxmi - Mypls->spdxmi ) / ( Mypls->spdxma - Mypls->spdxmi );
+    xdmax_save = ( Mypls->vpdxma - Mypls->spdxmi ) / ( Mypls->spdxma - Mypls->spdxmi );
+    ydmin_save = ( Mypls->vpdymi - Mypls->spdymi ) / ( Mypls->spdyma - Mypls->spdymi );
+    ydmax_save = ( Mypls->vpdyma - Mypls->spdymi ) / ( Mypls->spdyma - Mypls->spdymi );
+    PLFLT mxmin, mxmax, mymin, mymax;
+    plgspa( &mxmin, &mxmax, &mymin, &mymax );
+    PLFLT x_subpage_per_mm, y_subpage_per_mm;
+    x_subpage_per_mm = 1. / ( mxmax - mxmin );
+    y_subpage_per_mm = 1. / ( mymax - mymin );
+    PLFLT def_mm, charheight_mm;
+    plgchr( &def_mm, &charheight_mm );
+    PLFLT character_width=charheight_mm/(mymax-mymin );
+
+    plvpor( 0., 1., 0., 1. );
+    plwind( 0., 1., 0., 1. );
+    PLFLT xdmin_adopted, xdmax_adopted, ydmin_adopted, ydmax_adopted;
+    xdmin_adopted = ( Mypls->vpdxmi - Mypls->spdxmi ) / ( Mypls->spdxma - Mypls->spdxmi );
+    xdmax_adopted = ( Mypls->vpdxma - Mypls->spdxmi ) / ( Mypls->spdxma - Mypls->spdxmi );
+    ydmin_adopted = ( Mypls->vpdymi - Mypls->spdymi ) / ( Mypls->spdyma - Mypls->spdymi );
+    ydmax_adopted = ( Mypls->vpdyma - Mypls->spdymi ) / ( Mypls->spdyma - Mypls->spdymi );
+// we have all info, give back box values:
+    plvpor( xdmin_save, xdmax_save, ydmin_save, ydmax_save );
+    plwind( xwmin_save, xwmax_save, ywmin_save, ywmax_save );
+//call pllegend (outside plot)
+    PLINT opt_array[1];
+    PLINT text_colors[1];
+    PLINT line_colors[1];
+    PLINT line_styles[1];
+    PLINT line_widths[1];
+    PLFLT legend_width, legend_height;
+    PLFLT plot_width=1.0;
+    const char *text[1];
+    opt_array[0]   = 0;
+    text_colors[0] = 0;
+    line_colors[0] = 0;
+    line_styles[0] = 1;
+    line_widths[0] = 1;
+    text[0]=string;
+    pllegend (&legend_width , &legend_height ,
+            PL_LEGEND_NONE,
+            PL_POSITION_VIEWPORT|PL_POSITION_TOP|PL_POSITION_OUTSIDE,
+            0.0 , -0.1 , plot_width ,
+            0 , 0 , 1 ,
+            1 , 1 ,
+            1 , opt_array ,
+            0.0 , text_scale , 0.0 , 0.0 , text_colors ,
+            text , NULL , NULL , NULL , NULL , NULL ,
+            NULL , NULL , NULL , NULL , NULL , NULL);
+//with these values: legend_width = 2. * 0.4 *character_width + text_width ;
+    //invert pllegend work:
+#define subpage_to_adopted_x( nx )    ( ( nx - xdmin_adopted ) / ( ( xdmax_adopted ) - ( xdmin_adopted ) ) )
+#define adopted_to_subpage_x( nx )    ( ( xdmin_adopted ) + ( nx ) * ( ( xdmax_adopted ) - ( xdmin_adopted ) ) )
+    PLFLT tempsize=adopted_to_subpage_x(legend_width+subpage_to_adopted_x( 0. ));
+    tempsize=tempsize-0.8*character_width-adopted_to_subpage_x(plot_width) + adopted_to_subpage_x( 0. );
+    return tempsize/x_subpage_per_mm;
+  }
+#endif
+
+  void  currentPhysicalPos(PLFLT &x, PLFLT &y)
+  {
+    x=Mypls->currx; //Physical x-coordinate of current point
+    y=Mypls->curry;
+  }
+  void  currentWorldPos(PLFLT &x, PLFLT &y)
+  {
+    x=Mypls->currx; //Physical x-coordinate of current point
+    y=Mypls->curry;
+    x=(x-Mypls->wpxoff)/Mypls->wpxscl;
+    y=(y-Mypls->wpyoff)/Mypls->wpyscl;
+  }
+  void  currentDevicePos(PLFLT &x, PLFLT &y)
+  {
+    x=Mypls->currx; //Physical x-coordinate of current point
+    y=Mypls->curry;
+    x=p2dx(x);
+    y=p2dy(y);
+  }
+  void  currentMmPos(PLFLT &x, PLFLT &y)
+  {
+    x=Mypls->currx; //Physical x-coordinate of current point
+    y=Mypls->curry;
+    x=p2dx(x);x=d2mx(x);
+    y=p2dy(y);y=d2my(y);
+  }
+
+  void  pageWorldCoordinates(PLFLT &wxmin, PLFLT &wxmax, PLFLT &wymin, PLFLT &wymax)
+  {
+      wxmin=theBox.pageWorldCoordinates[0];
+      wxmax=theBox.pageWorldCoordinates[1];
+      wymin=theBox.pageWorldCoordinates[2];
+      wymax=theBox.pageWorldCoordinates[3];
+  }
+  void  subPageWorldCoordinates(PLFLT &wxmin, PLFLT &wxmax, PLFLT &wymin, PLFLT &wymax)
+  {
+      wxmin=theBox.subPageWorldCoordinates[0];
+      wxmax=theBox.subPageWorldCoordinates[1];
+      wymin=theBox.subPageWorldCoordinates[2];
+      wymax=theBox.subPageWorldCoordinates[3];
+  }
+  void  boxDeviceCoordinates(PLFLT &wxmin, PLFLT &wxmax, PLFLT &wymin, PLFLT &wymax)
+  {
+      wxmin=theBox.dx1;
+      wxmax=theBox.dx2;
+      wymin=theBox.dy1;
+      wymax=theBox.dy2;
+  }
+  PLFLT  boxAspectDevice(){return (theBox.dy2-theBox.dy1)/(theBox.dx2-theBox.dx1);}
+  PLFLT  boxAspectWorld(){return (theBox.wy2-theBox.wy1)/(theBox.wx2-theBox.wx1);}
+
+  void SaveLayout()
+  {
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"SaveLayout():\n");
+    pageLayout.nbPages=thePage.nbPages;
+    pageLayout.nx=thePage.nx;
+    pageLayout.ny=thePage.ny;
+    pageLayout.curPage=thePage.curPage;
+    pageLayout.length=thePage.length;
+    pageLayout.height=thePage.height;
+    pageLayout.xsizemm=thePage.xsizemm;
+    pageLayout.ysizemm=thePage.ysizemm;
+    pageLayout.plxoff=thePage.plxoff;
+    pageLayout.plyoff=thePage.plyoff;
+
+    boxLayout.nx1=theBox.nx1;
+    boxLayout.nx2=theBox.nx2;
+    boxLayout.ny1=theBox.ny1;
+    boxLayout.ny2=theBox.ny2;
+    boxLayout.ndx1=theBox.ndx1;
+    boxLayout.ndx2=theBox.ndx2;
+    boxLayout.ndy1=theBox.ndy1;
+    boxLayout.ndy2=theBox.ndy2;
+    boxLayout.ondx=theBox.ondx;
+    boxLayout.ondy=theBox.ondy;
+    boxLayout.sndx=theBox.sndx;
+    boxLayout.sndy=theBox.sndy;
+    boxLayout.dx1=theBox.dx1;
+    boxLayout.dx2=theBox.dx2;
+    boxLayout.dy1=theBox.dy1;
+    boxLayout.dy2=theBox.dy2;
+    boxLayout.wx1=theBox.wx1;
+    boxLayout.wx2=theBox.wx2;
+    boxLayout.wy1=theBox.wy1;
+    boxLayout.wy2=theBox.wy2;
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"saving box [%f,%f,%f,%f] at [%f,%f,%f,%f] in subpage %d of %dx%d (device coords [%f,%f,%f,%f]\n",boxLayout.wx1,boxLayout.wy1,boxLayout.wx2,boxLayout.wy2,boxLayout.nx1,boxLayout.ny1,boxLayout.nx2,boxLayout.ny2,pageLayout.curPage,pageLayout.nx,pageLayout.ny,boxLayout.dx1,boxLayout.dy1,boxLayout.dx2,boxLayout.dy2);
+  }
+
+  void RestoreLayout()
+  {
+      ssub(pageLayout.nx,pageLayout.ny);
+      adv(pageLayout.curPage);
+      vpor(boxLayout.nx1,boxLayout.nx2,boxLayout.ny1,boxLayout.ny2);
+      wind(boxLayout.wx1,boxLayout.wx2,boxLayout.wy1,boxLayout.wy2);
+  }
+
+  void OnePageSaveLayout()
+  {
+      SaveLayout();
+      NoSub();
+  }
+
+  bool updatePageInfo()
+  {
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"updatePageInfo():\n");
+    if (thePage.nbPages==0) {if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"            FAILED\n");return false;}
+    long xsize,ysize,xoff,yoff;
+    GetGeometry(xsize,ysize,xoff,yoff);
+    thePage.length=xsize;
+    thePage.height=ysize;
+    thePage.plxoff=xoff;
+    thePage.plyoff=yoff;
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"             %fx%f device units.\n",thePage.length, thePage.height);
+    return true;
+  }
+
+  inline void NormToDevice(PLFLT normx, PLFLT normy, PLFLT &devx, PLFLT &devy)
+  {
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"NormToDevice()\n");
+    devx=normx*thePage.subpage.dxsize+thePage.subpage.dxoff;
+    devy=normy*thePage.subpage.dysize+thePage.subpage.dyoff;
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"        input [%f,%f] output [%f,%f]\n", normx, normy, devx, devy);
+  }
+
+  inline void NormedDeviceToDevice(PLFLT normx, PLFLT normy, PLFLT &devx, PLFLT &devy)
+  {
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"NormedDeviceToDevice()\n");
+    devx=normx*thePage.length;
+    devy=normy*thePage.height;
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"         input [%f,%f] output [%f,%f]\n", normx, normy, devx, devy);
+  }
+
+  inline void DeviceToNorm(PLFLT devx, PLFLT devy, PLFLT &normx, PLFLT &normy)
+  {
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"DeviceToNorm()\n");
+    normx=(devx-thePage.subpage.dxoff)/thePage.subpage.dxsize;
+    normy=(devy-thePage.subpage.dyoff)/thePage.subpage.dysize;
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"          input [%f,%f] output [%f,%f]\n", devx, devy, normx, normy);
+  }
+  inline void DeviceToNormedDevice(PLFLT devx, PLFLT devy, PLFLT &normx, PLFLT &normy)
+  {
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"DeviceToNormedDevice()\n");
+    normx=devx/thePage.length;
+    normy=devy/thePage.height;
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"          input [%f,%f] output [%f,%f]\n", devx, devy, normx, normy);
+  }
+  inline void NormToWorld(PLFLT normx, PLFLT normy, PLFLT &worldx, PLFLT &worldy)
+  {
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"NormToWorld()\n");
+    DDouble s1,s2;
+    s1=(theBox.wx2-theBox.wx1)/(theBox.nx2-theBox.nx1);
+    s2=theBox.wx1;
+    worldx=s1*(normx-theBox.nx1)+s2;
+    s1=(theBox.wy2-theBox.wy1)/(theBox.ny2-theBox.ny1);
+    s2=theBox.wy1;
+    worldy=s1*(normy-theBox.ny1)+s2;
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"         input [%f,%f] output [%f,%f]\n", normx, normy, worldx, worldy);
+  }
+
+  inline void NormedDeviceToWorld(PLFLT normx, PLFLT normy, PLFLT &worldx, PLFLT &worldy)
+  {
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"NormedDeviceToWorld()\n");
+    DDouble s1,s2;
+    s1=(theBox.wx2-theBox.wx1)/(theBox.ndx2-theBox.ndx1);
+    s2=theBox.wx1;
+    worldx=s1*(normx-theBox.ndx1)+s2;
+    s1=(theBox.wy2-theBox.wy1)/(theBox.ndy2-theBox.ndy1);
+    s2=theBox.wy1;
+    worldy=s1*(normy-theBox.ndy1)+s2;
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"          input [%f,%f] (nd) output [%f,%f] (w)\n", normx, normy, worldx, worldy);
+  }
+
+  inline void WorldToNorm(PLFLT worldx, PLFLT worldy, PLFLT &normx, PLFLT &normy)
+  {
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"WorldToNormedDevice()\n");
+    DDouble s1,s2;
+    s1=(theBox.nx2-theBox.nx1)/(theBox.wx2-theBox.wx1);
+    s2=theBox.nx1;
+    normx=s1*(worldx-theBox.wx1)+s2;
+    s1=(theBox.ny2-theBox.ny1)/(theBox.wy2-theBox.wy1);
+    s2=theBox.ny1;
+    normy=s1*(worldy-theBox.wy1)+s2;
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"     input [%f,%f] output [%f,%f]\n", worldx, worldy, normx, normy);
+  }
+
+  inline void WorldToNormedDevice(PLFLT worldx, PLFLT worldy, PLFLT &normx, PLFLT &normy)
+  {
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"WorldToNormedDevice()\n");
+    DDouble s1,s2;
+    s1=(theBox.ndx2-theBox.ndx1)/(theBox.wx2-theBox.wx1);
+    s2=theBox.ndx1;
+    normx=s1*(worldx-theBox.wx1)+s2;
+    s1=(theBox.ndy2-theBox.ndy1)/(theBox.wy2-theBox.wy1);
+    s2=theBox.ndy1;
+    normy=s1*(worldy-theBox.wy1)+s2;
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"    input [%f,%f](w) output [%f,%f](nd)\n", worldx, worldy, normx, normy);
+  }
+
+
+  inline void DeviceToWorld(PLFLT devx, PLFLT devy, PLFLT &worldx, PLFLT &worldy)
+  {
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"DeviceToWorld()\n");
+    PLFLT normx, normy;
+    DeviceToNormedDevice(devx, devy, normx, normy);
+    NormedDeviceToWorld(normx, normy, worldx, worldy);
+  }
 
+  inline void WorldToDevice(PLFLT worldx, PLFLT worldy, PLFLT &devx, PLFLT &devy)
+  {
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"WorldToDevice()\n");
+    PLFLT normx, normy;
+    WorldToNormedDevice(worldx, worldy, normx, normy);
+    NormedDeviceToDevice(normx, normy,  devx, devy);
+  }
+  
   //  void Clear();
   void Color( ULong c, DLong decomposed=0, UInt ix=1);
   void Background( ULong c, DLong decomposed=0);
@@ -136,6 +652,79 @@
 
   void NoSub(); // no subwindows (/NORM, /DEVICE)
 
+  void CurrentCharSize(PLFLT scale)
+  {
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"CurrentCharsize()\n");
+    if (gdlDefaultCharInitialized==0)
+    {
+        if (updatePageInfo()==true)
+        {
+        GetPlplotDefaultCharSize();
+        }
+    }
+    theCurrentChar.scale=scale;
+    theCurrentChar.ndsx=scale*theDefaultChar.ndsx;
+    theCurrentChar.ndsy=scale*theDefaultChar.ndsy;
+    theCurrentChar.dsx=scale*theDefaultChar.dsx;
+    theCurrentChar.dsy=scale*theDefaultChar.dsy;
+    theCurrentChar.mmsx=scale*theDefaultChar.mmsx;
+    theCurrentChar.mmsy=scale*theDefaultChar.mmsy;
+    theCurrentChar.wsx=scale*theDefaultChar.wsx;
+    theCurrentChar.wsy=scale*theDefaultChar.wsy;
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"            sized by %f is %fx%f mm or %fx%f device or %fx%f world\n",scale,theCurrentChar.mmsx,theCurrentChar.mmsy,theCurrentChar.dsx,theCurrentChar.dsy,theCurrentChar.wsx, theCurrentChar.wsy);
+  }
+
+  void UpdateCurrentCharWorldSize()
+  {
+    PLFLT x,y,dx,dy;
+    DeviceToWorld(0,0,x,y);
+    DeviceToWorld(theDefaultChar.dsx,theDefaultChar.dsy, dx, dy);
+    theDefaultChar.wsx=abs(dx-x);
+    theDefaultChar.wsy=abs(dy-y);
+    theCurrentChar.wsx=theCurrentChar.scale*theDefaultChar.wsx;
+    theCurrentChar.wsy=theCurrentChar.scale*theDefaultChar.wsy;
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"UpdateCurrentCharWorldSize(%f,%f)\n",
+                                    theCurrentChar.wsx,theCurrentChar.wsy);
+  }
+  
+  void GetPlplotDefaultCharSize()
+  {
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"GetPlPlotDefaultCharsize()\n");
+    if (thePage.nbPages==0)   {return;}
+    //dimensions in normalized, device and millimetres
+    if (gdlDefaultCharInitialized==1) {if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"     Already initialized\n"); return;}
+
+    PLFLT nxmin, nxmax, nymin, nymax, wxmin, wxmax, wymin, wymax;
+    plstream::gvpd(nxmin, nxmax, nymin, nymax); //save norm of current box
+    if((nxmin==0.0&&nxmax==0.0)||(nymin==0.0&&nymax==0.0)) //if not initialized, set normalized mode
+    {
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"          Warning: initializing viewport\n");
+      plstream::vpor(0, 1, 0, 1);
+      plstream::gvpd(nxmin, nxmax, nymin, nymax);
+      plstream::wind(0.0,1.0,0.0,1.0);
+    }
+    plstream::gvpw(wxmin, wxmax, wymin, wymax); //save world of current box
+    PLFLT vpXmin, vpXmax, vpYmin, vpYmax;
+    PLFLT vpXmin2, vpXmax2, vpYmin2, vpYmax2;
+    plstream::vpor(0, 1, 0, 1);
+    plstream::wind(0.0,1.0,0.0,1.0);
+    plstream::gvpd(vpXmin, vpXmax, vpYmin, vpYmax);
+    plstream::vsta();
+    plstream::gvpd(vpXmin2, vpXmax2, vpYmin2, vpYmax2);
+    theDefaultChar.ndsx=0.5*((vpXmin2-vpXmin)/8.0+(vpXmax-vpXmax2)/5.0);
+    theDefaultChar.ndsy=0.5*((vpYmin2-vpYmin)/5.0+(vpYmax-vpYmax2)/5.0);
+    theDefaultChar.dsx=0.5*((vpXmin2-vpXmin)/8.0+(vpXmax-vpXmax2)/5.0)*thePage.length;
+    theDefaultChar.dsy=0.5*((vpYmin2-vpYmin)/5.0+(vpYmax-vpYmax2)/5.0)*thePage.height;
+    plstream::vpor(nxmin, nxmax, nymin, nymax); //restore norm of current box
+    plstream::wind(wxmin, wxmax, wymin, wymax); //restore world of current box
+    PLFLT defhmm, scalhmm;
+    plgchr(&defhmm, &scalhmm); // height of a letter in millimetres
+    theDefaultChar.mmsy=scalhmm;
+    theDefaultChar.mmsx=theDefaultChar.ndsx/theDefaultChar.ndsy*scalhmm;
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"             %fx%f(mm)\n",theDefaultChar.mmsx,theDefaultChar.mmsy);
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"             %fx%f(norm)\n",theDefaultChar.ndsx,theDefaultChar.ndsy);
+    gdlDefaultCharInitialized=1;
+  }
   // SA: overloading plplot methods in order to handle IDL-plplot extended
   // text formating syntax conversion
   const char * TranslateFormatCodes(const char *text);
@@ -143,7 +732,72 @@
                          const char *text);
   void ptex( PLFLT x, PLFLT y, PLFLT dx, PLFLT dy, PLFLT just,
                          const char *text);
+  void schr( PLFLT def, PLFLT scale );
+  void sizeChar(PLFLT scale);
+  void vpor( PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax );
+//  void gvpd( PLFLT& xmin, PLFLT& xmax, PLFLT& ymin, PLFLT& ymax );
+  void wind( PLFLT xmin, PLFLT xmax, PLFLT ymin, PLFLT ymax );
+  void ssub( PLINT nx, PLINT ny);
+  void adv(PLINT page);
+  void gpage(PLFLT& xp, PLFLT& yp, PLINT& xleng, PLINT& yleng,
+                PLINT& xoff, PLINT& yoff)
+  {
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"gpage()\n",xp,yp);
+    if(updatePageInfo()==true)
+    {
+        xp=thePage.xdpmm/MMTOINCH;
+        yp=thePage.ydpmm/MMTOINCH;
+        xleng=(PLINT)thePage.length;
+        yleng=(PLINT)thePage.height;
+        xoff=(PLINT)thePage.plxoff;
+        yoff=(PLINT)thePage.plyoff;
+    }
+  }
+
+  inline void syncPageInfo()
+  {
+      if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"SyncPageInfo()\n");
+      PLINT level;
+      plstream::glevel(level);
+      if (level>1 && thePage.nbPages!=0) //we need to have a vpor defined, and a page!
+      {
+        PLFLT bxsize_mm, bysize_mm, offx_mm, offy_mm;
+        PLFLT xmin,ymin,xmax,ymax;
+        plstream::gspa(xmin,xmax,ymin,ymax); //subpage in mm
+        bxsize_mm=xmax-xmin;
+        bysize_mm=ymax-ymin;
+        offx_mm=xmin;
+        offy_mm=ymin;
+        if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"         gspa returned size[%f,%f] at offset [%f,%f] (mm) for subpage %d of %dx%d subpages\n",bxsize_mm,bysize_mm,offx_mm,offy_mm,thePage.curPage,thePage.nx,thePage.ny);
+        //we can derive the dpm in x and y which converts mm to device coords:
+        thePage.xdpmm=abs(thePage.length/(thePage.nx*bxsize_mm));
+        thePage.ydpmm=abs(thePage.height/(thePage.ny*bysize_mm));
+        //and the page width and height in mm:
+        thePage.xsizemm=thePage.length/thePage.xdpmm;
+        thePage.ysizemm=thePage.height/thePage.ydpmm;
+        if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"         device resolution [%f,%f]mm^-1, device size [%f,%f], [%f,%f] mm\n",
+                thePage.xdpmm,thePage.ydpmm,thePage.length,thePage.height,thePage.xsizemm,thePage.ysizemm);
+        thePage.subpage.dxoff=offx_mm*thePage.xdpmm;
+        thePage.subpage.dyoff=offy_mm*thePage.ydpmm;
+        thePage.subpage.dxsize=bxsize_mm*thePage.xdpmm;
+        thePage.subpage.dysize=bysize_mm*thePage.ydpmm;
+        if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"         subpage is %fx%f at [%f,%f] device units\n",
+                thePage.subpage.dxsize,thePage.subpage.dysize,thePage.subpage.dxoff,thePage.subpage.dyoff);
+
+      } else         if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"       WARNING: not initalized\n");
+  }
 
+  inline void updateBoxDeviceCoords()
+  {
+      if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"updateBoxDeviceCoords()\n");
+    // world coordinates of current subpage boundaries and page boundaries
+    NormedDeviceToWorld(0.0, 0.0,theBox.pageWorldCoordinates[0],theBox.pageWorldCoordinates[2]);
+    NormedDeviceToWorld(1.0, 1.0,theBox.pageWorldCoordinates[1],theBox.pageWorldCoordinates[3]);
+    NormToWorld(0.0, 0.0,theBox.subPageWorldCoordinates[0],theBox.subPageWorldCoordinates[2]);
+    NormToWorld(1.0, 1.0,theBox.subPageWorldCoordinates[1],theBox.subPageWorldCoordinates[3]);
+    NormToDevice(theBox.nx1,theBox.ny1,theBox.dx1,theBox.dy1);
+    NormToDevice(theBox.nx2,theBox.ny2,theBox.dx2,theBox.dy2);
+  }
 };
 
 #endif
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/gdlgstream.hpp.rej gdl/src/gdlgstream.hpp.rej
--- gdl-0.9.3/src/gdlgstream.hpp.rej	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/gdlgstream.hpp.rej	2011-08-22 08:48:35.000000000 -0600
@@ -0,0 +1,29 @@
+--- src/gdlgstream.hpp.includes	2010-06-11 09:09:51.000000000 -0600
++++ src/gdlgstream.hpp	2011-08-18 13:10:41.285235153 -0600
+@@ -50,7 +50,7 @@
+   {
+ //   std::cerr << "GDLGStream()" << std::endl;
+     if (!checkPlplotDriver(driver))
+-      ThrowGDLException(string("PLplot installation lacks the requested driver: ") + driver);
++      ThrowGDLException(std::string("PLplot installation lacks the requested driver: ") + driver);
+   }
+ 
+   virtual ~GDLGStream()
+@@ -103,7 +103,7 @@
+ 
+ //     devNames = new std::vector<std::string>( numdevs_plus_one - 1);
+     for( int i = 0; i < numdevs_plus_one - 1; ++i)
+-		devNames.push_back(string(devnames[ i]));
++		devNames.push_back(std::string(devnames[ i]));
+     
+     free(devnames);
+ }
+@@ -111,7 +111,7 @@
+ // for debug
+ std::vector<std::string> devnamesDbg = devNames;
+ 
+-return std::find( devNames.begin(), devNames.end(), string( driver)) != devNames.end();
++return std::find( devNames.begin(), devNames.end(), std::string( driver)) != devNames.end();
+ 
+ //     checking if a given driver is in the list
+ //     bool supported = false;
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/GDLInterpreter.cpp gdl/src/GDLInterpreter.cpp
--- gdl-0.9.3/src/GDLInterpreter.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/GDLInterpreter.cpp	2013-05-16 12:36:32.992858720 -0600
@@ -1,4 +1,4 @@
-/* $ANTLR 2.7.7 (20110618): "gdlc.i.g" -> "GDLInterpreter.cpp"$ */
+/* $ANTLR 2.7.7 (20120518): "gdlc.i.g" -> "GDLInterpreter.cpp"$ */
 
     // gets inserted before the antlr generated includes in the cpp file
 #include "includefirst.hpp"
@@ -428,13 +428,28 @@
 		// .CONTINUE does not work)
 		_retTree = last; 
 		
-		if( dynamic_cast< GDLIOException*>( &e) != NULL)
+		// set !ERROR_STATE sys var 
+		static DStructDesc* errorStateDesc = SysVar::Error_State()->Desc();
+		static unsigned nameTag = errorStateDesc->TagIndex( "NAME");
+		static unsigned codeTag = errorStateDesc->TagIndex( "CODE");
+		static unsigned msgTag = errorStateDesc->TagIndex( "MSG");
+		
+		if( e.IsIOException())
 		{
+		assert( dynamic_cast< GDLIOException*>( &e) != NULL);
 		// set the jump target - also logs the jump
 		ProgNodeP onIOErr = 
 		static_cast<EnvUDT*>(callStack.back())->GetIOError();
 		if( onIOErr != NULL)
 		{
+		DStructGDL* errorState = SysVar::Error_State();
+		(*static_cast<DStringGDL*>( errorState->GetTag( nameTag)))[0] = 
+		"IDL_M_FAILURE";
+		(*static_cast<DLongGDL*>( errorState->GetTag( codeTag)))[0] = 
+		e.ErrorCode();
+		SysVar::SetErrError( e.ErrorCode());
+		(*static_cast<DStringGDL*>( errorState->GetTag( msgTag)))[0] = 
+		e.getMessage();
 		SysVar::SetErr_String( e.getMessage());
 		
 		_retTree = onIOErr;
@@ -442,10 +457,43 @@
 		}
 		}
 		
+		// handle CATCH
+		ProgNodeP catchNode = callStack.back()->GetCatchNode();
+		if( catchNode != NULL)
+		{
+		DStructGDL* errorState = SysVar::Error_State();
+		(*static_cast<DStringGDL*>( errorState->GetTag( nameTag)))[0] = 
+		"IDL_M_FAILURE";
+		(*static_cast<DLongGDL*>( errorState->GetTag( codeTag)))[0] = 
+		e.ErrorCode();
+		SysVar::SetErrError( e.ErrorCode());
+		(*static_cast<DStringGDL*>( errorState->GetTag( msgTag)))[0] = 
+		e.getMessage();
+		SysVar::SetErr_String( e.getMessage());
+		
+		BaseGDL** catchVar = callStack.back()->GetCatchVar();
+		GDLDelete(*catchVar);
+		*catchVar = new DLongGDL( e.ErrorCode());
+		_retTree = catchNode;
+		return RC_OK;
+		}
+		
 		EnvUDT* targetEnv = e.GetTargetEnv();
 		if( targetEnv == NULL)
 		{
 		// initial exception, set target env
+		
+		// set !ERROR_STATE here
+		DStructGDL* errorState = SysVar::Error_State();
+		(*static_cast<DStringGDL*>( errorState->GetTag( nameTag)))[0] = 
+		"IDL_M_FAILURE";
+		(*static_cast<DLongGDL*>( errorState->GetTag( codeTag)))[0] = 
+		e.ErrorCode();
+		SysVar::SetErrError( e.ErrorCode());
+		(*static_cast<DStringGDL*>( errorState->GetTag( msgTag)))[0] = 
+		e.getMessage();
+		SysVar::SetErr_String( e.getMessage());
+		
 		// look if ON_ERROR is set somewhere
 		for( EnvStackT::reverse_iterator i = callStack.rbegin();
 		i != callStack.rend(); ++i)
@@ -787,7 +835,7 @@
 	
 	assert( actEnv != NULL);
 	
-	auto_ptr<BaseGDL> e1_guard;
+	Guard<BaseGDL> e1_guard;
 	BaseGDL* e1;
 	ProgNodeP evalExpr = _t->getFirstChild();
 	if( NonCopyNode( evalExpr->getType()))
@@ -804,7 +852,7 @@
 	if( !callStack.back()->Contains( e1)) 
 	{
 	//                if( actEnv != NULL)
-	actEnv->Guard( e1); 
+	actEnv->DeleteAtExit( e1); 
 	//                else
 	//                    e1_guard.reset( e1);
 	}
@@ -814,7 +862,7 @@
 	e1 = evalExpr->Eval();
 	
 	//      if( actEnv != NULL)
-	actEnv->Guard( e1); 
+	actEnv->DeleteAtExit( e1); 
 	//      else
 	//          e1_guard.reset(e1);
 	}
@@ -882,7 +930,7 @@
 		e1=expr(_t);
 		_t = _retTree;
 		
-		auto_ptr<BaseGDL> e1_guard(e1);
+		Guard<BaseGDL> e1_guard(e1);
 		if( e1->True())
 		{
 		res=l_ret_expr(_t);
@@ -950,7 +998,7 @@
 		match(antlr::RefAST(_t),ASSIGN);
 		_t = _t->getFirstChild();
 		
-		auto_ptr<BaseGDL> r_guard;
+		Guard<BaseGDL> r_guard;
 		
 		{
 		if (_t == ProgNodeP(antlr::nullAST) )
@@ -985,7 +1033,7 @@
 			e1=tmp_expr(_t);
 			_t = _retTree;
 			
-			r_guard.reset( e1);
+			r_guard.Init( e1);
 			
 			break;
 		}
@@ -995,7 +1043,7 @@
 			_t = _retTree;
 			
 			if( !callStack.back()->Contains( e1)) 
-			r_guard.reset( e1);
+			r_guard.Init( e1);
 			
 			break;
 		}
@@ -1026,7 +1074,7 @@
 		match(antlr::RefAST(_t),ASSIGN_ARRAYEXPR_MFCALL);
 		_t = _t->getFirstChild();
 		
-		auto_ptr<BaseGDL> r_guard;
+		Guard<BaseGDL> r_guard;
 		
 		{
 		if (_t == ProgNodeP(antlr::nullAST) )
@@ -1061,7 +1109,7 @@
 			e1=tmp_expr(_t);
 			_t = _retTree;
 			
-			r_guard.reset( e1);
+			r_guard.Init( e1);
 			
 			break;
 		}
@@ -1071,7 +1119,7 @@
 			_t = _retTree;
 			
 			if( !callStack.back()->Contains( e1)) 
-			r_guard.reset( e1);
+			r_guard.Init( e1);
 			
 			break;
 		}
@@ -1102,7 +1150,7 @@
 		match(antlr::RefAST(_t),ASSIGN_REPLACE);
 		_t = _t->getFirstChild();
 		
-		auto_ptr<BaseGDL> r_guard;
+		Guard<BaseGDL> r_guard;
 		
 		{
 		if (_t == ProgNodeP(antlr::nullAST) )
@@ -1137,7 +1185,7 @@
 			e1=tmp_expr(_t);
 			_t = _retTree;
 			
-			r_guard.reset( e1);
+			r_guard.Init( e1);
 			
 			break;
 		}
@@ -1147,7 +1195,7 @@
 			_t = _retTree;
 			
 			if( !callStack.back()->Contains( e1)) 
-			r_guard.reset( e1);
+			r_guard.Init( e1);
 			
 			break;
 		}
@@ -1350,7 +1398,7 @@
 	match(antlr::RefAST(_t),IDENTIFIER);
 	_t = _t->getNextSibling();
 	
-	auto_ptr<BaseGDL> self_guard(self);
+	Guard<BaseGDL> self_guard(self);
 	
 	newEnv=new EnvUDT( self, mp2, "", true);
 	
@@ -2158,9 +2206,9 @@
 	_t = _t->getFirstChild();
 	
 	SizeT nDot=dot->nDot;
-	auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+	Guard<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
 	
-	l_dot_array_expr(_t, aD.get());
+	l_dot_array_expr(_t, aD.Get());
 	_t = _retTree;
 	{ // ( ... )+
 	int _cnt37=0;
@@ -2168,7 +2216,7 @@
 		if (_t == ProgNodeP(antlr::nullAST) )
 			_t = ASTNULL;
 		if ((_t->getType() == ARRAYEXPR || _t->getType() == EXPR || _t->getType() == IDENTIFIER)) {
-			tag_array_expr(_t, aD.get());
+			tag_array_expr(_t, aD.Get());
 			_t = _retTree;
 		}
 		else {
@@ -2184,23 +2232,23 @@
 	
 	if( dec_inc == DECSTATEMENT) 
 	{
-	aD->Dec(); 
+	aD.Get()->Dec(); 
 	res = NULL;
 	}
 	else if( dec_inc == INCSTATEMENT)
 	{
-	aD->Inc();
+	aD.Get()->Inc();
 	res = NULL;
 	}
 	else
 	{
-	if( dec_inc == DEC) aD->Dec(); //*** aD->Assign( dec_inc);
-	else if( dec_inc == INC) aD->Inc();
+	if( dec_inc == DEC) aD.Get()->Dec(); //*** aD->Assign( dec_inc);
+	else if( dec_inc == INC) aD.Get()->Inc();
 	//                
-	res=aD->ADResolve();
+	res=aD.Get()->ADResolve();
 	
-	if( dec_inc == POSTDEC) aD->Dec();
-	else if( dec_inc == POSTINC) aD->Inc();
+	if( dec_inc == POSTDEC) aD.Get()->Dec();
+	else if( dec_inc == POSTINC) aD.Get()->Inc();
 	}
 	
 	_retTree = _t;
@@ -2214,44 +2262,15 @@
 	
 	ArrayIndexListT* aL;
 	BaseGDL**        rP;
-	//DStructGDL*      structR;
-	ArrayIndexListGuard guard;
 		
 		if( _t->getType() == ARRAYEXPR)
 		{
 			rP=l_indexable_expr(_t->getFirstChild());
 			aL=arrayindex_list(_retTree);
-			guard.reset(aL);
 	
 			_retTree = _t->getNextSibling();
 	
-			// check here for object and get struct
-	//		structR=dynamic_cast<DStructGDL*>(*rP);
-	//		if( structR == NULL)
-			if( (*rP)->Type() != GDL_STRUCT)
-	{
-	bool isObj = callStack.back()->IsObject();
-	if( isObj)
-	{
-	DStructGDL* oStruct = ObjectStructCheckAccess( *rP, _t);
-	// oStruct cannot be "Assoc_"
-	aD->ADRoot( oStruct, guard.release()); 
-	}
-	else
-	{
-	throw GDLException( _t, "Expression must be a"
-	" STRUCT in this context: "+Name(*rP),
-	true,false);
-	}
-	}
-			else 
-	{
-	DStructGDL* structR=static_cast<DStructGDL*>(*rP);
-	if( (*rP)->IsAssoc())
-	throw GDLException( _t, "File expression not allowed "
-	"in this context: "+Name(*rP),true,false);
-	aD->ADRoot( structR, guard.release() /* aL */); 
-	}
+	SetRootL( _t, aD, *rP, aL); 
 		}
 	else
 		// case ARRAYEXPR_MFCALL:
@@ -2266,37 +2285,8 @@
 		// case VARPTR:
 		{
 			rP=l_indexable_expr(_t);
-			//_t = _retTree; _retTree set ok
 	
-			// check here for object and get struct
-			//structR = dynamic_cast<DStructGDL*>(*rP);
-			//if( structR == NULL)
-			if( (*rP)->Type() != GDL_STRUCT)
-	{
-	bool isObj = callStack.back()->IsObject();
-	if( isObj) // member access to object?
-	{
-	DStructGDL* oStruct = ObjectStructCheckAccess( *rP, _t);
-	// oStruct cannot be "Assoc_"
-	aD->ADRoot( oStruct); 
-	}
-	else
-	{
-	throw GDLException( _t, "Expression must be a"
-	" STRUCT in this context: "+Name(*rP),
-	true,false);
-	}
-	}
-			else
-	{
-	DStructGDL* structR=static_cast<DStructGDL*>(*rP);
-	if( (*rP)->IsAssoc())
-	{
-	throw GDLException( _t, "File expression not allowed "
-	"in this context: "+Name(*rP),true,false);
-	}
-	aD->ADRoot(structR); 
-	}
+	SetRootL( _t, aD, *rP, NULL); 
 		}
 	return;
 	//	_retTree = _t;
@@ -2385,7 +2375,6 @@
 		_t = _retTree;
 		aL=arrayindex_list(_t);
 		_t = _retTree;
-		aD->ADAddIx(aL);
 		_t = __t75;
 		_t = _t->getNextSibling();
 		break;
@@ -2395,7 +2384,6 @@
 	{
 		tag_expr(_t, aD);
 		_t = _retTree;
-		aD->ADAddIx(NULL);
 		break;
 	}
 	default:
@@ -2429,7 +2417,7 @@
 		e1=expr(_t);
 		_t = _retTree;
 		
-		auto_ptr<BaseGDL> e1_guard(e1);
+		Guard<BaseGDL> e1_guard(e1);
 		
 		if( e1->True())
 		{
@@ -2452,7 +2440,7 @@
 		match(antlr::RefAST(_t),ASSIGN);
 		_t = _t->getFirstChild();
 		
-		auto_ptr<BaseGDL> r_guard;
+		Guard<BaseGDL> r_guard;
 		
 		{
 		if (_t == ProgNodeP(antlr::nullAST) )
@@ -2491,7 +2479,7 @@
 		{
 			e1=indexable_tmp_expr(_t);
 			_t = _retTree;
-			r_guard.reset( e1);
+			r_guard.Init( e1);
 			break;
 		}
 		case FCALL_LIB:
@@ -2500,7 +2488,7 @@
 			_t = _retTree;
 			
 			if( !callStack.back()->Contains( e1)) 
-			r_guard.reset( e1); // guard if no global data
+			r_guard.Init( e1); // guard if no global data
 			
 			break;
 		}
@@ -2533,7 +2521,7 @@
 		match(antlr::RefAST(_t),ASSIGN_ARRAYEXPR_MFCALL);
 		_t = _t->getFirstChild();
 		
-		auto_ptr<BaseGDL> r_guard;
+		Guard<BaseGDL> r_guard;
 		
 		{
 		if (_t == ProgNodeP(antlr::nullAST) )
@@ -2572,7 +2560,7 @@
 		{
 			e1=indexable_tmp_expr(_t);
 			_t = _retTree;
-			r_guard.reset( e1);
+			r_guard.Init( e1);
 			break;
 		}
 		case FCALL_LIB:
@@ -2581,7 +2569,7 @@
 			_t = _retTree;
 			
 			if( !callStack.back()->Contains( e1)) 
-			r_guard.reset( e1); // guard if no global data
+			r_guard.Init( e1); // guard if no global data
 			
 			break;
 		}
@@ -2606,7 +2594,7 @@
 		{
 		delete *tmp;
 		
-		if( r_guard.get() == e1)
+		if( r_guard.Get() == e1)
 		*tmp = r_guard.release();
 		else          
 		*tmp = e1->Dup();
@@ -2640,7 +2628,7 @@
 		match(antlr::RefAST(_t),ASSIGN_REPLACE);
 		_t = _t->getFirstChild();
 		
-		auto_ptr<BaseGDL> r_guard;
+		Guard<BaseGDL> r_guard;
 		
 		{
 		if (_t == ProgNodeP(antlr::nullAST) )
@@ -2675,7 +2663,7 @@
 			e1=tmp_expr(_t);
 			_t = _retTree;
 			
-			r_guard.reset( e1);
+			r_guard.Init( e1);
 			
 			break;
 		}
@@ -2685,7 +2673,7 @@
 			_t = _retTree;
 			
 			if( !callStack.back()->Contains( e1)) 
-			r_guard.reset( e1);
+			r_guard.Init( e1);
 			
 			break;
 		}
@@ -2737,7 +2725,7 @@
 		{
 		delete *tmp;
 		
-		if( r_guard.get() == e1)
+		if( r_guard.Get() == e1)
 		*tmp = r_guard.release();
 		else  
 		*tmp = e1->Dup();
@@ -2784,7 +2772,7 @@
 		match(antlr::RefAST(_t),IDENTIFIER);
 		_t = _t->getNextSibling();
 		
-		auto_ptr<BaseGDL> self_guard(self);
+		Guard<BaseGDL> self_guard(self);
 		
 		EnvUDT* newEnv;
 		
@@ -3117,7 +3105,7 @@
 	//     _t = _t->getFirstChild();
 	//     e1=expr(_t);
 	//     _t = _retTree;
-	//     auto_ptr<BaseGDL> e1_guard(e1);
+	//     Guard<BaseGDL> e1_guard(e1);
 	//     if( e1->True())
 	//     {
 	//         res=l_expr(_t, right);
@@ -3166,7 +3154,7 @@
 	//     res=l_sys_var(_t);
 	//     // _t = _retTree; // ok
 	
-	//     auto_ptr<BaseGDL> conv_guard; //( rConv);
+	//     Guard<BaseGDL> conv_guard; //( rConv);
 	//     BaseGDL* rConv = right;
 	//     if( !(*res)->EqType( right))
 	//     {
@@ -3224,7 +3212,7 @@
 	//       _t = _t->getFirstChild();
 	
 	//       SizeT nDot = tIn->nDot;
-	//       auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+	//       Guard<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
 	
 	//       l_dot_array_expr(_t, aD.get());
 	//       _t = _retTree;
@@ -3867,7 +3855,7 @@
 	ProgNodeP parameter_def_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	
 	// as actEnv is not on the stack guard it here
-	auto_ptr<EnvBaseT> guard(actEnv); 
+	Guard<EnvBaseT> guard(actEnv); 
 	
 	EnvBaseT* callerEnv = callStack.back();
 	EnvBaseT* oldNewEnv = callerEnv->GetNewEnv();
@@ -4059,7 +4047,7 @@
 	match(antlr::RefAST(_t),IDENTIFIER);
 	_t = _t->getNextSibling();
 	
-	auto_ptr<BaseGDL> self_guard(self);
+	Guard<BaseGDL> self_guard(self);
 	
 	try {
 	newEnv=new EnvUDT( self, mp2, "", true);
@@ -4094,9 +4082,9 @@
 	_t = _t->getFirstChild();
 	
 	SizeT nDot=dot->nDot;
-	auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+	Guard<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
 	
-	l_dot_array_expr(_t, aD.get());
+	l_dot_array_expr(_t, aD.Get());
 	_t = _retTree;
 	{ // ( ... )+
 	int _cnt119=0;
@@ -4104,7 +4092,7 @@
 		if (_t == ProgNodeP(antlr::nullAST) )
 			_t = ASTNULL;
 		if ((_t->getType() == ARRAYEXPR || _t->getType() == EXPR || _t->getType() == IDENTIFIER)) {
-			tag_array_expr(_t, aD.get());
+			tag_array_expr(_t, aD.Get());
 			_t = _retTree;
 		}
 		else {
@@ -4123,7 +4111,7 @@
 	"Struct expression not allowed in this context.",
 	true,false);
 	
-	aD->ADAssign( right);
+	aD.Get()->ADAssign( right);
 	
 	res=NULL;
 	
@@ -4148,10 +4136,10 @@
 			_t = _t->getFirstChild();
 			e=expr(_t);
 			
-			auto_ptr<BaseGDL> e_guard(e);
+			Guard<BaseGDL> e_guard(e);
 			
 			SizeT tagIx;
-			int ret=e->Scalar2index(tagIx);
+			int ret=e->Scalar2Index(tagIx);
 			if( ret < 1) // this is a return code, not the index
 	throw GDLException( tIn, "Expression must be a scalar"
 	" >= 0 in this context: "+Name(e),true,false);
@@ -4183,17 +4171,6 @@
 		_t = _t->getFirstChild();
 		e=expr(_t);
 		_t = _retTree;
-		
-		auto_ptr<BaseGDL> e_guard(e);
-		
-		SizeT tagIx;
-		int ret=e->Scalar2index(tagIx);
-		if( ret < 1) // this is a return code, not the index
-		throw GDLException( _t, "Expression must be a scalar"
-		" >= 0 in this context: "+Name(e),true,false);
-		
-		aD->ADAdd( tagIx);
-		
 		_t = __t73;
 		_t = _t->getNextSibling();
 		break;
@@ -4203,10 +4180,6 @@
 		i = _t;
 		match(antlr::RefAST(_t),IDENTIFIER);
 		_t = _t->getNextSibling();
-		
-		std::string tagName=i->getText();
-		aD->ADAdd( tagName);
-		
 		break;
 	}
 	default:
@@ -4318,7 +4291,6 @@
 	
 	BaseGDL*         r;
 	ArrayIndexListT* aL;
-	ArrayIndexListGuard guard;
 	
 	
 	if (_t == ProgNodeP(antlr::nullAST) )
@@ -4334,58 +4306,11 @@
 		_t = _retTree;
 		aL=arrayindex_list(_t);
 		_t = _retTree;
-		guard.reset(aL);
 		_t = __t79;
 		_t = _t->getNextSibling();
 		
 		// check here for object and get struct
-		if( r->Type() != GDL_STRUCT)
-		{
-		// if( r->Type() != GDL_OBJ)
-		//     {
-		//         // check for Get/SetProperty
-		//         throw GDLException( _t, "Expression must be a"
-		//                             " STRUCT in this context: "+
-		//                             Name(r),true,false);
-		//     }
-		bool isObj = callStack.back()->IsObject();
-		if( isObj)
-		{
-		DStructGDL* oStruct = ObjectStructCheckAccess( r, _t);
-		
-		//                    DStructGDL* obj = oStruct->Index( aL);
-		
-		if( aD->IsOwner()) delete r; 
-		aD->SetOwner( false); // object struct, not owned
-		
-		aD->ADRoot( oStruct, guard.release()); 
-		//                    aD->ADRoot( obj); 
-		
-		//                     BaseGDL* obj = r->Index( aL);
-		//                     auto_ptr<BaseGDL> objGuard( obj); // new object -> guard
-		
-		//                     DStructGDL* oStruct = ObjectStructCheckAccess( obj, _t);
-		
-		//                     // oStruct cannot be "Assoc_"
-		//                     if( aD->IsOwner()) delete r; 
-		//                     aD->SetOwner( false); // object structs are never owned
-		//                     aD->ADRoot( oStruct); 
-		}
-		else
-		{
-		throw GDLException( _t, "Expression must be a"
-		" STRUCT in this context: "+Name(r),true,false);
-		}
-		}
-		else
-		{
-		if( r->IsAssoc())
-		throw GDLException( _t, "File expression not allowed "
-		"in this context: "+Name(r),true,false);
-		
-		DStructGDL* structR=static_cast<DStructGDL*>(r);
-		aD->ADRoot( structR, guard.release()); 
-		}
+		SetRootR( _t, aD, r, aL); 
 		
 		break;
 	}
@@ -4398,37 +4323,7 @@
 		_t = _retTree;
 		
 		// check here for object and get struct
-		// structR = dynamic_cast<DStructGDL*>(r);
-		// if( structR == NULL)
-		if( r->Type() != GDL_STRUCT)
-		{
-		bool isObj = callStack.back()->IsObject();
-		if( isObj) // member access to object?
-		{
-		DStructGDL* oStruct = ObjectStructCheckAccess( r, _t);
-		
-		// oStruct cannot be "Assoc_"
-		if( aD->IsOwner()) delete r;
-		aD->SetOwner( false); // object structs are never owned
-		aD->ADRoot( oStruct); 
-		}
-		else
-		{
-		throw GDLException( _t, "Expression must be a"
-		" STRUCT in this context: "+Name(r),true,false);
-		}
-		}
-		else
-		{
-		if( r->IsAssoc())
-		{
-		throw GDLException( _t, "File expression not allowed "
-		"in this context: "+Name(r),true,false);
-		}
-		
-		DStructGDL* structR=static_cast<DStructGDL*>(r);
-		aD->ADRoot(structR); 
-		}
+		SetRootR( _t, aD, r, NULL); 
 		
 		break;
 	}
@@ -4986,9 +4881,9 @@
 	_t = _t->getFirstChild();
 	
 	SizeT nDot=dot->nDot;
-	auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+	Guard<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
 	
-	l_dot_array_expr(_t, aD.get());
+	l_dot_array_expr(_t, aD.Get());
 	_t = _retTree;
 	{ // ( ... )+
 	int _cnt124=0;
@@ -4996,7 +4891,7 @@
 		if (_t == ProgNodeP(antlr::nullAST) )
 			_t = ASTNULL;
 		if ((_t->getType() == ARRAYEXPR || _t->getType() == EXPR || _t->getType() == IDENTIFIER)) {
-			tag_array_expr(_t, aD.get());
+			tag_array_expr(_t, aD.Get());
 			_t = _retTree;
 		}
 		else {
@@ -5017,7 +4912,7 @@
 	"Struct expression not allowed in this context.",
 	true,false);
 	
-	aD->ADAssign( right);
+	aD.Get()->ADAssign( right);
 	
 	res=NULL;
 	
@@ -5030,7 +4925,7 @@
 ) {
 	ProgNodeP parameter_def_n_elements_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	
-	auto_ptr<EnvBaseT> guard(actEnv); 
+	Guard<EnvBaseT> guard(actEnv); 
 	_retTree = _t;
 	//     bool interruptEnableIn = interruptEnable;
 	if( _retTree != NULL)
@@ -5111,7 +5006,7 @@
 ) {
 	ProgNodeP parameter_def_nocheck_AST_in = (_t == ProgNodeP(ASTNULL)) ? ProgNodeP(antlr::nullAST) : _t;
 	
-	auto_ptr<EnvBaseT> guard(actEnv); 
+	Guard<EnvBaseT> guard(actEnv); 
 	
 	EnvBaseT* callerEnv = callStack.back();
 	EnvBaseT* oldNewEnv = callerEnv->GetNewEnv();
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/GDLInterpreter.hpp gdl/src/GDLInterpreter.hpp
--- gdl-0.9.3/src/GDLInterpreter.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/GDLInterpreter.hpp	2013-05-16 12:36:32.994858713 -0600
@@ -3,7 +3,7 @@
 
 #include <antlr/config.hpp>
 #include "GDLInterpreterTokenTypes.hpp"
-/* $ANTLR 2.7.7 (20110618): "gdlc.i.g" -> "GDLInterpreter.hpp"$ */
+/* $ANTLR 2.7.7 (20120518): "gdlc.i.g" -> "GDLInterpreter.hpp"$ */
 #include <antlr/TreeParser.hpp>
 
 
@@ -116,8 +116,11 @@
     static int GetFunIx( const std::string& subName);
     static int GetProIx( ProgNodeP);//const std::string& subName);
     static int GetProIx( const std::string& subName);
-    DStructGDL* ObjectStruct( BaseGDL* self, ProgNodeP mp);
-    DStructGDL* ObjectStructCheckAccess( BaseGDL* self, ProgNodeP mp);
+    DStructGDL* ObjectStruct( DObjGDL* self, ProgNodeP mp);
+    void SetRootR( ProgNodeP tt, DotAccessDescT* aD, BaseGDL* r, ArrayIndexListT* aL);
+    void SetRootL( ProgNodeP tt, DotAccessDescT* aD, BaseGDL* r, ArrayIndexListT* aL);
+    // DStructGDL* ObjectStructCheckAccess( DObjGDL* self, ProgNodeP mp);
+    // DStructDesc* GDLObjectDesc( DObjGDL* self, ProgNodeP mp);
 
     // code in: dinterpreter.cpp
     static void SetFunIx( ProgNodeP f); // triggers read/compile
@@ -592,6 +595,9 @@
         return "<(ptr to undefined expression not found on the heap)>";
     }
 
+
+
+
     // compiler (lexer, parser, treeparser) def in dinterpreter.cpp
     static void ReportCompileError( GDLException& e, const std::string& file = "");
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/GDLInterpreterTokenTypes.hpp gdl/src/GDLInterpreterTokenTypes.hpp
--- gdl-0.9.3/src/GDLInterpreterTokenTypes.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/GDLInterpreterTokenTypes.hpp	2013-05-16 12:36:32.995858709 -0600
@@ -1,7 +1,7 @@
 #ifndef INC_GDLInterpreterTokenTypes_hpp_
 #define INC_GDLInterpreterTokenTypes_hpp_
 
-/* $ANTLR 2.7.7 (20110618): "gdlc.i.g" -> "GDLInterpreterTokenTypes.hpp"$ */
+/* $ANTLR 2.7.7 (20120518): "gdlc.i.g" -> "GDLInterpreterTokenTypes.hpp"$ */
 
 #ifndef CUSTOM_API
 # define CUSTOM_API
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/GDLInterpreterTokenTypes.txt gdl/src/GDLInterpreterTokenTypes.txt
--- gdl-0.9.3/src/GDLInterpreterTokenTypes.txt	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/GDLInterpreterTokenTypes.txt	2013-05-16 12:36:32.997858702 -0600
@@ -1,4 +1,4 @@
-// $ANTLR 2.7.7 (20110618): gdlc.i.g -> GDLInterpreterTokenTypes.txt$
+// $ANTLR 2.7.7 (20120518): gdlc.i.g -> GDLInterpreterTokenTypes.txt$
 GDLInterpreter    // output token vocab name
 ALL=4
 ASSIGN=5
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/GDLLexer.cpp gdl/src/GDLLexer.cpp
--- gdl-0.9.3/src/GDLLexer.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/GDLLexer.cpp	2013-05-16 12:36:33.021858616 -0600
@@ -1,4 +1,4 @@
-/* $ANTLR 2.7.7 (20110618): "gdlc.g" -> "GDLLexer.cpp"$ */
+/* $ANTLR 2.7.7 (20120518): "gdlc.g" -> "GDLLexer.cpp"$ */
 
 #include "includefirst.hpp"
 
@@ -38,45 +38,45 @@
 {
 	literals["endcase"] = 98;
 	literals["case"] = 92;
+	literals["while"] = 88;
 	literals["repeat"] = 78;
-	literals["endforeach"] = 101;
 	literals["ne"] = 117;
+	literals["endif"] = 102;
 	literals["end"] = 97;
 	literals["le"] = 114;
 	literals["then"] = 124;
-	literals["begin"] = 91;
 	literals["endswitch"] = 104;
+	literals["until"] = 125;
 	literals["and"] = 90;
 	literals["endrep"] = 103;
 	literals["not"] = 118;
-	literals["on_ioerror"] = 120;
+	literals["foreach"] = 32;
 	literals["mod"] = 116;
+	literals["forward_function"] = 107;
 	literals["do"] = 95;
 	literals["function"] = 108;
 	literals["endfor"] = 100;
 	literals["gt"] = 111;
+	literals["compile_opt"] = 94;
 	literals["inherits"] = 113;
 	literals["of"] = 119;
 	literals["or"] = 121;
 	literals["if"] = 112;
 	literals["pro"] = 122;
 	literals["xor"] = 126;
-	literals["compile_opt"] = 94;
 	literals["ge"] = 109;
 	literals["goto"] = 110;
 	literals["for"] = 30;
 	literals["eq"] = 106;
-	literals["forward_function"] = 107;
-	literals["foreach"] = 32;
+	literals["on_ioerror"] = 120;
 	literals["endelse"] = 99;
-	literals["until"] = 125;
+	literals["begin"] = 91;
 	literals["else"] = 96;
 	literals["lt"] = 115;
 	literals["endwhile"] = 105;
 	literals["switch"] = 123;
 	literals["common"] = 93;
-	literals["endif"] = 102;
-	literals["while"] = 88;
+	literals["endforeach"] = 101;
 }
 
 antlr::RefToken GDLLexer::nextToken()
@@ -400,11 +400,11 @@
 			}
 		}
 		else {
-			goto _loop261;
+			goto _loop263;
 		}
 		
 	}
-	_loop261:;
+	_loop263:;
 	} // ( ... )*
 	if ( _createToken && _token==antlr::nullToken && _ttype!=antlr::Token::SKIP ) {
 	   _token = makeToken(_ttype);
@@ -1152,10 +1152,10 @@
 	std::string::size_type _saveIndex;
 	
 	{
-	bool synPredMatched313 = false;
+	bool synPredMatched315 = false;
 	if (((LA(1) == 0xd /* '\r' */ ) && (LA(2) == 0xa /* '\n' */ ) && (true))) {
-		int _m313 = mark();
-		synPredMatched313 = true;
+		int _m315 = mark();
+		synPredMatched315 = true;
 		inputState->guessing++;
 		try {
 			{
@@ -1163,12 +1163,12 @@
 			}
 		}
 		catch (antlr::RecognitionException& pe) {
-			synPredMatched313 = false;
+			synPredMatched315 = false;
 		}
-		rewind(_m313);
+		rewind(_m315);
 		inputState->guessing--;
 	}
-	if ( synPredMatched313 ) {
+	if ( synPredMatched315 ) {
 		match("\r\n");
 	}
 	else if ((LA(1) == 0xa /* '\n' */ )) {
@@ -1419,18 +1419,18 @@
 		}
 		}
 		{ // ( ... )+
-		int _cnt331=0;
+		int _cnt333=0;
 		for (;;) {
 			if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 				mD(false);
 			}
 			else {
-				if ( _cnt331>=1 ) { goto _loop331; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+				if ( _cnt333>=1 ) { goto _loop333; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 			}
 			
-			_cnt331++;
+			_cnt333++;
 		}
-		_loop331:;
+		_loop333:;
 		}  // ( ... )+
 	}
 	else {
@@ -1504,18 +1504,18 @@
 		}
 		}
 		{ // ( ... )+
-		int _cnt338=0;
+		int _cnt340=0;
 		for (;;) {
 			if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 				mD(false);
 			}
 			else {
-				if ( _cnt338>=1 ) { goto _loop338; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+				if ( _cnt340>=1 ) { goto _loop340; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 			}
 			
-			_cnt338++;
+			_cnt340++;
 		}
-		_loop338:;
+		_loop340:;
 		}  // ( ... )+
 	}
 	else {
@@ -1939,27 +1939,27 @@
 	_ttype = CONSTANT_OR_STRING_LITERAL;
 	std::string::size_type _saveIndex;
 	
-	bool synPredMatched384 = false;
+	bool synPredMatched386 = false;
 	if (((LA(1) == 0x27 /* '\'' */ ) && (_tokenSet_4.member(LA(2))) && (_tokenSet_5.member(LA(3))))) {
-		int _m384 = mark();
-		synPredMatched384 = true;
+		int _m386 = mark();
+		synPredMatched386 = true;
 		inputState->guessing++;
 		try {
 			{
 			match('\'' /* charlit */ );
 			{ // ( ... )+
-			int _cnt382=0;
+			int _cnt384=0;
 			for (;;) {
 				if ((_tokenSet_4.member(LA(1)))) {
 					mH(false);
 				}
 				else {
-					if ( _cnt382>=1 ) { goto _loop382; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+					if ( _cnt384>=1 ) { goto _loop384; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 				}
 				
-				_cnt382++;
+				_cnt384++;
 			}
-			_loop382:;
+			_loop384:;
 			}  // ( ... )+
 			match('\'' /* charlit */ );
 			{
@@ -1995,29 +1995,29 @@
 			}
 		}
 		catch (antlr::RecognitionException& pe) {
-			synPredMatched384 = false;
+			synPredMatched386 = false;
 		}
-		rewind(_m384);
+		rewind(_m386);
 		inputState->guessing--;
 	}
-	if ( synPredMatched384 ) {
+	if ( synPredMatched386 ) {
 		{
 		_saveIndex = text.length();
 		match('\'' /* charlit */ );
 		text.erase(_saveIndex);
 		{ // ( ... )+
-		int _cnt387=0;
+		int _cnt389=0;
 		for (;;) {
 			if ((_tokenSet_4.member(LA(1)))) {
 				mH(false);
 			}
 			else {
-				if ( _cnt387>=1 ) { goto _loop387; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+				if ( _cnt389>=1 ) { goto _loop389; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 			}
 			
-			_cnt387++;
+			_cnt389++;
 		}
-		_loop387:;
+		_loop389:;
 		}  // ( ... )+
 		_saveIndex = text.length();
 		match('\'' /* charlit */ );
@@ -2114,27 +2114,27 @@
 		}
 	}
 	else {
-		bool synPredMatched393 = false;
+		bool synPredMatched395 = false;
 		if (((LA(1) == 0x27 /* '\'' */ ) && ((LA(2) >= 0x30 /* '0' */  && LA(2) <= 0x37 /* '7' */ )) && (_tokenSet_6.member(LA(3))))) {
-			int _m393 = mark();
-			synPredMatched393 = true;
+			int _m395 = mark();
+			synPredMatched395 = true;
 			inputState->guessing++;
 			try {
 				{
 				match('\'' /* charlit */ );
 				{ // ( ... )+
-				int _cnt391=0;
+				int _cnt393=0;
 				for (;;) {
 					if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x37 /* '7' */ ))) {
 						mO(false);
 					}
 					else {
-						if ( _cnt391>=1 ) { goto _loop391; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+						if ( _cnt393>=1 ) { goto _loop393; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 					}
 					
-					_cnt391++;
+					_cnt393++;
 				}
-				_loop391:;
+				_loop393:;
 				}  // ( ... )+
 				match('\'' /* charlit */ );
 				{
@@ -2161,29 +2161,29 @@
 				}
 			}
 			catch (antlr::RecognitionException& pe) {
-				synPredMatched393 = false;
+				synPredMatched395 = false;
 			}
-			rewind(_m393);
+			rewind(_m395);
 			inputState->guessing--;
 		}
-		if ( synPredMatched393 ) {
+		if ( synPredMatched395 ) {
 			{
 			_saveIndex = text.length();
 			match('\'' /* charlit */ );
 			text.erase(_saveIndex);
 			{ // ( ... )+
-			int _cnt396=0;
+			int _cnt398=0;
 			for (;;) {
 				if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x37 /* '7' */ ))) {
 					mO(false);
 				}
 				else {
-					if ( _cnt396>=1 ) { goto _loop396; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+					if ( _cnt398>=1 ) { goto _loop398; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 				}
 				
-				_cnt396++;
+				_cnt398++;
 			}
-			_loop396:;
+			_loop398:;
 			}  // ( ... )+
 			_saveIndex = text.length();
 			match('\'' /* charlit */ );
@@ -2280,27 +2280,27 @@
 			}
 		}
 		else {
-			bool synPredMatched402 = false;
+			bool synPredMatched404 = false;
 			if (((LA(1) == 0x27 /* '\'' */ ) && (LA(2) == 0x30 /* '0' */  || LA(2) == 0x31 /* '1' */ ) && (LA(3) == 0x27 /* '\'' */  || LA(3) == 0x30 /* '0' */  || LA(3) == 0x31 /* '1' */ ))) {
-				int _m402 = mark();
-				synPredMatched402 = true;
+				int _m404 = mark();
+				synPredMatched404 = true;
 				inputState->guessing++;
 				try {
 					{
 					match('\'' /* charlit */ );
 					{ // ( ... )+
-					int _cnt400=0;
+					int _cnt402=0;
 					for (;;) {
 						if ((LA(1) == 0x30 /* '0' */  || LA(1) == 0x31 /* '1' */ )) {
 							mB(false);
 						}
 						else {
-							if ( _cnt400>=1 ) { goto _loop400; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+							if ( _cnt402>=1 ) { goto _loop402; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 						}
 						
-						_cnt400++;
+						_cnt402++;
 					}
-					_loop400:;
+					_loop402:;
 					}  // ( ... )+
 					match('\'' /* charlit */ );
 					{
@@ -2327,29 +2327,29 @@
 					}
 				}
 				catch (antlr::RecognitionException& pe) {
-					synPredMatched402 = false;
+					synPredMatched404 = false;
 				}
-				rewind(_m402);
+				rewind(_m404);
 				inputState->guessing--;
 			}
-			if ( synPredMatched402 ) {
+			if ( synPredMatched404 ) {
 				{
 				_saveIndex = text.length();
 				match('\'' /* charlit */ );
 				text.erase(_saveIndex);
 				{ // ( ... )+
-				int _cnt405=0;
+				int _cnt407=0;
 				for (;;) {
 					if ((LA(1) == 0x30 /* '0' */  || LA(1) == 0x31 /* '1' */ )) {
 						mB(false);
 					}
 					else {
-						if ( _cnt405>=1 ) { goto _loop405; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+						if ( _cnt407>=1 ) { goto _loop407; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 					}
 					
-					_cnt405++;
+					_cnt407++;
 				}
-				_loop405:;
+				_loop407:;
 				}  // ( ... )+
 				_saveIndex = text.length();
 				match('\'' /* charlit */ );
@@ -2446,27 +2446,27 @@
 				}
 			}
 			else {
-				bool synPredMatched375 = false;
+				bool synPredMatched377 = false;
 				if (((LA(1) == 0x22 /* '\"' */ ) && ((LA(2) >= 0x30 /* '0' */  && LA(2) <= 0x37 /* '7' */ )) && (true))) {
-					int _m375 = mark();
-					synPredMatched375 = true;
+					int _m377 = mark();
+					synPredMatched377 = true;
 					inputState->guessing++;
 					try {
 						{
 						match('\"' /* charlit */ );
 						{ // ( ... )+
-						int _cnt373=0;
+						int _cnt375=0;
 						for (;;) {
 							if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x37 /* '7' */ ))) {
 								mO(false);
 							}
 							else {
-								if ( _cnt373>=1 ) { goto _loop373; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+								if ( _cnt375>=1 ) { goto _loop375; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 							}
 							
-							_cnt373++;
+							_cnt375++;
 						}
-						_loop373:;
+						_loop375:;
 						}  // ( ... )+
 						{
 						switch ( LA(1)) {
@@ -2505,29 +2505,29 @@
 						}
 					}
 					catch (antlr::RecognitionException& pe) {
-						synPredMatched375 = false;
+						synPredMatched377 = false;
 					}
-					rewind(_m375);
+					rewind(_m377);
 					inputState->guessing--;
 				}
-				if ( synPredMatched375 ) {
+				if ( synPredMatched377 ) {
 					{
 					_saveIndex = text.length();
 					match('\"' /* charlit */ );
 					text.erase(_saveIndex);
 					{ // ( ... )+
-					int _cnt378=0;
+					int _cnt380=0;
 					for (;;) {
 						if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x37 /* '7' */ ))) {
 							mO(false);
 						}
 						else {
-							if ( _cnt378>=1 ) { goto _loop378; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+							if ( _cnt380>=1 ) { goto _loop380; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 						}
 						
-						_cnt378++;
+						_cnt380++;
 					}
-					_loop378:;
+					_loop380:;
 					}  // ( ... )+
 					if ( inputState->guessing==0 ) {
 						_ttype=CONSTANT_OCT_I;
@@ -2618,10 +2618,10 @@
 					}
 				}
 				else {
-					bool synPredMatched426 = false;
+					bool synPredMatched428 = false;
 					if (((_tokenSet_7.member(LA(1))) && (_tokenSet_8.member(LA(2))) && (true))) {
-						int _m426 = mark();
-						synPredMatched426 = true;
+						int _m428 = mark();
+						synPredMatched428 = true;
 						inputState->guessing++;
 						try {
 							{
@@ -2639,18 +2639,18 @@
 							{
 								{
 								{ // ( ... )+
-								int _cnt418=0;
+								int _cnt420=0;
 								for (;;) {
 									if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 										mD(false);
 									}
 									else {
-										if ( _cnt418>=1 ) { goto _loop418; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+										if ( _cnt420>=1 ) { goto _loop420; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 									}
 									
-									_cnt418++;
+									_cnt420++;
 								}
-								_loop418:;
+								_loop420:;
 								}  // ( ... )+
 								{
 								switch ( LA(1)) {
@@ -2668,11 +2668,11 @@
 											mD(false);
 										}
 										else {
-											goto _loop421;
+											goto _loop423;
 										}
 										
 									}
-									_loop421:;
+									_loop423:;
 									} // ( ... )*
 									{
 									mDBL(false);
@@ -2692,18 +2692,18 @@
 							{
 								match('.' /* charlit */ );
 								{ // ( ... )+
-								int _cnt424=0;
+								int _cnt426=0;
 								for (;;) {
 									if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 										mD(false);
 									}
 									else {
-										if ( _cnt424>=1 ) { goto _loop424; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+										if ( _cnt426>=1 ) { goto _loop426; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 									}
 									
-									_cnt424++;
+									_cnt426++;
 								}
-								_loop424:;
+								_loop426:;
 								}  // ( ... )+
 								{
 								mDBL(false);
@@ -2718,12 +2718,12 @@
 							}
 						}
 						catch (antlr::RecognitionException& pe) {
-							synPredMatched426 = false;
+							synPredMatched428 = false;
 						}
-						rewind(_m426);
+						rewind(_m428);
 						inputState->guessing--;
 					}
-					if ( synPredMatched426 ) {
+					if ( synPredMatched428 ) {
 						{
 						switch ( LA(1)) {
 						case 0x30 /* '0' */ :
@@ -2739,18 +2739,18 @@
 						{
 							{
 							{ // ( ... )+
-							int _cnt430=0;
+							int _cnt432=0;
 							for (;;) {
 								if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 									mD(false);
 								}
 								else {
-									if ( _cnt430>=1 ) { goto _loop430; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+									if ( _cnt432>=1 ) { goto _loop432; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 								}
 								
-								_cnt430++;
+								_cnt432++;
 							}
-							_loop430:;
+							_loop432:;
 							}  // ( ... )+
 							{
 							switch ( LA(1)) {
@@ -2768,11 +2768,11 @@
 										mD(false);
 									}
 									else {
-										goto _loop433;
+										goto _loop435;
 									}
 									
 								}
-								_loop433:;
+								_loop435:;
 								} // ( ... )*
 								{
 								mDBL(false);
@@ -2792,18 +2792,18 @@
 						{
 							match('.' /* charlit */ );
 							{ // ( ... )+
-							int _cnt436=0;
+							int _cnt438=0;
 							for (;;) {
 								if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 									mD(false);
 								}
 								else {
-									if ( _cnt436>=1 ) { goto _loop436; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+									if ( _cnt438>=1 ) { goto _loop438; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 								}
 								
-								_cnt436++;
+								_cnt438++;
 							}
-							_loop436:;
+							_loop438:;
 							}  // ( ... )+
 							{
 							mDBL(false);
@@ -2821,10 +2821,10 @@
 						}
 					}
 					else {
-						bool synPredMatched449 = false;
+						bool synPredMatched451 = false;
 						if (((_tokenSet_7.member(LA(1))) && (_tokenSet_9.member(LA(2))) && (true))) {
-							int _m449 = mark();
-							synPredMatched449 = true;
+							int _m451 = mark();
+							synPredMatched451 = true;
 							inputState->guessing++;
 							try {
 								{
@@ -2842,18 +2842,18 @@
 								{
 									{
 									{ // ( ... )+
-									int _cnt441=0;
+									int _cnt443=0;
 									for (;;) {
 										if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 											mD(false);
 										}
 										else {
-											if ( _cnt441>=1 ) { goto _loop441; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+											if ( _cnt443>=1 ) { goto _loop443; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 										}
 										
-										_cnt441++;
+										_cnt443++;
 									}
-									_loop441:;
+									_loop443:;
 									}  // ( ... )+
 									{
 									switch ( LA(1)) {
@@ -2871,11 +2871,11 @@
 												mD(false);
 											}
 											else {
-												goto _loop444;
+												goto _loop446;
 											}
 											
 										}
-										_loop444:;
+										_loop446:;
 										} // ( ... )*
 										{
 										if ((LA(1) == 0x65 /* 'e' */ )) {
@@ -2900,18 +2900,18 @@
 								{
 									match('.' /* charlit */ );
 									{ // ( ... )+
-									int _cnt447=0;
+									int _cnt449=0;
 									for (;;) {
 										if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 											mD(false);
 										}
 										else {
-											if ( _cnt447>=1 ) { goto _loop447; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+											if ( _cnt449>=1 ) { goto _loop449; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 										}
 										
-										_cnt447++;
+										_cnt449++;
 									}
-									_loop447:;
+									_loop449:;
 									}  // ( ... )+
 									{
 									if ((LA(1) == 0x65 /* 'e' */ )) {
@@ -2931,12 +2931,12 @@
 								}
 							}
 							catch (antlr::RecognitionException& pe) {
-								synPredMatched449 = false;
+								synPredMatched451 = false;
 							}
-							rewind(_m449);
+							rewind(_m451);
 							inputState->guessing--;
 						}
-						if ( synPredMatched449 ) {
+						if ( synPredMatched451 ) {
 							{
 							switch ( LA(1)) {
 							case 0x30 /* '0' */ :
@@ -2952,18 +2952,18 @@
 							{
 								{
 								{ // ( ... )+
-								int _cnt453=0;
+								int _cnt455=0;
 								for (;;) {
 									if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 										mD(false);
 									}
 									else {
-										if ( _cnt453>=1 ) { goto _loop453; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+										if ( _cnt455>=1 ) { goto _loop455; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 									}
 									
-									_cnt453++;
+									_cnt455++;
 								}
-								_loop453:;
+								_loop455:;
 								}  // ( ... )+
 								{
 								switch ( LA(1)) {
@@ -2981,11 +2981,11 @@
 											mD(false);
 										}
 										else {
-											goto _loop456;
+											goto _loop458;
 										}
 										
 									}
-									_loop456:;
+									_loop458:;
 									} // ( ... )*
 									{
 									if ((LA(1) == 0x65 /* 'e' */ )) {
@@ -3010,18 +3010,18 @@
 							{
 								match('.' /* charlit */ );
 								{ // ( ... )+
-								int _cnt459=0;
+								int _cnt461=0;
 								for (;;) {
 									if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 										mD(false);
 									}
 									else {
-										if ( _cnt459>=1 ) { goto _loop459; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+										if ( _cnt461>=1 ) { goto _loop461; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 									}
 									
-									_cnt459++;
+									_cnt461++;
 								}
-								_loop459:;
+								_loop461:;
 								}  // ( ... )+
 								{
 								if ((LA(1) == 0x65 /* 'e' */ )) {
@@ -3061,11 +3061,11 @@
 									}
 								}
 								else {
-									goto _loop409;
+									goto _loop411;
 								}
 								
 							}
-							_loop409:;
+							_loop411:;
 							} // ( ... )*
 							{
 							if ((LA(1) == 0x22 /* '\"' */ )) {
@@ -3099,11 +3099,11 @@
 									}
 								}
 								else {
-									goto _loop413;
+									goto _loop415;
 								}
 								
 							}
-							_loop413:;
+							_loop415:;
 							} // ( ... )*
 							{
 							if ((LA(1) == 0x27 /* '\'' */ )) {
@@ -3127,18 +3127,18 @@
 						}
 						else if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ )) && (true) && (true)) {
 							{ // ( ... )+
-							int _cnt462=0;
+							int _cnt464=0;
 							for (;;) {
 								if (((LA(1) >= 0x30 /* '0' */  && LA(1) <= 0x39 /* '9' */ ))) {
 									mD(false);
 								}
 								else {
-									if ( _cnt462>=1 ) { goto _loop462; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+									if ( _cnt464>=1 ) { goto _loop464; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 								}
 								
-								_cnt462++;
+								_cnt464++;
 							}
-							_loop462:;
+							_loop464:;
 							}  // ( ... )+
 							if ( inputState->guessing==0 ) {
 								_ttype=CONSTANT_I;
@@ -3255,11 +3255,11 @@
 			}
 		}
 		else {
-			goto _loop468;
+			goto _loop470;
 		}
 		
 	}
-	_loop468:;
+	_loop470:;
 	} // ( ... )*
 	if ( inputState->guessing==0 ) {
 		_ttype=antlr::Token::SKIP;
@@ -3335,11 +3335,11 @@
 		}
 		default:
 		{
-			goto _loop472;
+			goto _loop474;
 		}
 		}
 	}
-	_loop472:;
+	_loop474:;
 	} // ( ... )*
 	if ( inputState->guessing==0 ) {
 		
@@ -3365,7 +3365,7 @@
 	match('!' /* charlit */ );
 	}
 	{ // ( ... )+
-	int _cnt476=0;
+	int _cnt478=0;
 	for (;;) {
 		switch ( LA(1)) {
 		case 0x5f /* '_' */ :
@@ -3420,12 +3420,12 @@
 		}
 		default:
 		{
-			if ( _cnt476>=1 ) { goto _loop476; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+			if ( _cnt478>=1 ) { goto _loop478; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 		}
 		}
-		_cnt476++;
+		_cnt478++;
 	}
-	_loop476:;
+	_loop478:;
 	}  // ( ... )+
 	if ( inputState->guessing==0 ) {
 		
@@ -3464,18 +3464,18 @@
 	std::string::size_type _saveIndex;
 	
 	{ // ( ... )+
-	int _cnt480=0;
+	int _cnt482=0;
 	for (;;) {
 		if ((LA(1) == 0x9 /* '\t' */  || LA(1) == 0xc /* '\14' */  || LA(1) == 0x20 /* ' ' */ )) {
 			mW(false);
 		}
 		else {
-			if ( _cnt480>=1 ) { goto _loop480; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
+			if ( _cnt482>=1 ) { goto _loop482; } else {throw antlr::NoViableAltForCharException(LA(1), getFilename(), getLine(), getColumn());}
 		}
 		
-		_cnt480++;
+		_cnt482++;
 	}
-	_loop480:;
+	_loop482:;
 	}  // ( ... )+
 	if ( inputState->guessing==0 ) {
 		_ttype=antlr::Token::SKIP;
@@ -3516,11 +3516,11 @@
 		}
 		default:
 		{
-			goto _loop483;
+			goto _loop485;
 		}
 		}
 	}
-	_loop483:;
+	_loop485:;
 	} // ( ... )*
 	if ( _createToken && _token==antlr::nullToken && _ttype!=antlr::Token::SKIP ) {
 	   _token = makeToken(_ttype);
@@ -3544,11 +3544,11 @@
 			}
 		}
 		else {
-			goto _loop487;
+			goto _loop489;
 		}
 		
 	}
-	_loop487:;
+	_loop489:;
 	} // ( ... )*
 	mEOL(false);
 	mSKIP_LINES(false);
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/GDLLexer.hpp gdl/src/GDLLexer.hpp
--- gdl-0.9.3/src/GDLLexer.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/GDLLexer.hpp	2013-05-16 12:36:33.023858608 -0600
@@ -2,7 +2,7 @@
 #define INC_GDLLexer_hpp_
 
 #include <antlr/config.hpp>
-/* $ANTLR 2.7.7 (20110618): "gdlc.g" -> "GDLLexer.hpp"$ */
+/* $ANTLR 2.7.7 (20120518): "gdlc.g" -> "GDLLexer.hpp"$ */
 #include <antlr/CommonToken.hpp>
 #include <antlr/InputBuffer.hpp>
 #include <antlr/BitSet.hpp>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/GDLParser.cpp gdl/src/GDLParser.cpp
--- gdl-0.9.3/src/GDLParser.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/GDLParser.cpp	2013-05-16 12:36:33.045858529 -0600
@@ -1,4 +1,4 @@
-/* $ANTLR 2.7.7 (20110618): "gdlc.g" -> "GDLParser.cpp"$ */
+/* $ANTLR 2.7.7 (20120518): "gdlc.g" -> "GDLParser.cpp"$ */
 
 #include "includefirst.hpp"
 
@@ -7894,12 +7894,114 @@
 	returnAST = member_function_call_dot_AST;
 }
 
+void GDLParser::arrayexpr_mfcall() {
+	returnAST = RefDNode(antlr::nullAST);
+	antlr::ASTPair currentAST;
+	RefDNode arrayexpr_mfcall_AST = RefDNode(antlr::nullAST);
+	RefDNode a1_AST = RefDNode(antlr::nullAST);
+	RefDNode t1_AST = RefDNode(antlr::nullAST);
+	antlr::RefToken  id = antlr::nullToken;
+	RefDNode id_AST = RefDNode(antlr::nullAST);
+	RefDNode al_AST = RefDNode(antlr::nullAST);
+	RefDNode deref_arrayexpr_mfcall_AST = RefDNode(antlr::nullAST);
+	
+	RefDNode dot;
+	RefDNode tag;
+	int nDot;
+	
+	
+	switch ( LA(1)) {
+	case IDENTIFIER:
+	case INHERITS:
+	case LBRACE:
+	case SYSVARNAME:
+	{
+		array_expr_1st();
+		if (inputState->guessing==0) {
+			a1_AST = returnAST;
+		}
+		{
+		nDot=tag_access_keeplast();
+		if (inputState->guessing==0) {
+			t1_AST = returnAST;
+		}
+		if ( inputState->guessing==0 ) {
+			
+			if( --nDot > 0)
+			{
+			dot=astFactory->create(DOT,"DOT_A_MF");
+			dot->SetNDot( nDot);    
+			dot->SetLine( a1_AST->getLine());
+			tag = RefDNode(astFactory->make((new antlr::ASTArray(3))->add(antlr::RefAST(dot))->add(antlr::RefAST(a1_AST))->add(antlr::RefAST(t1_AST))));
+			}
+			
+		}
+		}
+		id = LT(1);
+		if ( inputState->guessing == 0 ) {
+			id_AST = astFactory->create(id);
+		}
+		match(IDENTIFIER);
+		arrayindex_list();
+		if (inputState->guessing==0) {
+			al_AST = returnAST;
+		}
+		if ( inputState->guessing==0 ) {
+			arrayexpr_mfcall_AST = RefDNode(currentAST.root);
+			
+			if( nDot > 0)
+			arrayexpr_mfcall_AST = RefDNode(astFactory->make((new antlr::ASTArray(4))->add(antlr::RefAST(astFactory->create(ARRAYEXPR_MFCALL,"arrayexpr_mfcall")))->add(antlr::RefAST(tag))->add(antlr::RefAST(id_AST))->add(antlr::RefAST(al_AST))));
+			else
+			arrayexpr_mfcall_AST = RefDNode(astFactory->make((new antlr::ASTArray(4))->add(antlr::RefAST(astFactory->create(ARRAYEXPR_MFCALL,"arrayexpr_mfcall")))->add(antlr::RefAST(a1_AST))->add(antlr::RefAST(id_AST))->add(antlr::RefAST(al_AST))));
+			
+			currentAST.root = arrayexpr_mfcall_AST;
+			if ( arrayexpr_mfcall_AST!=RefDNode(antlr::nullAST) &&
+				arrayexpr_mfcall_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+				  currentAST.child = arrayexpr_mfcall_AST->getFirstChild();
+			else
+				currentAST.child = arrayexpr_mfcall_AST;
+			currentAST.advanceChildToEnd();
+		}
+		break;
+	}
+	case ASTERIX:
+	{
+		RefDNode tmp188_AST = RefDNode(antlr::nullAST);
+		if ( inputState->guessing == 0 ) {
+			tmp188_AST = astFactory->create(LT(1));
+		}
+		match(ASTERIX);
+		arrayexpr_mfcall();
+		if (inputState->guessing==0) {
+			deref_arrayexpr_mfcall_AST = returnAST;
+		}
+		if ( inputState->guessing==0 ) {
+			arrayexpr_mfcall_AST = RefDNode(currentAST.root);
+			arrayexpr_mfcall_AST = 
+						RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(DEREF,"deref")))->add(antlr::RefAST(deref_arrayexpr_mfcall_AST))));
+			currentAST.root = arrayexpr_mfcall_AST;
+			if ( arrayexpr_mfcall_AST!=RefDNode(antlr::nullAST) &&
+				arrayexpr_mfcall_AST->getFirstChild() != RefDNode(antlr::nullAST) )
+				  currentAST.child = arrayexpr_mfcall_AST->getFirstChild();
+			else
+				currentAST.child = arrayexpr_mfcall_AST;
+			currentAST.advanceChildToEnd();
+		}
+		break;
+	}
+	default:
+	{
+		throw antlr::NoViableAltException(LT(1), getFilename());
+	}
+	}
+	returnAST = arrayexpr_mfcall_AST;
+}
+
 void GDLParser::primary_expr() {
 	returnAST = RefDNode(antlr::nullAST);
 	antlr::ASTPair currentAST;
 	RefDNode primary_expr_AST = RefDNode(antlr::nullAST);
 	RefDNode d1_AST = RefDNode(antlr::nullAST);
-	RefDNode d2_AST = RefDNode(antlr::nullAST);
 	RefDNode d3_AST = RefDNode(antlr::nullAST);
 	antlr::RefToken  sl = antlr::nullToken;
 	RefDNode sl_AST = RefDNode(antlr::nullAST);
@@ -7982,10 +8084,10 @@
 		break;
 	}
 	default:
-		bool synPredMatched206 = false;
+		bool synPredMatched208 = false;
 		if (((_tokenSet_4.member(LA(1))) && (_tokenSet_5.member(LA(2))))) {
-			int _m206 = mark();
-			synPredMatched206 = true;
+			int _m208 = mark();
+			synPredMatched208 = true;
 			inputState->guessing++;
 			try {
 				{
@@ -7994,12 +8096,12 @@
 				}
 			}
 			catch (antlr::RecognitionException& pe) {
-				synPredMatched206 = false;
+				synPredMatched208 = false;
 			}
-			rewind(_m206);
+			rewind(_m208);
 			inputState->guessing--;
 		}
-		if ( synPredMatched206 ) {
+		if ( synPredMatched208 ) {
 			deref_dot_expr_keeplast();
 			if (inputState->guessing==0) {
 				d1_AST = returnAST;
@@ -8029,10 +8131,10 @@
 			primary_expr_AST = RefDNode(currentAST.root);
 		}
 		else {
-			bool synPredMatched211 = false;
+			bool synPredMatched213 = false;
 			if (((_tokenSet_4.member(LA(1))) && (_tokenSet_5.member(LA(2))))) {
-				int _m211 = mark();
-				synPredMatched211 = true;
+				int _m213 = mark();
+				synPredMatched213 = true;
 				inputState->guessing++;
 				try {
 					{
@@ -8048,56 +8150,34 @@
 							expr();
 						}
 						else {
-							goto _loop210;
+							goto _loop212;
 						}
 						
 					}
-					_loop210:;
+					_loop212:;
 					} // ( ... )*
 					match(RBRACE);
 					}
 					}
 				}
 				catch (antlr::RecognitionException& pe) {
-					synPredMatched211 = false;
+					synPredMatched213 = false;
 				}
-				rewind(_m211);
+				rewind(_m213);
 				inputState->guessing--;
 			}
-			if ( synPredMatched211 ) {
-				deref_dot_expr_keeplast();
+			if ( synPredMatched213 ) {
+				arrayexpr_mfcall();
 				if (inputState->guessing==0) {
-					d2_AST = returnAST;
 					astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
 				}
-				RefDNode tmp188_AST = RefDNode(antlr::nullAST);
-				if ( inputState->guessing == 0 ) {
-					tmp188_AST = astFactory->create(LT(1));
-					astFactory->addASTChild(currentAST, antlr::RefAST(tmp188_AST));
-				}
-				match(IDENTIFIER);
-				arrayindex_list();
-				if (inputState->guessing==0) {
-					astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
-				}
-				if ( inputState->guessing==0 ) {
-					primary_expr_AST = RefDNode(currentAST.root);
-					primary_expr_AST = RefDNode(astFactory->make((new antlr::ASTArray(2))->add(antlr::RefAST(astFactory->create(ARRAYEXPR_MFCALL,"arrayexpr_mfcall")))->add(antlr::RefAST(primary_expr_AST))));
-					currentAST.root = primary_expr_AST;
-					if ( primary_expr_AST!=RefDNode(antlr::nullAST) &&
-						primary_expr_AST->getFirstChild() != RefDNode(antlr::nullAST) )
-						  currentAST.child = primary_expr_AST->getFirstChild();
-					else
-						currentAST.child = primary_expr_AST;
-					currentAST.advanceChildToEnd();
-				}
 				primary_expr_AST = RefDNode(currentAST.root);
 			}
 			else {
-				bool synPredMatched213 = false;
+				bool synPredMatched215 = false;
 				if (((_tokenSet_4.member(LA(1))) && (_tokenSet_5.member(LA(2))))) {
-					int _m213 = mark();
-					synPredMatched213 = true;
+					int _m215 = mark();
+					synPredMatched215 = true;
 					inputState->guessing++;
 					try {
 						{
@@ -8106,12 +8186,12 @@
 						}
 					}
 					catch (antlr::RecognitionException& pe) {
-						synPredMatched213 = false;
+						synPredMatched215 = false;
 					}
-					rewind(_m213);
+					rewind(_m215);
 					inputState->guessing--;
 				}
-				if ( synPredMatched213 ) {
+				if ( synPredMatched215 ) {
 					deref_dot_expr_keeplast();
 					if (inputState->guessing==0) {
 						d3_AST = returnAST;
@@ -8135,10 +8215,10 @@
 					primary_expr_AST = RefDNode(currentAST.root);
 				}
 				else {
-					bool synPredMatched215 = false;
+					bool synPredMatched217 = false;
 					if (((_tokenSet_4.member(LA(1))) && (_tokenSet_22.member(LA(2))))) {
-						int _m215 = mark();
-						synPredMatched215 = true;
+						int _m217 = mark();
+						synPredMatched217 = true;
 						inputState->guessing++;
 						try {
 							{
@@ -8146,12 +8226,12 @@
 							}
 						}
 						catch (antlr::RecognitionException& pe) {
-							synPredMatched215 = false;
+							synPredMatched217 = false;
 						}
-						rewind(_m215);
+						rewind(_m217);
 						inputState->guessing--;
 					}
-					if ( synPredMatched215 ) {
+					if ( synPredMatched217 ) {
 						deref_expr();
 						if (inputState->guessing==0) {
 							astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
@@ -8234,10 +8314,10 @@
 						primary_expr_AST = RefDNode(currentAST.root);
 					}
 					else {
-						bool synPredMatched220 = false;
+						bool synPredMatched222 = false;
 						if (((LA(1) == IDENTIFIER || LA(1) == INHERITS) && (LA(2) == LBRACE || LA(2) == LSQUARE))) {
-							int _m220 = mark();
-							synPredMatched220 = true;
+							int _m222 = mark();
+							synPredMatched222 = true;
 							inputState->guessing++;
 							try {
 								{
@@ -8251,22 +8331,22 @@
 										expr();
 									}
 									else {
-										goto _loop219;
+										goto _loop221;
 									}
 									
 								}
-								_loop219:;
+								_loop221:;
 								} // ( ... )*
 								match(RBRACE);
 								}
 							}
 							catch (antlr::RecognitionException& pe) {
-								synPredMatched220 = false;
+								synPredMatched222 = false;
 							}
-							rewind(_m220);
+							rewind(_m222);
 							inputState->guessing--;
 						}
-						if ( synPredMatched220 ) {
+						if ( synPredMatched222 ) {
 							{
 							if (((LA(1) == IDENTIFIER) && (LA(2) == LBRACE))&&( IsFun(LT(1)))) {
 								formal_function_call();
@@ -8324,10 +8404,10 @@
 							primary_expr_AST = RefDNode(currentAST.root);
 						}
 						else {
-							bool synPredMatched223 = false;
+							bool synPredMatched225 = false;
 							if (((LA(1) == IDENTIFIER) && (LA(2) == LBRACE))) {
-								int _m223 = mark();
-								synPredMatched223 = true;
+								int _m225 = mark();
+								synPredMatched225 = true;
 								inputState->guessing++;
 								try {
 									{
@@ -8335,12 +8415,12 @@
 									}
 								}
 								catch (antlr::RecognitionException& pe) {
-									synPredMatched223 = false;
+									synPredMatched225 = false;
 								}
-								rewind(_m223);
+								rewind(_m225);
 								inputState->guessing--;
 							}
-							if ( synPredMatched223 ) {
+							if ( synPredMatched225 ) {
 								formal_function_call();
 								if (inputState->guessing==0) {
 									astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
@@ -8359,10 +8439,10 @@
 								primary_expr_AST = RefDNode(currentAST.root);
 							}
 							else {
-								bool synPredMatched225 = false;
+								bool synPredMatched227 = false;
 								if (((_tokenSet_4.member(LA(1))) && (_tokenSet_22.member(LA(2))))) {
-									int _m225 = mark();
-									synPredMatched225 = true;
+									int _m227 = mark();
+									synPredMatched227 = true;
 									inputState->guessing++;
 									try {
 										{
@@ -8370,12 +8450,12 @@
 										}
 									}
 									catch (antlr::RecognitionException& pe) {
-										synPredMatched225 = false;
+										synPredMatched227 = false;
 									}
-									rewind(_m225);
+									rewind(_m227);
 									inputState->guessing--;
 								}
-								if ( synPredMatched225 ) {
+								if ( synPredMatched227 ) {
 									deref_expr();
 									if (inputState->guessing==0) {
 										astFactory->addASTChild(currentAST, antlr::RefAST(returnAST));
@@ -8728,11 +8808,11 @@
 			}
 		}
 		else {
-			goto _loop231;
+			goto _loop233;
 		}
 		
 	}
-	_loop231:;
+	_loop233:;
 	} // ( ... )*
 	exponential_expr_AST = RefDNode(currentAST.root);
 	returnAST = exponential_expr_AST;
@@ -8814,11 +8894,11 @@
 			}
 		}
 		else {
-			goto _loop235;
+			goto _loop237;
 		}
 		
 	}
-	_loop235:;
+	_loop237:;
 	} // ( ... )*
 	multiplicative_expr_AST = RefDNode(currentAST.root);
 	returnAST = multiplicative_expr_AST;
@@ -9131,11 +9211,11 @@
 			}
 		}
 		else {
-			goto _loop242;
+			goto _loop244;
 		}
 		
 	}
-	_loop242:;
+	_loop244:;
 	} // ( ... )*
 	additive_expr_AST = RefDNode(currentAST.root);
 	returnAST = additive_expr_AST;
@@ -9271,11 +9351,11 @@
 			}
 		}
 		else {
-			goto _loop247;
+			goto _loop249;
 		}
 		
 	}
-	_loop247:;
+	_loop249:;
 	} // ( ... )*
 	relational_expr_AST = RefDNode(currentAST.root);
 	returnAST = relational_expr_AST;
@@ -9337,11 +9417,11 @@
 			}
 		}
 		else {
-			goto _loop251;
+			goto _loop253;
 		}
 		
 	}
-	_loop251:;
+	_loop253:;
 	} // ( ... )*
 	boolean_expr_AST = RefDNode(currentAST.root);
 	returnAST = boolean_expr_AST;
@@ -9393,11 +9473,11 @@
 			}
 		}
 		else {
-			goto _loop255;
+			goto _loop257;
 		}
 		
 	}
-	_loop255:;
+	_loop257:;
 	} // ( ... )*
 	logical_expr_AST = RefDNode(currentAST.root);
 	returnAST = logical_expr_AST;
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/GDLParser.hpp gdl/src/GDLParser.hpp
--- gdl-0.9.3/src/GDLParser.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/GDLParser.hpp	2013-05-16 12:36:33.048858519 -0600
@@ -2,7 +2,7 @@
 #define INC_GDLParser_hpp_
 
 #include <antlr/config.hpp>
-/* $ANTLR 2.7.7 (20110618): "gdlc.g" -> "GDLParser.hpp"$ */
+/* $ANTLR 2.7.7 (20120518): "gdlc.g" -> "GDLParser.hpp"$ */
 #include <antlr/TokenStream.hpp>
 #include <antlr/TokenBuffer.hpp>
 #include "GDLTokenTypes.hpp"
@@ -194,6 +194,7 @@
 	public: void deref_dot_expr();
 	public: bool  member_function_call();
 	public: void member_function_call_dot();
+	public: void arrayexpr_mfcall();
 	public: void primary_expr();
 	public: void decinc_expr();
 	public: void exponential_expr();
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/gdlpsstream.cpp gdl/src/gdlpsstream.cpp
--- gdl-0.9.3/src/gdlpsstream.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/gdlpsstream.cpp	2013-05-16 12:36:33.268857728 -0600
@@ -18,7 +18,7 @@
 #include "includefirst.hpp"
 
 //#include <iostream>
-
+#include "graphics.hpp"
 #include "gdlpsstream.hpp"
 
 using namespace std;
@@ -47,4 +47,3 @@
    }
    page++;
 };
-
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/gdlpsstream.hpp gdl/src/gdlpsstream.hpp
--- gdl-0.9.3/src/gdlpsstream.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/gdlpsstream.hpp	2013-05-16 12:36:33.271857718 -0600
@@ -27,11 +27,11 @@
   int page;
   bool encapsulated;
 public:
-  GDLPSStream( int nx, int ny, int pfont, bool encaps):
+  GDLPSStream( int nx, int ny, int pfont, bool encaps, int color):
 #ifdef _MSC_VER
-    GDLGStream( nx, ny, pfont == 1 ? "psttf" : "ps")
+    GDLGStream( nx, ny, /*pfont == 1 ? "psttf" :*/ (color==0)?"ps":"psc")
 #else
-    GDLGStream::GDLGStream( nx, ny, pfont == 1 ? "psttf" : "ps")
+    GDLGStream::GDLGStream( nx, ny, /*pfont == 1 ? "psttf" :*/(color==0)?"ps":"psc")
 #endif
   {
     encapsulated = encaps;
@@ -43,6 +43,7 @@
   void eop();
 
   void Init();
+
 };
 
 #endif
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/GDLTokenTypes.hpp gdl/src/GDLTokenTypes.hpp
--- gdl-0.9.3/src/GDLTokenTypes.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/GDLTokenTypes.hpp	2013-05-16 12:36:33.049858515 -0600
@@ -1,7 +1,7 @@
 #ifndef INC_GDLTokenTypes_hpp_
 #define INC_GDLTokenTypes_hpp_
 
-/* $ANTLR 2.7.7 (20110618): "gdlc.g" -> "GDLTokenTypes.hpp"$ */
+/* $ANTLR 2.7.7 (20120518): "gdlc.g" -> "GDLTokenTypes.hpp"$ */
 
 #ifndef CUSTOM_API
 # define CUSTOM_API
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/GDLTokenTypes.txt gdl/src/GDLTokenTypes.txt
--- gdl-0.9.3/src/GDLTokenTypes.txt	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/GDLTokenTypes.txt	2013-05-16 12:36:33.050858511 -0600
@@ -1,4 +1,4 @@
-// $ANTLR 2.7.7 (20110618): gdlc.g -> GDLTokenTypes.txt$
+// $ANTLR 2.7.7 (20120518): gdlc.g -> GDLTokenTypes.txt$
 GDL    // output token vocab name
 ALL=4
 ASSIGN=5
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/GDLTreeParser.cpp gdl/src/GDLTreeParser.cpp
--- gdl-0.9.3/src/GDLTreeParser.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/GDLTreeParser.cpp	2013-05-16 12:36:33.058858483 -0600
@@ -1,4 +1,4 @@
-/* $ANTLR 2.7.7 (20110618): "gdlc.tree.g" -> "GDLTreeParser.cpp"$ */
+/* $ANTLR 2.7.7 (20120518): "gdlc.tree.g" -> "GDLTreeParser.cpp"$ */
 
 #include "includefirst.hpp"
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/GDLTreeParser.hpp gdl/src/GDLTreeParser.hpp
--- gdl-0.9.3/src/GDLTreeParser.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/GDLTreeParser.hpp	2013-05-16 12:36:33.061858472 -0600
@@ -3,7 +3,7 @@
 
 #include <antlr/config.hpp>
 #include "GDLTreeParserTokenTypes.hpp"
-/* $ANTLR 2.7.7 (20110618): "gdlc.tree.g" -> "GDLTreeParser.hpp"$ */
+/* $ANTLR 2.7.7 (20120518): "gdlc.tree.g" -> "GDLTreeParser.hpp"$ */
 #include <antlr/TreeParser.hpp>
 
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/GDLTreeParserTokenTypes.hpp gdl/src/GDLTreeParserTokenTypes.hpp
--- gdl-0.9.3/src/GDLTreeParserTokenTypes.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/GDLTreeParserTokenTypes.hpp	2013-05-16 12:36:33.064858461 -0600
@@ -1,7 +1,7 @@
 #ifndef INC_GDLTreeParserTokenTypes_hpp_
 #define INC_GDLTreeParserTokenTypes_hpp_
 
-/* $ANTLR 2.7.7 (20110618): "gdlc.tree.g" -> "GDLTreeParserTokenTypes.hpp"$ */
+/* $ANTLR 2.7.7 (20120518): "gdlc.tree.g" -> "GDLTreeParserTokenTypes.hpp"$ */
 
 #ifndef CUSTOM_API
 # define CUSTOM_API
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/GDLTreeParserTokenTypes.txt gdl/src/GDLTreeParserTokenTypes.txt
--- gdl-0.9.3/src/GDLTreeParserTokenTypes.txt	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/GDLTreeParserTokenTypes.txt	2013-05-16 12:36:33.065858458 -0600
@@ -1,4 +1,4 @@
-// $ANTLR 2.7.7 (20110618): gdlc.tree.g -> GDLTreeParserTokenTypes.txt$
+// $ANTLR 2.7.7 (20120518): gdlc.tree.g -> GDLTreeParserTokenTypes.txt$
 GDLTreeParser    // output token vocab name
 ALL=4
 ASSIGN=5
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/gdlwidget.cpp gdl/src/gdlwidget.cpp
--- gdl-0.9.3/src/gdlwidget.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/gdlwidget.cpp	2013-03-25 10:36:38.368969803 -0600
@@ -651,7 +651,7 @@
 		}
 
 		// define grid object
-		wxFlexGridSizer *buttonSizer = new wxFlexGridSizer( rows, cols );
+		wxFlexGridSizer *buttonSizer = new wxFlexGridSizer( (int)rows, (int) cols, 0, 0 );
 		switch(mode)
 			{
 			case NORMAL:
@@ -927,7 +927,7 @@
     DSub *sub =  proList[ proIx];
 //     EnvUDT* e;
 //     e = new EnvUDT( NULL, sub);
-//     std::auto_ptr< EnvUDT> e_guard( e);
+//     Guard< EnvUDT> e_guard( e);
 //     StackSizeGuard<EnvStackT> guard( GDLInterpreter::CallStack());
 //     GDLInterpreter::CallStack().push_back( e);
 
@@ -969,7 +969,7 @@
     trAST = treeParser.getAST();
 
     ProgNodeP progAST = ProgNode::NewProgNode( trAST);
-    std::auto_ptr< ProgNode> progAST_guard( progAST);
+    Guard< ProgNode> progAST_guard( progAST);
 
     // necessary for correct FOR loop handling
     assert( dynamic_cast<EnvUDT*>(caller) != NULL);
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/gdlxstream.cpp gdl/src/gdlxstream.cpp
--- gdl-0.9.3/src/gdlxstream.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/gdlxstream.cpp	2013-02-25 17:04:24.851180064 -0700
@@ -130,10 +130,11 @@
   PLFLT xp; PLFLT yp; 
   PLINT xleng; PLINT yleng;
   PLINT plxoff; PLINT plyoff;
-  gpage( xp, yp, xleng, yleng, plxoff, plyoff);
+  plstream::gpage( xp, yp, xleng, yleng, plxoff, plyoff);
 
   xoff = plxoff;
   yoff = plyoff;
+  if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"GDLXStream::GetGeometry(%ld %ld %ld %ld)\n", xSize, ySize, xoff, yoff);
 }
 
 // plplot 5.3 does not provide the clear function for c++
@@ -211,5 +212,243 @@
   XwDisplay *xwd = (XwDisplay *) dev->xwd;
   XMapWindow(dev->xwd->display, dev->window);
 }
+void GDLXStream::Flush()
+{
+  XwDev *dev = (XwDev *) pls->dev;
+  XwDisplay *xwd = (XwDisplay *) dev->xwd;
+  XFlush( xwd->display);
+}
+void GDLXStream::WarpPointer(DLong x, DLong y)
+{
+  XwDev *dev = (XwDev *) pls->dev;
+  XwDisplay *xwd = (XwDisplay *) dev->xwd;
+  XWarpPointer( xwd->display, dev->window, None, 0, 0, 0, 0, x, y );
+}
+bool GDLXStream::GetGin( PLGraphicsIn *gin, int mode)
+{
+  bool status=true;
+  bool warp=false;
+  int dx,dy;
+  XwDev *dev = (XwDev *) pls->dev;
+  XwDisplay *xwd = (XwDisplay *) dev->xwd;
+  if (mode == 0)
+  {
+    Window root, child;
+    int root_x, root_y, x,y;
+    unsigned int state;
+    XQueryPointer(xwd->display, dev->window, &root, &child,
+               &root_x, &root_y, &x, &y, &state ) ;
+    gin->pX = x;
+    gin->pY = dev->height - y;
+    gin->state = state;
+    gin->dX = (PLFLT) gin->pX / ( dev->width - 1 );
+    gin->dY = (PLFLT) gin->pY / ( dev->height - 1 );
+    gin->string[0] = '\0';
+    gin->keysym = 0x20;
+    gin->button = 0;
+    return true;
+  }
+  int  x, x1, xmin = 0, xmax = (int) dev->width - 1;
+  int  y, y1, ymin = 0, ymax = (int) dev->height - 1;
+  XWMHints gestw;
+  XSizeHints sizehints,initialstate;
+  long hints_supplied;
+  /* get normal state of the window */
+  XGetWMNormalHints(xwd->display, dev->window,&initialstate,&hints_supplied);
+  /* force fixed size to prevent a change of window size with the cursor*/
+  sizehints.min_width=sizehints.max_width=dev->width;
+  sizehints.min_height=sizehints.max_height=dev->height;
+  sizehints.flags=(PMinSize|PMaxSize);
+  XSetWMNormalHints(xwd->display, dev->window,&sizehints);
+  /* add focus to the window on (all) displays */
+  gestw.input = TRUE;
+  gestw.flags = InputHint;
+  XSetWMHints(xwd->display, dev->window, &gestw);
+
+  unsigned long event_mask= PointerMotionMask | KeyPressMask;
+  switch (mode)
+  {
+    case 1:
+    case 3:
+      event_mask |= ButtonPressMask;
+      break;
+    case 4:
+      event_mask |= ButtonPressMask | ButtonReleaseMask;
+      break;
+    case 2:
+      event_mask |= ButtonPressMask | ButtonReleaseMask;
+  }
+
+  XEvent event;
+  //do our own event handling
+  int first=0;
+  XSelectInput(xwd->display, dev->window, event_mask);
+  XRaiseWindow(xwd->display, dev->window);
+  XFlush(xwd->display);
+  while(1)
+  {
+    XWindowEvent(xwd->display, dev->window, event_mask, &event);
+    switch (event.type)
+    {
+      int nchars;
+      KeySym mykey;
+
+      case KeyPress:    // exit in error if ^C
+        gin->pX = event.xkey.x;
+        gin->pY = event.xkey.y;
+        gin->state = event.xkey.state;
+        nchars = XLookupString(&event.xkey, gin->string, PL_MAXKEY - 1, &mykey, NULL);
+        gin->string[nchars] = '\0';
+        gin->keysym = (unsigned int) mykey;
+        if (gin->state&4 && (gin->keysym==67 || gin->keysym==99)) 
+        {
+          status=false;
+          goto end;
+        }
+        warp=false;
+        dx=0;
+        dy=0;
+        switch(mykey)
+        {
+          case XK_Cancel:
+          case XK_Break:
+            status = false;
+            goto end;
+          case XK_Left:
+            dx=-1; warp=true;
+            break;
+          case XK_Up:
+            dy=-1; warp=true;
+            break;
+          case XK_Right:
+            dx=1; warp=true;
+            break;
+          case XK_Down:
+            dy=1; warp=true;
+            break;
+        }
+        if (warp)
+        {
+        // Each modifier key added increases the multiplication factor by 5
+        // Shift
+        if ( gin->state & 0x01 )
+        {
+            dx *= 5;
+            dy *= 5;
+        }
+        // Caps Lock
+        if ( gin->state & 0x02 )
+        {
+            dx *= 5;
+            dy *= 5;
+        }
+        // Control
+        if ( gin->state & 0x04 )
+        {
+            dx *= 5;
+            dy *= 5;
+        }
+        // Alt
+        if ( gin->state & 0x08 )
+        {
+            dx *= 5;
+            dy *= 5;
+        }
+        // Bounds checking so that we don't send cursor out of window
+        x1 = gin->pX + dx;
+        y1 = gin->pY + dy;
+        if ( x1 < xmin )
+            dx = xmin - gin->pX;
+        if ( y1 < ymin )
+            dy = ymin - gin->pY;
+        if ( x1 > xmax )
+            dx = xmax - gin->pX;
+        if ( y1 > ymax )
+            dy = ymax - gin->pY;
+        XWarpPointer( xwd->display, dev->window, None, 0, 0, 0, 0, dx, dy );
+        }
+        break;
+      case MotionNotify:
+        gin->pX = event.xmotion.x;
+        gin->pY = event.xmotion.y;
+        gin->state = event.xmotion.state;
+        gin->string[0] = '\0';
+        gin->keysym = 0x20;
+  //      fprintf(stderr,"motion %d %d, state %d\n",gin->pX,gin->pY,gin->state);
+        if (mode==2) goto end; // crosshair not available if we exit on motion!!!
+        if(event.type==MotionNotify){
+            x=event.xmotion.x; y=event.xmotion.y;
+        }
+        else {
+            x=event.xcrossing.x; y=event.xcrossing.y;
+        }
+        if (!first)
+            first=1;
+        else
+        {
+          XDrawLines( xwd->display, dev->window, xwd->gcXor, dev->xhair_x, 2,
+              CoordModeOrigin );
+          XDrawLines( xwd->display, dev->window, xwd->gcXor, dev->xhair_y, 2,
+              CoordModeOrigin );
+        }
+        dev->xhair_x[0].x = (short) xmin; dev->xhair_x[0].y = (short) y;
+        dev->xhair_x[1].x = (short) xmax; dev->xhair_x[1].y = (short) y;
+        dev->xhair_y[0].x = (short) x; dev->xhair_y[0].y = (short) ymin;
+        dev->xhair_y[1].x = (short) x; dev->xhair_y[1].y = (short) ymax;
+        XDrawLines( xwd->display, dev->window, xwd->gcXor, dev->xhair_x, 2,
+            CoordModeOrigin );
+        XDrawLines( xwd->display, dev->window, xwd->gcXor, dev->xhair_y, 2,
+            CoordModeOrigin );
+        break;
+      case ButtonPress:
+        gin->pX = event.xbutton.x;
+        gin->pY = event.xbutton.y;
+        gin->state = event.xbutton.state;
+        gin->button = event.xbutton.button;
+        gin->string[0] = '\0';
+        gin->keysym = 0x20;
+        XSync(xwd->display, true);
+        if (mode==4) break;
+        goto end; //always exit on this event
+      case ButtonRelease:
+        gin->pX = event.xbutton.x;
+        gin->pY = event.xbutton.y;
+        gin->state = event.xbutton.state;
+        gin->button = event.xbutton.button;
+        gin->string[0] = '\0';
+        gin->keysym = 0x20;
+        XSync(xwd->display, true);
+        goto end; //always exit on this event
+      default:
+        break;
+    }
+  }
+  end: if(first) {
+        XDrawLines( xwd->display, dev->window, xwd->gcXor, dev->xhair_x, 2,
+            CoordModeOrigin );
+        XDrawLines( xwd->display, dev->window, xwd->gcXor, dev->xhair_y, 2,
+            CoordModeOrigin );
+  }
+  gin->pY = dev->height - gin->pY;
+  gin->dX = (PLFLT) gin->pX / ( dev->width - 1 );
+  gin->dY = (PLFLT) gin->pY / ( dev->height - 1 );
+  //give back plplot's handling:
+  XSelectInput(xwd->display, dev->window,dev->event_mask);
+   /* restore old hints */
+  XSetWMNormalHints(xwd->display, dev->window, &initialstate);
+  /* remove focus to the window on (all) displays */
+  gestw.input = FALSE;
+  gestw.flags = InputHint;
+  XSetWMHints(xwd->display, dev->window, &gestw);
+    /* give back the right to change the window size*/
+  sizehints.min_width=0;
+  sizehints.max_width=XWidthOfScreen(XDefaultScreenOfDisplay(xwd->display));
+  sizehints.min_height=32;
+  sizehints.max_height=XHeightOfScreen(XDefaultScreenOfDisplay(xwd->display));
+  sizehints.flags=(PMinSize|PMaxSize);
+  XSetWMNormalHints(xwd->display, dev->window,&sizehints);
+  XFlush(xwd->display);
+  return status;
+}
 
 #endif
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/gdlxstream.hpp gdl/src/gdlxstream.hpp
--- gdl-0.9.3/src/gdlxstream.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/gdlxstream.hpp	2013-02-25 17:04:24.852180060 -0700
@@ -53,6 +53,9 @@
   void Lower();
   void Iconic();
   void DeIconic();
+  bool GetGin(PLGraphicsIn *gin, int mode);
+  void WarpPointer(DLong x, DLong y);
+  void Flush();
 };
 
 #endif
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/graphics.hpp gdl/src/graphics.hpp
--- gdl-0.9.3/src/graphics.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/graphics.hpp	2013-02-25 17:04:24.873179974 -0700
@@ -172,9 +172,15 @@
   virtual bool SetFileName( const std::string& f)     { return false;}
   virtual bool  Decomposed( bool value)               { return false;}
   virtual DLong GetDecomposed()                       { return -1;}
+  virtual bool  SetGraphicsFunction( DLong value)     { return false;}
+  virtual DLong GetGraphicsFunction()                 { return -1;}
+  virtual bool CursorStandard( int value)             { return false;}
+  virtual bool CursorCrosshair()                      { return false;}
+  virtual bool UnsetFocus()                           { return false;}
+  virtual bool EnableBackingStore(bool enable)        { return false;}
   virtual bool SetXPageSize( const float xs)          { return false;}
   virtual bool SetYPageSize( const float ys)          { return false;}
-  virtual bool SetColor()                             { return false;}
+  virtual bool SetColor(const long color=0)           { return false;}
   virtual bool SetScale(const float)                  { return false;}
   virtual bool SetXOffset(const float)                { return false;}
   virtual bool SetYOffset(const float)                { return false;}
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/gshhs.cpp gdl/src/gshhs.cpp
--- gdl-0.9.3/src/gshhs.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/gshhs.cpp	2013-02-25 17:04:24.889179909 -0700
@@ -66,7 +66,7 @@
     if (!mapSet) 
       e->Throw("Map transform not established (MAP_SET).");
 
-    gkw_color(e, actStream);
+    gdlSetGraphicsForegroundColorFromKw(e, actStream);
 
     actStream->NoSub();
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/gsl_fun.cpp gdl/src/gsl_fun.cpp
--- gdl-0.9.3/src/gsl_fun.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/gsl_fun.cpp	2013-05-16 12:36:33.290857649 -0600
@@ -102,6 +102,7 @@
 namespace lib {
 
   using namespace std;
+  using std::isnan;
 
   const int szdbl=sizeof(double);
   const int szflt=sizeof(float);
@@ -133,6 +134,8 @@
     gsl_set_error_handler( GDLGenericGSLErrorHandler);
   }
   
+ 
+
   BaseGDL* invert_fun( EnvT* e)
   {
     SizeT nParam=e->NParam(1);
@@ -148,9 +151,10 @@
     BaseGDL* p0 = e->GetParDefined( 0);
 
     SizeT nEl = p0->N_Elements();
+
     if( nEl == 0)
       e->Throw( "Variable is undefined: " + e->GetParString(0));
-  
+    
     if (p0->Rank() > 2)
       e->Throw( "Input must be a square matrix:" + e->GetParString(0));
     
@@ -199,7 +203,7 @@
 	if (nParam == 2) e->SetPar(1,new DLongGDL( singular)); 
 	return res;
       }
-      if( p0->Type() == GDL_DOUBLE) {
+      if(( p0->Type() == GDL_DOUBLE) || e->KeywordSet("DOUBLE")) {
 	DDoubleGDL* res = static_cast<DDoubleGDL*>
 	  (p0->Convert2(GDL_DOUBLE, BaseGDL::COPY));
 	if ((*res)[0] == 0.0) {
@@ -234,7 +238,7 @@
       {
 	DComplexGDL* p0C = static_cast<DComplexGDL*>( p0);
 	DComplexGDL* res = new DComplexGDL( p0C->Dim(), BaseGDL::NOZERO);
-	auto_ptr<DComplexGDL> resGuard( res);
+	Guard<DComplexGDL> resGuard( res);
 
 	float f32_2[2];
 	double f64_2[2];
@@ -285,7 +289,7 @@
       {
 	DComplexDblGDL* p0C = static_cast<DComplexDblGDL*>( p0);
 	DComplexDblGDL* res = new DComplexDblGDL( p0C->Dim(), BaseGDL::NOZERO);
-	auto_ptr<DComplexDblGDL> resGuard( res);
+	Guard<DComplexDblGDL> resGuard( res);
 
 	gsl_matrix_complex *mat = 
 	  gsl_matrix_complex_alloc(p0->Dim(0), p0->Dim(1));
@@ -316,11 +320,16 @@
 	resGuard.release();
 	return res;
       }
-    else if( p0->Type() == GDL_DOUBLE)
+    else if (( p0->Type() == GDL_DOUBLE) ||  e->KeywordSet("DOUBLE"))
       {
-	DDoubleGDL* p0D = static_cast<DDoubleGDL*>( p0);
+
+	DDoubleGDL* p0D = static_cast<DDoubleGDL*>
+	  (p0->Convert2(GDL_DOUBLE,BaseGDL::COPY));
+
+
+	//	DDoubleGDL* p0D = static_cast<DDoubleGDL*>( p0);
 	DDoubleGDL* res = new DDoubleGDL( p0->Dim(), BaseGDL::NOZERO);
-	auto_ptr<DDoubleGDL> resGuard( res);
+	Guard<DDoubleGDL> resGuard( res);
 
 	gsl_matrix *mat = gsl_matrix_alloc(p0->Dim(0), p0->Dim(1));
 	GDLGuard<gsl_matrix> g1( mat, gsl_matrix_free);
@@ -368,11 +377,11 @@
 	//	if (p0->Type() == STRING) {
 	DFloatGDL* p0SS = static_cast<DFloatGDL*>
 	  (p0->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	auto_ptr<DFloatGDL> p0SSGuard( p0SS);
+	Guard<DFloatGDL> p0SSGuard( p0SS);
 	//}
 
 	DFloatGDL* res = new DFloatGDL( p0->Dim(), BaseGDL::NOZERO);
-	auto_ptr<DFloatGDL> resGuard( res);
+	Guard<DFloatGDL> resGuard( res);
 
 	gsl_matrix *mat = gsl_matrix_alloc(p0->Dim(0), p0->Dim(1));
 	GDLGuard<gsl_matrix> g1( mat, gsl_matrix_free);
@@ -630,23 +639,23 @@
     
     T* res;
     T* tabtemp=new T(p0->Dim());
-    auto_ptr<T> tabtempGuard( tabtemp);
+    Guard<T> tabtempGuard( tabtemp);
 
-    auto_ptr<T> resGuard;
+    Guard<T> resGuard;
     if (overwrite == 0)
       {
 	res = new T( p0->Dim(), BaseGDL::ZERO);
-	resGuard.reset( res);
+	resGuard.Reset( res);
       } 
     else
       res = (T*) p0;
     
     DComplexGDL* tabfft = new DComplexGDL(p0->Dim());
-    auto_ptr<DComplexGDL> tabfftGuard( tabfft);
+    Guard<DComplexGDL> tabfftGuard( tabfft);
     
     DComplexGDL* p0C = static_cast<DComplexGDL*>
       (p0->Convert2( GDL_COMPLEX, BaseGDL::COPY));
-    auto_ptr<DComplexGDL> p0CGuard( p0C);
+    Guard<DComplexGDL> p0CGuard( p0C);
       
     int dec=0;
     int temp=0;
@@ -944,7 +953,7 @@
       overwrite = 0;
       DComplexGDL* p0C = static_cast<DComplexGDL*>
 	(p0->Convert2( GDL_COMPLEX, BaseGDL::COPY));
-      auto_ptr<BaseGDL> guard_p0C( p0C); 
+      Guard<BaseGDL> guard_p0C( p0C); 
       return fft_template< DComplexGDL> (p0C, nEl, dbl, overwrite, 
 					 direct,dimension); 
 
@@ -1350,6 +1359,22 @@
   }
 #endif
 
+  // Alain C., 26 February 2013
+  // this is a temporary workaround of an in accuracy in the GSL (up to 1.15)
+  // when working on 64b version and integer bin size ...
+  // GDL bug report 618683
+  // http://sourceforge.net/tracker/?func=detail&aid=3602623&group_id=97659&atid=618683
+  // GSL bug report thread 
+  // http://lists.gnu.org/archive/html/bug-gsl/2013-02/msg00006.html
+
+  static void gdl_make_uniform (gsl_histogram * h, size_t n, double xmin, double xmax)
+  {
+    size_t i;
+    for (i = 0; i <= n; i++)
+      h->range[i] = xmin +  (double) i * (xmax-xmin)/((double) n);
+  }
+
+
   BaseGDL* histogram_fun( EnvT* e)
   {
     double a;
@@ -1392,11 +1417,11 @@
       e->Throw( "Conflicting keywords.");
 
     DDoubleGDL *p0D = dynamic_cast<DDoubleGDL*>(p0);
-    auto_ptr<BaseGDL> guard;
+    Guard<BaseGDL> guard;
     if( p0D == NULL)
       {
 	p0D = static_cast<DDoubleGDL*>(p0->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-	guard.reset( p0D);
+	guard.Reset( p0D);
       }
 
     // get min max
@@ -1502,6 +1527,9 @@
     GDLGuard<gsl_histogram> hhGuard( hh, gsl_histogram_free);
     gsl_histogram_set_ranges_uniform( hh, a, b);
 
+    // temporary revisited computation of bin values ...
+    gdl_make_uniform (hh, hh->n, a, b);
+
     // Set maxVal from keyword if present
     if (maxKW != NULL) e->AssureDoubleScalarKW(e->KeywordIx("MAX"), maxVal);
 
@@ -2069,10 +2097,10 @@
     DDoubleGDL* p1D;
     DDoubleGDL* p2D;
     DDoubleGDL* p3D;
-    auto_ptr<BaseGDL> guard0;
-    auto_ptr<BaseGDL> guard1;
-    auto_ptr<BaseGDL> guard2;
-    auto_ptr<BaseGDL> guard3;
+    Guard<BaseGDL> guard0;
+    Guard<BaseGDL> guard1;
+    Guard<BaseGDL> guard2;
+    Guard<BaseGDL> guard3;
 
     if (nParam < 2) e->Throw("Incorrect number of arguments.");
 
@@ -2084,7 +2112,7 @@
     else
       {
 	p0D = static_cast<DDoubleGDL*>(p0->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-	guard0.reset(p0D);
+	guard0.Init(p0D);
       }
 
     BaseGDL* p1 = e->GetParDefined(1);
@@ -2092,7 +2120,7 @@
     else
       {
 	p1D = static_cast<DDoubleGDL*>(p1->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-	guard1.reset(p1D);
+	guard1.Init(p1D);
       }
 
     BaseGDL* p2 = NULL;
@@ -2102,7 +2130,7 @@
       else
 	{
 	  p2D = static_cast<DDoubleGDL*>(p2->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-	  guard2.reset(p2D);
+	  guard2.Init(p2D);
 	}
     }
 
@@ -2113,7 +2141,7 @@
       else
 	{
 	  p3D = static_cast<DDoubleGDL*>(p3->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-	  guard3.reset(p3D);
+	  guard3.Init(p3D);
 	}
     }
 
@@ -2255,13 +2283,13 @@
 	gsl_linalg_hermtd_decomp (mat, tau);
 	gsl_linalg_hermtd_unpack (mat, tau, Q, diag, subdiag);
 
-	DLong dims[2] = {p0->Dim(0), p0->Dim(0)};
+	SizeT dims[2] = {p0->Dim(0), p0->Dim(0)};
 	dimension dim0(dims, (SizeT) 2);
 	BaseGDL** p0Co = &e->GetPar( 0);
 	GDLDelete((*p0Co));
 	*p0Co = new DComplexGDL(dim0, BaseGDL::NOZERO);
 
-	DLong n = p0->Dim(0);
+	SizeT n = p0->Dim(0);
 	dimension dim1(&n, (SizeT) 1);
 	BaseGDL** p1F = &e->GetPar( 1);
 	GDLDelete((*p1F));
@@ -2320,13 +2348,13 @@
 	gsl_linalg_hermtd_decomp (mat, tau);
 	gsl_linalg_hermtd_unpack (mat, tau, Q, diag, subdiag);
 
-	DLong dims[2] = {p0->Dim(0), p0->Dim(0)};
+	SizeT dims[2] = {p0->Dim(0), p0->Dim(0)};
 	dimension dim0(dims, (SizeT) 2);
 	BaseGDL** p0Co = &e->GetPar( 0);
 	GDLDelete((*p0Co));
 	*p0Co = new DComplexDblGDL(dim0, BaseGDL::NOZERO);
 
-	DLong n = p0->Dim(0);
+	SizeT n = p0->Dim(0);
 	dimension dim1(&n, (SizeT) 1);
 	BaseGDL** p1D = &e->GetPar( 1);
 	GDLDelete((*p1D));
@@ -2371,13 +2399,13 @@
 	gsl_linalg_symmtd_decomp (mat, tau);
 	gsl_linalg_symmtd_unpack (mat, tau, Q, diag, subdiag);
 
-	DLong dims[2] = {p0->Dim(0), p0->Dim(0)};
+	SizeT dims[2] = {p0->Dim(0), p0->Dim(0)};
 	dimension dim0(dims, (SizeT) 2);
 	BaseGDL** p0Do = &e->GetPar( 0);
 	GDLDelete((*p0Do));
 	*p0Do = new DDoubleGDL(dim0, BaseGDL::NOZERO);
 
-	DLong n = p0->Dim(0);
+	SizeT n = p0->Dim(0);
 	dimension dim1(&n, (SizeT) 1);
 	BaseGDL** p1D = &e->GetPar( 1);
 	GDLDelete((*p1D));
@@ -2442,13 +2470,13 @@
 	gsl_linalg_symmtd_decomp (mat, tau);
 	gsl_linalg_symmtd_unpack (mat, tau, Q, diag, subdiag);
 
-	DLong dims[2] = {p0->Dim(0), p0->Dim(0)};
+	SizeT dims[2] = {p0->Dim(0), p0->Dim(0)};
 	dimension dim0(dims, (SizeT) 2);
 	BaseGDL** p0Fo = &e->GetPar( 0);
 	GDLDelete((*p0Fo));
 	*p0Fo = new DFloatGDL(dim0, BaseGDL::NOZERO);
 
-	DLong n = p0->Dim(0);
+	SizeT n = p0->Dim(0);
 	dimension dim1(&n, (SizeT) 1);
 	BaseGDL** p1F = &e->GetPar( 1);
 	GDLDelete((*p1F));
@@ -2514,7 +2542,7 @@
 					   );
     // TODO: no guarding if res is an optimized constant
     // NO!!! the return value of call_fun() is always owned by the caller (constants are Dup()ed)
-    auto_ptr<BaseGDL> res_guard(res);
+    Guard<BaseGDL> res_guard(res);
     // sanity checks
     //   if (res->Rank() != 1 || res->N_Elements() != x->size) 
     //AC for iCosmo
@@ -2539,8 +2567,8 @@
     if (res != dres)
       {
 	// prevent 'res' from being deleted again
-	res_guard.release();
-	res_guard.reset (dres);
+	res_guard.Release();
+	res_guard.Init(dres);
       }
     // copying from GDL to GSL
     for (size_t i = 0; i < x->size; i++) gsl_vector_set(f, i, (*dres)[i]);
@@ -2590,7 +2618,7 @@
     //AC for iCosmo
     //if (p0->Rank() != 1) e->Throw("the first argument is expected to be a vector");
     BaseGDL* par = p0->Convert2(GDL_DOUBLE, BaseGDL::COPY);
-    auto_ptr<BaseGDL> par_guard(par);
+    Guard<BaseGDL> par_guard(par);
 
     // 2-nd argument : name of user function defining the system
     DString fun;
@@ -2732,12 +2760,12 @@
     // 2-nd argument : initial bound
     BaseGDL* p1 = e->GetParDefined(1);
     BaseGDL* par1 = p1->Convert2(GDL_DOUBLE, BaseGDL::COPY);
-    auto_ptr<BaseGDL> par1_guard(par1);
+    Guard<BaseGDL> par1_guard(par1);
 
     // 3-th argument : final bound
     BaseGDL* p2 = e->GetParDefined(2);
     BaseGDL* par2 = p2->Convert2(GDL_DOUBLE, BaseGDL::COPY);
-    auto_ptr<BaseGDL> par2_guard(par2);
+    Guard<BaseGDL> par2_guard(par2);
 
     // 1-st argument : name of user function defining the system
     DString fun;
@@ -2844,7 +2872,7 @@
     BaseGDL* par1 = NULL;
     p1 = e->GetParDefined(1);
     par1 = p1->Convert2(GDL_DOUBLE, BaseGDL::COPY);
-    auto_ptr<BaseGDL> par1_guard(par1);
+    Guard<BaseGDL> par1_guard(par1);
 
     BaseGDL* p2 = NULL;
     BaseGDL* par2 = NULL;
@@ -2853,7 +2881,7 @@
 	// 3-th argument : final bound
 	p2 = e->GetParDefined(2);
 	par2 = p2->Convert2(GDL_DOUBLE, BaseGDL::COPY);
-	auto_ptr<BaseGDL> par2_guard(par2);
+	Guard<BaseGDL> par2_guard(par2);
       }
 
     // 1-st argument : name of user function defining the system
@@ -3094,7 +3122,7 @@
     BaseGDL* p0 = e->GetNumericArrayParDefined(0);
     DComplexDblGDL* init = e->GetParAs<DComplexDblGDL>(0);
     BaseGDL* par0 = p0->Convert2(GDL_COMPLEXDBL, BaseGDL::COPY);
-    auto_ptr<BaseGDL> par0_guard(par0);
+    Guard<BaseGDL> par0_guard(par0);
 
     if (init->N_Elements() != 3)
       {
@@ -3624,8 +3652,8 @@
 							    ? BaseGDL::CONVERT
 							    : BaseGDL::COPY
 							    ));
-    auto_ptr<DDoubleGDL> ret_guard;
-    if (ret != p0) ret_guard.reset(ret);
+    Guard<DDoubleGDL> ret_guard;
+    if (ret != p0) ret_guard.Reset(ret);
 
     // GSL error handling
     gsl_error_handler_t* old_handler = gsl_set_error_handler(&gsl_err_2_gdl_warn);
@@ -3843,7 +3871,7 @@
       if (dbl) res = new DComplexDblGDL(dim);
       else res = new DComplexGDL(dim);
     }
-    auto_ptr<BaseGDL> res_guard(res);
+    Guard<BaseGDL> res_guard(res);
 
     // computing the result 
     if (dbl) 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/gsl_matrix.cpp gdl/src/gsl_matrix.cpp
--- gdl-0.9.3/src/gsl_matrix.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/gsl_matrix.cpp	2013-03-25 10:36:38.409969612 -0600
@@ -97,7 +97,7 @@
     }
     
     // copying over p0 the updated matrix	
-    DLong dims[2] = {p0->Dim(0), p0->Dim(0)};
+    SizeT dims[2] = {p0->Dim(0), p0->Dim(0)};
     dimension dim0(dims, (SizeT) 2);
 
     BaseGDL** p0Do = &e->GetPar( 0);
@@ -116,7 +116,7 @@
     // { p0->Convert2(GDL_FLOAT, BaseGDL::CONVERT); }
 
     // copying over p1 the permutation vector
-    DLong n = p0->Dim(0);
+    SizeT n = p0->Dim(0);
     dimension dim1(&n, (SizeT) 1);
     BaseGDL** p1D = &e->GetPar( 1);
     GDLDelete((*p1D));
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/image.cpp gdl/src/image.cpp
--- gdl-0.9.3/src/image.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/image.cpp	2013-02-25 17:04:24.977179550 -0700
@@ -51,22 +51,27 @@
     static int get_namesIx = e->KeywordIx( "GET_NAMES"); 
     bool get_names = e->KeywordPresent( get_namesIx);
     if( get_names)
-      {
-	e->AssureGlobalKW( get_namesIx);
-	
-	DStringGDL* names = new DStringGDL( nCT, BaseGDL::NOZERO);
-	for( SizeT i=0; i<nCT; ++i)
-	  (*names)[ i] = Graphics::GetCT( i)->Name();
+    {
+      e->AssureGlobalKW( get_namesIx);
 
-	e->SetKW( get_namesIx, names);
-      }
+      DStringGDL* names = new DStringGDL( nCT, BaseGDL::NOZERO);
+      for( SizeT i=0; i<nCT; ++i)
+        (*names)[ i] = Graphics::GetCT( i)->Name();
+
+      e->SetKW( get_namesIx, names);
+      return; //correct behaviour.
+    }
 
-    if( e->NParam() == 0) return;
+    if( e->NParam() == 0) return; //FIXME should list tables names, promt for number and load it!
 
     DLong iCT;
 
     DByte r[256], g[256], b[256];
     PLINT rint[256], gint[256], bint[256];
+    //load original table
+    GDLCT* actCT = Graphics::GetCT();
+    actCT->Get(rint,gint,bint,256);
+
 
     e->AssureLongScalarPar( 0, iCT);
     if( iCT < 0 || iCT >= nCT)
@@ -76,18 +81,44 @@
     GDLGStream* actStream = actDevice->GetStream( false); // no open
 
     Graphics::LoadCT( iCT);
-    GDLCT* actCT = Graphics::GetCT();
-
-    for( SizeT i=0; i<ctSize; ++i) {
+    //new table is:
+    actCT = Graphics::GetCT();
+#define MAX_COLORS 256
+    DLong bottom=0;
+    DLong ncolors=MAX_COLORS;
+    if ( e->KeywordSet ( "BOTTOM" ) ) e->AssureLongScalarKWIfPresent ( "BOTTOM", bottom );
+    if ( e->KeywordSet ( "NCOLORS" ) ) e->AssureLongScalarKWIfPresent ( "NCOLORS", ncolors );
+    if (bottom < 0) bottom=0;
+    if (bottom > MAX_COLORS-1) bottom=MAX_COLORS-1;
+    if (ncolors < 1) ncolors=1;
+    if (ncolors > MAX_COLORS) ncolors=MAX_COLORS;
+    if (bottom+ncolors > MAX_COLORS) ncolors=MAX_COLORS-bottom;
+#undef MAX_COLORS
+    for( SizeT i=0, j=bottom ; j<bottom+ncolors; ++i, ++j) {
       actCT->Get( i, r[ i], g[ i], b[ i]);
+      //update section of colors
+      rint[j] = (PLINT) r[i];
+      gint[j] = (PLINT) g[i];
+      bint[j] = (PLINT) b[i];
+    }
 
-      rint[i] = (PLINT) r[i];
-      gint[i] = (PLINT) g[i];
-      bint[i] = (PLINT) b[i];
+    static int rgbtableIx = e->KeywordIx( "RGB_TABLE");
+    if( e->KeywordPresent( rgbtableIx) )
+    {
+      e->AssureGlobalKW( rgbtableIx);
+      DByteGDL* rgbtable = new DByteGDL( dimension(ncolors, 3), BaseGDL::NOZERO);
+      for( SizeT i=0, j=bottom ; j<bottom+ncolors; ++i, ++j)
+      {
+        (*rgbtable)[i] = rint[j];
+        (*rgbtable)[i+ncolors] = gint[j];
+        (*rgbtable)[i+2*ncolors] = bint[j];
+      }
+      e->SetKW( rgbtableIx, rgbtable);
+      return; //correct behaviour.
     }
 
     if (actStream != NULL)
-      actStream->scmap1( rint, gint, bint, ctSize);
+      actStream->scmap1( rint, gint, bint, 256);
   }
 
 } // namespace
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/image.hpp gdl/src/image.hpp
--- gdl-0.9.3/src/image.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/image.hpp	2013-02-25 17:04:24.979179542 -0700
@@ -19,7 +19,6 @@
 #define IMAGE_HPP_
 
 #include <plplot/plstream.h>
-#include <plplot/plplotP.h>
 
 #include "envt.hpp"
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/includefirst.hpp gdl/src/includefirst.hpp
--- gdl-0.9.3/src/includefirst.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/includefirst.hpp	2013-03-21 14:04:04.313825472 -0600
@@ -24,7 +24,6 @@
 //#else
 //#error "config.h required. Compile with -DHAVE_CONFIG_H"
 //#endif
-
 #ifdef _MSC_VER
 #define NOMINMAX
 #endif
@@ -58,6 +57,10 @@
 //#if defined(USE_PYTHON) || defined(PYTHON_MODULE)
 #endif
 
+#if defined(USE_EIGEN)
+#include <Eigen/Core>
+#endif
+
 #if defined(__sun__)
 // SA: CS is defined in /usr/include/sys/regset.h and used in an enum statement by ANTLR
 #  include <sys/regset.h>
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/initsysvar.cpp gdl/src/initsysvar.cpp
--- gdl-0.9.3/src/initsysvar.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/initsysvar.cpp	2013-02-25 17:04:24.989179501 -0700
@@ -180,6 +180,13 @@
     DVar& eSSysVar = *sysVarList[ err_stringIx];
     static_cast<DStringGDL&>(*eSSysVar.Data())[0] = eS;
   }
+  void SetErrError( DLong eC)
+  {
+    DVar& errSysVar = *sysVarList[ errIx];
+    DVar& errorSysVar = *sysVarList[ errorIx];
+    static_cast<DLongGDL&>(*errSysVar.Data())[0] = eC;
+    static_cast<DLongGDL&>(*errorSysVar.Data())[0] = eC;
+  }
 
   DStructGDL* P()
   {
@@ -339,7 +346,7 @@
     // plotting
     // !P
     SizeT clipDim = 6;
-    DLong p_clipInit[] = { 60, 40, 622, 492, 0, 1000};
+    DLong p_clipInit[] = { 0, 0, 1024, 1024, 0, 1000};
     DLongGDL* p_clip = new DLongGDL( dimension( &clipDim, one));
     for( UInt i=0; i<clipDim; i++) (*p_clip)[ i] = p_clipInit[ i];
     SizeT multiDim = 5;
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/initsysvar.hpp gdl/src/initsysvar.hpp
--- gdl-0.9.3/src/initsysvar.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/initsysvar.hpp	2013-02-25 17:04:24.993179485 -0700
@@ -54,6 +54,7 @@
   DString MsgPrefix();
 
   void SetErr_String( const DString& eS);
+  void SetErrError( DLong eC);
 
   // set !C
   void SetC( DLong newC);
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/io.cpp gdl/src/io.cpp
--- gdl-0.9.3/src/io.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/io.cpp	2013-02-25 17:04:25.028179342 -0700
@@ -281,7 +281,9 @@
 	  {
 	    delete fStream;
 	    fStream = NULL;
-	    throw GDLIOException("Error opening file.");
+	    if( ((mode_ | ios_base::in) != 0) && ((mode_ | ios_base::out) == 0))
+	      throw GDLIOException(-265,"Error opening file for reading.");
+	    throw GDLIOException(-1,"Error opening file.");
 	  }
       }
   }
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/libinit_ac.cpp gdl/src/libinit_ac.cpp
--- gdl-0.9.3/src/libinit_ac.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/libinit_ac.cpp	2013-05-16 12:36:33.307857588 -0600
@@ -68,8 +68,6 @@
   const string fx_rootKey[]={"DOUBLE","ITMAX","STOP","TOL",KLISTEND};
   new DLibFun(lib::fx_root_fun,string("FX_ROOT"),2,fx_rootKey);
   
-
-
 #endif
   
   const string spl1Key[]={"YP0","YPN_1","DOUBLE","HELP",KLISTEND};
@@ -84,5 +82,8 @@
   const string prewittKey[]={"HELP",KLISTEND};
   new DLibFun(lib::prewitt_fun,string("PREWITT"),1,prewittKey);
 
+  const string matrix_multiplyKey[]={"ATRANSPOSE","BTRANSPOSE",KLISTEND};
+  new DLibFun(lib::matrix_multiply,string("MATRIX_MULTIPLY"),2,matrix_multiplyKey);
+
 }
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/libinit_cl.cpp gdl/src/libinit_cl.cpp
--- gdl-0.9.3/src/libinit_cl.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/libinit_cl.cpp	2013-05-16 12:36:33.311857574 -0600
@@ -205,7 +205,7 @@
 
   // SA: support fot query/ping routines
   const string magick_pingKey[] = {"INFO", "CHANNELS", "DIMENSIONS", "HAS_PALETTE", "IMAGE_INDEX",
-    "NUM_IMAGES", "PIXEL_TYPE",/* "SUPPORTED_READ", "SUPPORTED_WRITE", */"TYPE"};
+    "NUM_IMAGES", "PIXEL_TYPE",/* "SUPPORTED_READ", "SUPPORTED_WRITE", */"TYPE",KLISTEND};
   new DLibFun(lib::magick_ping, string("MAGICK_PING"), 2, magick_pingKey);
 
   // see bug no. 3376577
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/libinit.cpp gdl/src/libinit.cpp
--- gdl-0.9.3/src/libinit.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/libinit.cpp	2013-05-16 12:36:33.305857596 -0600
@@ -97,7 +97,7 @@
   new DLibFunRetNew(lib::temporary,string("TEMPORARY"),1);
 
   const string routine_infoKey[]={"FUNCTIONS","SYSTEM","DISABLED","ENABLED",
-				  "PARAMETERS", KLISTEND};
+				  "PARAMETERS","SOURCE", KLISTEND};
   new DLibFun(lib::routine_info,string("ROUTINE_INFO"),1,routine_infoKey);
 
 #ifndef _MSC_VER
@@ -200,8 +200,8 @@
   
   const string helpKey[]={"STRUCTURES","ROUTINES","BRIEF",
 			  "OUTPUT","PROCEDURES","FUNCTIONS",
-			  "INFO","LIB","LIB_GDL_INTERNAL","CALLS","RECALL_COMMANDS",
-                          "MEMORY","PREFERENCES", KLISTEND};
+			  "INFO","LIB","INTERNAL_LIB_GDL","CALLS","RECALL_COMMANDS",
+                          "MEMORY","PREFERENCES", "SOURCE_FILES", KLISTEND};
   new DLibPro(lib::help,string("HELP"),-1,helpKey);
 
   const string memoryKey[]={"CURRENT","HIGHWATER","NUM_ALLOC",
@@ -234,7 +234,7 @@
 
   const string heap_gcKey[]={"PTR","OBJ","VERBOSE",KLISTEND};
   new DLibPro(lib::heap_gc,string("HEAP_GC"),0,heap_gcKey); 
-  new DLibPro(lib::heap_free,string("HEAP_FREE"),1,heap_gcKey); 
+  new DLibPro(lib::heap_free,string("HEAP_FREE"),1,heap_gcKey);
 
 
   new DLibPro(lib::ptr_free,string("PTR_FREE"),-1);
@@ -495,18 +495,26 @@
   const string tvlctKey[]={"GET","HLS","HSV",KLISTEND};
   new DLibPro(lib::tvlct,string("TVLCT"),4,tvlctKey);
 
+  const string tvcrsKey[]={"DATA","DEVICE","NORMAL",KLISTEND};
+  const string tvcrsWarnKey[]={"CENTIMETERS","INCHES","HIDE_CURSOR","T3D","Z",KLISTEND};
+  new DLibPro(lib::tvcrs,string("TVCRS"),2,tvcrsKey,tvcrsWarnKey);
+
+  new DLibPro(lib::empty,string("EMPTY"),-1);
+  
   const string deviceKey[]=
     {
       "CLOSE_FILE","FILENAME","LANDSCAPE","PORTRAIT",
       "DECOMPOSED","GET_DECOMPOSED","Z_BUFFERING","SET_RESOLUTION",
       "SET_CHARACTER_SIZE","GET_VISUAL_DEPTH","XSIZE","YSIZE",
       "COLOR","GET_SCREEN_SIZE","INCHES","WINDOW_STATE","SCALE_FACTOR", 
-      "XOFFSET", "YOFFSET", "ENCAPSULATED", KLISTEND
+      "XOFFSET", "YOFFSET", "ENCAPSULATED", "GET_GRAPHICS_FUNCTION", 
+      "SET_GRAPHICS_FUNCTION", "CURSOR_STANDARD", "CURSOR_ORIGINAL",
+      "CURSOR_CROSSHAIR","RETAIN", KLISTEND
     };
-  const string deviceWarnKey[] = {"RETAIN", "SET_FONT", "HELVETICA", 
+  const string deviceWarnKey[] = {"SET_FONT", "HELVETICA", 
     "AVANTGARDE", "BKMAN", "COURIER", "PALATINO", 
     "SCHOOLBOOK", "TIMES", "ZAPFCHANCERY", "ZAPFDINGBATS", "BITS_PER_PIXEL", 
-    "ITALIC", "BOLD", "TRUE_COLOR", KLISTEND};
+    "ITALIC", "BOLD", "TRUE_COLOR", "CURSOR_IMAGE","CURSOR_MASK","CURSOR_XY", KLISTEND};
   new DLibPro(lib::device,string("DEVICE"),0, deviceKey, deviceWarnKey);
 
   const string usersymKey[]= 
@@ -523,65 +531,68 @@
      "LINESTYLE", "NOCLIP",  "NODATA",   "NOERASE", 
      "NORMAL",    "POSITION","PSYM",     "SUBTITLE",
      "SYMSIZE",   "THICK",    "TICKLEN", "TITLE",
-     "XCHARSIZE", "XMARGIN", "XMINOR",
-     "XRANGE",    "XSTYLE",     "XTHICK",  "XTICKFORMAT",
-     "XTICKLEN",  "XTICKS",     "XTITLE",
-     "YCHARSIZE", "YMARGIN", "YMINOR",
-     "YRANGE",    "YSTYLE",     "YTHICK",  "YTICKFORMAT", "YTICKLEN",
-     "YTICKS",    "YTITLE", "ZCHARSIZE",    "ZGRIDSTYLE", "ZMARGIN", "ZMINOR",
-     "ZRANGE",    "ZSTYLE",     "ZTHICK",  "ZTICKFORMAT",
-     "ZTICKLEN",  "ZTICKS",    "ZTITLE", "ZVALUE", "MAX_VALUE", "MIN_VALUE",
-     "XLOG",      "YLOG",     "YNOZERO", "XTYPE", "YTYPE", "POLAR", "NSUM",
-     KLISTEND
+     "MAX_VALUE", "MIN_VALUE",
+     "XLOG",      "YLOG",
+     "YNOZERO",   "XTYPE",    "YTYPE",   "POLAR", "NSUM",
+      "XCHARSIZE", "YCHARSIZE",
+      "XGRIDSTYLE", "YGRIDSTYLE",
+      "XMARGIN", "YMARGIN",
+      "XMINOR", "YMINOR",
+      "XRANGE", "YRANGE",
+      "XSTYLE", "YSTYLE",
+      "XTHICK", "YTHICK",
+      "XTICK_GET", "YTICK_GET",
+      "XTICKFORMAT", "YTICKFORMAT",
+      "XTICKINTERVAL", "YTICKINTERVAL",
+      "XTICKLAYOUT", "YTICKLAYOUT",
+      "XTICKLEN", "YTICKLEN",
+      "XTICKNAME", "YTICKNAME",
+      "XTICKS", "YTICKS",
+      "XTICKUNITS", "YTICKUNITS",
+      "XTICKV", "YTICKV",
+      "XTITLE", "YTITLE",
+      "ZCHARSIZE", "ZGRIDSTYLE", "ZMARGIN", "ZMINOR",
+      "ZRANGE", "ZSTYLE", "ZTHICK", "ZTICK_GET", "ZTICKFORMAT", "ZTICKINTERVAL",
+      "ZTICKLAYOUT", "ZTICKLEN", "ZTICKNAME", "ZTICKS", "ZTICKUNITS", "ZTICKV",
+      "ZTITLE", "T3D", "ZVALUE", KLISTEND
     };
   //
-  const string plotWarnKey[]= {
-    "FONT", "T3D", "YTICKUNITS", "XTICKLAYOUT", "YTICKLAYOUT", 
-    "ZTICKLAYOUT", "XGRIDSTYLE", "YGRIDSTYLE", "XTICKUNITS", "XTICKV", "XTICK_GET", "YTICKV",
-    "YTICK_GET", "XTICKNAME", "ZTICKNAME", "ZTICKUNITS", "ZTICKV",  "ZTICK_GET",
-    "XTICKINTERVAL", "YTICKINTERVAL", "YTICKNAME", "ZTICKINTERVAL", 
-    KLISTEND
-  };
+  const string plotWarnKey[]= { "FONT", KLISTEND };
   new DLibPro(lib::plot,string("PLOT"),2,plotKey,plotWarnKey);
 
   const string axisKey[]=
-    {
-     "CHARSIZE","CHARTHICK",
-     "COLOR",     "DATA",    "DEVICE",   "FONT",
-     "NODATA",    "NOERASE", 
-     "NORMAL",    "SUBTITLE",
-     "T3D",       "TICKLEN", 
-     "XCHARSIZE", "XGRIDSTYLE", "XMARGIN", "XMINOR",
-     "XRANGE",    "XSTYLE",     "XTHICK",  "XTICKFORMAT",
-     "XTICKLEN",  "XTICKNAME",
-     "XTICKS",    
-     "XTITLE",
-     "YCHARSIZE",  "YGRIDSTYLE", "YMARGIN", "YMINOR",
-     "YRANGE",     "YSTYLE",     "YTHICK",  "YTICKFORMAT",
-     "YTICKLEN",   "YTICKNAME",
-     "YTICKS",
-     "YTITLE",
-     "ZCHARSIZE",  "ZGRIDSTYLE", "ZMARGIN", "ZMINOR",
-     "ZRANGE",     "ZSTYLE",     "ZTHICK",  "ZTICKFORMAT",
-     "ZTICKLEN",   "ZTICKNAME",
-     "ZTICKS",
-     "ZTITLE",
-     "ZVALUE", 
-
-     "SAVE", "XAXIS", "YAXIS", "XLOG", "YLOG", "XTYPE", "YTYPE", "YNOZERO", "THICK",
-      KLISTEND
-     };
-   const string axisWarnKey[]=
-   {
-   "ZAXIS","ZLOG", 
-   "XTICKINTERVAL", "YTICKINTERVAL", "ZTICKINTERVAL",
-   "XTICKLAYOUT", "YTICKLAYOUT", "ZTICKLAYOUT",
-   "XTICKUNITS", "YTICKUNITS", "ZTICKUNITS",
-   "XTICKV", "YTICKV", "ZTICKV",
-   "XTICK_GET", "YTICK_GET", "ZTICK_GET",
-   KLISTEND
+  {
+    "CHARSIZE",  "CHARTHICK",
+    "COLOR",     "DATA",    "DEVICE",   "FONT",
+    "NODATA",    "NOERASE", 
+    "NORMAL",    "SUBTITLE",
+    "T3D",       "TICKLEN", 
+    "SAVE", "XAXIS", "YAXIS", "XLOG", "YLOG", "XTYPE", "YTYPE", "YNOZERO", "THICK",
+    "XCHARSIZE", "YCHARSIZE",
+    "XGRIDSTYLE", "YGRIDSTYLE",
+    "XMARGIN", "YMARGIN",
+    "XMINOR", "YMINOR",
+    "XRANGE", "YRANGE",
+    "XSTYLE", "YSTYLE",
+    "XTHICK", "YTHICK",
+    "XTICK_GET", "YTICK_GET",
+    "XTICKFORMAT", "YTICKFORMAT",
+    "XTICKINTERVAL", "YTICKINTERVAL",
+    "XTICKLAYOUT", "YTICKLAYOUT",
+    "XTICKLEN", "YTICKLEN",
+    "XTICKNAME", "YTICKNAME",
+    "XTICKS", "YTICKS",
+    "XTICKUNITS", "YTICKUNITS",
+    "XTICKV", "YTICKV",
+    "XTITLE", "YTITLE",
+    "ZAXIS", "ZLOG", "ZVALUE", "ZCHARSIZE", "ZGRIDSTYLE", "ZMARGIN", "ZMINOR",
+    "ZRANGE", "ZSTYLE", "ZTHICK", "ZTICK_GET", "ZTICKFORMAT", "ZTICKINTERVAL",
+    "ZTICKLAYOUT", "ZTICKLEN", "ZTICKNAME", "ZTICKS", "ZTICKUNITS", "ZTICKV",
+    "ZTITLE",
+    KLISTEND
   };
-  new DLibPro(lib::axis,string("AXIS"),3,axisKey,axisWarnKey);
+//  const string axisWarnKey[]={KLISTEND};
+  new DLibPro(lib::axis,string("AXIS"),3,axisKey);  //,axisWarnKey);
 
   const string oplotKey[]=
     {
@@ -589,7 +600,7 @@
       // 0
       "CLIP","COLOR", "LINESTYLE", "NOCLIP",
       // 4
-      "PSYM", "SYMSIZE",  "T3D",  "THICK",
+      "PSYM", "SYMSIZE",  "T3D",  "ZVALUE", "THICK",
       // 8
       "MAX_VALUE", "MIN_VALUE", "NSUM", "POLAR",
       KLISTEND
@@ -599,15 +610,57 @@
   const string plotsKey[]=
     {
       "CLIP","COLOR", "LINESTYLE", "NOCLIP",
-      "PSYM", "SYMSIZE",  "T3D",  "THICK",
+      "PSYM", "SYMSIZE",  "T3D",  "Z", "THICK",
       "DATA","DEVICE","NORMAL","CONTINUE",
       KLISTEND
     };
-  const string plotsWarnKey[] = 
+
+  new DLibPro(lib::plots, string("PLOTS"), 3, plotsKey);
+
+  const string set_shadingKey[]=
+  {
+    "LIGHT", KLISTEND
+  };
+  
+  const string set_shadingWarnKey[]=
+  {
+     "GOURAUD","REJECT","VALUES",KLISTEND
+  };
+  new DLibPro(lib::set_shading, string("SET_SHADING"), 0, set_shadingKey, set_shadingWarnKey);
+
+  const string shade_surfKey[]=
+    {
+      "AX", "AZ",  "MAX_VALUE", "MIN_VALUE", "SHADES", "XLOG", "YLOG","ZLOG", 
+      //General Graphics KW
+      "BACKGROUND", "NOERASE",
+      "CHARSIZE", "CHARTHICK", "COLOR", "DATA", "DEVICE", "NORMAL", "FONT",
+      "NODATA", "POSITION", "SUBTITLE", "THICK", "TICKLEN", "TITLE",
+      //Axis KW
+      "ZCHARSIZE", "YCHARSIZE", "XCHARSIZE",
+      "ZGRIDSTYLE", "YGRIDSTYLE", "XGRIDSTYLE",
+      "ZMARGIN", "YMARGIN", "XMARGIN",
+      "ZMINOR", "YMINOR", "XMINOR",
+      "ZRANGE", "YRANGE", "XRANGE",
+      "ZSTYLE", "YSTYLE", "XSTYLE",
+      "ZTHICK", "YTHICK", "XTHICK",
+      "ZTICKFORMAT", "YTICKFORMAT", "XTICKFORMAT",
+      "ZTICKINTERVAL", "YTICKINTERVAL", "XTICKINTERVAL",
+      "ZTICKLAYOUT", "YTICKLAYOUT", "XTICKLAYOUT",
+      "ZTICKLEN", "YTICKLEN", "XTICKLEN",
+      "ZTICKNAME", "YTICKNAME", "XTICKNAME",
+      "ZTICKS", "YTICKS", "XTICKS",
+      "ZTICKUNITS", "YTICKUNITS", "XTICKUNITS",
+      "ZTICKV", "YTICKV", "XTICKV",
+      "ZTICK_GET", "YTICK_GET", "XTICK_GET",
+      "ZTITLE", "YTITLE", "XTITLE",
+      //3D KW
+      "ZVALUE","T3D", "SAVE", "SKIRT", "ZAXIS", KLISTEND
+    };
+  const string shade_surfWarnKey[]=
   {
-    "Z", KLISTEND
+      "IMAGE", "PIXELS",  KLISTEND
   };
-  new DLibPro(lib::plots, string("PLOTS"), 3, plotsKey, plotsWarnKey);
+  new DLibPro(lib::shade_surf,string("SHADE_SURF"),3,shade_surfKey, shade_surfWarnKey);
 
   const string surfaceKey[]=
     {
@@ -621,7 +674,7 @@
      // 12
      "NORMAL",    "POSITION",     "SUBTITLE",
      // 15
-     "T3D",     "THICK",    "TICKLEN", 
+     "THICK",    "TICKLEN", 
      // 18
      "TITLE",
      // 19
@@ -655,52 +708,64 @@
      // 69
      "ZTITLE",
      // 70
-     "ZVALUE", 
+
 
      // SURFACE keywords
      // 73
-     "MAX_VALUE",  "MIN_VALUE", "AX", "AZ", "XLOG", "YLOG", "ZLOG", KLISTEND
+     "MAX_VALUE",  "MIN_VALUE", "AX", "AZ", "XLOG", "YLOG", "ZLOG",
+     "HORIZONTAL", "LOWER_ONLY", "UPPER_ONLY", "SHADES", "ZAXIS",  "BOTTOM", 
+     "SKIRT", "SAVE", "T3D",  "ZVALUE", KLISTEND
     };
   const string surfaceWarnKey[]=
   {
-    "SAVE", "BOTTOM", "HORIZONTAL", "LOWER_ONLY", "UPPER_ONLY",
-    "SHADES", "SKIRT", "ZAXIS", "LEGO", KLISTEND
+      "LEGO", KLISTEND
   };
   new DLibPro(lib::surface,string("SURFACE"),3,surfaceKey, surfaceWarnKey);
 
   const string contourKey[]=
     {
-     "BACKGROUND","CHARSIZE","CHARTHICK","CLIP",
-     "COLOR",     "DATA",    "DEVICE",   "FONT",
-     "NOCLIP",  "NODATA",   "NOERASE", 
-     "NORMAL",    "POSITION",     "SUBTITLE",
-     "T3D",     "THICK",    "TICKLEN", 
-     "TITLE",
-     "XCHARSIZE",    "XGRIDSTYLE", "XMARGIN", "XMINOR",
-     "XRANGE",       "XSTYLE",     "XTHICK",  "XTICKFORMAT",
-     "XTICKLEN","XTICKNAME",
-     "XTICKS",       "XTICKV",  "XTICK_GET",
-     "XTITLE",
-     "YCHARSIZE",    "YGRIDSTYLE", "YMARGIN", "YMINOR",
-     "YRANGE",       "YSTYLE",     "YTHICK",  "YTICKFORMAT",
-     "YTICKLEN","YTICKNAME",
-     "YTICKS",       "YTICKV",  "YTICK_GET",
-     "YTITLE",
-     "ZCHARSIZE",    "ZGRIDSTYLE", "ZMARGIN", "ZMINOR",
-     "ZRANGE",       "ZSTYLE",     "ZTHICK",  "ZTICKFORMAT",
-     "ZTICKLEN","ZTICKNAME",
-     "ZTICKS",       "ZTICKV",  "ZTICK_GET",
-     "ZTITLE",
-     "ZVALUE", 
-     "LEVELS", "NLEVELS",
-     "MAX_VALUE", "MIN_VALUE",
-     "XLOG", "XTYPE", "YLOG", "YTYPE", "ZLOG", "ZTYPE", "FILL", "ISOTROPIC",
-     "FOLLOW", "C_CHARSIZE","OVERPLOT","C_COLORS","C_LINESTYLE",
-     KLISTEND
+      "BACKGROUND","CHARSIZE","CHARTHICK","CLIP",
+      "COLOR",     "DATA",    "DEVICE",   "FONT",
+      "NOCLIP",  "NODATA",   "NOERASE",
+      "NORMAL",    "POSITION", "SUBTITLE",
+      "T3D",     "THICK",    "TICKLEN",
+      "TITLE" ,    "LEVELS", "NLEVELS",
+      "MAX_VALUE", "MIN_VALUE",
+      "XLOG", "YLOG", "FILL", "ISOTROPIC",
+      "FOLLOW",
+
+      "XCHARSIZE", "YCHARSIZE", "ZCHARSIZE",
+      "XGRIDSTYLE", "YGRIDSTYLE", "ZGRIDSTYLE",
+      "XMARGIN", "YMARGIN", "ZMARGIN",
+      "XMINOR", "YMINOR", "ZMINOR",
+      "XRANGE", "YRANGE", "ZRANGE",
+      "XSTYLE", "YSTYLE", "ZSTYLE",
+      "XTHICK", "YTHICK", "ZTHICK",
+      "XTICK_GET", "YTICK_GET", "ZTICK_GET",
+      "XTICKFORMAT", "YTICKFORMAT", "ZTICKFORMAT",
+      "XTICKINTERVAL", "YTICKINTERVAL", "ZTICKINTERVAL",
+      "XTICKLAYOUT", "YTICKLAYOUT", "ZTICKLAYOUT",
+      "XTICKLEN", "YTICKLEN", "ZTICKLEN",
+      "XTICKNAME", "YTICKNAME", "ZTICKNAME",
+      "XTICKS", "YTICKS",  "ZTICKS",
+      "XTICKUNITS", "YTICKUNITS",  "ZTICKUNITS",
+      "XTICKV", "YTICKV","ZTICKV",
+      "XTITLE", "YTITLE", "ZTITLE",
+      "ZVALUE", "ZAXIS",
+      "C_CHARSIZE","OVERPLOT","C_COLORS","C_LINESTYLE",
+      "C_LABELS", "C_CHARTHICK", "C_ORIENTATION", "C_SPACING", "C_THICK",
+      "PATH_INFO","PATH_XY",
+      "ZLOG","IRREGULAR", //ZLOG is an addition for GDL only
+      KLISTEND
     };
+   // NO SUPPORT AT ALL for:,"CLOSED","DOWNHILL","IRREGULAR","PATH_DATA_COORDS","PATH_FILENAME",
+   // "PATH_INFO","PATH_XY","TRIANGULATION","PATH_DOUBLE","ZAXIS"
    const string contourWarnKey[]=
     {
-        "CELL_FILL","C_LABELS","C_ANNOTATIONS", "C_CHARTHICK","C_ORIENTATION","C_SPACING","C_THICK",KLISTEND 
+      
+      "CELL_FILL","C_ANNOTATIONS","CLOSED","DOWNHILL",
+      "PATH_DATA_COORDS","PATH_FILENAME",
+      "PATH_INFO","PATH_XY","TRIANGULATION","PATH_DOUBLE",KLISTEND
     };
    new DLibPro(lib::contour,string("CONTOUR"),3,contourKey,contourWarnKey);
 
@@ -709,22 +774,37 @@
   const string xyoutsKey[]=
     {
       "COLOR","DATA","NORMAL","DEVICE","CLIP",
-      "ORIENTATION","ALIGNMENT","CHARSIZE","SIZE","CHARTHICK",
-      "NOCLIP","Z","WIDTH","FONT",KLISTEND
+      "ORIENTATION","ALIGNMENT","CHARSIZE","SIZE","CHARTHICK", //note SIZE is not in doc but in XYOUTS demo!
+      "NOCLIP","T3D","Z","TEXT_AXES","WIDTH","FONT",KLISTEND
     };
-   const string xyoutsWarnKey[]=
-    {
-      "TEXT_AXES","T3D", KLISTEND 
-    };  
-   new DLibPro(lib::xyouts, string("XYOUTS"), 3, xyoutsKey, xyoutsWarnKey);
+   const string xyoutsWarnKey[]={KLISTEND};  
+   new DLibPro(lib::xyouts, string("XYOUTS"), 3, xyoutsKey);//, xyoutsWarnKey);
    
    const string polyfillKey[]=
     {
-      "COLOR","DATA","NORMAL","DEVICE","CLIP","NOCLIP",
-      "LINE_FILL","SPACING","LINESTYLE","ORIENTATION","THICK",
+      "CLIP", "COLOR","DATA","DEVICE","NORMAL","LINESTYLE","NOCLIP", //supported graphic KW
+      "ORIENTATION","THICK", //supported graphic KW
+      "LINE_FILL", "SPACING", "T3D","Z", //polyfill specifics
       KLISTEND
     };
-  new DLibPro(lib::polyfill, string("POLYFILL"), 3, polyfillKey);
+   const string polyfillWarnKey[]=
+    {
+     "IMAGE_COORD","IMAGE_INTERP", "PATTERN", "TRANSPARENT",KLISTEND
+    };
+  new DLibPro(lib::polyfill, string("POLYFILL"), 3, polyfillKey,polyfillWarnKey);
+
+  const string scale3Key[]=
+  {
+    "AX", "AZ", "XRANGE", "YRANGE", "ZRANGE", KLISTEND
+  };
+  new DLibPro(lib::scale3_pro, string("SCALE3"), 0, scale3Key); //in plotting_convert_coord.cpp
+
+  const string t3dKey[]=
+  {
+     "RESET", "MATRIX", "OBLIQUE", "PERSPECTIVE", "ROTATE", "SCALE", "TRANSLATE",
+     "XYEXCH", "XZEXCH", "YZEXCH", KLISTEND
+  };
+  new DLibPro(lib::t3d_pro, string("T3D"), 1, t3dKey); //in plotting_convert_coord.cpp
 
   const string eraseKey[]= {"CHANNEL","COLOR",KLISTEND};
   new DLibPro(lib::erase,string("ERASE"),1, eraseKey);
Only in gdl-0.9.3/src: .#libinit.cpp.1.150
Only in gdl-0.9.3/src: .#libinit.cpp.1.151
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/libinit_jmg.cpp gdl/src/libinit_jmg.cpp
--- gdl-0.9.3/src/libinit_jmg.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/libinit_jmg.cpp	2013-03-21 14:04:04.333825380 -0600
@@ -140,6 +140,22 @@
 			   "GRAY","LINEAR","NRHO","NTHETA","NX","NY",
 			   "RHO","RMIN","THETA","XMIN","YMIN",KLISTEND};
   new DLibFun(lib::radon_fun,string("RADON"),1,radonKey);
+#ifdef PL_HAVE_QHULL
+  const string triangulateKey[]={"CONNECTIVITY", "SPHERE", "DEGREES", "FVALUE", "REPEATS", "TOLERANCE",KLISTEND};
+  new DLibPro(lib::triangulate,string("TRIANGULATE"),4,triangulateKey);
+
+  const string qhullKey[]={"BOUNDS", "CONNECTIVITY", "DELAUNAY", "SPHERE", "VDIAGRAM" ,"VNORMALS", "VVERTICES", KLISTEND};
+  new DLibPro(lib::qhull,string("QHULL"),8,qhullKey);
+
+  const string sph_scatKey[]={"BOUNDS", "BOUT", "GOUT", "GS", "NLON", "NLAT", KLISTEND};
+  new DLibFun(lib::sph_scat_fun,string("SPH_SCAT"),3,sph_scatKey);
+
+  const string grid_inputKey[]={"SPHERE", "POLAR", "DEGREES", "DUPLICATES", "EPSILON", "EXCLUDE", KLISTEND};
+  new DLibPro(lib::grid_input,string("GRID_INPUT"),6,grid_inputKey);
+
+  const string qgrid3Key[]={"DELTA", "DIMENSION", "MISSING", "START", KLISTEND};
+  new DLibFun(lib::qgrid3_fun,string("QGRID3"),5,qgrid3Key);
+#endif
 
   const string trigridKey[]={"MAX_VALUE","MISSING","NX","NY","MAP",
 			     KLISTEND};
@@ -255,8 +271,9 @@
   const string tvrdKey[]={"CHANNEL","ORDER","TRUE","WORDS",KLISTEND};
   new DLibFun(lib::tvrd,string("TVRD"),5,tvrdKey);
 
-  const string loadctKey[]={"GET_NAMES",KLISTEND};
-  new DLibPro(lib::loadct,string("LOADCT_INTERNALGDL"),1,loadctKey);
+  const string loadctKey[]={"GET_NAMES","BOTTOM","NCOLORS","RGB_TABLE","SILENT",KLISTEND};
+  const string loadctWarnKey[]={"FILE",KLISTEND};
+  new DLibPro(lib::loadct,string("LOADCT_INTERNALGDL"),1,loadctKey,loadctWarnKey);
 
   const string widget_baseKey[] = {"ALIGN_BOTTOM","ALIGN_CENTER","ALIGN_LEFT","ALIGN_RIGHT","ALIGN_TOP","MBAR","MODAL","BASE_ALIGN_BOTTOM","BASE_ALIGN_CENTER","BASE_ALIGN_LEFT","BASE_ALIGN_RIGHT","BASE_ALIGN_TOP","COLUMN","ROW","CONTEXT_EVENTS","CONTEXT_MENU","EVENT_FUNC","EVENT_PRO","EXCLUSIVE","NONEXCLUSIVE","FLOATING","FRAME","FUNC_GET_VALUE","GRID_LAYOUT","GROUP_LEADER","KBRD_FOCUS_EVENTS","KILL_NOTIFY","MAP","NO_COPY","NOTIFY_REALIZE","PRO_SET_VALUE","SCR_XSIZE","SCR_YSIZE","SCROLL","SENSITIVE","SPACE","TITLE","TLB_FRAME_ATTR","TLB_ICONIFY_EVENTS","TLB_KILL_REQUEST_EVENTS","TLB_MOVE_EVENTS","TLB_SIZE_EVENTS","TOOLBAR","TRACKING_EVENTS","UNITS","UNAME","UVALUE","XOFFSET","XPAD","XSIZE","X_SCROLL_SIZE","YOFFSET","YPAD","YSIZE","Y_SCROLL_SIZE","DISPLAY_NAME","RESOURCE_NAME","RNAME_MBAR",KLISTEND};
   new DLibFun(lib::widget_base,string("WIDGET_BASE"),1,widget_baseKey);
@@ -306,5 +323,3 @@
   new DLibFun(lib::call_external, string("CALL_EXTERNAL"), -1, call_externalKey);
 
 }
-
-
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/magick_cl.cpp gdl/src/magick_cl.cpp
--- gdl-0.9.3/src/magick_cl.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/magick_cl.cpp	2013-03-25 10:36:38.468969341 -0600
@@ -55,30 +55,7 @@
   unsigned int gValid[40];
   unsigned int gCount=0;
 
-  string GDLutos(unsigned int i)
-  {
-    int mema=3;
-    char *n=new char(mema);
-    while (snprintf(n, sizeof n, "%u", i) >= sizeof n)
-      {			delete n;mema++; n=new char(mema);   }
-    string s=n;
-    delete n;
-    return s;
-  }
-
   
-  string GDLitos(int i)
-  {
-    int mema=3;
-    char *n=new char(mema);
-    while (snprintf(n, sizeof n, "%d", i) >= sizeof n)
-      {			delete n;mema++; n=new char(mema);   }
-    string s=n;
-    delete n;
-    return s;
-  }
-
-
   void magick_setup()
   {
     int i;
@@ -564,7 +541,7 @@
 	    else 
 	      {
 		string s="MAGICK_READ: RGB order type not supported (";
-		s+=GDLutos(rgb);
+		s+=i2s(rgb);
 		s+="), using BGR ordering.";
 		Message(s);		
 		map="BGR";
@@ -659,7 +636,7 @@
 		else
 		{
 		  string s="MAGICK_WRITE: RGB order type not supported (";
-		  s+=GDLutos(rgb);
+		  s+=i2s(rgb);
 		  s+="), using BGR ordering.";
 		  Message(s);		
 		  map="BGR";
@@ -1069,15 +1046,15 @@
     BaseGDL* GDLCol=e->GetParDefined(1);
     DByteGDL * Red=static_cast<DByteGDL*>(GDLCol->Convert2(GDL_BYTE,BaseGDL::COPY));
     //e->Guard( Red);
-    auto_ptr<BaseGDL> r_guard( Red);
+    Guard<BaseGDL> r_guard( Red);
     GDLCol=e->GetParDefined(2);
     DByteGDL * Green=static_cast<DByteGDL*>(GDLCol->Convert2(GDL_BYTE,BaseGDL::COPY));
     //e->Guard( Green);
-    auto_ptr<BaseGDL> g_guard( Green);
+    Guard<BaseGDL> g_guard( Green);
     GDLCol=e->GetParDefined(3);
     DByteGDL *Blue= static_cast<DByteGDL*>(GDLCol->Convert2(GDL_BYTE,BaseGDL::COPY));
     //e->Guard( Blue);
-    auto_ptr<BaseGDL> b_guard( Blue);
+    Guard<BaseGDL> b_guard( Blue);
 
     if(Red->N_Elements() == Green->N_Elements() && 
        Red->N_Elements() == Blue->N_Elements())
Only in gdl-0.9.3/src: .#Makefile.am.1.64
Only in gdl-0.9.3/src: Makefile.in
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/math_fun_ac.cpp gdl/src/math_fun_ac.cpp
--- gdl-0.9.3/src/math_fun_ac.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/math_fun_ac.cpp	2013-05-16 12:36:33.327857516 -0600
@@ -6,11 +6,6 @@
     email                : alaingdl@users.sourceforge.net
 
 ****************************************************************************/
-
-
-
-
-
 /***************************************************************************
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -52,6 +47,7 @@
 
 */
 
+
 #define GM_EPS   1.0e-6
 #define GM_ITER  50
 #define GM_TINY  1.0e-18
@@ -67,7 +63,7 @@
     throw GDLException(e->CallingNode(), "Variable is undefined: "+e->GetParString(0));	\
   									\
   DType t0 = e->GetParDefined(0)->Type();				\
-  //if (t0 == GDL_COMPLEX || t0 == GDL_COMPLEXDBL)				\
+  //if (t0 == GDL_COMPLEX || t0 == GDL_COMPLEXDBL)			\
   //  e->Throw("Complex not implemented (GSL limitation). ");
 
 #define AC_2P1()							\
@@ -81,7 +77,7 @@
       p1 = new DIntGDL(1, BaseGDL::NOZERO);				\
       (*p1)[0]=0;							\
       nElp1=1;								\
-      t1 = GDL_INT;								\
+      t1 = GDL_INT;							\
       p1_float = new DFloatGDL(1, BaseGDL::NOZERO);			\
       (*p1_float)[0]=0.000;						\
     }									\
@@ -97,25 +93,25 @@
 									\
   //    throw GDLException(e->CallingNode(), "Variable is undefined: "+e->GetParString(1)); \
   									\
-//  DType t1 = e->GetParDefined(1)->Type();				\
-  //  if (t1 == GDL_COMPLEX || t1 == GDL_COMPLEXDBL)				\
+  //  DType t1 = e->GetParDefined(1)->Type();				\
+  //  if (t1 == GDL_COMPLEX || t1 == GDL_COMPLEXDBL)			\
   // e->Throw("Complex not implemented (GSL limitation). ");
 
-#define GM_DF2()							\
-  									\
-  DDoubleGDL* res;							\
-  if (nElp0 == 1 && nElp1 == 1)						\
-    res = new DDoubleGDL(1, BaseGDL::NOZERO);				\
-  else if (nElp0 > 1 && nElp1 == 1)					\
-    res = new DDoubleGDL(p0->Dim(), BaseGDL::NOZERO);			\
-  else if (nElp0 == 1 && nElp1 > 1)					\
-    res = new DDoubleGDL(p1->Dim(), BaseGDL::NOZERO);			\
-  else if (nElp0 <= nElp1)						\
-    res = new DDoubleGDL(p0->Dim(), BaseGDL::NOZERO);			\
-  else									\
-    res = new DDoubleGDL(p1->Dim(), BaseGDL::NOZERO);			\
-  									\
-  SizeT nElp = res->N_Elements();					\
+#define GM_DF2()					\
+							\
+  DDoubleGDL* res;					\
+  if (nElp0 == 1 && nElp1 == 1)				\
+    res = new DDoubleGDL(1, BaseGDL::NOZERO);		\
+  else if (nElp0 > 1 && nElp1 == 1)			\
+    res = new DDoubleGDL(p0->Dim(), BaseGDL::NOZERO);	\
+  else if (nElp0 == 1 && nElp1 > 1)			\
+    res = new DDoubleGDL(p1->Dim(), BaseGDL::NOZERO);	\
+  else if (nElp0 <= nElp1)				\
+    res = new DDoubleGDL(p0->Dim(), BaseGDL::NOZERO);	\
+  else							\
+    res = new DDoubleGDL(p1->Dim(), BaseGDL::NOZERO);	\
+							\
+  SizeT nElp = res->N_Elements();			\
 
 #define GM_CV0()					\
   static DInt doubleKWIx = e->KeywordIx("DOUBLE");	\
@@ -133,20 +129,20 @@
   else							\
     return res;
 
-#define GM_CC1()						\
-  static DInt coefKWIx = e->KeywordIx("ITER");			\
-  if(e->KeywordPresent(coefKWIx))				\
-    {								\
+#define GM_CC1()							\
+  static DInt coefKWIx = e->KeywordIx("ITER");				\
+  if(e->KeywordPresent(coefKWIx))					\
+    {									\
       cout << "ITER keyword not used, always return -1)" << endl;	\
-      e->SetKW( coefKWIx, new DLongGDL( -1));			\
+      e->SetKW( coefKWIx, new DLongGDL( -1));				\
     }
 
-#define AC_HELP()				\
-  if (e->KeywordSet("HELP")) {			\
+#define AC_HELP()							\
+  if (e->KeywordSet("HELP")) {						\
     string inline_help[]={						\
       "Usage: res="+e->GetProName()+"(x, [n,] double=double)",		\
       " -- x is a number or an array",					\
-      " -- n is a number or an array (if missing, set to 0)",					\
+      " -- n is a number or an array (if missing, set to 0)",		\
       " If x and n dimensions differ, reasonnable rules applied"};	\
     int size_of_s = sizeof(inline_help) / sizeof(inline_help[0]);	\
     e->Help(inline_help, size_of_s);					\
@@ -158,13 +154,18 @@
 #include <gsl/gsl_sf_bessel.h>
 
 #ifdef _MSC_VER
-#define isfinite _finite
+#define isfinite _finite
 #define isinf !_finite
 #endif
 
+namespace lib {
+
 using namespace std;
+using std::isinf;
 
-namespace lib {
+#if defined(USE_EIGEN)
+using namespace Eigen;
+#endif
 
   BaseGDL* beseli_fun(EnvT* e)
   {
@@ -177,8 +178,8 @@
 
     // GSL Limitation for X : must be lower than ~708
     for (count = 0;count<nElp0;++count)
-	  if ((*p0)[count] > 708.)
-	    e->Throw("Value of X is out of allowed range.");
+      if ((*p0)[count] > 708.)
+	e->Throw("Value of X is out of allowed range.");
 
     // we need to check if N values (array) are Integer or not
     int test=0;
@@ -520,10 +521,10 @@
 
     // we only issue a message
     if (nElpXpos != nElpYpos) {
-	cout << "SPL_INIT (warning): X and Y arrays do not have same lengths !" << endl;
-	// all next computations to be done on MIN(nElpXpos,nElpYpos) (except NaN/Inf checks)
-    	if (nElpXpos > nElpYpos)
-	  nElpXpos=nElpYpos;
+      cout << "SPL_INIT (warning): X and Y arrays do not have same lengths !" << endl;
+      // all next computations to be done on MIN(nElpXpos,nElpYpos) (except NaN/Inf checks)
+      if (nElpXpos > nElpYpos)
+	nElpXpos=nElpYpos;
     }
 
     // creating result array
@@ -569,10 +570,10 @@
       }
     }
 
-    auto_ptr<BaseGDL> U_guard;
+    Guard<BaseGDL> U_guard;
     DDoubleGDL* U;
     U = new DDoubleGDL(nElpXpos, BaseGDL::NOZERO);
-    U_guard.reset(U); // delete upon exit
+    U_guard.Reset(U); // delete upon exit
     
     // may be we will have to check the size of these arrays ?
 
@@ -580,10 +581,10 @@
     DDoubleGDL* YP0;
 
     if(Yderiv0 !=NULL && !isinf((*(YP0=e->GetKWAs<DDoubleGDL>(e->KeywordIx("YP0"))))[0] )){ 
-    // first derivative at the point X0 is defined and different to Inf
+      // first derivative at the point X0 is defined and different to Inf
       (*res)[0]=-0.5;
       (*U)[0] = ( 3. / ((*Xpos)[1]-(*Xpos)[0])) * (((*Ypos)[1]-(*Ypos)[0]) / 
-                ((*Xpos)[1]-(*Xpos)[0]) - (*YP0)[0] );
+						   ((*Xpos)[1]-(*Xpos)[0]) - (*YP0)[0] );
 
     }else{ 
       // YP0 is omitted or equal to Inf
@@ -613,7 +614,7 @@
     DDoubleGDL* YPN;
 
     if(YderivN !=NULL && !isinf((*(YPN=e->GetKWAs<DDoubleGDL>(e->KeywordIx("YPN_1"))))[0] )){ 
-    // first derivative at the point XN-1 is defined and different to Inf 
+      // first derivative at the point XN-1 is defined and different to Inf 
       (*res)[nElpXpos-1] =0.;
       qn=0.5;
 
@@ -621,7 +622,7 @@
       (*U)[nElpXpos-1]= (3./dx)*((*YPN)[0]-((*Ypos)[nElpXpos-1]-(*Ypos)[nElpXpos-2])/dx);
 
     }else{
-    // YPN_1 is omitted or equal to Inf
+      // YPN_1 is omitted or equal to Inf
       qn=0.;
       (*U)[nElpXpos-1]=0.;
     } 
@@ -629,7 +630,7 @@
     (*res)[nElpXpos-1] =((*U)[nElpXpos-1]-qn*(*U)[nElpXpos-2])/(qn*(*res)[nElpXpos-2]+ 1.);
 
     for (count = nElpXpos-2; count != -1; --count){
-       (*res)[count] =(*res)[count]*(*res)[count+1]+(*U)[count];
+      (*res)[count] =(*res)[count]*(*res)[count+1]+(*U)[count];
     }
       
     GM_CV0();
@@ -735,5 +736,64 @@
     return NULL;
   }
 
+  BaseGDL* matrix_multiply( EnvT* e)
+  {
+    BaseGDL* a = e->GetParDefined(0);
+    BaseGDL* b = e->GetParDefined(1);
+
+    DType aTy = a->Type();
+    if (!NumericType(aTy))
+      e->Throw("Array type cannot be " + a->TypeStr() + " here: " + e->GetParString(0));
+    DType bTy = b->Type();
+    if (!NumericType(bTy))
+      e->Throw("Array type cannot be " + b->TypeStr() + " here: " + e->GetParString(1));
+
+    static int atIx = e->KeywordIx("ATRANSPOSE");
+    static int btIx = e->KeywordIx("BTRANSPOSE");
+    bool at = e->KeywordSet(atIx);
+    bool bt = e->KeywordSet(btIx);
+
+    if (a->Rank() > 2)
+      {
+	e->Throw("Array must have 1 or 2 dimensions: " + e->GetParString(0));
+      }
+    if (b->Rank() > 2)
+      {
+	e->Throw("Array must have 1 or 2 dimensions: " + e->GetParString(1));
+      }
+
+    // code from ProgNode::AdjustTypes()
+    Guard<BaseGDL> aGuard;
+    Guard<BaseGDL> bGuard;
+
+    // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
+    DType cxTy = PromoteComplexOperand( aTy, bTy);
+    if( cxTy != GDL_UNDEF)
+    {
+      a = a->Convert2( cxTy, BaseGDL::COPY);
+      aGuard.Init( a);
+      b = b->Convert2( cxTy, BaseGDL::COPY);
+      bGuard.Init( b);
+    }
+    else
+    {
+      DType cTy = PromoteMatrixOperands( aTy, bTy);
+
+      if( aTy != cTy)
+	{
+	  a = a->Convert2( cTy, BaseGDL::COPY);
+	  aGuard.Init( a);
+	}
+      if( bTy != cTy)
+	{
+	  b = b->Convert2( cTy, BaseGDL::COPY);
+	  bGuard.Init( b);
+	}
+    }
+    
+    // might use eigen3
+    return a->MatrixOp( b, at, bt);
+  }
+  
 } // namespace
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/math_fun_ac.hpp gdl/src/math_fun_ac.hpp
--- gdl-0.9.3/src/math_fun_ac.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/math_fun_ac.hpp	2013-05-16 12:36:33.329857509 -0600
@@ -18,6 +18,11 @@
 #include "datatypes.hpp"
 #include "envt.hpp"
 
+#if defined(USE_EIGEN)
+#include <Eigen/Dense>
+//using namespace Eigen; // never in header files!
+#endif
+
 namespace lib {
 
   BaseGDL* beseli_fun( EnvT* e);
@@ -31,6 +36,7 @@
   BaseGDL* sobel_fun( EnvT* e);
   BaseGDL* roberts_fun( EnvT* e);
   BaseGDL* prewitt_fun( EnvT* e);
+  BaseGDL* matrix_multiply( EnvT* e);
 
 } // namespace
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/math_fun.cpp gdl/src/math_fun.cpp
--- gdl-0.9.3/src/math_fun.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/math_fun.cpp	2013-03-25 10:36:38.484969266 -0600
@@ -223,16 +223,26 @@
     T* p0C = static_cast<T*>( p0);
     T* res = new T( p0C->Dim(), BaseGDL::NOZERO);
     SizeT nEl = p0->N_Elements();
+// eigen is not faster here
+// #ifdef USE_EIGEN
+// 
+//   Eigen::Map<Eigen::Array<typename T::Ty,Eigen::Dynamic,1> ,Eigen::Aligned> m1(&(*p0C)[0], nEl);
+//   Eigen::Map<Eigen::Array<typename T::Ty,Eigen::Dynamic,1> ,Eigen::Aligned> m2(&(*res)[0], nEl);
+//   m2 = m1.sin();
+//   return res;
+// #else
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	{
 	  (*res)[ i] = sin((*p0C)[ i]); 
 	}
     }
     return res;
+// #endif
+    
   }
 
   BaseGDL* sin_fun( BaseGDL* p0, bool isReference)
@@ -265,7 +275,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[ i] = sin((*res)[ i]); 
 	    }
@@ -284,7 +294,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	{
 	  (*res)[ i] = cos((*p0C)[ i]); 
 	}
@@ -326,7 +336,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[ i] = cos((*res)[ i]); 
 	    }
@@ -345,7 +355,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	{
 	  (*res)[ i] = tan((*p0C)[ i]); 
 	}
@@ -364,7 +374,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	{
 	  (*res)[ i] = tan(static_cast<DComplexDbl>((*p0C)[ i]));
 	}
@@ -406,7 +416,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[ i] = tan((*res)[ i]); 
 	    }
@@ -425,7 +435,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	{
 	  (*res)[ i] = sinh((*p0C)[ i]); 
 	}
@@ -467,7 +477,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[ i] = sinh((*res)[ i]); 
 	    }
@@ -486,7 +496,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	{
 	  (*res)[ i] = cosh((*p0C)[ i]); 
 	}
@@ -528,7 +538,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[ i] = cosh((*res)[ i]); 
 	    }
@@ -547,7 +557,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	{
 	  (*res)[ i] = tanh((*p0C)[ i]); 
 	}
@@ -589,7 +599,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[ i] = tanh((*res)[ i]); 
 	    }
@@ -623,7 +633,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[ i] = asin((*p0D)[ i]); 
 	    }
@@ -638,7 +648,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[ i] = asin((*p0F)[ i]); 
 	    }
@@ -653,7 +663,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[ i] = asin((*res)[ i]); 
 	    }
@@ -687,7 +697,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[ i] = acos((*p0D)[ i]); 
 	    }
@@ -702,7 +712,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[ i] = acos((*p0F)[ i]); 
 	    }
@@ -716,7 +726,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[ i] = acos((*res)[ i]); 
 	    }
@@ -741,8 +751,9 @@
   inline C atanC(const C& c1, const C& c2)
   {
     const C i(0.0,1.0);
-    const C one(1.0,0.0);
-    return -i * log((c2 + i * c1) / sqrt(pow(c2, 2) + pow(c1, 2)));
+    //const C one(1.0,0.0);
+//     return -i * log((c2 + i * c1) / (sqrt(pow(c2, 2) + pow(c1, 2))));
+    return -i * log((c2 + i * c1) / sqrt((c2 * c2) + (c1 * c1)));
   }
 
   BaseGDL* atan_fun( EnvT* e)
@@ -784,13 +795,13 @@
 
 	if( t == GDL_COMPLEX)
 	  {
-	    auto_ptr< DComplexGDL> guard0;
-	    auto_ptr< DComplexGDL> guard1;
+	    Guard< DComplexGDL> guard0;
+	    Guard< DComplexGDL> guard1;
 
 	    DComplexGDL* p0F = static_cast<DComplexGDL*>(p0->Convert2( GDL_COMPLEX, BaseGDL::COPY));
-	    guard0.reset( p0F);
+	    guard0.Init( p0F);
 	    DComplexGDL* p1F = static_cast<DComplexGDL*>(p1->Convert2( GDL_COMPLEX, BaseGDL::COPY));
-	    guard1.reset( p1F);
+	    guard1.Init( p1F);
 	      
 	    DComplexGDL* res = new DComplexGDL( dim, BaseGDL::NOZERO);
 	    for (i = 0; i < nElMin; ++i) (*res)[i] = atanC((*p0F)[*i0], (*p1F)[*i1]); 
@@ -798,13 +809,13 @@
 	  }
 	else if( t == GDL_COMPLEXDBL)
 	  {
-	    auto_ptr< DComplexDblGDL> guard0;
-	    auto_ptr< DComplexDblGDL> guard1;
+	    Guard< DComplexDblGDL> guard0;
+	    Guard< DComplexDblGDL> guard1;
 
 	    DComplexDblGDL* p0F = static_cast<DComplexDblGDL*>(p0->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY));
-	    guard0.reset( p0F);
+	    guard0.Init( p0F);
 	    DComplexDblGDL* p1F = static_cast<DComplexDblGDL*>(p1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY));
-	    guard1.reset( p1F);
+	    guard1.Init( p1F);
 	      
 	    DComplexDblGDL* res = new DComplexDblGDL( dim, BaseGDL::NOZERO);
 	    for (i = 0; i < nElMin; ++i) (*res)[i] = atanC((*p0F)[*i0], (*p1F)[*i1]); 
@@ -812,13 +823,13 @@
 	  }
 	else if( t == GDL_DOUBLE)
 	  {
-	    auto_ptr< DDoubleGDL> guard;
+	    Guard< DDoubleGDL> guard;
 	    
 	    DDoubleGDL* p0D;
 	    if( p0->Type() != GDL_DOUBLE)
 	      {
 		p0D =  static_cast<DDoubleGDL*>( p0->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-		guard.reset( p0D);
+		guard.Reset( p0D);
 	      }
 	    else
 	      {
@@ -829,7 +840,7 @@
 	    if( p1->Type() != GDL_DOUBLE)
 	      {
 		p1D =  static_cast<DDoubleGDL*>( p1->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-		guard.reset( p1D);
+		guard.Reset( p1D);
 	      }
 	    else
 	      {
@@ -842,13 +853,13 @@
 	  }
 	else if( t == GDL_FLOAT)
 	  {
-	    auto_ptr< DFloatGDL> guard;
+	    Guard< DFloatGDL> guard;
 	    
 	    DFloatGDL* p0F;
 	    if( p0->Type() != GDL_FLOAT)
 	      {
 		p0F =  static_cast<DFloatGDL*>( p0->Convert2( GDL_FLOAT, BaseGDL::COPY));
-		guard.reset( p0F);
+		guard.Reset( p0F);
 	      }
 	    else
 	      {
@@ -859,7 +870,7 @@
 	    if( p1->Type() != GDL_FLOAT)
 	      {
 		p1F =  static_cast<DFloatGDL*>( p1->Convert2( GDL_FLOAT, BaseGDL::COPY));
-		guard.reset( p1F);
+		guard.Reset( p1F);
 	      }
 	    else
 	      {
@@ -873,13 +884,13 @@
 	  }
 	else 
 	  {
-	    auto_ptr< DFloatGDL> guard0;
-	    auto_ptr< DFloatGDL> guard1;
+	    Guard< DFloatGDL> guard0;
+	    Guard< DFloatGDL> guard1;
 
 	    DFloatGDL* p0F = static_cast<DFloatGDL*>(p0->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	    guard0.reset( p0F);
+	    guard0.Init( p0F);
 	    DFloatGDL* p1F = static_cast<DFloatGDL*>(p1->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	    guard1.reset( p1F);
+	    guard1.Init( p1F);
 	      
 	    DFloatGDL* res = new DFloatGDL( dim, BaseGDL::NOZERO);
 	    for (i = 0; i < nElMin; ++i) 
@@ -901,7 +912,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		{
 		  DComplex& C = (*p0C)[ i];
 		  (*res)[ i] = (float)atan2((double)C.imag(), (double)C.real());
@@ -917,7 +928,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i) (
+	      for( OMPInt i=0; i<nEl; ++i) (
 			*res)[ i] = atanC((*p0C)[ i]);
 	    }
 	    return res;
@@ -930,7 +941,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	       for( int i=0; i<nEl; ++i)
+	       for( OMPInt i=0; i<nEl; ++i)
 	      	      {
 	      		DComplexDbl& C = (*p0C)[ i];
 	      		(*res)[ i] = atan2( C.imag(), C.real());
@@ -946,7 +957,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 			(*res)[ i] = atanC((*p0C)[ i]);
 	    }
 	    return res;
@@ -959,7 +970,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		{
 		  (*res)[ i] = atan((*p0D)[ i]); 
 		}
@@ -974,7 +985,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		{
 		  (*res)[ i] = atan((*p0F)[ i]); 
 		}
@@ -989,7 +1000,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	    {
 #pragma omp for
-	      for( int i=0; i<nEl; ++i)
+	      for( OMPInt i=0; i<nEl; ++i)
 		{
 		  (*res)[ i] = atan((*res)[ i]); 
 		}
@@ -1078,16 +1089,26 @@
     T* p0C = static_cast<T*>( p0);
     T* res = new T( p0C->Dim(), BaseGDL::NOZERO);
     SizeT nEl = p0->N_Elements();
+#ifdef USE_EIGEN
+
+  Eigen::Map<Eigen::Array<typename T::Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mP0C(&(*p0C)[0], nEl);
+  Eigen::Map<Eigen::Array<typename T::Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mRes(&(*res)[0], nEl);
+  mRes = mP0C.sqrt();
+  return res;
+#else
+
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma intel omp forthis
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	{
 	  (*res)[ i] = sqrt((*p0C)[ i]); 
 	}
     }
     return res;
+#endif
+    
   }
 
   template< typename T>
@@ -1095,16 +1116,23 @@
   {
     T* p0C = static_cast<T*>( p0);
     SizeT nEl = p0->N_Elements();
+#ifdef USE_EIGEN
+
+  Eigen::Map<Eigen::Array<typename T::Ty,Eigen::Dynamic,1> ,Eigen::Aligned> mP0C(&(*p0C)[0], nEl);
+  mP0C = mP0C.sqrt();
+  return p0C;
+#else
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	{
 	  (*p0C)[ i] = sqrt((*p0C)[ i]); 
 	}
     }
     return p0C;
+#endif
   }
 
   BaseGDL* sqrt_fun( BaseGDL* p0, bool isReference)//( EnvT* e)
@@ -1112,46 +1140,53 @@
     assert( p0 != NULL);
     assert( p0->N_Elements() > 0);
     
+    DType p0Type = p0->Type();  
     if( isReference)
     {
-    if( p0->Type() == GDL_COMPLEX)
+    if( p0Type == GDL_COMPLEX)
       return sqrt_fun_template< DComplexGDL>( p0);
-    else if( p0->Type() == GDL_COMPLEXDBL)
+    else if( p0Type == GDL_COMPLEXDBL)
       return sqrt_fun_template< DComplexDblGDL>( p0);
-    else if( p0->Type() == GDL_DOUBLE)
+    else if( p0Type == GDL_DOUBLE)
       return sqrt_fun_template< DDoubleGDL>( p0);
-    else if( p0->Type() == GDL_FLOAT)
+    else if( p0Type == GDL_FLOAT)
       return sqrt_fun_template< DFloatGDL>( p0);
     }
     else
     {
-    if( p0->Type() == GDL_COMPLEX)
+    if( p0Type == GDL_COMPLEX)
       return sqrt_fun_template_grab< DComplexGDL>( p0);
-    else if( p0->Type() == GDL_COMPLEXDBL)
+    else if( p0Type == GDL_COMPLEXDBL)
       return sqrt_fun_template_grab< DComplexDblGDL>( p0);
-    else if( p0->Type() == GDL_DOUBLE)
+    else if( p0Type == GDL_DOUBLE)
       return sqrt_fun_template_grab< DDoubleGDL>( p0);
-    else if( p0->Type() == GDL_FLOAT)
+    else if( p0Type == GDL_FLOAT)
       return sqrt_fun_template_grab< DFloatGDL>( p0);
     } 
-      {
-	DFloatGDL* res = static_cast<DFloatGDL*>
-	  (p0->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	SizeT nEl = p0->N_Elements();
+    {
+      DFloatGDL* res = static_cast<DFloatGDL*>
+	(p0->Convert2( GDL_FLOAT, BaseGDL::COPY));
+      SizeT nEl = p0->N_Elements();
+#ifdef USE_EIGEN
+
+      Eigen::Map<Eigen::Array<DFloat,Eigen::Dynamic,1> ,Eigen::Aligned> mRes(&(*res)[0], nEl);
+      mRes = mRes.sqrt();
+      return res;
+#else
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
-	{
+      {
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
-	    {
-	      (*res)[ i] = sqrt( (*res)[ i]); 
-	    }
-	}
-	return res;
+	for( OMPInt i=0; i<nEl; ++i)
+	  {
+	    (*res)[ i] = sqrt( (*res)[ i]); 
+	  }
       }
+      return res;
+#endif  
+    }
   }
 
-
   template< typename T>
   BaseGDL* abs_fun_template( BaseGDL* p0)
   {
@@ -1162,7 +1197,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	{
 	  (*res)[ i] = abs((*p0C)[ i]); 
 	}
@@ -1191,7 +1226,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      // 	    DComplex& C = (*p0C)[ i];
 	      // 	    float Creal = C.real(), Cimag = C.imag();
@@ -1210,7 +1245,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      // 	    DComplexDbl& C = (*p0C)[ i];
 	      // 	    double Creal = C.real(), Cimag = C.imag();
@@ -1259,7 +1294,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
     {
 #pragma omp for
-      for( int i=0; i<nEl; ++i)
+      for( OMPInt i=0; i<nEl; ++i)
 	{
 	  (*res)[ i] = abs( (*res)[ i]); 
 	}
@@ -1281,7 +1316,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
       {
 #pragma omp for
-	for( int i=0; i<nEl; ++i)
+	for( OMPInt i=0; i<nEl; ++i)
 	  {
 	    (*res)[ i] = static_cast<DLong64>( round((*p0C)[ i])); 
 	  }
@@ -1293,7 +1328,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
       {
 #pragma omp for
-	for( int i=0; i<nEl; ++i)
+	for( OMPInt i=0; i<nEl; ++i)
 	  {
 	    (*res)[ i] = static_cast<DLong>( round((*p0C)[ i])); 
 	  }
@@ -1328,7 +1363,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	  {
 #pragma omp for
-	    for( int i=0; i<nEl; ++i)
+	    for( OMPInt i=0; i<nEl; ++i)
 	      {
 		DComplex& C = (*p0C)[ i];
 		(*res)[ i] = (DLong64) round(C.real());
@@ -1341,7 +1376,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	  {
 #pragma omp for
-	    for( int i=0; i<nEl; ++i)
+	    for( OMPInt i=0; i<nEl; ++i)
 	      {
 		DComplex& C = (*p0C)[ i];
 		(*res)[ i] = (int) round(C.real());
@@ -1362,7 +1397,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	  {
 #pragma omp for
-	    for( int i=0; i<nEl; ++i)
+	    for( OMPInt i=0; i<nEl; ++i)
 	      {
 		DComplexDbl& C = (*p0C)[ i];
 		(*res)[ i] = (DLong64) round(C.real());
@@ -1375,7 +1410,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	  {
 #pragma omp for
-	    for( int i=0; i<nEl; ++i)
+	    for( OMPInt i=0; i<nEl; ++i)
 	      {
 		DComplexDbl& C = (*p0C)[ i];
 		(*res)[ i] = (int) round(C.real());
@@ -1411,7 +1446,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[ i] = (int) round((double) (*p0F)[ i]); 
 	    }
@@ -1433,7 +1468,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
       {
 #pragma omp for
-	for( int i=0; i<nEl; ++i)
+	for( OMPInt i=0; i<nEl; ++i)
 	  {
 	    (*res)[ i] = (DLong64) ceil((*p0C)[ i]); 
 	  }
@@ -1445,7 +1480,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
       {
 #pragma omp for
-	for( int i=0; i<nEl; ++i)
+	for( OMPInt i=0; i<nEl; ++i)
 	  {
 	    (*res)[ i] = (int) ceil((*p0C)[ i]); 
 	  }
@@ -1479,7 +1514,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	  {
 #pragma omp for
-	    for( int i=0; i<nEl; ++i)
+	    for( OMPInt i=0; i<nEl; ++i)
 	      {
 		DComplex& C = (*p0C)[ i];
 		(*res)[ i] = (DLong64) ceil(C.real());
@@ -1492,7 +1527,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	  {
 #pragma omp for
-	    for( int i=0; i<nEl; ++i)
+	    for( OMPInt i=0; i<nEl; ++i)
 	      {
 		DComplex& C = (*p0C)[ i];
 		(*res)[ i] = (int) ceil(C.real());
@@ -1513,7 +1548,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	  {
 #pragma omp for
-	    for( int i=0; i<nEl; ++i)
+	    for( OMPInt i=0; i<nEl; ++i)
 	      {
 		DComplexDbl& C = (*p0C)[ i];
 		(*res)[ i] = (DLong64) ceil(C.real());
@@ -1526,7 +1561,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	  {
 #pragma omp for
-	    for( int i=0; i<nEl; ++i)
+	    for( OMPInt i=0; i<nEl; ++i)
 	      {
 		DComplexDbl& C = (*p0C)[ i];
 		(*res)[ i] = (int) ceil(C.real());
@@ -1562,7 +1597,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[ i] = (int) ceil((double) (*p0F)[ i]); 
 	    }
@@ -1584,7 +1619,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
       {
 #pragma omp for
-	for( int i=0; i<nEl; ++i)
+	for( OMPInt i=0; i<nEl; ++i)
 	  {
 	    (*res)[ i] = (DLong64) floor((*p0C)[ i]); 
 	  }
@@ -1596,7 +1631,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
       {
 #pragma omp for
-	for( int i=0; i<nEl; ++i)
+	for( OMPInt i=0; i<nEl; ++i)
 	  {
 	    (*res)[ i] = (int) floor((*p0C)[ i]); 
 	  }
@@ -1630,7 +1665,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	  {
 #pragma omp for
-	    for( int i=0; i<nEl; ++i)
+	    for( OMPInt i=0; i<nEl; ++i)
 	      {
 		DComplex& C = (*p0C)[ i];
 		(*res)[ i] = (DLong64) floor(C.real());
@@ -1643,7 +1678,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	  {
 #pragma omp for
-	    for( int i=0; i<nEl; ++i)
+	    for( OMPInt i=0; i<nEl; ++i)
 	      {
 		DComplex& C = (*p0C)[ i];
 		(*res)[ i] = (int) floor(C.real());
@@ -1664,7 +1699,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	  {
 #pragma omp for
-	    for( int i=0; i<nEl; ++i)
+	    for( OMPInt i=0; i<nEl; ++i)
 	      {
 		DComplexDbl& C = (*p0C)[ i];
 		(*res)[ i] = (DLong64) floor(C.real());
@@ -1677,7 +1712,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	  {
 #pragma omp for
-	    for( int i=0; i<nEl; ++i)
+	    for( OMPInt i=0; i<nEl; ++i)
 	      {
 		DComplexDbl& C = (*p0C)[ i];
 		(*res)[ i] = (int) floor(C.real());
@@ -1713,7 +1748,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[ i] = (int) floor((double) (*p0F)[ i]); 
 	    }
@@ -1741,7 +1776,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[i] = DComplex( (*p0C)[i].real(), -(*p0C)[i].imag());
 	    }
@@ -1756,7 +1791,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    {
 	      (*res)[i] = DComplexDbl( (*p0C)[i].real(), -(*p0C)[i].imag());
 	    }
@@ -1855,7 +1890,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    (*res)[ i] = exp( (*c0)[ i]);
 	}
 	return res;
@@ -1868,7 +1903,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    (*res)[ i] = exp( (*c0)[ i]);
 	}
 	return res;
@@ -1881,7 +1916,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    (*res)[ i] = exp( (*c0)[ i]);
 	}
 	return res;
@@ -1894,7 +1929,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    (*res)[ i] = exp( (*c0)[ i]);
 	}
 	return res;
@@ -1914,7 +1949,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i<nEl; ++i)
+	  for( OMPInt i=0; i<nEl; ++i)
 	    (*res)[ i] = exp( (*res)[ i]);
 	}	
 	return res;
@@ -2017,7 +2052,7 @@
       e->Throw("Argument N must be greater than or equal to zero.");
     
     DDoubleGDL* kval;
-    auto_ptr<DDoubleGDL> kval_guard;
+    Guard<DDoubleGDL> kval_guard;
     if (nParam>2) {
       kval = e->GetParAs<DDoubleGDL>(2);
       if(kval->N_Elements() != 1)
@@ -2026,14 +2061,14 @@
         e->Throw("Argument K must be greater than or equal to zero.");
     } else {
       kval = new DDoubleGDL(0);
-      kval_guard.reset(kval);
+      kval_guard.Reset(kval);
     }
 
     DDoubleGDL* res = new DDoubleGDL(xvals->Dim(),BaseGDL::NOZERO);
     DDouble k = (*kval)[0];
     DInt n = (*nval)[0];
     SizeT nEx = xvals->N_Elements();
-    int count;
+    OMPInt count;
     
 TRACEOMP( __FILE__, __LINE__)
 #pragma omp parallel if (nEx >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEx))
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/math_fun_gm.cpp gdl/src/math_fun_gm.cpp
--- gdl-0.9.3/src/math_fun_gm.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/math_fun_gm.cpp	2013-05-16 12:36:33.335857488 -0600
@@ -194,10 +194,11 @@
 #define isfinite _finite
 #endif
 
-using namespace std;
-
 namespace lib
 {
+using namespace std;
+using std::isnan;
+
   double gm_expint(int n, double x);
   double gm_lentz(double a[], double b[], double tiny, int n, double eps);
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/math_fun_jmg.cpp gdl/src/math_fun_jmg.cpp
--- gdl-0.9.3/src/math_fun_jmg.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/math_fun_jmg.cpp	2013-05-16 12:36:33.348857441 -0600
@@ -48,10 +48,12 @@
 #define signbit(d) (d < 0.0)? 1:0
 #endif
 
-using namespace std;
-
 namespace lib {
 
+  using namespace std;
+  using std::isinf;
+  using std::isnan;
+
   BaseGDL* machar_fun( EnvT* e)
   {
     long int ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, maxexp;
@@ -309,7 +311,7 @@
      e->NParam( 1);
 
      BaseGDL* p0     = e->GetParDefined( 0);
-     auto_ptr<BaseGDL> guard;
+     Guard<BaseGDL> guard;
 
      static int nanIx = e->KeywordIx( "NAN");
      bool kwNaN      = e->KeywordSet( nanIx);
@@ -348,7 +350,7 @@
 	     {
 	       DFloatGDL* p0F = 
 		 static_cast<DFloatGDL*>(p0->Convert2(GDL_FLOAT,BaseGDL::COPY));
-	       guard.reset( p0F);
+	       guard.Reset( p0F);
 	       return finite_template<DFloatGDL, false>(p0F, kwNaN, kwInfinity);
 	     }
 	   case GDL_STRUCT:
@@ -396,7 +398,7 @@
 	     {
 	       DFloatGDL* p0F = 
 		 static_cast<DFloatGDL*>(p0->Convert2(GDL_FLOAT,BaseGDL::COPY));
-	       guard.reset( p0F);
+	       guard.Reset( p0F);
 	       return finite_template<DFloatGDL, false>(p0F, kwNaN, kwInfinity, kwSign);
 	     }
 	   case GDL_STRUCT:
@@ -733,7 +735,45 @@
     }
   }
 
+// see http://www.geom.umn.edu/software/qhull/. Used also with plplot.
+#ifdef PL_HAVE_QHULL
+  void triangulate ( EnvT* e)
+  {
+    DDoubleGDL *yVal, *xVal;
+    int npts;
+    SizeT nParam=e->NParam();
+    if( nParam < 3)
+    {
+      e->Throw("Incorrect number of arguments.");
+    }
+    yVal = e->GetParAs< DDoubleGDL > (0);
+    if (yVal->Rank() == 0) e->Throw("Expression must be an array in this context: " + e->GetParString(0));
+    npts=yVal->N_Elements();
+    xVal = e->GetParAs< DDoubleGDL > (1);
+    if (xVal->Rank() == 0) e->Throw("Expression must be an array in this context: " + e->GetParString(1));
+    if (xVal->N_Elements()!=npts) e->Throw("X & Y arrays must have same number of points.");
+    e->Throw("Writing in progress.");
+  }
+  void qhull ( EnvT* e)
+  {
+    e->Throw("Writing in progress.");
+  }
+
+  void grid_input (EnvT* e)
+  {
+    e->Throw("Writing in progress.");
+  }
 
+  BaseGDL* qgrid3_fun ( EnvT* e)
+  {
+    e->Throw("Writing in progress.");
+  }
+  BaseGDL* sph_scat_fun ( EnvT* e)
+  {
+    e->Throw("Writing in progress.");
+  }
+
+#endif
   BaseGDL* trigrid_fun( EnvT* e)
   {
     //   Compute plane parameters A,B,C given 3 points on plane.
@@ -893,10 +933,10 @@
 	if(Map->N_Elements() != 4)
 	  e->Throw("Keyword array parameter MAP"
 		   "must have 4 elements.");
-	auto_ptr<DDoubleGDL> guard;
+	Guard<DDoubleGDL> guard;
 	DDoubleGDL* mapD = static_cast<DDoubleGDL*>
 	  ( Map->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-	guard.reset( mapD);
+	guard.Reset( mapD);
 	xvsx[0] = (*mapD)[0];
 	xvsx[1] = (*mapD)[1];
 	yvsy[0] = (*mapD)[2];
@@ -1911,7 +1951,7 @@
     treeParser.interactive(theAST);
     trAST = treeParser.getAST();
     ProgNodeP progAST = ProgNode::NewProgNode( trAST);
-    auto_ptr< ProgNode> progAST_guard( progAST);
+    Guard< ProgNode> progAST_guard( progAST);
 
 	// Marc: necessary for correct FOR loop handling
 	assert( dynamic_cast<EnvUDT*>(caller) != NULL);
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/math_fun_jmg.hpp gdl/src/math_fun_jmg.hpp
--- gdl-0.9.3/src/math_fun_jmg.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/math_fun_jmg.hpp	2013-03-21 14:04:04.372825200 -0600
@@ -56,6 +56,13 @@
   BaseGDL* finite_fun( EnvT* e);
   BaseGDL* check_math_fun( EnvT* e);
   BaseGDL* radon_fun( EnvT* e);
+#ifdef PL_HAVE_QHULL
+  void     triangulate( EnvT* e);
+  void qhull ( EnvT* e);
+  void grid_input (EnvT* e);
+  BaseGDL* qgrid3_fun ( EnvT* e);
+  BaseGDL* sph_scat_fun ( EnvT* e);
+#endif
   BaseGDL* trigrid_fun( EnvT* e);
   BaseGDL* poly_2d_fun( EnvT* e);
   BaseGDL* rk4jmg_fun( EnvT* e);
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/math_utl.hpp gdl/src/math_utl.hpp
--- gdl-0.9.3/src/math_utl.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/math_utl.hpp	2013-03-21 14:04:04.378825172 -0600
@@ -73,6 +73,12 @@
 #define COMPLEX2 GDL_COMPLEX
 #endif
 
+#ifdef _MSC_VER
+#  define isinf !_finite
+#  define isfinite _finite
+#  define isnan _isnan
+#endif
+
 } // namespace
 
 #endif
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/ncdf_att_cl.cpp gdl/src/ncdf_att_cl.cpp
--- gdl-0.9.3/src/ncdf_att_cl.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/ncdf_att_cl.cpp	2013-05-16 12:36:33.354857420 -0600
@@ -32,7 +32,7 @@
 #  include <gsl/gsl_sys.h>
 #  include <gsl/gsl_linalg.h>
 #  include <gsl/gsl_sf.h>
-#  include <netcdfcpp.h>
+#  include <netcdf.h>
 
 #  include "datatypes.hpp"
 #  include "math_utl.hpp"
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/ncdf_cl.cpp gdl/src/ncdf_cl.cpp
--- gdl-0.9.3/src/ncdf_cl.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/ncdf_cl.cpp	2013-03-25 10:36:38.505969168 -0600
@@ -151,7 +151,7 @@
 		{
 			BaseGDL* v=e->GetParDefined(2);
 			DIntGDL* dim_in=static_cast<DIntGDL*>(v->Convert2(GDL_INT, BaseGDL::COPY));
-			auto_ptr<DIntGDL> dim_in_guard( dim_in);
+			Guard<DIntGDL> dim_in_guard( dim_in);
 			int var_ndims=dim_in->N_Elements();
 			if(var_ndims > NC_MAX_VAR_DIMS)
                           e->Throw("NCDF internal error in error handler (too many dimension IDs).");
@@ -260,17 +260,8 @@
 	else 
 	  {
 	  /*unknown error*/
-	    int mema=3;
-	    char *n=new char(mema);
-	    while (snprintf(n, sizeof n, "%d", status) >= sizeof n)
-	      {			delete n;mema++; n=new char(mema);   }
-
 	    error+=nc_strerror(status);
-	    error+=" (NC_ERROR=";
-	    error+=n;
-	    delete n;
-	    error+=")";
-	    
+	    error+=" (NC_ERROR="+i2s(status)+")";
 	  }
 
 	e->Throw(error);
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/ncdf_cl.hpp gdl/src/ncdf_cl.hpp
--- gdl-0.9.3/src/ncdf_cl.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/ncdf_cl.hpp	2013-05-16 12:36:33.356857412 -0600
@@ -18,7 +18,7 @@
 #ifndef NCDF_HPP_CL_
 #define NCDF_HPP_CL_
 
-#include <netcdfcpp.h>
+#include <netcdf.h>
 #include <string>
 
 namespace lib {
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/ncdf_dim_cl.cpp gdl/src/ncdf_dim_cl.cpp
--- gdl-0.9.3/src/ncdf_dim_cl.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/ncdf_dim_cl.cpp	2013-05-16 12:36:33.357857409 -0600
@@ -30,7 +30,7 @@
 #include <gsl/gsl_sys.h>
 #include <gsl/gsl_linalg.h>
 #include <gsl/gsl_sf.h>
-#include <netcdfcpp.h>
+#include <netcdf.h>
 
 #include "datatypes.hpp"
 #include "math_utl.hpp"
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/ncdf_var_cl.cpp gdl/src/ncdf_var_cl.cpp
--- gdl-0.9.3/src/ncdf_var_cl.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/ncdf_var_cl.cpp	2013-05-16 12:36:33.359857402 -0600
@@ -31,7 +31,7 @@
 #include <gsl/gsl_sys.h>
 #include <gsl/gsl_linalg.h>
 #include <gsl/gsl_sf.h>
-#include <netcdfcpp.h>
+#include <netcdf.h>
 
 #include "datatypes.hpp"
 #include "math_utl.hpp"
@@ -57,27 +57,10 @@
   
   void exceed_message(const char * name,int index, int set)
   {
-    int mema=3;
     string mess;
     mess=name;
-    mess+="Limit exceeded on index ";
-    char * n=new char(mema);
-    while (snprintf(n, sizeof n, "%d", index) >= sizeof n)
-      {   delete n; mema++; n=new char(mema);
-      }
-    mess+=n;
-    delete n;
-    
-    mess+=", setting to ";
-    mema=3;
-    n=new char(mema);
-    while (snprintf(n, sizeof n, "%d", set) >= sizeof n)
-      {
-	delete n;mema++; n=new char(mema);
-      }
-    mess+=n;
-    delete n;
-    mess+=".";
+    mess+="Limit exceeded on index "+i2s(index);
+    mess+=", setting to "+i2s(set)+".";
     Message(mess);
 
   }
@@ -87,28 +70,14 @@
     int mema=3;
     string mess;
     mess=name;
-    mess+="Value of index";
-    char * n=new char(mema);
-    while (snprintf(n, sizeof n, "%d", index) >= sizeof n)
-      {   delete n; mema++; n=new char(mema);
-      }
-    mess+=n;
-    delete n;
+    mess+="Value of index "+i2s(index);
     if(set > 0) 
       mess+=" is negative or zero, setting to ";
     else if(set == 0) 
       mess+=" is negative , setting to ";
     else
       mess+=" INTERNAL ERROR NCDF_VAR_CL.CPP negzero_message";
-    
-    mema=3;
-    n=new char(mema);
-    while (snprintf(n, sizeof n, "%d", set) >= sizeof n)
-      {
-	delete n;mema++; n=new char(mema);
-      }
-    mess+=n;
-    delete n;
+    mess+=i2s(set);
     mess+=".";
     Message(mess);
 
@@ -660,22 +629,9 @@
               int mema=3;
               string mess;
               mess = "NCDF_VARGET: Requested read is larget than data in dimension ";
-              char * n=new char(mema);
-              while (snprintf(n, sizeof n, "%d", i) >= sizeof n)
-              {
-                delete n; mema++; n=new char(mema);
-              }
-              mess+=n;
-              delete n;
+              mess+=i2s(i);
               mess+=". Reducing COUNT to ";
-              mema=3;
-              n=new char[3];
-              while (snprintf(n, sizeof n, "%d",  cou[trans[i]]) >= sizeof n)
-              { 
-                delete n; mema++; n=new char(mema);
-              }
-              mess+=n;
-              delete n;
+              mess+=i2s(cou[trans[i]]);
               mess+=".";
               Message(mess);
             }	
@@ -764,7 +720,7 @@
       {
 	v=e->GetParDefined(2);
 	DIntGDL* dim_in=static_cast<DIntGDL*>(v->Convert2(GDL_INT, BaseGDL::COPY));
-	auto_ptr<DIntGDL> dim_in_guard( dim_in);
+	Guard<DIntGDL> dim_in_guard( dim_in);
 	var_ndims=dim_in->N_Elements();
 	if(var_ndims > NC_MAX_VAR_DIMS)
 	  {
@@ -962,7 +918,7 @@
       }
     }
 
-    int total = 1;
+    long total = 1;
 	  
     if (e->GetKW(0) != NULL)
     {
@@ -1042,7 +998,7 @@
       case GDL_ULONG64 :
       {
         BaseGDL* val;
-        auto_ptr<BaseGDL> val_guard(val);
+        Guard<BaseGDL> val_guard(val);
         switch (var_type) 
         {
           case NC_BYTE :   // 8-bit signed integer
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/new.cpp gdl/src/new.cpp
--- gdl-0.9.3/src/new.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/new.cpp	2013-02-25 17:04:25.159178808 -0700
@@ -22,7 +22,7 @@
 
 #include "datatypes.hpp"
 #include "envt.hpp"
+#include "dinterpreter.hpp"
 
 namespace lib {
 }
-
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/newprognode.cpp gdl/src/newprognode.cpp
--- gdl-0.9.3/src/newprognode.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/newprognode.cpp	2013-03-25 10:36:38.521969094 -0600
@@ -359,7 +359,7 @@
 	{
 	  if( !newNode->ConstantExpr()) return newNode;
 
-	  auto_ptr<ProgNode> guard( newNode);
+	  Guard<ProgNode> guard( newNode);
 
 	  BaseGDL* cData = newNode->Eval();
 
@@ -373,7 +373,7 @@
 	{
 	  if( !newUnary->ConstantExpr()) return newUnary;
 
-	  auto_ptr<ProgNode> guard( newUnary);
+	  Guard<ProgNode> guard( newUnary);
 
 	  BaseGDL* cData = newUnary->Eval();
 
@@ -540,7 +540,7 @@
 	{
 	  if( !newNode->ConstantExpr()) return newNode;
 
-	  auto_ptr<ProgNode> guard( newNode);
+	  Guard<ProgNode> guard( newNode);
 
 	  BaseGDL* cData = newNode->Eval();
 
@@ -554,7 +554,7 @@
 	{
 	  if( !newUnary->ConstantExpr()) return newUnary;
 
-	  auto_ptr<ProgNode> guard( newUnary);
+	  Guard<ProgNode> guard( newUnary);
 
 	  BaseGDL* cData = newUnary->Eval();
 
@@ -576,7 +576,7 @@
 	if( !static_cast<DLibFunRetNew*>(c->libFun)->RetConstant()
 	    || !ConstantPar( c->getFirstChild())) return c;
 
-	auto_ptr< ProgNode> guard( c);
+	Guard< ProgNode> guard( c);
 
 	BaseGDL* cData = c->Eval();
 
@@ -593,7 +593,7 @@
 	if( !static_cast<DLibFunDirect*>(c->libFun)->RetConstant()
 	    || !ConstantPar( c->getFirstChild())) return c;
 
-	auto_ptr< ProgNode> guard( c);
+	Guard< ProgNode> guard( c);
 
 	BaseGDL* cData = c->Eval();
 
@@ -610,7 +610,7 @@
 	if( !static_cast<DLibFunRetNew*>(c->libFun)->RetConstant()
 	    || !ConstantPar( c->getFirstChild())) return c;
 
-	auto_ptr< ProgNode> guard( c);
+	Guard< ProgNode> guard( c);
 
 	BaseGDL* cData = c->Eval();
 
@@ -698,7 +698,7 @@
 	ARRAYDEFNode* c = new ARRAYDEFNode( refNode);
 	if( !c->ConstantArray()) return c;
 
-	auto_ptr< ARRAYDEFNode> guard( c);
+	Guard< ARRAYDEFNode> guard( c);
 
 	BaseGDL* cData = c->Eval();
 
@@ -723,7 +723,7 @@
 //   cout << endl;
 	assert( c->ConstantArray());
 
-	auto_ptr< ProgNode> guard( c);
+	Guard< ProgNode> guard( c);
 
 	BaseGDL* cData = c->Eval();
 
@@ -741,7 +741,7 @@
 // 	refNode->setNextSibling(antlr::nullAST);
 
 // 	ProgNodeP c = new ARRAYDEFNode( refNode);
-// 	auto_ptr< ProgNode> guard( c);
+// 	Guard< ProgNode> guard( c);
 // 	//c->setType(  GDLTokenTypes::ARRAYDEF);
 
 // 	// evaluate constant
@@ -963,7 +963,7 @@
 	new ParameterNode( refNode);//->GetFirstChild());
       return firstChild;
 
-// 		  auto_ptr<ProgNode> guard(nn);
+// 		  Guard<ProgNode> guard(nn);
 // 		  return nn->StealFirstChild();
     }
     case GDLTokenTypes::REF_EXPR_VN:
@@ -978,7 +978,7 @@
 	new ParameterNode( refNode);//->GetFirstChild());
       return firstChild;
 
-// 		  auto_ptr<ProgNode> guard(nn);
+// 		  Guard<ProgNode> guard(nn);
 // 		  return nn->StealFirstChild();
     }
     case GDLTokenTypes::KEYDEF_REF_CHECK:
@@ -1004,7 +1004,7 @@
 	new ParameterNode( refNode);
       return firstChild;
 
-// 		  auto_ptr<ProgNode> guard(nn);
+// 		  Guard<ProgNode> guard(nn);
 // 		  ProgNodeP firstChild = nn->StealFirstChild();
 // 		  firstChild->SetNextSibling( nn->StealNextSibling());
 // 		  return firstChild;
@@ -1021,7 +1021,7 @@
 	new ParameterNode( refNode);
       return firstChild;
 
-// 		  auto_ptr<ProgNode> guard(nn);
+// 		  Guard<ProgNode> guard(nn);
 // 		  ProgNodeP firstChild = nn->StealFirstChild();
 // 		  firstChild->SetNextSibling( nn->StealNextSibling());
 // 		  return firstChild;
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/nullgdl.cpp gdl/src/nullgdl.cpp
--- gdl-0.9.3/src/nullgdl.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/nullgdl.cpp	2013-05-16 12:36:33.361857394 -0600
@@ -204,7 +204,7 @@
   throw GDLException("NullGDL::SetBufferSize called.");
 }
 
-int NullGDL::Scalar2index(SizeT& ret) const 
+int NullGDL::Scalar2Index(SizeT& ret) const 
 { 
   throw GDLException("Operation not defined for !NULL 1.");
 }
@@ -499,7 +499,7 @@
   throw GDLException("Operation not defined for !NULL 170.");
 }
 
-BaseGDL* NullGDL::MatrixOp( BaseGDL* r, bool rtranspose, bool transposeResult, bool strassen)
+BaseGDL* NullGDL::MatrixOp( BaseGDL* r, bool atranspose, bool btranspose)
 {
   throw GDLException("Operation not defined for !NULL 18.");
 }
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/nullgdl.hpp gdl/src/nullgdl.hpp
--- gdl-0.9.3/src/nullgdl.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/nullgdl.hpp	2013-05-16 12:36:33.363857387 -0600
@@ -124,7 +124,7 @@
   /*virtual*/ BaseGDL* GetEmptyInstance() const;
   /*virtual*/ BaseGDL* SetBuffer( const void* b);
   /*virtual*/ void     SetBufferSize( SizeT s);
-  /*virtual*/ int Scalar2index(SizeT& ret) const;
+  /*virtual*/ int Scalar2Index(SizeT& ret) const;
   /*virtual*/ int Scalar2RangeT(RangeT& ret) const;
   /*virtual*/ SizeT GetAsIndex( SizeT i) const;
   /*virtual*/ SizeT GetAsIndexStrict( SizeT i) const;
@@ -281,7 +281,7 @@
 
   
   //  /*virtual*/ BaseGDL* PowInvNew( BaseGDL* r);
-  /*virtual*/ BaseGDL* MatrixOp( BaseGDL* r, bool rtranspose = false, bool transposeResult =false, bool strassen = false);
+  /*virtual*/ BaseGDL* MatrixOp( BaseGDL* r, bool atranspose, bool btranspose);
   /*virtual*/ void AssignAt( BaseGDL* srcIn, ArrayIndexListT* ixList, SizeT offset);
   /*virtual*/ void AssignAt( BaseGDL* srcIn, ArrayIndexListT* ixList);
   /*virtual*/ void AssignAt( BaseGDL* srcIn);
Only in gdl-0.9.3/src: .#objects.cpp.1.22
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/ofmt.cpp gdl/src/ofmt.cpp
--- gdl-0.9.3/src/ofmt.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/ofmt.cpp	2013-03-21 14:04:04.409825029 -0600
@@ -675,8 +675,11 @@
       (*os) << oct << setw(w) << setfill(f) << (*this)[ i];
   else if ( oMode == BIN)
     for( SizeT i=offs; i<endEl; ++i)
+#ifdef _MSC_VER
+      (*os) << binstr((int)(*this)[ i], w);
+#else
       (*os) << binstr((*this)[ i], w);
-//       (*os) << binstr((std::bitset<32>)i, w);
+#endif
   else if ( oMode == HEX)
     for( SizeT i=offs; i<endEl; ++i)
       (*os) << uppercase << hex << setw(w) << setfill(f) << (*this)[ i];
@@ -710,11 +713,15 @@
   else if ( oMode == BIN)
     for( SizeT i=offs; i<endEl; ++i)
     {
-//       if (w > 32) 
-// 	(*os) << binstr((std::bitset<32>)i >> 32, w - 32);
-//       (*os) << binstr((std::bitset<32>)i, w <= 32 ? w : 32);
-      if (w > 32) (*os) << binstr((*this)[ i] >> 32, w - 32);
+#ifdef _MSC_VER
+      if (w > 32)
+	(*os) << binstr((int)(*this)[ i] >> 32, w - 32);
+      (*os) << binstr((int)(*this)[ i], w <= 32 ? w : 32);
+#else
+      if (w > 32) 
+	(*os) << binstr((*this)[ i] >> 32, w - 32);
       (*os) << binstr((*this)[ i], w <= 32 ? w : 32);
+#endif
     }
   else if ( oMode == HEX)
     for( SizeT i=offs; i<endEl; ++i)
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/overload.cpp gdl/src/overload.cpp
--- gdl-0.9.3/src/overload.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/overload.cpp	2013-03-21 14:04:04.428824941 -0600
@@ -270,7 +270,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*left)[i] == s);
 	}    }
   else if( left->StrictScalar(s)) 
@@ -285,7 +285,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] == s);
 	}    }
   else if( rEl < nEl) 
@@ -295,7 +295,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] == (*left)[i]);
 	}    }
   else // ( rEl >= nEl)
@@ -310,7 +310,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*right)[i] == (*left)[i]);
 	}    }
   return res;
@@ -358,7 +358,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*left)[i] != s);
 	}    }
   else if( left->StrictScalar(s)) 
@@ -373,7 +373,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] != s);
 	}    }
   else if( rEl < nEl) 
@@ -383,7 +383,7 @@
 #pragma omp parallel if (rEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= rEl))
 	{
 #pragma omp for
-	  for( int i=0; i < rEl; ++i)
+	  for( OMPInt i=0; i < rEl; ++i)
 	    (*res)[i] = ((*right)[i] != (*left)[i]);
 	}    }
   else // ( rEl >= nEl)
@@ -398,7 +398,7 @@
 #pragma omp parallel if (nEl >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= nEl))
 	{
 #pragma omp for
-	  for( int i=0; i < nEl; ++i)
+	  for( OMPInt i=0; i < nEl; ++i)
 	    (*res)[i] = ((*right)[i] != (*left)[i]);
 	}    }
   return res;
@@ -410,6 +410,7 @@
 BaseGDL* _GDL_OBJECT_OverloadReportIllegalOperation( EnvUDT* e)
 {
   ThrowFromInternalUDSub( e, "Operation illegal with object reference types.");
+  return 0;
 }
 
 // set up the _overload... subroutines for GDL_OBJECT
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting_axis.cpp gdl/src/plotting_axis.cpp
--- gdl-0.9.3/src/plotting_axis.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting_axis.cpp	2013-05-16 12:36:33.414857204 -0600
@@ -25,29 +25,33 @@
   class axis_call : public plotting_routine_call 
   {
 
-    private: bool handle_args(EnvT* e) // {{{
+    private: bool handle_args(EnvT* e)
     {
       return true;
-    } // }}}
+    } 
 
-  private: void old_body( EnvT* e, GDLGStream* actStream) // {{{
+  private: void old_body( EnvT* e, GDLGStream* actStream) 
   { 
-    bool valid=true;
-    // !X, !Y (also used below)
+    bool doT3d, real3d;
+    DDouble zValue;
+    //note: Z (VALUE) will be used uniquely if Z is not effectively defined.
+    static int zvIx = e->KeywordIx( "Z");
+    zValue=0.0;
+    e->AssureDoubleScalarKWIfPresent ( zvIx, zValue );
+    //T3D
+    static int t3dIx = e->KeywordIx( "T3D");
+    doT3d=e->KeywordSet(t3dIx);
 
-    DLong xStyle=0, yStyle=0; 
-    DString xTitle, yTitle; 
-    DFloat x_CharSize, y_CharSize; 
     DFloat xMarginL, xMarginR, yMarginB, yMarginT; 
-    DFloat xTicklen, yTicklen;
 
-    bool xAxis=false, yAxis=false; 
+    bool xAxis=false, yAxis=false, zAxis=false;
     static int xaxisIx = e->KeywordIx( "XAXIS");
     static int yaxisIx = e->KeywordIx( "YAXIS");
+    static int zaxisIx = e->KeywordIx( "ZAXIS");
     
-    PLINT xaxis_value, yaxis_value; 
+    PLINT xaxis_value, yaxis_value, zaxis_value;
     bool standardNumPos;
-    //IDL behaviour for XAXIS and YAXIS options
+    //IDL behaviour for XAXIS and YAXIS and ZAXIS options: only one option is considered, and ZAXIS above YAXIS above XAXIS
     if( (e->GetKW( xaxisIx) != NULL) ) {
       xAxis = true;
       e->AssureLongScalarKWIfPresent( "XAXIS", xaxis_value);
@@ -58,60 +62,88 @@
       e->AssureLongScalarKWIfPresent( "YAXIS", yaxis_value);
       if (yaxis_value == 0) {standardNumPos = true;} else {standardNumPos = false;}
     }
-    if( (e->GetKW( xaxisIx) == NULL) & (e->GetKW( yaxisIx) == NULL ) )  {
+    if( e->GetKW( zaxisIx) != NULL) {
+      zAxis = true; xAxis = false; yAxis=false; // like in IDL, zaxis overrides all
+      e->AssureLongScalarKWIfPresent( "ZAXIS", zaxis_value);
+    }
+    if( (e->GetKW( xaxisIx) == NULL) && (e->GetKW( yaxisIx) == NULL )  && ((e->GetKW( zaxisIx) == NULL )||!doT3d))  {
       xAxis = true; standardNumPos = true; 
     }
     
-    // [XY]STYLE
-    gkw_axis_style(e, "X", xStyle);
-    gkw_axis_style(e, "Y", yStyle);
-
-    e->AssureLongScalarKWIfPresent( "XSTYLE", xStyle);
-    e->AssureLongScalarKWIfPresent( "YSTYLE", yStyle);
-
-    // AXIS TITLE
-    gkw_axis_title(e, "X", xTitle);
-    gkw_axis_title(e, "Y", yTitle);
     // MARGIN
-    gkw_axis_margin(e, "X",xMarginL, xMarginR);
-    gkw_axis_margin(e, "Y",yMarginB, yMarginT);
+    gdlGetDesiredAxisMargin(e, "X",xMarginL, xMarginR);
+    gdlGetDesiredAxisMargin(e, "Y",yMarginB, yMarginT);
+
+    // will handle axis logness..
+    bool xLog, yLog, zLog;
+    // is current box log or not?
+    bool xAxisWasLog, yAxisWasLog, zAxisWasLog;
+    gdlGetAxisType("X", xAxisWasLog);
+    gdlGetAxisType("Y", yAxisWasLog);
+    gdlGetAxisType("Z", zAxisWasLog);
+    xLog=xAxisWasLog;
+    yLog=yAxisWasLog; //by default logness is similar until another option is set
+    zLog=zAxisWasLog;
 
-    // x and y range
+    enum
+    {
+      DATA=0,
+      NORMAL,
+      DEVICE
+    } coordinateSystem=DATA;
+    //check presence of DATA,DEVICE and NORMAL options
+    if ( e->KeywordSet("DATA") ) coordinateSystem=DATA;
+    if ( e->KeywordSet("DEVICE") ) coordinateSystem=DEVICE;
+    if ( e->KeywordSet("NORMAL") ) coordinateSystem=NORMAL;
+
+    // x and y range, old and new
+    DDouble oxStart, oxEnd;
+    DDouble oyStart, oyEnd;
     DDouble xStart, xEnd;
     DDouble yStart, yEnd;
-
-    get_axis_crange("X", xStart, xEnd);
-    get_axis_crange("Y", yStart, yEnd);
-    
-    DLong xnozero=1, ynozero=0;
-	gkw_axis_range( e, "X", xStart, xEnd, xnozero);
-	gkw_axis_range( e, "Y", yStart, yEnd, ynozero);
-
+    // get viewport coordinates in normalised units
+    PLFLT ovpXL, ovpXR, ovpYB, ovpYT;
+    actStream->gvpd(ovpXL, ovpXR, ovpYB, ovpYT);
+    //undefined previous viewport, seems IDL returns without complain:
+    if ((ovpXL==0.0 && ovpXR==0.0) || (ovpYB==0.0 && ovpYT==0.0)) return;
+    PLFLT ovpSizeX, ovpSizeY;
+    ovpSizeX=ovpXR-ovpXL;
+    ovpSizeY=ovpYT-ovpYB;
+    //get wiewport window in world coordinates
+    PLFLT xmin, xmax, ymin, ymax;
+    actStream->gvpw(xmin, xmax, ymin, ymax);
+
+    xStart=oxStart=xmin;
+    xEnd=oxEnd=xmax;
+    yStart=oyStart=ymin;
+    yEnd=oyEnd=ymax;
+    //convert these values to real values if box was log
+    if (xAxisWasLog) {xStart=pow(10,xStart);xEnd=pow(10,xEnd);}
+    if (yAxisWasLog) {yStart=pow(10,yStart);yEnd=pow(10,yEnd);}
+
+    static int xLogIx = e->KeywordIx( "XLOG" );
+    static int yLogIx = e->KeywordIx( "YLOG" );
+    xLog = (xLog || e->KeywordSet( xLogIx ));
+    yLog = (yLog || e->KeywordSet( yLogIx ));
+
+    //YNOZERO corrects yStart
+    if ( e->KeywordSet( "YNOZERO") && yStart >0 && !yLog ) yStart=0.0;
+	bool setdummy;
+    setdummy=gdlGetDesiredAxisRange( e, "X", xStart, xEnd);
+	setdummy=gdlGetDesiredAxisRange( e, "Y", yStart, yEnd);
     if (xStart == xEnd && yStart == yEnd) {
       e->Throw("Invalid plotting ranges.  Set up a plot window first.");
     }
+    gdlHandleUnwantedAxisValue(xStart, xEnd, xLog);
+    gdlHandleUnwantedAxisValue(yStart, yEnd, yLog);
 
-    /*
-    if ((xStyle & 1) != 1 && xAxis) {
-      PLFLT intv;
-      intv = AutoIntvAC(xStart, xEnd, false );
-      // xEnd = ceil(xEnd/intv) * intv;
-      // xStart = floor(xStart/intv) * intv;
-    }
-
-    if ((yStyle & 1) != 1 && yAxis) {
-      PLFLT intv;
-      intv = AutoIntvAC(yStart, yEnd, false );
-      //yEnd = ceil(yEnd/intv) * intv;
-      //yStart = floor(yStart/intv) * intv;
-    }
-    */
-
-    DDouble zVal, yVal, xVal;
+    DDouble yVal, xVal;
+    //in absence of arguments we will have:
+    yVal=(standardNumPos)?oyStart:oyEnd;
+    xVal=(standardNumPos)?oxStart:oxEnd;
     //read arguments 
     if (nParam() == 1) {
       e->AssureDoubleScalarPar( 0, xVal);
-      yVal=0.; //IDL behaviour
     }
     if (nParam() == 2) {
       e->AssureDoubleScalarPar( 0, xVal);
@@ -120,245 +152,94 @@
     if (nParam() == 3) {
       e->Throw( "Sorry, we do not yet support the 3D case");
     }
-    if (nParam() == 0 && standardNumPos) { xVal = xStart; yVal = yStart; }
-    if (nParam() == 0 && !standardNumPos) { xVal = xEnd; yVal = yEnd; }
 
-    /*
-    DLong ynozero, xnozero;
-    //[x|y]range keyword
-    gkw_axis_range(e, "X", xStart, xEnd, ynozero);
-    gkw_axis_range(e, "Y", yStart, yEnd, xnozero);
-    */
-
-    // AC nomore useful
-    // if(xEnd == xStart) xEnd=xStart+1;
-
-    DDouble minVal = yStart;
-    DDouble maxVal = yEnd;
-
-    DLong xTicks=0, yTicks=0; 
-    e->AssureLongScalarKWIfPresent( "XTICKS", xTicks);
-    e->AssureLongScalarKWIfPresent( "YTICKS", yTicks);
-
-    DLong xMinor=0, yMinor=0; 
-    e->AssureLongScalarKWIfPresent( "XMINOR", xMinor);
-    e->AssureLongScalarKWIfPresent( "YMINOR", yMinor);
-
-    DString xTickformat, yTickformat;
-    e->AssureStringScalarKWIfPresent( "XTICKFORMAT", xTickformat);
-    e->AssureStringScalarKWIfPresent( "YTICKFORMAT", yTickformat);
-
-    bool xLog, yLog;
-    //get_axis_type("X", xLog);
-    //get_axis_type("Y", yLog);
-
-    // keyword overrides
-    static int xLogIx = e->KeywordIx( "XLOG");
-    static int yLogIx = e->KeywordIx( "YLOG");
-    xLog = e->KeywordSet( xLogIx);
-    yLog = e->KeywordSet( yLogIx);
-
-    // test for x/yVal
-    if (xLog) { if (xVal <= 0.) xVal=xStart; else xVal=log10(xVal);}
-    if (yLog) { if (yVal <= 0.) yVal=yStart; else yVal=log10(yVal);}
-
-    DDouble ticklen = 0.02;
-    e->AssureDoubleScalarKWIfPresent( "TICKLEN", ticklen);
-						 
-    DFloat charsize, xCharSize, yCharSize;
     // *** start drawing
-    gkw_color(e, actStream);       //COLOR
-    gkw_noerase(e, actStream, true);     //NOERASE
-    gkw_charsize(e, actStream, charsize);    //CHARSIZE
-    gkw_axis_charsize(e, "X",xCharSize);//XCHARSIZE
-    gkw_axis_charsize(e, "Y",yCharSize);//YCHARSIZE
-
-    // plplot stuff
-    // set the charsize (scale factor)
-    DDouble charScale = 1.0;
-    DLongGDL* pMulti = SysVar::GetPMulti();
-    if( (*pMulti)[1] > 2 || (*pMulti)[2] > 2) charScale = 0.5;
-    actStream->schr( 0.0, charsize * charScale);
-
-    // get subpage in mm
-    PLFLT scrXL, scrXR, scrYB, scrYT;
-    actStream->gspa( scrXL, scrXR, scrYB, scrYT); 
-    PLFLT scrX = scrXR-scrXL;
-    PLFLT scrY = scrYT-scrYB;
-
-    // get char size in mm (default, actual)
-    PLFLT defH, actH;
-    actStream->gchr( defH, actH);
-
-    // get viewport coordinates in normalised units
-    PLFLT vpXL, vpXR, vpYB, vpYT;
-    actStream->gvpd(vpXL, vpXR, vpYB, vpYT);
-    PLFLT vpX = vpXR-vpXL;
-    PLFLT vpY = vpYT-vpYB;
-
-    // create new viewport and draw only the relevant side (viewport
-    // will be reset to its original values later)
-    PLFLT svpXL, svpXR, svpYB, svpYT; //new viewport coordinates
-    if (xAxis) {
-      //keep the X values the same
-      svpXL=vpXL; svpXR=vpXR;
-      if (standardNumPos) { //our axis is the bottom of viewport
-	svpYB=vpY*(yVal-yStart)/(yEnd-yStart)+vpYB;
-	svpYT=svpYB+0.2; //value doesn't matter, as long as svpYT>svpYB
-      } else { //our axis is the top of viewport
-	svpYT=vpYT-vpY*(yEnd-yVal)/(yEnd-yStart);
-	svpYB=svpYT-0.2; //value doesn't matter, as long as svpYT>svpYB
-      }
+    gdlSetGraphicsForegroundColorFromKw(e, actStream);       //COLOR
+    //    contrary to the documentation axis does not erase the plot (fortunately!)
+    //    gdlNextPlotHandlingNoEraseOption(e, actStream, true);     //NOERASE -- not supported
+    gdlSetPlotCharthick(e,actStream); 
+    gdlSetPlotCharsize(e, actStream);    //CHARSIZE
+
+    PLFLT vpXL, vpXR, vpYB, vpYT; //define new viewport in relative units
+    // where is point of world coords xVal, yVal in viewport relative coords?
+    DDouble vpX,vpY;
+    if ( coordinateSystem==DEVICE )
+    {
+      actStream->DeviceToNormedDevice(xVal, yVal, vpX, vpY);
     }
-    if (yAxis) {
-      //keep the top and bottom the same
-      svpYT=vpYT; svpYB=vpYB;
-      if (standardNumPos) { //our axis is the left of the viewport
-	svpXL=vpX*(xVal-xStart)/(xEnd-xStart)+vpXL;
-	svpXR=svpXL+0.2; //value doesn't matter, as long as svpXR>svpXL
-      } else { //our axis is the right of the viewport
-	svpXR=vpXR-vpX*(xEnd-xVal)/(xEnd-xStart);
-	svpXL=svpXR-0.2; //value doesn't matter, as long as svpXR>svpXL
-      }
+    else if ( coordinateSystem==NORMAL )
+    {
+      vpX=xVal;
+      vpY=yVal;
+    }
+    else
+    {
+      if (xAxisWasLog) xVal=log10(xVal);
+      if (yAxisWasLog) yVal=log10(yVal);
+      actStream->WorldToNormedDevice(xVal, yVal, vpX, vpY);
+    }
+    //compute new temporary viewport in relative coords
+#define ADDEPSILON 0.1
+    if ( standardNumPos )
+    {
+      vpXL=(xAxis)?ovpXL:vpX;
+      vpXR=(xAxis)?ovpXR:vpX+ovpSizeY;
+      vpYB=(xAxis)?vpY:ovpYB;
+      vpYT=(xAxis)?vpY+ovpSizeX:ovpYT;
+    }
+    else
+    {
+      vpXL=(xAxis)?ovpXL:vpX-ovpSizeY;
+      vpXR=(xAxis)?ovpXR:vpX;
+      vpYB=(xAxis)?vpY-ovpSizeX:ovpYB;
+      vpYT=(xAxis)?vpY:ovpYT;
     }
-    actStream->vpor(svpXL, svpXR, svpYB, svpYT);
-    //The world coordinates for the relevant axis should be same as
-    //the originals, while the other axis doesn't matter.  
-    actStream->wind(xStart, xEnd, yStart,yEnd);
-
-    // POSITION
-    //DFloatGDL* pos = (DFloatGDL*) 0xF;
-
-    /*
-    // viewport and world coordinates
-    bool okVPWC = SetVP_WC( e, actStream, pos, NULL,
-			    xLog, yLog,
-			    xMarginL, xMarginR, yMarginB, yMarginT,
-			    xStart, xEnd, minVal, maxVal);
-    if( !okVPWC) return;
-    */
-
-    // pen thickness for axis
-    actStream->wid( 0);
-
-    // axis
-    string xOpt, yOpt;
-    if (standardNumPos) { xOpt = "b"; yOpt = "b";} else { xOpt = "c"; yOpt = "c"; }
-
-    if (xTicks == 1) xOpt += "t"; else xOpt += "st";
-    if (yTicks == 1) yOpt += "tv"; else yOpt += "stv";
-
-    if (xTickformat != "(A1)" && standardNumPos) xOpt += "nf";
-    if (xTickformat != "(A1)" && !standardNumPos) xOpt += "mf";
-    if (yTickformat != "(A1)" && standardNumPos) yOpt += "nf";
-    if (yTickformat != "(A1)" && !standardNumPos) yOpt += "mf";
-
-    if( xLog) xOpt += "l";
-    if( yLog) yOpt += "l";
-
-    if ((xStyle & 4) == 4) xOpt = "";
-    if ((yStyle & 4) == 4) yOpt = "";
-
-    string titleOpt;
-    if (xAxis) {
-
-      // axis titles
-      actStream->schr( 0.0, actH/defH * xCharSize);
-      if (standardNumPos) { titleOpt = "b"; } else { titleOpt = "t"; }
-      actStream->mtex(titleOpt.c_str(),3.5,0.5,0.5,xTitle.c_str());
-
-      // the axis (separate for x and y axis because of charsize)
-      PLFLT xintv;
-      if (xTicks == 0) {
-	xintv = AutoTick(xEnd-xStart);
-      } else {
-	xintv = (xEnd - xStart) / xTicks;
-      }
-      actStream->box( xOpt.c_str(), xintv, xMinor, "", 0.0, 0);
 
-      if (e->KeywordSet("SAVE"))
-      {
-        // X.CRANGE
-        set_axis_crange("X", xStart, xEnd, xLog);
+    actStream->OnePageSaveLayout(); // one page
 
-        // X.TYPE
-        set_axis_type("X",xLog);
+    actStream->vpor(vpXL, vpXR, vpYB, vpYT);
+    if (xLog) {xStart=log10(xStart);xEnd=log10(xEnd);}
+    if (yLog) {yStart=log10(yStart);yEnd=log10(yEnd);}
+    actStream->wind(xStart, xEnd, yStart, yEnd);
+
+    if ( xAxis )
+    {
+      gdlAxis(e, actStream, "X", xStart, xEnd, xLog, standardNumPos?1:2);
 
-        // X.S ... TODO: set_axis_s()
-        DStructGDL* Struct=NULL;
-        Struct = SysVar::X();
-        static unsigned sTag = Struct->Desc()->TagIndex( "S");
-        PLFLT p_xmin, p_xmax, p_ymin, p_ymax;
-        actStream->gvpd (p_xmin, p_xmax, p_ymin, p_ymax);
-        if(Struct != NULL)
-        {
-          (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[0] =
-            (p_xmin*xEnd - p_xmax*xStart) / (xEnd - xStart);
-          (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[1] =
-            (p_xmax - p_xmin) / (xEnd - xStart);
-        }
+      if ( e->KeywordSet("SAVE") )
+      {
+        gdlStoreAxisCRANGE("X", xStart, xEnd, xLog);
+        gdlStoreAxisType("X", xLog);
+        gdlStoreAxisSandWINDOW(actStream, "X", xStart, xEnd, xLog);
       }
     }
 
-    if (yAxis) {
-
-      // axis titles
-      actStream->schr( 0.0, actH/defH * yCharSize);
-      if (standardNumPos) { titleOpt = "l"; } else { titleOpt = "r"; }
-      actStream->mtex(titleOpt.c_str(),5.0,0.5,0.5,yTitle.c_str());
-
-      // the axis (separate for x and y axis because of charsize)
-      PLFLT yintv;
-      if (yTicks == 0) {
-	yintv = AutoTick(yEnd-yStart);
-      } else {
-	yintv = (yEnd - yStart) / yTicks;
-      }
-      actStream->box( "", 0.0, 0, yOpt.c_str(), yintv, yMinor);
+    if ( yAxis )
+    {
+      gdlAxis(e, actStream, "Y", yStart, yEnd, yLog, standardNumPos?1:2);
 
-      if (e->KeywordSet("SAVE"))
+      if ( e->KeywordSet("SAVE") )
       {
-        // Y.CRANGE
-        set_axis_crange("Y", yStart, yEnd, yLog);
-
-        // Y.TYPE
-        set_axis_type("Y",yLog);
-
-        // Y.S ... TODO: set_axis_s()
-        DStructGDL* Struct=NULL;
-        Struct = SysVar::Y();
-        static unsigned sTag = Struct->Desc()->TagIndex( "S");
-        PLFLT p_xmin, p_xmax, p_ymin, p_ymax;
-        actStream->gvpd (p_xmin, p_xmax, p_ymin, p_ymax);
-        if(Struct != NULL)
-        {
-          (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[0] =
-            (p_ymin*yEnd - p_ymax*yStart) / (yEnd - yStart);
-          (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[1] =
-            (p_ymax - p_ymin) / (yEnd - yStart);
-        }
+        gdlStoreAxisCRANGE("Y", yStart, yEnd, yLog);
+        gdlStoreAxisType("Y", yLog);
+        gdlStoreAxisSandWINDOW(actStream, "Y", yStart, yEnd, yLog);
       }
     }
-
     // reset the viewport and world coordinates to the original values
-    actStream->vpor(vpXL, vpXR, vpYB, vpYT);
-    actStream->wind(xStart, xEnd, yStart,yEnd);
-
-    // title and sub title
-    // axis has subtitle but no title, gkw_title requires both
-    //    gkw_title(e, actStream, actH/defH);
+    actStream->RestoreLayout();
 
-  } // }}}
+  }
 
-    private: void call_plplot(EnvT* e, GDLGStream* actStream) // {{{
+    private: void call_plplot(EnvT* e, GDLGStream* actStream) 
     {
-    } // }}}
+    } 
  
-    private: virtual void post_call(EnvT*, GDLGStream*) // {{{
+    private: virtual void post_call(EnvT* e, GDLGStream* actStream)
     {
-    } // }}}
+       actStream->sizeChar(1.0);
+    } 
 
-  }; // axis_call
+  }; 
 
   void axis(EnvT* e)
   {
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting_contour.cpp gdl/src/plotting_contour.cpp
--- gdl-0.9.3/src/plotting_contour.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting_contour.cpp	2013-05-16 12:36:33.486856945 -0600
@@ -1,884 +1,925 @@
-/***************************************************************************
-                       plotting.cpp  -  GDL routines for plotting
-                             -------------------
-    begin                : July 22 2002
-    copyright            : (C) 2002-2011 by Marc Schellens et al.
-    email                : m_schellens@users.sf.net
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "includefirst.hpp"
-#include "plotting.hpp"
-#include "math_utl.hpp"
-
-#ifdef _MSC_VER
-#define isinf !_finite
-#endif
-
-namespace lib {
-
-  using namespace std;
-
-  struct mypltr_passinfo // {{{
-  {
-    PLFLT spa[4];
-#ifdef USE_LIBPROJ4
-    PLFLT sx[2], sy[2];
-    LPTYPE* idata;
-    XYTYPE* odata; 
-    PROJTYPE* ref; 
-    DDouble d_nan;
-    bool mapSet;
-#endif
-    bool xLog;
-    bool yLog;
-  }; // }}}
-
-  void mypltr(PLFLT x, PLFLT y, PLFLT *tx, PLFLT *ty, void *pltr_data) // {{{
-  {
-    PLFLT tr[6]={0.0,0.0,0.0,0.0,0.0,0.0};
-    struct mypltr_passinfo *ptr = (mypltr_passinfo* )pltr_data;
-
-    tr[0] = ptr->spa[0];
-    tr[4] = ptr->spa[1];
-    tr[2] = ptr->spa[2];
-    //    tr[5] = ptr->spa[4];
-    tr[5] = ptr->spa[3];
-
-    // conversion from array indices to data coord
-    x = tr[0] * x + tr[2];
-    y = tr[4] * y + tr[5];
-    
-    // conversion from lon / lat to projected values (in normal coordinates)
-#ifdef USE_LIBPROJ4
-    if (ptr->mapSet)
-    {
-      // Convert from lon/lat in degrees to radians
-      ptr->idata->lam = x * DEG_TO_RAD;
-      ptr->idata->phi = y * DEG_TO_RAD;
-      
-      // Convert from lon/lat in radians to data coord
-      *ptr->odata = PJ_FWD(*ptr->idata, ptr->ref);
-      x = ptr->odata->x;
-      y = ptr->odata->y;
-
-      // handling inf points (not sure if this is needed?)
-      if (!isfinite(x) || !isfinite(y)) x = y = ptr->d_nan;
-    }
-#endif
-
-    // assignment to pointers passed in arguments
-    *tx = ptr->xLog ? log10(x) : x;
-    *ty = ptr->yLog ? log10(y) : y;
-  } // }}}
-
-  class contour_call : public plotting_routine_call
-  {
-    DDoubleGDL *zVal, *yVal, *xVal;
-    auto_ptr<BaseGDL> xval_guard, yval_guard, p0_guard;
-    SizeT xEl, yEl, zEl;
-    DDouble xStart, xEnd, yStart, yEnd, zStart, zEnd;
-    bool xLog, yLog, zLog;
-    bool overplot;
-
-    private: bool handle_args( EnvT* e) // {{{
-    {
-      if( nParam() == 1)
-      {
-	BaseGDL* p0 = e->GetNumericArrayParDefined( 0)->Transpose( NULL);
-
-	zVal = static_cast<DDoubleGDL*>
-	  (p0->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-	p0_guard.reset( p0); // delete upon exit
-
-	xEl = zVal->Dim(1);
-	yEl = zVal->Dim(0);
-
-	if(zVal->Rank() != 2)
-	  e->Throw(  "Array must have 2 dimensions: "
-			      +e->GetParString(0));
-
-	xVal = new DDoubleGDL( dimension( xEl), BaseGDL::INDGEN);
-	xval_guard.reset( xVal); // delete upon exit
-	yVal = new DDoubleGDL( dimension( yEl), BaseGDL::INDGEN);
-	yval_guard.reset( yVal); // delete upon exit
-      } 
-      else if ( nParam() == 2 || nParam() > 3) 
-      {
-        e->Throw( "Incorrect number of arguments.");
-      } 
-      else 
-      {
-	BaseGDL* p0 = e->GetNumericArrayParDefined( 0)->Transpose( NULL);
-	zVal = static_cast<DDoubleGDL*>
-	  (p0->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-	p0_guard.reset( p0); // delete upon exit
-
-	if(zVal->Dim(0) == 1)
-	  e->Throw( "Array must have 2 dimensions: "
-			      +e->GetParString(0));
-
-	xVal = e->GetParAs< DDoubleGDL>( 1);
-	yVal = e->GetParAs< DDoubleGDL>( 2);
-
-	if (xVal->Rank() > 2)
-	  e->Throw( "X, Y, or Z array dimensions are incompatible.");
-
-	if (yVal->Rank() > 2)
-	  e->Throw( "X, Y, or Z array dimensions are incompatible.");
-
-	if (xVal->Rank() == 1) {
-	  xEl = xVal->Dim(0);
-
-	  if(xEl != zVal->Dim(1))
-	    e->Throw( "X, Y, or Z array dimensions are incompatible.");
-	}
-
-	if (yVal->Rank() == 1) {
-	  yEl = yVal->Dim(0);
-
-	  if(yEl != zVal->Dim(0))
-	    e->Throw( "X, Y, or Z array dimensions are incompatible.");
-	}
-
-	if (xVal->Rank() == 2) {
-	  if((xVal->Dim(0) != zVal->Dim(1)) && (xVal->Dim(1) != zVal->Dim(0)))
-	    e->Throw( "X, Y, or Z array dimensions are incompatible.");
-	}
-
-	if (yVal->Rank() == 2) {
-	  if((yVal->Dim(0) != zVal->Dim(1)) && (yVal->Dim(1) != zVal->Dim(0)))
-	    e->Throw( "X, Y, or Z array dimensions are incompatible.");
-	}
-      }
-      static int overplotKW = e->KeywordIx("OVERPLOT");
-      overplot = e->KeywordSet( overplotKW);
-    
-      return overplot;
-    } // }}}
-
-  private: void old_body( EnvT* e, GDLGStream* actStream) // {{{
-  {
-    // !P 
-    DLong p_background, p_noErase, p_color, p_psym, p_linestyle;
-    DFloat p_symsize, p_charsize, p_thick, p_ticklen; 
-    DString p_title, p_subTitle; 
-    
-    GetPData( p_background,
-	      p_noErase, p_color, p_psym, p_linestyle,
-	      p_symsize, p_charsize, p_thick,
-	      p_title, p_subTitle, p_ticklen);
-
-    // !X, !Y, !Z (also used below)
-    static DStructGDL* xStruct = SysVar::X();
-    static DStructGDL* yStruct = SysVar::Y();
-    static DStructGDL* zStruct = SysVar::Z();
-    DLong xStyle, yStyle, zStyle;
-    DString xTitle, yTitle, zTitle;
-    DFloat x_CharSize, y_CharSize, z_CharSize;
-    DFloat xMarginL; 
-    DFloat xMarginR; 
-    DFloat yMarginB; 
-    DFloat yMarginF; 
-    DFloat zMarginB; 
-    DFloat zMarginT; 
-    DFloat xTicklen;
-    DFloat yTicklen;
-    DFloat zTicklen;
-    GetAxisData( xStruct, xStyle, xTitle, x_CharSize, xMarginL, xMarginR,
-		 xTicklen);
-    GetAxisData( yStruct, yStyle, yTitle, y_CharSize, yMarginB, yMarginF,
-		 yTicklen);
-    GetAxisData( zStruct, zStyle, zTitle, z_CharSize, zMarginB, zMarginT,
-		 zTicklen);
-
-    // [XY]STYLE
-    e->AssureLongScalarKWIfPresent( "XSTYLE", xStyle);
-    e->AssureLongScalarKWIfPresent( "YSTYLE", yStyle);
-    e->AssureLongScalarKWIfPresent( "ZSTYLE", zStyle);
-
-    // TITLE
-    DString title = p_title;
-    DString subTitle = p_subTitle;
-    e->AssureStringScalarKWIfPresent( "TITLE", title);
-    e->AssureStringScalarKWIfPresent( "SUBTITLE", subTitle);
-
-    // AXIS TITLE
-    e->AssureStringScalarKWIfPresent( "XTITLE", xTitle);
-    e->AssureStringScalarKWIfPresent( "YTITLE", yTitle);
-    e->AssureStringScalarKWIfPresent( "ZTITLE", zTitle);
-
-    // MARGIN (in characters)
-    static int xMarginEnvIx = e->KeywordIx( "XMARGIN"); 
-    static int yMarginEnvIx = e->KeywordIx( "YMARGIN"); 
-    static int zMarginEnvIx = e->KeywordIx( "ZMARGIN"); 
-    BaseGDL* xMargin = e->GetKW( xMarginEnvIx);
-    BaseGDL* yMargin = e->GetKW( yMarginEnvIx);
-    BaseGDL* zMargin = e->GetKW( zMarginEnvIx);
-    if( xMargin != NULL)
-      {
-	if( xMargin->N_Elements() > 2)
-	  e->Throw( "Keyword array parameter XMARGIN"
-		    " must have from 1 to 2 elements.");
-	auto_ptr<DFloatGDL> guard;
-	DFloatGDL* xMarginFl = static_cast<DFloatGDL*>
-	  ( xMargin->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	guard.reset( xMarginFl);
-	xMarginL = (*xMarginFl)[0];
-	if( xMarginFl->N_Elements() > 1)
-	  xMarginR = (*xMarginFl)[1];
-      }
-    if( yMargin != NULL)
-      {
-	if( yMargin->N_Elements() > 2)
-	  e->Throw( "Keyword array parameter YMARGIN"
-		    " must have from 1 to 2 elements.");
-	auto_ptr<DFloatGDL> guard;
-	DFloatGDL* yMarginFl = static_cast<DFloatGDL*>
-	  ( yMargin->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	guard.reset( yMarginFl);
-	yMarginB = (*yMarginFl)[0];
-	if( yMarginFl->N_Elements() > 1)
-	  yMarginF = (*yMarginFl)[1];
-      }
-    if( zMargin != NULL)
-      {
-	if( zMargin->N_Elements() > 2)
-	  e->Throw( "Keyword array parameter ZMARGIN"
-		    " must have from 1 to 2 elements.");
-	auto_ptr<DFloatGDL> guard;
-	DFloatGDL* zMarginFl = static_cast<DFloatGDL*>
-	  ( zMargin->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	guard.reset( zMarginFl);
-	zMarginB = (*zMarginFl)[0];
-	if( zMarginFl->N_Elements() > 1)
-	  zMarginT = (*zMarginFl)[1];
-      }
-
-    // x and y and z range
-    GetMinMaxVal( xVal, &xStart, &xEnd);
-    GetMinMaxVal( yVal, &yStart, &yEnd);
-    GetMinMaxVal( zVal, &zStart, &zEnd);
-    
-    xLog = e->KeywordSet( "XLOG");
-    yLog = e->KeywordSet( "YLOG");
-    zLog = e->KeywordSet( "ZLOG");
-
-    if ((xStyle & 1) != 1) {
-      PLFLT intv = AutoIntvAC(xStart, xEnd, false, xLog );
-    }
-
-    if ((yStyle & 1) != 1) {
-      PLFLT intv = AutoIntvAC(yStart, yEnd, false, yLog );
-    }
-    
-    if ((zStyle & 1) != 1) {
-      PLFLT intv = AutoIntvAC(zStart, zEnd, false, zLog );
-    }
-
-    //[x|y|z]range keyword
-    static int zRangeEnvIx = e->KeywordIx("ZRANGE");
-    static int yRangeEnvIx = e->KeywordIx("YRANGE");
-    static int xRangeEnvIx = e->KeywordIx("XRANGE");
-    BaseGDL* xRange = e->GetKW( xRangeEnvIx);
-    BaseGDL* yRange = e->GetKW( yRangeEnvIx);
-    BaseGDL* zRange = e->GetKW( zRangeEnvIx);
-    
-    if(xRange != NULL) 
-      {
-	if(xRange->N_Elements() != 2)
-	  e->Throw("Keyword array parameter XRANGE"
-		   " must have 2 elements.");
-	auto_ptr<DFloatGDL> guard;
-	DFloatGDL* xRangeF = static_cast<DFloatGDL*>
-	  ( xRange->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	guard.reset( xRangeF);
-	xStart = (*xRangeF)[0];
-	xEnd = (*xRangeF)[1];
-      }
-
-    if(yRange != NULL)
-      {
-	if(yRange->N_Elements() != 2)
-	  e->Throw("Keyword array parameter YRANGE"
-		   " must have 2 elements.");
-	auto_ptr<DFloatGDL> guard;
-	DFloatGDL* yRangeF = static_cast<DFloatGDL*>
-	  ( yRange->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	guard.reset( yRangeF);
-	yStart = (*yRangeF)[0];
-	yEnd = (*yRangeF)[1];
-      }
-    if(zRange != NULL)
-      {
-	if(zRange->N_Elements() != 2)
-	  e->Throw("Keyword array parameter ZRANGE"
-		   " must have 2 elements.");
-	auto_ptr<DFloatGDL> guard;
-	DFloatGDL* zRangeF = static_cast<DFloatGDL*>
-	  ( zRange->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	guard.reset( zRangeF);
-	zStart = (*zRangeF)[0];
-	zEnd = (*zRangeF)[1];
-      }
-
-    bool mapSet = false;
-#ifdef USE_LIBPROJ4
-    get_mapset(mapSet);
-#endif
-
-    DDouble minVal = zStart;
-    DDouble maxVal = zEnd;
-    e->AssureDoubleScalarKWIfPresent( "MIN_VALUE", minVal);
-    e->AssureDoubleScalarKWIfPresent( "MAX_VALUE", maxVal);
-
-    // AC july 2008 please remember that data sweep out by that
-    // are really processed like MISSING data (NaN ...)
-    if (minVal > zStart) cout << "This MIN_VALUE is not ready, sorry. Help welcome." <<endl;
-    if (maxVal < zEnd) cout << "This MAX_VALUE is not ready, sorry. Help welcome." <<endl;
-    //cout << "MIN_VALUE" << minVal << endl;
-    //cout << "MAX_VALUE" << maxVal << endl;
-
-    //ISOTROPIC
-    DLong iso=0;
-    e->AssureLongScalarKWIfPresent( "ISOTROPIC", iso);
-
-    DLong xTicks=0, yTicks=0, zTicks=0;
-    e->AssureLongScalarKWIfPresent( "XTICKS", xTicks);
-    e->AssureLongScalarKWIfPresent( "YTICKS", yTicks);
-    e->AssureLongScalarKWIfPresent( "ZTICKS", zTicks);
-
-    DLong xMinor=0, yMinor=0, zMinor=0; 
-    e->AssureLongScalarKWIfPresent( "XMINOR", xMinor);
-    e->AssureLongScalarKWIfPresent( "YMINOR", yMinor);
-    e->AssureLongScalarKWIfPresent( "ZMINOR", zMinor);
-
-    DString xTickformat, yTickformat, zTickformat;
-    e->AssureStringScalarKWIfPresent( "XTICKFORMAT", xTickformat);
-    e->AssureStringScalarKWIfPresent( "YTICKFORMAT", yTickformat);
-    e->AssureStringScalarKWIfPresent( "ZTICKFORMAT", zTickformat);
-
-    if( xLog && xStart <= 0.0)
-      Warning( "CONTOUR: Infinite x plot range.");
-    if( yLog && yStart <= 0.0)
-      Warning( "CONTOUR: Infinite y plot range.");
-    if( zLog && zStart <= 0.0)
-      Warning( "CONTOUR: Infinite z plot range.");
-
-    DDouble ticklen = p_ticklen;
-    e->AssureDoubleScalarKWIfPresent( "TICKLEN", ticklen);
-						 
-    DLong noErase = p_noErase;
-    if( e->KeywordSet( "NOERASE")) noErase = 1;
-    
-    // POSITION
-    PLFLT xScale = 1.0;
-    PLFLT yScale = 1.0;
-    //    PLFLT scale = 1.0;
-    static int positionIx = e->KeywordIx( "POSITION"); 
-    DFloatGDL* pos = e->IfDefGetKWAs<DFloatGDL>( positionIx);
-    if (pos == NULL) pos = (DFloatGDL*) 0xF;
-    /*
-    PLFLT position[ 4] = { 0.0, 0.0, 1.0, 1.0};
-    if( pos != NULL)
-      {
-      for( SizeT i=0; i<4 && i<pos->N_Elements(); ++i)
-	position[ i] = (*pos)[ i];
-
-      xScale = position[2]-position[0];
-      yScale = position[3]-position[1];
-      //      scale = sqrt( pow( xScale,2) + pow( yScale,2));
-      }
-    */
-
-    // CHARSIZE
-    DDouble charsize = p_charsize;
-    e->AssureDoubleScalarKWIfPresent( "CHARSIZE", charsize);
-    if( charsize <= 0.0) charsize = 1.0;
-    //    charsize *= scale;
-
-    // AXIS CHARSIZE
-    DDouble xCharSize = x_CharSize;
-    e->AssureDoubleScalarKWIfPresent( "XCHARSIZE", xCharSize);
-    if( xCharSize <= 0.0) xCharSize = 1.0;
-
-    DDouble yCharSize = y_CharSize;
-    e->AssureDoubleScalarKWIfPresent( "YCHARSIZE", yCharSize);
-    if( yCharSize <= 0.0) yCharSize = 1.0;
-    //    yCharSize *= scale;
-
-    DDouble zCharSize = z_CharSize;
-    e->AssureDoubleScalarKWIfPresent( "ZCHARSIZE", zCharSize);
-    if( zCharSize <= 0.0) zCharSize = 1.0;
-
-
-    // THICK
-    DFloat thick = p_thick;
-    e->AssureFloatScalarKWIfPresent( "THICK", thick);
-
-   // CHARTHICK (thickness of "char")
-    PLINT charthick=1;
-
-    DDouble *sx, *sy;
-    DFloat *wx, *wy;
-    GetSFromPlotStructs(&sx, &sy);
-    GetWFromPlotStructs(&wx, &wy);
-
-    // mapping only in OVERPLOT mode
-    if (!overplot) set_mapset(0);
-
-    if (overplot) 
-    {
-      //rewrite these quantities
-      if (!mapSet) 
-      {
-        get_axis_crange("X", xStart, xEnd);
-        get_axis_crange("Y", yStart, yEnd);
-      } 
-      else 
-      {
-        DataCoordLimits(sx, sy, wx, wy, &xStart, &xEnd, &yStart, &yEnd, true);
-      }
-      get_axis_margin("X",xMarginL, xMarginR);
-      get_axis_margin("Y",yMarginB, yMarginF);
-      get_axis_type("X", xLog);
-      get_axis_type("Y", yLog);
-      DFloat charsizeF;
-      gkw_charsize(e,actStream, charsizeF, false);
-      charsize=charsizeF;
-      pos = NULL;
-    }
-
-   // *** start drawing
-    gkw_background(e, actStream);  //BACKGROUND
-    gkw_color(e, actStream);       //COLOR
-
-    if (!overplot) {
-      actStream->NextPlot( !noErase);
-      if( !noErase) actStream->Clear();
-    }
-
-    // plplot stuff
-    // set the charsize (scale factor)
-    DDouble charScale = 1.0;
-    DLongGDL* pMulti = SysVar::GetPMulti();
-    if( (*pMulti)[1] > 2 || (*pMulti)[2] > 2) charScale = 0.5;
-    actStream->schr( 0.0, charsize * charScale);
-
-#if 0
-    // get subpage in mm
-    PLFLT scrXL, scrXR, scrYB, scrYF;
-    actStream->gspa( scrXL, scrXR, scrYB, scrYF); 
-    PLFLT scrX = scrXR-scrXL;
-    PLFLT scrY = scrYF-scrYB;
-#endif
-
-    // get char size in mm (default, actual)
-    PLFLT defH, actH;
-    actStream->gchr( defH, actH);
-
-    // CLIPPING
-    DDoubleGDL* clippingD=NULL;
-    DLong noclip=0;
-    e->AssureLongScalarKWIfPresent( "NOCLIP", noclip);
-    if(noclip == 0)
-      {
-	static int clippingix = e->KeywordIx( "CLIP"); 
-	clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
-      }
-    
-    if (!overplot || !mapSet)
-    {
-      // viewport and world coordinates
-      bool okVPWC = SetVP_WC( e, actStream, overplot?NULL:pos, clippingD,
-                            xLog, yLog,
-                            xMarginL, xMarginR, yMarginB, yMarginF,
-                            xStart, xEnd, yStart, yEnd, iso);
-      if( !okVPWC) return;
-    } else {
-      // not using SetVP_WC as it seem to always select full window for plotting (FIXME)
-      actStream->NoSub();
-      actStream->vpor(wx[0], wx[1], wy[0], wy[1]);
-      actStream->wind( xStart, xEnd, yStart, yEnd);
-    }
-
-    // managing the levels list OR the nlevels value
-
-    PLINT nlevel;
-    PLFLT *clevel;
-    ArrayGuard<PLFLT> clevel_guard;
-
-    // we need to define the NaN value
-    static DStructGDL *Values =  SysVar::Values();       
-    DDouble d_nan=(*static_cast<DDoubleGDL*>(Values->GetTag(Values->Desc()->TagIndex("D_NAN"), 0)))[0]; 
-    
-    static int levelsix = e->KeywordIx( "LEVELS"); 
-
-    BaseGDL* b_levels=e->GetKW(levelsix);
-    if(b_levels != NULL) {
-      DDoubleGDL* d_levels = e->GetKWAs<DDoubleGDL>( levelsix);
-      nlevel = d_levels->N_Elements();
-      clevel = (PLFLT *) &(*d_levels)[0];
-      // are the levels ordered ?
-      for ( SizeT i=1; i<nlevel; i++) {
-	if (clevel[i] <= clevel[i-1]) 
-	  e->Throw( "Contour levels must be in increasing order.");
-      }      
-    } else {
-      PLFLT zintv;
-      // Jo: added keyword NLEVELS
-      if (e->KeywordSet( "NLEVELS")) {
-        DLong l_nlevel = nlevel; // GCC 3.4.4 needs that
-      	e->AssureLongScalarKWIfPresent( "NLEVELS", l_nlevel);
-        nlevel = l_nlevel;
-	if (nlevel <= 0) nlevel= 2;  // AC: mimication of IDL
-
-        // cokhavim: IDL does this...
-        zintv = (PLFLT) ((zEnd - zStart) / (nlevel+1));
-        // ... but I think this is better:
-        // if (e->KeywordSet( "FILL")) zintv = (PLFLT) ((zEnd - zStart) / (nlevel));
-        // else zintv = (PLFLT) ((zEnd - zStart) / (nlevel+1));
-
-        // SA: this indeed seems better in some cases; however, it makes calls
-        //     with and without the /FILL keyword behave differently. As a result,
-        //     when overlaing contours over a filled contour, the contours do not match, e.g.:
-        //     a=dist(7) & contour,a,/fill,nl=5 & contour,a,/over,/foll,nl=5
-
-      } else {
-	zintv = AutoTick(zEnd - zStart);
-	nlevel = (PLINT) floor((zEnd - zStart) / zintv);
-        // SA: sanity check to prevent segfaults, e.g. with solely non-finite values 
-        if (zintv == 0 || nlevel < 0) nlevel = 0; 
-      }
-
-
-//       clevel = new PLFLT[nlevel+1];
-//       clevel_guard.Reset( clevel);
-//       // Jo: fixed clevel to account for non-zero zMin
-//       for( SizeT i=1; i<=nlevel; i++) clevel[i-1] = zintv * (i-1) + zStart;
-//       //for( SizeT i=0; i<=nlevel; i++) clevel[i] = zintv * i + zStart;
-DDouble offset=0.;
-if (e->KeywordSet( "FILL")) { nlevel = nlevel + 1; offset=zintv;}
-clevel = new PLFLT[nlevel];
-clevel_guard.Reset( clevel);
-//IDL does this:
-// for( SizeT i=1; i<=nlevel; i++) clevel[i-1] = zintv * i + zStart;
-//but I think this is better:
-for( SizeT i=1; i<=nlevel; i++) clevel[i-1] = zintv * i + zStart - offset;
-clevel[nlevel-1]=zEnd; //make this explicit
-
-    }
-    
-//     // Jo: added keyword FILL
-
-    PLINT  &nlevel_fill = nlevel;
-    PLFLT* &clevel_fill = clevel;
-
-//     PLFLT *clevel_fill;
-//     ArrayGuard<PLFLT> clevel_fill_guard;
-//     PLINT nlevel_fill;
-//     if (e->KeywordSet( "FILL")) {
-//       // To ensure that the highest level is filled, define a new
-//       // clevel to include highest value of z:   
-//       // modif by AC to manage the exception (nlevel=1)
-//       if (nlevel > 1) {
-// 	nlevel_fill=nlevel+1;
-// 	clevel_fill = new PLFLT[nlevel_fill];
-// 	clevel_fill_guard.Reset( clevel_fill);
-// 	clevel_fill[nlevel_fill-1] = clevel[nlevel - 1] < zEnd ? zEnd : clevel[nlevel - 1] + 1.;
-// 	for( SizeT i=0; i<nlevel; i++) clevel_fill[i] = clevel[i];
-//       } else {
-// 	nlevel_fill=3;
-// 	clevel_fill = new PLFLT[nlevel_fill];
-// 	clevel_fill_guard.Reset( clevel_fill);
-//         clevel_fill[0] = clevel[0] > zStart ? zStart : clevel[0] - 1.;
-//         clevel_fill[1] = clevel[0];
-//         clevel_fill[2] = clevel[0] < zEnd ? zEnd : clevel[0] + 1.;
-//       }
-      
-//     }
-
-//     // levels outside limits are changed ...
-//     for (SizeT i=0; i<=nlevel; i++) {
-//       if (clevel[i] < zStart) clevel[i]=zStart;
-//       if (clevel[i] > zEnd) clevel[i]=zEnd;
-//     }
-
-    // pen thickness for plot
-    actStream->wid( static_cast<PLINT>(floor( thick-0.5)));
-
-    // labeling
-    bool label = false;
-    if (e->KeywordSet("FOLLOW") || e->KeywordSet("C_CHARSIZE")) label = true;
-    // TODO: if (e->KeywordSet("C_ANNOTATION") || e->KeywordSet("C_CHARTHICK") || e->KeywordSet("C_LABELS")) label = true;  
-    if (e->KeywordSet("FILL")) label = false;
-    if (label)
-    { 
-      // IDL default: 3/4 of the axis charsize (CHARSIZE keyword or !P.CHARSIZE)
-      // PlPlot default: .3
-      DFloat label_size = .75 * charsize;
-      if (e->KeywordSet("C_CHARSIZE")) e->AssureFloatScalarKWIfPresent("C_CHARSIZE", label_size);
-      //usage: setcontlabelparam(PLFLT offset, PLFLT size, PLFLT spacing, PLINT active);
-      actStream->setcontlabelparam(0.0, (PLFLT)label_size, .3, true);
-    }
-
-#ifdef USE_LIBPROJ4
-    static LPTYPE idata;
-    static XYTYPE odata;
-    static PROJTYPE* ref;
-    if (mapSet)
-    {
-      ref = map_init();
-      if ( ref == NULL) e->Throw( "Projection initialization failed.");
-    }
-#endif
-
-    // starting plotting the data
-    struct mypltr_passinfo passinfo;
-
-    static int c_colorsIx = e->KeywordIx("C_COLORS");
-    static int c_linestyleIx = e->KeywordIx("C_LINESTYLE");
-    // 1 DIM X & Y
-    if (xVal->Rank() == 1 && yVal->Rank() == 1) 
-    {
-      PLFLT spa[4];
-      
-      // don't forgot we have to use the real limits, not the adjusted ones
-      DDouble xMin, xMax, yMin, yMax;
-      GetMinMaxVal( xVal, &xMin, &xMax);
-      GetMinMaxVal( yVal, &yMin, &yMax);
- 
-      passinfo.spa[0] = (xMax - xMin) / (xEl - 1);
-      passinfo.spa[1] = (yMax - yMin) / (yEl - 1);
-      passinfo.spa[2] = xMin;
-      passinfo.spa[3] = yMin;
-      passinfo.xLog = xLog;
-      passinfo.yLog = yLog;
-
-#ifdef USE_LIBPROJ4
-      passinfo.mapSet = mapSet;
-      if (mapSet) // which imposes overplotting
-      {
-        passinfo.idata = &idata;
-        passinfo.odata = &odata;
-        passinfo.ref = ref;
-        passinfo.d_nan = d_nan;
-
-        passinfo.sx[0] = sx[0];
-        passinfo.sx[1] = sx[1];
-        passinfo.sy[0] = sy[0];
-        passinfo.sy[1] = sy[1];
-      }
-#endif
-
-      PLFLT** z = new PLFLT*[xEl];
-      for( SizeT i=0; i<xEl; i++) 
-      {
-        z[i] = &(*zVal)[i*yEl];
-      }
-      
-      // plplot knows how to manage NaN but not Infinity ...
-      // we remplace Infinity by Nan
-      for( SizeT i=0; i<xEl*yEl; i++) 
-      {
-	if (isinf((*zVal)[i])) (*z)[i]= d_nan;
-      }
-      // a draft for MaxVal ...
-      //      if (maxVal < zEnd) {
-      //;	for( SizeT i=0; i<xEl*yEl; i++) {
-      //if ((*zVal)[i] > maxVal) (*z)[i]= d_nan;
-      //	}
-      //}
-      
-      //      gkw_linestyle(e, actStream);
-      //actStream->lsty(2);
-      //
-      // AC 18 juin 2007 LineStyle and contour
-      // NOT READY NOW
-      // here we plot the axis 
-      // actStream->cont(z, xEl, yEl, 1, xEl, 1, yEl, 
-      //		      clevel, 0, mypltr, static_cast<void*>( spa));
-      // we recover the linestyle if a !p.linestyle does exist
-      //gkw_linestyle_c(e, actStream, TRUE);
-
-
-      if (e->KeywordSet( "FILL")) {
-	// the "clevel_fill, nlevel_fill" have been computed before
-        actStream->shades(z, xEl, yEl, NULL, xStart, xEnd, yStart, yEnd,
- 			  clevel_fill, nlevel_fill, 2, 0, 0, plstream::fill,
-                          mapSet, mypltr, static_cast<void*>(&passinfo));
-	
-	gkw_color(e, actStream);//needs to be called again or else PS files look wrong
-	// Redraw the axes just in case the filling overlaps them
-	//actStream->box( xOpt.c_str(), xintv, xMinor, "", 0.0, 0);
-	//actStream->box( "", 0.0, 0, yOpt.c_str(), yintv, yMinor);
-	// pen thickness for axis
-	actStream->wid(charthick);
-      } else {
-        if (e->GetKW(c_colorsIx) != NULL)
-        {
-          DLongGDL *colors = e->GetKWAs<DLongGDL>(c_colorsIx);
-          for (SizeT i = 0; i < nlevel; ++i) 
-          { 
-            actStream->Color((*colors)[i % colors->N_Elements()], true, 2);
-            actStream->cont(z, xEl, yEl, 1, xEl, 1, yEl, &(clevel[i]), 1, mypltr, static_cast<void*>(&passinfo));
-          }
-        }
-        else
-        {
-          actStream->cont(z, xEl, yEl, 1, xEl, 1, yEl, clevel, nlevel, mypltr, static_cast<void*>(&passinfo));
-        }
-      }
-      delete[] z;
-    }
-    else if (xVal->Rank() == 2 && yVal->Rank() == 2) 
-    {
-      // FIXME: mapping not supported here yet
-      
-      PLcGrid2 cgrid2;
-      actStream->Alloc2dGrid(&cgrid2.xg,xVal->Dim(0),xVal->Dim(1));
-      actStream->Alloc2dGrid(&cgrid2.yg,xVal->Dim(0),xVal->Dim(1));
-      cgrid2.nx = xVal->Dim(0);
-      cgrid2.ny = xVal->Dim(1);
-
-      for( SizeT i=0; i<xVal->Dim(0); i++) {
-	for( SizeT j=0; j<xVal->Dim(1); j++) {
- 	  cgrid2.xg[i][j] = (*xVal)[j*(xVal->Dim(0))+i];
-	  cgrid2.yg[i][j] = (*yVal)[j*(xVal->Dim(0))+i];
-	}
-      }
-
-      PLFLT** z = new PLFLT*[xVal->Dim(0)];
-      for( SizeT i=0; i<xVal->Dim(0); i++) z[i] = &(*zVal)[i*xVal->Dim(1)];
-
-      for( SizeT i=0; i<xVal->Dim(0)*xVal->Dim(1); i++) {
-	if (isinf((*zVal)[i])) (*z)[i]= d_nan;
-      }
-
-      if (e->KeywordSet( "FILL")) {
-	// the "clevel_fill, nlevel_fill" have been computed before
-        actStream->shades(z, xVal->Dim(0), xVal->Dim(1), 
-			  NULL, xStart, xEnd, yStart, yEnd,
- 			  clevel_fill, nlevel_fill, 2, 0, 0, plstream::fill,
-			  false, plstream::tr2, (void *) &cgrid2 );
-
-	gkw_color(e, actStream);//needs to be called again or else PS files look wrong
-	// Redraw the axes just in case the filling overlaps them
-	//actStream->box( xOpt.c_str(), xintv, xMinor, "", 0.0, 0);
-	//actStream->box( "", 0.0, 0, yOpt.c_str(), yintv, yMinor);
-	// pen thickness for axis
-	actStream->wid(charthick);
-      } else {	      
-        if (e->GetKW(c_colorsIx) != NULL)
-        {
-          DLongGDL *colors = e->GetKWAs<DLongGDL>(c_colorsIx);
-          for (SizeT i = 0; i < nlevel; ++i) 
-          { 
-            actStream->Color((*colors)[i % colors->N_Elements()], true, 2);
-	    actStream->cont(z, xVal->Dim(0), xVal->Dim(1), 1, xVal->Dim(0), 1, xVal->Dim(1), &(clevel[i]), 1, plstream::tr2, (void *) &cgrid2);
-          }
-        }
-        else
-        {
-	  actStream->cont(z, xVal->Dim(0), xVal->Dim(1), 1, xVal->Dim(0), 1, xVal->Dim(1), clevel, nlevel, plstream::tr2, (void *) &cgrid2);
-        }
-      }
-      actStream->Free2dGrid(cgrid2.xg,xVal->Dim(0),xVal->Dim(1));
-      actStream->Free2dGrid(cgrid2.yg,xVal->Dim(0),xVal->Dim(1));
-
-      // AC june 07 : symetry for the previous case
-      delete[] z;
-    }
-
-    //Draw axes after the data because /fill could potentially overlap the axes.
-    //... if keyword "OVERPLOT" is not set
-    if (!overplot) 
-    {
-      gkw_background(e, actStream);  //BACKGROUND
-      gkw_color(e, actStream);       //COLOR
-
-      // pen thickness for axis
-      actStream->wid( 0);
-
-      // axis
-      string xOpt = "bcnst";
-      string yOpt = "bcnstv";
-
-      DString xTickformat, yTickformat;
-      e->AssureStringScalarKWIfPresent( "XTICKFORMAT", xTickformat);
-      e->AssureStringScalarKWIfPresent( "YTICKFORMAT", yTickformat);
-      AdjustAxisOpts(xOpt, yOpt, xStyle, yStyle, xTicks, yTicks, xTickformat, yTickformat, xLog, yLog);
-
-      // axis titles
-      actStream->schr( 0.0, actH/defH * xCharSize);
-      actStream->mtex("b",3.5,0.5,0.5,xTitle.c_str());
-
-      // the axis (separate for x and y axis because of charsize)
-      PLFLT xintv;
-      if (xTicks == 0) {
-        xintv = AutoTick(xEnd-xStart);
-      } else {
-        xintv = (xEnd - xStart) / xTicks;
-      }
-      //Draw axis if keyword "OVERPLOT" is not set
-      actStream->box( xOpt.c_str(), xintv, xMinor, "", 0.0, 0);
-      actStream->schr( 0.0, actH/defH * yCharSize);
-      actStream->mtex("l",5.0,0.5,0.5,yTitle.c_str());
-
-      // the axis (separate for x and y axis because of charsize)
-      PLFLT yintv;
-      if (yTicks == 0) {
-        yintv = AutoTick(yEnd-yStart);
-      } else {
-        yintv = (yEnd - yStart) / yTicks;
-      }
-      actStream->box( "", 0.0, 0, yOpt.c_str(), yintv, yMinor);
-
-      // title and sub title
-      actStream->schr( 0.0, 1.25*actH/defH);
-      actStream->mtex("t",1.25,0.5,0.5,title.c_str());
-      actStream->schr( 0.0, actH/defH); // charsize is reset here
-      actStream->mtex("b",5.4,0.5,0.5,subTitle.c_str());
-
-    }
-  } // }}}
-
-    private: void call_plplot(EnvT* e, GDLGStream* actStream) // {{{
-    {
-    } // }}}
-
-    private: virtual void post_call(EnvT*, GDLGStream* actStream) // {{{
-    {
-      UpdateSWPlotStructs(actStream, xStart, xEnd, yStart, yEnd, xLog, yLog);
-
-      actStream->lsty(1);//reset linestyle
-
-      if (!overplot)
-      {
-        // set ![XY].CRANGE
-        set_axis_crange("X", xStart, xEnd, xLog);
-        set_axis_crange("Y", yStart, yEnd, yLog);
-
-        //set ![x|y].type
-        set_axis_type("X",xLog);
-        set_axis_type("Y",yLog);
-      }
-    } // }}}
-
-  }; // contour_call class
-
-  void contour(EnvT* e)
-  {
-    contour_call contour;
-    contour.call(e, 1);
-  }
-  
-} // namespace
+/***************************************************************************
+                       plotting.cpp  -  GDL routines for plotting
+                             -------------------
+    begin                : July 22 2002
+    copyright            : (C) 2002-2011 by Marc Schellens et al.
+    email                : m_schellens@users.sf.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "includefirst.hpp"
+#include "plotting.hpp"
+#include "math_utl.hpp"
+
+#define LABELOFFSET 0.003
+#define LABELSPACING 0.25
+
+namespace lib
+{
+
+  using namespace std;
+
+// shared parameter
+  static bool xLog;
+  static bool yLog;
+
+  PLINT doIt( PLFLT x, PLFLT y )
+  {
+    if (xLog && x<=0 ) return 0;
+    if (yLog && y<=0 ) return 0;
+    return 1;
+  }
+
+  class contour_call: public plotting_routine_call
+  {
+
+    DDoubleGDL *zVal, *yVal, *xVal;
+    Guard<BaseGDL> xval_guard, yval_guard, p0_guard;
+    DDoubleGDL *yValTemp, *xValTemp;
+    Guard<BaseGDL> xval_temp_guard, yval_temp_guard;
+    SizeT xEl, yEl, zEl;
+    DDouble xStart, xEnd, yStart, yEnd, zStart, zEnd, datamax, datamin;
+    bool zLog, isLog;
+    bool overplot, make2dBox, make3dBox, nodata;
+    DLongGDL *colors,*thick,*labels,*style;
+    Guard<BaseGDL> colors_guard,thick_guard,labels_guard,style_guard;
+    DFloatGDL *spacing,*orientation;
+    Guard<BaseGDL> spacing_guard,orientation_guard;
+    bool doT3d;
+    bool irregular;
+
+    //PATH_XY etc: use actStream->stransform with a crafted recording function per level [lev-maxmax].
+    //disentangle positive and negative contours with their rotation signature.
+  private:
+    bool handle_args (EnvT* e)
+    {
+      static int irregIx = e->KeywordIx( "IRREGULAR");
+      irregular=e->KeywordSet(irregIx);
+      if ( nParam ( )==1 )
+      {
+        BaseGDL* p0=e->GetNumericArrayParDefined ( 0 )->Transpose ( NULL );
+
+        zVal=static_cast<DDoubleGDL*>
+        ( p0->Convert2 ( GDL_DOUBLE, BaseGDL::COPY ) );
+        p0_guard.Init ( p0 ); // delete upon exit
+
+        xEl=zVal->Dim ( 1 );
+        yEl=zVal->Dim ( 0 );
+
+        if ( zVal->Rank ( )!=2 )
+          e->Throw ( "Array must have 2 dimensions: "
+                     +e->GetParString ( 0 ) );
+
+        xVal=new DDoubleGDL ( dimension ( xEl ), BaseGDL::INDGEN );
+        xval_guard.Init ( xVal ); // delete upon exit
+        yVal=new DDoubleGDL ( dimension ( yEl ), BaseGDL::INDGEN );
+        yval_guard.Init ( yVal ); // delete upon exit
+      }
+      else if ( nParam ( )==2||nParam ( )>3 )
+      {
+        e->Throw ( "Incorrect number of arguments." );
+      }
+      else if (irregular)
+      {
+        //ZVal will be treated as 1 dim array and X and Y must have the same number of elements.
+          BaseGDL* p0=e->GetNumericArrayParDefined ( 0 )->Transpose ( NULL );
+          zVal=static_cast<DDoubleGDL*>
+          ( p0->Convert2 ( GDL_DOUBLE, BaseGDL::COPY ) );
+          p0_guard.Init( p0 ); // delete upon exit
+        xValTemp=e->GetParAs< DDoubleGDL>( 1 );
+        yValTemp=e->GetParAs< DDoubleGDL>( 2 );
+
+        if (xValTemp->N_Elements() != zVal->N_Elements() )
+          e->Throw ( "X, Y, or Z array dimensions are incompatible." );
+        if (yValTemp->N_Elements() != zVal->N_Elements() )
+          e->Throw ( "X, Y, or Z array dimensions are incompatible." );
+        //x-y ranges:
+        DDouble xmin,xmax,ymin,ymax;
+        GetMinMaxVal ( xValTemp, &xmin, &xmax );
+        GetMinMaxVal ( yValTemp, &ymin, &ymax );
+        xEl=xValTemp->N_Elements()+1;
+        yEl=yValTemp->N_Elements()+1; //all points inside
+        xVal=new DDoubleGDL ( dimension ( xEl ), BaseGDL::NOZERO );
+        yVal=new DDoubleGDL ( dimension ( yEl ), BaseGDL::NOZERO );
+        for(SizeT i=0; i<xEl; ++i) (*xVal)[i]=xmin+(i-0.5)*(xmax-xmin)/xEl;
+        for(SizeT i=0; i<yEl; ++i) (*yVal)[i]=ymin+(i-0.5)*(ymax-ymin)/yEl;
+
+      }
+      else
+      {
+        BaseGDL* p0=e->GetNumericArrayParDefined ( 0 )->Transpose ( NULL );
+        zVal=static_cast<DDoubleGDL*>
+        ( p0->Convert2 ( GDL_DOUBLE, BaseGDL::COPY ) );
+        p0_guard.Init( p0 ); // delete upon exit
+
+        if ( zVal->Dim ( 0 )==1 )
+          e->Throw ( "Array must have 2 dimensions: "
+                     +e->GetParString ( 0 ) );
+
+        xVal=e->GetParAs< DDoubleGDL>( 1 );
+        yVal=e->GetParAs< DDoubleGDL>( 2 );
+
+        if ( xVal->Rank ( )>2 )
+          e->Throw ( "X, Y, or Z array dimensions are incompatible." );
+
+        if ( yVal->Rank ( )>2 )
+          e->Throw ( "X, Y, or Z array dimensions are incompatible." );
+        if ( xVal->Rank ( )==0 || yVal->Rank ( )==0 ) e->Throw ( "X, Y, or Z array dimensions are incompatible." );
+
+        if ( xVal->Rank ( )==1 )
+        {
+          xEl=xVal->Dim ( 0 );
+
+          if ( xEl!=zVal->Dim ( 1 ) )
+            e->Throw ( "X, Y, or Z array dimensions are incompatible." );
+        }
+
+        if ( yVal->Rank ( )==1 )
+        {
+          yEl=yVal->Dim ( 0 );
+
+          if ( yEl!=zVal->Dim ( 0 ) )
+            e->Throw ( "X, Y, or Z array dimensions are incompatible." );
+        }
+
+        if ( xVal->Rank ( )==2 )
+        {
+          xEl=xVal->Dim ( 0 );
+          if ( ( xVal->Dim ( 0 )!=zVal->Dim ( 1 ) )&&( xVal->Dim ( 1 )!=zVal->Dim ( 0 ) ) )
+            e->Throw ( "X, Y, or Z array dimensions are incompatible." );
+        }
+
+        if ( yVal->Rank ( )==2 )
+        {
+          yEl=yVal->Dim ( 1 );
+          if ( ( yVal->Dim ( 0 )!=zVal->Dim ( 1 ) )&&( yVal->Dim ( 1 )!=zVal->Dim ( 0 ) ) )
+            e->Throw ( "X, Y, or Z array dimensions are incompatible." );
+        }
+      }
+
+      GetMinMaxVal ( xVal, &xStart, &xEnd );
+      GetMinMaxVal ( yVal, &yStart, &yEnd );
+      //XRANGE and YRANGE overrides all that, but  Start/End should be recomputed accordingly
+      DDouble xAxisStart, xAxisEnd, yAxisStart, yAxisEnd;
+      bool setx=gdlGetDesiredAxisRange(e, "X", xAxisStart, xAxisEnd);
+      bool sety=gdlGetDesiredAxisRange(e, "Y", yAxisStart, yAxisEnd);
+      if(setx && sety)
+      {
+        xStart=xAxisStart;
+        xEnd=xAxisEnd;
+        yStart=yAxisStart;
+        yEnd=yAxisEnd;
+      }
+      else if (sety)
+      {
+        yStart=yAxisStart;
+        yEnd=yAxisEnd;
+        //must compute min-max for other axis!
+        {
+          gdlDoRangeExtrema(yVal,xVal,xStart,xEnd,yStart,yEnd);
+        }
+      }
+      else if (setx)
+      {
+        xStart=xAxisStart;
+        xEnd=xAxisEnd;
+        //must compute min-max for other axis!
+        {
+          gdlDoRangeExtrema(xVal,yVal,yStart,yEnd,xStart,xEnd);
+        }
+      }
+      // z range
+      datamax=0.0;
+      datamin=0.0;
+      GetMinMaxVal ( zVal, &datamin, &datamax );
+      zStart=datamin;
+      zEnd=datamax;
+      gdlGetDesiredAxisRange(e, "Z", zStart, zEnd);
+
+      return false;
+    }
+
+  private:
+
+    void old_body (EnvT* e, GDLGStream* actStream) // {{{
+    {
+      // we need to define the NaN value
+      static DStructGDL *Values=SysVar::Values ( );
+      static DDouble d_nan=( *static_cast<DDoubleGDL*> ( Values->GetTag ( Values->Desc ( )->TagIndex ( "D_NAN" ), 0 ) ) )[0];
+      static DDouble minmin=gdlAbsoluteMinValueDouble();
+      static DDouble maxmax=gdlAbsoluteMaxValueDouble();
+      //for 3D
+      DDoubleGDL* plplot3d;
+      DDouble az, alt, ay, scale;
+      ORIENTATION3D axisExchangeCode;
+
+      //projection: would work only with 2D X and Y.
+      bool mapSet=false;
+#ifdef USE_LIBPROJ4
+      static LPTYPE idata;
+      static XYTYPE odata;
+      static PROJTYPE* ref;
+      get_mapset ( mapSet );
+      if ( mapSet )
+      {
+        ref=map_init ( );
+        if ( ref==NULL ) e->Throw ( "Projection initialization failed." );
+      }
+#endif
+      //T3D
+      static int t3dIx = e->KeywordIx( "T3D");
+      doT3d=e->KeywordSet(t3dIx);
+      //ZVALUE
+      static int zvIx = e->KeywordIx( "ZVALUE");
+      DDouble zValue=0.0;
+      bool hasZvalue=false;
+      if( e->KeywordPresent(zvIx))
+      {
+        e->AssureDoubleScalarKW( zvIx, zValue );
+        zValue=min(zValue,0.999999); //to avoid problems with plplot
+        zValue=max(zValue,0.0);
+        hasZvalue=true;
+      }
+      //NODATA
+      int nodataIx = e->KeywordIx( "NODATA");
+      nodata=e->KeywordSet(nodataIx);
+      //We could RECORD PATH this way. Not developed since PATH_INFO seems not to be used
+      bool recordPath;
+      int pathinfoIx = e->KeywordIx( "PATH_INFO");
+      int pathxyIx= e->KeywordIx( "PATH_XY");
+      recordPath=(e->KeywordSet(pathinfoIx)||e->KeywordSet(pathxyIx));
+      if (recordPath)
+      {
+        Warning( "PATH_INFO, PATH_XY not yet supported, (FIXME)");
+        recordPath=false;
+      }
+      //recordPath--> use actStream->stransform(myrecordingfunction, &data);
+      //ISOTROPIC
+      DLong iso=0;
+      e->AssureLongScalarKWIfPresent( "ISOTROPIC", iso);
+
+      // [XY]STYLE
+      DLong xStyle=0, yStyle=0, zStyle=0; ;
+      gdlGetDesiredAxisStyle(e, "X", xStyle);
+      gdlGetDesiredAxisStyle(e, "Y", yStyle);
+      gdlGetDesiredAxisStyle(e, "Z", zStyle);
+
+      // MARGIN
+      DFloat xMarginL, xMarginR, yMarginB, yMarginT, zMarginF, zMarginB;
+      gdlGetDesiredAxisMargin(e, "X", xMarginL, xMarginR);
+      gdlGetDesiredAxisMargin(e, "Y", yMarginB, yMarginT);
+      gdlGetDesiredAxisMargin(e, "Z", zMarginF, zMarginB);
+
+      xLog=e->KeywordSet ( "XLOG" );
+      yLog=e->KeywordSet ( "YLOG" );
+      if (xLog || yLog) isLog=true; else isLog=false;
+      zLog=e->KeywordSet ( "ZLOG" );
+
+      if ( ( xStyle&1 )!=1 )
+      {
+        PLFLT intv=AutoIntvAC ( xStart, xEnd, xLog );
+      }
+
+      if ( ( yStyle&1 )!=1 )
+      {
+        PLFLT intv=AutoIntvAC ( yStart, yEnd, yLog );
+      }
+
+      bool hasMinVal=e->KeywordPresent("MIN_VALUE");
+      bool hasMaxVal=e->KeywordPresent("MAX_VALUE");
+      DDouble minVal=datamin;
+      DDouble maxVal=datamax;
+      e->AssureDoubleScalarKWIfPresent ( "MIN_VALUE", minVal );
+      e->AssureDoubleScalarKWIfPresent ( "MAX_VALUE", maxVal );
+
+      // then only apply expansion  of axes:
+      if ( ( zStyle&1 )!=1 )
+      {
+        PLFLT intv=AutoIntvAC ( zStart, zEnd, zLog );
+      }
+
+      //OVERPLOT: get stored range values instead to use them!
+      static int overplotKW=e->KeywordIx ( "OVERPLOT" );
+      overplot=e->KeywordSet(overplotKW);
+      make2dBox=(!overplot&&!doT3d);
+      make3dBox=(!overplot&& doT3d);
+
+      if (overplot) //retrieve information in case they are not in the command line ans apply
+                    // some computation (alas)!
+      {
+        gdlGetAxisType("X", xLog);
+        gdlGetAxisType("Y", yLog);
+        gdlGetAxisType("Z", zLog);
+        gdlGetCurrentAxisRange("X", xStart, xEnd);
+        gdlGetCurrentAxisRange("Y", yStart, yEnd);
+        gdlGetCurrentAxisRange("Z", zStart, zEnd); //we should memorize the number of levels!
+      }
+
+      static DDouble x0,y0,xs,ys; //conversion to normalized coords
+      x0=(xLog)?-log10(xStart):-xStart;
+      y0=(yLog)?-log10(yStart):-yStart;
+      xs=(xLog)?(log10(xEnd)-log10(xStart)):xEnd-xStart;xs=1.0/xs;
+      ys=(yLog)?(log10(yEnd)-log10(yStart)):yEnd-yStart;ys=1.0/ys;
+
+      //optimization below?
+      if ( minVal>zEnd || maxVal<zStart) nodata=true; //do not complain but do nothing.
+
+      if(!overplot) {
+        // background BEFORE next plot since it is the only place plplot may redraw the background...
+        gdlSetGraphicsBackgroundColorFromKw ( e, actStream ); //BACKGROUND
+        gdlNextPlotHandlingNoEraseOption(e, actStream);     //NOERASE
+      }
+
+      if(make2dBox) {       //start a plot
+        // viewport and world coordinates
+        // use POSITION
+        int positionIx = e->KeywordIx( "POSITION");
+        DFloatGDL* boxPosition = e->IfDefGetKWAs<DFloatGDL>( positionIx);
+        if (boxPosition == NULL) boxPosition = (DFloatGDL*) 0xF;
+        // set the PLOT charsize before computing box, see plot command.
+        gdlSetPlotCharsize(e, actStream);
+        if ( gdlSetViewPortAndWorldCoordinates(e, actStream, boxPosition,
+        xLog, yLog,
+        xMarginL, xMarginR, yMarginB, yMarginT,
+        xStart, xEnd, yStart, yEnd, iso)==FALSE ) return; //no good: should catch an exception to get out of this mess.
+      }
+
+      if (doT3d) {
+        plplot3d = gdlConvertT3DMatrixToPlplotRotationMatrix( zValue, az, alt, ay, scale, axisExchangeCode);
+        if (plplot3d == NULL)
+        {
+          e->Throw("Illegal 3D transformation. (FIXME)");
+        }
+
+        Data3d.zValue = zValue;
+        Data3d.Matrix = plplot3d; //try to change for !P.T in future?
+
+        switch (axisExchangeCode) {
+          case NORMAL: //X->X Y->Y plane XY
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code012;
+            break;
+          case XY: // X->Y Y->X plane XY
+            Data3d.x0=0;
+            Data3d.y0=x0;
+            Data3d.xs=ys;
+            Data3d.ys=xs;
+            Data3d.code = code102;
+            break;
+          case XZ: // Y->Y X->Z plane YZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code210;
+            break;
+          case YZ: // X->X Y->Z plane XZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code021;
+            break;
+          case XZXY: //X->Y Y->Z plane YZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code120;
+            break;
+          case XZYZ: //X->Z Y->X plane XZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code201;
+            break;
+        }
+
+        //necessary even if overplot
+        // set the PLOT charsize before computing box, see plot command.
+        gdlSetPlotCharsize(e, actStream);
+        if (gdlSet3DViewPortAndWorldCoordinates(e, actStream, plplot3d, xLog, yLog,
+        xStart, xEnd, yStart, yEnd, zStart, zEnd, zLog) == FALSE) return;
+        //start 3D->2D coordinate conversions in plplot
+        actStream->stransform(gdl3dTo2dTransformContour, &Data3d);
+      }
+
+
+
+      gdlSetPlotCharthick(e,actStream);
+
+      if ( xLog && xStart<=0.0 ) Warning ( "CONTOUR: Infinite x plot range." );
+      if ( yLog && yStart<=0.0 ) Warning ( "CONTOUR: Infinite y plot range." );
+      if ( zLog && zStart<=0.0 ) Warning ( "CONTOUR: Infinite z plot range." );
+
+      // labeling
+      // initiated by /FOLLOW.
+      // C_ANNOTATION=vector of strings:  strings replace the default numerical values. Implies FOLLOW. Impossible with PLPLOT!
+      // C_CHARSIZE. IDL doc false: c_charsize independent from /CHARSIZE. Charsize should be 3/4 size of AXIS LABELS,
+      // but in fact c_charsize is independent from all [XYZ]charsize setups. Implies FOLLOW.
+      // C_CHARTHICK Implies FOLLOW.
+      // C_COLORS=vector, (eventually converted to integer), give color index. repated if less than contours.
+      // C_LABELS=vector of 0 and 1 (float, double, int) . Implies FOLLOW.
+      // C_LINESTYLE =vector of linestyles. Defaults to !P.LINESTYLE
+      // C_ORIENTATION = vector of angles of lines to  FILL (needs FILL KW) .
+      // C_SPACING= vector of spacing in CENTIMETRES of lines to  FILL (needs FILL KW) .
+      // if C_SPACING and C_ORIENTATION absent, FILL will do a solid fill .
+      // C_THICK=vector of thickness. repated if less than contours. defaults to !P.THICK or THICK
+
+      bool label=( e->KeywordSet ( "FOLLOW" ) || e->KeywordSet ( "C_CHARSIZE" ) || e->KeywordSet("C_CHARTHICK") || e->KeywordSet("C_LABELS") );
+      bool fill=( e->KeywordSet("FILL") || e->KeywordSet ("C_SPACING") || e->KeywordSet ("C_ORIENTATION") );
+      if (fill) label=false; //mutually exclusive
+      if (recordPath) {fill=true;}
+
+      // managing the levels list OR the nlevels value
+      // LEVELS=vector_of_values_in_increasing_order
+      // NLEVELS=[1..60]
+      PLINT nlevel;
+      PLFLT *clevel;
+      ArrayGuard<PLFLT> clevel_guard;
+      static int levelsix=e->KeywordIx ( "LEVELS" );
+      BaseGDL* b_levels=e->GetKW ( levelsix );
+      if ( b_levels!=NULL )
+      {
+        DDoubleGDL* d_levels=e->GetKWAs<DDoubleGDL>( levelsix );
+        nlevel=d_levels-> N_Elements ( );
+        clevel=( PLFLT * ) &( *d_levels )[0];
+        // are the levels ordered ?
+        for ( SizeT i=1; i<nlevel; i++ )
+        {
+          if ( clevel[i]<=clevel[i-1] )
+            e->Throw ( "Contour levels must be in increasing order." );
+        }
+      }
+      else
+      {
+        PLFLT zintv;
+        // Jo: added keyword NLEVELS
+        if ( e->KeywordSet ( "NLEVELS" ) )
+        {
+          DLong l_nlevel=nlevel; // GCC 3.4.4 needs that
+          e->AssureLongScalarKWIfPresent ( "NLEVELS", l_nlevel );
+          nlevel=l_nlevel;
+          if ( nlevel<0) nlevel=2; //as IDL
+          if (nlevel==0) nlevel=3; //idem
+
+          // cokhavim: IDL does this...
+          zintv=(PLFLT) ( ( zEnd-zStart )/( nlevel+1 ) );
+          //gd: we can support ZLOG as well:
+          if (zLog) zintv=(PLFLT) ( ( log10(zEnd)-log10(zStart )) / ( nlevel+1 ) );
+
+        }
+        else
+        {
+          zintv=AutoTick ( zEnd-zStart ); if (zLog) zintv=AutoTick ( log10(zEnd)-log10(zStart) );
+          nlevel=(PLINT) floor ( ( zEnd-zStart )/zintv ); if (zLog) nlevel=(PLINT) floor ( ( log10(zEnd)-log10(zStart) )/zintv );
+          // SA: sanity check to prevent segfaults, e.g. with solely non-finite values
+          if ( zintv==0||nlevel<0 ) nlevel=0;
+        }
+
+        if (fill)
+        {
+          nlevel=nlevel+1;
+        }
+        clevel=new PLFLT[nlevel];
+        clevel_guard.Reset ( clevel );
+        //IDL does this:
+        for( SizeT i=1; i<=nlevel; i++) clevel[i-1] = zintv * i + zStart;
+        if (zLog) for( SizeT i=1; i<=nlevel; i++) clevel[i-1] = pow(10.0,(log10(zStart)+zintv*i));
+      }
+
+      // set label params always since they are not forgotten by plplot.'label' tells if they should be used.
+      // IDL default: 3/4 of the axis charsize (CHARSIZE keyword or !P.CHARSIZE)
+      // PlPlot default: .3
+      // should be: DFloat label_size=.75*actStream->charScale(); however IDL doc false.
+      DFloat label_size=0.9; //IDL behaviour, IDL doc false.
+      if ( e->KeywordSet ( "C_CHARSIZE" ) ) e->AssureFloatScalarKWIfPresent ( "C_CHARSIZE", label_size );
+      actStream->setcontlabelparam ( LABELOFFSET, (PLFLT) label_size, LABELSPACING, (label)?1:0 );
+      actStream->setcontlabelformat (3, 3 );
+
+      // PLOT ONLY IF NODATA=0
+      if (!nodata)
+      {
+        //use of intermediate map for correct handling of blanking values and nans. We take advantage of the fact that
+        //this program makes either filled regions with plshades() [but plshades hates Nans!] or contours with plcont,
+        //which needs Nans to avoid blanked regions. The idea is to mark unwanted regions with Nans for plcont, and
+        //with a blanking value (minmin) for plshade. Eventually one could use a zdefined() function testing on top of it.
+        PLFLT ** map;
+        actStream->Alloc2dGrid( &map, xEl, yEl);
+
+        if (irregular)
+        {
+          PLFLT data=0;
+          actStream->griddata(&(*xValTemp)[0],&(*yValTemp)[0],&(*zVal)[0],xEl-1,
+              &(*xVal)[0],xEl,&(*yVal)[0],yEl,map,GRID_DTLI,data);
+          for ( SizeT i=0, k=0; i<xEl; i++ )
+          {
+            for ( SizeT j=0; j<yEl; j++)
+            {
+              PLFLT v=map[i][j];
+              if ( !isfinite(v) ) v=(fill)?minmin:d_nan; //note: nan regions could eventually be filled.
+              if ( hasMinVal && v < minVal) v=(fill)?minmin:d_nan;
+              if ( hasMaxVal && v > maxVal) v=(fill)?maxmax:d_nan;
+              map[i][j] = v;
+            }
+          }
+
+        }else{
+          for ( SizeT i=0, k=0; i<xEl; i++ )
+          {
+            for ( SizeT j=0; j<yEl; j++)
+            {
+              PLFLT v=( *zVal )[k++];
+              if ( !isfinite(v) ) v=(fill)?minmin:d_nan; //note: nan regions could eventually be filled.
+              if ( hasMinVal && v < minVal) v=(fill)?minmin:d_nan;
+              if ( hasMaxVal && v > maxVal) v=(fill)?minmin:d_nan;
+              map[i][j] = v;
+            }
+          }
+        }
+        // provision for 2 types of grids.
+        PLcGrid cgrid1; // X and Y independent deformation
+        PLFLT* xg1;
+        PLFLT* yg1;
+        PLcGrid2 cgrid2; // Dependent X Y (e.g., rotation)
+        bool tidyGrid1WorldData=false;
+        bool tidyGrid2WorldData=false;
+        bool oneDim=true;
+        // the Grids:
+        // 1 DIM X & Y
+        if ( xVal->Rank ( )==1&&yVal->Rank ( )==1 )
+        {
+          oneDim=true;
+          xg1 = new PLFLT[xEl];
+          yg1 = new PLFLT[yEl];
+          cgrid1.xg = xg1;
+          cgrid1.yg = yg1;
+          cgrid1.nx = xEl;
+          cgrid1.ny = yEl;
+          for ( SizeT i=0; i<xEl; i++ ) cgrid1.xg[i] = (*xVal)[i];
+          for ( SizeT i=0; i<yEl; i++ ) cgrid1.yg[i] = (*yVal)[i];
+          //apply plot options transformations:
+          if (xLog) for ( SizeT i=0; i<xEl; i++ ) cgrid1.xg[i] = cgrid1.xg[i]>0?log10(cgrid1.xg[i]):1E-12;  // #define EXTENDED_DEFAULT_LOGRANGE 12
+          if (yLog) for ( SizeT i=0; i<yEl; i++ ) cgrid1.yg[i] = cgrid1.yg[i]>0?log10(cgrid1.yg[i]):1E-12;
+          tidyGrid1WorldData=true;
+        }
+        else //if ( xVal->Rank ( )==2&&yVal->Rank ( )==2 )
+        {
+          oneDim=false;
+
+          actStream->Alloc2dGrid ( &cgrid2.xg, xEl, yEl );
+          actStream->Alloc2dGrid ( &cgrid2.yg, xEl, yEl );
+          tidyGrid2WorldData=true;
+          cgrid2.nx=xEl;
+          cgrid2.ny=yEl;
+          //create 2D grid
+          for ( SizeT i=0; i<xEl; i++ )
+          {
+            for ( SizeT j=0; j<yEl; j++ )
+            {
+              cgrid2.xg[i][j]=(*xVal)[j*( xEl )+i];
+              cgrid2.yg[i][j]=(*yVal)[j*( xEl )+i];
+            }
+          }
+          //apply projection transformations:
+#ifdef USE_LIBPROJ4
+          if ( mapSet )
+          {
+            for ( SizeT i=0; i<xEl; i++ )
+            {
+              for ( SizeT j=0; j<yEl; j++ )
+              {
+                idata.lam= cgrid2.xg[i][j] * DEG_TO_RAD;
+                idata.phi= cgrid2.yg[i][j] * DEG_TO_RAD;
+                odata=PJ_FWD ( idata, ref );
+                cgrid2.xg[i][j]=odata.x;
+                cgrid2.yg[i][j]=odata.y;
+              }
+            }
+          }
+#endif
+          //apply plot options transformations:
+          if (xLog) for ( SizeT i=0; i<xEl; i++ ) for ( SizeT j=0; j<yEl; j++ )
+          {
+            cgrid2.xg[i][j]=(cgrid2.xg[i][j]>0)?log10(cgrid2.xg[i][j]):1E-12;
+          }
+          if (yLog) for ( SizeT i=0; i<xEl; i++ ) for ( SizeT j=0; j<yEl; j++ )
+          {
+            cgrid2.yg[i][j]=(cgrid2.yg[i][j]>0)?log10(cgrid2.yg[i][j]):1E-12;
+          }
+        }
+
+        // Graphic options
+        // C_COLORS=vector, (eventually converted to integer), give color index. repated if less than contours.
+        // C_LABELS=vector of 0 and 1 (float, double, int) . Implies FOLLOW.
+        // C_LINESTYLE =vector of linestyles. Defaults to !P.LINESTYLE
+        // C_THICK=vector of thickness. repated if less than contours. defaults to !P.THICK or THICK
+        int c_colorsIx=e->KeywordIx ( "C_COLORS" ); bool docolors=false;
+        int c_linestyleIx=e->KeywordIx ( "C_LINESTYLE" ); bool dostyle=false;
+        int c_thickIx=e->KeywordIx ( "C_THICK" ); bool dothick=false;
+        int c_labelsIx=e->KeywordIx ( "C_LABELS" ); bool dolabels=false;
+        int c_orientationIx=e->KeywordIx ( "C_ORIENTATION" ); bool doori=false;
+        int c_spacingIx=e->KeywordIx ( "C_SPACING" ); bool dospacing=false;
+        if ( e->GetKW ( c_colorsIx )!=NULL )
+        {
+          colors=e->GetKWAs<DLongGDL>( c_colorsIx ); docolors=true;
+        }
+        if ( e->GetKW ( c_thickIx )!=NULL )
+        {
+          thick=e->GetKWAs<DLongGDL>( c_thickIx ); dothick=true;
+        }
+        if ( e->GetKW ( c_labelsIx )!=NULL )
+        {
+          labels=e->GetKWAs<DLongGDL>( c_labelsIx ); dolabels=true;
+        }
+        else //every other level
+        {
+          labels=new DLongGDL  ( dimension (2), BaseGDL::ZERO );
+          labels_guard.Init( labels);
+          (*labels)[0]=1;(*labels)[1]=0;
+          if (label) dolabels=true; //yes!
+        }
+        if ( e->GetKW ( c_linestyleIx )!=NULL )
+        {
+          style=e->GetKWAs<DLongGDL>( c_linestyleIx ); dostyle=true;
+        }
+        if ( e->GetKW ( c_orientationIx )!=NULL )
+        {
+          orientation=e->GetKWAs<DFloatGDL>( c_orientationIx ); doori=true;
+        }
+        else
+        {
+          orientation=new DFloatGDL  ( dimension (1), BaseGDL::ZERO );
+          orientation_guard.Init( orientation);
+          (*orientation)[0]=0;
+        }
+        if ( e->GetKW ( c_spacingIx )!=NULL )
+        {
+          spacing=e->GetKWAs<DFloatGDL>( c_spacingIx ); dospacing=true;
+        }
+        else
+        {
+          spacing=new DFloatGDL  ( dimension (1), BaseGDL::ZERO );
+          spacing_guard.Init(spacing);
+          (*spacing)[0]=0.25;
+        }
+        bool hachures=(dospacing || doori);
+        // Get decomposed value for colors
+        DLong decomposed=Graphics::GetDevice()->GetDecomposed();
+
+        // Important: make all clipping computations BEFORE setting graphic properties (color, size)
+        bool doClip=(e->KeywordSet("CLIP")||e->KeywordSet("NOCLIP"));
+        bool stopClip=false;
+        if ( doClip )  if ( startClipping(e, actStream, false)==TRUE ) stopClip=true;
+
+        if (fill) {
+          PLFLT colorindex_table_0_color=2;
+          PLFLT colorindex_table_1_color=0;
+          if (hachures) {
+            PLINT ori;
+            PLINT spa;
+
+            actStream->psty(1);
+            // C_ORIENTATION = vector of angles of lines to  FILL (needs FILL KW) .
+            // C_SPACING= vector of spacing in CENTIMETRES of lines to  FILL (needs FILL KW) .
+            // if C_SPACING and C_ORIENTATION absent, FILL will do a solid fill .
+            for ( SizeT i=0; i<nlevel-1; ++i ) {
+              if (doT3d & !hasZvalue) {
+                Data3d.zValue=clevel[i]/(zEnd-zStart);
+                actStream->stransform(gdl3dTo2dTransformContour, &Data3d);
+              }
+              ori=floor(10.0*(*orientation)[i%orientation->N_Elements()]);
+              spa=floor(10000*(*spacing)[i%spacing->N_Elements()]);
+              actStream->pat(1,&ori,&spa);
+
+              if (docolors) actStream->Color ( ( *colors )[i%colors->N_Elements ( )], decomposed, (PLINT)colorindex_table_0_color );
+              if (dothick) actStream->wid ( ( *thick )[i%thick->N_Elements ( )]);
+              if (dostyle) gdlLineStyle(actStream, ( *style )[i%style->N_Elements ( )]);
+              actStream->shade( map, xEl, yEl, isLog?doIt:NULL, xStart, xEnd, yStart, yEnd,
+              clevel[i], clevel[i+1],
+              0, colorindex_table_0_color, 1, //colorindex is an int passed as a double in case map0
+              0,0,0,0,
+              (plstream::fill), (oneDim),  //example of possible use of recordpath.
+              (oneDim)?(plstream::tr1):(plstream::tr2), (oneDim)?(void *)&cgrid1:(void *)&cgrid2);
+            }
+            actStream->psty(0);
+            if (docolors) gdlSetGraphicsForegroundColorFromKw ( e, actStream );
+            if (dothick) gdlSetPenThickness(e, actStream);
+            if (dostyle) gdlLineStyle(actStream, 0);
+          }
+          else  if (doT3d & !hasZvalue) {
+            for ( SizeT i=0; i<nlevel-1; ++i ) {
+                Data3d.zValue=clevel[i]/(zEnd-zStart);
+                colorindex_table_1_color=(PLFLT)i/PLFLT(nlevel-1);
+                actStream->stransform(gdl3dTo2dTransformContour, &Data3d);
+                actStream->shade( map, xEl, yEl, isLog?doIt:NULL,
+                xStart, xEnd, yStart, yEnd,
+                clevel[i], clevel[nlevel-1],
+                1, colorindex_table_1_color, 1,   //colorindex is a double [0.0..1.0] in case map1
+                0,0,0,0,
+                plstream::fill, (oneDim), //Onedim is accelerator since rectangles are kept rectangles see plplot doc
+                (oneDim)?(plstream::tr1):(plstream::tr2), (oneDim)?(void *)&cgrid1:(void *)&cgrid2);
+             }
+            if (docolors) gdlSetGraphicsForegroundColorFromKw ( e, actStream );
+          }
+          else {
+            //useful?
+            gdlSetGraphicsForegroundColorFromKw ( e, actStream );
+            // note that plshade is not protected against 1 level (color formula is
+            // "shade_color = color_min + i / (PLFLT) ( nlevel - 2 ) * color_range;"
+            // meaning that nlevel must be >2 for plshade!)
+            if (nlevel>2) {
+              actStream->shades( map, xEl, yEl, isLog?doIt:NULL, xStart, xEnd, yStart, yEnd,
+                                clevel, nlevel, 1, 0, 0, plstream::fill, (oneDim),
+                                (oneDim)?(plstream::tr1):(plstream::tr2),
+                                (oneDim)?(void *)&cgrid1:(void *)&cgrid2);
+            }
+            else  {
+              colorindex_table_1_color=0.5;
+              actStream->shade( map, xEl, yEl, isLog?doIt:NULL,
+              xStart, xEnd, yStart, yEnd,
+              clevel[0], clevel[1],
+              1,  colorindex_table_1_color , 1,
+              0,0,0,0,
+              plstream::fill, (oneDim), //Onedim is accelerator since rectangles are kept rectangles see plplot doc
+              (oneDim)?(plstream::tr1):(plstream::tr2), (oneDim)?(void *)&cgrid1:(void *)&cgrid2);
+            }
+            //useful?
+            gdlSetGraphicsForegroundColorFromKw ( e, actStream ); //needs to be called again or else PS files look wrong
+          }
+        }
+        else  {
+          //useful?
+          gdlSetGraphicsForegroundColorFromKw ( e, actStream );
+          gdlSetPenThickness(e, actStream);
+          gdlSetPlotCharsize(e, actStream);
+          for ( SizeT i=0; i<nlevel; ++i ) {
+            if (doT3d & !hasZvalue) {
+              Data3d.zValue=clevel[i]/(zEnd-zStart);
+              actStream->stransform(gdl3dTo2dTransformContour, &Data3d);
+            }
+            if (docolors) actStream->Color ( ( *colors )[i%colors->N_Elements ( )], decomposed, 2);
+            if (dothick) actStream->wid ( ( *thick )[i%thick->N_Elements ( )]);
+            if (dostyle) gdlLineStyle(actStream, ( *style )[i%style->N_Elements ( )]);
+            if (dolabels) actStream->setcontlabelparam ( LABELOFFSET, (PLFLT) label_size, LABELSPACING,
+                                                        (PLINT)(*labels)[i%labels->N_Elements()] );
+            actStream->cont ( map, xEl, yEl, 1, xEl, 1, yEl, &( clevel[i] ), 1,
+                (oneDim)?(plstream::tr1):(plstream::tr2), (oneDim)?(void *)&cgrid1:(void *)&cgrid2);
+          }
+          if (docolors) gdlSetGraphicsForegroundColorFromKw ( e, actStream );
+          if (dothick) gdlSetPenThickness(e, actStream);
+          if (dostyle) gdlLineStyle(actStream, 0);
+        }
+        if (tidyGrid2WorldData)
+        {
+          actStream->Free2dGrid ( cgrid2.xg, xEl, yEl );
+          actStream->Free2dGrid ( cgrid2.yg, xEl, yEl );
+        }
+        if (tidyGrid1WorldData)
+        {
+          delete[] xg1;
+          delete[] yg1;
+        }
+
+        if (stopClip) stopClipping(actStream);
+        actStream->Free2dGrid(map, xEl, yEl);
+      }
+      //finished? Store Zrange and Loginess unless we are overplot:
+      if ( make2dBox || make3dBox )
+      {
+       gdlStoreAxisCRANGE("Z", zStart, zEnd, zLog);
+       gdlStoreAxisType("Z",zLog);
+      }
+
+      if (doT3d) {
+        actStream->stransform(NULL,NULL); //remove transform BEFORE writing axes, ticks..
+      }
+      //Draw axes after the data because /fill could potentially overlap the axes.
+      //... if keyword "OVERPLOT" is not set
+      if ( make2dBox ) //onlyplace where tick etc is relevant!
+      {
+        gdlSetGraphicsForegroundColorFromKw ( e, actStream ); //COLOR
+        gdlBox(e, actStream, xStart, xEnd, yStart, yEnd, xLog, yLog);
+      }
+      if(make3dBox) {  //overplot box
+        DDouble t3xStart, t3xEnd, t3yStart, t3yEnd, t3zStart, t3zEnd;
+        switch (axisExchangeCode) {
+          case NORMAL: //X->X Y->Y plane XY
+            t3xStart=(xLog)?log10(xStart):xStart,
+            t3xEnd=(xLog)?log10(xEnd):xEnd,
+            t3yStart=(yLog)?log10(yStart):yStart,
+            t3yEnd=(yLog)?log10(yEnd):yEnd,
+            t3zStart=0;
+            t3zEnd=1.0;
+            actStream->w3d(scale, scale, scale*(1.0 - zValue),
+            t3xStart,t3xEnd,t3yStart,t3yEnd,t3zStart,t3zEnd,
+            alt, az);
+            gdlAxis3(e, actStream, "X", xStart, xEnd, xLog);
+            gdlAxis3(e, actStream, "Y", yStart, yEnd, yLog);
+            break;
+          case XY: // X->Y Y->X plane XY
+            t3yStart=(xLog)?log10(xStart):xStart,
+            t3yEnd=(xLog)?log10(xEnd):xEnd,
+            t3xStart=(yLog)?log10(yStart):yStart,
+            t3xEnd=(yLog)?log10(yEnd):yEnd,
+            t3zStart=0;
+            t3zEnd=1.0;
+            actStream->w3d(scale, scale, scale*(1.0 - zValue),
+            t3xStart,t3xEnd,t3yStart,t3yEnd,t3zStart,t3zEnd,
+            alt, az);
+            gdlAxis3(e, actStream, "Y", xStart, xEnd, xLog);
+            gdlAxis3(e, actStream, "X", yStart, yEnd, yLog);
+            break;
+          case XZ: // Y->Y X->Z plane YZ
+            t3zStart=(xLog)?log10(xStart):xStart,
+            t3zEnd=(xLog)?log10(xEnd):xEnd,
+            t3yStart=(yLog)?log10(yStart):yStart,
+            t3yEnd=(yLog)?log10(yEnd):yEnd,
+            t3xStart=0;
+            t3xEnd=1.0;
+            actStream->w3d(scale, scale, scale,
+            t3xStart,t3xEnd,t3yStart,t3yEnd,t3zStart,t3zEnd,
+            alt, az);
+            gdlAxis3(e, actStream, "Z", xStart, xEnd, xLog, 0);
+            gdlAxis3(e, actStream, "Y", yStart, yEnd, yLog);
+            break;
+          case YZ: // X->X Y->Z plane XZ
+            t3xStart=(xLog)?log10(xStart):xStart,
+            t3xEnd=(xLog)?log10(xEnd):xEnd,
+            t3zStart=(yLog)?log10(yStart):yStart,
+            t3zEnd=(yLog)?log10(yEnd):yEnd,
+            t3yStart=0;
+            t3yEnd=1.0;
+            actStream->w3d(scale, scale, scale,
+            t3xStart,t3xEnd,t3yStart,t3yEnd,t3zStart,t3zEnd,
+            alt, az);
+            gdlAxis3(e, actStream, "X", xStart, xEnd, xLog);
+            gdlAxis3(e, actStream, "Z", yStart, yEnd, yLog,1);
+            break;
+          case XZXY: //X->Y Y->Z plane YZ
+            t3yStart=(xLog)?log10(xStart):xStart,
+            t3yEnd=(xLog)?log10(xEnd):xEnd,
+            t3zStart=(yLog)?log10(yStart):yStart,
+            t3zEnd=(yLog)?log10(yEnd):yEnd,
+            t3xStart=0;
+            t3xEnd=1.0;
+            actStream->w3d(scale, scale, scale,
+            t3xStart,t3xEnd,t3yStart,t3yEnd,t3zStart,t3zEnd,
+            alt, az);
+            gdlAxis3(e, actStream, "Y", xStart, xEnd, xLog);
+            gdlAxis3(e, actStream, "Z", yStart, yEnd, yLog);
+            break;
+          case XZYZ: //X->Z Y->X plane XZ
+            t3zStart=(xLog)?log10(xStart):xStart,
+            t3zEnd=(xLog)?log10(xEnd):xEnd,
+            t3xStart=(yLog)?log10(yStart):yStart,
+            t3xEnd=(yLog)?log10(yEnd):yEnd,
+            t3yStart=0;
+            t3yEnd=1.0;
+            actStream->w3d(scale, scale, scale,
+            t3xStart,t3xEnd,t3yStart,t3yEnd,t3zStart,t3zEnd,
+            alt, az);
+            gdlAxis3(e, actStream, "Z", xStart, xEnd, xLog,1);
+            gdlAxis3(e, actStream, "X", yStart, yEnd, yLog);
+            break;
+        }
+        // title and sub title
+        gdlWriteTitleAndSubtitle(e, actStream);
+      }
+    }
+
+  private:
+
+    void call_plplot (EnvT* e, GDLGStream* actStream)
+    {
+    }
+
+  private:
+
+    virtual void post_call (EnvT*, GDLGStream* actStream)
+    {
+      actStream->lsty(1);//reset linestyle
+      actStream->sizeChar(1.0);
+    }
+
+  }; // contour_call class
+
+  void contour (EnvT* e)
+  {
+    contour_call contour;
+    contour.call ( e, 1 );
+  }
+
+} // namespace
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting_convert_coord.cpp gdl/src/plotting_convert_coord.cpp
--- gdl-0.9.3/src/plotting_convert_coord.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting_convert_coord.cpp	2013-05-16 12:36:33.521856820 -0600
@@ -23,8 +23,13 @@
 
   using namespace std;
 
+  static DDouble cubeCorners[32]=
+      {
+   0,1,0,1,0,1,0,1,0,0,1,1,0,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1
+  };
+
   template< typename T1, typename T2>
-  BaseGDL* convert_coord_template( EnvT* e, 
+  BaseGDL* convert_coord_template( EnvT* e,
 				   BaseGDL* p0, BaseGDL* p1, BaseGDL* p2,
 				   DDouble *sx, DDouble *sy, DDouble *sz,
 				   DLong xv, DLong yv, DLong xt, DLong yt)
@@ -62,7 +67,7 @@
     } else {
       // rank == 2
       nrows = 1;
-      for( SizeT i = 0; i<2; ++i) {	
+      for( SizeT i = 0; i<2; ++i) {
 	nrows  *= p0->Dim(i);
       }
       dims[1] = nrows;
@@ -74,7 +79,7 @@
     T2 *ptr1, *ptr2, *ptr3;
     DLong deln=1, ires=0;
     bool third = false;
-    if( e->NParam() == 1) { 
+    if( e->NParam() == 1) {
       in = static_cast<T1*>(p0->Convert2( aTy, BaseGDL::COPY));
       ptr1 = &(*in)[0];
       ptr2 = &(*in)[1];
@@ -109,11 +114,11 @@
 
       // ll -> xy
       // lam = longitude  phi = latitude
-      if (e->KeywordSet("DATA") || (!e->KeywordSet("DEVICE") && 
+      if (e->KeywordSet("DATA") || (!e->KeywordSet("DEVICE") &&
 				    !e->KeywordSet("NORMAL"))) {
-	if (!e->KeywordSet("TO_DEVICE") && 
+	if (!e->KeywordSet("TO_DEVICE") &&
 	    !e->KeywordSet("TO_NORMAL")) {
-	  for( SizeT i = 0; i<nrows; ++i) {	
+	  for( SizeT i = 0; i<nrows; ++i) {
 	    (*res)[ires++] = (*ptr1);
 	    (*res)[ires++] = (*ptr2);
 	    ptr1++;
@@ -123,7 +128,7 @@
 	} else if (e->KeywordSet("TO_NORMAL")) {
 	  LPTYPE idata;
 	  XYTYPE odata;
-	  for( SizeT i = 0; i<nrows; ++i) {	
+	  for( SizeT i = 0; i<nrows; ++i) {
 	    idata.lam = (*ptr1) * DEG_TO_RAD;
 	    idata.phi = (*ptr2) * DEG_TO_RAD;
 	    odata = PJ_FWD(idata, ref);
@@ -136,7 +141,7 @@
 	} else if (e->KeywordSet("TO_DEVICE")) {
 	  LPTYPE idata;
 	  XYTYPE odata;
-	  for( SizeT i = 0; i<nrows; ++i) {	
+	  for( SizeT i = 0; i<nrows; ++i) {
 	    idata.lam = (*ptr1) * DEG_TO_RAD;
 	    idata.phi = (*ptr2) * DEG_TO_RAD;
 	    odata = PJ_FWD(idata, ref);
@@ -164,7 +169,7 @@
         } else {
 	  XYTYPE idata;
 	  LPTYPE odata;
-	  for( SizeT i = 0; i<nrows; ++i) {	
+	  for( SizeT i = 0; i<nrows; ++i) {
 	    idata.x = ((*ptr1) - sx[0]) / sx[1];
 	    idata.y = ((*ptr2) - sy[0]) / sy[1];
 	    odata = PJ_INV(idata, ref);
@@ -178,7 +183,7 @@
       } else if (e->KeywordSet("DEVICE")) {
 	XYTYPE idata;
 	LPTYPE odata;
-	for( SizeT i = 0; i<nrows; ++i) {	
+	for( SizeT i = 0; i<nrows; ++i) {
 	  idata.x = ((*ptr1) / xv - sx[0]) / sx[1];
 	  idata.y = ((*ptr2) / yv - sy[0]) / sy[1];
 	  odata = PJ_INV(idata, ref);
@@ -193,8 +198,8 @@
       {
         static DStructGDL *Values = SysVar::Values();
         DDouble d_nan = (*static_cast<DDoubleGDL*>(Values->GetTag(Values->Desc()->TagIndex("D_NAN"), 0)))[0];
-        for( SizeT i = 0; i<res->N_Elements(); ++i) {	
-          if (isinf((DDouble) (*res)[i]) != 0) (*res)[i] = d_nan;
+        for( SizeT i = 0; i<res->N_Elements(); ++i) {
+          if (std::isinf((DDouble) (*res)[i]) != 0) (*res)[i] = d_nan;
         }
       }
       return res;
@@ -202,9 +207,9 @@
 #endif
 
     // in: DATA  out: NORMAL/DEVICE
-    if (e->KeywordSet("DATA") || (!e->KeywordSet("DEVICE") && 
+    if (e->KeywordSet("DATA") || (!e->KeywordSet("DEVICE") &&
 	!e->KeywordSet("NORMAL"))) {
-      for( SizeT i = 0; i<nrows; ++i) {	
+      for( SizeT i = 0; i<nrows; ++i) {
 	if (xt == 0)
 	  (*res)[ires++] = xv * (sx[0] + sx[1] * (*ptr1));
 	else
@@ -243,7 +248,7 @@
 	    (*res)[ires++] = ((*ptr1) - sx[0]) / sx[1];
 	  else
 	    (*res)[ires++] = pow(10.,((*ptr1) - sx[0]) / sx[1]);
-	
+
 	  if (yt == 0)
 	    (*res)[ires++] = ((*ptr2) - sy[0]) / sy[1];
 	  else
@@ -278,12 +283,12 @@
 	    (*res)[ires++] = ((*ptr1) / xv - sx[0]) / sx[1];
 	  else
 	    (*res)[ires++] = pow(10.,((*ptr1) / xv - sx[0]) / sx[1]);
-	  
+
 	  if (yt == 0)
 	    (*res)[ires++] = ((*ptr2) / yv - sy[0]) / sy[1];
 	  else
 	    (*res)[ires++] = pow(10.,((*ptr2) / yv - sy[0]) / sy[1]);
-	  
+
 	  if (third)
 	    (*res)[ires++] = ((*ptr3) - sz[0]) / sz[1];
 	  else
@@ -292,12 +297,12 @@
 	  ptr2 += deln;
 	  ptr3 += deln;
 	}
-      }	
+      }
     }
     return res;
   }
 
-  BaseGDL* convert_coord( EnvT* e) 
+  BaseGDL* convert_coord( EnvT* e)
   {
     SizeT nParam=e->NParam();
     if( nParam < 1)
@@ -364,4 +369,608 @@
     }
   }
 
+  //THE FOLLOWING ARE POSSIBLY THE WORST WAY TO DO THE JOB. At least they are to be used *only*
+  //for [4,4] generalized 3D matrices
+  void SelfTranspose3d(DDoubleGDL* me)
+  {
+    //crude quick hack to have the same behaviour as the other functions.
+    SizeT dim0=me->Dim(0);
+    SizeT dim1=me->Dim(1);
+    if (dim0 !=4 && dim1 !=4) return;
+    DDoubleGDL* mat=(new DDoubleGDL(dimension(dim1,dim0),BaseGDL::NOZERO));
+    for (int j=0; j < dim0; ++j) for (int i=0; i < dim1; ++i)(*mat)[i*dim1+j]=(*me)[j*dim0 + i];
+    memcpy(me->DataAddr(),mat->DataAddr(),dim0*dim1*sizeof(double));
+//    for (int i=0; i < dim0; ++i) for (int j=0; j < dim1; ++j)(*me)[i*dim0+j]=(*mat)[i*dim0 + j];
+    GDLDelete(mat);
+  }
+  void SelfReset3d(DDoubleGDL* me)
+  {
+    SizeT dim0=me->Dim(0);
+    SizeT dim1=me->Dim(1);
+    if (dim0 !=4 && dim1 !=4) return;
+    DDoubleGDL* Identity=(new DDoubleGDL(dimension(dim0,dim1)));
+    for(SizeT i=0; i<dim1; ++i) {(*Identity)[i*dim1+i]=(double)1.0;}
+    memcpy(me->DataAddr(),Identity->DataAddr(),dim0*dim1*sizeof(double));
+    GDLDelete(Identity);
+  }
+  DDoubleGDL* Translate3d(DDoubleGDL* me, DDouble* trans)
+  {
+    SizeT dim0=me->Dim(0);
+    SizeT dim1=me->Dim(1);
+    Guard<BaseGDL> mat_guard;
+    DDoubleGDL* mat=(new DDoubleGDL(dimension(dim0,dim1)));
+    mat_guard.Reset(mat);
+    SelfReset3d(mat); //identity Matrix
+    for(SizeT i=0; i<3; ++i) {(*mat)[3*dim1+i]=trans[i];}
+    return mat->MatrixOp(me,false,false);
+  }
+  void SelfTranslate3d(DDoubleGDL* me, DDouble* trans)
+  {
+    SizeT dim0=me->Dim(0);
+    SizeT dim1=me->Dim(1);
+    if (dim0 !=4 && dim1 !=4) return;
+    DDoubleGDL* mat=(new DDoubleGDL(dimension(dim0,dim1)));
+    SelfReset3d(mat); //identity Matrix
+    for(SizeT i=0; i<3; ++i) {(*mat)[3*dim1+i]=trans[i];}
+    memcpy(me->DataAddr(),(mat->MatrixOp(me,false,false))->DataAddr(),dim0*dim1*sizeof(double));
+    GDLDelete(mat);
+  }
+  DDoubleGDL* Scale3d(DDoubleGDL* me, DDouble *scale)
+  {
+    SizeT dim0=me->Dim(0);
+    SizeT dim1=me->Dim(1);
+    Guard<BaseGDL> mat_guard;
+    DDoubleGDL* mat=(new DDoubleGDL(dimension(dim0,dim1)));
+    mat_guard.Reset(mat);
+    SelfReset3d(mat); //identity Matrix
+    for(SizeT i=0; i<3; ++i) {(*mat)[i*dim1+i]=scale[i];}
+    return mat->MatrixOp(me,false,false);
+  }
+  void SelfScale3d(DDoubleGDL* me, DDouble *scale)
+  {
+    SizeT dim0=me->Dim(0);
+    SizeT dim1=me->Dim(1);
+    if (dim0 !=4 && dim1 !=4) return;
+    DDoubleGDL* mat=(new DDoubleGDL(dimension(dim0,dim1)));
+    SelfReset3d(mat); //identity Matrix
+    for(SizeT i=0; i<3; ++i) {(*mat)[i*dim1+i]=scale[i];}
+    memcpy(me->DataAddr(),(mat->MatrixOp(me,false,false))->DataAddr(),dim0*dim1*sizeof(double));
+    GDLDelete(mat);
+}
+#define DPI (double)(4*atan(1.0))
+#define DEGTORAD (DPI/180.0)
+#define RADTODEG (180.0/DPI)
+  void SelfRotate3d(DDoubleGDL* me, DDouble *rot)
+  {
+    SizeT dim0=me->Dim(0);
+    SizeT dim1=me->Dim(1);
+    if (dim0 !=4 && dim1 !=4) return;
+    DDoubleGDL* mat=(new DDoubleGDL(dimension(4,4)));
+    SelfReset3d(mat);
+    DDoubleGDL* maty=(new DDoubleGDL(dimension(4,4)));
+    SelfReset3d(maty);
+    DDoubleGDL* matz=(new DDoubleGDL(dimension(4,4)));
+    SelfReset3d(matz);
+    SizeT ncols=4;
+    double c,s;
+    for(SizeT j=0; j<3; ++j)
+    {
+        c=cos(rot[j]*DEGTORAD);
+        s=sin(rot[j]*DEGTORAD);
+        switch(j)
+        {
+          case 0:
+          {
+            (*mat)[1 * ncols + 1] = c;
+            (*mat)[1 * ncols + 2] = s;
+            (*mat)[2 * ncols + 1] = -s;
+            (*mat)[2 * ncols + 2] = c;
+            break;
+          }
+          case 1:
+          {
+            (*maty)[0 * ncols + 0] = c;
+            (*maty)[0 * ncols + 2] = -s;
+            (*maty)[2 * ncols + 0] = s;
+            (*maty)[2 * ncols + 2] = c;
+            memcpy(mat->DataAddr(),(maty->MatrixOp(mat,false,false))->DataAddr(),dim0*dim1*sizeof(double));
+            break;
+          }
+          case 2:
+          {
+            (*matz)[0 * ncols + 0] = c;
+            (*matz)[0 * ncols + 1] = s;
+            (*matz)[1 * ncols + 0] = -s;
+            (*matz)[1 * ncols + 1] = c;
+            memcpy(mat->DataAddr(),(matz->MatrixOp(mat,false,false))->DataAddr(),dim0*dim1*sizeof(double));
+          }
+        }
+      }
+
+    memcpy(me->DataAddr(),(mat->MatrixOp(me,false,false))->DataAddr(),dim0*dim1*sizeof(double));
+    GDLDelete(matz);
+    GDLDelete(maty);
+    GDLDelete(mat);
+  }
+  void SelfPerspective3d(DDoubleGDL* me, DDouble zdist)
+  {
+    if (!(zdist==zdist)) return; //Nan
+    if (zdist==0.0) return;
+    SizeT dim0=me->Dim(0);
+    SizeT dim1=me->Dim(1);
+    if (dim0 !=4 && dim1 !=4) return;
+    DDoubleGDL* mat=(new DDoubleGDL(dimension(dim0,dim1)));
+    SelfReset3d(mat); //identity Matrix
+    (*mat)[2*dim1+3]=-1.0/zdist;
+    memcpy(me->DataAddr(),(mat->MatrixOp(me,false,false))->DataAddr(),dim0*dim1*sizeof(double));
+    GDLDelete(mat);
+ }
+  void SelfOblique3d(DDoubleGDL* me, DDouble dist, DDouble angle)
+  {
+    SizeT dim0=me->Dim(0);
+    SizeT dim1=me->Dim(1);
+    if (dim0 !=4 && dim1 !=4) return;
+    DDoubleGDL* mat=(new DDoubleGDL(dimension(dim0,dim1)));
+    SelfReset3d(mat); //identity Matrix
+    (*mat)[2*dim1+2]=0.0;
+    (*mat)[2*dim1+0]=dist*cos(angle*DEGTORAD);
+    (*mat)[2*dim1+1]=dist*sin(angle*DEGTORAD);
+    memcpy(me->DataAddr(),(mat->MatrixOp(me,false,false))->DataAddr(),dim0*dim1*sizeof(double));
+    GDLDelete(mat);
+  }
+  void SelfExch3d(DDoubleGDL* me, DLong code)
+  {
+    SizeT dim0=me->Dim(0);
+    SizeT dim1=me->Dim(1);
+    if (dim0 !=4 && dim1 !=4) return;
+    DDoubleGDL* mat=me->Dup();
+    switch(code)
+    {
+      case 1: //exchange 0 and 1
+        for(SizeT i=0; i<dim0; ++i)
+        {
+          (*me)[0*dim1+i]=(*mat)[1*dim1+i];
+          (*me)[1*dim1+i]=(*mat)[0*dim1+i];
+        }
+        break;
+      case 2: //exchange 0 and 2
+        for(SizeT i=0; i<dim0; ++i)
+        {
+          (*me)[0*dim1+i]=(*mat)[2*dim1+i];
+          (*me)[2*dim1+i]=(*mat)[0*dim1+i];
+        }
+        break;
+      case 12: //exchange 1 and 2
+        for(SizeT i=0; i<dim0; ++i)
+        {
+          (*me)[1*dim1+i]=(*mat)[2*dim1+i];
+          (*me)[2*dim1+i]=(*mat)[1*dim1+i];
+        }
+    }
+    GDLDelete(mat);
+  }
+ DDoubleGDL* gdlComputePlplotRotationMatrix(DDouble az, DDouble alt, DDouble zValue, DDouble scale)
+  {
+    //scale should not be used and must be 1 until scale is introduced everywhre.
+    DDoubleGDL* plplot3d=(new DDoubleGDL(dimension(4,4),BaseGDL::NOZERO));
+    SelfReset3d(plplot3d);
+    static DDouble mytrans[3]={-0.5, -0.5, -zValue};
+    SelfTranslate3d(plplot3d,mytrans);
+    static DDouble myscale[3]={scale, scale, scale};
+    SelfScale3d(plplot3d,myscale);
+    DDouble rot1[3]={-90.0, az, 0.0};
+    DDouble rot2[3]={alt, 0.0, 0.0};
+    SelfRotate3d(plplot3d,rot1);
+    SelfRotate3d(plplot3d,rot2);
+//    static DDouble mytrans2[3]={0.5, 0.5, zValue};
+//    SelfTranslate3d(plplot3d,mytrans2);
+    return plplot3d; //this matrix converts 3D xyz in plplot's 2d
+ }
+
+ void gdl3dTo2dTransform(PLFLT x, PLFLT y, PLFLT *xt, PLFLT *yt, PLPointer data)
+ {
+   struct GDL_3DTRANSFORMDATA *ptr = (GDL_3DTRANSFORMDATA* )data;
+   DDoubleGDL* xyzw=new DDoubleGDL(dimension(4));
+   (*xyzw)[3]=1.0;
+   (*xyzw)[ptr->code[0]]=(x+ptr->x0)*ptr->xs;
+   (*xyzw)[ptr->code[1]]=(y+ptr->y0)*ptr->ys;;
+   (*xyzw)[ptr->code[2]]=ptr->zValue;
+   DDoubleGDL* trans=xyzw->MatrixOp(ptr->Matrix,false,true);
+   *xt=(*trans)[0];
+   *yt=(*trans)[1];
+   GDLDelete(trans);
+   GDLDelete(xyzw);
+ }
+//Special for Contour (not special for the moment in fact):
+ void gdl3dTo2dTransformContour(PLFLT x, PLFLT y, PLFLT *xt, PLFLT *yt, PLPointer data)
+ {
+   struct GDL_3DTRANSFORMDATA *ptr = (GDL_3DTRANSFORMDATA* )data;
+   DDoubleGDL* xyzw=new DDoubleGDL(dimension(4));
+   (*xyzw)[3]=1.0;
+   (*xyzw)[ptr->code[0]]=(x+ptr->x0)*ptr->xs;
+   (*xyzw)[ptr->code[1]]=(y+ptr->y0)*ptr->ys;;
+   (*xyzw)[ptr->code[2]]=ptr->zValue;
+   DDoubleGDL* trans=xyzw->MatrixOp(ptr->Matrix,false,true);
+   *xt=(*trans)[0];
+   *yt=(*trans)[1];
+   GDLDelete(trans);
+   GDLDelete(xyzw);
+ }
+
+ //retrieve !P.T,
+ DDoubleGDL* gdlGetT3DMatrix()
+ {
+    DDoubleGDL* t3dMatrix=(new DDoubleGDL(dimension(4,4),BaseGDL::NOZERO));
+    static DStructGDL* pStruct=SysVar::P();
+    static unsigned tTag=pStruct->Desc()->TagIndex("T");
+    for (int i=0; i<t3dMatrix->N_Elements(); ++i )(*t3dMatrix)[i]=(*static_cast<DDoubleGDL*>(pStruct->GetTag(tTag, 0)))[i];
+    SelfTranspose3d(t3dMatrix);
+    return t3dMatrix;
+ }
+ // retrieve !P.T, (or use passed matrix)
+ // scale to current X.S Y.S and Z.S, returns a matrix that can be applied directly to
+ // XYZ data to get projected X' Y' *normalized* coordinates values
+ DDoubleGDL* gdlGetScaledNormalizedT3DMatrix(DDoubleGDL* passedMatrix)
+ {
+    DDoubleGDL* t3dMatrix;
+    if (passedMatrix==NULL) t3dMatrix=gdlGetT3DMatrix(); else t3dMatrix=passedMatrix;
+    DDouble *sx, *sy, *sz;
+    GetSFromPlotStructs(&sx, &sy, &sz);
+    DDoubleGDL* toScaled=(new DDoubleGDL(dimension(4,4),BaseGDL::NOZERO));
+    SelfReset3d(toScaled);
+    DDouble depla[3]={sx[0],sy[0],sz[0]};
+    DDouble scale[3]={sx[1],sy[1],sz[1]};
+    SelfScale3d(toScaled, scale);  //pay attention to order for matrices!
+    SelfTranslate3d(toScaled,depla);
+    DDoubleGDL* returnMatrix=t3dMatrix->MatrixOp(toScaled,false,false);
+    GDLDelete(toScaled);
+    if (passedMatrix==NULL) GDLDelete(t3dMatrix);
+    return returnMatrix;
+ }
+
+ void gdlNormed3dToWorld3d(DDoubleGDL *xValin, DDoubleGDL *yValin, DDoubleGDL* zValin,
+                           DDoubleGDL *xValou, DDoubleGDL *yValou, DDoubleGDL* zValou)
+ {
+    DDouble *sx, *sy, *sz;
+    GetSFromPlotStructs(&sx, &sy, &sz);
+    DDoubleGDL* toWorld=(new DDoubleGDL(dimension(4,4),BaseGDL::NOZERO));
+    SelfReset3d(toWorld);
+    DDouble depla[3]={-sx[0],-sy[0],-sz[0]};
+    DDouble scale[3]={1/sx[1],1/sy[1],1/sz[1]};
+    SelfTranslate3d(toWorld,depla);  //pay attention to order for matrices!
+    SelfScale3d(toWorld, scale);
+    //populate a 4D matrix with reduced coordinates through sx,sy,sz:
+    SizeT nEl=xValin->N_Elements();
+    DDoubleGDL* xyzw=new DDoubleGDL(dimension(nEl,4));
+    memcpy(&((*xyzw)[0]),xValin->DataAddr(),nEl*sizeof(double));
+    memcpy(&((*xyzw)[nEl]),yValin->DataAddr(),nEl*sizeof(double));
+    if (zValin != NULL) memcpy(&((*xyzw)[2*nEl]),zValin->DataAddr(),nEl*sizeof(double));
+    else for (int index=0; index< nEl; ++index){ (*xyzw)[2*nEl+index]=1.0;}
+    for (int index=0; index< nEl; ++index){ (*xyzw)[3*nEl+index]=1.0;}
+    DDoubleGDL* trans=xyzw->MatrixOp(toWorld,false,true);
+    memcpy(xValou->DataAddr(), trans->DataAddr(),nEl*sizeof(double));
+    memcpy(yValou->DataAddr(), &(*trans)[nEl],nEl*sizeof(double));
+    if (zValou != NULL) memcpy(zValou->DataAddr(), &(*trans)[2*nEl],nEl*sizeof(double));
+    GDLDelete(trans);
+    GDLDelete(xyzw);
+    GDLDelete(toWorld);
+ }
+ void gdl3dto2dProjectDDouble(DDoubleGDL* t3dMatrix, DDoubleGDL *xVal, DDoubleGDL *yVal, DDoubleGDL* zVal,
+                              DDoubleGDL *xValou, DDoubleGDL *yValou, int* code)
+ {
+      DDoubleGDL *decodedAxis[3]={xVal,yVal,zVal};
+      int *localCode=code;
+      if (localCode == NULL) localCode=code012;
+      //populate a 4D matrix with reduced coordinates through sx,sy,sz:
+      SizeT nEl=xVal->N_Elements();
+      DDoubleGDL* xyzw=new DDoubleGDL(dimension(nEl,4));
+      memcpy(&((*xyzw)[0]),decodedAxis[localCode[0]]->DataAddr(),nEl*sizeof(double));
+      memcpy(&((*xyzw)[nEl]),decodedAxis[localCode[1]]->DataAddr(),nEl*sizeof(double));
+      memcpy(&((*xyzw)[2*nEl]),decodedAxis[localCode[2]]->DataAddr(),nEl*sizeof(double));
+      for (int index=0; index< nEl; ++index){ (*xyzw)[3*nEl+index]=1.0;}
+      DDoubleGDL* trans=xyzw->MatrixOp(t3dMatrix,false,true);
+      memcpy(xValou->DataAddr(), trans->DataAddr(),nEl*sizeof(double));
+      memcpy(yValou->DataAddr(), &(*trans)[nEl],nEl*sizeof(double));
+      GDLDelete(trans);
+      GDLDelete(xyzw);
+ }
+
+  void gdlProject3dCoordinatesIn2d(DDoubleGDL* Matrix, DDoubleGDL *xVal, DDouble* sx,
+      DDoubleGDL *yVal, DDouble *sy, DDoubleGDL* zVal, DDouble *sz , DDoubleGDL *xValou, DDoubleGDL *yValou)
+ {
+      DDoubleGDL* toScaled=(new DDoubleGDL(dimension(4,4),BaseGDL::NOZERO));
+      SelfReset3d(toScaled);
+      DDouble depla[3]={sx[0],sy[0],sz[0]};
+      DDouble scale[3]={sx[1],sy[1],sz[1]};
+      SelfScale3d(toScaled, scale);
+      SelfTranslate3d(toScaled,depla);
+      //populate a 4D matrix with reduced coordinates through sx,sy,sz:
+      SizeT nEl=xVal->N_Elements();
+      DDoubleGDL* xyzw=new DDoubleGDL(dimension(nEl,4));
+      memcpy(&((*xyzw)[0]),xVal->DataAddr(),nEl*sizeof(double));
+      memcpy(&((*xyzw)[nEl]),yVal->DataAddr(),nEl*sizeof(double));
+      memcpy(&((*xyzw)[2*nEl]),zVal->DataAddr(),nEl*sizeof(double));
+      for (int index=0; index< nEl; ++index){ (*xyzw)[3*nEl+index]=1.0;}
+      DDoubleGDL* temp=Matrix->MatrixOp(toScaled,false,false);
+      DDoubleGDL* trans=xyzw->MatrixOp(temp,false,true);
+      memcpy(xValou->DataAddr(), trans->DataAddr(),nEl*sizeof(double));
+      memcpy(yValou->DataAddr(), &(*trans)[nEl],nEl*sizeof(double));
+      GDLDelete(trans);
+      GDLDelete(xyzw);
+      GDLDelete(temp);
+ }
+
+  bool isMatrixRotation(DDoubleGDL* Matrix,DDouble &rx, DDouble &ry, DDouble &rz, DDouble &scale)
+  {
+    DDoubleGDL* t3dMatrix=Matrix->Dup();
+    // !P.T=rt#cs#9r#Ry#Rx(#Rz?)#tr !Ry contains az!
+    // r9#sc#tr# rt#cs#9r#Ry#Rx(#Rz?)#tr #rt =  r9#sc#tr#!P.T#rt = Ry#Rx(#Rz?)
+    //
+    // a= r9#sc#tr#!P.T#rt
+    //construct derotator of Matrix=!P.T . We can find sc if not stretch.
+    //substract translation rt
+    static DDouble rt[3]={-0.5, -0.5, -0.5};
+    SelfTranslate3d(t3dMatrix,rt); //!P.T#rt
+    //on the other end compute the good invert translation-rotation t3dMatrix
+    DDoubleGDL* test=(new DDoubleGDL(dimension(4,4)));
+    SelfReset3d(test);
+    static DDouble r9[3]={90.0, 0.0, 0.0};
+    SelfRotate3d(test,r9);
+    static DDouble tr[3]={0.5, 0.5, 0.5};
+    SelfTranslate3d(test,tr);
+    // product of the two should be a pure scaled rotx,roty(rotz)(scale) matrix, hence:
+    DDoubleGDL* xz=(t3dMatrix->MatrixOp(test,false,false));
+    rx=atan2((*xz)[1*4+2],(*xz)[1*4+1])*RADTODEG;
+    ry=atan2((*xz)[2*4+0],sqrt(pow((*xz)[2*4+1],2.0)+pow((*xz)[2*4+2],2.0)))*RADTODEG;
+    rz=atan2((*xz)[1*4+0],(*xz)[0*4+0])*RADTODEG;
+    //test by rotation inverse
+    static DDouble Rot[3];
+    memset(Rot,'\0',3*sizeof(DDouble)); Rot[2]=-rz; SelfRotate3d(xz,Rot); //#zR
+    memset(Rot,'\0',3*sizeof(DDouble)); Rot[0]=-rx; SelfRotate3d(xz,Rot); //#xR
+    memset(Rot,'\0',3*sizeof(DDouble)); Rot[1]=-ry; SelfRotate3d(xz,Rot); //#yR
+    scale=(*xz)[0];
+    DDouble sum=(*xz)[0]+(*xz)[5]+(*xz)[10];
+    sum/=scale; //sum of scaled Rotation matrix diagonal
+    if (abs(sum-3.0)<1E-4) return true; else return false;
+  }
+  DDoubleGDL* gdlConvertT3DMatrixToPlplotRotationMatrix( DDouble zValue, DDouble &az,
+      DDouble &alt,  DDouble &ay, DDouble &scale, ORIENTATION3D &code)
+  {
+    //returns NULL if error!
+    DDoubleGDL* t3dMatrix=(new DDoubleGDL(dimension(4,4)));
+    //retrieve !P.T and find az, alt, inversions, and (possibly) scale and roty
+    static DStructGDL* pStruct=SysVar::P();
+    static unsigned tTag=pStruct->Desc()->TagIndex("T");
+    for (int i=0; i<t3dMatrix->N_Elements(); ++i )(*t3dMatrix)[i]=(*static_cast<DDoubleGDL*>(pStruct->GetTag(tTag, 0)))[i];
+    SelfTranspose3d(t3dMatrix);
+    //check repeatedly rotations & translations
+    if (isMatrixRotation(t3dMatrix,alt,az,ay,scale))
+    {
+      code=NORMAL;   goto done; // 0
+    }
+    SelfExch3d(t3dMatrix,01); //XY, 1
+    if (isMatrixRotation(t3dMatrix,alt,az,ay,scale))
+    {
+      code=XY;   goto done;
+    }
+    SelfExch3d(t3dMatrix,01); //-XY
+    SelfExch3d(t3dMatrix,02); //+XZ 2
+    if (isMatrixRotation(t3dMatrix,alt,az,ay,scale))
+    {
+      code=XZ;   goto done;
+    }
+    SelfExch3d(t3dMatrix,02); //-XZ
+    SelfExch3d(t3dMatrix,12); //+YZ 3
+    if (isMatrixRotation(t3dMatrix,alt,az,ay,scale))
+    {
+      code=YZ;   goto done;
+    }
+    SelfExch3d(t3dMatrix,12); //-YZ
+
+    SelfExch3d(t3dMatrix,01); //XY first
+
+    SelfExch3d(t3dMatrix,02); //+XZ 5
+    if (isMatrixRotation(t3dMatrix,alt,az,ay,scale))
+    {
+      code=XZXY;   goto done;
+    }
+    SelfExch3d(t3dMatrix,02); //-XZ
+    SelfExch3d(t3dMatrix,12); //+YZ 4
+    if (isMatrixRotation(t3dMatrix,alt,az,ay,scale))
+    {
+      code=XZYZ;   goto done;
+    }
+    SelfExch3d(t3dMatrix,12); //-YZ
+    SelfExch3d(t3dMatrix,01); //-XY
+//redundant
+//    SelfExch3d(t3dMatrix,12); // YZ first
+//
+//    SelfExch3d(t3dMatrix,01); //XY 5
+//    if (isMatrixRotation(t3dMatrix,alt,az,ay,scale))
+//    {
+//      code=YZXY;   goto done;
+//    }
+//    SelfExch3d(t3dMatrix,01); //-XY
+//    SelfExch3d(t3dMatrix,02); //+XZ 4
+//    if (isMatrixRotation(t3dMatrix,alt,az,ay,scale))
+//    {
+//      code=YZXZ;   goto done;
+//    }
+//    SelfExch3d(t3dMatrix,02); //-XZ
+//    SelfExch3d(t3dMatrix,12); //-YZ
+//
+//    SelfExch3d(t3dMatrix,02); // XZ first
+//
+//    SelfExch3d(t3dMatrix,01); //XY 4
+//    if (isMatrixRotation(t3dMatrix,alt,az,ay,scale))
+//    {
+//      code=XZXY;   goto done;
+//    }
+//    SelfExch3d(t3dMatrix,01); //-XY
+//    SelfExch3d(t3dMatrix,12); //+YZ 4
+//    if (isMatrixRotation(t3dMatrix,alt,az,ay,scale))
+//    {
+//      code=XZYZ;   goto done;
+//    }
+    return (DDoubleGDL*)(NULL); //ERROR!
+done:
+    if (alt > 90.0 || alt <-1.E-3) return (DDoubleGDL*)(NULL);
+    if (alt<0.0) alt=0.0; //prevents plplot complain for epsilon not being strictly positive.
+
+    //recompute transformation matrix with plplot conventions:
+    DDoubleGDL* plplot3d=gdlComputePlplotRotationMatrix(az, alt, zValue, scale);
+    return plplot3d;
+  }
+  void scale3_pro(EnvT* e)
+  {
+    static unsigned tTag=SysVar::P()->Desc()->TagIndex("T");
+    const double invsqrt3=1.0/sqrt(3);
+    //AX
+    DDouble ax=30.0;
+    e->AssureDoubleScalarKWIfPresent("AX", ax);
+    //AZ
+    DDouble az=30.0;
+    e->AssureDoubleScalarKWIfPresent("AZ", az);
+    DDoubleGDL* mat=(new DDoubleGDL(dimension(4,4),BaseGDL::NOZERO));
+    SelfReset3d(mat);
+    static DDouble mytrans[3]={-0.5, -0.5, -0.5};
+    SelfTranslate3d(mat,mytrans);
+    static DDouble myscale[3]={invsqrt3, invsqrt3, invsqrt3};
+    SelfScale3d(mat,myscale);
+    DDouble rot1[3]={-90.0, az, 0.0};
+    DDouble rot2[3]={ax, 0.0, 0.0};
+    SelfRotate3d(mat,rot1);
+    SelfRotate3d(mat,rot2);
+    static DDouble mytrans2[3]={0.5, 0.5, 0.5};
+    SelfTranslate3d(mat,mytrans2);
+    SelfTranspose3d(mat); 
+    for (int i=0; i<mat->N_Elements(); ++i )(*static_cast<DDoubleGDL*>(SysVar::P()->GetTag(tTag, 0)))[i]=(*mat)[i];
+
+    DDouble size;
+    //XRANGE
+    static int xrangeIx = e->KeywordIx( "XRANGE");
+    DDoubleGDL* xrange = e->IfDefGetKWAs<DDoubleGDL>( xrangeIx);
+    if (xrange != NULL){
+        if (xrange->N_Elements()<2) e->Throw("XRANGE needs at least a 2-elements vector");
+        static unsigned sTag=SysVar::X()->Desc()->TagIndex("S");
+        size=((*xrange)[1]-(*xrange)[0]);
+        (*static_cast<DDoubleGDL*>(SysVar::X()->GetTag(sTag, 0)))[0]=-(*xrange)[0]/size;
+        (*static_cast<DDoubleGDL*>(SysVar::X()->GetTag(sTag, 0)))[1]=1.0/size;
+      }
+    //YRANGE
+    static int yrangeIx = e->KeywordIx( "YRANGE");
+    DDoubleGDL* yrange = e->IfDefGetKWAs<DDoubleGDL>( yrangeIx);
+    if (yrange != NULL){
+        if (yrange->N_Elements()<2) e->Throw("YRANGE needs at least a 2-elements vector");
+        static unsigned sTag=SysVar::Y()->Desc()->TagIndex("S");
+        size=((*yrange)[1]-(*yrange)[0]);
+        (*static_cast<DDoubleGDL*>(SysVar::Y()->GetTag(sTag, 0)))[0]=-(*yrange)[0]/size;
+        (*static_cast<DDoubleGDL*>(SysVar::Y()->GetTag(sTag, 0)))[1]=1.0/size;
+      }
+    //ZRANGE
+    static int zrangeIx = e->KeywordIx( "ZRANGE");
+    DDoubleGDL* zrange = e->IfDefGetKWAs<DDoubleGDL>( zrangeIx);
+    if (zrange != NULL){
+      if (zrange->N_Elements()<2) e->Throw("ZRANGE needs at least a 2-elements vector");
+        static unsigned sTag=SysVar::Z()->Desc()->TagIndex("S");
+        size=((*zrange)[1]-(*zrange)[0]);
+        (*static_cast<DDoubleGDL*>(SysVar::Z()->GetTag(sTag, 0)))[0]=-(*zrange)[0]/size;
+        (*static_cast<DDoubleGDL*>(SysVar::Z()->GetTag(sTag, 0)))[1]=1.0/size;
+      }
+  }
+  void t3d_pro( EnvT* e)
+  {
+    static unsigned tTag=SysVar::P()->Desc()->TagIndex("T");
+    DDoubleGDL *mat=NULL;
+    DDoubleGDL *matin=NULL;
+    // MATRIX keyword (read, write)
+    static int matrixIx=e->KeywordIx("MATRIX");
+    bool externalarray=e->KeywordPresent(matrixIx);
+
+    static int resetIx = e->KeywordIx( "RESET");
+    bool reset=e->KeywordSet(resetIx);
+    if (e->NParam() > 1)
+    {
+        e->Throw("Accepts only one (optional) 4x4 array");
+    }
+    else  if (e->NParam() == 1 && !reset)
+    {
+      matin=e->GetParAs< DDoubleGDL > (0);
+      if (matin->Rank() != 2)  e->Throw(e->GetParString(0)+"must be a 2d array.");
+      if (matin->Dim(0) != 4 || matin->Dim(1) != 4) e->Throw(e->GetParString(0)+"must be a [4,4] array.");
+      mat=matin->Dup();
+    }
+    else
+    {
+      mat=(new DDoubleGDL(dimension(4,4)));
+      for (int i=0; i<mat->N_Elements(); ++i )(*mat)[i]=(*static_cast<DDoubleGDL*>(SysVar::P()->GetTag(tTag, 0)))[i];
+    }
+    SelfTranspose3d(mat); //for c matrix handling
+    if (reset) SelfReset3d(mat);
+    //TRANSLATE
+    static int translateIx = e->KeywordIx( "TRANSLATE");
+    DDoubleGDL* translate = e->IfDefGetKWAs<DDoubleGDL>( translateIx);
+    if (translate != NULL)
+    {
+      if (translate->N_Elements() != 3) e->Throw("TRANSLATE parameter must be a [3] array.");
+      SelfTranslate3d(mat, (DDouble*)translate->DataAddr());
+    }
+    //SCALE
+    static int scaleIx = e->KeywordIx( "SCALE");
+    DDoubleGDL* scale = e->IfDefGetKWAs<DDoubleGDL>( scaleIx);
+    if (scale != NULL)
+    {
+      if (scale->N_Elements() != 3) e->Throw("SCALE parameter must be a [3] array.");
+      SelfScale3d(mat, (DDouble*)scale->DataAddr());
+    }
+    //ROTATE
+    static int rotateIx = e->KeywordIx( "ROTATE");
+    DDoubleGDL* rotate = e->IfDefGetKWAs<DDoubleGDL>( rotateIx);
+    if (rotate != NULL)
+    {
+      if (rotate->N_Elements() != 3) e->Throw("ROTATE parameter must be a [3] array.");
+      SelfRotate3d(mat, (DDouble*)rotate->DataAddr());
+    }
+    //PERSPECTIVE
+    static int perspIx = e->KeywordIx("PERSPECTIVE");
+    BaseGDL* perspective=e->GetKW(perspIx);
+    if (perspective != NULL) 
+    { DDoubleGDL* persp= static_cast<DDoubleGDL*>(perspective->Convert2( GDL_DOUBLE, BaseGDL::COPY));
+      SelfPerspective3d(mat, (*persp)[0]);
+    }
+    //OBLIQUE
+    static int obliqueIx = e->KeywordIx( "OBLIQUE");
+    DDoubleGDL* oblique = e->IfDefGetKWAs<DDoubleGDL>( obliqueIx);
+    if (oblique != NULL)
+    {
+      if (oblique->N_Elements() != 2) e->Throw("OBLIQUE parameter must be a [2] array.");
+      SelfOblique3d(mat, (*oblique)[0],(*oblique)[1]);
+    }
+    DLong code;
+    //XYEXCH
+    static int exchxyIx = e->KeywordIx( "XYEXCH");
+    bool exchxy=e->KeywordSet(exchxyIx);
+    if (exchxy) code=01;
+    //XZEXCH
+    static int exchxzIx = e->KeywordIx( "XZEXCH");
+    bool exchxz=e->KeywordSet(exchxzIx);
+    if (exchxz) code=02;
+    //YYEXCH
+    static int exchyzIx = e->KeywordIx( "YZEXCH");
+    bool exchyz=e->KeywordSet(exchyzIx);
+    if (exchyz) code=12;
+
+    if (exchxy||exchxz||exchyz) SelfExch3d(mat, code );
+
+    SelfTranspose3d(mat); //prior to give back.
+    if ( externalarray )
+    {
+       e->SetKW(matrixIx, mat);
+    }
+    else
+    {
+      for (int i=0; i<mat->N_Elements(); ++i )(*static_cast<DDoubleGDL*>(SysVar::P()->GetTag(tTag, 0)))[i]=(*mat)[i];
+      GDLDelete(mat);
+    }
+  }
 } // namespace
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting.cpp gdl/src/plotting.cpp
--- gdl-0.9.3/src/plotting.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting.cpp	2013-05-16 12:36:33.404857240 -0600
@@ -19,787 +19,1429 @@
 
 #include <memory>
 
+#include <string>
+#include <fstream>
+#include "envt.hpp"
+#include "dinterpreter.hpp"
 // PLplot is used for direct graphics
 #include <plplot/plstream.h>
 
 #include "initsysvar.hpp"
-#include "envt.hpp"
 #include "graphics.hpp"
 #include "plotting.hpp"
 #include "math_utl.hpp"
 
 #ifdef _MSC_VER
-#define isfinite _finite
-#define isnan _isnan
+#define snprintf _snprintf
 #endif
 
-namespace lib {
+namespace lib
+{
 
   using namespace std;
+//  using std::isinf;
+  using std::isnan;
+  
+//static values
+  static DDouble savedPointX=0.0;
+  static DDouble savedPointY=0.0;
+  static gdlbox saveBox;
+  static DDouble epsDouble=0.0;
+  static DDouble absoluteMinVal=0.0;
+  static DDouble absoluteMaxVal=0.0;
+  static DFloat sym1x[5]={1, -1, 0, 0, 0}; // +
+  static DFloat sym1y[5]={0, 0, 0, -1, 1}; // +
+  static DFloat sym2x[11]= {1, -1, 0, 0, 0, 0,1,-1,0,1,-1}; //*
+  static DFloat sym2y[11]= {0, 0, 0, -1, 1,0,1,-1,0,-1,1}; // *
+  static DFloat sym3x[2]={0,0}; // .
+  static DFloat sym3y[2]={0,0}; // .
+  static DFloat sym4x[5]={ 0, 1, 0, -1, 0 }; //diamond.
+  static DFloat sym4y[5]={ 1, 0, -1, 0, 1 }; //diamond.
+  static DFloat sym5x[4]={ -1, 0, 1, -1 }; // triangle up.
+  static DFloat sym5y[4]={ -1, 1, -1, -1 }; // triangle up.
+  static DFloat sym6x[5]={ -1, 1, 1, -1, -1 }; //square
+  static DFloat sym6y[5]={ 1, 1, -1, -1, 1 }; //square
+  static DFloat sym7x[5]= {1,-1,0,1,-1}; //x
+  static DFloat sym7y[5]= {1,-1,0,-1,1}; //x
+  DLong syml[7]={5,11,2,5,4,5,5};
+
+  struct GDL_TICKDATA
+  {
+    bool isLog;
+  };
+
+  struct GDL_TICKNAMEDATA
+  {
+    SizeT counter;
+    SizeT nTickName;
+    DStringGDL* TickName;
+    bool isLog;
+  };
+
+  struct GDL_MULTIAXISTICKDATA
+  {
+    EnvT *e;
+    SizeT counter;
+    int what;
+    SizeT nTickFormat;
+    DDouble axismin;
+    DDouble axismax;
+    DStringGDL* TickFormat;
+    SizeT nTickUnits;
+    DStringGDL* TickUnits;
+    bool isLog;
+  };
 
   // local helper function
-  void GetMinMaxVal( DDoubleGDL* val, double* minVal, double* maxVal)
+  DDouble gdlEpsDouble()
   {
-    DLong minE, maxE;
-    const bool omitNaN = true;
-    val->MinMax( &minE, &maxE, NULL, NULL, omitNaN);
-    if( minVal != NULL) *minVal = (*val)[ minE];
-    if( maxVal != NULL) *maxVal = (*val)[ maxE];
+    static bool done=FALSE;
+    if (!done)
+    {
+      long int ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, maxexp;
+      double epsD, epsnegD, xminD, xmaxD;
+      machar_d(&ibeta, &it, &irnd, &ngrd, &machep,
+                &negep, &iexp, &minexp, &maxexp,
+                &epsDouble, &epsnegD, &xminD, &xmaxD );
+      done=TRUE;
+    }
+    return epsDouble;
   }
+  DDouble gdlAbsoluteMinValueDouble()
+  {
+    static bool done=FALSE;
+    if (!done)
+    {
+      long int ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, maxexp;
+      double epsD, epsnegD, xminD, xmaxD;
+       machar_d(&ibeta, &it, &irnd, &ngrd, &machep,
+       &negep, &iexp, &minexp, &maxexp,
+       &epsD, &epsnegD, &absoluteMinVal, &xmaxD );
+      done=TRUE;
+    }
+    return absoluteMinVal;
+  }
+  DDouble gdlAbsoluteMaxValueDouble()
+  {
+    static bool done=FALSE;
+    if (!done)
+    {
+      long int ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, maxexp;
+      double epsD, epsnegD, xminD, xmaxD;
+       machar_d(&ibeta, &it, &irnd, &ngrd, &machep,
+       &negep, &iexp, &minexp, &maxexp,
+       &epsD, &epsnegD, &xminD, &absoluteMaxVal );
+      done=TRUE;
+    }
+    return absoluteMaxVal;
+  }
+
+  template <typename T> void gdlDoRangeExtrema(T* xVal, T* yVal, DDouble &min, DDouble &max, DDouble xmin, DDouble xmax, bool doMinMax, DDouble minVal, DDouble maxVal)
+  {
+    DDouble valx, valy;
+    SizeT i,k;
+    DLong n=xVal->N_Elements();
+    if(n!=yVal->N_Elements()) return;
+    for (i=0,k=0 ; i<n ; ++i)
+    {
+       valx=(*xVal)[i];
+       if (std::isnan(valx)) break;
+       valy=(*yVal)[i];
+       if (std::isnan(valy)) break;
+       if(valx<xmin || valx>xmax) break;
+       if (doMinMax &&(valy<minVal || valy>maxVal)) break;
+       if(k==0) {min=valy; max=valy;} else {min=gdlPlot_Min(min,valy); max=gdlPlot_Max(max,valy);}
+       k++;
+    }
+  }
+  template void gdlDoRangeExtrema(Data_<SpDDouble>*, Data_<SpDDouble>*, DDouble &, DDouble &, DDouble, DDouble, bool, DDouble, DDouble);
 
-
+  void GetMinMaxVal(DDoubleGDL* val, double* minVal, double* maxVal)
+  {
+    DLong minE, maxE;
+    const bool omitNaN=true;
+    val->MinMax(&minE, &maxE, NULL, NULL, omitNaN);
+    if ( minVal!=NULL ) *minVal=(*val)[ minE];
+    if ( maxVal!=NULL ) *maxVal=(*val)[ maxE];
+  }
+
+  //call this function if Y data is strictly >0.
+  //set yStart to 0 only if gdlYaxisNoZero is false.
+  bool gdlYaxisNoZero(EnvT* e)
+  {
+    //no explict range given?
+    SysVar::Y();
+    DDouble test1, test2;
+    static unsigned rangeTag=SysVar::Y()->Desc()->TagIndex("RANGE");
+    test1=(*static_cast<DDoubleGDL*>(SysVar::Y()->GetTag(rangeTag, 0)))[0];
+    test2=(*static_cast<DDoubleGDL*>(SysVar::Y()->GetTag(rangeTag, 0)))[1];
+    if(!(test1==0.0 && test2==0.0)) return TRUE;
+    if ( e->KeywordSet( "YRANGE")) return TRUE;
+    //Style contains 1?
+    DLong ystyle;
+    gdlGetDesiredAxisStyle(e, "Y", ystyle);
+    if (ystyle&1) return TRUE;
+
+    DLong nozero=0;
+    if (ystyle&16) nozero=1;
+    if ( e->KeywordSet( "YNOZERO")) nozero = 1;
+    return (nozero==1);
+  }
   PLFLT AutoTick(DDouble x)
   {
-    if( x == 0.0) return 1.0;
+    if ( x==0.0 ) return 1.0;
 
-    DLong n = static_cast<DLong>( floor(log10(x/3.5)));
-    DDouble y = (x / (3.5 * pow(10.,static_cast<double>(n))));
+    DLong n=static_cast<DLong>(floor(log10(x/3.5)));
+    DDouble y=(x/(3.5*pow(10., static_cast<double>(n))));
     DLong m;
-    if (y >= 1 && y < 2)
-      m = 1;
-    else if (y >= 2 && y < 5)
-      m = 2;
-    else if (y >= 5)
-      m = 5;
+    if ( y>=1&&y<2 )
+      m=1;
+    else if ( y>=2&&y<5 )
+      m=2;
+    else if ( y>=5 )
+      m=5;
 
-    PLFLT intv = (PLFLT) (m * pow(10.,static_cast<double>(n)));
+    PLFLT intv=(PLFLT)(m*pow(10., static_cast<double>(n)));
     return intv;
   }
 
-
   PLFLT AutoIntv(DDouble x)
   {
-    if( x == 0.0) {
+    if ( x==0.0 )
+    {
       //      cout << "zero"<<endl;
       return 1.0;
     }
 
-    DLong n = static_cast<DLong>( floor(log10(x/2.82)));
-    DDouble y = (x / (2.82 * pow(10.,static_cast<double>(n))));
+    DLong n=static_cast<DLong>(floor(log10(x/2.82)));
+    DDouble y=(x/(2.82*pow(10., static_cast<double>(n))));
     DLong m;
-    if (y >= 1 && y < 2)
-      m = 1;
-    else if (y >= 2 && y < 4.47)
-      m = 2;
-    else if (y >= 4.47)
-      m = 5;
+    if ( y>=1&&y<2 )
+      m=1;
+    else if ( y>=2&&y<4.47 )
+      m=2;
+    else if ( y>=4.47 )
+      m=5;
 
     //    cout << "AutoIntv" << x << " " << y << endl;
 
-    PLFLT intv = (PLFLT) (m * pow(10.,static_cast<double>(n)));
+    PLFLT intv=(PLFLT)(m*pow(10., static_cast<double>(n)));
+    return intv;
+  }
+
+  PLFLT gdlComputeTickInterval(EnvT *e, string axis, DDouble &min, DDouble &max, bool log)
+  {
+    DLong nticks=0;
+    DStructGDL* Struct;
+
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+
+    if ( Struct!=NULL )
+    {
+      static unsigned tickTag=Struct->Desc()->TagIndex("TICKS");
+      nticks=
+      (*static_cast<DLongGDL*>(Struct->GetTag(tickTag, 0)))[0];
+    }
+
+    string TitleName=axis+"TICKS";
+    e->AssureLongScalarKWIfPresent(TitleName, nticks);
+
+    PLFLT intv;
+    if (nticks == 0)
+    {
+      intv = (log)? AutoTick(log10(max-min)): AutoTick(max-min);
+    } else {
+      intv = (log)? log10(max-min)/nticks: (max-min)/nticks;
+    }
     return intv;
   }
 
+ #define EXTENDED_DEFAULT_LOGRANGE 12
+  //protect from (inverted, strange) axis log values
+  void gdlHandleUnwantedAxisValue(DDouble &min, DDouble &max, bool log)
+  {
+    bool invert=FALSE;
+    DDouble val_min, val_max;
+    if (!log) return;
+
+    if(max-min >= 0)
+    {
+      val_min=min;
+      val_max=max;
+      invert=FALSE;
+    } else {
+      val_min=max;
+      val_max=min;
+      invert=TRUE;
+    }
+
+    if ( val_min<=0. )
+    {
+      if ( val_max<=0. )
+      {
+        val_min=-EXTENDED_DEFAULT_LOGRANGE;
+        val_max=0.0;
+      }
+      else
+      {
+        val_min=log10(val_max)-EXTENDED_DEFAULT_LOGRANGE;
+        val_max=log10(val_max);
+      }
+    }
+    else
+    {
+      val_min=log10(val_min);
+      val_max=log10(val_max);
+    }
+    if (invert)
+    {
+      min=pow(10.,val_max);
+      max=pow(10.,val_min);
+    } else {
+      min=pow(10.,val_min);
+      max=pow(10.,val_max);
+    }
+
+  }
+#undef EXTENDED_DEFAULT_LOGRANGE
+
+
   //improved version of "AutoIntv" for:
   // 1/ better managing ranges when all the data have same value
   // 2/ mimic IDL behavior when data are all positive
   // please notice that (val_min, val_max) will be changed
   // and "epsilon" is a coefficient if "extended range" is expected
-  PLFLT AutoIntvAC(DDouble &val_min, DDouble &val_max, DLong NoZero, bool log)
+  // input: linear min and max, output: linear min and max.
+
+  PLFLT AutoIntvAC(DDouble &start, DDouble &end, bool log)
   {
-    PLFLT intv = 1.;
-    int cas = 0 ;
-    DDouble x;
-    bool debug = false ;
-    if (debug) {cout << "init: " <<  val_min << " " << val_max << endl;}
+    gdlHandleUnwantedAxisValue(start, end, log);
+
+    DDouble min, max;
+    bool invert=FALSE;
 
-    if (log)
+    if(end-start >= 0)
     {
-      if (val_min == 0 || val_max == 0) return intv;
-      val_min = log10(val_min);
-      val_max = log10(val_max);
+      min=start;
+      max=end;
+      invert=FALSE;
+    } else {
+      min=end;
+      max=start;
+      invert=TRUE;
     }
 
+    PLFLT intv=1.;
+    int cas=0;
+    DDouble x;
+    bool debug=false;
+    if ( debug )
+    {
+      cout<<"init: "<<min<<" "<<max<<endl;
+    }
+    //retrieve eps Double
     // case "all below ABS((MACHAR()).xmin)
-    if ((abs(val_min) < 1e-38) && (abs(val_max) < 1e-38))
-      {
-	val_min=DDouble(-1.);
-	val_max=DDouble( 1.);
-	intv = (PLFLT) (2.);
-	cas = 1 ;
-      }
+    if ( !log && (abs(min)<=gdlEpsDouble()) && (abs(max)<gdlEpsDouble()) )
+    {
+      min=DDouble(0.);
+      max=DDouble(1.);
+      intv=(PLFLT)(2.);
+      cas=1;
+    }
 
-    // case "all values are equal"
-    if (cas == 0)
-      {
-	x=val_max-val_min;
-	if (abs(x) < 1e-30) {
-	  DDouble val_ref;
-          val_ref=val_max;
-          if (0.98*val_min < val_ref) { // positive case
-            val_max=1.02*val_ref;
-            val_min=0.98*val_ref;
-          } else {     // negative case
-            val_max=0.98*val_ref;
-            val_min=1.02*val_ref;
-          }
-          if (debug) {cout << "Rescale : " << val_min << " " << val_max << endl;}
-	}
-      }
+    if(log)
+    {
+      min=log10(min);
+      max=log10(max);
+    }
 
-    // case "all data positive, must start at Zero" (mimic IDL behavior)
-    if ((cas == 0) && (val_min >= 0.0) && (NoZero == 0))
+    // case "all values are equal"
+    if ( cas==0 )
+    {
+      x=max-min;
+      if ( abs(x)<1e-30 )
       {
-	cas = 2 ;
-	DDouble resu, val_norm ;
-	// we used redundant scale (1.,1.2 and 10., 12. to avoid roundoff problem in log10)
-	DDouble levels[12]={1.,1.2,1.5,2.,2.5,3.,4.,5.,6.,8.,10.,12.};
-	int nb_levels= 12;
-
-	DLong n = static_cast<DLong>( floor(log10(val_max)));
-	DDouble scale= pow(10.,static_cast<double>(n));
-
-	val_norm=val_max/scale;
-
-	resu=levels[0];
-	for (int c = 0; c < nb_levels; c++) {
-	  if ((val_norm > levels[c]) && (val_norm <= levels[c+1])) resu=levels[c+1] ;
-	}
-	val_min=0.0;
-	val_max=resu*scale;
-	intv = (PLFLT)(val_max);
+        DDouble val_ref;
+        val_ref=max;
+        if ( 0.98*min<val_ref )
+        { // positive case
+          max=1.02*val_ref;
+          min=0.98*val_ref;
+        }
+        else
+        { // negative case
+          max=0.98*val_ref;
+          min=1.02*val_ref;
+        }
+        if ( debug )
+        {
+          cout<<"Rescale : "<<min<<" "<<max<<endl;
+        }
       }
+    }
 
     // general case (only negative OR negative and positive)
-    if (cas == 0)
-      {
-	x=val_max-val_min;
-	intv = AutoIntv( x);
-	val_max = ceil(val_max/intv) * intv;
-	val_min = floor(val_min/intv) * intv;
-      }
-
-    if (debug) {cout << "cas: "<< cas << " new range: "<<  val_min << " " << val_max << endl;}
-
-    if (log)
+    if ( cas==0 )
     {
-      val_min = pow(10, val_min);
-      val_max = pow(10, val_max);
+      x=max-min;
+      intv=AutoIntv(x);
+      max=ceil(max/intv)*intv;
+      min=floor(min/intv)*intv;
     }
 
+    if ( debug )
+    {
+      cout<<"cas: "<<cas<<" new range: "<<min<<" "<<max<<endl;
+    }
+    //give back non-log values
+    if ( log )
+    {
+      min=pow(10, min);
+      max=pow(10, max);
+    }
+    if (invert)
+    {
+      start=max;
+      end=min;
+    } else {
+      start=min;
+      end=max;
+    }
     return intv;
   }
 
   // !P
-  void GetPData( DLong& p_background,
-		 DLong& p_noErase, DLong& p_color, DLong& p_psym,
-		 DLong& p_linestyle,
-		 DFloat& p_symsize, DFloat& p_charsize, DFloat& p_thick,
-		 DString& p_title, DString& p_subTitle, DFloat& p_ticklen)
-  {
-    static DStructGDL* pStruct = SysVar::P();
-    static unsigned backgroundTag = pStruct->Desc()->TagIndex( "BACKGROUND");
-    static unsigned noEraseTag = pStruct->Desc()->TagIndex( "NOERASE");
-    static unsigned colorTag = pStruct->Desc()->TagIndex( "COLOR");
-    static unsigned psymTag = pStruct->Desc()->TagIndex( "PSYM");
-    static unsigned linestyleTag = pStruct->Desc()->TagIndex( "LINESTYLE");
-    static unsigned symsizeTag = pStruct->Desc()->TagIndex( "SYMSIZE");
-    static unsigned charsizeTag = pStruct->Desc()->TagIndex( "CHARSIZE");
-    static unsigned thickTag = pStruct->Desc()->TagIndex( "THICK");
-    static unsigned ticklenTag = pStruct->Desc()->TagIndex( "TICKLEN");
-    static unsigned titleTag = pStruct->Desc()->TagIndex( "TITLE");
-    static unsigned subTitleTag = pStruct->Desc()->TagIndex( "SUBTITLE");
-    p_background =
-      (*static_cast<DLongGDL*>( pStruct->GetTag( backgroundTag, 0)))[0];
-    p_noErase =
-      (*static_cast<DLongGDL*>( pStruct->GetTag( noEraseTag, 0)))[0];
-    p_color =
-      (*static_cast<DLongGDL*>( pStruct->GetTag( colorTag, 0)))[0];
-    p_psym =
-      (*static_cast<DLongGDL*>( pStruct->GetTag( psymTag, 0)))[0];
-    p_linestyle =
-      (*static_cast<DLongGDL*>( pStruct->GetTag( linestyleTag, 0)))[0];
-    p_symsize =
-      (*static_cast<DFloatGDL*>( pStruct->GetTag( symsizeTag, 0)))[0];
-    p_charsize =
-      (*static_cast<DFloatGDL*>( pStruct->GetTag( charsizeTag, 0)))[0];
-    p_thick =
-      (*static_cast<DFloatGDL*>( pStruct->GetTag( thickTag, 0)))[0];
-    p_title =
-      (*static_cast<DStringGDL*>( pStruct->GetTag( titleTag, 0)))[0];
-    p_subTitle =
-      (*static_cast<DStringGDL*>( pStruct->GetTag( subTitleTag, 0)))[0];
-    p_ticklen =
-      (*static_cast<DFloatGDL*>( pStruct->GetTag( ticklenTag, 0)))[0];
+
+  void GetPData(
+                DLong& p_background,
+                DLong& p_noErase, DLong& p_color, DLong& p_psym,
+                DLong& p_linestyle,
+                DFloat& p_symsize, DFloat& p_charsize, DFloat& p_thick,
+                DString& p_title, DString& p_subTitle, DFloat& p_ticklen)
+  {
+    static DStructGDL* pStruct=SysVar::P();
+    static unsigned backgroundTag=pStruct->Desc()->TagIndex("BACKGROUND");
+    static unsigned noEraseTag=pStruct->Desc()->TagIndex("NOERASE");
+    static unsigned colorTag=pStruct->Desc()->TagIndex("COLOR");
+    static unsigned psymTag=pStruct->Desc()->TagIndex("PSYM");
+    static unsigned linestyleTag=pStruct->Desc()->TagIndex("LINESTYLE");
+    static unsigned symsizeTag=pStruct->Desc()->TagIndex("SYMSIZE");
+    static unsigned charsizeTag=pStruct->Desc()->TagIndex("CHARSIZE");
+    static unsigned thickTag=pStruct->Desc()->TagIndex("THICK");
+    static unsigned ticklenTag=pStruct->Desc()->TagIndex("TICKLEN");
+    static unsigned titleTag=pStruct->Desc()->TagIndex("TITLE");
+    static unsigned subTitleTag=pStruct->Desc()->TagIndex("SUBTITLE");
+    p_background=
+    (*static_cast<DLongGDL*>(pStruct->GetTag(backgroundTag, 0)))[0];
+    p_noErase=
+    (*static_cast<DLongGDL*>(pStruct->GetTag(noEraseTag, 0)))[0];
+    p_color=
+    (*static_cast<DLongGDL*>(pStruct->GetTag(colorTag, 0)))[0];
+    p_psym=
+    (*static_cast<DLongGDL*>(pStruct->GetTag(psymTag, 0)))[0];
+    p_linestyle=
+    (*static_cast<DLongGDL*>(pStruct->GetTag(linestyleTag, 0)))[0];
+    p_symsize=
+    (*static_cast<DFloatGDL*>(pStruct->GetTag(symsizeTag, 0)))[0];
+    p_charsize=
+    (*static_cast<DFloatGDL*>(pStruct->GetTag(charsizeTag, 0)))[0];
+    p_thick=
+    (*static_cast<DFloatGDL*>(pStruct->GetTag(thickTag, 0)))[0];
+    p_title=
+    (*static_cast<DStringGDL*>(pStruct->GetTag(titleTag, 0)))[0];
+    p_subTitle=
+    (*static_cast<DStringGDL*>(pStruct->GetTag(subTitleTag, 0)))[0];
+    p_ticklen=
+    (*static_cast<DFloatGDL*>(pStruct->GetTag(ticklenTag, 0)))[0];
+  }
+
+  void GetPData2(pstruct& p)
+  {
+    int i, j;
+    static DStructGDL* pStruct=SysVar::P();
+
+    static unsigned backgroundTag=pStruct->Desc()->TagIndex("BACKGROUND");
+    p.background=
+    (*static_cast<DLongGDL*>(pStruct->GetTag(backgroundTag, 0)))[0];
+
+    static unsigned charsizeTag=pStruct->Desc()->TagIndex("CHARSIZE");
+    p.charSize=
+    (*static_cast<DFloatGDL*>(pStruct->GetTag(charsizeTag, 0)))[0];
+
+    static unsigned charthickTag=pStruct->Desc()->TagIndex("CHARTHICK");
+    p.charThick=
+    (*static_cast<DFloatGDL*>(pStruct->GetTag(charthickTag, 0)))[0];
+
+    static unsigned clipTag=pStruct->Desc()->TagIndex("CLIP");
+    for ( i=0; i<6; ++i ) p.clip[i]=(*static_cast<DLongGDL*>(pStruct->GetTag(clipTag, 0)))[i];
+
+    static unsigned colorTag=pStruct->Desc()->TagIndex("COLOR");
+    p.color=
+    (*static_cast<DLongGDL*>(pStruct->GetTag(colorTag, 0)))[0];
+
+    static unsigned fontTag=pStruct->Desc()->TagIndex("FONT");
+    p.font=
+    (*static_cast<DLongGDL*>(pStruct->GetTag(fontTag, 0)))[0];
+
+    static unsigned linestyleTag=pStruct->Desc()->TagIndex("LINESTYLE");
+    p.lineStyle=
+    (*static_cast<DLongGDL*>(pStruct->GetTag(linestyleTag, 0)))[0];
+
+    static unsigned multiTag=pStruct->Desc()->TagIndex("MULTI");
+    for ( i=0; i<5; ++i ) p.multi[i]=
+    (*static_cast<DLongGDL*>(pStruct->GetTag(multiTag, 0)))[i];
+
+    static unsigned noClipTag=pStruct->Desc()->TagIndex("NOCLIP");
+    p.noClip=
+    (*static_cast<DLongGDL*>(pStruct->GetTag(noClipTag, 0)))[0];
+
+    static unsigned noEraseTag=pStruct->Desc()->TagIndex("NOERASE");
+    p.noErase=
+    (*static_cast<DLongGDL*>(pStruct->GetTag(noEraseTag, 0)))[0];
+
+    static unsigned nsumTag=pStruct->Desc()->TagIndex("NSUM");
+    p.nsum=
+    (*static_cast<DLongGDL*>(pStruct->GetTag(nsumTag, 0)))[0];
+
+    static unsigned positionTag=pStruct->Desc()->TagIndex("POSITION");
+    for ( i=0; i<4; ++i ) p.position[i]=
+    (*static_cast<DFloatGDL*>(pStruct->GetTag(positionTag, 0)))[i];
+
+    static unsigned psymTag=pStruct->Desc()->TagIndex("PSYM");
+    p.psym=
+    (*static_cast<DLongGDL*>(pStruct->GetTag(psymTag, 0)))[0];
+
+    static unsigned regionTag=pStruct->Desc()->TagIndex("REGION");
+    for ( i=0; i<4; ++i ) p.region[i]=
+    (*static_cast<DFloatGDL*>(pStruct->GetTag(regionTag, 0)))[i];
+
+    static unsigned subtitleTag=pStruct->Desc()->TagIndex("SUBTITLE");
+    p.subTitle=
+    (*static_cast<DStringGDL*>(pStruct->GetTag(subtitleTag, 0)))[0];
+
+    static unsigned symsizeTag=pStruct->Desc()->TagIndex("SYMSIZE");
+    p.symSize=
+    (*static_cast<DFloatGDL*>(pStruct->GetTag(symsizeTag, 0)))[0];
+
+    static unsigned tTag=pStruct->Desc()->TagIndex("T");
+    for ( i=0; i<4; ++i ) for ( j=0; j<4; ++j ) p.t[i][j]=
+      (*static_cast<DDoubleGDL*>(pStruct->GetTag(tTag, 0)))[j*4+i];
+
+    static unsigned t3dTag=pStruct->Desc()->TagIndex("T3D");
+    p.t3d=
+    (*static_cast<DLongGDL*>(pStruct->GetTag(t3dTag, 0)))[0];
+
+    static unsigned thickTag=pStruct->Desc()->TagIndex("THICK");
+    p.thick=
+    (*static_cast<DFloatGDL*>(pStruct->GetTag(thickTag, 0)))[0];
+
+    static unsigned titleTag=pStruct->Desc()->TagIndex("TITLE");
+    p.title=
+    (*static_cast<DStringGDL*>(pStruct->GetTag(titleTag, 0)))[0];
+
+    static unsigned ticklenTag=pStruct->Desc()->TagIndex("TICKLEN");
+    p.ticklen=
+    (*static_cast<DFloatGDL*>(pStruct->GetTag(ticklenTag, 0)))[0];
+
+    static unsigned channelTag=pStruct->Desc()->TagIndex("CHANNEL");
+    p.channel=
+    (*static_cast<DLongGDL*>(pStruct->GetTag(channelTag, 0)))[0];
   }
 
   // !X, !Y, !Z
-  void GetAxisData( DStructGDL* xStruct,
-		    DLong& style, DString& title, DFloat& charSize,
-		    DFloat& margin0, DFloat& margin1, DFloat& ticklen)
-  {
-    static unsigned styleTag = xStruct->Desc()->TagIndex( "STYLE");
-    static unsigned marginTag = xStruct->Desc()->TagIndex( "MARGIN");
-    static unsigned axisTitleTag = xStruct->Desc()->TagIndex( "TITLE");
-    static unsigned axischarsizeTag = xStruct->Desc()->TagIndex( "CHARSIZE");
-    static unsigned ticklenTag = xStruct->Desc()->TagIndex( "TICKLEN");
-    style =
-      (*static_cast<DLongGDL*>( xStruct->GetTag( styleTag, 0)))[0];
-    title =
-      (*static_cast<DStringGDL*>( xStruct->GetTag( axisTitleTag, 0)))[0];
-    charSize =
-      (*static_cast<DFloatGDL*>( xStruct->GetTag( axischarsizeTag, 0)))[0];
-    margin0 =
-      (*static_cast<DFloatGDL*>( xStruct->GetTag( marginTag, 0)))[0];
-    margin1 =
-      (*static_cast<DFloatGDL*>( xStruct->GetTag( marginTag, 0)))[1];
-    ticklen =
-      (*static_cast<DFloatGDL*>( xStruct->GetTag( ticklenTag, 0)))[0];
-  }
-
-  void GetUserSymSize(EnvT *e,  GDLGStream *a, DDouble& UsymConvX, DDouble& UsymConvY)
-  {
-    DDouble *scaleX, *scaleY;
-    GetSFromPlotStructs(&scaleX, &scaleY);
-    // get subpage in mm
-    PLFLT scrXL, scrXR, scrYB, scrYT;
-    a->gspa( scrXL, scrXR, scrYB, scrYT);
-    PLFLT scrX = scrXR-scrXL;
-    PLFLT scrY = scrYT-scrYB;
-    // get char size in mm (default, actual)
-    PLFLT defH, actH;
-    a->gchr( defH, actH);
-    //get symsize
-    static DStructGDL* pStruct = SysVar::P();
-    DFloat symsize = (*static_cast<DFloatGDL*>
-		      (pStruct->GetTag( pStruct->Desc()->TagIndex("SYMSIZE"), 0)))[0];
-    e->AssureFloatScalarKWIfPresent( "SYMSIZE", symsize);
-    if( symsize <= 0.0) symsize = 1.0;
-    UsymConvX=0.5*symsize*(defH/scrX)/scaleX[1];
-    UsymConvY=0.5*symsize*(defH/scrY)/scaleY[1];
 
+  void GetAxisData(DStructGDL* xStruct,
+                   DLong& style, DString& title, DFloat& charSize,
+                   DFloat& margin0, DFloat& margin1, DFloat& ticklen)
+  {
+    static unsigned styleTag=xStruct->Desc()->TagIndex("STYLE");
+    static unsigned marginTag=xStruct->Desc()->TagIndex("MARGIN");
+    static unsigned axisTitleTag=xStruct->Desc()->TagIndex("TITLE");
+    static unsigned axischarsizeTag=xStruct->Desc()->TagIndex("CHARSIZE");
+    static unsigned ticklenTag=xStruct->Desc()->TagIndex("TICKLEN");
+    style=
+    (*static_cast<DLongGDL*>(xStruct->GetTag(styleTag, 0)))[0];
+    title=
+    (*static_cast<DStringGDL*>(xStruct->GetTag(axisTitleTag, 0)))[0];
+    charSize=
+    (*static_cast<DFloatGDL*>(xStruct->GetTag(axischarsizeTag, 0)))[0];
+    margin0=
+    (*static_cast<DFloatGDL*>(xStruct->GetTag(marginTag, 0)))[0];
+    margin1=
+    (*static_cast<DFloatGDL*>(xStruct->GetTag(marginTag, 0)))[1];
+    ticklen=
+    (*static_cast<DFloatGDL*>(xStruct->GetTag(ticklenTag, 0)))[0];
+  }
+
+  void GetUserSymSize(EnvT *e, GDLGStream *a, DDouble& UsymConvX, DDouble& UsymConvY)
+  {
+    //get symsize
+    static DStructGDL* pStruct=SysVar::P();
+    DFloat symsize=(*static_cast<DFloatGDL*>
+                    (pStruct->GetTag(pStruct->Desc()->TagIndex("SYMSIZE"), 0)))[0];
+    e->AssureFloatScalarKWIfPresent("SYMSIZE", symsize);
+    if ( symsize<=0.0 ) symsize=1.0;
+    
+    a->updatePageInfo(); a->UpdateCurrentCharWorldSize();
+
+    UsymConvX=(0.5*symsize*(a->wCharLength()/a->charScale())); //be dependent only on symsize!
+    UsymConvY=(0.5*symsize*(a->wCharHeight()/a->charScale()));
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"GetUserSymSize(%f,%f)\n",a->wCharLength(),a->wCharHeight());
   }
 
   void AdjustAxisOpts(string& xOpt, string& yOpt,
-    DLong xStyle, DLong yStyle, DLong xTicks, DLong yTicks,
-    string& xTickformat, string& yTickformat, DLong xLog, DLong yLog
-  ) // {{{
-  {
-    if ((xStyle & 8) == 8) xOpt = "b";
-    if ((yStyle & 8) == 8) yOpt = "b";
-
-    if (xTicks == 1) xOpt += "t"; else xOpt += "st";
-    if (yTicks == 1) yOpt += "tv"; else yOpt += "stv";
-
-    if (xTickformat != "(A1)") xOpt += "n";
-    if (yTickformat != "(A1)") yOpt += "n";
-
-    if( xLog) xOpt += "l";
-    if( yLog) yOpt += "l";
-
-    if ((xStyle & 4) == 4) xOpt = "";
-    if ((yStyle & 4) == 4) yOpt = "";
-  } // }}}
-
-  void CheckMargin( EnvT* e, GDLGStream* actStream,
-		    DFloat xMarginL,
-		    DFloat xMarginR,
-		    DFloat yMarginB,
-		    DFloat yMarginT,
-		    PLFLT& xMR,
-		    PLFLT& xML,
-		    PLFLT& yMB,
-		    PLFLT& yMT)
-  {
-    // get subpage in mm
-    PLFLT scrXL, scrXR, scrYB, scrYT;
-    actStream->gspa( scrXL, scrXR, scrYB, scrYT);
-    PLFLT scrX = scrXR-scrXL;
-    PLFLT scrY = scrYT-scrYB;
-
-    // get char size in mm (default, actual)
-    PLFLT defH, actH;
-    actStream->gchr( defH, actH);
-
-    xML = xMarginL * actH / scrX;
-    xMR = xMarginR * actH / scrX;
-
-    // factor 1.111 by ACoulais on 16/12/2010. Consequences on CONVERT_COORD
-    const float yCharExtension = 1.5*1.11111;
-    yMB = yMarginB * actH / scrY * yCharExtension;
-    yMT = yMarginT * actH / scrY * yCharExtension;
-
-    if( xML+xMR >= 1.0)
-      {
-	Message( e->GetProName() + ": XMARGIN to large (adjusted).");
-	PLFLT xMMult = xML+xMR;
-	xML /= xMMult * 1.5;
-	xMR /= xMMult * 1.5;
-      }
-    if( yMB+yMT >= 1.0)
-      {
-	Message( e->GetProName() + ": YMARGIN to large (adjusted).");
-	PLFLT yMMult = yMB+yMT;
-	yMB /= yMMult * 1.5;
-	yMT /= yMMult * 1.5;
-      }
-  }
- void Clipping( DDoubleGDL* clippingD,
-		 DDouble& xStart,
-		 DDouble& xEnd,
-		 DDouble& minVal,
-		 DDouble& maxVal)
-  { //do nothing, clipping should not be done thusly.
-  }
- // temporary ignor clipping
-//  void Clipping( DDoubleGDL* clippingD,
-//		 DDouble& xStart,
-//		 DDouble& xEnd,
-//		 DDouble& minVal,
-//		 DDouble& maxVal)
-//  {
-//    SizeT cEl=clippingD->N_Elements();
-//
-//    // world coordinates
-//    DDouble wcxs, wcxe,wcys, wcye;
-//
-//    if(cEl >= 1) wcxs=(*clippingD)[0]; else wcxs=0;
-//    if(cEl >= 2) wcys=(*clippingD)[1]; else wcys=0;
-//    if(cEl >= 3) wcxe=(*clippingD)[2]; else wcxe=wcxs;
-//    if(cEl >= 4) wcye=(*clippingD)[3]; else wcye=wcys;
-//
-//    if(wcxe < wcxs ) wcxe=wcxs;
-//    if(wcye < wcys ) wcye=wcys;
-//
-//    //     // viewport (0..1)
-//    //     DDouble cxs, cxe,cys, cye;
-//    //     cxs=(-xStart+wcxs)*(1-0)/(xEnd-xStart);
-//    //     cxe=(-xStart+wcxe)*(1-0)/(xEnd-xStart);
-//    //     cys=(-yStart+wcys)*(1-0)/(yEnd-yStart);
-//    //     cye=(-yStart+wcye)*(1-0)/(yEnd-yStart);
-//    //     actStream->vpor(cxs, cxe, cys, cye);
-//
-//    xStart=wcxs; xEnd=wcxe; minVal=wcys; maxVal=wcye;
-//  }
+                      DLong xStyle, DLong yStyle, DLong xTicks, DLong yTicks,
+                      string& xTickformat, string& yTickformat, DLong xLog, DLong yLog
+                      )
+  {
+    if ( (xStyle&8)==8 ) xOpt="b";
+    if ( (yStyle&8)==8 ) yOpt="b";
+
+    if ( xTicks==1 ) xOpt+="t";
+    else xOpt+="st";
+    if ( yTicks==1 ) yOpt+="tv";
+    else yOpt+="stv";
+
+    if ( xTickformat!="(A1)" ) xOpt+="n";
+    if ( yTickformat!="(A1)" ) yOpt+="n";
+
+    if ( xLog ) xOpt+="l";
+    if ( yLog ) yOpt+="l";
+
+    if ( (xStyle&4)==4 ) xOpt="";
+    if ( (yStyle&4)==4 ) yOpt="";
+  }
+
+
+  void CheckMargin3d(EnvT* e, GDLGStream* actStream,
+                   PLFLT& xMR,
+                   PLFLT& xML,
+                   PLFLT& yMB,
+                   PLFLT& yMT)
+  {
+    // [XY]MARGIN
+    DFloat xMarginL, xMarginR, yMarginB, yMarginT;
+    gdlGetDesiredAxisMargin(e, "X", xMarginL, xMarginR);
+    gdlGetDesiredAxisMargin(e, "Y", yMarginB, yMarginT);
+//    PLFLT scl=actStream->dCharLength()/actStream->xSubPageSize(); //current char length/subpage size
+    PLFLT scl=actStream->nCharLength(); //current char length
+    xML=xMarginL*scl; //margin as percentage of subpage
+    xMR=xMarginR*scl;
+    cout<<scl<<","<<xML<<endl;
+//    scl=actStream->dCharHeight()/actStream->ySubPageSize(); //current char length/subpage size
+    scl=actStream->nCharHeight(); //current char height
+    cout<<scl<<endl;
+    yMB=(yMarginB)*scl;
+    yMT=(yMarginT)*scl;
+
+    if ( xML+xMR>=1.0 )
+    {
+      Message(e->GetProName()+": XMARGIN to large (adjusted).");
+      PLFLT xMMult=xML+xMR;
+      xML/=xMMult*1.5;
+      xMR/=xMMult*1.5;
+    }
+    if ( yMB+yMT>=1.0 )
+    {
+      Message(e->GetProName()+": YMARGIN to large (adjusted).");
+      PLFLT yMMult=yMB+yMT;
+      yMB/=yMMult*1.5;
+      yMT/=yMMult*1.5;
+    }
+  }
+
+
+  void CheckMargin(EnvT* e, GDLGStream* actStream,
+                   DFloat xMarginL,
+                   DFloat xMarginR,
+                   DFloat yMarginB,
+                   DFloat yMarginT,
+                   PLFLT& xMR,
+                   PLFLT& xML,
+                   PLFLT& yMB,
+                   PLFLT& yMT)
+  {
+    PLFLT scl=actStream->dCharLength()/actStream->xSubPageSize(); //current char length/subpage size
+    xML=xMarginL*scl; //margin as percentage of subpage
+    xMR=xMarginR*scl;
+    scl=actStream->dCharHeight()/actStream->ySubPageSize(); //current char length/subpage size
+    yMB=(yMarginB+1.85)*scl;
+    yMT=(yMarginT+1)*scl;
+
+    if ( xML+xMR>=1.0 )
+    {
+      Message(e->GetProName()+": XMARGIN to large (adjusted).");
+      PLFLT xMMult=xML+xMR;
+      xML/=xMMult*1.5;
+      xMR/=xMMult*1.5;
+    }
+    if ( yMB+yMT>=1.0 )
+    {
+      Message(e->GetProName()+": YMARGIN to large (adjusted).");
+      PLFLT yMMult=yMB+yMT;
+      yMB/=yMMult*1.5;
+      yMT/=yMMult*1.5;
+    }
+  }
+
   void setIsoPort(GDLGStream* actStream,
-  PLFLT x1,
-  PLFLT x2,
-  PLFLT y1,
-  PLFLT y2,
-  PLFLT aspect)
+                  PLFLT x1,
+                  PLFLT x2,
+                  PLFLT y1,
+                  PLFLT y2,
+                  PLFLT aspect)
   {
-    PLFLT X1, X2, Y1, Y2, X1s, X2s, Y1s, Y2s, displacx,displacy, scalex,scaley,offsetx,offsety;
-    if (aspect <= 0.0)
+    PLFLT X1, X2, Y1, Y2, X1s, X2s, Y1s, Y2s, displacx, displacy, scalex, scaley, offsetx, offsety;
+    if ( aspect<=0.0 )
     {
       actStream->vpor(x1, x2, y1, y2);
       return;
     }
     // here we need too compensate for the change of aspect due to eventual !P.MULTI plots
-     actStream->vpor(x1, x2, y1, y2); //ask for non-iso window
-     actStream->gvpd(X1, X2, Y1, Y2); //get viewport values
-     //compute relation desiredViewport-page viewport x=scalex*X+offsetx:
-     scalex=(x2-x1)/(X2-X1);
-     offsetx=(x1*X2-x2*X1)/(X2-X1);
-     scaley=(y2-y1)/(Y2-Y1);
-     offsety=(y1*Y2-y2*Y1)/(Y2-Y1);
-     //ask for wiewport scaled to isotropic by plplot
-     actStream->vpas(x1, x2, y1, y2, aspect);
-     //retrieve values
-     actStream->gvpd(X1s, X2s, Y1s, Y2s);
-     //measure displacement
-     displacx=X1s-X1;
-     displacy=Y1s-Y1;
-     //set wiewport scaled by plplot, displaced, as vpor using above linear transformation
-     x1=(X1s-displacx)*scalex+offsetx;
-     x2=(X2s-displacx)*scalex+offsetx;
-     y1=(Y1s-displacy)*scaley+offsety;
-     y2=(Y2s-displacy)*scaley+offsety;
-     actStream->vpor(x1, x2, y1, y2);
-}
-
-  bool SetVP_WC( EnvT* e,
-		 GDLGStream* actStream,
-		 DFloatGDL* pos,
-		 DDoubleGDL* clippingD,
-		 bool xLog, bool yLog,
-		 DFloat xMarginL,
-		 DFloat xMarginR,
-		 DFloat yMarginB,
-		 DFloat yMarginT,
-		 // input/output
-		 DDouble xStart,
-		 DDouble xEnd,
-		 DDouble yStart,
-		 DDouble yEnd,
-         DLong iso   )
-  {
-    //    cout << "xStart " << xStart << "  xEnd "<<xEnd<<endl;
-    //    cout << "yStart " << yStart << "  yEnd "<<yEnd<<endl;
+    actStream->vpor(x1, x2, y1, y2); //ask for non-iso window
+    actStream->gvpd(X1, X2, Y1, Y2); //get viewport values
+    //compute relation desiredViewport-page viewport x=scalex*X+offsetx:
+    scalex=(x2-x1)/(X2-X1);
+    offsetx=(x1*X2-x2*X1)/(X2-X1);
+    scaley=(y2-y1)/(Y2-Y1);
+    offsety=(y1*Y2-y2*Y1)/(Y2-Y1);
+    //ask for wiewport scaled to isotropic by plplot
+    actStream->vpas(x1, x2, y1, y2, aspect);
+    //retrieve values
+    actStream->gvpd(X1s, X2s, Y1s, Y2s);
+    //measure displacement
+    displacx=X1s-X1;
+    displacy=Y1s-Y1;
+    //set wiewport scaled by plplot, displaced, as vpor using above linear transformation
+    x1=(X1s-displacx)*scalex+offsetx;
+    x2=(X2s-displacx)*scalex+offsetx;
+    y1=(Y1s-displacy)*scaley+offsety;
+    y2=(Y2s-displacy)*scaley+offsety;
+    actStream->vpor(x1, x2, y1, y2);
+  }
+
+  bool gdlSet3DViewPortAndWorldCoordinates(EnvT* e,
+                                           GDLGStream* actStream,
+                                           DDoubleGDL* Matrix,
+                                           bool xLog, bool yLog,
+                                           DDouble xStart,
+                                           DDouble xEnd,
+                                           DDouble yStart,
+                                           DDouble yEnd,
+                                           DDouble zStart,
+                                           DDouble zEnd,
+                                           bool zLog)
+  {
+    // First, do as gdlSetViewPortAndWorldCoordinates, save some values:
+    // set ![XY].CRANGE
+    gdlStoreAxisCRANGE("X", xStart, xEnd, xLog);
+    gdlStoreAxisCRANGE("Y", yStart, yEnd, yLog);
+    gdlStoreAxisCRANGE("Z", zStart, zEnd, zLog);
+    //set ![XY].type
+    gdlStoreAxisType("X",xLog);
+    gdlStoreAxisType("Y",yLog);
+    gdlStoreAxisType("Z",zLog);
+    //set ![XY].WINDOW and ![XY].S
+    gdlStoreAxisSandWINDOW(actStream, "X", xStart, xEnd, xLog);
+    gdlStoreAxisSandWINDOW(actStream, "Y", yStart, yEnd, yLog);
+    gdlStoreAxisSandWINDOW(actStream, "Z", zStart, zEnd, zLog);
+
+    //3D work
+    enum{ DATA=0,
+          NORMAL,
+          DEVICE
+        } coordinateSystem=DATA;
+    //To center plot, compute projected corners of 1 unit box
+    static DDouble zz[8]={0,0,0,0,1,1,1,1};
+    static DDouble yy[8]={0,0,1,1,0,0,1,1};
+    static DDouble xx[8]={0,1,0,1,0,1,0,1};
+    static DDouble ww[8]={1,1,1,1,1,1,1,1};
+
+    DDoubleGDL* V=(new DDoubleGDL(dimension(8,4)));
+    memcpy(&((*V)[0]),xx,8*sizeof(double));
+    memcpy(&((*V)[8]),yy,8*sizeof(double));
+    memcpy(&((*V)[16]),zz,8*sizeof(double));
+    memcpy(&((*V)[24]),ww,8*sizeof(double));
+
+    DDoubleGDL* pV=(Matrix->MatrixOp(V,false,true));
+
+    DDouble xmin,xmax,ymin,ymax;
+    DLong iMin,iMax;
+    pV->MinMax(&iMin,&iMax,NULL,NULL,false,0,0,4);
+    xmin=(*pV)[iMin];
+    xmax=(*pV)[iMax];
+    pV->MinMax(&iMin,&iMax,NULL,NULL,false,1,0,4);
+    ymin=(*pV)[iMin];
+    ymax=(*pV)[iMax];
+
+    PLFLT xMR, xML, yMB, yMT;
+    DFloat xMarginL, xMarginR, yMarginB, yMarginT;
+    gdlGetDesiredAxisMargin(e, "X", xMarginL, xMarginR);
+    gdlGetDesiredAxisMargin(e, "Y", yMarginB, yMarginT);
+    PLFLT scl=actStream->nCharLength(); //current char length
+    xML=xMarginL*scl; //margin as percentage of subpage
+    xMR=xMarginR*scl;
+    scl=actStream->nCharHeight(); //current char height
+    yMB=(yMarginB)*scl;
+    yMT=(yMarginT)*scl;
+
+    if ( xML+xMR>=1.0 )
+    {
+      PLFLT xMMult=xML+xMR;
+      xML/=xMMult*1.5;
+      xMR/=xMMult*1.5;
+    }
+    if ( yMB+yMT>=1.0 )
+    {
+      PLFLT yMMult=yMB+yMT;
+      yMB/=yMMult*1.5;
+      yMT/=yMMult*1.5;
+    }
+
+    static bool kwP=FALSE;
+    PLFLT positionP[4]={0, 0, 0, 0};
+//default box for 3d: evrything minus P.Title /P.subtitle place
+    PLFLT position[4]={0,0,1,1};
+    // Get !P.position default values
+    static unsigned positionTag=SysVar::P()->Desc()->TagIndex("POSITION");
+    for ( SizeT i=0; i<4; ++i ) positionP[i]=(PLFLT)(*static_cast<DFloatGDL*>(SysVar::P()->GetTag(positionTag, 0)))[i];
+    //check presence of DATA,DEVICE and NORMAL options
+    if ( e->KeywordSet( "DATA")) coordinateSystem=DATA;
+    if ( e->KeywordSet( "DEVICE")) coordinateSystem=DEVICE;
+    if ( e->KeywordSet( "NORMAL")) coordinateSystem=NORMAL;
+    if (coordinateSystem==DATA && !actStream->validWorldBox()) e->Throw("PLOT: Data coordinate system not established.");
+    // read boxPosition if needed
+    int positionIx = e->KeywordIx( "POSITION");
+    DFloatGDL* boxPosition = e->IfDefGetKWAs<DFloatGDL>( positionIx);
+    if (boxPosition == NULL) boxPosition = (DFloatGDL*) 0xF;
+    if ( boxPosition!=(DFloatGDL*)0xF)
+    {
+      for ( SizeT i=0; i<4&&i<boxPosition->N_Elements(); ++i ) position[i]=(*boxPosition)[i];
+    }
+    // modify positionP and/or boxPosition to NORMAL if DEVICE is present
+    if (coordinateSystem==DEVICE)
+    {
+      PLFLT normx;
+      PLFLT normy;
+      actStream->DeviceToNormedDevice(positionP[0], positionP[1], normx, normy);
+      positionP[0]=normx;
+      positionP[1]=normy;
+      actStream->DeviceToNormedDevice(positionP[2], positionP[3], normx, normy);
+      positionP[2]=normx;
+      positionP[3]=normy;
+      if ( boxPosition!=(DFloatGDL*)0xF)
+      {
+        actStream->DeviceToNormedDevice(position[0], position[1], normx, normy);
+        position[0]=normx;
+        position[1]=normy;
+        actStream->DeviceToNormedDevice(position[2], position[3], normx, normy);
+        position[2]=normx;
+        position[3]=normy;
+      }
+    }
+
+    // New plot without POSITION=[] as argument
+    if ( boxPosition==(DFloatGDL*)0xF )
+    {
+      kwP=false;
+      // If !P.position not set use default values. coordinatesSystem not used even if present!
+      if ( positionP[0]==0&&positionP[1]==0&&
+           positionP[2]==0&&positionP[3]==0 )
+      {
+        // Set to (smart?) default values
+        position[0]=0;
+        position[1]=0+2*(yMB/yMarginB); //subtitle
+        position[2]=1.0;
+        position[3]=1.0-2*(yMT/yMarginT); //title
+        actStream->vpor(position[0], position[2], position[1], position[3]);
+      }
+      else
+      {
+        // Use !P.position values.
+        actStream->vpor(positionP[0], positionP[2], positionP[1], positionP[3]);
+     }
+    }
+    else // Position keyword set
+    {
+      kwP=true;
+      actStream->vpor(position[0], position[2], position[1], position[3]);
+    }
+    //adjust 'world' values to give room to axis labels. Could be better if we take
+    //into account projection angles
+    // fix word values without labels:
+    actStream->wind(xmin, xmax, ymin, ymax);
+    //compute world Charsize
+    PLFLT xb, xe, yb, ye;
+    xb=xmin-xMarginL*actStream->wCharLength();
+    xe=xmax+xMarginR*actStream->wCharLength();
+    yb=ymin-yMarginB*actStream->wCharHeight();
+    ye=ymax-yMarginT*actStream->wCharHeight();
+    actStream->wind(xb, xe, yb, ye);
+
+    //Clipping is false in 3D... 
+
+    //set P.CLIP (done by PLOT, CONTOUR, SHADE_SURF, and SURFACE)
+    Guard<BaseGDL> clipbox_guard;
+    DLongGDL* clipBox= new DLongGDL(4, BaseGDL::ZERO); clipbox_guard.Reset(clipBox);
+    PLFLT x,y;
+    actStream->gvpd(xmin, xmax, ymin, ymax);
+
+    actStream->NormedDeviceToDevice(xmin, ymin, x,y);
+    (*clipBox)[0]=x;
+    (*clipBox)[1]=y;
+    actStream->NormedDeviceToDevice(xmax, ymax,x,y);
+    (*clipBox)[2]=x;
+    (*clipBox)[3]=y;
+    gdlStoreCLIP(clipBox);
+    return true;
+  }
+
 
+  //TODO: put margin discovery in gdlSetViewPortAndWorldCoordinates (simplify call list)
+  //also, solve the proble of passing back xStart etc if they are changed by unwantedaxisvalue())
+  
+  bool gdlSetViewPortAndWorldCoordinates(EnvT* e,
+                                         GDLGStream* actStream,
+                                         DFloatGDL* boxPosition,
+                                         bool xLog, bool yLog,
+                                         DFloat xMarginL,
+                                         DFloat xMarginR,
+                                         DFloat yMarginB,
+                                         DFloat yMarginT,
+                                         DDouble xStart,
+                                         DDouble xEnd,
+                                         DDouble yStart,
+                                         DDouble yEnd,
+                                         DLong iso)
+  {
 
     PLFLT xMR;
     PLFLT xML;
     PLFLT yMB;
     PLFLT yMT;
-
-    CheckMargin( e, actStream,
-		 xMarginL,
-		 xMarginR,
-		 yMarginB,
-		 yMarginT,
-		 xMR, xML, yMB, yMT);
+    enum{ DATA=0,
+          NORMAL,
+          DEVICE
+        } coordinateSystem=DATA;
+
+    CheckMargin(e, actStream,
+                xMarginL,
+                xMarginR,
+                yMarginB,
+                yMarginT,
+                xMR, xML, yMB, yMT);
 
     // viewport - POSITION overrides
     static bool kwP=FALSE;
     static bool do_iso=FALSE;
     static PLFLT aspect=0.0;
-    static PLFLT positionP[ 4]={0,0,0,0};
-    static PLFLT position[ 4];
-    DStructGDL* pStruct = SysVar::P();
 
+    static PLFLT positionP[4]={0, 0, 0, 0};
+    static PLFLT position[4]={0,0,1,1};
+    DStructGDL* pStruct=SysVar::P();
     // Get !P.position values
-    if(pStruct != NULL) {
-      static unsigned positionTag = pStruct->Desc()->TagIndex( "POSITION");
-      for( SizeT i=0; i<4; ++i)
-	positionP[i] = (PLFLT)
-	  (*static_cast<DFloatGDL*>(pStruct->GetTag( positionTag, 0)))[i];
+    if ( pStruct!=NULL )
+    {
+      static unsigned positionTag=pStruct->Desc()->TagIndex("POSITION");
+      for ( SizeT i=0; i<4; ++i ) positionP[i]=(PLFLT)(*static_cast<DFloatGDL*>(pStruct->GetTag(positionTag, 0)))[i];
     }
-
-    // If pos == NULL (oplot, /OVERPLOT etc. Reuse previous values)
-    if (pos == NULL)
+    //check presence of DATA,DEVICE and NORMAL options
+    if ( e->KeywordSet( "DATA")) coordinateSystem=DATA;
+    if ( e->KeywordSet( "DEVICE")) coordinateSystem=DEVICE;
+    if ( e->KeywordSet( "NORMAL")) coordinateSystem=NORMAL;
+    if (coordinateSystem==DATA && !actStream->validWorldBox()) e->Throw("PLOT: Data coordinate system not established.");
+    // read boxPosition if needed
+    if ( boxPosition!=NULL && boxPosition!=(DFloatGDL*)0xF )
+    {
+      for ( SizeT i=0; i<4&&i<boxPosition->N_Elements(); ++i ) position[i]=(*boxPosition)[i];
+    }
+    // modify positionP and/or boxPosition to NORMAL if DEVICE is present
+    if (coordinateSystem==DEVICE)
+    {
+      PLFLT normx;
+      PLFLT normy;
+      actStream->DeviceToNormedDevice(positionP[0], positionP[1], normx, normy);
+      positionP[0]=normx;
+      positionP[1]=normy;
+      actStream->DeviceToNormedDevice(positionP[2], positionP[3], normx, normy);
+      positionP[2]=normx;
+      positionP[3]=normy;
+      if ( boxPosition!=NULL && boxPosition!=(DFloatGDL*)0xF )
+      {
+        actStream->DeviceToNormedDevice(position[0], position[1], normx, normy);
+        position[0]=normx;
+        position[1]=normy;
+        actStream->DeviceToNormedDevice(position[2], position[3], normx, normy);
+        position[2]=normx;
+        position[3]=normy;
+      }
+    }
+    // Adjust Start and End for Log (convert to log)
+    if ( boxPosition!=NULL ) //new box
+    {
+      if ( xLog )
+      {
+        gdlHandleUnwantedAxisValue(xStart, xEnd, xLog);
+        xStart=log10(xStart);
+        xEnd=log10(xEnd);
+      }
+      if ( yLog )
+      {
+        gdlHandleUnwantedAxisValue(yStart, yEnd, yLog);
+        yStart=log10(yStart);
+        yEnd=log10(yEnd);
+      }
+    }
+    // If pos == NULL (oplot, /OVERPLOT etc: Reuse previous values)
+    if ( boxPosition==NULL )
     {
       // If position keyword previously set
-      if (kwP)
+      if ( kwP )
       {
-// Creates a viewport with the specified normalized subpage coordinates.
-        if (do_iso) setIsoPort(actStream,position[0], position[2], position[1], position[3], aspect);
+        // Creates a viewport with the specified normalized subpage coordinates.
+        if ( do_iso ) setIsoPort(actStream, position[0], position[2], position[1], position[3], aspect);
         else actStream->vpor(position[0], position[2], position[1], position[3]);
       }
       else
       {
         // If !P.position not set
-        if (positionP[0] == 0 && positionP[1] == 0 &&
-            positionP[2] == 0 && positionP[3] == 0)
+        if ( positionP[0]==0&&positionP[1]==0&&
+             positionP[2]==0&&positionP[3]==0 )
         {
-          if (do_iso) setIsoPort(actStream,position[0], position[2], position[1], position[3], aspect);
+          if ( do_iso ) setIsoPort(actStream, position[0], position[2], position[1], position[3], aspect);
           else actStream->vpor(position[0], position[2], position[1], position[3]);
-      }
+        }
         else
         {
           // !P.position set
-          if (do_iso) setIsoPort(actStream,positionP[0], positionP[2], positionP[1], positionP[3], aspect);
+          if ( do_iso ) setIsoPort(actStream, positionP[0], positionP[2], positionP[1], positionP[3], aspect);
           else actStream->vpor(positionP[0], positionP[2], positionP[1], positionP[3]);
         }
       }
     }
     else //New Plot
     {
-      if (iso == 1) // Check ISOTROPIC first
+      if ( iso==1 ) // Check ISOTROPIC first
       {
-        do_iso = TRUE;
-        if ((xLog) && (yLog))
-        {
-          aspect = abs(log10(yEnd/yStart) / log10(xEnd/xStart));
-        } else if (xLog)
-        {
-          aspect = abs((yEnd-yStart) / log10(xEnd/xStart));
-        } else if (yLog)
-        {
-          aspect = abs( log10(yEnd/yStart) / (xEnd-xStart));
-        } else
-        {
-           aspect = abs((yEnd-yStart)/(xEnd-xStart));
-        }
+        do_iso=TRUE;
+        aspect=abs((yEnd-yStart)/(xEnd-xStart)); //log-log or lin-log
       }
       else
       {
-        do_iso = FALSE;
-        aspect = 0.0; // vpas with aspect=0.0 equals vpor.
+        do_iso=FALSE;
+        aspect=0.0; // vpas with aspect=0.0 equals vpor.
       }
 
       // New plot without POSITION=[] as argument
-      if (pos == (DFloatGDL*) 0xF)
+      if ( boxPosition==(DFloatGDL*)0xF )
       {
-        kwP = false;
-        //compute isotropic ratio & save values
-
-        // If !P.position not set use default values
-        if (positionP[0] == 0 && positionP[1] == 0 &&
-            positionP[2] == 0 && positionP[3] == 0)
+        kwP=false;
+        // If !P.position not set use default values. coordinatesSystem not used even if present!
+        if ( positionP[0]==0&&positionP[1]==0&&
+             positionP[2]==0&&positionP[3]==0 )
         {
 
           // Set to default values
-          position[0] = xML;
-          position[1] = yMB;
-          position[2] = 1.0 - xMR;
-          position[3] = 1.0 - yMT;
-          if (do_iso) setIsoPort(actStream,position[0], position[2], position[1], position[3], aspect);
+          position[0]=xML;
+          position[1]=yMB;
+          position[2]=1.0-xMR;
+          position[3]=1.0-yMT;
+          if ( do_iso ) setIsoPort(actStream, position[0], position[2], position[1], position[3], aspect);
           else actStream->vpor(position[0], position[2], position[1], position[3]);
-         }
+        }
         else
         {
-          // Use !P.position values
-          if (do_iso) setIsoPort(actStream,positionP[0], positionP[2], positionP[1], positionP[3], aspect);
+          // Use !P.position values.
+          if ( do_iso ) setIsoPort(actStream, positionP[0], positionP[2], positionP[1], positionP[3], aspect);
           else actStream->vpor(positionP[0], positionP[2], positionP[1], positionP[3]);
         }
       }
-      else       // Position keyword set
+      else // Position keyword set
       {
-        kwP = true;
-        for (SizeT i = 0; i < 4 && i < pos->N_Elements(); ++i) position[ i] = (*pos)[ i];
-        if (do_iso) setIsoPort(actStream,position[0], position[2], position[1], position[3], aspect);
+        kwP=true;
+        if ( do_iso ) setIsoPort(actStream, position[0], position[2], position[1], position[3], aspect);
         else actStream->vpor(position[0], position[2], position[1], position[3]);
       }
     }
 
-    // CLIPPING
-    if( clippingD != NULL)
-	Clipping( clippingD, xStart, xEnd, yStart, yEnd);
-
     // for OPLOT start and end values are already log
     // SA: changing only local variables!
-    if( pos != NULL)
-      {
-	if( xLog) //normally xStart at this point should never be <=0!
-	  {
-	    if( xStart <= 0.0) xStart = -12; else xStart = log10( xStart);
-	    if( xEnd   <= 0.0) return false; else xEnd = log10( xEnd);
-	  }
-	if( yLog) //normally yStart at this point should never be <=0!
-	  {
-	    if( yStart <= 0.0) yStart = -12; else yStart = log10( yStart);
-	    if( yEnd <= 0.0) return false; else yEnd = log10( yEnd);
-	  }
-      }
-//    cout << "VP wind: "<<xStart<<" "<<xEnd<<" "<<yStart<<" "<<yEnd<<endl;
-     //   printf("data lim (setv): %f %f %f %f\n", xStart, xEnd, yStart, yEnd);
-    // set world coordinates
-    actStream->wind( xStart, xEnd, yStart, yEnd);
-//       cout << "xStart " << xStart << "  xEnd "<<xEnd<<endl;
-//        cout << "yStart " << yStart << "  yEnd "<<yEnd<<endl;
-
-   return true;
-  }
 
-  void UpdateSWPlotStructs(GDLGStream* actStream, DDouble xStart, DDouble xEnd, DDouble yStart, DDouble yEnd, bool xLog, bool yLog)
-  {
-    // Get viewpoint parameters and store in WINDOW & S
-    PLFLT p_xmin, p_xmax, p_ymin, p_ymax;
-    actStream->gvpd (p_xmin, p_xmax, p_ymin, p_ymax);
-
-    DStructGDL* Struct = NULL;
-    if (xLog) xStart=log10(xStart);
-    if (xLog) xEnd=log10(xEnd);
-    if (yLog) yStart=log10(yStart);
-    if (yLog) yEnd=log10(yEnd);
-
-    Struct = SysVar::X();
-    static unsigned windowTag = Struct->Desc()->TagIndex( "WINDOW");
-    static unsigned sTag = Struct->Desc()->TagIndex( "S");
-    if (Struct != NULL)
+    //cout << "VP wind: "<<xStart<<" "<<xEnd<<" "<<yStart<<" "<<yEnd<<endl;
+    //printf("data lim (setv): %f %f %f %f\n", xStart, xEnd, yStart, yEnd);
+    // set world coordinates
+    //protection against silly coordinates
+    if (xStart==xEnd)
     {
-      (*static_cast<DFloatGDL*>( Struct->GetTag( windowTag, 0)))[0] = p_xmin;
-      (*static_cast<DFloatGDL*>( Struct->GetTag( windowTag, 0)))[1] = p_xmax;
-
-      (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[0] =
-        (p_xmin*xEnd - p_xmax*xStart) / (xEnd - xStart);
-      (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[1] =
-        (p_xmax - p_xmin) / (xEnd - xStart);
+      Message(e->GetProName()+"Coordinate system in error, please report to authors.");
+      xStart=0.0;
+      xEnd=1.0;
     }
-
-    Struct = SysVar::Y();
-    if(Struct != NULL)
+    if (yStart==yEnd)
     {
-      (*static_cast<DFloatGDL*>( Struct->GetTag( windowTag, 0)))[0] = p_ymin;
-      (*static_cast<DFloatGDL*>( Struct->GetTag( windowTag, 0)))[1] = p_ymax;
-
-      (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[0] =
-        (p_ymin*yEnd - p_ymax*yStart) / (yEnd - yStart);
-      (*static_cast<DDoubleGDL*>( Struct->GetTag( sTag, 0)))[1] =
-        (p_ymax - p_ymin) / (yEnd - yStart);
-    }
+      Message(e->GetProName()+"Coordinate system in error, please report to authors.");
+      yStart=0.0;
+      yEnd=1.0;
+    }
+    actStream->wind(xStart, xEnd, yStart, yEnd);
+    //       cout << "xStart " << xStart << "  xEnd "<<xEnd<<endl;
+    //        cout << "yStart " << yStart << "  yEnd "<<yEnd<<endl;
+    
+    // set ![XYZ].CRANGE (Z is not defined but must be [0,1])
+    gdlStoreAxisCRANGE("X", xStart, xEnd, FALSE); //already in log here if relevant!
+    gdlStoreAxisCRANGE("Y", yStart, yEnd, FALSE);
+
+    //set ![XY].type
+    gdlStoreAxisType("X",xLog); 
+    gdlStoreAxisType("Y",yLog);
+
+    //set ![XY].WINDOW and ![XY].S
+    gdlStoreAxisSandWINDOW(actStream, "X", xStart, xEnd, FALSE);//already in log here if relevant!
+    gdlStoreAxisSandWINDOW(actStream, "Y", yStart, yEnd, FALSE);
+    //set P.CLIP (done by PLOT, CONTOUR, SHADE_SURF, and SURFACE)
+    Guard<BaseGDL> clipbox_guard;
+    DLongGDL* clipBox= new DLongGDL(4, BaseGDL::ZERO); clipbox_guard.Reset(clipBox);
+    PLFLT xmin, xmax, ymin, ymax, x,y;
+    actStream->gvpd(xmin, xmax, ymin, ymax);
+
+    actStream->NormedDeviceToDevice(xmin, ymin, x,y);
+    (*clipBox)[0]=x;
+    (*clipBox)[1]=y;
+    actStream->NormedDeviceToDevice(xmax, ymax,x,y);
+    (*clipBox)[2]=x;
+    (*clipBox)[3]=y;
+    gdlStoreCLIP(clipBox);
+    return true;
   }
 
-  void GetSFromPlotStructs(DDouble **sx, DDouble **sy)
-  {
-    static DStructGDL* xStruct = SysVar::X();
-    static DStructGDL* yStruct = SysVar::Y();
-    unsigned sxTag = xStruct->Desc()->TagIndex( "S");
-    unsigned syTag = yStruct->Desc()->TagIndex( "S");
-    *sx = &(*static_cast<DDoubleGDL*>( xStruct->GetTag( sxTag, 0)))[0];
-    *sy = &(*static_cast<DDoubleGDL*>( yStruct->GetTag( syTag, 0)))[0];
+
+  void GetSFromPlotStructs(DDouble **sx, DDouble **sy, DDouble **sz)
+  {
+    static DStructGDL* xStruct=SysVar::X();
+    static DStructGDL* yStruct=SysVar::Y();
+    static DStructGDL* zStruct=SysVar::Z();
+    unsigned sxTag=xStruct->Desc()->TagIndex("S");
+    unsigned syTag=yStruct->Desc()->TagIndex("S");
+    unsigned szTag=zStruct->Desc()->TagIndex("S");
+    if (sx != NULL) *sx= &(*static_cast<DDoubleGDL*>(xStruct->GetTag(sxTag, 0)))[0];
+    if (sy != NULL) *sy= &(*static_cast<DDoubleGDL*>(yStruct->GetTag(syTag, 0)))[0];
+    if (sz != NULL) *sz= &(*static_cast<DDoubleGDL*>(zStruct->GetTag(szTag, 0)))[0];
   }
 
   void GetWFromPlotStructs(DFloat **wx, DFloat **wy)
   {
-    static DStructGDL* xStruct = SysVar::X();
-    static DStructGDL* yStruct = SysVar::Y();
-    unsigned xwindowTag = xStruct->Desc()->TagIndex( "WINDOW");
-    unsigned ywindowTag = yStruct->Desc()->TagIndex( "WINDOW");
-    *wx = &(*static_cast<DFloatGDL*>( xStruct->GetTag( xwindowTag, 0)))[0];
-    *wy = &(*static_cast<DFloatGDL*>( yStruct->GetTag( ywindowTag, 0)))[0];
+    static DStructGDL* xStruct=SysVar::X();
+    static DStructGDL* yStruct=SysVar::Y();
+    unsigned xwindowTag=xStruct->Desc()->TagIndex("WINDOW");
+    unsigned ywindowTag=yStruct->Desc()->TagIndex("WINDOW");
+    *wx= &(*static_cast<DFloatGDL*>(xStruct->GetTag(xwindowTag, 0)))[0];
+    *wy= &(*static_cast<DFloatGDL*>(yStruct->GetTag(ywindowTag, 0)))[0];
   }
 
   void GetUsym(DLong **n, DInt **do_fill, DFloat **x, DFloat **y)
   {
-    static DStructGDL* usymStruct = SysVar::USYM();
-    unsigned nTag = usymStruct->Desc()->TagIndex( "DIM");
-    unsigned fillTag = usymStruct->Desc()->TagIndex( "FILL");
-    unsigned xTag = usymStruct->Desc()->TagIndex( "X");
-    unsigned yTag = usymStruct->Desc()->TagIndex( "Y");
-
-    *n = &(*static_cast<DLongGDL*>( usymStruct->GetTag( nTag, 0)))[0];
-    *do_fill = &(*static_cast<DIntGDL*>( usymStruct->GetTag( fillTag, 0)))[0];
-    *x = &(*static_cast<DFloatGDL*>( usymStruct->GetTag( xTag, 0)))[0];
-    *y = &(*static_cast<DFloatGDL*>( usymStruct->GetTag( yTag, 0)))[0];
+    static DStructGDL* usymStruct=SysVar::USYM();
+    unsigned nTag=usymStruct->Desc()->TagIndex("DIM");
+    unsigned fillTag=usymStruct->Desc()->TagIndex("FILL");
+    unsigned xTag=usymStruct->Desc()->TagIndex("X");
+    unsigned yTag=usymStruct->Desc()->TagIndex("Y");
+
+    *n= &(*static_cast<DLongGDL*>(usymStruct->GetTag(nTag, 0)))[0];
+    *do_fill= &(*static_cast<DIntGDL*>(usymStruct->GetTag(fillTag, 0)))[0];
+    *x= &(*static_cast<DFloatGDL*>(usymStruct->GetTag(xTag, 0)))[0];
+    *y= &(*static_cast<DFloatGDL*>(usymStruct->GetTag(yTag, 0)))[0];
   }
 
   void SetUsym(DLong n, DInt do_fill, DFloat *x, DFloat *y)
   {
-    static DStructGDL* usymStruct = SysVar::USYM();
-    unsigned xTag = usymStruct->Desc()->TagIndex( "X");
-    unsigned yTag = usymStruct->Desc()->TagIndex( "Y");
-    unsigned nTag = usymStruct->Desc()->TagIndex( "DIM");
-    unsigned fillTag = usymStruct->Desc()->TagIndex( "FILL");
-
-    (*static_cast<DLongGDL*>( usymStruct->GetTag( nTag, 0)))[0] = n;
-    (*static_cast<DIntGDL*>( usymStruct->GetTag( fillTag, 0)))[0] = do_fill;
-
-     for (int i=0; i<n; i++)
-     {
-        (*static_cast<DFloatGDL*>( usymStruct->GetTag( xTag, 0)))[i] = x[i];
-        (*static_cast<DFloatGDL*>( usymStruct->GetTag( yTag, 0)))[i] = y[i];
-     }
-   }
+    static DStructGDL* usymStruct=SysVar::USYM();
+    unsigned xTag=usymStruct->Desc()->TagIndex("X");
+    unsigned yTag=usymStruct->Desc()->TagIndex("Y");
+    unsigned nTag=usymStruct->Desc()->TagIndex("DIM");
+    unsigned fillTag=usymStruct->Desc()->TagIndex("FILL");
+
+    (*static_cast<DLongGDL*>(usymStruct->GetTag(nTag, 0)))[0]=n;
+    (*static_cast<DIntGDL*>(usymStruct->GetTag(fillTag, 0)))[0]=do_fill;
+
+    for ( int i=0; i<n; i++ )
+    {
+      (*static_cast<DFloatGDL*>(usymStruct->GetTag(xTag, 0)))[i]=x[i];
+      (*static_cast<DFloatGDL*>(usymStruct->GetTag(yTag, 0)))[i]=y[i];
+    }
+  }
 
   void DataCoordLimits(DDouble *sx, DDouble *sy, DFloat *wx, DFloat *wy,
-    DDouble *xStart, DDouble *xEnd, DDouble *yStart, DDouble *yEnd, bool clip_by_default)
+                       DDouble *xStart, DDouble *xEnd, DDouble *yStart, DDouble *yEnd, bool clip_by_default)
   {
-    *xStart = (wx[0] - sx[0]) / sx[1];
-    *xEnd   = (wx[1] - sx[0]) / sx[1];
-    *yStart = (wy[0] - sy[0]) / sy[1];
-    *yEnd   = (wy[1] - sy[0]) / sy[1];
+    *xStart=(wx[0]-sx[0])/sx[1];
+    *xEnd=(wx[1]-sx[0])/sx[1];
+    *yStart=(wy[0]-sy[0])/sy[1];
+    *yEnd=(wy[1]-sy[0])/sy[1];
     //   cout << *xStart <<" "<< *xEnd << " "<< *yStart <<" "<< *yEnd << ""<< endl;
 
     // patch from Joanna (tracker item no. 3029409, see test_clip.pro)
-    if (!clip_by_default) {
+    if ( !clip_by_default )
+    {
       //      cout << "joanna" << endl;
-      DFloat wxlen = wx[1] - wx[0];
-      DFloat wylen = wy[1] - wy[0];
-      DFloat xlen = *xEnd - *xStart;
-      DFloat ylen = *yEnd - *yStart;
-      *xStart = *xStart - xlen/wxlen * wx[0];
-      *xEnd = *xEnd + xlen/wxlen * (1 - wx[1]);
-      *yStart = *yStart - ylen/wylen * wy[0];
-      *yEnd = *yEnd + ylen/wylen * (1 - wy[1]);
+      DFloat wxlen=wx[1]-wx[0];
+      DFloat wylen=wy[1]-wy[0];
+      DFloat xlen= *xEnd- *xStart;
+      DFloat ylen= *yEnd- *yStart;
+      *xStart= *xStart-xlen/wxlen*wx[0];
+      *xEnd= *xEnd+xlen/wxlen*(1-wx[1]);
+      *yStart= *yStart-ylen/wylen*wy[0];
+      *yEnd= *yEnd+ylen/wylen*(1-wy[1]);
     }
     //    cout << *xStart <<" "<< *xEnd << " "<< *yStart <<" "<< *yEnd << ""<< endl;
   }
 
-
-  void ac_histo(GDLGStream *a, int i_buff, PLFLT *x_buff, PLFLT *y_buff, bool xLog )
+  void ac_histo(GDLGStream *a, int i_buff, PLFLT *x_buff, PLFLT *y_buff, bool xLog)
   {
-    PLFLT x,x1,y,y1,val;
-    for ( int jj=1; jj<i_buff; ++jj)
+    PLFLT x, x1, y, y1, val;
+    for ( int jj=1; jj<i_buff; ++jj )
     {
       x1=x_buff[jj-1];
       x=x_buff[jj];
       y1=y_buff[jj-1];
       y=y_buff[jj];
       // cf patch 3567803
-      if (xLog) {
-	//  val=log10((pow(10.0,x1)+pow(10.0,x))/2.0);
-	val=x1+log10(0.5+0.5*(pow(10.0,x-x1)));
-      }
-      else {
-	val=(x1+x)/2.0;
-      }
-      a->join(x1,y1,val,y1);
-      a->join(val,y1,val,y);
-      a->join(val,y,x,y);
+      if ( xLog )
+      {
+        //  val=log10((pow(10.0,x1)+pow(10.0,x))/2.0);
+        val=x1+log10(0.5+0.5*(pow(10.0, x-x1)));
+      }
+      else
+      {
+        val=(x1+x)/2.0;
+      }
+      a->join(x1, y1, val, y1);
+      a->join(val, y1, val, y);
+      a->join(val, y, x, y);
     }
   }
+  bool startClipping(EnvT *e, GDLGStream *a, bool UsePClip)
+  {
+    if (GDL_DEBUG_PLSTREAM)  fprintf(stderr,"startClipping\n");
+    //function to be called when clipping must be actived, i.e., if the combination of CLIP= and NOCLIP= necessitate it
+    //the function retrievs the pertinent information in keywords
+    enum
+    {
+      DATA=0,
+      NORMAL,
+      DEVICE
+    } coordinateSystem=DATA;
+    bool xinverted=FALSE;
+    bool yinverted=FALSE; //for inverted DATA coordinates
+    if ( e->KeywordSet("DATA") ) coordinateSystem=DATA;
+    if ( e->KeywordSet("DEVICE") ) coordinateSystem=DEVICE;
+    if ( e->KeywordSet("NORMAL") ) coordinateSystem=NORMAL;
+    //special treatment for PLOTS, XYOUTS...
 
-  void getNormalizedCoordinatesFromPLPLOT(GDLGStream *a, DDouble wx, DDouble wy, DDouble *nx, DDouble *ny)
-  {
-    // from current values derive the relative coordinates in the sense of plplot
-    DDouble s1,s2;
-    PLFLT nxmin,nxmax,nymin,nymax,wxmin,wxmax,wymin,wymax;
-    a->gvpd(nxmin,nxmax,nymin,nymax);//norm of current box
-    a->gvpw(wxmin,wxmax,wymin,wymax);
-//   fprintf(stderr,"World: x=[%lf,%lf] y=[%lf,%lf] Norm: x=[%lf,%lf] y=[%lf,%lf]\n",wxmin,wxmax,wymin,wymax,nxmin,nxmax,nymin,nymax);
-    s1=(nxmax-nxmin)/(wxmax-wxmin);
-    s2=nxmin;
-    *nx=s1*(wx-wxmin)+s2;
-    s1=(nymax-nymin)/(wymax-wymin);
-    s2=nymin;
-    *ny=s1*(wy-wymin)+s2;
-  }
-  void getWorldCoordinatesFromPLPLOT(GDLGStream *a, DDouble nx, DDouble ny, DDouble *wx, DDouble *wy)
-  {
-    // from current values derive the world coordinates in the sense of plplot
-    DDouble s1,s2;
-    PLFLT nxmin,nxmax,nymin,nymax,wxmin,wxmax,wymin,wymax;
-    a->gvpd(nxmin,nxmax,nymin,nymax); //norm of current box
-    a->gvpw(wxmin,wxmax,wymin,wymax); //world of current box
-//   fprintf(stderr,"World: x=[%lf,%lf] y=[%lf,%lf] Norm: x=[%lf,%lf] y=[%lf,%lf]\n",wxmin,wxmax,wymin,wymax,nxmin,nxmax,nymin,nymax);
-    s1=(wxmax-wxmin)/(nxmax-nxmin);
-    s2=wxmin;
-    *wx=s1*(nx-nxmin)+s2;
-    s1=(wymax-wymin)/(nymax-nymin);
-    s2=wymin;
-    *wy=s1*(ny-nymin)+s2;
- }
+    if (UsePClip)
+    {
+      coordinateSystem=DEVICE;
+      if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"USEPCLIP=TRUE!\n");
+    }
+    int clippingix=e->KeywordIx("CLIP");
+    DFloatGDL* clipBox=NULL;
+    clipBox=e->IfDefGetKWAs<DFloatGDL>(clippingix);
+    if (clipBox!=NULL)
+    {
+      if (clipBox->N_Elements()<4) return false;
+      if ( (*clipBox)[0]==(*clipBox)[3] ||(*clipBox)[1]==(*clipBox)[2] ) return false;
+    } else if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"NULL CLIPBOX passed\n");
+    //Save current box
+    a->gvpd(saveBox.nx1, saveBox.nx2, saveBox.ny1, saveBox.ny2); //save norm of current box
+    a->gvpw(saveBox.wx1, saveBox.wx2, saveBox.wy1, saveBox.wy2); //save world of current box
+    //test axis inversion
+    xinverted=(saveBox.wx1>saveBox.wx2);
+    yinverted=(saveBox.wy1>saveBox.wy2);
+    //GET CLIPPING
+    PLFLT dClipBox[4]={0, 0, 0, 0};
+    PLFLT tempbox[4]={0, 0, 0, 0};
+    DDouble un, deux, trois, quatre;
+    bool willNotClip=e->KeywordSet("NOCLIP");
+
+    if (willNotClip)
+    {
+        dClipBox[2]=a->xPageSize();
+        dClipBox[3]=a->yPageSize();
+        if (GDL_DEBUG_PLSTREAM) fprintf(stderr, "using  NOCLIP, i.e. [%f,%f,%f,%f]\n", dClipBox[0], dClipBox[1], dClipBox[2], dClipBox[3]);
+    }
+    else
+    {
+      if ( clipBox==NULL || UsePClip ) //get !P.CLIP
+      {
+        DStructGDL* pStruct=SysVar::P();
+        unsigned clipTag=pStruct->Desc()->TagIndex("CLIP"); //is in device coordinates
+        for ( int i=0; i<4; ++i ) tempbox[i]=dClipBox[i]=(*static_cast<DLongGDL*>(pStruct->GetTag(clipTag, 0)))[i];
+        if (GDL_DEBUG_PLSTREAM) fprintf(stderr, "using !P.CLIP=[%f,%f,%f,%f]\n", dClipBox[0], dClipBox[1], dClipBox[2], dClipBox[3]);
+      }
+      else //get units, convert to world coords for plplot, take care of axis direction
+      {
+        for ( int i=0; i<4&&i<clipBox->N_Elements(); ++i ) tempbox[i]=dClipBox[i]=(*clipBox)[i];
+        if (GDL_DEBUG_PLSTREAM) fprintf(stderr, "using given CLIP=[%f,%f,%f,%f]\n", dClipBox[0], dClipBox[1], dClipBox[2], dClipBox[3]);
+        if ( coordinateSystem==DATA )
+        {
+          int *tx,*ty;
+          int txn[2]={0,2};
+          int txr[2]={2,0};
+          int tyn[2]={1,3};
+          int tyr[2]={3,1};
+          if(tempbox[0]<tempbox[2]) { if (xinverted) tx=txr; else tx=txn;} else { if (xinverted) tx=txn; else tx=txr;}
+          if(tempbox[1]<tempbox[3]) { if (yinverted) ty=tyr; else ty=tyn;} else { if (yinverted) ty=tyn; else ty=tyr;}
+          un=tempbox[tx[0]];
+          deux=tempbox[ty[0]];
+          a->WorldToDevice(un, deux, trois, quatre);
+          dClipBox[0]=trois;
+          dClipBox[1]=quatre;
+          un=tempbox[tx[1]];
+          deux=tempbox[ty[1]];
+          a->WorldToDevice(un, deux, trois, quatre);
+          dClipBox[2]=trois;
+          dClipBox[3]=quatre;
+        }
+        else if ( coordinateSystem==NORMAL )
+        {
+          a->NormToDevice(tempbox[0], tempbox[1], dClipBox[0], dClipBox[1]);
+          a->NormToDevice(tempbox[2], tempbox[3], dClipBox[2], dClipBox[3]);
+        }
+      }
+    }
+    //if new box is in error, return it:
+    if (dClipBox[0]>=dClipBox[2]||dClipBox[1]>=dClipBox[3]) return FALSE;
+    //compute and set corresponding world coords before using whole page:
+    a->DeviceToWorld(dClipBox[0], dClipBox[1],tempbox[0], tempbox[1]);
+    a->DeviceToWorld(dClipBox[2], dClipBox[3],tempbox[2], tempbox[3]);
+
+    a->NoSub();
+    // set full page viewport for the clip box boundaries:
+    PLFLT xmin,xmax,ymin,ymax;
+    a->DeviceToNormedDevice(dClipBox[0], dClipBox[1],xmin, ymin);
+    a->DeviceToNormedDevice(dClipBox[2], dClipBox[3],xmax, ymax);
+    a->vpor(xmin, xmax,ymin, ymax);
+    a->wind(tempbox[0], tempbox[2], tempbox[1], tempbox[3]);
+//    a->box( "bc", 0, 0, "bc", 0.0, 0);
+    return TRUE;
+  }
 
- static DDouble savedPointX=0.0;
- static DDouble savedPointY=0.0;
- void saveLastPoint(GDLGStream *a, DDouble wx, DDouble wy)
-  {
-   DDouble nx;
-   DDouble ny;
-   getNormalizedCoordinatesFromPLPLOT(a, wx, wy, &savedPointX, &savedPointY);
-//   fprintf(stderr,"Saved norm: %lf %lf\n",savedPointX,savedPointY);
+  void stopClipping(GDLGStream *a)
+  {
+    a->vpor(saveBox.nx1, saveBox.nx2, saveBox.ny1, saveBox.ny2); //restore norm of current box
+    a->wind(saveBox.wx1, saveBox.wx2, saveBox.wy1, saveBox.wy2); //give back world of current box
+  }
+
+  void saveLastPoint(GDLGStream *a, DDouble wx, DDouble wy)
+  {
+    a->WorldToNormedDevice(wx, wy, savedPointX, savedPointY);
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"saveLastPoint as %lf %lf\n", savedPointX, savedPointY);
   }
-  void getLastPoint(GDLGStream *a, DDouble* wx, DDouble* wy)
+
+  void getLastPoint(GDLGStream *a, DDouble& wx, DDouble& wy)
   {
-   getWorldCoordinatesFromPLPLOT(a, savedPointX, savedPointY , wx, wy);
-//   fprintf(stderr,"Got norm: %lf %lf giving %lf %lf world\n", savedPointX, savedPointY, *wx, *wy);
+    a->NormedDeviceToWorld(savedPointX, savedPointY, wx, wy);
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"getLastPoint: Got dev: %lf %lf giving %lf %lf world\n", savedPointX, savedPointY, wx, wy);
   }
+
+
   //CORE PLOT FUNCTION -> Draws a line along xVal, yVal
 
   template <typename T> bool draw_polyline(EnvT *e, GDLGStream *a,
-  T * xVal, T* yVal,
-  DDouble minVal, DDouble maxVal, bool doMinMax,
-  bool xLog, bool yLog,
-  DLong psym, bool append){
-    bool line = false;
-    bool valid = true;
-    DLong psym_ = 0;
-
-    if (psym < 0) {
-      line = true;
-      psym_ = -psym;
-    } else if (psym == 0) {
-      line = true;
-      psym_ = psym;
-    } else {
-      psym_ = psym;
+                                           T * xVal, T* yVal,
+                                           DDouble minVal, DDouble maxVal, bool doMinMax,
+                                           bool xLog, bool yLog,
+                                           DLong psym, bool append, DLongGDL *color)
+  {
+    bool docolor=(color != NULL);
+    // Get decomposed value for colors
+    DLong decomposed=Graphics::GetDevice()->GetDecomposed();
+
+    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"draw_polyline()\n");
+    SizeT plotIndex=0;
+    bool line=false;
+    bool valid=true;
+    DLong psym_=0;
+
+    if ( psym<0 )
+    {
+      line=true;
+      psym_= -psym;
+    }
+    else if ( psym==0 )
+    {
+      line=true;
+      psym_=psym;
+    }
+    else
+    {
+      psym_=psym;
     }
 
-    //usersym
+    //usersym and other syms as well!
     DFloat *userSymX, *userSymY;
     DLong *userSymArrayDim;
     DInt *do_fill;
-    if (psym_ == 8) {
+    static DInt nofill=0;
+    DDouble UsymConvX, UsymConvY;
+    GetUserSymSize(e, a, UsymConvX, UsymConvY);
+    if ( psym_==8 )
+    {
       GetUsym(&userSymArrayDim, &do_fill, &userSymX, &userSymY);
-      if (*userSymArrayDim == 0) {
+      if ( *userSymArrayDim==0 )
+      {
         e->Throw("No user symbol defined.");
       }
     }
-    DDouble UsymConvX, UsymConvY;
-    GetUserSymSize(e, a, UsymConvX, UsymConvY);
+    else if ( (psym_>0&&psym_<8))
+    {
+      do_fill=&nofill;
+      userSymArrayDim=&(syml[psym_-1]);
+      switch(psym_)
+      {
+        case 1:
+          userSymX=sym1x;
+          userSymY=sym1y;
+          break;
+        case 2:
+          userSymX=sym2x;
+          userSymY=sym2y;
+          break;
+        case 3:
+          userSymX=sym3x;
+          userSymY=sym3y;
+          break;
+        case 4:
+          userSymX=sym4x;
+          userSymY=sym4y;
+          break;
+        case 5:
+          userSymX=sym5x;
+          userSymY=sym5y;
+          break;
+        case 6:
+          userSymX=sym6x;
+          userSymY=sym6y;
+          break;
+        case 7:
+          userSymX=sym7x;
+          userSymY=sym7y;
+          break;
+     }
+    }
 
-    DLong minEl = (xVal->N_Elements() < yVal->N_Elements()) ?
-    xVal->N_Elements() : yVal->N_Elements();
+    DLong minEl=(xVal->N_Elements()<yVal->N_Elements())?
+    xVal->N_Elements():yVal->N_Elements();
     // if scalar x
-    if (xVal->N_Elements() == 1 && xVal->Rank() == 0)
-      minEl = yVal->N_Elements();
+    if ( xVal->N_Elements()==1&&xVal->Rank()==0 )
+      minEl=yVal->N_Elements();
     // if scalar y
-    if (yVal->N_Elements() == 1 && yVal->Rank() == 0)
-      minEl = xVal->N_Elements();
+    if ( yVal->N_Elements()==1&&yVal->Rank()==0 )
+      minEl=xVal->N_Elements();
 
-    bool mapSet = false;
-  #ifdef USE_LIBPROJ4
+    bool mapSet=false;
+#ifdef USE_LIBPROJ4
     // Map Stuff (xtype = 3)
     LPTYPE idata;
     XYTYPE odata;
@@ -807,183 +1449,213 @@
     get_mapset(mapSet);
 
     DDouble xStart, xEnd;
-    get_axis_crange("X", xStart, xEnd);
+    gdlGetCurrentAxisRange("X", xStart, xEnd);
 
-    if (mapSet) {
-      ref = map_init();
-      if (ref == NULL) {
+    if ( mapSet )
+    {
+      ref=map_init();
+      if ( ref==NULL )
+      {
         e->Throw("Projection initialization failed.");
       }
     }
-  #endif
+#endif
 
     // is one of the 2 "arrays" a singleton or not ?
 
-    PLFLT y, y1, yMapBefore, y_ref;
-    int flag_y_const = 0;
-    y_ref = static_cast<PLFLT>((*yVal)[0]);
-    if (yVal->N_Elements() == 1 && yVal->Rank() == 0) flag_y_const = 1;
+    PLFLT y, yMapBefore, y_ref;
+    int flag_y_const=0;
+    y_ref=static_cast<PLFLT>((*yVal)[0]);
+    if ( yVal->N_Elements()==1&&yVal->Rank()==0 ) flag_y_const=1;
 
     PLFLT x, x1, xMapBefore, x_ref;
-    int flag_x_const = 0;
-    x_ref = static_cast<PLFLT>((*xVal)[0]);
-    if (xVal->N_Elements() == 1 && xVal->Rank() == 0) flag_x_const = 1;
+    int flag_x_const=0;
+    x_ref=static_cast<PLFLT>((*xVal)[0]);
+    if ( xVal->N_Elements()==1&&xVal->Rank()==0 ) flag_x_const=1;
 
     // AC 070601 we use a buffer to use the fast ->line method
     // instead of the slow ->join one.
     // 2 tricks:
     // trick 1/ size of buffer is limited to 1e4 (compromize syze/speed) in order to be able to manage very
-    //    large among of data whitout duplicating all the arrays
+    //    large amount of data whitout duplicating all the arrays
     // trick 2/ when we have a NaN or and Inf, we realize the plot, then reset.
 
-    int debug_ac = 0;
-
-    int n_buff_max = 500000; // idl default seems to be more than 2e6 !!
+    int GDL_POLYLINE_BUFFSIZE=500000; // idl default seems to be more than 2e6 !!
 
-    if (minEl < n_buff_max) n_buff_max = append ? minEl + 1 : minEl;
-    int i_buff = 0;
-    PLFLT *x_buff = new PLFLT[n_buff_max];
-    PLFLT *y_buff = new PLFLT[n_buff_max];
+    if ( minEl<GDL_POLYLINE_BUFFSIZE ) GDL_POLYLINE_BUFFSIZE=append?minEl+1:minEl;
+    int i_buff=0;
+    PLFLT *x_buff=new PLFLT[GDL_POLYLINE_BUFFSIZE];
+    PLFLT *y_buff=new PLFLT[GDL_POLYLINE_BUFFSIZE];
 
     // flag to reset Buffer when a NaN or a Infinity are founded
-    int reset = 0;
+    int reset=0;
 
-    // translation plplot symbols - 8th symbol is superseded by USERSYM.
-    const PLINT codeArr[] = {0, 2, 3, 1, 11, 7, 6, 5, 4};
-    bool isBad = FALSE;
-    for (int i = 0; i < minEl; ++i) {
-      isBad = FALSE;
-      if (append) //start with the old point
+    bool isBad=FALSE;
+
+    for ( SizeT i=0; i<minEl; ++i ) {
+      isBad=FALSE;
+      if ( append ) //start with the old point
       {
-        getLastPoint(a, &x, &y);
+        getLastPoint(a, x, y);
         i--; //to get good counter afterwards
-        append = FALSE; //and stop appending after!
-        if (xLog) x = pow(10, x);
-        if (yLog) y = pow(10, y);
-      } else {
-        if (!flag_x_const) x = static_cast<PLFLT>((*xVal)[i]);
-        else x = x_ref;
-        if (!flag_y_const) y = static_cast<PLFLT>((*yVal)[i]);
-        else y = y_ref;
-      }
-  #ifdef USE_LIBPROJ4
-      if (mapSet && !e->KeywordSet("NORMAL")) {
-        idata.lam = x * DEG_TO_RAD;
-        idata.phi = y * DEG_TO_RAD;
-        if (i > 0) {
-          xMapBefore = odata.x;
-          yMapBefore = odata.y;
-        }
-        odata = PJ_FWD(idata, ref);
-        x = odata.x;
-        y = odata.y;
-      }
-  #endif
-      isBad = (!isfinite(x) || !isfinite(y) || isnan(x) || isnan(y));
-      if (doMinMax) isBad = (isBad || (y < minVal) || (y > maxVal));
-      if (isBad) {
-        reset = 1;
-        if (i_buff > 0) {
-          if (line) {
-            a->line(i_buff, x_buff, y_buff);
-          }
-          if ((psym_ > 0 && psym_ < 8) || psym_ == 9) {
-            a->poin(i_buff, x_buff, y_buff, codeArr[psym_]);
-          }
-          if (psym_ == 8) {
-            PLFLT *xx = new PLFLT[*userSymArrayDim];
-            PLFLT *yy = new PLFLT[*userSymArrayDim];
-            for (int j = 0; j < i_buff; ++j) {
-              if (debug_ac) {
-                cout << "j: " << j << ", X: " << x_buff[j] << ", Y: " << y_buff[j] << endl;
-              };
-              for (int kk = 0; kk < *userSymArrayDim; kk++) {
-                xx[kk] = x_buff[j] + userSymX[kk] * UsymConvX;
-                yy[kk] = y_buff[j] + userSymY[kk] * UsymConvY;
-              }
-              if (*do_fill == 1) {
-                a->fill(*userSymArrayDim, xx, yy);
-              } else {
-                a->line(*userSymArrayDim, xx, yy);
-              }
-            }
-          }
-          if (psym_ == 10) {
-            ac_histo(a, i_buff, x_buff, y_buff, xLog);
-          }
-          i_buff = 0;
-        }
+        append=FALSE; //and stop appending after!
+        if ( xLog ) x=pow(10, x);
+        if ( yLog ) y=pow(10, y);
+      }
+      else
+      {
+        if ( !flag_x_const ) x=static_cast<PLFLT>((*xVal)[i]);
+        else x=x_ref;
+        if ( !flag_y_const ) y=static_cast<PLFLT>((*yVal)[i]);
+        else y=y_ref;
+      }
+#ifdef USE_LIBPROJ4
+      if ( mapSet&& !e->KeywordSet("NORMAL") )
+      {
+        idata.lam=x * DEG_TO_RAD;
+        idata.phi=y * DEG_TO_RAD;
+        if ( i>0 )
+        {
+          xMapBefore=odata.x;
+          yMapBefore=odata.y;
+        }
+        odata=PJ_FWD(idata, ref);
+        x=odata.x;
+        y=odata.y;
+      }
+#endif
+      //note: here y is in minVal maxVal
+      if ( doMinMax ) isBad=((y<minVal)||(y>maxVal));
+      if ( xLog ) x=log10(x);
+      if ( yLog ) y=log10(y);
+      isBad=(isBad||!isfinite(x)|| !isfinite(y)||std::isnan(x)||std::isnan(y));
+      if ( isBad )
+      {
+        reset=1;
+        if ( i_buff>0 )
+        {
+          if ( line )
+          {
+            if (docolor) for (SizeT jj=0; jj< i_buff-1 ; ++jj)
+            {
+              a->Color ( ( *color )[plotIndex%color->N_Elements ( )], decomposed, 2);
+              a->line(2, &(x_buff[jj]), &(y_buff[jj]));
+              plotIndex++;
+            }
+            else a->line(i_buff, x_buff, y_buff);
+          }
+          if (psym_>0&&psym_<9)
+          {
+            PLFLT *xx=new PLFLT[*userSymArrayDim];
+            PLFLT *yy=new PLFLT[*userSymArrayDim];
+            for ( int j=0; j<i_buff; ++j )
+            {
+              for ( int kk=0; kk < *userSymArrayDim; kk++ )
+              {
+                xx[kk]=x_buff[j]+userSymX[kk]*UsymConvX;
+                yy[kk]=y_buff[j]+userSymY[kk]*UsymConvY;
+              }
+              if (docolor)
+              {
+                a->Color ( ( *color )[plotIndex%color->N_Elements ( )], decomposed, 2 );
+                plotIndex++;
+              }
+              if ( *do_fill==1 )
+              {
+                a->fill(*userSymArrayDim, xx, yy);
+              }
+              else
+              {
+                a->line(*userSymArrayDim, xx, yy);
+              }
+            }
+          }
+          if ( psym_==10 )
+          {
+            ac_histo(a, i_buff, x_buff, y_buff, xLog);
+          }
+          i_buff=0;
+        }
         continue;
       }
 
-  #ifdef USE_LIBPROJ4
-      if (mapSet && !e->KeywordSet("NORMAL")) {
-        if (i > 0) //;&& (i_buff >0))
+#ifdef USE_LIBPROJ4
+      if ( mapSet&& !e->KeywordSet("NORMAL") ) //IS BROKEN FOR X/YLOG !!!!!!
+      {
+        if ( i>0 ) //;&& (i_buff >0))
         {
-          x1 = xMapBefore;
-          if (!isfinite(xMapBefore) || !isfinite(yMapBefore)) continue;
+          x1=xMapBefore;
+          if ( !isfinite(xMapBefore)|| !isfinite(yMapBefore) ) continue;
 
           // Break "jumps" across maps (kludge!)
-          if (fabs(x - x1) > 0.5 * (xEnd - xStart)) {
-            reset = 1;
-            if ((i_buff > 0) && (line)) {
+          if ( fabs(x-x1)>0.5*(xEnd-xStart) )
+          {
+            reset=1;
+            if ( (i_buff>0)&&(line) )
+            {
               a->line(i_buff, x_buff, y_buff);
               //		  x_buff[0]=x_buff[i_buff-1];
               //y_buff[0]=y_buff[i_buff-1];
-              i_buff = 0;
+              i_buff=0;
             }
             continue;
           }
         }
       }
-  #endif
-      //note: here y is in minVal maxVal
-      if (xLog) if (x <= 0.0) continue;
-        else x = log10(x);
-      if (yLog) if (y <= 0.0) continue;
-        else y = log10(y);
-
-      x_buff[i_buff] = x;
-      y_buff[i_buff] = y;
-      i_buff = i_buff + 1;
+#endif
+      x_buff[i_buff]=x;
+      y_buff[i_buff]=y;
+      i_buff=i_buff+1;
 
       //	cout << "nbuf: " << i << " " << i_buff << " "<< n_buff_max-1 << " " << minEl-1 << endl;
 
-      if ((i_buff == n_buff_max) || ((i == minEl - 1) && !append) || ((i == minEl) && append)) {
-        if (line) {
-          a->line(i_buff, x_buff, y_buff);
-        };
-        if ((psym_ > 0 && psym_ < 8) || psym_ == 9) {
-          a->poin(i_buff, x_buff, y_buff, codeArr[psym_]);
-        }
-        if (psym_ == 8) {
-          PLFLT *xx = new PLFLT[*userSymArrayDim];
-          PLFLT *yy = new PLFLT[*userSymArrayDim];
-          for (int j = 0; j < i_buff; ++j) {
-            if (debug_ac) {
-              cout << "j: " << j << ", X: " << x_buff[j] << ", Y: " << y_buff[j] << endl;
-            };
-            for (int kk = 0; kk < *userSymArrayDim; kk++) {
-              xx[kk] = x_buff[j] + userSymX[kk] * UsymConvX;
-              yy[kk] = y_buff[j] + userSymY[kk] * UsymConvY;
+      if ( (i_buff==GDL_POLYLINE_BUFFSIZE)||((i==minEl-1)&& !append)||((i==minEl)&&append) )
+      {
+        if ( line )
+        {
+          if (docolor) for (SizeT jj=0; jj< i_buff-1 ; ++jj)
+            {
+              a->Color ( ( *color )[plotIndex%color->N_Elements ( )], decomposed, 2);
+              a->line(2, &(x_buff[jj]), &(y_buff[jj]));
+              plotIndex++;
+            }
+            else a->line(i_buff, x_buff, y_buff);
+        }
+        if ( psym_>0&&psym_<9 )
+        {
+          PLFLT *xx=new PLFLT[*userSymArrayDim];
+          PLFLT *yy=new PLFLT[*userSymArrayDim];
+          for ( int j=0; j<i_buff; ++j )
+          {
+            for ( int kk=0; kk < *userSymArrayDim; kk++ )
+            {
+              xx[kk]=x_buff[j]+userSymX[kk]*UsymConvX;
+              yy[kk]=y_buff[j]+userSymY[kk]*UsymConvY;
+            }
+            if (docolor)
+            {
+              a->Color ( ( *color )[plotIndex%color->N_Elements ( )], decomposed, 2 );
+              plotIndex++;
             }
-            if (*do_fill == 1) {
+            if ( *do_fill==1 )
+            {
               a->fill(*userSymArrayDim, xx, yy);
-              //to be tested: provided we define a 'non-gradient' gradient before this should work
-              //                a->gradient(*userSymArrayDim,xx,yy,0.0);
-            } else {
+            }
+            else
+            {
               a->line(*userSymArrayDim, xx, yy);
             }
           }
         }
-        if (psym_ == 10) {
+        if ( psym_==10 )
+        {
           ac_histo(a, i_buff, x_buff, y_buff, xLog);
         }
 
         // we must recopy the last point since the line must continue (tested via small buffer ...)
-        x_buff[0] = x_buff[i_buff - 1];
-        y_buff[0] = y_buff[i_buff - 1];
-        i_buff = 1;
+        x_buff[0]=x_buff[i_buff-1];
+        y_buff[0]=y_buff[i_buff-1];
+        i_buff=1;
       }
     }
 
@@ -994,545 +1666,1526 @@
     return (valid);
   }
   // explicit instantiation for SpDDouble
-  template bool draw_polyline(EnvT*, GDLGStream*, Data_<SpDDouble>*, Data_<SpDDouble>*, DDouble, DDouble, bool, bool, bool, DLong, bool);
+  template bool draw_polyline(EnvT*, GDLGStream*, Data_<SpDDouble>*, Data_<SpDDouble>*, DDouble, DDouble, bool, bool, bool, DLong, bool, DLongGDL*);
 
-  //[XYZ]MARGIN kw decoding
-  void gkw_axis_margin(EnvT *e, string axis,DFloat &start, DFloat &end)
-  {
-    DStructGDL* Struct;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
-
-    if(Struct != NULL)
-      {
-	static unsigned marginTag = Struct->Desc()->TagIndex( "MARGIN");
-	start =
-	  (*static_cast<DFloatGDL*>( Struct->GetTag( marginTag, 0)))[0];
-	end =
-	  (*static_cast<DFloatGDL*>( Struct->GetTag( marginTag, 0)))[1];
-      }
+ 
+  //BACKGROUND COLOR
 
-    string MarginName=axis+"MARGIN";
-    BaseGDL* Margin=e->GetKW(e->KeywordIx(MarginName));
-    if(Margin !=NULL)
-      {
-	if(Margin->N_Elements() > 2)
-	  e->Throw("Keyword array parameter "+MarginName+
-		   " must have from 1 to 2 elements.");
-	auto_ptr<DFloatGDL> guard;
-	DFloatGDL* MarginF = static_cast<DFloatGDL*>
-	  ( Margin->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	guard.reset( MarginF);
-	start = (*MarginF)[0];
-	if( MarginF->N_Elements() > 1)
-	  end = (*MarginF)[1];
-      }
+  void gdlSetGraphicsBackgroundColorFromKw(EnvT *e, GDLGStream *a, bool kw)
+  {
+    static DStructGDL* pStruct=SysVar::P();
+    DLong background=
+    (*static_cast<DLongGDL*>
+     (pStruct->GetTag(pStruct->Desc()->TagIndex("BACKGROUND"), 0)))[0];
+    if ( kw )
+      e->AssureLongScalarKWIfPresent("BACKGROUND", background);
+    a->Background(background);
   }
 
-  //BACKGROUND COLOR
-  void gkw_background(EnvT *e, GDLGStream *a, bool kw)
+  void gdlSetGraphicsPenColorToBackground(GDLGStream *a)
   {
-    static DStructGDL* pStruct = SysVar::P();
-    DLong background =
-      (*static_cast<DLongGDL*>
-       (pStruct->GetTag( pStruct->Desc()->TagIndex("BACKGROUND"), 0)))[0];
-    if(kw)
-      e->AssureLongScalarKWIfPresent( "BACKGROUND", background);
-
-    // Get decomposed value
-    Graphics* actDevice = Graphics::GetDevice();
-    DLong decomposed = actDevice->GetDecomposed();
-    if (decomposed != 0 && decomposed != 1) {decomposed=0;}
-
-    a->Background( background, decomposed);
+    a->plstream::col0( 0);
   }
 
   //COLOR
-  void gkw_color(EnvT *e, GDLGStream *a)
-  {
+#define GDL_PLPLOT_MAX_SIMPLE_COLORS 16
+#define GDL_PLPLOT_INDEX_WHITE 15
+  void gdlSetGraphicsForegroundColorFromKw(EnvT *e, GDLGStream *a, string OtherColorKw)
+  {
+    static unsigned int colorindex=1;
+    static long value[GDL_PLPLOT_MAX_SIMPLE_COLORS];
+    static int maxindex=2;
+    static bool notDone=1;
+
     // Get COLOR from PLOT system variable
-    static DStructGDL* pStruct = SysVar::P();
-    DLong color =
-      (*static_cast<DLongGDL*>
-       (pStruct->GetTag( pStruct->Desc()->TagIndex("COLOR"), 0)))[0];
+    static DStructGDL* pStruct=SysVar::P();
+    DLong color=
+    (*static_cast<DLongGDL*>
+     (pStruct->GetTag(pStruct->Desc()->TagIndex("COLOR"), 0)))[0];
 
     // Get # of colors from DEVICE system variable
-    DVar *var=FindInVarList(sysVarList,"D");
-    DStructGDL* s = static_cast<DStructGDL*>( var->Data());
-    DLong ncolor = (*static_cast<DLongGDL*>
-                    (s->GetTag(s->Desc()->TagIndex("N_COLORS"), 0)))[0];
-
-    if (ncolor > 256 && color == 255) color = ncolor - 1;
-
-    e->AssureLongScalarKWIfPresent( "COLOR", color);
-
-    // Get decomposed value
-    Graphics* actDevice = Graphics::GetDevice();
-    DLong decomposed = actDevice->GetDecomposed();
-    if (decomposed != 0 && decomposed != 1) {decomposed=0;}
-    a->Color( color, decomposed, 2);
+    DVar *var=FindInVarList(sysVarList, "D");
+    DStructGDL* s=static_cast<DStructGDL*>(var->Data());
+    DLong ncolor=(*static_cast<DLongGDL*>
+                  (s->GetTag(s->Desc()->TagIndex("N_COLORS"), 0)))[0];
+
+    //FIXME: serves to update color if palette larger than 256. We can do better!
+    if ( ncolor>256&&color==255 ) color=ncolor-1;
+
+    if (notDone)
+    {
+      for (int i=0; i<GDL_PLPLOT_MAX_SIMPLE_COLORS; i++) value[i]=0;
+      value[1]=ncolor-1;
+      notDone=false;
+      maxindex=2;
+    }
+    DLongGDL *colorVect;
+    int colorIx;
+    //eventually do not get color from standard "COLOR" keyword but from another...
+    if (OtherColorKw == "") colorIx=e->KeywordIx ( "COLOR" ); //color may be vector in GDL!
+    else colorIx=e->KeywordIx (OtherColorKw);
+    if ( e->GetKW ( colorIx )!=NULL )
+    {
+      colorVect=e->GetKWAs<DLongGDL>( colorIx );
+      color=(*colorVect)[0]; //this function only sets color to 1st arg in list!
+    }
+    int i;
+    bool found=false;
+    for (i=0; i<maxindex; i++) if (value[i]==color) {found=true;break;}
+    if (!found)
+    {
+      value[i]=color;
+      maxindex++;
+      maxindex=min(maxindex,GDL_PLPLOT_INDEX_WHITE); //avoid BLACK & WHITE, use last color if more than 16.
+    }
+    colorindex=i;
+    // Get decomposed value for colors
+    DLong decomposed=Graphics::GetDevice()->GetDecomposed();
+    a->Color(color, decomposed, colorindex);
   }
 
   // helper for NOERASE (but also used in XYOUTS)
+
   void handle_pmulti_position(EnvT *e, GDLGStream *a)
   {
-    // !P.MULTI is ignored if POSITION kw or !P.POSITION or !P.REGION is specified
+    // all but the first element of !P.MULTI are ignored if POSITION kw or !P.POSITION or !P.REGION is specified
     // TODO: !P.REGION!
 
-    DFloatGDL* pos = NULL;
+    DFloatGDL* pos=NULL;
 
     // system variable
-    static DStructGDL* pStruct = SysVar::P();
-    pos = static_cast<DFloatGDL*>(pStruct-> GetTag( pStruct->Desc()->TagIndex("POSITION"), 0));
-    if ((*pos)[0] == (*pos)[2]) pos = NULL;
+    static DStructGDL* pStruct=SysVar::P();
+    pos=static_cast<DFloatGDL*>(pStruct-> GetTag(pStruct->Desc()->TagIndex("POSITION"), 0));
+    if ( (*pos)[0]==(*pos)[2] ) pos=NULL; //ignored
 
     // keyword
-    if (pos == NULL)
+    if ( pos==NULL )
     {
-      DSub* pro = e->GetPro();
-      int positionIx = pro->FindKey( "POSITION");
-      if (positionIx != -1) pos = e->IfDefGetKWAs<DFloatGDL>( positionIx);
+      DSub* pro=e->GetPro();
+      int positionIx=pro->FindKey("POSITION");
+      if ( positionIx!= -1 ) pos=e->IfDefGetKWAs<DFloatGDL>(positionIx);
     }
 
-    if (pos != NULL) a->NoSub();
+    if ( pos!=NULL ) a->NoSub();
   }
 
   //NOERASE
-  void gkw_noerase(EnvT *e,GDLGStream *a, bool noe)
+
+  void gdlNextPlotHandlingNoEraseOption(EnvT *e, GDLGStream *a, bool noe)
   {
-    DLong noErase=0;
-    DLongGDL* pMulti = SysVar::GetPMulti();
-    static DStructGDL* pStruct = SysVar::P();
-
-    if(!noe)
-      {
-	noErase = (*static_cast<DLongGDL*>
-		   ( pStruct->
-		     GetTag( pStruct->Desc()->TagIndex("NOERASE"), 0)))[0];
-	if(e->KeywordSet("NOERASE")) {
-	  noErase=1;
-	}
-      }
-    else
+    bool noErase=FALSE;
+    static DStructGDL* pStruct=SysVar::P();
+
+    if ( !noe )
+    {
+      DLong LnoErase=(*static_cast<DLongGDL*>
+                      (pStruct->
+                       GetTag(pStruct->Desc()->TagIndex("NOERASE"), 0)))[0];
+      noErase=(LnoErase==1);
+      if ( e->KeywordSet("NOERASE") )
       {
-	noErase=1;
+        noErase=TRUE;
       }
+    }
+    else
+    {
+      noErase=TRUE;
+    }
 
-    a->NextPlot( !noErase);
+    a->NextPlot(!noErase);
     handle_pmulti_position(e, a);
   }
 
   //PSYM
-  void gkw_psym(EnvT *e, DLong &psym)
+
+  void gdlGetPsym(EnvT *e, DLong &psym)
   {
-    static DStructGDL* pStruct = SysVar::P();
-    psym= (*static_cast<DLongGDL*>
-	   (pStruct->GetTag(pStruct->Desc()->TagIndex("PSYM"), 0)))[0];
+    static DStructGDL* pStruct=SysVar::P();
+    psym=(*static_cast<DLongGDL*>
+          (pStruct->GetTag(pStruct->Desc()->TagIndex("PSYM"), 0)))[0];
 
-    e->AssureLongScalarKWIfPresent( "PSYM", psym);
-    if( psym > 10 || psym < -8 || psym == 9)
+    e->AssureLongScalarKWIfPresent("PSYM", psym);
+    if ( psym>10||psym < -8||psym==9 )
       e->Throw(
-			  "PSYM (plotting symbol) out of range.");
+               "PSYM (plotting symbol) out of range.");
   }
 
-    //SYMSIZE
-  void gkw_symsize(EnvT *e, GDLGStream *a)
+  //SYMSIZE
+
+  void gdlSetSymsize(EnvT *e, GDLGStream *a)
   {
-    static DStructGDL* pStruct = SysVar::P();
-    DFloat symsize = (*static_cast<DFloatGDL*>
-		      (pStruct->GetTag( pStruct->Desc()->TagIndex("SYMSIZE"), 0)))[0];
-    e->AssureFloatScalarKWIfPresent( "SYMSIZE", symsize);
-    if( symsize <= 0.0) symsize = 1.0;
+    static DStructGDL* pStruct=SysVar::P();
+    DFloat symsize=(*static_cast<DFloatGDL*>
+                    (pStruct->GetTag(pStruct->Desc()->TagIndex("SYMSIZE"), 0)))[0];
+    e->AssureFloatScalarKWIfPresent("SYMSIZE", symsize);
+    if ( symsize<=0.0 ) symsize=1.0;
     a->ssym(0.0, symsize);
   }
 
   //CHARSIZE
-  void gkw_charsize(EnvT *e, GDLGStream *a, DFloat &charsize, bool kw)
-  {
-    static DStructGDL* pStruct = SysVar::P();
-    charsize = (*static_cast<DFloatGDL*>
-			(pStruct->GetTag
-			 ( pStruct->Desc()->TagIndex("CHARSIZE"), 0)))[0];
-    if(kw)
-      e->AssureFloatScalarKWIfPresent( "CHARSIZE", charsize);
-
-    if( charsize <= 0.0) charsize = 1.0;
-    a->schr(0.0, charsize);
-  }
-  //OLD CHARSIZE (for xyouts only?)
-  void gkw_charsize_xyouts(EnvT *e, GDLGStream *a, DFloat &charsize)
-  {
-    static DStructGDL* pStruct = SysVar::P();
-    charsize = (*static_cast<DFloatGDL*>
-			(pStruct->GetTag
-			 ( pStruct->Desc()->TagIndex("CHARSIZE"), 0)))[0];
-    //imagine CHARSIZE & SIZE: we prefer CHARSIZE of course
-    if(e->KeywordSet("SIZE")) e->AssureFloatScalarKWIfPresent( "SIZE", charsize);
-    e->AssureFloatScalarKWIfPresent( "CHARSIZE", charsize);
 
-    if( charsize <= 0.0) charsize = 1.0;
-    a->schr(0.0, charsize);
+  void gdlSetPlotCharsize(EnvT *e, GDLGStream *a, bool accept_sizeKw)
+  {
+    PLFLT charsize;
+    DDouble pmultiscale=1.0;
+    // get !P preference
+    static DStructGDL* pStruct=SysVar::P();
+    charsize=(*static_cast<DFloatGDL*>
+              (pStruct->GetTag
+               (pStruct->Desc()->TagIndex("CHARSIZE"), 0)))[0];
+    //overload with command preference. Charsize may be a vector now in some gdl commands, take care of it:
+    if (accept_sizeKw) //XYOUTS specials!
+    {
+      DFloat fcharsize;
+      fcharsize=charsize;
+      e->AssureFloatScalarKWIfPresent("SIZE", fcharsize);   //conversions are boring...
+      charsize=fcharsize;
+    }
+    int charsizeIx=e->KeywordIx ( "CHARSIZE" );
+    if ( e->GetKW ( charsizeIx )!=NULL )
+    {
+      DFloatGDL* charsizeVect=e->GetKWAs<DFloatGDL>( charsizeIx );
+      charsize=(*charsizeVect)[0];
+    }
+    if ( charsize<=0.0 ) charsize=1.0;
+    // adjust if MULTI:
+    DLongGDL* pMulti=SysVar::GetPMulti();
+    if ( (*pMulti)[1]>2||(*pMulti)[2]>2 ) pmultiscale=0.5;
+    a->sizeChar(charsize*pmultiscale);
+  }
+
+  void gdlSetPlotCharthick(EnvT *e, GDLGStream *a)
+  {
+    PLINT charthick=1;
+     // get !P preference
+    static DStructGDL* pStruct=SysVar::P();
+    charthick=(*static_cast<DFloatGDL*>
+              (pStruct->GetTag
+               (pStruct->Desc()->TagIndex("CHARTHICK"), 0)))[0];
+    int charthickIx=e->KeywordIx ( "CHARTHICK" ); //Charthick values may be vector in GDL, not in IDL!
+    if ( e->GetKW ( charthickIx )!=NULL )
+    {
+      DFloatGDL* charthickVect=e->GetKWAs<DFloatGDL>( charthickIx );
+      charthick=(*charthickVect)[0];
+    }
+    a->wid(charthick);
   }
+
+  void gdlSetAxisCharsize(EnvT *e, GDLGStream *a, string axis)
+  {
+
+    DFloat charsize=0.0;
+    DDouble pmultiscale=1.0;
+    gdlGetDesiredAxisCharsize(e, axis, charsize);
+    // adjust if MULTI:
+    DLongGDL* pMulti=SysVar::GetPMulti();
+    if ( (*pMulti)[1]>2||(*pMulti)[2]>2 ) pmultiscale=0.5; //IDL behaviour
+    // scale default value (which depends on number of subpages)
+    // a->schr(0.0, charsize*pmultiscale);
+    a->sizeChar(charsize*pmultiscale);
+   }
+
+
   //THICK
-  void gkw_thick(EnvT *e, GDLGStream *a)
+
+  void gdlSetPenThickness(EnvT *e, GDLGStream *a)
   {
-    static DStructGDL* pStruct = SysVar::P();
-    DFloat thick = (*static_cast<DFloatGDL*>
-		    (pStruct->GetTag( pStruct->Desc()->TagIndex("THICK"), 0)))[0];
-
-    e->AssureFloatScalarKWIfPresent( "THICK", thick);
-    if( thick <= 0.0) thick = 1.0;
-    a->wid( static_cast<PLINT>(floor( thick-0.5)));
+    static DStructGDL* pStruct=SysVar::P();
+    DFloat thick=(*static_cast<DFloatGDL*>
+                  (pStruct->GetTag(pStruct->Desc()->TagIndex("THICK"), 0)))[0];
+
+    e->AssureFloatScalarKWIfPresent("THICK", thick);
+    if ( thick<=0.0 ) thick=1.0;
+    a->wid(static_cast<PLINT>(floor(thick-0.5)));
   }
 
   //LINESTYLE
-  void gkw_linestyle(EnvT *e, GDLGStream *a)
+  void gdlLineStyle(GDLGStream *a, DLong style)
+  {
+      static PLINT mark1[]={75};
+      static PLINT space1[]={1500};
+      static PLINT mark2[]={1500};
+      static PLINT space2[]={1500};
+      static PLINT mark3[]={1500, 100};
+      static PLINT space3[]={1000, 1000};
+      static PLINT mark4[]={1500, 100, 100, 100};
+      static PLINT space4[]={1000, 1000, 1000, 1000};
+      static PLINT mark5[]={3000};
+      static PLINT space5[]={1500};          // see plplot-5.5.3/examples/c++/x09.cc
+      switch(style)
+      {
+        case 0:
+          a->styl(0, mark1, space1);
+          return;
+         case 1:
+          a->styl(1, mark1, space1);
+          return;
+        case 2:
+          a->styl(1, mark2, space2);
+          return;
+        case 3:
+          a->styl(2, mark3, space3);
+          return;
+        case 4:
+          a->styl(4, mark4, space4);
+          return;
+        case 5:
+          a->styl(1, mark5, space5);
+          return;
+        default:
+          a->styl(0, NULL, NULL);
+          return;
+      }
+  }
+
+  void gdlSetLineStyle(EnvT *e, GDLGStream *a)
   {
-    static DStructGDL* pStruct = SysVar::P();
+    static DStructGDL* pStruct=SysVar::P();
     DLong linestyle=
-      (*static_cast<DLongGDL*>
-       (pStruct->GetTag( pStruct->Desc()->TagIndex("LINESTYLE"), 0)))[0];
+    (*static_cast<DLongGDL*>
+     (pStruct->GetTag(pStruct->Desc()->TagIndex("LINESTYLE"), 0)))[0];
 
     // if the LINESTYLE keyword is present, the value will be change
     DLong temp_linestyle=-1111;
-    e->AssureLongScalarKWIfPresent( "LINESTYLE",temp_linestyle);
+    if (e->KeywordSet("LINESTYLE")) e->AssureLongScalarKWIfPresent("LINESTYLE", temp_linestyle);
 
     bool debug=false;
-    if (debug) {
-      cout << "temp_linestyle " <<  temp_linestyle << endl;
-      cout << "     linestyle " <<  linestyle << endl;
-    }
-    if (temp_linestyle != -1111) {linestyle=temp_linestyle;}//+1;
-    if (linestyle < 0 ) {linestyle=0;}
-    if (linestyle > 5 ) {linestyle=5;}
-
-      // see
-      // file:///home/coulais/SoftsExternes/plplot-5.5.3/examples/c++/x09.cc
-      // file:///home/coulais/SoftsExternes/plplot-5.5.3/doc/docbook/src/plstyl.html
-
-    if (linestyle == 0) { // solid (continuous line)
-      static PLINT nbp=0;
-      a->styl(nbp, NULL, NULL);
-    }
-    if (linestyle == 1) { // dots
-      static PLINT nbp=1;
-      static PLINT mark[] = {75};
-      static PLINT space[] = {1500};
-      a->styl(nbp, mark, space);
-    }
-    if (linestyle == 2) { // dashed
-      static PLINT nbp=1;
-      static PLINT mark[] = {1500};
-      static PLINT space[] = {1500};
-      a->styl(nbp, mark, space);
-  }
-    if (linestyle == 3) { // dash dot
-      static PLINT nbp=2;
-      static PLINT mark[] = {1500,100};
-      static PLINT space[] = {1000,1000};
-      a->styl(nbp, mark, space);
-    }
-    if (linestyle == 4) { // dash dot dot
-      static PLINT nbp=4;
-      static PLINT mark[] = {1500,100,100,100};
-      static PLINT space[] = {1000,1000,1000,1000};
-      a->styl(nbp, mark, space);
-    }
-    if (linestyle == 5) { // long dash
-      static PLINT nbp=1;
-      static PLINT mark[] = {3000};
-      static PLINT space[] = {1500};
-      a->styl(nbp, mark, space);
+    if ( debug )
+    {
+      cout<<"temp_linestyle "<<temp_linestyle<<endl;
+      cout<<"     linestyle "<<linestyle<<endl;
+    }
+    if ( temp_linestyle!= -1111 )
+    {
+      linestyle=temp_linestyle;
+    }//+1;
+    if ( linestyle<0 )
+    {
+      linestyle=0;
+    }
+    if ( linestyle>5 )
+    {
+      linestyle=5;
     }
+    gdlLineStyle(a, linestyle);
   }
 
   //TITLE
-  void gkw_title(EnvT* e, GDLGStream *a, PLFLT ad)
+
+  void gdlWriteTitleAndSubtitle(EnvT* e, GDLGStream *a)
   {
-    DLong thick=0;
-    e->AssureLongScalarKWIfPresent("CHARTHICK",thick);
-    a->wid(thick);
-
-    static DStructGDL* pStruct = SysVar::P();
-    static unsigned titleTag = pStruct->Desc()->TagIndex( "TITLE");
-    static unsigned subTitleTag = pStruct->Desc()->TagIndex( "SUBTITLE");
-    DString title =
-      (*static_cast<DStringGDL*>( pStruct->GetTag( titleTag, 0)))[0];
-    DString subTitle =
-      (*static_cast<DStringGDL*>( pStruct->GetTag( subTitleTag, 0)))[0];
-    e->AssureStringScalarKWIfPresent( "TITLE", title);
-    e->AssureStringScalarKWIfPresent( "SUBTITLE", subTitle);
-
-    a->schr( 0.0, 1.25*ad);
-    a->mtex("t",1.25,0.5,0.5,title.c_str());
-    a->schr( 0.0, ad); // charsize is reset here
-    a->mtex("b",5.4,0.5,0.5,subTitle.c_str());
-    a->wid(0);
-  }
+    static unsigned titleTag=SysVar::P()->Desc()->TagIndex("TITLE");
+    static unsigned subTitleTag=SysVar::P()->Desc()->TagIndex("SUBTITLE");
+    DString title=(*static_cast<DStringGDL*>(SysVar::P()->GetTag(titleTag, 0)))[0];
+    DString subTitle=(*static_cast<DStringGDL*>(SysVar::P()->GetTag(subTitleTag, 0)))[0];
+    e->AssureStringScalarKWIfPresent("TITLE", title);
+    e->AssureStringScalarKWIfPresent("SUBTITLE", subTitle);
+    if (title.empty() && subTitle.empty()) return;
 
+    gdlSetPlotCharsize(e, a);
+    if (!title.empty())
+    {
+      e->AssureStringScalarKWIfPresent("TITLE", title);
+      gdlSetPlotCharthick(e, a);
+      a->sizeChar(1.25*a->charScale());
+      a->mtex("t", 1.25, 0.5, 0.5, title.c_str()); //position is in units of current char height. baseline at half-height
+      a->sizeChar(a->charScale()/1.25);
+    }
+    if (!subTitle.empty()) 
+    {
+      e->AssureStringScalarKWIfPresent("SUBTITLE", subTitle);
+      a->mtex("b", 5.4, 0.5, 0.5, subTitle.c_str());
+    }
+ }
+  
   //crange to struct
 
-  void set_axis_crange(string axis, DDouble Start, DDouble End, bool log)
+  void gdlStoreAxisCRANGE(string axis, DDouble Start, DDouble End, bool log)
   {
-    DStructGDL* Struct = NULL;
-    if (axis == "X") Struct = SysVar::X();
-    if (axis == "Y") Struct = SysVar::Y();
-    if (axis == "Z") Struct = SysVar::Z();
-    if (Struct != NULL)
-    {
-      int debug = 0;
-      if (debug) cout << "Set     :" << Start << " " << End << endl;
-
-      static unsigned crangeTag = Struct->Desc()->TagIndex("CRANGE");
-      if (log)
-      {
-        (*static_cast<DDoubleGDL*> (Struct->GetTag(crangeTag, 0)))[0] = log10(Start);
-        (*static_cast<DDoubleGDL*> (Struct->GetTag(crangeTag, 0)))[1] = log10(End);
-        if (debug) cout << "set log" << Start << " " << End << endl;
+    DStructGDL* Struct=NULL;
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+    if ( Struct!=NULL )
+    {
+      int debug=0;
+      if ( debug ) cout<<"Set     :"<<Start<<" "<<End<<endl;
+
+      unsigned crangeTag=Struct->Desc()->TagIndex("CRANGE");
+      if ( log )
+      {
+        (*static_cast<DDoubleGDL*>(Struct->GetTag(crangeTag, 0)))[0]=log10(Start);
+        (*static_cast<DDoubleGDL*>(Struct->GetTag(crangeTag, 0)))[1]=log10(End);
+        if ( debug ) cout<<"set log"<<Start<<" "<<End<<endl;
       }
       else
       {
-        (*static_cast<DDoubleGDL*> (Struct->GetTag(crangeTag, 0)))[0] = Start;
-        (*static_cast<DDoubleGDL*> (Struct->GetTag(crangeTag, 0)))[1] = End;
+        (*static_cast<DDoubleGDL*>(Struct->GetTag(crangeTag, 0)))[0]=Start;
+        (*static_cast<DDoubleGDL*>(Struct->GetTag(crangeTag, 0)))[1]=End;
       }
     }
   }
 
   //CRANGE from struct
-  void get_axis_crange(string axis, DDouble &Start, DDouble &End)
+
+  void gdlGetCurrentAxisRange(string axis, DDouble &Start, DDouble &End)
   {
     DStructGDL* Struct=NULL;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
-    if(axis=="Z") Struct = SysVar::Z();
-    if(Struct!=NULL)
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+    if ( Struct!=NULL )
     {
-	int debug=0;
-	if (debug) cout << "Get     :" << Start << " " << End << endl;
+      int debug=0;
+      if ( debug ) cout<<"Get     :"<<Start<<" "<<End<<endl;
 
-	static unsigned crangeTag = Struct->Desc()->TagIndex( "CRANGE");
-	Start = (*static_cast<DDoubleGDL*>( Struct->GetTag( crangeTag, 0)))[0];
-	End = (*static_cast<DDoubleGDL*>( Struct->GetTag( crangeTag, 0)))[1];
+      static unsigned crangeTag=Struct->Desc()->TagIndex("CRANGE");
+      Start=(*static_cast<DDoubleGDL*>(Struct->GetTag(crangeTag, 0)))[0];
+      End=(*static_cast<DDoubleGDL*>(Struct->GetTag(crangeTag, 0)))[1];
 
-	static unsigned typeTag = Struct->Desc()->TagIndex( "TYPE");
-	if ((*static_cast<DLongGDL*>(Struct->GetTag( typeTag, 0)))[0] == 1)
-	  {
-	    Start=pow(10.,Start);
-	    End=pow(10.,End);
-	    if (debug) cout << "Get log :" << Start << " " << End << endl;
-	  }
+      static unsigned typeTag=Struct->Desc()->TagIndex("TYPE");
+      if ( (*static_cast<DLongGDL*>(Struct->GetTag(typeTag, 0)))[0]==1 )
+      {
+        Start=pow(10., Start);
+        End=pow(10., End);
+        if ( debug ) cout<<"Get log :"<<Start<<" "<<End<<endl;
+      }
     }
   }
 
-   void get_axis_type(string axis,bool &log)
+  //S to struct
+  void gdlStoreAxisSandWINDOW(GDLGStream* actStream, string axis, DDouble Start, DDouble End, bool log)
+  {
+    PLFLT p_xmin, p_xmax, p_ymin, p_ymax, min, max;
+    actStream->gvpd(p_xmin, p_xmax, p_ymin, p_ymax); //viewport normalized coords
+    DStructGDL* Struct=NULL;
+    if ( axis=="X" ) {Struct=SysVar::X(); min=p_xmin, max=p_xmax;}
+    if ( axis=="Y" ) {Struct=SysVar::Y(); min=p_ymin, max=p_ymax;}
+    if ( axis=="Z" ) {Struct=SysVar::Z(); min=0, max=1;}
+    if ( Struct!=NULL )
+    {
+      if ( log ) {Start=log10(Start); End=log10(End);}
+      static unsigned windowTag=Struct->Desc()->TagIndex("WINDOW");
+      static unsigned sTag=Struct->Desc()->TagIndex("S");
+      (*static_cast<DFloatGDL*>(Struct->GetTag(windowTag, 0)))[0]=min;
+      (*static_cast<DFloatGDL*>(Struct->GetTag(windowTag, 0)))[1]=max;
+
+      (*static_cast<DDoubleGDL*>(Struct->GetTag(sTag, 0)))[0]=
+      (min*End-max*Start)/(End-Start);
+      (*static_cast<DDoubleGDL*>(Struct->GetTag(sTag, 0)))[1]=
+      (max-min)/(End-Start);
+    }
+  }
+
+  void gdlStoreCLIP(DLongGDL* clipBox)
+  {
+    static DStructGDL* pStruct=SysVar::P();
+    int i;
+    static unsigned clipTag=pStruct->Desc()->TagIndex("CLIP");
+    for ( i=0; i<clipBox->N_Elements(); ++i ) (*static_cast<DLongGDL*>(pStruct->GetTag(clipTag, 0)))[i]=(*clipBox)[i];
+  }
+
+  void gdlGetAxisType(string axis, bool &log)
   {
     DStructGDL* Struct;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
-    if(axis=="Z") Struct = SysVar::Z();
-    if(Struct != NULL) {
-      static unsigned typeTag = Struct->Desc()->TagIndex( "TYPE");
-      if ((*static_cast<DLongGDL*>(Struct->GetTag( typeTag, 0)))[0] == 1)
-	log = 1;
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+    if ( Struct!=NULL )
+    {
+      static unsigned typeTag=Struct->Desc()->TagIndex("TYPE");
+      if ( (*static_cast<DLongGDL*>(Struct->GetTag(typeTag, 0)))[0]==1 )
+        log=true;
       else
-	log=0;
+        log=false;
     }
   }
 
   void get_mapset(bool &mapset)
   {
-    DStructGDL* Struct = SysVar::X();
-    if(Struct != NULL) {
-      static unsigned typeTag = Struct->Desc()->TagIndex( "TYPE");
+    DStructGDL* Struct=SysVar::X();
+    if ( Struct!=NULL )
+    {
+      static unsigned typeTag=Struct->Desc()->TagIndex("TYPE");
 
-      if ((*static_cast<DLongGDL*>(Struct->GetTag( typeTag, 0)))[0] == 3)
-	mapset = 1;
+      if ( (*static_cast<DLongGDL*>(Struct->GetTag(typeTag, 0)))[0]==3 )
+        mapset=true;
       else
-	mapset = 0;
+        mapset=false;
     }
   }
 
   void set_mapset(bool mapset)
   {
-    DStructGDL* Struct = SysVar::X();
-    if(Struct!=NULL)
-      {
-	static unsigned typeTag = Struct->Desc()->TagIndex( "TYPE");
-	(*static_cast<DLongGDL*>( Struct->GetTag( typeTag, 0)))[0] = mapset;
-      }
+    DStructGDL* Struct=SysVar::X();
+    if ( Struct!=NULL )
+    {
+      static unsigned typeTag=Struct->Desc()->TagIndex("TYPE");
+      (*static_cast<DLongGDL*>(Struct->GetTag(typeTag, 0)))[0]=(mapset)?3:0;
+    }
   }
 
 
   //axis type (log..)
-  void set_axis_type(string axis, bool Type)
+
+  void gdlStoreAxisType(string axis, bool Type)
   {
     DStructGDL* Struct=NULL;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
-    if(axis=="Z") Struct = SysVar::Z();
-    if(Struct!=NULL)
-      {
-	static unsigned typeTag = Struct->Desc()->TagIndex("TYPE");
-	(*static_cast<DLongGDL*>(Struct->GetTag(typeTag, 0)))[0] = Type;
-      }
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+    if ( Struct!=NULL )
+    {
+      static unsigned typeTag=Struct->Desc()->TagIndex("TYPE");
+      (*static_cast<DLongGDL*>(Struct->GetTag(typeTag, 0)))[0]=Type;
+    } 
+  }
+
+  void gdlGetDesiredAxisCharsize(EnvT* e, string axis, DFloat &charsize)
+  {
+    //default:
+    charsize=1.0;
+    // get !P preference. Even if xcharsize is absent, presence of charsize or !P.charsize must be taken into account.
+    static DStructGDL* pStruct=SysVar::P();
+    charsize=(*static_cast<DFloatGDL*>
+              (pStruct->GetTag
+              (pStruct->Desc()->TagIndex("CHARSIZE"), 0)))[0];
+    string Charsize_s="CHARSIZE";
+    e->AssureFloatScalarKWIfPresent(Charsize_s, charsize); // option charsize overloads P.CHARSIZE
+    if (charsize==0) charsize=1.0;
+    // Axis Preference
+    static DStructGDL* Struct=NULL;
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+
+    if ( Struct!=NULL )
+    {
+      DFloat axisCharsize=0.0;
+      static unsigned charsizeTag=Struct->Desc()->TagIndex("CHARSIZE"); //X.CHARSIZE
+      axisCharsize=(*static_cast<DFloatGDL*>(Struct->GetTag(charsizeTag, 0)))[0];
+      Charsize_s=axis+"CHARSIZE"; //XCHARSIZE
+      e->AssureFloatScalarKWIfPresent(Charsize_s, axisCharsize); //option [XYZ]CHARSIZE overloads ![XYZ].CHARSIZE
+      if (axisCharsize>0.0) charsize*=axisCharsize; //IDL Behaviour...
+    }
+  }
+  
+  void gdlGetDesiredAxisGridStyle(EnvT* e, string axis, DLong &axisGridstyle)
+  {
+    axisGridstyle=0;
+    DStructGDL* Struct=NULL;
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+    if ( Struct!=NULL )
+    {
+      string gridstyle_s=axis+"GRIDSTYLE";
+      e->AssureLongScalarKWIfPresent(gridstyle_s, axisGridstyle);
+    }
   }
 
-  void gkw_axis_charsize(EnvT* e, string axis, DFloat &charsize)
+  //[XYZ]MARGIN kw decoding
+  void gdlGetDesiredAxisMargin(EnvT *e, string axis, DFloat &start, DFloat &end)
   {
     DStructGDL* Struct;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
 
-    if(Struct != NULL)
-      {
-	static unsigned charsizeTag = Struct->Desc()->TagIndex("CHARSIZE");
-	charsize =
-	  (*static_cast<DFloatGDL*>( Struct->GetTag( charsizeTag, 0)))[0];
-      }
+    if ( Struct!=NULL )
+    {
+      unsigned marginTag=Struct->Desc()->TagIndex("MARGIN");
+      start=
+      (*static_cast<DFloatGDL*>(Struct->GetTag(marginTag, 0)))[0];
+      end=
+      (*static_cast<DFloatGDL*>(Struct->GetTag(marginTag, 0)))[1];
+    }
 
-    string Charsize_s=axis+"CHARSIZE";
-    e->AssureFloatScalarKWIfPresent( Charsize_s, charsize);
-    if(charsize <=0.0) charsize=1.0;
+    string MarginName=axis+"MARGIN";
+    BaseGDL* Margin=e->GetKW(e->KeywordIx(MarginName));
+    if ( Margin!=NULL )
+    {
+      if ( Margin->N_Elements()>2 )
+        e->Throw("Keyword array parameter "+MarginName+
+                 " must have from 1 to 2 elements.");
+      Guard<DFloatGDL> guard;
+      DFloatGDL* MarginF=static_cast<DFloatGDL*>
+      (Margin->Convert2(GDL_FLOAT, BaseGDL::COPY));
+      guard.Reset(MarginF);
+      start=(*MarginF)[0];
+      if ( MarginF->N_Elements()>1 )
+        end=(*MarginF)[1];
+    }
+  }
+
+  void gdlGetDesiredAxisMinor(EnvT* e, string axis, DLong &axisMinor)
+  {
+    axisMinor=0;
+    string what_s="MINOR";
+    DStructGDL* Struct=NULL;
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+    if ( Struct!=NULL )
+    {
+      static unsigned AxisMinorTag=Struct->Desc()->TagIndex(what_s);
+      axisMinor=(*static_cast<DLongGDL*>(Struct->GetTag(AxisMinorTag,0)))[0];
+    }
+    what_s=axis+"MINOR";
+    e->AssureLongScalarKWIfPresent(what_s, axisMinor);
   }
 
+  //GET RANGE
 
-  //STYLE
-  void gkw_axis_style(EnvT *e, string axis, DLong &style)
+  bool gdlGetDesiredAxisRange(EnvT *e, string axis, DDouble &start, DDouble &end)
   {
     DStructGDL* Struct;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
-    if(Struct != NULL)
-      {
-	static unsigned styleTag = Struct->Desc()->TagIndex( "STYLE");
-	style =
-	  (*static_cast<DLongGDL*>( Struct->GetTag( styleTag, 0)))[0];
+    bool set=FALSE;
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+    if ( Struct!=NULL )
+    {
+      DDouble test1, test2;
+      static unsigned rangeTag=Struct->Desc()->TagIndex("RANGE");
+      test1=(*static_cast<DDoubleGDL*>(Struct->GetTag(rangeTag, 0)))[0];
+      test2=(*static_cast<DDoubleGDL*>(Struct->GetTag(rangeTag, 0)))[1];
+      if ( !(test1==0.0&&test2==0.0) )
+      {
+        start=test1;
+        end=test2;
+        set=TRUE;
       }
+    }
+    string RangeName=axis+"RANGE";
+    BaseGDL* Range=e->GetKW(e->KeywordIx(RangeName));
+    if ( Range!=NULL )
+    {
+      if ( Range->N_Elements()!=2 )
+        e->Throw("Keyword array parameter "+RangeName+
+                 " must have 2 elements.");
+      Guard<DDoubleGDL> guard;
+      DDoubleGDL* RangeF=static_cast<DDoubleGDL*>(Range->Convert2(GDL_DOUBLE, BaseGDL::COPY));
+      guard.Reset(RangeF);
+      start=(*RangeF)[0];
+      end=(*RangeF)[1];
+      set=TRUE;
+    }
+    return set;
+  }
 
-    string StyleName=axis+"STYLE";
+  //STYLE
 
+  void gdlGetDesiredAxisStyle(EnvT *e, string axis, DLong &style)
+  {
+    DStructGDL* Struct;
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+    if ( Struct!=NULL )
+    {
+      static unsigned styleTag=Struct->Desc()->TagIndex("STYLE");
+      style=
+      (*static_cast<DLongGDL*>(Struct->GetTag(styleTag, 0)))[0];
+    }
+
+    string style_s=axis+"STYLE";
+    e->AssureLongScalarKWIfPresent( style_s, style);
   }
 
-  void gkw_axis_title(EnvT *e, string axis, DString &title)
+   //XTHICK
+  void gdlGetDesiredAxisThick(EnvT *e,  string axis, DFloat &thick)
   {
+    thick=1.0;
     DStructGDL* Struct;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
 
-    if(Struct != NULL)
-      {
-	static unsigned titleTag = Struct->Desc()->TagIndex("TITLE");
-	title =
-	  (*static_cast<DStringGDL*>( Struct->GetTag( titleTag, 0)))[0];
-      }
+    if ( Struct!=NULL )
+    {
+      string thick_s=axis+"THICK";
+      e->AssureFloatScalarKWIfPresent(thick_s, thick);
+      if ( thick<=0.0 ) thick=1.0;
+    }
+  }
 
-    string TitleName=axis+"TITLE";
-    e->AssureStringScalarKWIfPresent( TitleName, title);
+  void gdlGetDesiredAxisTickget(EnvT *e,  string axis, DDoubleGDL *Axistickget)
+  {
+    //TODO!
+  }
 
+  void gdlGetDesiredAxisTickFormat(EnvT* e, string axis, DStringGDL* &axisTickformatVect)
+  {
+    static DStructGDL* Struct=NULL;
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+    if ( Struct!=NULL )
+    {
+      static unsigned AxisTickformatTag=Struct->Desc()->TagIndex("TICKFORMAT");
+      axisTickformatVect=static_cast<DStringGDL*>(Struct->GetTag(AxisTickformatTag,0));
+    }
+    string what_s=axis+"TICKFORMAT";
+    int axistickformatIx=e->KeywordIx (what_s);
+    if (axistickformatIx==-1)
+    {
+      Warning("[XYZ]TICKFORMAT Keyword unknown (FIXME)");
+      return;
+    }
+    if ( e->GetKW ( axistickformatIx )!=NULL )
+    {
+      axisTickformatVect=e->GetKWAs<DStringGDL>( axistickformatIx );
+    }
   }
 
-  //GET RANGE
+   void gdlGetDesiredAxisTickInterval(EnvT* e, string axis, DDouble &axisTickinterval)
+  {
+    axisTickinterval=0;
+    DStructGDL* Struct=NULL;
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+    if ( Struct!=NULL )
+    {
+      axisTickinterval=(*static_cast<DDoubleGDL*>
+                (Struct->GetTag
+                (Struct->Desc()->TagIndex("TICKINTERVAL"), 0)))[0];
+    }
+    string what_s=axis+"TICKINTERVAL";
+    e->AssureDoubleScalarKWIfPresent(what_s, axisTickinterval);
+  }
+
+  void gdlGetDesiredAxisTickLayout(EnvT* e, string axis, DLong &axisTicklayout)
+  {
+    axisTicklayout=0;
+    DStructGDL* Struct=NULL;
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+    if ( Struct!=NULL )
+    {
+      axisTicklayout=(*static_cast<DFloatGDL*>
+                (Struct->GetTag
+                (Struct->Desc()->TagIndex("TICKLAYOUT"), 0)))[0];
+    }
+    string what_s=axis+"TICKLAYOUT";
+    e->AssureLongScalarKWIfPresent(what_s, axisTicklayout);
+  }
+
+  void gdlGetDesiredAxisTickLen(EnvT* e, string axis, DFloat &ticklen)
+  {
+    // order: !P.TICKLEN, TICKLEN, !X.TICKLEN, /XTICKLEN
+    // get !P preference
+    static DStructGDL* pStruct=SysVar::P();
+    ticklen=(*static_cast<DFloatGDL*>
+            (pStruct->GetTag
+            (pStruct->Desc()->TagIndex("TICKLEN"), 0)))[0];
+    string ticklen_s="TICKLEN";
+    e->AssureFloatScalarKWIfPresent(ticklen_s, ticklen);
+
+    DStructGDL* Struct=NULL;
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+    if ( Struct!=NULL )
+    {
+      static unsigned ticklenTag=Struct->Desc()->TagIndex("TICKLEN");
+      DFloat axisTicklen=0.0;
+      axisTicklen=(*static_cast<DFloatGDL*>(Struct->GetTag(ticklenTag, 0)))[0];
+      ticklen_s=axis+"TICKLEN";
+      e->AssureFloatScalarKWIfPresent(ticklen_s, axisTicklen);
+      if (axisTicklen!=0.0) ticklen=axisTicklen;
+    }
+  }
+
+
+  void gdlGetDesiredAxisTickName(EnvT* e, string axis, DStringGDL* &axisTicknameVect)
+  {
+    static DStructGDL* Struct=NULL;
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+    if ( Struct!=NULL )
+    {
+      static unsigned AxisTicknameTag=Struct->Desc()->TagIndex("TICKNAME");
+      axisTicknameVect=static_cast<DStringGDL*>(Struct->GetTag(AxisTicknameTag,0));
+    }
+    string what_s=axis+"TICKNAME";
+    int axisticknameIx=e->KeywordIx (what_s);
+    if (axisticknameIx==-1)
+    {
+      Warning("[XYZ]TICKNAME Keyword unknown (FIXME)");
+      return;
+    }
+    if ( e->GetKW ( axisticknameIx )!=NULL )
+    {
+      axisTicknameVect=e->GetKWAs<DStringGDL>( axisticknameIx );
+    }
+
+  }
+
+  void gdlGetDesiredAxisTicks(EnvT* e, string axis, DLong &axisTicks)
+  {
+    axisTicks=0;
+    DStructGDL* Struct=NULL;
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+    if ( Struct!=NULL )
+    {
+      axisTicks=(*static_cast<DFloatGDL*>
+                (Struct->GetTag
+                (Struct->Desc()->TagIndex("TICKS"), 0)))[0];
+    }
+    string what_s=axis+"TICKS";
+    e->AssureLongScalarKWIfPresent(what_s, axisTicks);
+  }
 
-  void gkw_axis_range(EnvT *e, string axis, DDouble &start, DDouble &end,
-                      DLong &ynozero)
+ void gdlGetDesiredAxisTickUnits(EnvT* e, string axis, DStringGDL* &axisTickunitsVect)
+  {
+    static DStructGDL* Struct=NULL;
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+    if ( Struct!=NULL )
+    {
+      static unsigned AxisTickunitsTag=Struct->Desc()->TagIndex("TICKUNITS");
+      axisTickunitsVect=static_cast<DStringGDL*>(Struct->GetTag(AxisTickunitsTag,0));
+    }
+    string what_s=axis+"TICKUNITS";
+    int axistickunitsIx=e->KeywordIx (what_s);
+    if (axistickunitsIx==-1) 
+    {
+      Warning("[XYZ]TICKUNITS Keyword unknown (FIXME)");
+      return;
+    }
+    if ( e->GetKW ( axistickunitsIx )!=NULL )
+    {
+      axisTickunitsVect=e->GetKWAs<DStringGDL>( axistickunitsIx );
+    }
+  }
+
+  void gdlGetDesiredAxisTickv(EnvT* e, string axis, DDoubleGDL* axisTickvVect)
+  {
+    static DStructGDL* Struct=NULL;
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+    if ( Struct!=NULL )
+    {
+      static unsigned AxisTickvTag=Struct->Desc()->TagIndex("TICKV");
+      axisTickvVect=static_cast<DDoubleGDL*>(Struct->GetTag(AxisTickvTag,0));
+
+    }
+    string what_s=axis+"TICKV";
+    int axistickvIx=e->KeywordIx (what_s);
+    if (axistickvIx==-1)
+    {
+      Warning("[XYZ]TICKV Keyword unknown (FIXME)");
+      return;
+    }
+    if ( e->GetKW ( axistickvIx )!=NULL )
+    {
+      axisTickvVect=e->GetKWAs<DDoubleGDL>( axistickvIx );
+    }
+  }
+
+  void gdlGetDesiredAxisTitle(EnvT *e, string axis, DString &title)
   {
     DStructGDL* Struct;
-    if (axis == "X") Struct = SysVar::X();
-    if (axis == "Y") Struct = SysVar::Y();
-    if (Struct != NULL)
+    if ( axis=="X" ) Struct=SysVar::X();
+    if ( axis=="Y" ) Struct=SysVar::Y();
+    if ( axis=="Z" ) Struct=SysVar::Z();
+
+    if ( Struct!=NULL )
     {
-      DDouble test1, test2;
-      static unsigned rangeTag = Struct->Desc()->TagIndex("RANGE");
-      test1 = (*static_cast<DDoubleGDL*> (Struct->GetTag(rangeTag, 0)))[0];
-      test2 = (*static_cast<DDoubleGDL*> (Struct->GetTag(rangeTag, 0)))[1];
-      if (!(test1 == 0.0 && test2 == 0.0))
+      static unsigned titleTag=Struct->Desc()->TagIndex("TITLE");
+      title=
+      (*static_cast<DStringGDL*>(Struct->GetTag(titleTag, 0)))[0];
+    }
+
+    string TitleName=axis+"TITLE";
+    e->AssureStringScalarKWIfPresent(TitleName, title);
+  }
+
+    void tickformat_date(PLFLT juliandate, string &Month , PLINT &Day , PLINT &Year , PLINT &Hour , PLINT &Minute, PLFLT &Second)
+    {
+    static string theMonth[12]={"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
+    PLFLT JD,Z,F,a;
+    PLINT A,B,C,D,E,month;
+    JD = juliandate + 0.5;
+    Z = floor(JD);
+    F = JD - Z;
+
+    if (Z < 2299161) A = (PLINT)Z;
+    else {
+      a = (int) ((Z - 1867216.25) / 36524.25);
+      A = (PLINT) (Z + 1 + a - (int)(a / 4));
+    }
+
+    B = A + 1524;
+    C = (PLINT) ((B - 122.1) / 365.25);
+    D = (PLINT) (365.25 * C);
+    E = (PLINT) ((B - D) / 30.6001);
+
+    // month
+    month = E < 14 ? E - 1 : E - 13;
+    Month=theMonth[month-1];
+    // day
+    Day=B - D - (int)(30.6001 * E);
+    // year
+    Year = month > 2 ? C - 4716 : C - 4715;
+    // hours
+    Hour = (PLINT) (F * 24);
+    F -= (double)Hour / 24;
+    // minutes
+    Minute = (int) (F * 1440);
+    F -= (double)Minute / 1440;
+    // seconds
+    Second = F * 86400;
+  }
+
+  void doOurOwnFormat(PLINT axisNotUsed, PLFLT value, char *label, PLINT length, PLPointer data)
+  {
+    struct GDL_TICKDATA *ptr = (GDL_TICKDATA* )data;
+    static string normalfmt[7]={"%1.0fx10#u%d#d","%2.1fx10#u%d#d","%3.2fx10#u%d#d","%4.2fx10#u%d#d","%5.4fx10#u%d#d","%6.5fx10#u%d#d","%7.6fx10#u%d#d"};
+    static string specialfmt="10#u%d#d";
+    static string specialfmtlog="10#u%s#d";
+    PLFLT z;
+    int ns;
+    char *i;
+    char *test=(char*)calloc(2*length, sizeof(char)); //be safe
+    int sgn=(value<0)?-1:1;
+    if (sgn*value<gdlEpsDouble()) {snprintf(label, length, "0",value); return;}
+    int e=floor(log10(value*sgn));
+    if (!(e==e)||(e<4 && e>-4)) 
+    {
+      snprintf(test, length, "%f",value);
+      ns=strlen(test);
+      i=rindex(test,'0');
+      while (i==(test+ns-1)) //remove trailing zeros...
+      {
+          *i='\0';
+        i=rindex(test,'0');
+        ns--;
+      }
+      i=rindex(test,'.'); //remove trailing '.'
+      if (i==(test+ns-1)) {*i='\0'; ns--;}
+      if (ptr->isLog) snprintf( label, length, specialfmtlog.c_str(),test);
+      else
+      strncpy(label, test, length);
+    }
+    else
+    {
+      z=value*sgn/pow(10,e);
+      snprintf(test,20,"%7.6f",z);
+      ns=strlen(test);
+      i=rindex(test,'0');
+      while (i==(test+ns-1))
+      {
+          *i='\0';
+        i=rindex(test,'0');
+        ns--;
+      }
+      ns-=2;ns=(ns>6)?6:ns;
+      if (floor(sgn*z)==1 && ns==0) snprintf( label, length, specialfmt.c_str(),e); else snprintf( label, length, normalfmt[ns].c_str(),sgn*z,e);
+    }
+    free(test);
+  }
+
+  void gdlMultiAxisTickFunc(PLINT axis, PLFLT value, char *label, PLINT length, PLPointer data)
+  {
+    static GDL_TICKDATA tdata;
+    static SizeT internalIndex=0;
+    static DLong lastUnits=0;
+    string Month;
+    PLINT Day , Year , Hour , Minute;
+    PLFLT Second;
+    struct GDL_MULTIAXISTICKDATA *ptr = (GDL_MULTIAXISTICKDATA* )data;
+    tdata.isLog=ptr->isLog;
+    if (ptr->counter != lastUnits)
+    {
+      lastUnits=ptr->counter;
+      internalIndex=0;
+    }
+    if (ptr->what==GDL_TICKFORMAT || (ptr->what==GDL_TICKFORMAT_AND_UNITS && ptr->counter < ptr->nTickFormat) )
+    {
+      if (ptr->counter > ptr->nTickFormat-1)
       {
-        start = test1;
-        end = test2;
+        doOurOwnFormat(axis, value, label, length, &tdata);
+//        snprintf( label, length, "%f", value );
+      }
+      else
+      {
+        if (((*ptr->TickFormat)[ptr->counter]).substr(0,1) == "(")
+        { //internal format, call internal func "STRING"
+          EnvT *e=ptr->e;
+          static int stringIx = LibFunIx("STRING");
+          assert( stringIx >= 0);
+          EnvT* newEnv= new EnvT(e, libFunList[stringIx], NULL);
+          Guard<EnvT> guard( newEnv);
+          // add parameters
+          newEnv->SetNextPar( new DDoubleGDL(value));
+          newEnv->SetNextPar( new DStringGDL(((*ptr->TickFormat)[ptr->counter]).c_str()));
+          // make the call
+          BaseGDL* res = static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
+          strcpy(label,(*static_cast<DStringGDL*>(res))[0].c_str()); 
+        }
+        else if (((*ptr->TickFormat)[ptr->counter]).substr(0,10) == "LABEL_DATE")
+        { //special internal format, TBD
+          Warning("unsupported LABEL_DATE for TICKFORMAT (FIXME)");
+        }
+        else // external function: if tickunits not specified, pass Axis (int), Index(int),Value(Double)
+          //    else pass also Level(int)
+          // Thanks to Marc for code snippet!
+        {
+          EnvT *e=ptr->e;
+          DString callF=(*ptr->TickFormat)[ptr->counter];
+          // this is a function name -> convert to UPPERCASE
+          callF = StrUpCase( callF);
+          	//  Search in user proc and function
+          SizeT funIx = GDLInterpreter::GetFunIx( callF);
+
+          EnvUDT* newEnv = new EnvUDT( e->CallingNode(), funList[ funIx], (BaseGDL**)NULL);
+          Guard< EnvUDT> guard( newEnv);
+          // add parameters
+          newEnv->SetNextPar( new DLongGDL(axis));
+          newEnv->SetNextPar( new DLongGDL(internalIndex));
+          newEnv->SetNextPar( new DDoubleGDL(value));
+          if (ptr->what==GDL_TICKFORMAT_AND_UNITS) newEnv->SetNextPar( new DLongGDL(ptr->counter));
+          // guard *before* pushing new env
+          StackGuard<EnvStackT> guard1 ( e->Interpreter()->CallStack());
+          e->Interpreter()->CallStack().push_back(newEnv);
+          guard.release();
+
+          BaseGDL* retValGDL = e->Interpreter()->call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree()); 
+          // we are the owner of the returned value
+          Guard<BaseGDL> retGuard( retValGDL);
+          strcpy(label,(*static_cast<DStringGDL*>(retValGDL))[0].c_str()); 
+        }
       }
     }
-    string RangeName = axis + "RANGE";
-    BaseGDL* Range = e->GetKW(e->KeywordIx(RangeName));
-    if (Range != NULL)
+    else if (ptr->what==GDL_TICKUNITS)
     {
-      if (Range->N_Elements() != 2)
-        e->Throw("Keyword array parameter " + RangeName +
-                 " must have 2 elements.");
-      auto_ptr<DDoubleGDL> guard;
-      DDoubleGDL* RangeF = static_cast<DDoubleGDL*>
-	(Range->Convert2(GDL_DOUBLE, BaseGDL::COPY));
-      guard.reset(RangeF);
-      start = (*RangeF)[0];
-      end = (*RangeF)[1];
-      if (axis == "Y") ynozero = 1;
+      if (ptr->counter > ptr->nTickUnits-1)
+      {
+        doOurOwnFormat(axis, value, label, length, &tdata);
+//        snprintf( label, length, "%f", value );
+      }
+      else
+      {
+        DString what=StrUpCase((*ptr->TickUnits)[ptr->counter]);
+        DDouble range=abs(ptr->axismax-ptr->axismin);
+        tickformat_date(value, Month , Day , Year , Hour , Minute, Second);
+        if (what.substr(0,4)=="YEAR")
+          snprintf( label, length, "%d", Year);
+        else if (what.substr(0,5)=="MONTH")
+          snprintf( label, length, "%s", Month.c_str());
+        else if (what.substr(0,3)=="DAY")
+          snprintf( label, length, "%d", Day);
+        else if (what.substr(0,4)=="HOUR")
+          snprintf( label, length, "%d", Hour);
+        else if (what.substr(0,6)=="MINUTE")
+          snprintf( label, length, "%d", Minute);
+        else if (what.substr(0,6)=="SECOND")
+          snprintf( label, length, "%f", Second);
+        else if (what.substr(0,4)=="TIME")
+        {
+          if(range>=366) snprintf( label, length, "%d", Year);
+          else if(range>=32) snprintf( label, length, "%s", Month.c_str());
+          else if(range>=1.1) snprintf( label, length, "%d", Day);
+          else if(range*24>=1.1) snprintf( label, length, "%d", Hour);
+          else if(range*24*60>=1.1) snprintf( label, length, "%d", Minute);
+          else snprintf( label, length, "%04.1f",Second);
+        }
+        else snprintf( label, length, "%g", value );
+      }
     }
+    internalIndex++;
   }
-  //current value of margin of axis 'axis'
-  void get_axis_margin(string axis, DFloat &low, DFloat &high)
+
+  void gdlSingleAxisTickFunc( PLINT axis, PLFLT value, char *label, PLINT length, PLPointer data)
   {
-    DStructGDL* Struct=NULL;
-    if(axis=="X") Struct = SysVar::X();
-    if(axis=="Y") Struct = SysVar::Y();
-    if(Struct!=NULL)
-      {
-	static unsigned marginTag = Struct->Desc()->TagIndex( "MARGIN");
-	low = (*static_cast<DFloatGDL*>( Struct->GetTag( marginTag, 0)))[0];
-	high = (*static_cast<DFloatGDL*>( Struct->GetTag( marginTag, 0)))[1];
+    static GDL_TICKDATA tdata;
+    struct GDL_TICKNAMEDATA *ptr = (GDL_TICKNAMEDATA* )data;
+    tdata.isLog=ptr->isLog;
+    if (ptr->counter > ptr->nTickName-1)
+    {
+      doOurOwnFormat(axis, value, label, length, &tdata);
+    }
+    else
+    {
+      snprintf( label, length, "%s", ((*ptr->TickName)[ptr->counter]).c_str() );
+    }
+    ptr->counter++;
+  }
+
+  bool gdlAxis(EnvT *e, GDLGStream *a, string axis, DDouble Start, DDouble End, bool Log, DLong modifierCode)
+  {
+    static GDL_TICKNAMEDATA data;
+    static GDL_MULTIAXISTICKDATA muaxdata;
+
+    static GDL_TICKDATA tdata;
+    tdata.isLog=Log;
+
+    data.nTickName=0;
+    muaxdata.e=e;
+    muaxdata.what=GDL_NONE;
+    muaxdata.nTickFormat=0;
+    muaxdata.nTickUnits=0;
+    muaxdata.axismin=Start;
+    muaxdata.axismax=End;
+
+    DFloat Charsize;
+    gdlGetDesiredAxisCharsize(e, axis, Charsize);
+    DLong GridStyle;
+    gdlGetDesiredAxisGridStyle(e, axis, GridStyle);
+    DFloat MarginL, MarginR;
+    gdlGetDesiredAxisMargin(e, axis, MarginL, MarginR);
+    DLong Minor;
+    gdlGetDesiredAxisMinor(e, axis, Minor);
+    DLong Style;
+    gdlGetDesiredAxisStyle(e, axis, Style);
+    DFloat Thick;
+    gdlGetDesiredAxisThick(e, axis, Thick);
+    DStringGDL* TickFormat;
+    gdlGetDesiredAxisTickFormat(e, axis, TickFormat);
+    DDouble TickInterval;
+    gdlGetDesiredAxisTickInterval(e, axis, TickInterval);
+    DLong TickLayout;
+    gdlGetDesiredAxisTickLayout(e, axis, TickLayout);
+    DFloat TickLen;
+    gdlGetDesiredAxisTickLen(e, axis, TickLen);
+    DStringGDL* TickName;
+    gdlGetDesiredAxisTickName(e, axis, TickName);
+    DLong Ticks;
+    gdlGetDesiredAxisTicks(e, axis, Ticks);
+    DStringGDL* TickUnits;
+    gdlGetDesiredAxisTickUnits(e, axis, TickUnits);
+    DDoubleGDL* Tickv;
+    gdlGetDesiredAxisTickv(e, axis, Tickv);
+    DString Title;
+    gdlGetDesiredAxisTitle(e, axis, Title);
+
+    //special values
+    PLFLT baseTickLen;
+    if (axis=="X") baseTickLen=a->mmyPageSize()*(a->boxnYSize());
+    if (axis=="Y") baseTickLen=a->mmxPageSize()*(a->boxnXSize());
+
+    if ( (Style&4)!=4 ) //if we write the axis...
+    {
+      if (TickInterval==0)
+      {
+        if (Ticks<=0) TickInterval=gdlComputeTickInterval(e, axis, Start, End, Log);
+        else if (Ticks>1) TickInterval=(End-Start)/Ticks;
+        else TickInterval=(End-Start);
+      }
+      string Opt;
+      //first write labels only:
+      gdlSetAxisCharsize(e, a, axis);
+      gdlSetPlotCharthick(e, a);
+      // axis legend if box style, else do not draw:
+      if (modifierCode==0 ||modifierCode==1)
+      {
+        if (axis=="X") a->mtex("b", 3.5, 0.5, 0.5, Title.c_str());
+        else if (axis=="Y") a->mtex("l",5.0,0.5,0.5,Title.c_str());
+      }
+      else if (modifierCode==2)
+      {
+        if (axis=="X") a->mtex("t", 3.5, 0.5, 0.5, Title.c_str());
+        else if (axis=="Y") a->mtex("r",5.0,0.5,0.5,Title.c_str());
+      }
+      //axis, 1st time: labels
+      Opt="tvx";// the x option is in plplot 5.9.8 but not before. It permits
+                // to avoid writing tick marks here (they will be written after)
+                // I hope old plplots were clever enough to ignore 'x'
+                // if they did not understand 'x'
+      if ( Log ) Opt+="l";
+      if (TickName->NBytes()>0) // /TICKNAME=[array]
+      {
+        data.counter=0;
+        data.TickName=TickName;
+        data.nTickName=TickName->N_Elements();
+#if (HAVE_PLPLOT_SLABELFUNC)
+        a->slabelfunc( gdlSingleAxisTickFunc, &data );
+        Opt+="o";
+#endif
+        if (modifierCode==2) Opt+="m"; else Opt+="n";
+        if (axis=="X") a->box(Opt.c_str(), TickInterval, Minor, "", 0.0, 0);
+        else if (axis=="Y") a->box("", 0.0 ,0.0, Opt.c_str(), TickInterval, Minor);
+#if (HAVE_PLPLOT_SLABELFUNC)
+        a->slabelfunc( NULL, NULL );
+#endif
+      }
+      else if (TickUnits->NBytes()>0) // /TICKUNITS=[several types of axes written below each other]
+      {
+        muaxdata.counter=0;
+        muaxdata.what=GDL_TICKUNITS;
+        if (TickFormat->NBytes()>0)  // with also TICKFORMAT option..
+        {
+          muaxdata.what=GDL_TICKFORMAT_AND_UNITS;
+          muaxdata.TickFormat=TickFormat;
+          muaxdata.nTickFormat=TickFormat->N_Elements();
+        }
+        muaxdata.TickUnits=TickUnits;
+        muaxdata.nTickUnits=TickUnits->N_Elements();
+#if (HAVE_PLPLOT_SLABELFUNC)
+        a->slabelfunc( gdlMultiAxisTickFunc, &muaxdata );
+        Opt+="o";
+#endif
+        if (modifierCode==2) Opt+="m"; else Opt+="n";
+        for (SizeT i=0; i< muaxdata.nTickUnits; ++i) //loop on TICKUNITS axis
+        {
+          PLFLT un,deux,trois,quatre,xun,xdeux,xtrois,xquatre;
+          a->plstream::gvpd(un,deux,trois,quatre);
+          a->plstream::gvpw(xun,xdeux,xtrois,xquatre);
+          if (axis=="X") 
+          {
+            a->smaj(a->mmCharHeight(), 1.0 );
+            a->plstream::vpor(un,deux,(PLFLT)(trois-i*3*a->nCharHeight()),quatre);
+            a->plstream::wind(xun,xdeux,xtrois,xquatre);
+            a->box(Opt.c_str(), TickInterval, Minor, "", 0.0, 0);
+          }
+          else if (axis=="Y") 
+          {
+            a->smaj(a->mmCharLength(), 1.0 );
+            a->plstream::vpor(un-i*3*a->nCharLength(),deux,trois,quatre);
+            a->plstream::wind(xun,xdeux,xtrois,xquatre);
+            a->box("", 0.0 ,0.0, Opt.c_str(), TickInterval, Minor);
+          }
+          a->plstream::vpor(un,deux,trois,quatre);
+          a->plstream::wind(xun,xdeux,xtrois,xquatre);
+          muaxdata.counter++;
+        }
+#if (HAVE_PLPLOT_SLABELFUNC)
+        a->slabelfunc( NULL, NULL );
+#endif
+      }
+      else if (TickFormat->NBytes()>0) //no /TICKUNITS=> only 1 value taken into account
+      {
+        muaxdata.counter=0;
+        muaxdata.what=GDL_TICKFORMAT;
+        muaxdata.TickFormat=TickFormat;
+        muaxdata.nTickFormat=1;
+#if (HAVE_PLPLOT_SLABELFUNC)
+        a->slabelfunc( gdlMultiAxisTickFunc, &muaxdata );
+        Opt+="o";
+#endif
+        if (modifierCode==2) Opt+="m"; else Opt+="n";
+        if (axis=="X") a->box(Opt.c_str(), TickInterval, Minor, "", 0.0, 0);
+        else if (axis=="Y") a->box("", 0.0 ,0.0, Opt.c_str(), TickInterval, Minor);
+        
+#if (HAVE_PLPLOT_SLABELFUNC)        
+        a->slabelfunc( NULL, NULL );
+#endif
+      }
+      else
+      {
+#if (HAVE_PLPLOT_SLABELFUNC)
+        a->slabelfunc( doOurOwnFormat, &tdata );
+        Opt+="o";
+#endif
+        if (modifierCode==2) Opt+="m"; else Opt+="n";
+        if (axis=="X") a->box(Opt.c_str(), TickInterval, Minor, "", 0.0, 0);
+        else if (axis=="Y") a->box("", 0.0 ,0.0, Opt.c_str(), TickInterval, Minor);
+#if (HAVE_PLPLOT_SLABELFUNC)
+        a->slabelfunc( NULL, NULL );
+#endif
+      }
+      
+      if (TickLayout==0)
+      {
+        a->smaj((PLFLT)baseTickLen, 1.0); //set base ticks to default 0.02 viewport converted to mm.
+        a->smin((PLFLT)baseTickLen/2.0,1.0); //idem min (plplt defaults)
+        //thick for box and ticks.
+        a->wid(Thick);
+        //ticks or grid eventually with style and length:
+        Opt="st";
+        switch(modifierCode)
+        {
+          case 2:
+            Opt+="c";
+            break;
+          case 1:
+            Opt+="b";
+            break;
+          case 0:
+            if ( (Style&8)==8 ) Opt+="b"; else Opt+="bc";
+        }
+        if (TickLen<0) {Opt+="i"; TickLen=-TickLen;}
+        bool bloatsmall=(TickLen<0.3);
+        //gridstyle applies here:
+        gdlLineStyle(a,GridStyle);
+        a->smaj (0.0, (PLFLT)TickLen); //relative value
+        if (bloatsmall) a->smin (0.0, (PLFLT)TickLen); else a->smin( 1.5, 1.0 );
+        if ( Log ) Opt+="l";
+        if (axis=="X") a->box(Opt.c_str(), TickInterval, Minor, "", 0.0, 0);
+        else if (axis=="Y") a->box("", 0.0, 0, Opt.c_str(), TickInterval, Minor);
+        //reset ticks to default plplot value...
+        a->smaj( 3.0, 1.0 );
+        a->smin( 1.5, 1.0 );
+        //reset gridstyle
+        gdlLineStyle(a,0);
+        // pass over with outer box, with thick. No style applied, only ticks
+        Opt=" ";
+        switch(modifierCode)
+        {
+          case 2:
+            Opt+="c";
+            break;
+          case 1:
+            Opt+="b";
+            break;
+          case 0:
+            if ( (Style&8)==8 ) Opt+="b"; else Opt+="bc";
+        }
+        if (axis=="X") a->box(Opt.c_str(), 0.0, 0, "", 0.0, 0);
+        else if (axis=="Y") a->box("", 0.0, 0 , Opt.c_str(), 0.0, 0);
+      }
+      //reset charsize & thick
+      a->wid(1);
+      a->sizeChar(1.0);
+    }
+	return 0;
+  }
+
+  bool gdlBox(EnvT *e, GDLGStream *a, DDouble xStart, DDouble xEnd, DDouble yStart, DDouble yEnd, bool xLog, bool yLog)
+  {
+    gdlAxis(e, a, "X", xStart, xEnd, xLog);
+    gdlAxis(e, a, "Y", yStart, yEnd, yLog);
+    // title and sub title
+    gdlWriteTitleAndSubtitle(e, a);
+    return true;
+  }
+
+ bool gdlAxis3(EnvT *e, GDLGStream *a, string axis, DDouble Start, DDouble End, bool Log, DLong zAxisCode)
+  {
+    //exit if nothing to do...
+    string addCode="b"; //for X and Y, and some Z
+    if(zAxisCode==1 || zAxisCode==4) addCode="cm";
+    if(zAxisCode==-1) return true;
+
+    //
+    static GDL_TICKNAMEDATA data;
+    static GDL_MULTIAXISTICKDATA muaxdata;
+    data.nTickName=0;
+    muaxdata.e=e;
+    muaxdata.what=GDL_NONE;
+    muaxdata.nTickFormat=0;
+    muaxdata.nTickUnits=0;
+    muaxdata.axismin=Start;
+    muaxdata.axismax=End;
+
+    DFloat Charsize;
+    gdlGetDesiredAxisCharsize(e, axis, Charsize);
+    DLong GridStyle;
+    gdlGetDesiredAxisGridStyle(e, axis, GridStyle);
+    DFloat MarginL, MarginR;
+    gdlGetDesiredAxisMargin(e, axis, MarginL, MarginR);
+    DLong Minor;
+    gdlGetDesiredAxisMinor(e, axis, Minor);
+    DLong Style;
+    gdlGetDesiredAxisStyle(e, axis, Style);
+    DFloat Thick;
+    gdlGetDesiredAxisThick(e, axis, Thick);
+    DStringGDL* TickFormat;
+    gdlGetDesiredAxisTickFormat(e, axis, TickFormat);
+    DDouble TickInterval;
+    gdlGetDesiredAxisTickInterval(e, axis, TickInterval);
+    DLong TickLayout;
+    gdlGetDesiredAxisTickLayout(e, axis, TickLayout);
+    DFloat TickLen;
+    gdlGetDesiredAxisTickLen(e, axis, TickLen);
+    DStringGDL* TickName;
+    gdlGetDesiredAxisTickName(e, axis, TickName);
+    DLong Ticks;
+    gdlGetDesiredAxisTicks(e, axis, Ticks);
+    DStringGDL* TickUnits;
+    gdlGetDesiredAxisTickUnits(e, axis, TickUnits);
+    DDoubleGDL* Tickv;
+    gdlGetDesiredAxisTickv(e, axis, Tickv);
+    DString Title;
+    gdlGetDesiredAxisTitle(e, axis, Title);
+
+    //special values
+    PLFLT baseTickLen;
+    if (axis=="X") baseTickLen=a->mmyPageSize()*(a->boxnYSize());
+    if (axis=="Y") baseTickLen=a->mmxPageSize()*(a->boxnXSize());
+    if (axis=="Z") baseTickLen=a->mmxPageSize()*(a->boxnXSize());
+
+    if ( (Style&4)!=4 ) //if we write the axis...
+    {
+      if (TickInterval==0)
+      {
+        if (Ticks<=0) TickInterval=gdlComputeTickInterval(e, axis, Start, End, Log);
+        else if (Ticks>1) TickInterval=(End-Start)/Ticks;
+        else TickInterval=(End-Start);
+      }
+      string Opt;
+      //first write labels only:
+      gdlSetAxisCharsize(e, a, axis);
+      gdlSetPlotCharthick(e, a);
+      // axis legend if box style, else do not draw:
+      Opt="u";
+
+      if      (axis=="X") a->box3(Opt.c_str(), Title.c_str() , 0.0, 0, "", "", 0.0, 0, "", "", 0.0, 0);
+      else if (axis=="Y") a->box3("", "", 0.0 ,0, Opt.c_str(), Title.c_str(), 0.0, 0, "", "", 0.0, 0);
+      else if (axis=="Z") a->box3("", "", 0.0, 0, "", "", 0.0, 0, Opt.c_str(), Title.c_str(), 0.0, 0);
+
+
+      //axis, 1st time: labels
+      Opt=addCode+"nst"; //will write labels beside the left hand axis (u) at major ticks (n)
+      if ( Log ) Opt+="l";
+      if (TickName->NBytes()>0) // /TICKNAME=[array]
+      {
+        data.counter=0;
+        data.TickName=TickName;
+        data.nTickName=TickName->N_Elements();
+#if (HAVE_PLPLOT_SLABELFUNC)
+        a->slabelfunc( gdlSingleAxisTickFunc, &data );
+        Opt+="o";
+#endif
+        if      (axis=="X") a->box3(Opt.c_str(), "" , TickInterval, Minor, "", "", 0.0, 0, "", "", 0.0, 0);
+        else if (axis=="Y") a->box3("", "", 0.0 ,0.0, Opt.c_str(),"", TickInterval, Minor, "", "", 0.0, 0);
+        else if (axis=="Z") a->box3("", "", 0.0, 0, "", "", 0.0, 0, Opt.c_str(), "", TickInterval, Minor);
+#if (HAVE_PLPLOT_SLABELFUNC)
+        a->slabelfunc( NULL, NULL );
+#endif
+      }
+      else if (TickFormat->NBytes()>0) //no /TICKUNITS=> only 1 value taken into account
+      {
+        muaxdata.counter=0;
+        muaxdata.what=GDL_TICKFORMAT;
+        muaxdata.TickFormat=TickFormat;
+        muaxdata.nTickFormat=1;
+#if (HAVE_PLPLOT_SLABELFUNC)
+        a->slabelfunc( gdlMultiAxisTickFunc, &muaxdata );
+        Opt+="o";
+#endif
+        if      (axis=="X") a->box3(Opt.c_str(), "", TickInterval, Minor, "", "", 0.0, 0, "", "", 0.0, 0);
+        else if (axis=="Y") a->box3("", "", 0.0 ,0.0, Opt.c_str(),"", TickInterval, Minor, "", "", 0.0, 0);
+        else if (axis=="Z") a->box3("", "", 0.0, 0, "", "", 0.0, 0, Opt.c_str(), "", TickInterval, Minor);
+
+#if (HAVE_PLPLOT_SLABELFUNC)
+        a->slabelfunc( NULL, NULL );
+#endif
       }
+      else
+      {
+        if      (axis=="X") a->box3(Opt.c_str(), "", TickInterval, Minor, "", "", 0.0, 0, "", "", 0.0, 0);
+        else if (axis=="Y") a->box3("", "", 0.0 ,0.0, Opt.c_str(),"", TickInterval, Minor, "", "", 0.0, 0);
+        else if (axis=="Z") a->box3("", "", 0.0, 0, "", "", 0.0, 0, Opt.c_str(), "", TickInterval, Minor);
+      }
+
+      if (TickLayout==0)
+      {
+        a->smaj((PLFLT)baseTickLen, 1.0); //set base ticks to default 0.02 viewport converted to mm.
+        a->smin((PLFLT)baseTickLen/2.0,1.0); //idem min (plplt defaults)
+        //thick for box and ticks.
+        a->wid(Thick);
+        //ticks or grid eventually with style and length:
+        Opt=addCode+"st";
+
+        if (TickLen<0) {Opt+="i"; TickLen=-TickLen;}
+        bool bloatsmall=(TickLen<0.3);
+        //gridstyle applies here:
+        gdlLineStyle(a,GridStyle);
+        a->smaj (0.0, (PLFLT)TickLen); //relative value
+        if (bloatsmall) a->smin (0.0, (PLFLT)TickLen); else a->smin( 1.5, 1.0 );
+        if ( Log ) Opt+="l";
+        if      (axis=="X") a->box3(Opt.c_str(), "", TickInterval, Minor, "", "", 0.0, 0, "", "", 0.0, 0);
+        else if (axis=="Y") a->box3("", "", 0.0 ,0.0, Opt.c_str(),"", TickInterval, Minor, "", "", 0.0, 0);
+        else if (axis=="Z") a->box3("", "", 0.0, 0, "", "", 0.0, 0, Opt.c_str(), "", TickInterval, Minor);
+        //reset ticks to default plplot value...
+        a->smaj( 3.0, 1.0 );
+        a->smin( 1.5, 1.0 );
+        //reset gridstyle
+        gdlLineStyle(a,0);
+        // pass over with outer box, with thick. No style applied, only ticks
+        Opt="b";
+        if      (axis=="X") a->box3(Opt.c_str(), "", TickInterval, Minor, "","",0,0,"","",0,0);
+        else if (axis=="Y") a->box3("","",0,0, Opt.c_str(), "", TickInterval, Minor, "","",0,0);
+        else if (axis=="Z") a->box3("","",0,0,"","",0,0, Opt.c_str(), "", TickInterval, Minor);
+      }
+      //reset charsize & thick
+      a->wid(1);
+      a->sizeChar(1.0);
+    }
+	return 0;
+  }
+
+  bool gdlBox3(EnvT *e, GDLGStream *a, DDouble xStart, DDouble xEnd, DDouble yStart,
+      DDouble yEnd, DDouble zStart, DDouble zEnd, bool xLog, bool yLog, bool zLog, bool doSpecialZAxisPlacement)
+  {
+    DLong zAxisCode=0;
+    if (doSpecialZAxisPlacement) e->AssureLongScalarKWIfPresent("ZAXIS", zAxisCode);
+    gdlAxis3(e, a, "X", xStart, xEnd, xLog, 0);
+    gdlAxis3(e, a, "Y", yStart, yEnd, yLog, 0);
+    gdlAxis3(e, a, "Z", zStart, zEnd, zLog, zAxisCode);
+    // title and sub title
+    gdlWriteTitleAndSubtitle(e, a);
+    return true;
   }
+
   void usersym(EnvT *e)
-{
-      DFloatGDL *xyVal, *xVal, *yVal;
-      auto_ptr<BaseGDL> p0_guard;
-      DLong n;
-      DInt do_fill;
-      DFloat *x, *y;
-      SizeT nParam = e->NParam();
-
-      if (nParam == 1) {
- 	   BaseGDL* p0 = e->GetNumericArrayParDefined( 0)->Transpose( NULL); //hence [1024,2]
-
-	xyVal = static_cast<DFloatGDL*>
-	  (p0->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	p0_guard.reset( p0); // delete upon exit
+  {
+    DFloatGDL *xyVal, *xVal, *yVal;
+    Guard<BaseGDL> p0_guard;
+    DLong n;
+    DInt do_fill;
+    DFloat *x, *y;
+    SizeT nParam=e->NParam();
 
-	if(xyVal->Rank() != 2 || xyVal->Dim(1) != 2)
-          e->Throw(e->GetParString(0)+" must be a 2-dim array of type [2,N] in this context.");
+    if ( nParam==1 )
+    {
+      BaseGDL* p0=e->GetNumericArrayParDefined(0)->Transpose(NULL); //hence [1024,2]
 
-            if (xyVal->Dim(0) > 1024)
-            {
-                e->Throw("Max array size for USERSYM is 1024");
-            }
-            n = xyVal->Dim(0);
-            // array is in the good order for direct C assignement
-            x=&(*xyVal)[0];
-            y=&(*xyVal)[n];
-       } else {
-            xVal = e->GetParAs< DFloatGDL > (0);
-            if (xVal->Rank() != 1)
-                e->Throw(e->GetParString(0)+" must be a 1D array in this context: ");
-
-            yVal = e->GetParAs< DFloatGDL > (1);
-            if (yVal->Rank() != 1)
-                e->Throw("Expression must be a 1D array in this context: " + e->GetParString(1));
+      xyVal=static_cast<DFloatGDL*>
+      (p0->Convert2(GDL_FLOAT, BaseGDL::COPY));
+      p0_guard.Reset(p0); // delete upon exit
 
-            if (xVal->Dim(0)!= yVal->Dim(0))
-            {
-               e->Throw("Arrays must have same size ");
-            }
+      if ( xyVal->Rank()!=2||xyVal->Dim(1)!=2 )
+        e->Throw(e->GetParString(0)+" must be a 2-dim array of type [2,N] in this context.");
 
-            if (xVal->Dim(0) > 1024)
-            {
-                e->Throw("Max array size for USERSYM is 1024");
-            }
-            n = xVal->Dim(0);
-            x=&(*xVal)[0];
-            y=&(*yVal)[0];
-        }
-        do_fill=0;
-        if (e->KeywordSet("FILL")) {
-        do_fill=1;
-        }
-        SetUsym(n,do_fill, x, y);
+      if ( xyVal->Dim(0)>1024 )
+      {
+        e->Throw("Max array size for USERSYM is 1024");
+      }
+      n=xyVal->Dim(0);
+      // array is in the good order for direct C assignement
+      x=&(*xyVal)[0];
+      y=&(*xyVal)[n];
+    }
+    else
+    {
+      xVal=e->GetParAs< DFloatGDL>(0);
+      if ( xVal->Rank()!=1 )
+        e->Throw(e->GetParString(0)+" must be a 1D array in this context: ");
+
+      yVal=e->GetParAs< DFloatGDL>(1);
+      if ( yVal->Rank()!=1 )
+        e->Throw("Expression must be a 1D array in this context: "+e->GetParString(1));
+
+      if ( xVal->Dim(0)!=yVal->Dim(0) )
+      {
+        e->Throw("Arrays must have same size ");
+      }
+
+      if ( xVal->Dim(0)>1024 )
+      {
+        e->Throw("Max array size for USERSYM is 1024");
+      }
+      n=xVal->Dim(0);
+      x=&(*xVal)[0];
+      y=&(*yVal)[0];
+    }
+    do_fill=0;
+    if ( e->KeywordSet("FILL") )
+    {
+      do_fill=1;
+    }
+    SetUsym(n, do_fill, x, y);
   }
+
 } // namespace
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting_cursor.cpp gdl/src/plotting_cursor.cpp
--- gdl-0.9.3/src/plotting_cursor.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting_cursor.cpp	2013-05-16 12:36:33.523856813 -0600
@@ -24,18 +24,101 @@
 
 using namespace std;
 
-// get cursor from plPlot     AC February 2008
-// known limitations : WAIT parameter and similar keywords not fully managed (wait, nowait ...)
+void empty(EnvT* e)
+{
+  Graphics* actDevice = Graphics::GetDevice();
+  if (actDevice->Name() == "X")
+  {
+    GDLGStream *plg = actDevice->GetStream();
+    if (plg != NULL) plg->Flush();
+  }
+}
+
+void tvcrs( EnvT* e)
+{
+  Graphics* actDevice = Graphics::GetDevice();
+
+  if (actDevice->Name() != "X")
+  {
+    e->Throw("Routine is not defined for current graphics device.");
+  }
+  SizeT nParam = e->NParam(1);
+
+  if (nParam < 2 )
+  {
+    e->Throw("TVCRS with 1 argument not implemented (fixme)");
+  }
+  DDoubleGDL *x,*y;
+
+  x = e->GetParAs< DDoubleGDL > (0);
+  y = e->GetParAs< DDoubleGDL > (1);
+
+  GDLGStream *plg = actDevice->GetStream();
+  if (plg == NULL) e->Throw("Unable to create window.");
+  PLINT plplot_level;
+  plg->glevel(plplot_level);
+  // when level < 2, we have to read if ![x|y].crange exist
+  // if not, we have to build a [0,1]/[0,1] window
+  if (plplot_level < 2)
+  {
+    plg->NextPlot();
+
+    plg->vpor(0, 1, 0, 1);
+    plg->wind(0, 1, 0, 1);
 
+  }
+
+  PLFLT ix,iy;
+
+  if (e->KeywordSet("DEVICE"))
+  {
+    ix=(*x)[0];
+    iy=(*y)[0];
+  }
+  else if (e->KeywordSet("NORMAL"))
+  {
+    plg->NormToDevice((*x)[0],(*y)[0],ix,iy);
+  }
+  else // /DATA
+  { 
+    DDouble tempx,tempy;
+    tempx=(*x)[0];
+    tempy=(*y)[0];
+#ifdef USE_LIBPROJ4
+    bool mapSet = false;
+    get_mapset(mapSet);
+    if (mapSet)
+    {
+      PROJTYPE* ref = map_init();
+      if (ref == NULL) e->Throw("Projection initialization failed.");
+      LPTYPE idata, idataN;
+      idataN.lam = tempx* RAD_TO_DEG;
+      idataN.phi = tempy* RAD_TO_DEG;
+      XYTYPE odata = PJ_FWD(idata, ref);
+      tempx = odata.x;
+      tempy = odata.y;
+    }
+#endif
+    bool xLog, yLog;
+    gdlGetAxisType("X", xLog);
+    gdlGetAxisType("Y", yLog);
+    if(xLog) tempx=pow(10,tempx);
+    if(yLog) tempy=pow(10,tempy);
+    plg->WorldToDevice(tempx,tempy,ix,iy);
+  }
+  plg->WarpPointer(ix,iy);
+}
+
+// get cursor from plPlot     AC February 2008
+// fully compatible with IDL using our own cursor routines GD Jan 2013
 void cursor(EnvT* e){
   Graphics* actDevice = Graphics::GetDevice();
-  //cout << actDevice->Name() << endl;
+
   if (actDevice->Name() != "X")
   {
     e->Throw("Routine is not defined for current graphics device.");
   }
 
-  int debug = 0;
   SizeT nParam = e->NParam(1);
 
   if (nParam < 2 || nParam > 3)
@@ -51,12 +134,8 @@
 
   static PLGraphicsIn gin;
 
-  // content of : plGetCursor();
-  // [retval, state, keysym, button, string, pX, pY, dX, dY, wX, wY, subwin]
-
   PLINT plplot_level;
   plg->glevel(plplot_level);
-  if (debug) cout << "Plplot_level : " << plplot_level << endl;
   // when level < 2, we have to read if ![x|y].crange exist
   // if not, we have to build a [0,1]/[0,1] window
   if (plplot_level < 2)
@@ -66,124 +145,73 @@
     plg->vpor(0, 1, 0, 1);
     plg->wind(0, 1, 0, 1);
 
-    /* we are not ready for the correct way (rebuilding a window following
-   stored info)
-
-    // we have to read them back from !x.crange and !y.crange
-    PLFLT xStart, xEnd, yStart, yEnd;
-    get_axis_crange("X", xStart, xEnd);
-    get_axis_crange("Y", yStart, yEnd);
-    if ((xStart == xEnd ) || ( xEnd ==0.0)) {
-  xStart=0.0;
-  xEnd=1.0;
-    }
-    if ((yStart == yEnd ) || ( yEnd ==0.0)) {
-  yStart=0.0;
-  yEnd=1.0;
-    }
-    AC_debug("crange", xStart, xEnd, yStart, yEnd);
-
-    bool okVPWC = SetVP_WC( e, plg, NULL, NULL, 0, 0,
-                xStart, xEnd, yStart, yEnd, false, false);
-    if( !okVPWC) return;
-     */
   }
-
+  // mimic idl logic:
   DLong wait = 1;
-
   if (nParam == 3)
   {
     e->AssureLongScalarPar(2, wait);
   }
+  if (e->KeywordSet("NOWAIT")) wait=0;
+  if (e->KeywordSet("CHANGE")) wait=2;
+  if (e->KeywordSet("WAIT")) wait=1;
+  if (e->KeywordSet("DOWN")) wait=3;
+  if (e->KeywordSet("UP")) wait=4;
+  PLFLT xp, yp;
+  PLINT xleng, yleng, xoff, yoff;
+  plg->gpage(xp, yp, xleng, yleng, xoff, yoff);
 
-  if ((wait == 1) || (wait == 3) || (wait == 4) ||
-  e->KeywordSet("WAIT") ||
-  e->KeywordSet("DOWN") ||
-  e->KeywordSet("UP"))
-  {
-    //cout << "Sorry, this option is currently not *really* managed. Help welcome" << endl;
-    // we toggle to "wait == 1" (the mouse can move but we return if mouse is pressed)
-    wait = 1;
-  }
-
-  int mode = 0; // just a flag to manage the general case (cursor,x,y)
-
-  if ((wait == 0) || e->KeywordSet("NOWAIT"))
+  if (wait == 0)
   {
-    gin.button = 1;
-    plg->GetCursor(&gin);
-    gin.button = 0;
-    mode = 1;
-    wait = 0;
+    if(plg->GetGin(&gin, 0)==false) return;
   }
-  if (wait == 1)
+  else if (wait == 2)
   {
-    while (1)
-    {
-      plg->GetCursor(&gin);
-      //	cout << gin.button << endl;
-      if (gin.button > 0) break;
-      if (sigControlC)
-        return;
-    }
-    mode = 1;
-  }
-  if ((wait == 2) || e->KeywordSet("CHANGE"))
-  {
-    plg->GetCursor(&gin);
-    long RefX, RefY;
+    if(plg->GetGin(&gin, 0)==false) return;
+    PLFLT RefX, RefY;
     RefX = gin.pX;
     RefY = gin.pY;
-    if (gin.button == 0)
+    unsigned int refstate=gin.state;
+    while (1)
     {
-      while (1)
+      if(plg->GetGin(&gin, 2)==false) return;
+      if (abs(RefX - gin.pX) > 0 || abs(RefY - gin.pY) > 0)
+      {
+        RefX = gin.pX;
+        RefY = gin.pY;
+        break;
+      }
+      if (gin.state != refstate)
       {
-        plg->GetCursor(&gin);
-        if (abs(RefX - gin.dX) > 0 || abs(RefY - gin.dY) > 0) break;
-        if (gin.button > 0) break;
-        if (sigControlC)
-          return;
+        refstate=gin.state;
+        break;
       }
     }
-    mode = 1;
   }
-
-  if (mode == 0)
+  else if (wait == 3)
   {
-    while (1)
-    {
-      plg->GetCursor(&gin);
-      // TODO: When no Mouse, should be extended later to any key of the keyboard
-      if (gin.keysym == PLK_Escape) break;
-      if (gin.button > 0) break;
-      if (sigControlC)
-        return;
-    }
+    if(plg->GetGin(&gin, 3)==false) return;
   }
-
-  if (debug)
+  else if (wait == 4)
   {
-    // plg->text();
-    cout << "mouse button : " << gin.button << endl;
-    cout << "keysym : " << gin.keysym << endl;
-    //plg->gra();
-    /* if (gin.keysym < 0xFF && isprint(gin.keysym))
-   cout << "wx = " << gin.wX << ", wy = " << gin.wY <<
-   ", dx = " << gin.dX << ",  dy = " << gin.dY <<
-   ",  c = '" << gin.keysym << "'" << endl;
-   plg->gra(); */
+    if(plg->GetGin(&gin, 4)==false) return;
+  }
+  else
+  {
+    if(plg->GetGin(&gin, 1)==false) return;
+  }
+  // outside window report -1 -1 at least for DEVICE values
+  if (gin.pX < 0 || gin.pX > plg->xPageSize() || gin.pY < 0 || gin.pY > plg->yPageSize())
+  {
+    gin.pX = -1;
+    gin.pY = -1;
   }
-
   if (e->KeywordSet("DEVICE"))
   {
-    PLFLT xp, yp;
-    PLINT xleng, yleng, xoff, yoff;
-    plg->gpage(xp, yp, xleng, yleng, xoff, yoff);
-
     DLongGDL* xLong;
     DLongGDL* yLong;
     xLong = new DLongGDL(gin.pX);
-    yLong = new DLongGDL(yleng - gin.pY);
+    yLong = new DLongGDL(gin.pY);
 
     e->SetPar(0, xLong);
     e->SetPar(1, yLong);
@@ -206,8 +234,7 @@
       if (!mapSet)
       {
 #endif
-
-        getWorldCoordinatesFromPLPLOT(plg, (DDouble)gin.dX, (DDouble)gin.dY, &tempx, &tempy);
+        plg->NormToWorld((DDouble)gin.dX, (DDouble)gin.dY, tempx, tempy);
 #ifdef USE_LIBPROJ4
       }
       else
@@ -217,15 +244,15 @@
         XYTYPE idata, idataN;
         idataN.x = gin.dX;
         idataN.y = gin.dY;
-        getWorldCoordinatesFromPLPLOT(plg, idataN.x, idataN.y, &idata.x, &idata.y);
+        plg->NormToWorld(idataN.x, idataN.y, idata.x, idata.y);
         LPTYPE odata = PJ_INV(idata, ref);
         tempx = odata.lam * RAD_TO_DEG;
         tempy = odata.phi * RAD_TO_DEG;
       }
 #endif
       bool xLog, yLog;
-      get_axis_type("X", xLog);
-      get_axis_type("Y", yLog);
+      gdlGetAxisType("X", xLog);
+      gdlGetAxisType("Y", yLog);
       if(xLog) tempx=pow(10,tempx);
       if(yLog) tempy=pow(10,tempy);
       x = new DDoubleGDL(tempx);
@@ -236,6 +263,9 @@
   }
 
   // we update the !Mouse structure (4 fields, only 3 managed up to now)
+  // found on the web:
+  //"Information about which mouse button has been used (if) any is stored in the !err variable. A value of 1 corresponds to the left, 2 to middle and 4 to the right button."
+  //!err is obsolete but still working:
   DStructGDL* Struct = SysVar::Mouse();
   if (Struct != NULL)
   {
@@ -247,6 +277,8 @@
     if (gin.button == 3) gin.button = 4; // 4 values only (0,1,2,4)
     (*static_cast<DLongGDL*>(Struct->GetTag(ButtonMouseTag)))[0] = gin.button;
   }
+  DVar *err=FindInVarList(sysVarList, "ERR");
+  (static_cast<DLongGDL*>(err->Data()))[0]=  gin.button;
 }
 
 } // namespace
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting_device.cpp gdl/src/plotting_device.cpp
--- gdl-0.9.3/src/plotting_device.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting_device.cpp	2013-03-21 14:04:04.436824904 -0600
@@ -1,345 +1,416 @@
-/***************************************************************************
-                       plotting.cpp  -  GDL routines for plotting
-                             -------------------
-    begin                : July 22 2002
-    copyright            : (C) 2002-2011 by Marc Schellens et al.
-    email                : m_schellens@users.sf.net
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "includefirst.hpp"
-#include "plotting.hpp"
-#include <gsl/gsl_const_mksa.h> // GSL_CONST_MKSA_INCH
-
-namespace lib {
-
-  using namespace std;
-
-  void device( EnvT* e)
-  {
-    Graphics* actDevice = Graphics::GetDevice();
-    
-    // GET_SCREEN_SIZE {{{
-    {
-      static int get_screen_sizeIx = e->KeywordIx( "GET_SCREEN_SIZE");
-      if( e->KeywordPresent( get_screen_sizeIx))
-      {
-#ifndef HAVE_X
-        e->Throw("GDL was compiled without support for X-windows");
-#else
-	// see below in Function "get_scren_size()" explanations ...
-	Display* display = XOpenDisplay(NULL);
-	if (display == NULL)
-	  e->Throw("Cannot connect to X server");
-	
-	int screen_num;
-	int screen_width;
-	int screen_height;
-	screen_num = DefaultScreen(display);
-	screen_width = DisplayWidth(display, screen_num);
-	screen_height = DisplayHeight(display, screen_num);
-
-	DIntGDL* res;
-	res = new DIntGDL(2, BaseGDL::NOZERO);
-    
-	(*res)[0]= screen_width;
-	(*res)[1]= screen_height;
-	e->SetKW( get_screen_sizeIx, res);
-#endif
-      }
-    }
-    // }}}
-
-    // WINDOW_STATE kw {{{
-    { 
-      static int window_stateIx = e->KeywordIx( "WINDOW_STATE");
-      if (e->KeywordPresent(window_stateIx))
-      {
-        // check if X (could be more elegant...)
-        DStructGDL* dStruct = SysVar::D();
-        static unsigned nameTag = dStruct->Desc()->TagIndex( "NAME");
-        DString d_name = (*static_cast<DStringGDL*>( dStruct->GetTag( nameTag, 0)))[0];
-        // if PS and not noErase (ie, erase) then set !p.noerase=0    
-        if (d_name != "X") e->Throw("WINDOW_STATE not supported for the current device (" + d_name + "), it works for X only");
-        int maxwin = actDevice->MaxWin();
-        assert(maxwin > 0);
-        DByteGDL* ret = new DByteGDL(dimension( maxwin), BaseGDL::NOZERO);
-        for (int i = 0; i < maxwin; i++) (*ret)[i] = actDevice->WState(i);
-        e->SetKW( window_stateIx, ret);
-      }
-    }
-    // }}}
-
-    // CLOSE_FILE {{{
-    {
-      static int closeFileIx = e->KeywordIx( "CLOSE_FILE"); 
-      if( e->KeywordSet( closeFileIx))
-      {
-        bool success = actDevice->CloseFile();
-        if( !success)
-          e->Throw( "Current device does not support keyword CLOSE_FILE.");
-      }
-    }
-    // }}}
-
-    // Z_BUFFERING {{{
-    {
-      static int z_bufferingIx = e->KeywordIx( "Z_BUFFERING"); 
-      BaseGDL* z_buffering = e->GetKW( z_bufferingIx);
-      if( z_buffering != NULL)
-      {
-        bool success = actDevice->ZBuffering( e->KeywordSet( z_bufferingIx));
-        if( !success)
-          e->Throw( "Current device does not support keyword Z_BUFFERING.");
-      }
-    }
-    // }}}
-
-    // SET_RESOLUTION {{{
-    {
-      static int set_resolutionIx = e->KeywordIx( "SET_RESOLUTION"); 
-      BaseGDL* set_resolution = e->GetKW( set_resolutionIx);
-      if( set_resolution != NULL)
-      {
-        DLongGDL* resolution = e->GetKWAs<DLongGDL>( set_resolutionIx);
-        if( resolution->N_Elements() != 2)
-          e->Throw( "Keyword array parameter SET_RESOLUTION must have 2 elements.");
-        DLong x = (*resolution)[0];
-        DLong y = (*resolution)[1];
-
-        if( x<0 || y<0)
-          e->Throw( "Value of Resolution is out of allowed range.");
-
-        bool success = actDevice->SetResolution( x, y);
-        if( !success)
-          e->Throw( "Current device does not support keyword SET_RESOLUTION.");
-      }
-    }
-    // }}}
-
-    // DECOMPOSED {{{
-    {
-      static int decomposedIx = e->KeywordIx( "DECOMPOSED"); 
-      BaseGDL* decomposed = e->GetKW( decomposedIx);
-      if( decomposed != NULL)
-      {
-        bool success = actDevice->Decomposed( e->KeywordSet( decomposedIx));
-        if( !success)
-          e->Throw( "Current device does not support keyword DECOMPOSED.");
-      }
-    }  
-    // }}}
-
-    // GET_DECOMPOSED {{{
-    {
-      static int get_decomposedIx = e->KeywordIx( "GET_DECOMPOSED"); 
-      if( e->KeywordPresent( get_decomposedIx)) 
-      {
-        DLong value = actDevice->GetDecomposed();
-        if(value == -1)
-	  e->Throw( "Current device does not support keyword GET_DECOMPOSED.");
-        else 
-	  e->SetKW( get_decomposedIx, new DLongGDL( value));
-      }
-    }
-    // }}}
-
-    // GET_VISUAL_DEPTH {{{
-    {
-      static int get_visual_depthIx = e->KeywordIx( "GET_VISUAL_DEPTH");
-      if (e->KeywordPresent( get_visual_depthIx))
-      {
-        {
-          DStructGDL* dStruct = SysVar::D(); 
-          static unsigned nameTag = dStruct->Desc()->TagIndex( "NAME");
-          if ((*static_cast<DStringGDL*>( dStruct->GetTag( nameTag, 0)))[0] != "X")
-            e->Throw("GET_VISUAL_DEPTH is not supported by current device");
-        }
-#ifndef HAVE_X
-        e->Throw("GDL was compiled without support for X-windows");
-#else
-        Display* display = XOpenDisplay(NULL);
-        if (display == NULL) 
-          e->Throw("Cannot connect to X server");
-        int depth = DefaultDepth(display, DefaultScreen(display));
-        XCloseDisplay(display);
-        e->SetKW( get_visual_depthIx, new DLongGDL( depth));
-#endif
-      }
-    }
-    // }}}
-
-    // FILENAME {{{
-    {
-      static int fileNameIx = e->KeywordIx( "FILENAME"); 
-      BaseGDL* fileName = e->GetKW( fileNameIx);
-      if( fileName != NULL)
-      {
-        DString fName;
-        e->AssureStringScalarKW( fileNameIx, fName);
-        if( fName == "")
-	  e->Throw( "Null filename not allowed.");
-	WordExp(fName);
-        bool success = actDevice->SetFileName( fName);
-        if( !success)
-          e->Throw( "Current device does not support keyword FILENAME.");
-      }
-    }
-    // }}}
-
-    // LANDSCAPE and PORTRAIT need to be executed before XSIZE, YSIZE, XOFFSET and YOFFSET!
-    {
-      static int portraitIx = e->KeywordIx( "PORTRAIT");
-      static int landscapeIx = e->KeywordIx( "LANDSCAPE"); 
-      if (e->KeywordSet(portraitIx) && e->KeywordSet(landscapeIx)) 
-        Warning("Warning: both PORTRAIT and LANDSCAPE specified!");
-
-      // LANDSCAPE {{{
-      {
-        if (e->GetKW(landscapeIx) != NULL)
-        {
-          bool success = actDevice->SetLandscape();
-          if (!success) e->Throw("Current device does not support keyword LANDSCAPE");
-        }
-      }
-      // }}}
-
-      // PORTRAIT {{{
-      {
-        if (e->GetKW(portraitIx) != NULL)
-        {
-          bool success = actDevice->SetPortrait();
-          if (!success) e->Throw("Current device does not support keyword PORTRAIT");
-        }
-      }
-      // }}}
-    }
-
-    {
-      static int inchesIx = e->KeywordIx( "INCHES");
-      // XOFFSET {{{
-      {
-        static int xOffsetIx = e->KeywordIx( "XOFFSET");
-        BaseGDL* xOffsetKW = e->GetKW( xOffsetIx);
-        if( xOffsetKW != NULL)
-        {
-          DFloat xOffsetValue;
-          e->AssureFloatScalarKW( xOffsetIx, xOffsetValue);
-          bool success = actDevice->SetXOffset( xOffsetValue 
-            * (e->KeywordPresent(inchesIx) ? 100. * GSL_CONST_MKSA_INCH : 1.)
-          );
-          if( !success)
-            e->Throw( "Current device does not support keyword XOFFSET.");
-        } 
-      }
-      // }}}
-
-      // YOFFSET {{{
-      {
-        static int yOffsetIx = e->KeywordIx( "YOFFSET");
-        BaseGDL* yOffsetKW = e->GetKW( yOffsetIx);
-        if( yOffsetKW != NULL)
-        {
-          DFloat yOffsetValue;
-          e->AssureFloatScalarKW( yOffsetIx, yOffsetValue);
-          bool success = actDevice->SetYOffset( yOffsetValue 
-            * (e->KeywordPresent(inchesIx) ? 100. * GSL_CONST_MKSA_INCH : 1.)
-          );
-          if( !success)
-            e->Throw( "Current device does not support keyword YOFFSET.");
-        } 
-      }
-      // }}}
-
-      // XSIZE {{{
-      {
-        static int xSizeIx = e->KeywordIx( "XSIZE");
-        BaseGDL* xSizeKW = e->GetKW( xSizeIx);
-        if( xSizeKW != NULL)
-        {
-          DFloat xSizeValue;
-          e->AssureFloatScalarKW( xSizeIx, xSizeValue);
-          bool success = actDevice->SetXPageSize( xSizeValue 
-            * (e->KeywordPresent(inchesIx) ? 100. * GSL_CONST_MKSA_INCH : 1.)
-          );
-          if( !success)
-          e->Throw( "Current device does not support keyword XSIZE.");
-        } 
-      }
-      // }}}
-
-      // YSIZE {{{
-      {
-        static int ySizeIx = e->KeywordIx( "YSIZE");
-        BaseGDL* ySizeKW = e->GetKW( ySizeIx);
-        if( ySizeKW != NULL)
-        {
-          DFloat ySizeValue;
-          e->AssureFloatScalarKW( ySizeIx, ySizeValue);
-          bool success = actDevice->SetYPageSize( ySizeValue
-            * (e->KeywordPresent(inchesIx) ? 100. * GSL_CONST_MKSA_INCH : 1.)
-          );
-          if( !success)
-            e->Throw( "Current device does not support keyword YSIZE.");
-        } 
-      }
-      // }}}
-    }
-
-    // SCALE_FACTOR {{{
-    {
-      static int scaleIx = e->KeywordIx( "SCALE_FACTOR");
-      BaseGDL* scaleKW = e->GetKW( scaleIx);
-      if( scaleKW != NULL)
-      {
-        DFloat scaleValue;
-        e->AssureFloatScalarKW( scaleIx, scaleValue);
-        bool success = actDevice->SetScale( scaleValue);
-        if( !success)
-          e->Throw( "Current device does not support keyword SCALE.");
-      } 
-    }
-    // }}}
-
-    // COLOR {{{
-    {
-      // TODO: turn off with COLOR=0?
-      static int colorIx = e->KeywordIx( "COLOR");
-      BaseGDL* colorKW = e->GetKW( colorIx);
-      if( colorKW != NULL)
-      {
-        bool success = actDevice->SetColor();
-        if( !success) e->Throw( "Current device does not support keyword COLOR.");
-      } 
-    }
-    // }}}
-
-    // ENCAPSULATED {{{
-    {
-      static int encapsulatedIx = e->KeywordIx( "ENCAPSULATED");
-      BaseGDL* encapsulatedKW = e->GetKW( encapsulatedIx);
-      if( encapsulatedKW != NULL)
-      {
-        bool success;
-        if ((*e->GetKWAs<DIntGDL>(encapsulatedIx))[0] == 0)
-          success = actDevice->SetEncapsulated(false);
-        else
-          success = actDevice->SetEncapsulated(true);
-        if (!success) e->Throw( "Current device does not support keyword ENCAPSULATED.");
-      } 
-    }
-    // }}}
-
-
-  }
-
-} // namespace
-
+/***************************************************************************
+                       plotting.cpp  -  GDL routines for plotting
+                             -------------------
+    begin                : July 22 2002
+    copyright            : (C) 2002-2011 by Marc Schellens et al.
+    email                : m_schellens@users.sf.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "includefirst.hpp"
+#include "plotting.hpp"
+#include <gsl/gsl_const_mksa.h> // GSL_CONST_MKSA_INCH
+
+namespace lib {
+
+  using namespace std;
+
+  void device( EnvT* e)
+  {
+    Graphics* actDevice = Graphics::GetDevice();
+    
+    // GET_SCREEN_SIZE {{{
+    {
+      static int get_screen_sizeIx = e->KeywordIx( "GET_SCREEN_SIZE");
+      if( e->KeywordPresent( get_screen_sizeIx))
+      {
+#ifndef HAVE_X
+        e->Throw("GDL was compiled without support for X-windows");
+#else
+	// see below in Function "get_scren_size()" explanations ...
+	Display* display = XOpenDisplay(NULL);
+	if (display == NULL)
+	  e->Throw("Cannot connect to X server");
+	
+	int screen_num;
+	int screen_width;
+	int screen_height;
+	screen_num = DefaultScreen(display);
+	screen_width = DisplayWidth(display, screen_num);
+	screen_height = DisplayHeight(display, screen_num);
+
+	DIntGDL* res;
+	res = new DIntGDL(2, BaseGDL::NOZERO);
+    
+	(*res)[0]= screen_width;
+	(*res)[1]= screen_height;
+	e->SetKW( get_screen_sizeIx, res);
+#endif
+      }
+    }
+    // }}}
+
+    // WINDOW_STATE kw {{{
+    { 
+      static int window_stateIx = e->KeywordIx( "WINDOW_STATE");
+      if (e->KeywordPresent(window_stateIx))
+      {
+        // check if X (could be more elegant...)
+        DStructGDL* dStruct = SysVar::D();
+        static unsigned nameTag = dStruct->Desc()->TagIndex( "NAME");
+        DString d_name = (*static_cast<DStringGDL*>( dStruct->GetTag( nameTag, 0)))[0];
+        // if PS and not noErase (ie, erase) then set !p.noerase=0    
+        if (d_name != "X") e->Throw("WINDOW_STATE not supported for the current device (" + d_name + "), it works for X only");
+        int maxwin = actDevice->MaxWin();
+        assert(maxwin > 0);
+        DByteGDL* ret = new DByteGDL(dimension( maxwin), BaseGDL::NOZERO);
+        for (int i = 0; i < maxwin; i++) (*ret)[i] = actDevice->WState(i);
+        e->SetKW( window_stateIx, ret);
+      }
+    }
+    // }}}
+
+    // CLOSE_FILE {{{
+    {
+      static int closeFileIx = e->KeywordIx( "CLOSE_FILE"); 
+      if( e->KeywordSet( closeFileIx))
+      {
+        bool success = actDevice->CloseFile();
+        if( !success)
+          e->Throw( "Current device does not support keyword CLOSE_FILE.");
+      }
+    }
+    // }}}
+
+    // Z_BUFFERING {{{
+    {
+      static int z_bufferingIx = e->KeywordIx( "Z_BUFFERING"); 
+      BaseGDL* z_buffering = e->GetKW( z_bufferingIx);
+      if( z_buffering != NULL)
+      {
+        bool success = actDevice->ZBuffering( e->KeywordSet( z_bufferingIx));
+        if( !success)
+          e->Throw( "Current device does not support keyword Z_BUFFERING.");
+      }
+    }
+    // }}}
+
+    // SET_RESOLUTION {{{
+    {
+      static int set_resolutionIx = e->KeywordIx( "SET_RESOLUTION"); 
+      BaseGDL* set_resolution = e->GetKW( set_resolutionIx);
+      if( set_resolution != NULL)
+      {
+        DLongGDL* resolution = e->GetKWAs<DLongGDL>( set_resolutionIx);
+        if( resolution->N_Elements() != 2)
+          e->Throw( "Keyword array parameter SET_RESOLUTION must have 2 elements.");
+        DLong x = (*resolution)[0];
+        DLong y = (*resolution)[1];
+
+        if( x<0 || y<0)
+          e->Throw( "Value of Resolution is out of allowed range.");
+
+        bool success = actDevice->SetResolution( x, y);
+        if( !success)
+          e->Throw( "Current device does not support keyword SET_RESOLUTION.");
+      }
+    }
+    // }}}
+
+    // DECOMPOSED {{{
+    {
+      static int decomposedIx = e->KeywordIx( "DECOMPOSED"); 
+      BaseGDL* decomposed = e->GetKW( decomposedIx);
+      if( decomposed != NULL)
+      {
+        bool success = actDevice->Decomposed( e->KeywordSet( decomposedIx));
+        if( !success)
+          e->Throw( "Current device does not support keyword DECOMPOSED.");
+      }
+    }  
+    // }}}
+
+    // GET_DECOMPOSED {{{
+    {
+      static int get_decomposedIx = e->KeywordIx( "GET_DECOMPOSED"); 
+      if( e->KeywordPresent( get_decomposedIx)) 
+      {
+        DLong value = actDevice->GetDecomposed();
+        if(value == -1)
+	  e->Throw( "Current device does not support keyword GET_DECOMPOSED.");
+        else 
+	  e->SetKW( get_decomposedIx, new DLongGDL( value));
+      }
+    }
+    // }}}
+    // GET_GRAPHICS_FUNCTION
+    {
+      static int get_graphicsFunctionIx = e->KeywordIx( "GET_GRAPHICS_FUNCTION");
+      if( e->KeywordPresent( get_graphicsFunctionIx)) 
+      {
+        DLong value = actDevice->GetGraphicsFunction();
+        if(value == -1)
+          e->Throw( "Current device does not support keyword GET_GRAPHICS_FUNCTION.");
+        else 
+          e->SetKW( get_graphicsFunctionIx, new DLongGDL( value));
+      }
+    }
+    // SET_GRAPHICS_FUNCTION
+    {
+      static int set_graphicsFunctionIx = e->KeywordIx( "SET_GRAPHICS_FUNCTION");
+      BaseGDL* set_gfunction = e->GetKW( set_graphicsFunctionIx);
+      if( set_gfunction != NULL)
+      {
+        DLongGDL* gfunction = e->GetKWAs<DLongGDL>( set_graphicsFunctionIx);
+        bool success = actDevice->SetGraphicsFunction((*gfunction)[0]);
+        if( !success)
+          e->Throw( "Current device does not support keyword SET_GRAPHICS_FUNCTION.");
+      }
+    }
+    // CURSOR_STANDARD
+    {
+      static int cursorStandardIx = e->KeywordIx( "CURSOR_STANDARD");
+      BaseGDL* res = e->GetKW( cursorStandardIx);
+      if( res != NULL)
+      {
+        DLongGDL* val = e->GetKWAs<DLongGDL>( cursorStandardIx);
+        bool success = actDevice->CursorStandard((*val)[0]);
+        if( !success)
+          e->Throw( "Current device does not support keyword CURSOR_STANDARD.");
+      }
+    }
+    // RETAIN
+    {
+      static int valIx = e->KeywordIx( "RETAIN");
+      BaseGDL* res = e->GetKW( valIx);
+      if( res != NULL)
+      {
+        DLongGDL* val = e->GetKWAs<DLongGDL>( valIx);
+        bool success = actDevice->EnableBackingStore((*val)[0]);
+        if( !success)
+          e->Throw( "Current device does not support keyword RETAIN.");
+      }
+    }
+     // CURSOR_CROSSHAIR
+    {
+      static int valIx = e->KeywordIx( "CURSOR_CROSSHAIR");
+      BaseGDL* res = e->GetKW( valIx);
+      if( res != NULL)
+      {
+        bool success = actDevice->CursorCrosshair();
+        if( !success)
+          e->Throw( "Current device does not support keyword CURSOR_CROSSHAIR.");
+      }
+    }
+    // CURSOR_ORIGINAL (WARNING: SAME CODE AS  CURSOR_CROSSHAIR!)
+    {
+      static int valIx = e->KeywordIx( "CURSOR_ORIGINAL");
+      BaseGDL* res = e->GetKW( valIx);
+      if( res != NULL)
+      {
+        bool success = actDevice->CursorCrosshair();
+        if( !success)
+          e->Throw( "Current device does not support keyword CURSOR_ORIGINAL.");
+      }
+    }
+    // GET_VISUAL_DEPTH {{{
+    {
+      static int get_visual_depthIx = e->KeywordIx( "GET_VISUAL_DEPTH");
+      if (e->KeywordPresent( get_visual_depthIx))
+      {
+        {
+          DStructGDL* dStruct = SysVar::D(); 
+          static unsigned nameTag = dStruct->Desc()->TagIndex( "NAME");
+          if ((*static_cast<DStringGDL*>( dStruct->GetTag( nameTag, 0)))[0] != "X")
+            e->Throw("GET_VISUAL_DEPTH is not supported by current device");
+        }
+#ifndef HAVE_X
+        e->Throw("GDL was compiled without support for X-windows");
+#else
+        Display* display = XOpenDisplay(NULL);
+        if (display == NULL) 
+          e->Throw("Cannot connect to X server");
+        int depth = DefaultDepth(display, DefaultScreen(display));
+        XCloseDisplay(display);
+        e->SetKW( get_visual_depthIx, new DLongGDL( depth));
+#endif
+      }
+    }
+    // }}}
+
+    // FILENAME {{{
+    {
+      static int fileNameIx = e->KeywordIx( "FILENAME"); 
+      BaseGDL* fileName = e->GetKW( fileNameIx);
+      if( fileName != NULL)
+      {
+        DString fName;
+        e->AssureStringScalarKW( fileNameIx, fName);
+        if( fName == "")
+	  e->Throw( "Null filename not allowed.");
+	WordExp(fName);
+        bool success = actDevice->SetFileName( fName);
+        if( !success)
+          e->Throw( "Current device does not support keyword FILENAME.");
+      }
+    }
+    // }}}
+
+    // LANDSCAPE and PORTRAIT need to be executed before XSIZE, YSIZE, XOFFSET and YOFFSET!
+    {
+      static int portraitIx = e->KeywordIx( "PORTRAIT");
+      static int landscapeIx = e->KeywordIx( "LANDSCAPE"); 
+      if (e->KeywordSet(portraitIx) && e->KeywordSet(landscapeIx)) 
+        Warning("Warning: both PORTRAIT and LANDSCAPE specified!");
+
+      // LANDSCAPE {{{
+      {
+        if (e->GetKW(landscapeIx) != NULL)
+        {
+          bool success = actDevice->SetLandscape();
+          if (!success) e->Throw("Current device does not support keyword LANDSCAPE");
+        }
+      }
+      // }}}
+
+      // PORTRAIT {{{
+      {
+        if (e->GetKW(portraitIx) != NULL)
+        {
+          bool success = actDevice->SetPortrait();
+          if (!success) e->Throw("Current device does not support keyword PORTRAIT");
+        }
+      }
+      // }}}
+    }
+
+    {
+      static int inchesIx = e->KeywordIx( "INCHES");
+      // XOFFSET {{{
+      {
+        static int xOffsetIx = e->KeywordIx( "XOFFSET");
+        BaseGDL* xOffsetKW = e->GetKW( xOffsetIx);
+        if( xOffsetKW != NULL)
+        {
+          DFloat xOffsetValue;
+          e->AssureFloatScalarKW( xOffsetIx, xOffsetValue);
+          bool success = actDevice->SetXOffset( xOffsetValue 
+            * (e->KeywordPresent(inchesIx) ? 100. * GSL_CONST_MKSA_INCH : 1.)
+          );
+          if( !success)
+            e->Throw( "Current device does not support keyword XOFFSET.");
+        } 
+      }
+      // }}}
+
+      // YOFFSET {{{
+      {
+        static int yOffsetIx = e->KeywordIx( "YOFFSET");
+        BaseGDL* yOffsetKW = e->GetKW( yOffsetIx);
+        if( yOffsetKW != NULL)
+        {
+          DFloat yOffsetValue;
+          e->AssureFloatScalarKW( yOffsetIx, yOffsetValue);
+          bool success = actDevice->SetYOffset( yOffsetValue 
+            * (e->KeywordPresent(inchesIx) ? 100. * GSL_CONST_MKSA_INCH : 1.)
+          );
+          if( !success)
+            e->Throw( "Current device does not support keyword YOFFSET.");
+        } 
+      }
+      // }}}
+
+      // XSIZE {{{
+      {
+        static int xSizeIx = e->KeywordIx( "XSIZE");
+        BaseGDL* xSizeKW = e->GetKW( xSizeIx);
+        if( xSizeKW != NULL)
+        {
+          DFloat xSizeValue;
+          e->AssureFloatScalarKW( xSizeIx, xSizeValue);
+          bool success = actDevice->SetXPageSize( xSizeValue 
+            * (e->KeywordPresent(inchesIx) ? 100. * GSL_CONST_MKSA_INCH : 1.)
+          );
+          if( !success)
+          e->Throw( "Current device does not support keyword XSIZE.");
+        } 
+      }
+      // }}}
+
+      // YSIZE {{{
+      {
+        static int ySizeIx = e->KeywordIx( "YSIZE");
+        BaseGDL* ySizeKW = e->GetKW( ySizeIx);
+        if( ySizeKW != NULL)
+        {
+          DFloat ySizeValue;
+          e->AssureFloatScalarKW( ySizeIx, ySizeValue);
+          bool success = actDevice->SetYPageSize( ySizeValue
+            * (e->KeywordPresent(inchesIx) ? 100. * GSL_CONST_MKSA_INCH : 1.)
+          );
+          if( !success)
+            e->Throw( "Current device does not support keyword YSIZE.");
+        } 
+      }
+      // }}}
+    }
+
+    // SCALE_FACTOR {{{
+    {
+      static int scaleIx = e->KeywordIx( "SCALE_FACTOR");
+      BaseGDL* scaleKW = e->GetKW( scaleIx);
+      if( scaleKW != NULL)
+      {
+        DFloat scaleValue;
+        e->AssureFloatScalarKW( scaleIx, scaleValue);
+        bool success = actDevice->SetScale( scaleValue);
+        if( !success)
+          e->Throw( "Current device does not support keyword SCALE.");
+      } 
+    }
+    // }}}
+
+    // COLOR {{{
+    {
+      // TODO: turn off with COLOR=0?
+      static int colorIx = e->KeywordIx( "COLOR");
+      BaseGDL* colorKW = e->GetKW( colorIx);
+      if( colorKW != NULL)
+      {
+        DLong colorValue;
+        e->AssureLongScalarKW( colorIx, colorValue);
+        bool success = actDevice->SetColor(colorValue);
+        if( !success) e->Throw( "Current device does not support keyword COLOR.");
+      } 
+    }
+    // }}}
+
+    // ENCAPSULATED {{{
+    {
+      static int encapsulatedIx = e->KeywordIx( "ENCAPSULATED");
+      BaseGDL* encapsulatedKW = e->GetKW( encapsulatedIx);
+      if( encapsulatedKW != NULL)
+      {
+        bool success;
+        if ((*e->GetKWAs<DIntGDL>(encapsulatedIx))[0] == 0)
+          success = actDevice->SetEncapsulated(false);
+        else
+          success = actDevice->SetEncapsulated(true);
+        if (!success) e->Throw( "Current device does not support keyword ENCAPSULATED.");
+      } 
+    }
+    // }}}
+
+
+  }
+
+} // namespace
+
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting_erase.cpp gdl/src/plotting_erase.cpp
--- gdl-0.9.3/src/plotting_erase.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting_erase.cpp	2013-05-16 12:36:33.524856809 -0600
@@ -76,13 +76,8 @@
 	  if (bColor < 0)   bColor = 0;
 	}
 
-      // Get decomposed value
-      Graphics* actDevice = Graphics::GetDevice();
-      DLong decomposed = actDevice->GetDecomposed();
-      if (decomposed != 0 && decomposed != 1) {decomposed=0;}
-
-      actStream->Background( bColor, decomposed);
-      actStream->Clear();      
+    actStream->Background( bColor);
+    actStream->Clear();      
     }
 
     private: virtual void post_call(EnvT*, GDLGStream*) // {{{
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting.hpp gdl/src/plotting.hpp
--- gdl-0.9.3/src/plotting.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting.hpp	2013-05-16 12:36:33.412857211 -0600
@@ -17,11 +17,88 @@
 
 #ifndef PLOTTING_HPP_
 #define PLOTTING_HPP_
+#define gdlPlot_Min(a, b) ((a) < (b) ? (a) : (b))
+#define gdlPlot_Max(a, b) ((a) > (b) ? (a) : (b))
+
+//To debug Affine 3D homogenous projections matrices.
+//IDL define a matrix as  M[ncol,mrow] and print as such. However col_major and
+//row_major refer to the math notation M[row,col] where row=dim(0) and col=dim(1).
+//Matrices are stored COL Major in IDL/Fortran and ROW Major in C,C++ etc.
+//so element at (i,j) is computed as  (j*dim0 + i) for ColMajor/IDL
+//and (i*dim1 + j) for RowMajor/C
+
+#define TRACEMATRIX_C(var__)\
+      {int dim0__=(var__)->Dim(0), dim1__=(var__)->Dim(1);\
+        fprintf(stderr,"c matrix[%d,%d]\n",dim0__,dim1__);\
+        for (int row=0; row < dim0__ ; row++)\
+        {\
+          for (int col=0; col < dim1__-1; col++)\
+          {\
+            fprintf(stderr,"%g, ",(*var__)[row*dim1__ + col]);\
+          }\
+          fprintf(stderr,"%g\n",(*var__)[row*dim1__ + dim1__ -1]);\
+        }\
+        fprintf(stderr,"\n");\
+      }
+//The following abbrevs should output the C matrix as IDL would do (ie,transposed):
+#define TRACEMATRIX_IDL(var__)\
+      {int dim0__=(var__)->Dim(0), dim1__=(var__)->Dim(1);\
+        fprintf(stderr,"idl matrix[%d,%d]\n[",dim0__,dim1__);\
+        for (int col=0; col < dim1__; col++)\
+        {\
+          fprintf(stderr,"[");\
+          for (int row=0; row < dim0__; row++)\
+          {\
+            fprintf(stderr,"%g",(*var__)[row*dim1__ + col]);\
+            if (row<dim0__-1) fprintf(stderr," ,"); \
+            else if (col<dim1__-1) fprintf(stderr," ],$\n"); else fprintf(stderr," ]]\n") ;\
+          }\
+        }\
+      }
 
 #include "envt.hpp"
 #include "graphics.hpp"
 #include "initsysvar.hpp"
 
+  struct GDL_3DTRANSFORMDATA
+  {
+    DDoubleGDL* Matrix;
+    DDouble zValue;
+    int* code;
+    DDouble x0;
+    DDouble xs;
+    DDouble y0;
+    DDouble ys;
+    DDouble z0;
+    DDouble zs;
+    bool xlog;
+    bool ylog;
+    bool zlog;
+  };
+
+  static GDL_3DTRANSFORMDATA Data3d;
+
+  static int code012[3] = {0, 1, 2};
+  static int code102[3] = {1, 0, 2};
+  static int code120[3] = {1, 2, 0};
+  static int code210[3] = {2, 1, 0};
+  static int code201[3] = {2, 0, 1};
+  static int code021[3] = {0, 2, 1};
+
+  enum ORIENTATION3D
+  {
+    NORMAL=0,
+    XY,
+    XZ,
+    YZ,
+    XZYZ,
+    XZXY
+  };
+#define GDL_NONE -1
+#define GDL_TICKFORMAT 0
+#define GDL_TICKUNITS 1
+#define GDL_TICKFORMAT_AND_UNITS 2
+
 namespace lib {
 
   using namespace std;
@@ -31,11 +108,13 @@
   void oplot( EnvT* e);
   void plots( EnvT* e);
   void surface( EnvT* e);
+  void shade_surf( EnvT* e);
   void contour( EnvT* e);
   void xyouts( EnvT* e);
   void axis( EnvT* e);
   void polyfill( EnvT* e);
   void usersym( EnvT* e);
+  void set_shading( EnvT* e);
 
   // other plotting routines
   void erase( EnvT* e);
@@ -48,6 +127,8 @@
   BaseGDL* get_screen_size( EnvT* e);
   void device( EnvT* e);
   void cursor( EnvT* e);
+  void tvcrs( EnvT* e);
+  void empty(EnvT* e);
 
   // Map stuff
   BaseGDL* map_proj_forward_fun( EnvT* e);
@@ -55,7 +136,41 @@
 
   BaseGDL* convert_coord( EnvT* e);
 
+  //3D conversions
+  void SelfTranspose3d(DDoubleGDL* me);
+  void SelfReset3d(DDoubleGDL* me);
+  void SelfTranslate3d(DDoubleGDL* me, DDouble *trans);
+  void SelfScale3d(DDoubleGDL* me, DDouble *scale);
+  void SelfRotate3d(DDoubleGDL* me, DDouble *rot);
+  void SelfPerspective3d(DDoubleGDL* me, DDouble zdist);
+  void SelfOblique3d(DDoubleGDL* me, DDouble dist, DDouble angle);
+  void SelfExch3d(DDoubleGDL* me, DLong code);
+  void gdl3dTo2dTransformContour(PLFLT x, PLFLT y, PLFLT *xt, PLFLT *yt, PLPointer data);
+  void gdl3dTo2dTransform(PLFLT x, PLFLT y, PLFLT *xt, PLFLT *yt, PLPointer data);
+  void gdlProject3dCoordinatesIn2d( DDoubleGDL* Matrix, DDoubleGDL *xVal, DDouble *sx,
+                                    DDoubleGDL *yVal, DDouble *sy, DDoubleGDL* zVal,
+                                    DDouble *sz, DDoubleGDL *xValou, DDoubleGDL *yValou);
+  DDoubleGDL* gdlComputePlplotRotationMatrix(DDouble az, DDouble alt, DDouble zValue, DDouble scale=1.0);
+  DDoubleGDL* gdlConvertT3DMatrixToPlplotRotationMatrix(DDouble zValue, DDouble &az, DDouble &alt, DDouble &ay, DDouble &scale, ORIENTATION3D &code);
+  DDoubleGDL* gdlGetScaledNormalizedT3DMatrix(DDoubleGDL* Matrix=NULL);
+  DDoubleGDL* gdlGetT3DMatrix();
+  void gdlNormed3dToWorld3d(DDoubleGDL *xVal, DDoubleGDL *yVal, DDoubleGDL* zVal,
+                            DDoubleGDL* xValou, DDoubleGDL *yValou, DDoubleGDL *zValou);
+  void gdl3dto2dProjectDDouble(DDoubleGDL* t3dMatrix, DDoubleGDL *xVal, DDoubleGDL *yVal, 
+                               DDoubleGDL* zVal, DDoubleGDL *xValou, DDoubleGDL *yValou, int* code);
+  bool gdlSet3DViewPortAndWorldCoordinates( EnvT* e, GDLGStream* actStream, DDoubleGDL* Matrix,
+  bool xLog, bool yLog, DDouble xStart, DDouble xEnd, DDouble yStart, DDouble yEnd, DDouble zStart=0.0, DDouble zEnd=1.0, bool zLog=false);
+  void scale3_pro(EnvT* e);
+  void t3d_pro( EnvT* e);
+  bool gdlAxis3(EnvT *e, GDLGStream *a, string axis, DDouble Start, DDouble End, bool Log, DLong zAxisCode=0 );
+  bool gdlBox3(EnvT *e, GDLGStream *a, DDouble xStart, DDouble xEnd, DDouble yStart, DDouble yEnd,
+        DDouble zStart, DDouble zEnd, bool xLog, bool yLog, bool zLog,bool doSpecialAxisPlacement=0);
+
   //helper functions / classes
+  inline void logifyGDLDouble(DDoubleGDL* x)
+  {
+    for (SizeT i=0; i<x->N_Elements(); ++i) (*x)[i]=log10((*x)[i]);
+  }
 
   class plotting_routine_call
   {
@@ -93,71 +208,87 @@
       post_call(e, actStream);
     } // }}}
   };
-
+  template <typename T>
+  void gdlDoRangeExtrema(T* xVal, T* yVal, DDouble &min, DDouble &max, DDouble xmin, DDouble xmax, bool doMinMax=FALSE, DDouble minVal=0, DDouble maxVal=0);
   template <typename T> 
   bool draw_polyline(EnvT *e,  GDLGStream *a, T * xVal, T* yVal, 
              DDouble minVal, DDouble maxVal, bool doMinMax,
 		     bool xLog, bool yLog, 
-		     DLong psym=0, bool append=FALSE);
-  
-  void gkw_axis_margin(EnvT *e, string axis,DFloat &start, DFloat &end);
-
+		     DLong psym=0, bool append=FALSE, DLongGDL *color=NULL);
+  DDouble gdlEpsDouble();
+  DDouble gdlAbsoluteMinValueDouble();
+  DDouble gdlAbsoluteMaxValueDouble();
+  //protect from (inverted, strange) axis log values
+  void gdlHandleUnwantedAxisValue(DDouble &min, DDouble &max, bool log);
   //set the background color
-  void gkw_background(EnvT * e, GDLGStream * a,bool kw=true);
+  void gdlSetGraphicsBackgroundColorFromKw(EnvT * e, GDLGStream * a,bool kw=true);
+  //set The background color as foreground ()
+  void gdlSetGraphicsPenColorToBackground(GDLGStream *a);
   //set the foreground color
-  void gkw_color(EnvT * e, GDLGStream * a);
-  //set the noerase flag
-  void gkw_noerase(EnvT * e, GDLGStream * a,bool noe=0);
+  void gdlSetGraphicsForegroundColorFromKw(EnvT * e, GDLGStream * a, string otherColorKw="");
+  //advance to next plot unless the noerase flag is set
+  void gdlNextPlotHandlingNoEraseOption(EnvT * e, GDLGStream * a,bool noe=0);
   //set the symbol shape
-  void gkw_psym(EnvT *e, DLong &psym);
+  void gdlGetPsym(EnvT *e, DLong &psym);
   //set the symbol size
-  void gkw_symsize(EnvT * e, GDLGStream * a);
-  //set the character size, special version authorizing 'SIZE' keyword
-  void gkw_charsize_xyouts(EnvT * e, GDLGStream * a, DFloat& charsize);
-  //set the character size
-  void gkw_charsize(EnvT * e, GDLGStream * a, DFloat& charsize, bool kw=true);
+  void gdlSetSymsize(EnvT * e, GDLGStream * a);
+  //set the PLOT character size (including MULTI subscaling)
+  void gdlSetPlotCharsize(EnvT *e, GDLGStream *a, bool accept_sizeKw=false);
+  //set the PLOT Char Thickness
+  void gdlSetPlotCharthick(EnvT *e, GDLGStream *a);
   //set the line thickness
-  void gkw_thick(EnvT * e, GDLGStream * a);
+  void gdlSetPenThickness(EnvT * e, GDLGStream * a);
   //set the linestyle
-  void gkw_linestyle(EnvT * e, GDLGStream * a);
+  void gdlLineStyle(GDLGStream *a, DLong style);
+  void gdlSetLineStyle(EnvT * e, GDLGStream * a);
+  //set axis linewidth
+  void gdlSetAxisThickness(EnvT *e, GDLGStream *a, string axis);
   //title
-  void gkw_title(EnvT* e, GDLGStream *a, PLFLT ad);
+  void gdlWriteTitleAndSubtitle(EnvT* e, GDLGStream *a);
   //set the !axis.crange vector
-  void set_axis_crange(string axis, DDouble Start, DDouble End, bool log);
-  //get the !axis.crange vector
-  void get_axis_crange(string axis, DDouble &Start, DDouble &End);
-  void get_axis_margin(string axis, DFloat &low, DFloat &high);
-  //axis_type
-  void get_axis_type(string axis, bool &log);
-  void set_axis_type(string axis, bool type);
+  void gdlStoreAxisCRANGE(string axis, DDouble Start, DDouble End, bool log);
+  //set the !axis.s vector
+  void gdlStoreAxisSandWINDOW(GDLGStream* actStream, string axis, DDouble Start, DDouble End, bool log=false);
 
   // mapset
   void get_mapset(bool &mapset);
   void set_mapset(bool mapset);
 
-  void gkw_axis_charsize(EnvT* e, string axis, DFloat &charsize);
-
-  void gkw_axis_style(EnvT *e, string axis,DLong &style);
-  void gkw_axis_title(EnvT *e, string axis,DString &title);
-  void gkw_axis_range(EnvT *e, string axis,
-		      DDouble &start, DDouble &end, DLong & ynozero);
-
-  void mesh_nr(PLFLT *, PLFLT *, PLFLT **, PLINT, PLINT, PLINT);
-
-  void GetSFromPlotStructs(DDouble **sx, DDouble **sy);
+  //axis_type
+  void gdlGetAxisType(string axis, bool &log);
+  //get the !axis.crange vector
+  void gdlGetCurrentAxisRange(string axis, DDouble &Start, DDouble &End);
+  void gdlGetDesiredAxisMargin(EnvT *e, string axis,DFloat &start, DFloat &end);
+  void gdlGetDesiredAxisCharsize(EnvT* e, string axis, DFloat &charsize);
+  void gdlGetDesiredAxisStyle(EnvT *e, string axis,DLong &style);
+  void gdlGetDesiredAxisTitle(EnvT *e, string axis,DString &title);
+  bool gdlGetDesiredAxisRange(EnvT *e, string axis,
+		      DDouble &start, DDouble &end);
+  //set the axis 'axis' charsize (including MULTI subscaling)
+  void gdlSetAxisCharsize(EnvT *e, GDLGStream *a, string axis);
+  void gdlStoreAxisType(string axis, bool type);
+
+  //length and height of a char in normalized coords, using trick
+  void gdlGetCharSizes(GDLGStream *a, PLFLT &nsx, PLFLT &nsy, DDouble &wsx, DDouble &wsy, DDouble &dsx, DDouble &dsy, DDouble &lsx, DDouble &lsy);
+  void GetSFromPlotStructs(DDouble **sx, DDouble **sy, DDouble **sz=NULL);
   void GetWFromPlotStructs(DFloat **wx, DFloat **wy);
-  void getWorldCoordinatesFromPLPLOT(GDLGStream *a, DDouble nx, DDouble ny, DDouble *wx, DDouble *wy);
+  bool startClipping(EnvT *e, GDLGStream *a, bool UsePClip);
+  void stopClipping(GDLGStream *a);
+  void gdlStoreCLIP(DLongGDL* clipBox);
   void DataCoordLimits(DDouble *sx, DDouble *sy, DFloat *wx, DFloat *wy, 
     DDouble *xStart, DDouble *xEnd, DDouble *yStart, DDouble *yEnd, bool);
 
-  PLFLT AutoIntvAC(DDouble &val_min, DDouble &val_max, DLong NoZero, bool log = false);
+  PLFLT AutoIntvAC(DDouble &val_min, DDouble &val_max, bool log = false);
   PLFLT AutoTick(DDouble x);
+  PLFLT gdlComputeTickInterval(EnvT *e, string axis, DDouble &min, DDouble &max, bool log);
+  bool gdlYaxisNoZero(EnvT* e);
   void AdjustAxisOpts(string& xOpt, string& yOpt,
     DLong xStyle, DLong yStyle, DLong xTicks, DLong yTicks,
     string& xTickformat, string& yTickformat, DLong xLog, DLong yLog);
-  bool SetVP_WC( EnvT* e, GDLGStream* actStream, DFloatGDL* pos, DDoubleGDL* clippingD, bool xLog, bool yLog,
-                 DFloat xMarginL, DFloat xMarginR, DFloat yMarginB, DFloat yMarginT, // input/output
+  bool gdlSetViewPortAndWorldCoordinates( EnvT* e, GDLGStream* actStream, DFloatGDL* boxPosition, bool xLog, bool yLog,
+                 DFloat xMarginL, DFloat xMarginR, DFloat yMarginB, DFloat yMarginT,
                  DDouble xStart, DDouble xEnd, DDouble minVal, DDouble maxVal, DLong iso);
+;
   void GetMinMaxVal( DDoubleGDL* val, double* minVal, double* maxVal);
   void GetAxisData( DStructGDL* xStruct,
                     DLong& style, DString& title, DFloat& charSize,
@@ -168,13 +299,14 @@
                  DLong& p_linestyle,
                  DFloat& p_symsize, DFloat& p_charsize, DFloat& p_thick,
                  DString& p_title, DString& p_subTitle, DFloat& p_ticklen);
+  void GetPData2 (pstruct& p);
     void CheckMargin( EnvT* e, GDLGStream* actStream,
                     DFloat xMarginL, DFloat xMarginR, DFloat yMarginB, DFloat yMarginT,
                     PLFLT& xMR, PLFLT& xML, PLFLT& yMB, PLFLT& yMT);
-    void Clipping( DDoubleGDL* clippingD, 
-                 DDouble& xStart, DDouble& xEnd, DDouble& minVal, DDouble& maxVal);
     void handle_pmulti_position(EnvT *e, GDLGStream *a);
     void UpdateSWPlotStructs(GDLGStream* actStream, DDouble xStart, DDouble xEnd, DDouble yStart, DDouble yEnd, bool xLog, bool yLog);
+    bool gdlAxis(EnvT *e, GDLGStream *a, string axis, DDouble Start, DDouble End, bool Log, DLong modifierCode=0);
+    bool gdlBox(EnvT *e, GDLGStream *a, DDouble xStart, DDouble xEnd, DDouble yStart, DDouble yEnd, bool xLog, bool yLog);
 
 } // namespace
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting_map_proj.cpp gdl/src/plotting_map_proj.cpp
--- gdl-0.9.3/src/plotting_map_proj.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting_map_proj.cpp	2013-02-25 17:04:31.011154955 -0700
@@ -19,26 +19,27 @@
 #include "plotting.hpp"
 #include "math_utl.hpp"
 
-namespace lib {
+namespace lib
+{
 
   using namespace std;
 
-
-  BaseGDL* map_proj_forward_fun( EnvT* e)
+  BaseGDL* map_proj_forward_fun(EnvT* e)
   {
 #ifdef USE_LIBPROJ4
     // lonlat -> xy
 
     SizeT nParam=e->NParam();
-    if( nParam < 1)
-      e->Throw( "Incorrect number of arguments.");
+    if ( nParam<1 )
+      e->Throw("Incorrect number of arguments.");
 
     LPTYPE idata;
     XYTYPE odata;
 
-    ref = map_init();
-    if ( ref == NULL) {
-      e->Throw( "Projection initialization failed.");
+    ref=map_init();
+    if ( ref==NULL )
+    {
+      e->Throw("Projection initialization failed.");
     }
 
     BaseGDL* p0;
@@ -50,56 +51,67 @@
     DDoubleGDL* res;
     DLong dims[2];
 
-    if ( nParam == 1) {
-      p0 = e->GetParDefined( 0);
-      DDoubleGDL* ll = static_cast<DDoubleGDL*>
-	(p0->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-
-      dims[0] = 2;
-      if (p0->Rank() == 1) {
-	dimension dim((DLong *) dims, 1);
-	res = new DDoubleGDL( dim, BaseGDL::NOZERO);
-      } else {
-	dims[1] = p0->Dim(1);
-	dimension dim((DLong *) dims, 2);
-	res = new DDoubleGDL( dim, BaseGDL::NOZERO);
-      }
-
-      SizeT nEl = p0->N_Elements();
-      for( SizeT i=0; i<nEl/2; ++i) {
-	idata.lam = (*ll)[2*i]   * DEG_TO_RAD;
-	idata.phi = (*ll)[2*i+1] * DEG_TO_RAD;
-	odata = PJ_FWD(idata, ref);
-	(*res)[2*i]   = odata.x;
-	(*res)[2*i+1] = odata.y;
+    if ( nParam==1 )
+    {
+      p0=e->GetParDefined(0);
+      DDoubleGDL* ll=static_cast<DDoubleGDL*>
+      (p0->Convert2(GDL_DOUBLE, BaseGDL::COPY));
+
+      dims[0]=2;
+      if ( p0->Rank()==1 )
+      {
+        dimension dim((DLong *)dims, 1);
+        res=new DDoubleGDL(dim, BaseGDL::NOZERO);
+      }
+      else
+      {
+        dims[1]=p0->Dim(1);
+        dimension dim((DLong *)dims, 2);
+        res=new DDoubleGDL(dim, BaseGDL::NOZERO);
+      }
+
+      SizeT nEl=p0->N_Elements();
+      for ( SizeT i=0; i<nEl/2; ++i )
+      {
+        idata.lam=(*ll)[2*i]*DEG_TO_RAD;
+        idata.phi=(*ll)[2*i+1]*DEG_TO_RAD;
+        odata=PJ_FWD(idata, ref);
+        (*res)[2*i]=odata.x;
+        (*res)[2*i+1]=odata.y;
       }
       return res;
 
-    } else if ( nParam == 2) {
-      p0 = e->GetParDefined( 0);
-      p1 = e->GetParDefined( 1);
-      DDoubleGDL* lon = static_cast<DDoubleGDL*>
-	(p0->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-      DDoubleGDL* lat = static_cast<DDoubleGDL*>
-	(p1->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-
-      dims[0] = 2;
-      if (p0->Rank() == 0 || p0->Rank() == 1) {
-	dimension dim((DLong *) dims, 1);
-	res = new DDoubleGDL( dim, BaseGDL::NOZERO);
-      } else {
-	dims[1] = p0->Dim(0);
-	dimension dim((DLong *) dims, 2);
-	res = new DDoubleGDL( dim, BaseGDL::NOZERO);
-      }
-
-      SizeT nEl = p0->N_Elements();
-      for( SizeT i=0; i<nEl; ++i) {
-	idata.lam = (*lon)[i] * DEG_TO_RAD;
-	idata.phi = (*lat)[i] * DEG_TO_RAD;
-	odata = PJ_FWD(idata, ref);
-	(*res)[2*i]   = odata.x;
-	(*res)[2*i+1] = odata.y;
+    }
+    else if ( nParam==2 )
+    {
+      p0=e->GetParDefined(0);
+      p1=e->GetParDefined(1);
+      DDoubleGDL* lon=static_cast<DDoubleGDL*>
+      (p0->Convert2(GDL_DOUBLE, BaseGDL::COPY));
+      DDoubleGDL* lat=static_cast<DDoubleGDL*>
+      (p1->Convert2(GDL_DOUBLE, BaseGDL::COPY));
+
+      dims[0]=2;
+      if ( p0->Rank()==0||p0->Rank()==1 )
+      {
+        dimension dim((DLong *)dims, 1);
+        res=new DDoubleGDL(dim, BaseGDL::NOZERO);
+      }
+      else
+      {
+        dims[1]=p0->Dim(0);
+        dimension dim((DLong *)dims, 2);
+        res=new DDoubleGDL(dim, BaseGDL::NOZERO);
+      }
+
+      SizeT nEl=p0->N_Elements();
+      for ( SizeT i=0; i<nEl; ++i )
+      {
+        idata.lam=(*lon)[i]*DEG_TO_RAD;
+        idata.phi=(*lat)[i]*DEG_TO_RAD;
+        odata=PJ_FWD(idata, ref);
+        (*res)[2*i]=odata.x;
+        (*res)[2*i+1]=odata.y;
       }
       return res;
     }
@@ -109,21 +121,21 @@
 #endif
   }
 
-
-  BaseGDL* map_proj_inverse_fun( EnvT* e)
+  BaseGDL* map_proj_inverse_fun(EnvT* e)
   {
 #ifdef USE_LIBPROJ4
     // xy -> lonlat
     SizeT nParam=e->NParam();
-    if( nParam < 1)
-      e->Throw( "Incorrect number of arguments.");
+    if ( nParam<1 )
+      e->Throw("Incorrect number of arguments.");
 
     XYTYPE idata;
     LPTYPE odata;
 
-    ref = map_init();
-    if ( ref == NULL) {
-      e->Throw( "Projection initialization failed.");
+    ref=map_init();
+    if ( ref==NULL )
+    {
+      e->Throw("Projection initialization failed.");
     }
 
     BaseGDL* p0;
@@ -135,56 +147,67 @@
     DDoubleGDL* res;
     DLong dims[2];
 
-    if ( nParam == 1) {
-      p0 = e->GetParDefined( 0);
-      DDoubleGDL* xy = static_cast<DDoubleGDL*>
-	(p0->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-
-      dims[0] = 2;
-      if (p0->Rank() == 1) {
-	dimension dim((DLong *) dims, 1);
-	res = new DDoubleGDL( dim, BaseGDL::NOZERO);
-      } else {
-	dims[1] = p0->Dim(1);
-	dimension dim((DLong *) dims, 2);
-	res = new DDoubleGDL( dim, BaseGDL::NOZERO);
-      }
-
-      SizeT nEl = p0->N_Elements();
-      for( SizeT i=0; i<nEl/2; ++i) {
-	idata.x = (*xy)[2*i];
-	idata.y = (*xy)[2*i+1];
-	odata = PJ_INV(idata, ref);
-	(*res)[2*i]   = odata.lam * RAD_TO_DEG;
-	(*res)[2*i+1] = odata.phi * RAD_TO_DEG;
+    if ( nParam==1 )
+    {
+      p0=e->GetParDefined(0);
+      DDoubleGDL* xy=static_cast<DDoubleGDL*>
+      (p0->Convert2(GDL_DOUBLE, BaseGDL::COPY));
+
+      dims[0]=2;
+      if ( p0->Rank()==1 )
+      {
+        dimension dim((DLong *)dims, 1);
+        res=new DDoubleGDL(dim, BaseGDL::NOZERO);
+      }
+      else
+      {
+        dims[1]=p0->Dim(1);
+        dimension dim((DLong *)dims, 2);
+        res=new DDoubleGDL(dim, BaseGDL::NOZERO);
+      }
+
+      SizeT nEl=p0->N_Elements();
+      for ( SizeT i=0; i<nEl/2; ++i )
+      {
+        idata.x=(*xy)[2*i];
+        idata.y=(*xy)[2*i+1];
+        odata=PJ_INV(idata, ref);
+        (*res)[2*i]=odata.lam * RAD_TO_DEG;
+        (*res)[2*i+1]=odata.phi * RAD_TO_DEG;
       }
       return res;
 
-    } else if ( nParam == 2) {
-      p0 = e->GetParDefined( 0);
-      p1 = e->GetParDefined( 1);
-      DDoubleGDL* x = static_cast<DDoubleGDL*>
-	(p0->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-      DDoubleGDL* y = static_cast<DDoubleGDL*>
-	(p1->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-
-      dims[0] = 2;
-      if (p0->Rank() == 0 || p0->Rank() == 1) {
-	dimension dim((DLong *) dims, 1);
-	res = new DDoubleGDL( dim, BaseGDL::NOZERO);
-      } else {
-	dims[1] = p0->Dim(0);
-	dimension dim((DLong *) dims, 2);
-	res = new DDoubleGDL( dim, BaseGDL::NOZERO);
-      }
-
-      SizeT nEl = p0->N_Elements();
-      for( SizeT i=0; i<nEl; ++i) {
-	idata.x = (*x)[i];
-	idata.y = (*y)[i];
-	odata = PJ_INV(idata, ref);
-	(*res)[2*i]   = odata.lam * RAD_TO_DEG;
-	(*res)[2*i+1] = odata.phi * RAD_TO_DEG;
+    }
+    else if ( nParam==2 )
+    {
+      p0=e->GetParDefined(0);
+      p1=e->GetParDefined(1);
+      DDoubleGDL* x=static_cast<DDoubleGDL*>
+      (p0->Convert2(GDL_DOUBLE, BaseGDL::COPY));
+      DDoubleGDL* y=static_cast<DDoubleGDL*>
+      (p1->Convert2(GDL_DOUBLE, BaseGDL::COPY));
+
+      dims[0]=2;
+      if ( p0->Rank()==0||p0->Rank()==1 )
+      {
+        dimension dim((DLong *)dims, 1);
+        res=new DDoubleGDL(dim, BaseGDL::NOZERO);
+      }
+      else
+      {
+        dims[1]=p0->Dim(0);
+        dimension dim((DLong *)dims, 2);
+        res=new DDoubleGDL(dim, BaseGDL::NOZERO);
+      }
+
+      SizeT nEl=p0->N_Elements();
+      for ( SizeT i=0; i<nEl; ++i )
+      {
+        idata.x=(*x)[i];
+        idata.y=(*y)[i];
+        odata=PJ_INV(idata, ref);
+        (*res)[2*i]=odata.lam * RAD_TO_DEG;
+        (*res)[2*i+1]=odata.phi * RAD_TO_DEG;
       }
       return res;
     }
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting_misc.cpp gdl/src/plotting_misc.cpp
--- gdl-0.9.3/src/plotting_misc.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting_misc.cpp	2013-05-16 12:36:33.526856802 -0600
@@ -18,198 +18,213 @@
 #include "includefirst.hpp"
 #include "plotting.hpp"
 
-namespace lib {
+namespace lib
+{
 
   using namespace std;
 
-  void set_plot( EnvT* e) // modifies !D system variable
+  void set_plot(EnvT* e) // modifies !D system variable
   {
     SizeT nParam=e->NParam();
-    if( nParam < 1)
-      e->Throw( "Incorrect number of arguments.");
+    if ( nParam<1 )
+      e->Throw("Incorrect number of arguments.");
     DString device;
-    e->AssureScalarPar<DStringGDL>( 0, device);
+    e->AssureScalarPar<DStringGDL>(0, device);
 
     // this is the device name
-    device = StrUpCase( device);
-    
-    bool success = Graphics::SetDevice( device);
-    if( !success)
-      e->Throw( "Device not supported/unknown: "+device);
+    device=StrUpCase(device);
 
-    if (device == "PS" || device == "SVG") {
-      static DStructGDL* pStruct = SysVar::P();
+    bool success=Graphics::SetDevice(device);
+    if ( !success )
+      e->Throw("Device not supported/unknown: "+device);
+
+    if ( device=="PS"/*||device=="SVG"*/ )
+    {
+      static DStructGDL* pStruct=SysVar::P();
       // SA: this does not comply with IDL behaviour, see testsuite/test_pmulti.pro
       //static unsigned noEraseTag = pStruct->Desc()->TagIndex( "NOERASE");
       //(*static_cast<DLongGDL*>( pStruct->GetTag( noEraseTag, 0)))[0] = 1;
-      if (device == "PS") {
-	static unsigned colorTag = pStruct->Desc()->TagIndex( "COLOR");
-	(*static_cast<DLongGDL*>( pStruct->GetTag( colorTag, 0)))[0] = 0;
-      }
-    } else {
-      static DStructGDL* pStruct = SysVar::P();
-      static unsigned colorTag = pStruct->Desc()->TagIndex( "COLOR");
-      (*static_cast<DLongGDL*>( pStruct->GetTag( colorTag, 0)))[0] = 255;
+      if ( device=="PS" )
+      {
+        static unsigned colorTag=pStruct->Desc()->TagIndex("COLOR");
+        (*static_cast<DLongGDL*>(pStruct->GetTag(colorTag, 0)))[0]=255; //PLEASE DO NOT CHANGE values here until a better color
+                                                                        // handling has been found.
+         static unsigned bckTag=pStruct->Desc()->TagIndex("BACKGROUND");
+        (*static_cast<DLongGDL*>(pStruct->GetTag(bckTag, 0)))[0]=0; //PLEASE DO NOT CHANGE values here. This default is OK.
+      }
+    }
+    else
+    {
+      static DStructGDL* pStruct=SysVar::P();
+      static unsigned colorTag=pStruct->Desc()->TagIndex("COLOR");
+      (*static_cast<DLongGDL*>(pStruct->GetTag(colorTag, 0)))[0]=16777215;
+        static unsigned bckTag=pStruct->Desc()->TagIndex("BACKGROUND");
+      (*static_cast<DLongGDL*>(pStruct->GetTag(bckTag, 0)))[0]=0;
     }
   }
 
-  void tvlct( EnvT* e)
+  void tvlct(EnvT* e)
   {
-    int nParam = e->NParam( 1); //, "TVLCT");
+    int nParam=e->NParam(1); //, "TVLCT");
+
+    static int getKW=e->KeywordIx("GET");
+    bool get=e->KeywordSet(getKW);
+    static int hlsKW=e->KeywordIx("HLS");
+    bool hls=e->KeywordSet(hlsKW);
+    static int hsvKW=e->KeywordIx("HSV");
+    bool hsv=e->KeywordSet(hsvKW);
+
+    DLong start=0;
+    GDLCT* actCT=Graphics::GetCT();
+    if ( nParam<=2 ) // TVLCT,I[,Start]
+    {
+      if ( nParam==2 )
+        e->AssureLongScalarPar(1, start);
+      if ( start<0 ) start=0;
+
+      if ( get ) // always RGB
+      {
+        BaseGDL*& p0=e->GetParGlobal(0);
+
+        SizeT nCol=ctSize-start;
+
+        DByteGDL* rgb=new DByteGDL(dimension(nCol, 3), BaseGDL::NOZERO);
+
+        for ( SizeT i=start, ii=0; i<ctSize; ++i, ++ii )
+          actCT->Get(i, (*rgb)[ ii], (*rgb)[ ii+nCol], (*rgb)[ ii+2*nCol]);
 
-    static int getKW = e->KeywordIx( "GET");
-    bool get = e->KeywordSet( getKW);
-    static int hlsKW = e->KeywordIx( "HLS");
-    bool hls = e->KeywordSet( hlsKW);
-    static int hsvKW = e->KeywordIx( "HSV");
-    bool hsv = e->KeywordSet( hsvKW);
-
-    DLong start = 0;
-    GDLCT* actCT = Graphics::GetCT();
-    if( nParam <= 2) // TVLCT,I[,Start]
-      {
-	if( nParam == 2)
-	  e->AssureLongScalarPar( 1, start);
-	if( start < 0) start = 0;
-
- 	if( get) // always RGB
-	  {
-	    BaseGDL*& p0 = e->GetParGlobal( 0);
-
-	    SizeT nCol = ctSize - start;
-
-	    DByteGDL* rgb = new DByteGDL( dimension( nCol, 3), BaseGDL::NOZERO);
-
-	    for( SizeT i=start,ii=0; i<ctSize; ++i,++ii)
-	      actCT->Get( i, (*rgb)[ ii], (*rgb)[ ii+nCol], (*rgb)[ ii+2*nCol]);
-
-	    GDLDelete(p0);
-	    p0 = rgb;
-	  }
-	else
-	  {
-	    if( hls || hsv)
-	      {
-		DFloatGDL* rgb = e->GetParAs< DFloatGDL>( 0);
-		if( rgb->Dim( 1) != 3)
-		  e->Throw( "Array must have dimensions of (1, 3): "+
-			    e->GetParString( 0));
-
-		SizeT nCol = rgb->Dim( 0);
-		SizeT setCol = nCol + start;
-		if( setCol > ctSize) setCol = ctSize;
-
-		if( hls)
-		  for( SizeT i=start, ii=0; i<setCol; ++i,++ii)
-		    actCT->SetHLS( i, 
-				   (*rgb)[ ii], 
-				   (*rgb)[ ii+nCol],
-				   (*rgb)[ ii+2*nCol]);
-		else
-		  for( SizeT i=start, ii=0; i<setCol; ++i,++ii)
-		    actCT->SetHSV( i, 
-				   (*rgb)[ ii], 
-				   (*rgb)[ ii+nCol],
-				   (*rgb)[ ii+2*nCol]);
-	      }
-	    else
-	      {
-		DByteGDL* rgb = e->GetParAs< DByteGDL>( 0);
-		if( rgb->Dim( 1) != 3)
-		  e->Throw( "Array must have dimensions of (1, 3): "+
-			    e->GetParString( 0));
-
-		SizeT nCol = rgb->Dim( 0);
-		SizeT setCol = nCol + start;
-		if( setCol > ctSize) setCol = ctSize;
-
-		for( SizeT i=start, ii=0; i<setCol; ++i,++ii)
-		  actCT->Set( i, 
-			      (*rgb)[ ii], 
-			      (*rgb)[ ii+nCol],
-			      (*rgb)[ ii+2*nCol]);
-	      }
-	  }
+        GDLDelete(p0);
+        p0=rgb;
       }
+      else
+      {
+        if ( hls||hsv )
+        {
+          DFloatGDL* rgb=e->GetParAs< DFloatGDL>(0);
+          if ( rgb->Dim(1)!=3 )
+            e->Throw("Array must have dimensions of (1, 3): "+
+                     e->GetParString(0));
+
+          SizeT nCol=rgb->Dim(0);
+          SizeT setCol=nCol+start;
+          if ( setCol>ctSize ) setCol=ctSize;
+
+          if ( hls )
+            for ( SizeT i=start, ii=0; i<setCol; ++i, ++ii )
+              actCT->SetHLS(i,
+                            (*rgb)[ ii],
+                            (*rgb)[ ii+nCol],
+                            (*rgb)[ ii+2*nCol]);
+          else
+            for ( SizeT i=start, ii=0; i<setCol; ++i, ++ii )
+              actCT->SetHSV(i,
+                            (*rgb)[ ii],
+                            (*rgb)[ ii+nCol],
+                            (*rgb)[ ii+2*nCol]);
+        }
+        else
+        {
+          DByteGDL* rgb=e->GetParAs< DByteGDL>(0);
+          if ( rgb->Dim(1)!=3 )
+            e->Throw("Array must have dimensions of (1, 3): "+
+                     e->GetParString(0));
+
+          SizeT nCol=rgb->Dim(0);
+          SizeT setCol=nCol+start;
+          if ( setCol>ctSize ) setCol=ctSize;
+
+          for ( SizeT i=start, ii=0; i<setCol; ++i, ++ii )
+            actCT->Set(i,
+                       (*rgb)[ ii],
+                       (*rgb)[ ii+nCol],
+                       (*rgb)[ ii+2*nCol]);
+        }
+      }
+    }
     else // TVLCT,I1,I2,I3[,Start]
+    {
+      if ( nParam==4 )
+        e->AssureLongScalarPar(3, start);
+      if ( start<0 ) start=0;
+
+      if ( get ) // always RGB
       {
-	if( nParam == 4)
-	  e->AssureLongScalarPar( 3, start);
-	if( start < 0) start = 0;
-
- 	if( get) // always RGB
-	  {
-	    BaseGDL*& p0 = e->GetParGlobal( 0);
-	    BaseGDL*& p1 = e->GetParGlobal( 1);
-	    BaseGDL*& p2 = e->GetParGlobal( 2);
-
-	    SizeT nCol = ctSize - start;
-
-	    DByteGDL* r = new DByteGDL( dimension( nCol), BaseGDL::NOZERO);
-	    DByteGDL* g = new DByteGDL( dimension( nCol), BaseGDL::NOZERO);
-	    DByteGDL* b = new DByteGDL( dimension( nCol), BaseGDL::NOZERO);
-
-	    for( SizeT i=start,ii=0; i<ctSize; ++i,++ii)
-	      actCT->Get( i, (*r)[ ii], (*g)[ ii], (*b)[ ii]);
-
-	    GDLDelete(p0); p0 = r;
-	    GDLDelete(p1); p1 = g;
-	    GDLDelete(p2); p2 = b;
-	  }
-	else
-	  {
-	    if( hls || hsv)
-	      {
-		DFloatGDL* r = e->GetParAs< DFloatGDL>( 0);
-		DFloatGDL* g = e->GetParAs< DFloatGDL>( 1);
-		DFloatGDL* b = e->GetParAs< DFloatGDL>( 2);
-		SizeT rCol = r->N_Elements();
-		SizeT gCol = g->N_Elements();
-		SizeT bCol = b->N_Elements();
-		SizeT nCol = rCol;
-		if( gCol < nCol) nCol = gCol;
-		if( bCol < nCol) nCol = bCol;
-	
-		SizeT setCol = nCol + start;
-		if( setCol > ctSize) setCol = ctSize;
-
-		if( hls)
-		  for( SizeT i=start, ii=0; i<setCol; ++i,++ii)
-		    actCT->SetHLS( i, (*r)[ ii], (*g)[ ii], (*b)[ ii]);
-		else
-		  for( SizeT i=start, ii=0; i<setCol; ++i,++ii)
-		    actCT->SetHSV( i, (*r)[ ii], (*g)[ ii], (*b)[ ii]);
-	      }
-	    else
-	      {
-		DByteGDL* r = e->GetParAs< DByteGDL>( 0);
-		DByteGDL* g = e->GetParAs< DByteGDL>( 1);
-		DByteGDL* b = e->GetParAs< DByteGDL>( 2);
-		SizeT rCol = r->N_Elements();
-		SizeT gCol = g->N_Elements();
-		SizeT bCol = b->N_Elements();
-		SizeT nCol = rCol;
-		if( gCol < nCol) nCol = gCol;
-		if( bCol < nCol) nCol = bCol;
-	
-		SizeT setCol = nCol + start;
-		if( setCol > ctSize) setCol = ctSize;
-
-		for( SizeT i=start, ii=0; i<setCol; ++i,++ii)
-		  actCT->Set( i, (*r)[ ii], (*g)[ ii], (*b)[ ii]);
-	      }
-	  }
+        BaseGDL*& p0=e->GetParGlobal(0);
+        BaseGDL*& p1=e->GetParGlobal(1);
+        BaseGDL*& p2=e->GetParGlobal(2);
+
+        SizeT nCol=ctSize-start;
+
+        DByteGDL* r=new DByteGDL(dimension(nCol), BaseGDL::NOZERO);
+        DByteGDL* g=new DByteGDL(dimension(nCol), BaseGDL::NOZERO);
+        DByteGDL* b=new DByteGDL(dimension(nCol), BaseGDL::NOZERO);
+
+        for ( SizeT i=start, ii=0; i<ctSize; ++i, ++ii )
+          actCT->Get(i, (*r)[ ii], (*g)[ ii], (*b)[ ii]);
+
+        GDLDelete(p0);
+        p0=r;
+        GDLDelete(p1);
+        p1=g;
+        GDLDelete(p2);
+        p2=b;
       }
+      else
+      {
+        if ( hls||hsv )
+        {
+          DFloatGDL* r=e->GetParAs< DFloatGDL>(0);
+          DFloatGDL* g=e->GetParAs< DFloatGDL>(1);
+          DFloatGDL* b=e->GetParAs< DFloatGDL>(2);
+          SizeT rCol=r->N_Elements();
+          SizeT gCol=g->N_Elements();
+          SizeT bCol=b->N_Elements();
+          SizeT nCol=rCol;
+          if ( gCol<nCol ) nCol=gCol;
+          if ( bCol<nCol ) nCol=bCol;
+
+          SizeT setCol=nCol+start;
+          if ( setCol>ctSize ) setCol=ctSize;
+
+          if ( hls )
+            for ( SizeT i=start, ii=0; i<setCol; ++i, ++ii )
+              actCT->SetHLS(i, (*r)[ ii], (*g)[ ii], (*b)[ ii]);
+          else
+            for ( SizeT i=start, ii=0; i<setCol; ++i, ++ii )
+              actCT->SetHSV(i, (*r)[ ii], (*g)[ ii], (*b)[ ii]);
+        }
+        else
+        {
+          DByteGDL* r=e->GetParAs< DByteGDL>(0);
+          DByteGDL* g=e->GetParAs< DByteGDL>(1);
+          DByteGDL* b=e->GetParAs< DByteGDL>(2);
+          SizeT rCol=r->N_Elements();
+          SizeT gCol=g->N_Elements();
+          SizeT bCol=b->N_Elements();
+          SizeT nCol=rCol;
+          if ( gCol<nCol ) nCol=gCol;
+          if ( bCol<nCol ) nCol=bCol;
+
+          SizeT setCol=nCol+start;
+          if ( setCol>ctSize ) setCol=ctSize;
+
+          for ( SizeT i=start, ii=0; i<setCol; ++i, ++ii )
+            actCT->Set(i, (*r)[ ii], (*g)[ ii], (*b)[ ii]);
+        }
+      }
+    }
 
     // AC, 07/02/2012, please report any unexpected side effect (see test_tvlct.pro)
-    if (~get) {
-      GDLGStream* actStream = Graphics::GetDevice()->GetStream(false);
-      if (actStream != NULL) {
-	PLINT red[ctSize], green[ctSize], blue[ctSize];
-	actCT->Get( red, green, blue);
-	actStream->scmap1( red, green, blue, ctSize); 
+    if ( ~get )
+    {
+      GDLGStream* actStream=Graphics::GetDevice()->GetStream(false);
+      if ( actStream!=NULL )
+      {
+        PLINT red[ctSize], green[ctSize], blue[ctSize];
+        actCT->Get(red, green, blue);
+        actStream->scmap1(red, green, blue, ctSize);
       }
     }
   }
-  
+
 } // namespace
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting_oplot.cpp gdl/src/plotting_oplot.cpp
--- gdl-0.9.3/src/plotting_oplot.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting_oplot.cpp	2013-05-16 12:36:33.527856798 -0600
@@ -24,23 +24,31 @@
 
   class oplot_call : public plotting_routine_call 
   {
-    DDoubleGDL *yVal, *xVal, *xTemp, *yTemp;
-    SizeT xEl, yEl;
-    auto_ptr<BaseGDL> xval_guard,yval_guard,xtempval_guard;
+    DDoubleGDL *yVal, *xVal, *zVal, *xTemp, *yTemp;
+    SizeT xEl, yEl, zEl;
+    Guard<BaseGDL> xval_guard,yval_guard, zval_guard, xtempval_guard;
+    bool doT3d;
+    DDouble zValue;
 
     private: bool handle_args( EnvT* e) // {{{
     {
+      //T3D?
+      static int t3dIx = e->KeywordIx( "T3D");
+      doT3d=e->KeywordSet(t3dIx);
+
+      //note: Z (VALUE) will be used uniquely if Z is not effectively defined.
+      zValue=0.0;
+      static int zvIx = e->KeywordIx( "ZVALUE");
+      e->AssureDoubleScalarKWIfPresent ( zvIx, zValue );
+
       bool polar=FALSE;
       DLong nsum=1;
       e->AssureLongScalarKWIfPresent( "NSUM", nsum);
       if ( e->KeywordSet( "POLAR"))
       {
         polar=TRUE;
-       // e->Throw( "Sorry, POLAR keyword not ready");
       }
 
-      DDoubleGDL *yValBis, *xValBis;
-      auto_ptr<BaseGDL> xvalBis_guard, yvalBis_guard;
       //test and transform eventually if POLAR and/or NSUM!
       if( nParam() == 1)
       {
@@ -50,7 +58,7 @@
         yEl=yTemp->N_Elements();
         xEl=yEl;
         xTemp = new DDoubleGDL( dimension( xEl), BaseGDL::INDGEN);
-        xtempval_guard.reset( xTemp); // delete upon exit
+        xtempval_guard.Reset( xTemp); // delete upon exit
       }
       else
       {
@@ -80,15 +88,15 @@
         if (polar)
         {
           xVal = new DDoubleGDL(dimension(xEl), BaseGDL::NOZERO);
-          xval_guard.reset(xVal); // delete upon exit
+          xval_guard.Reset(xVal); // delete upon exit
           yVal = new DDoubleGDL(dimension(yEl), BaseGDL::NOZERO);
-          yval_guard.reset(yVal); // delete upon exit
+          yval_guard.Reset(yVal); // delete upon exit
           for (int i = 0; i < xEl; i++) (*xVal)[i] = (*xTemp)[i] * cos((*yTemp)[i]);
           for (int i = 0; i < yEl; i++) (*yVal)[i] = (*xTemp)[i] * sin((*yTemp)[i]);
         }
         else
         { //careful about previously set autopointers!
-          if (nParam() == 1) xval_guard = xtempval_guard;
+          if (nParam() == 1) xval_guard.Init( xtempval_guard.release());
           xVal = xTemp;
           yVal = yTemp;
         }
@@ -98,9 +106,9 @@
         int i, j, k;
         DLong size = xEl / nsum;
         xVal = new DDoubleGDL(size, BaseGDL::ZERO); //SHOULD BE ZERO, IS NOT!
-        xval_guard.reset(xVal); // delete upon exit
+        xval_guard.Reset(xVal); // delete upon exit
         yVal = new DDoubleGDL(size, BaseGDL::ZERO); //IDEM
-        yval_guard.reset(yVal); // delete upon exit
+        yval_guard.Reset(yVal); // delete upon exit
         for (i = 0, k = 0; i < size; i++)
         {
           (*xVal)[i] = 0.0;
@@ -126,25 +134,32 @@
           }
         }
       }
+      if (doT3d)
+      {
+        //make zVal
+        zEl=xVal->N_Elements();
+        zVal=new DDoubleGDL(dimension(zEl), BaseGDL::NOZERO);
+        zval_guard.Reset(zVal); // delete upon exit
+        for (SizeT i=0; i< zEl ; ++i) (*zVal)[i]=zValue;
+      }
+	  return 0;
     }
 
-  private: void old_body( EnvT* e, GDLGStream* actStream) // {{{
+  private: void old_body( EnvT* e, GDLGStream* actStream) 
   {
-    bool valid;
-    valid=true;
     DLong psym;
 
     // get ![XY].CRANGE
     DDouble xStart, xEnd, yStart, yEnd;
-    get_axis_crange("X", xStart, xEnd);
-    get_axis_crange("Y", yStart, yEnd);
+    gdlGetCurrentAxisRange("X", xStart, xEnd);
+    gdlGetCurrentAxisRange("Y", yStart, yEnd);
     DDouble minVal, maxVal;
     bool doMinMax;
 
     bool xLog;
     bool yLog;
-    get_axis_type("X", xLog);
-    get_axis_type("Y", yLog);
+    gdlGetAxisType("X", xLog);
+    gdlGetAxisType("Y", yLog);
 
     if ((yStart == yEnd) || (xStart == xEnd))
     {
@@ -157,9 +172,6 @@
         Message("OPLOT: !X.CRANGE ERROR, setting to [0,1]");
       xStart = 0; //xVal->min();
       xEnd = 1; //xVal->max();
-
-      set_axis_crange("X", xStart, xEnd, xLog);
-      set_axis_crange("Y", yStart, yEnd, yLog);
     }
     
     //now we can setup minVal and maxVal to defaults: Start-End and overload if KW present
@@ -172,45 +184,104 @@
     e->AssureDoubleScalarKWIfPresent( "MIN_VALUE", minVal);
     e->AssureDoubleScalarKWIfPresent( "MAX_VALUE", maxVal);
 
-    // CLIPPING
-    DDoubleGDL* clippingD=NULL;
-    DLong noclip=0;
-    e->AssureLongScalarKWIfPresent( "NOCLIP", noclip);
-    if(noclip == 0)
+    int noclipvalue=0;
+    e->AssureLongScalarKWIfPresent( "NOCLIP", noclipvalue);
+    // Clipping is enabled by default for OPLOT.
+    // make all clipping computations BEFORE setting graphic properties (color, size)
+    bool doClip=(e->KeywordSet("CLIP")||noclipvalue==1);
+    bool stopClip=false;
+    if ( doClip )  if ( startClipping(e, actStream, false)==TRUE ) stopClip=true;
+
+    // start drawing. Graphic Keywords accepted:CLIP(YES), COLOR(YES), LINESTYLE(YES), NOCLIP(YES),
+    //                                          PSYM(YES), SYMSIZE(YES), T3D(YES), ZVALUE(YES)
+    gdlSetGraphicsForegroundColorFromKw(e, actStream);
+    gdlGetPsym(e, psym);
+    gdlSetPenThickness(e, actStream);
+    gdlSetSymsize(e, actStream);
+    gdlSetLineStyle(e, actStream);
+
+    static DDouble x0,y0,xs,ys; //conversion to normalized coords
+    x0=(xLog)?-log10(xStart):-xStart;
+    y0=(yLog)?-log10(yStart):-yStart;
+    xs=(xLog)?(log10(xEnd)-log10(xStart)):xEnd-xStart;xs=1.0/xs;
+    ys=(yLog)?(log10(yEnd)-log10(yStart)):yEnd-yStart;ys=1.0/ys;
+
+    if ( doT3d ) //convert X,Y,Z in X',Y' as per T3D perspective.
+    {
+      DDoubleGDL* plplot3d;
+      DDouble az, alt, ay, scale;
+      ORIENTATION3D axisExchangeCode;
+
+      plplot3d = gdlConvertT3DMatrixToPlplotRotationMatrix( zValue, az, alt, ay, scale, axisExchangeCode);
+      if (plplot3d == NULL)
       {
-	static int clippingix = e->KeywordIx( "CLIP"); 
-	clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
+        e->Throw("Illegal 3D transformation. (FIXME)");
       }
-    
-    // start drawing. Graphic Keywords accepted:CLIP(NO), COLOR(YES), LINESTYLE(YES), NOCLIP(YES),
-    //                                          PSYM(YES), SYMSIZE(YES), T3D(NO), ZVALUE(NO)
-    gkw_background(e, actStream, false);
-    gkw_color(e, actStream);
-    //    gkw_noerase(e, actStream, true);
-    gkw_psym(e, psym);
-    DFloat charsize;
-    gkw_charsize(e,actStream, charsize, false); //set !P.CHARSIZE
-    gkw_thick(e, actStream);
-    gkw_symsize(e, actStream);
-    gkw_linestyle(e, actStream);
-
-    // plot the data
-    if(valid) //invalid is not yet possible. Could be done by a severe clipping for example.
-      valid=draw_polyline(e, actStream, 
-			  xVal, yVal, minVal, maxVal, doMinMax, xLog, yLog,
-			  psym, FALSE);
+      Data3d.zValue = zValue;
+      Data3d.Matrix = plplot3d; //try to change for !P.T in future?
+        switch (axisExchangeCode) {
+          case NORMAL: //X->X Y->Y plane XY
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code012;
+            break;
+          case XY: // X->Y Y->X plane XY
+            Data3d.x0=0;
+            Data3d.y0=x0;
+            Data3d.xs=ys;
+            Data3d.ys=xs;
+            Data3d.code = code102;
+            break;
+          case XZ: // Y->Y X->Z plane YZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code210;
+            break;
+          case YZ: // X->X Y->Z plane XZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code021;
+            break;
+          case XZXY: //X->Y Y->Z plane YZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code120;
+            break;
+          case XZYZ: //X->Z Y->X plane XZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code201;
+            break;
+        }
 
+        actStream->stransform(gdl3dTo2dTransform, &Data3d);
+    }
 
-    actStream->lsty(1);//reset linestyle
-  } // }}}
+      // TODO: handle "valid"!
+    bool valid=draw_polyline(e, actStream, xVal, yVal, minVal, maxVal, doMinMax, xLog, yLog, psym, FALSE);
+    if (stopClip) stopClipping(actStream);
+  } 
 
-    private: void call_plplot(EnvT* e, GDLGStream* actStream) // {{{
+    private: void call_plplot(EnvT* e, GDLGStream* actStream) 
     {
-    } // }}}
+    } 
 
-    private: void post_call(EnvT* e, GDLGStream* actStream) // {{{
+    private: void post_call(EnvT* e, GDLGStream* actStream)
     {
-    } // }}}
+     if (doT3d) actStream->stransform(NULL,NULL);
+      actStream->lsty(1);//reset linestyle
+      actStream->sizeChar(1.0);
+    } 
 
   }; // oplot_call class 
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting_plot.cpp gdl/src/plotting_plot.cpp
--- gdl-0.9.3/src/plotting_plot.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting_plot.cpp	2013-05-16 12:36:33.534856773 -0600
@@ -25,32 +25,47 @@
 namespace lib {
 
   using namespace std;
+//  using std::isinf;
+  using std::isnan;
 
   class plot_call : public plotting_routine_call 
   {
-    DDoubleGDL *yVal, *xVal, *xTemp, *yTemp;
-    SizeT xEl, yEl;
-    DDouble minVal, maxVal, xStart, xEnd, yStart, yEnd;
+    DDoubleGDL *yVal, *xVal, *zVal, *xTemp, *yTemp;
+    SizeT xEl, yEl, zEl;
+    DDouble minVal, maxVal, xStart, xEnd, yStart, yEnd,
+            zValue;
     bool doMinMax;
     bool xLog, yLog, wasBadxLog, wasBadyLog;
-    DLong psym;
-    auto_ptr<BaseGDL> xval_guard,yval_guard,xtemp_guard;
+    Guard<BaseGDL> xval_guard, yval_guard, zval_guard, xtemp_guard;
+    DLong iso;
+    bool doT3d;
 
 private:
 
-  bool handle_args(EnvT* e) // {{{
+  bool handle_args(EnvT* e) 
   {
+
+    //T3D ?
+    static int t3dIx = e->KeywordIx( "T3D");
+    doT3d=e->KeywordSet(t3dIx);
+
+    //note: Z (VALUE) will be used uniquely if Z is not effectively defined.
+    static int zvIx = e->KeywordIx( "ZVALUE");
+    zValue=0.0;
+    e->AssureDoubleScalarKWIfPresent ( zvIx, zValue );
+    zValue=min(zValue,0.999999); //to avoid problems with plplot
+    zValue=max(zValue,0.0);
+
     bool polar = FALSE;
     DLong nsum = 1;
     e->AssureLongScalarKWIfPresent("NSUM", nsum);
     if (e->KeywordSet("POLAR"))
     {
       polar = TRUE;
-      // e->Throw( "Sorry, POLAR keyword not ready");
     }
 
     DDoubleGDL *yValBis, *xValBis;
-    auto_ptr<BaseGDL> xvalBis_guard, yvalBis_guard;
+    Guard<BaseGDL> xvalBis_guard, yvalBis_guard;
     //test and transform eventually if POLAR and/or NSUM!
     if (nParam() == 1)
     {
@@ -60,7 +75,7 @@
       yEl=yTemp->N_Elements();
       xEl=yEl;
       xTemp = new DDoubleGDL(dimension(xEl), BaseGDL::INDGEN);
-      xtemp_guard.reset(xTemp); // delete upon exit
+      xtemp_guard.Reset(xTemp); // delete upon exit
     }
     else
     {
@@ -90,15 +105,15 @@
       if (polar)
       {
         xVal = new DDoubleGDL(dimension(xEl), BaseGDL::NOZERO);
-        xval_guard.reset(xVal); // delete upon exit
+        xval_guard.Reset(xVal); // delete upon exit
         yVal = new DDoubleGDL(dimension(yEl), BaseGDL::NOZERO);
-        yval_guard.reset(yVal); // delete upon exit
+        yval_guard.Reset(yVal); // delete upon exit
         for (int i = 0; i < xEl; i++) (*xVal)[i] = (*xTemp)[i] * cos((*yTemp)[i]);
         for (int i = 0; i < yEl; i++) (*yVal)[i] = (*xTemp)[i] * sin((*yTemp)[i]);
       }
       else
       { //careful about previously set autopointers!
-        if (nParam() == 1) xval_guard = xtemp_guard;
+        if (nParam() == 1) xval_guard.Init( xtemp_guard.release());
         xVal = xTemp;
         yVal = yTemp;
       }
@@ -108,9 +123,9 @@
       int i, j, k;
       DLong size = (DLong)xEl / nsum;
       xVal = new DDoubleGDL(size, BaseGDL::ZERO); //SHOULD BE ZERO, IS NOT!
-      xval_guard.reset(xVal); // delete upon exit
+      xval_guard.Reset(xVal); // delete upon exit
       yVal = new DDoubleGDL(size, BaseGDL::ZERO); //IDEM
-      yval_guard.reset(yVal); // delete upon exit
+      yval_guard.Reset(yVal); // delete upon exit
       for (i = 0, k = 0; i < size; i++)
       {
         (*xVal)[i] = 0.0;
@@ -136,9 +151,9 @@
         }
       }
     }
-    // keyword overrides
-    static int xLogIx = e->KeywordIx("XLOG");
-    static int yLogIx = e->KeywordIx("YLOG");
+    // handle Log options
+    int xLogIx = e->KeywordIx("XLOG");
+    int yLogIx = e->KeywordIx("YLOG");
     xLog = e->KeywordSet(xLogIx);
     yLog = e->KeywordSet(yLogIx);
     // compute adequate values for log scale, warn adequately...
@@ -150,7 +165,7 @@
       xVal->MinMax(&minEl, &maxEl, NULL, NULL, true);
       if ((*xVal)[minEl] <= 0.0) wasBadxLog = TRUE;
       xValBis = new DDoubleGDL(dimension(xEl), BaseGDL::NOZERO);
-      xvalBis_guard.reset(xValBis); // delete upon exit
+      xvalBis_guard.Reset(xValBis); // delete upon exit
       for (int i = 0; i < xEl; i++) (*xValBis)[i] = log10((*xVal)[i]);
     }
     else xValBis = xVal;
@@ -160,279 +175,325 @@
       yVal->MinMax(&minEl, &maxEl, NULL, NULL, true);
       if ((*yVal)[minEl] <= 0.0) wasBadyLog = TRUE;
       yValBis = new DDoubleGDL(dimension(yEl), BaseGDL::NOZERO);
-      yvalBis_guard.reset(yValBis); // delete upon exit
+      yvalBis_guard.Reset(yValBis); // delete upon exit
       for (int i = 0; i < yEl; i++) (*yValBis)[i] = log10((*yVal)[i]);
     }
     else yValBis = yVal;
-    //   BaseGDL *x, *y;
-    {
-      DLong minEl, maxEl, debug=0;
 
+#define UNDEF_RANGE_VALUE 1E-12
+    {
+      DLong minEl, maxEl;
       xValBis->MinMax(&minEl, &maxEl, NULL, NULL, true);
       xStart = (*xVal)[minEl];
-      if (isnan(xStart)) xStart = 1e-12;
-      if (wasBadxLog) xStart = 1e-12;
       xEnd = (*xVal)[maxEl];
+      if (isnan(xStart)) xStart = UNDEF_RANGE_VALUE;
       if (isnan(xEnd)) xEnd = 1.0;
-     if (wasBadxLog) {
-	xStart = 1e-20;
-	xEnd = 1.;
-      }
-
-      if (debug) cout << "X Min/Max : " << xStart << " " << xEnd << endl;
-      if (debug) cout << "xLog mode : " << xLog << endl;
+      if (xStart==xEnd) xStart=xEnd-UNDEF_RANGE_VALUE;
 
       yValBis->MinMax(&minEl, &maxEl, NULL, NULL, true);
       yStart = (*yVal)[minEl];
-      if (wasBadyLog) yStart = 1e-12;
-      if (isnan(yStart)) yStart = 1e-12;
       yEnd = (*yVal)[maxEl];
+      if (isnan(yStart)) yStart = UNDEF_RANGE_VALUE;
       if (isnan(yEnd)) yEnd = 1.0;
-      if (wasBadyLog) {
-	yStart = 1e-20;
-	yEnd = 1.;
+      if (yStart==yEnd) yStart=yEnd-UNDEF_RANGE_VALUE;
+    }
+    //MIN_VALUE and MAX_VALUE overwrite yStart/yEnd eventually (note: the points will not be "seen" at all in plots)
+    minVal = yStart; //to give a reasonable value...
+    maxVal = yEnd;   //idem
+    doMinMax = false; //although we will not use it...
+    if( e->KeywordSet( "MIN_VALUE") || e->KeywordSet( "MAX_VALUE"))
+      doMinMax = true; //...unless explicitely required
+    e->AssureDoubleScalarKWIfPresent( "MIN_VALUE", minVal);
+    e->AssureDoubleScalarKWIfPresent( "MAX_VALUE", maxVal);
+    yStart=gdlPlot_Max(yStart,minVal);
+    yEnd=gdlPlot_Min(yEnd,maxVal);
+    //XRANGE and YRANGE overrides all that, but  Start/End should be recomputed accordingly
+    DDouble xAxisStart, xAxisEnd, yAxisStart, yAxisEnd;
+    bool setx=gdlGetDesiredAxisRange(e, "X", xAxisStart, xAxisEnd);
+    bool sety=gdlGetDesiredAxisRange(e, "Y", yAxisStart, yAxisEnd);
+    if(setx && sety)
+    {
+      xStart=xAxisStart;
+      xEnd=xAxisEnd;
+      yStart=yAxisStart;
+      yEnd=yAxisEnd;
+    }
+    else if (sety)
+    {
+      yStart=yAxisStart;
+      yEnd=yAxisEnd;
+      //must compute min-max for other axis!
+      {
+        gdlDoRangeExtrema(yVal,xVal,xStart,xEnd,yStart,yEnd);
       }
+    }
+    else if (setx)
+    {
+      xStart=xAxisStart;
+      xEnd=xAxisEnd;
+      //must compute min-max for other axis!
+      {
+        gdlDoRangeExtrema(xVal,yVal,yStart,yEnd,xStart,xEnd,doMinMax,minVal,maxVal);
+      }
+    }
+    //handle Nozero option after all that!
+    if(!gdlYaxisNoZero(e) && yStart >0 && !yLog ) yStart=0.0;
+#undef UNDEF_RANGE_VALUE
 
+     //ISOTROPIC
+    iso=0;
+    e->AssureLongScalarKWIfPresent( "ISOTROPIC", iso);
 
-      if (debug) cout << "Y Min/Max : " << yStart << " " << yEnd << endl;
-      if (debug) cout << "yLog mode : " << yLog << endl;
-
+    if (doT3d)
+    {
+      //make zVal
+      zEl=xVal->N_Elements();
+      zVal=new DDoubleGDL(dimension(zEl), BaseGDL::NOZERO);
+      zval_guard.Reset(zVal); // delete upon exit
+      for (SizeT i=0; i< zEl ; ++i) (*zVal)[i]=zValue;
     }
+
     return false;
-  } // }}}
+  }
 
-  private: void old_body( EnvT* e, GDLGStream* actStream) // {{{
+  private: void old_body( EnvT* e, GDLGStream* actStream) 
   {
-    //ISOTROPIC
-    DLong iso=0;
-    e->AssureLongScalarKWIfPresent( "ISOTROPIC", iso);
+    // background BEFORE next plot since it is the only place plplot may redraw the background...
+    gdlSetGraphicsBackgroundColorFromKw(e, actStream);
+   //start a plot
+    gdlNextPlotHandlingNoEraseOption(e, actStream);     //NOERASE
 
-    // [XY]STYLE
-    DLong xStyle=0, yStyle=0; 
-    gkw_axis_style(e, "X", xStyle);
-    gkw_axis_style(e, "Y", yStyle);
-
-    e->AssureLongScalarKWIfPresent( "XSTYLE", xStyle);
-    e->AssureLongScalarKWIfPresent( "YSTYLE", yStyle);
-
-    // AXIS TITLE
-    DString xTitle, yTitle; 
-    gkw_axis_title(e, "X", xTitle);
-    gkw_axis_title(e, "Y", yTitle);
 
-    // MARGIN
-    DFloat xMarginL, xMarginR, yMarginB, yMarginT; 
-    gkw_axis_margin(e, "X", xMarginL, xMarginR);
-    gkw_axis_margin(e, "Y", yMarginB, yMarginT);
-
-    DLong xnozero=1, ynozero=0;
-    if ( e->KeywordSet( "YNOZERO")) ynozero = 1;
-
-    // Please remember the {X|Y}range overwrite the data range
-    //[x|y]range keyword
-    gkw_axis_range(e, "X", xStart, xEnd, xnozero);
-    gkw_axis_range(e, "Y", yStart, yEnd, ynozero);
-
-    if ((xLog && xStart <= 0.0) || wasBadxLog) Warning( "PLOT: Infinite x plot range.");
-    if ((yLog && yStart <= 0.0) || wasBadyLog) Warning( "PLOT: Infinite y plot range.");
-    //xStyle and yStyle apply on range values
+    // [XY]STYLE
+    DLong xStyle=0, yStyle=0;
+    gdlGetDesiredAxisStyle(e, "X", xStyle);
+    gdlGetDesiredAxisStyle(e, "Y", yStyle);
 
-//    // style applies on the final values
+     //xStyle and yStyle apply on range values
     if ((xStyle & 1) != 1) {
-      PLFLT intv = AutoIntvAC(xStart, xEnd, xnozero, xLog);
+      PLFLT intv = AutoIntvAC(xStart, xEnd, xLog);
     }
     if ((yStyle & 1) != 1) {
-      PLFLT intv = AutoIntvAC(yStart, yEnd, ynozero, yLog);
+      PLFLT intv = AutoIntvAC(yStart, yEnd, yLog);
     }
 
-    DLong xTicks=0, yTicks=0;
-    e->AssureLongScalarKWIfPresent( "XTICKS", xTicks);
-    e->AssureLongScalarKWIfPresent( "YTICKS", yTicks);
-
-    DLong xMinor=0, yMinor=0; 
-    e->AssureLongScalarKWIfPresent( "XMINOR", xMinor);
-    e->AssureLongScalarKWIfPresent( "YMINOR", yMinor);
-
-    DString xTickformat, yTickformat;
-    e->AssureStringScalarKWIfPresent( "XTICKFORMAT", xTickformat);
-    e->AssureStringScalarKWIfPresent( "YTICKFORMAT", yTickformat);
-
-    DDouble ticklen = 0.02;
-    e->AssureDoubleScalarKWIfPresent( "TICKLEN", ticklen);
-
-    DFloat xTicklen, yTicklen;
-    e->AssureFloatScalarKWIfPresent( "XTICKLEN", xTicklen);
-    e->AssureFloatScalarKWIfPresent( "YTICKLEN", yTicklen);
-    // plsmin (def, scale);
-
-    // POSITION
-    static int positionIx = e->KeywordIx( "POSITION"); 
-    DFloatGDL* pos = e->IfDefGetKWAs<DFloatGDL>( positionIx);
-    if (pos == NULL) pos = (DFloatGDL*) 0xF;
-
-    // *** start drawing. Graphic Keywords accepted: BACKGROUND, CHARSIZE, CHARTHICK, CLIP, COLOR, DATA, DEVICE, FONT, LINESTYLE, NOCLIP, NODATA, NOERASE, NORMAL, POSITION, PSYM, SUBTITLE, SYMSIZE, T3D, THICK, TICKLEN, TITLE, [XYZ]CHARSIZE, [XYZ]GRIDSTYLE, [XYZ]MARGIN(OK), [XYZ]MINOR, [XYZ]RANGE, [XYZ]STYLE, [XYZ]THICK, [XYZ]TICKFORMAT, [XYZ]TICKINTERVAL, [XYZ]TICKLAYOUT, [XYZ]TICKLEN, [XYZ]TICKNAME, [XYZ]TICKS, [XYZ]TICKUNITS, [XYZ]TICKV, [XYZ]TICK_GET, [XYZ]TITLE, ZVALUE
-    gkw_background(e, actStream);  //BACKGROUND
-    gkw_color(e, actStream);       //COLOR
-
-    gkw_psym(e, psym);//PSYM
-
-    DFloat charsize, xCharSize, yCharSize;
-    gkw_charsize(e, actStream, charsize);  //CHARSIZE
-    gkw_axis_charsize(e, "X", xCharSize);   //XCHARSIZE
-    gkw_axis_charsize(e, "Y", yCharSize);   //YCHARSIZE
-
-    // Turn off map projection processing
-    set_mapset(0);
-
-    gkw_noerase(e, actStream);     //NOERASE
-
-    DLong noErase = 0;
-    if( e->KeywordSet( "NOERASE")) noErase = 1;
-    if( !noErase) actStream->Clear();
-
-    // Get device name
-    DStructGDL* dStruct = SysVar::D();
-    static unsigned nameTag = dStruct->Desc()->TagIndex( "NAME");
-    DString d_name = 
-      (*static_cast<DStringGDL*>( dStruct->GetTag( nameTag, 0)))[0];
-    // if PS and not noErase (ie, erase) then set !p.noerase=0    
-    if ((d_name == "PS" || d_name == "SVG") && !noErase) {
-      static DStructGDL* pStruct = SysVar::P();
-      static unsigned noEraseTag = pStruct->Desc()->TagIndex( "NOERASE");
-      (*static_cast<DLongGDL*>( pStruct->GetTag( noEraseTag, 0)))[0] = 0;
-    }
-
-    // plplot stuff
-    // set the charsize (scale factor)
-    DDouble charScale = 1.0;
-    DLongGDL* pMulti = SysVar::GetPMulti();
-    if( (*pMulti)[1] > 2 || (*pMulti)[2] > 2) charScale = 0.5;
-    actStream->schr( 0.0, charsize * charScale);
-
-    // get char size in mm (default, actual)
-    PLFLT defH, actH;
-    actStream->gchr( defH, actH);
-
-    // CLIPPING
-    DDoubleGDL* clippingD=NULL;
-    DLong noclip=0;
-    e->AssureLongScalarKWIfPresent( "NOCLIP", noclip);
-    if(noclip == 0)
-    {
-      static int clippingix = e->KeywordIx( "CLIP"); 
-      clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
-    }
-    
+    // MARGIN
+    DFloat xMarginL, xMarginR, yMarginB, yMarginT;
+    gdlGetDesiredAxisMargin(e, "X", xMarginL, xMarginR);
+    gdlGetDesiredAxisMargin(e, "Y", yMarginB, yMarginT);
+
     // viewport and world coordinates
-    bool okVPWC = SetVP_WC( e, actStream, pos, clippingD, 
-			    xLog, yLog,
-			    xMarginL, xMarginR, yMarginB, yMarginT,
-			    xStart, xEnd, yStart, yEnd, iso);
-    if( !okVPWC) return;
+    // use POSITION
+    int positionIx = e->KeywordIx( "POSITION");
+    DFloatGDL* boxPosition = e->IfDefGetKWAs<DFloatGDL>( positionIx);
+    if (boxPosition == NULL) boxPosition = (DFloatGDL*) 0xF;
+    // set the PLOT charsize before setting viewport (margin depend on charsize)
+    gdlSetPlotCharsize(e, actStream);
+
+    static DDouble x0,y0,xs,ys; //conversion to normalized coords
+    x0=(xLog)?-log10(xStart):-xStart;
+    y0=(yLog)?-log10(yStart):-yStart;
+    xs=(xLog)?(log10(xEnd)-log10(xStart)):xEnd-xStart;xs=1.0/xs;
+    ys=(yLog)?(log10(yEnd)-log10(yStart)):yEnd-yStart;ys=1.0/ys;
+
+    if (doT3d)
+    {
+      DDoubleGDL* plplot3d;
+      DDouble az, alt, ay, scale;
+      ORIENTATION3D axisExchangeCode;
+
+      plplot3d = gdlConvertT3DMatrixToPlplotRotationMatrix( zValue, az, alt, ay, scale, axisExchangeCode);
+      if (plplot3d == NULL)
+      {
+        e->Throw("Illegal 3D transformation. (FIXME)");
+      }
 
+      if (gdlSet3DViewPortAndWorldCoordinates(e, actStream, plplot3d, xLog, yLog,
+        xStart, xEnd, yStart, yEnd) == FALSE) return;
+      gdlSetGraphicsForegroundColorFromKw(e, actStream);
+      gdlSetPlotCharthick(e, actStream);
+
+      DDouble  t3xStart, t3xEnd, t3yStart, t3yEnd, t3zStart, t3zEnd;
+      switch (axisExchangeCode) {
+        case NORMAL: //X->X Y->Y plane XY
+          t3xStart=(xLog)?log10(xStart):xStart,
+          t3xEnd=(xLog)?log10(xEnd):xEnd,
+          t3yStart=(yLog)?log10(yStart):yStart,
+          t3yEnd=(yLog)?log10(yEnd):yEnd,
+          t3zStart=0;
+          t3zEnd=1.0;
+          actStream->w3d(scale, scale, scale*(1.0 - zValue),
+          t3xStart,t3xEnd,t3yStart,t3yEnd,t3zStart,t3zEnd,
+          alt, az);
+          gdlAxis3(e, actStream, "X", xStart, xEnd, xLog);
+          gdlAxis3(e, actStream, "Y", yStart, yEnd, yLog);
+          break;
+        case XY: // X->Y Y->X plane XY
+          t3yStart=(xLog)?log10(xStart):xStart,
+          t3yEnd=(xLog)?log10(xEnd):xEnd,
+          t3xStart=(yLog)?log10(yStart):yStart,
+          t3xEnd=(yLog)?log10(yEnd):yEnd,
+          t3zStart=0;
+          t3zEnd=1.0;
+          actStream->w3d(scale, scale, scale*(1.0 - zValue),
+          t3xStart,t3xEnd,t3yStart,t3yEnd,t3zStart,t3zEnd,
+          alt, az);
+          gdlAxis3(e, actStream, "Y", xStart, xEnd, xLog);
+          gdlAxis3(e, actStream, "X", yStart, yEnd, yLog);
+          break;
+        case XZ: // Y->Y X->Z plane YZ
+          t3zStart=(xLog)?log10(xStart):xStart,
+          t3zEnd=(xLog)?log10(xEnd):xEnd,
+          t3yStart=(yLog)?log10(yStart):yStart,
+          t3yEnd=(yLog)?log10(yEnd):yEnd,
+          t3xStart=0;
+          t3xEnd=1.0;
+          actStream->w3d(scale, scale, scale,
+          t3xStart,t3xEnd,t3yStart,t3yEnd,t3zStart,t3zEnd,
+          alt, az);
+          gdlAxis3(e, actStream, "Z", xStart, xEnd, xLog, 0);
+          gdlAxis3(e, actStream, "Y", yStart, yEnd, yLog);
+          break;
+        case YZ: // X->X Y->Z plane XZ
+          t3xStart=(xLog)?log10(xStart):xStart,
+          t3xEnd=(xLog)?log10(xEnd):xEnd,
+          t3zStart=(yLog)?log10(yStart):yStart,
+          t3zEnd=(yLog)?log10(yEnd):yEnd,
+          t3yStart=0;
+          t3yEnd=1.0;
+          actStream->w3d(scale, scale, scale,
+          t3xStart,t3xEnd,t3yStart,t3yEnd,t3zStart,t3zEnd,
+          alt, az);
+          gdlAxis3(e, actStream, "X", xStart, xEnd, xLog);
+          gdlAxis3(e, actStream, "Z", yStart, yEnd, yLog,1);
+          break;
+        case XZXY: //X->Y Y->Z plane YZ
+          t3yStart=(xLog)?log10(xStart):xStart,
+          t3yEnd=(xLog)?log10(xEnd):xEnd,
+          t3zStart=(yLog)?log10(yStart):yStart,
+          t3zEnd=(yLog)?log10(yEnd):yEnd,
+          t3xStart=0;
+          t3xEnd=1.0;
+          actStream->w3d(scale, scale, scale,
+          t3xStart,t3xEnd,t3yStart,t3yEnd,t3zStart,t3zEnd,
+          alt, az);
+          gdlAxis3(e, actStream, "Y", xStart, xEnd, xLog);
+          gdlAxis3(e, actStream, "Z", yStart, yEnd, yLog);
+          break;
+        case XZYZ: //X->Z Y->X plane XZ
+          t3zStart=(xLog)?log10(xStart):xStart,
+          t3zEnd=(xLog)?log10(xEnd):xEnd,
+          t3xStart=(yLog)?log10(yStart):yStart,
+          t3xEnd=(yLog)?log10(yEnd):yEnd,
+          t3yStart=0;
+          t3yEnd=1.0;
+          actStream->w3d(scale, scale, scale,
+          t3xStart,t3xEnd,t3yStart,t3yEnd,t3zStart,t3zEnd,
+          alt, az);
+          gdlAxis3(e, actStream, "Z", xStart, xEnd, xLog,1);
+          gdlAxis3(e, actStream, "X", yStart, yEnd, yLog);
+          break;
+      }
+      // title and sub title
+      gdlWriteTitleAndSubtitle(e, actStream);
 
-    //now we can setup minVal and maxVal to defaults: Start-End and overload if KW present
+      //data: will plot using coordinates transform.
+      //TODO: unless PSYM=0 (optimize)
 
-    minVal = yStart; //to give a reasonable value...
-    maxVal = yEnd;   //idem
-    doMinMax = false; //although we will not use it...
-    if( e->KeywordSet( "MIN_VALUE") || e->KeywordSet( "MAX_VALUE"))
-      doMinMax = true; //...unless explicitely required
-    e->AssureDoubleScalarKWIfPresent( "MIN_VALUE", minVal);
-    e->AssureDoubleScalarKWIfPresent( "MAX_VALUE", maxVal);
+      Data3d.zValue = zValue;
+      Data3d.Matrix = plplot3d; //try to change for !P.T in future?
+        switch (axisExchangeCode) {
+          case NORMAL: //X->X Y->Y plane XY
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code012;
+            break;
+          case XY: // X->Y Y->X plane XY
+            Data3d.x0=0;
+            Data3d.y0=x0;
+            Data3d.xs=ys;
+            Data3d.ys=xs;
+            Data3d.code = code102;
+            break;
+          case XZ: // Y->Y X->Z plane YZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code210;
+            break;
+          case YZ: // X->X Y->Z plane XZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code021;
+            break;
+          case XZXY: //X->Y Y->Z plane YZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code120;
+            break;
+          case XZYZ: //X->Z Y->X plane XZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code201;
+            break;
+        }
 
-    //AXES:
-    // pen thickness for axis
-    actStream->wid( 0);
-
-    // axis
-    string xOpt="bc", yOpt="bc";
-    AdjustAxisOpts(xOpt, yOpt, xStyle, yStyle, xTicks, yTicks, xTickformat, yTickformat, xLog, yLog);
-
-    DLong charthick=0;
-    e->AssureLongScalarKWIfPresent("CHARTHICK",charthick);
-    actStream->wid(charthick);
-
-//X
-    // axis titles
-    actStream->schr( 0.0, actH/defH * xCharSize);
-    actStream->mtex("b",3.5,0.5,0.5,xTitle.c_str());
-
-    DLong xthick=0;
-    e->AssureLongScalarKWIfPresent("XTHICK",xthick);
-    actStream->wid(xthick);
-    // the axis (separate for x and y axis because of charsize)
-    PLFLT xintv;
-    if (xTicks == 0) {
-      xintv = AutoTick(xEnd-xStart);
-    } else {
-      xintv = (xEnd - xStart) / xTicks;
-      // changing "xintv" has no effects in plplot in Log Mode ...
-      // http://sourceforge.net/tracker/index.php?func=detail&aid=3095515&group_id=2915&atid=202915
-      if (yLog) Warning("PLOT: XTICKS keyword not active in plplot in Log mode");
-    }
-    actStream->box( xOpt.c_str(), xintv, xMinor, "", 0.0, 0);
-//Y
-    actStream->wid(charthick);
-    actStream->schr( 0.0, actH/defH * yCharSize);
-    actStream->mtex("l",5.0,0.5,0.5,yTitle.c_str());
-    
-    DLong ythick=0;
-    e->AssureLongScalarKWIfPresent("YTHICK",ythick);
-    actStream->wid(ythick);
-    // the axis (separate for x and y axis because of charsize)
-    PLFLT yintv;
-    if (yTicks == 0) {
-      yintv = AutoTick(yEnd-yStart);
-    } else {
-      yintv = (yEnd - yStart) / yTicks;
-      if (yLog) Warning("PLOT: YTICKS keyword not active in plplot in Log mode");
-    }
-    
-    int debug=0;
-    if (debug) cout << xOpt.c_str() << endl;
-    if (debug) cout << yOpt.c_str() << endl;
-    if (debug) cout << xintv << " "<< yintv<< endl;
-
-    actStream->box( "", 0.0, 0, yOpt.c_str(), yintv, yMinor);
-    // reset pen thickness
-    actStream->wid( 0);
-
-    // title and sub title
-    gkw_title(e, actStream, actH/defH);
-
-    // pen thickness for plot
-    gkw_thick(e, actStream);
-    gkw_symsize(e, actStream);
-    gkw_linestyle(e, actStream);
+      actStream->stransform(gdl3dTo2dTransform, &Data3d);
 
-    UpdateSWPlotStructs(actStream, xStart, xEnd, yStart, yEnd, xLog, yLog);
+    } else
+    {
+      //fix viewport and coordinates for box
+      if (gdlSetViewPortAndWorldCoordinates(e, actStream, boxPosition,
+          xLog, yLog,
+          xMarginL, xMarginR, yMarginB, yMarginT,
+	      xStart, xEnd, yStart, yEnd, iso)==FALSE) return; //no good: should catch an exception to get out of this mess.
+      //current pen color...
+      gdlSetGraphicsForegroundColorFromKw(e, actStream);
+      gdlSetPlotCharthick(e, actStream);
 
-  } // }}}
+      gdlBox(e, actStream, xStart, xEnd, yStart, yEnd, xLog, yLog);
+    }
+  } 
   
-    private: void call_plplot(EnvT* e, GDLGStream* actStream) // {{{
+    private: void call_plplot(EnvT* e, GDLGStream* actStream) 
     {
+      DLong psym;
       // plot the data
-      static int nodataIx = e->KeywordIx( "NODATA"); 
-      if (!e->KeywordSet(nodataIx)) 
+      int nodataIx = e->KeywordIx( "NODATA"); 
+      if ( !e->KeywordSet(nodataIx) )
       {
-        bool valid = draw_polyline(e, actStream, xVal, yVal, minVal, maxVal, doMinMax, xLog, yLog, psym, FALSE);
-        // TODO: handle valid?
+        //get psym
+        gdlGetPsym(e, psym); //PSYM
+        //handle clipping
+        bool doClip=(e->KeywordSet("CLIP")||e->KeywordSet("NOCLIP"));
+        // make all clipping computations BEFORE setting graphic properties (color, size)
+        bool stopClip=false;
+        if ( doClip )  if ( startClipping(e, actStream, false)==TRUE ) stopClip=true;
+        // here graphic properties
+        gdlSetPenThickness(e, actStream);
+        gdlSetSymsize(e, actStream);
+        gdlSetLineStyle(e, actStream);
+        // TODO: handle "valid"!
+        bool valid=draw_polyline(e, actStream, xVal, yVal, minVal, maxVal, doMinMax, xLog, yLog, psym, FALSE);
+        if (stopClip) stopClipping(actStream);
       }
-    } // }}}
+    } 
 
-    private: void post_call(EnvT* e, GDLGStream* actStream) // {{{
+    private: void post_call(EnvT* e, GDLGStream* actStream) 
     {
+     if (doT3d) actStream->stransform(NULL,NULL);
       actStream->lsty(1);//reset linestyle
-
-      // set ![XY].CRANGE
-      set_axis_crange("X", xStart, xEnd, xLog);
-      set_axis_crange("Y", yStart, yEnd, yLog);
-
-      //set ![x|y].type
-      set_axis_type("X",xLog);
-      set_axis_type("Y",yLog);
-    } // }}}
+      actStream->sizeChar(1.0);
+    } 
 
   };
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting_plots.cpp gdl/src/plotting_plots.cpp
--- gdl-0.9.3/src/plotting_plots.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting_plots.cpp	2013-05-16 12:36:33.559856683 -0600
@@ -19,269 +19,420 @@
 #include "plotting.hpp"
 #include "math_utl.hpp"
 
-namespace lib {
+namespace lib
+{
 
   using namespace std;
 
-  class plots_call : public plotting_routine_call
+  class plots_call: public plotting_routine_call
   {
 
     DDoubleGDL *xVal, *yVal, *zVal;
-    auto_ptr<BaseGDL> xval_guard, yval_guard;
+    Guard<BaseGDL> xval_guard, yval_guard, zval_guard;
+    DDouble xStart, xEnd, yStart, yEnd, zStart, zEnd;
     DLong psym;
-    PLFLT xStart, xEnd, yStart, yEnd, zStart, zEnd;
-    PLFLT xMarginL, xMarginR, yMarginB, yMarginT;
-    bool xLog, yLog, xLogOrig, yLogOrig;
+    bool xLog, yLog, zLog;
     SizeT xEl, yEl, zEl;
     bool append;
+    bool doClip;
+    bool restoreClipBox;
+    PLFLT savebox[4];
+    bool doT3d, real3d;
+    DDouble zValue;
+    DDoubleGDL* plplot3d;
+    Guard<BaseGDL> plplot3d_guard;
+    DLongGDL *color;
 
-    private: bool handle_args(EnvT* e) // {{{
+  private:
+
+    bool handle_args(EnvT* e) // {{{
     {
+      real3d=false;
+
+      //note: Z (VALUE) will be used uniquely if Z is not effectively defined.
+      static int zvIx = e->KeywordIx( "Z");
+      zValue=0.0;
+      e->AssureDoubleScalarKWIfPresent ( zvIx, zValue );
+
       append=e->KeywordSet("CONTINUE");
-      if( nParam() == 1)
+      if ( nParam()==1 )
       {
         BaseGDL* p0;
-        p0 = e->GetParDefined( 0);  
-        if (p0->Dim(0) != 2)
-          e->Throw( "When only 1 param, dims must be (2,n)");
-
-        if (e->KeywordSet("T3D")) e->Throw("Only 3-argument case supported for T3D - FIXME!");
-        // TODO: the (3,n) case
+        p0=e->GetParDefined(0);
+        SizeT dim0=p0->Dim(0);
+        if ( dim0<2 || dim0>3 )
+          e->Throw("When only 1 param, dims must be (2,n) or (3,n)");
+
+        DDoubleGDL *val=e->GetParAs< DDoubleGDL>(0);
+        xEl=p0->N_Elements()/dim0;
+        xVal=new DDoubleGDL(dimension(xEl), BaseGDL::NOZERO);
+        xval_guard.Reset(xVal); // delete upon exit
+
+        yEl=p0->N_Elements()/dim0;
+        yVal=new DDoubleGDL(dimension(yEl), BaseGDL::NOZERO);
+        yval_guard.Reset(yVal); // delete upon exit
 
-        DDoubleGDL *val = e->GetParAs< DDoubleGDL>( 0);
-
-        xEl = p0->N_Elements() / p0->Dim(0);
-        xVal = new DDoubleGDL( dimension( xEl), BaseGDL::NOZERO);
-        xval_guard.reset( xVal); // delete upon exit
-
-        yEl = p0->N_Elements() / p0->Dim(0);
-        yVal = new DDoubleGDL( dimension( yEl), BaseGDL::NOZERO);
-        yval_guard.reset( yVal); // delete upon exit
-
-        for( SizeT i = 0; i < xEl; i++) 
+        for ( SizeT i=0; i<xEl; i++ )
         {
-	  (*xVal)[i] = (*val)[2*i];
-	  (*yVal)[i] = (*val)[2*i+1];
+          (*xVal)[i]=(*val)[dim0*i];
+          (*yVal)[i]=(*val)[dim0*i+1];
         }
+
+        zEl=p0->N_Elements()/dim0;
+        zVal=new DDoubleGDL(dimension(zEl), BaseGDL::NOZERO);
+        zval_guard.Reset(zVal); // delete upon exit
+        if (dim0==3) for ( SizeT i=0; i<zEl; i++ ) (*zVal)[i]=(*val)[dim0*i+2];
+        else for (SizeT i=0; i< zEl ; ++i) (*zVal)[i]=zValue;
       }
-      else if(nParam() == 2)
+      else if ( nParam()==2 )
       {
-        if (e->KeywordSet("T3D")) e->Throw("Only 3-argument case supported for T3D - FIXME!"); // TODO
+        xVal=e->GetParAs< DDoubleGDL>(0);
+        xEl=xVal->N_Elements();
 
-        xVal = e->GetParAs< DDoubleGDL>( 0);
-        xEl = xVal->N_Elements();
-
-        yVal = e->GetParAs< DDoubleGDL>( 1);
-        yEl = yVal->N_Elements();
+        yVal=e->GetParAs< DDoubleGDL>(1);
+        yEl=yVal->N_Elements();
         //silently drop unmatched values
-        if (yEl!=xEl)
+        if ( yEl!=xEl )
         {
           SizeT size;
-          size=min(xEl,yEl);
+          size=min(xEl, yEl);
           xEl=size;
           yEl=size;
         }
+        //z will be set at Zero unless Z=value is given
+        zEl=xEl;
+        zVal=new DDoubleGDL(dimension(zEl));
+        zval_guard.Reset(zVal); // delete upon exit
+        for (SizeT i=0; i< zEl ; ++i) (*zVal)[i]=zValue;
       }
-      else if(nParam() == 3)
+      else if ( nParam()==3 )
       {
-        zVal = e->GetParAs< DDoubleGDL>( 2);
-        zEl = zVal->N_Elements();
-
-        //if ((*zVal)[0] == 0 && zEl == 1) {
-          xVal = e->GetParAs< DDoubleGDL>( 0);
-          xEl = xVal->N_Elements();
-
-          yVal = e->GetParAs< DDoubleGDL>( 1);
-          yEl = yVal->N_Elements();
-        if (!(xEl==yEl && yEl==zEl))
+        real3d=true;
+        zVal=e->GetParAs< DDoubleGDL>(2);
+        zEl=zVal->N_Elements();
+
+        xVal=e->GetParAs< DDoubleGDL>(0);
+        xEl=xVal->N_Elements();
+
+        yVal=e->GetParAs< DDoubleGDL>(1);
+        yEl=yVal->N_Elements();
+        if ( !(xEl==yEl&&yEl==zEl) )
         {
           SizeT size;
-          size=min(xEl,yEl);
-          size=min(size,zEl);
+          size=min(xEl, yEl);
+          size=min(size, zEl);
           xEl=size;
           yEl=size;
           zEl=size;
         }
       }
       return false;
-    } 
+    }
 
-  private: void old_body( EnvT* e, GDLGStream* actStream) // {{{
-  {
-    DDoubleGDL* clippingD=NULL;
+  private:
 
-    actStream->gvpd(xMarginL,xMarginR,yMarginB,yMarginT);
-    if((xMarginL==0.0&&xMarginR==0.0)||(yMarginB==0.0&&yMarginT==0.0)) //if not initialized, set normalized mode
+    void old_body(EnvT* e, GDLGStream* actStream)
     {
-        actStream->NoSub();
-        actStream->vpor(0, 1, 0, 1);
-        actStream->gvpd(xMarginL,xMarginR,yMarginB,yMarginT);
-        actStream->wind(0.0,1.0,0.0,1.0);
-   }
-    // get current viewport limit in world coords
-//    get_axis_crange("X",xStart,xEnd);
-//    get_axis_crange("Y",yStart,yEnd);
-    actStream->gvpw(xStart,xEnd,yStart,yEnd);
-    // get_axis_type
-    get_axis_type("X", xLogOrig); xLog=xLogOrig;
-    get_axis_type("Y", yLogOrig); yLog=yLogOrig;
-    
-    /*    DLong background = p_background;
-    static int cix=e->KeywordIx("COLOR");
-    BaseGDL* color_arr=e->GetKW(cix);
-    DLongGDL* l_color_arr;
-
-    if(color_arr != NULL)
-      {
-	l_color_arr=static_cast<DLongGDL*>
-	  (color_arr->Convert2(GDL_LONG, BaseGDL::COPY));
-	if(color_arr->N_Elements() < minEl && color_arr->N_Elements() > 1)
-	  e->Throw( "Array "+e->GetParString(cix)+
-		    " does not have enough elements for COLOR keyword.");
-      }
-    DLong color = p_color;
-
-    if(color_arr != NULL)  
-      if(color_arr->N_Elements() >= 1) 
-	  	color=(*l_color_arr)[0];
-    */
-  
-    bool mapSet=false;
+      int clippingix=e->KeywordIx("CLIP");
+      DFloatGDL* clipBox=NULL;
+
+      enum
+      {
+        DATA=0,
+        NORMAL,
+        DEVICE
+      } coordinateSystem=DATA;
+      //check presence of DATA,DEVICE and NORMAL options
+      if ( e->KeywordSet("DATA") ) coordinateSystem=DATA;
+      if ( e->KeywordSet("DEVICE") ) coordinateSystem=DEVICE;
+      if ( e->KeywordSet("NORMAL") ) coordinateSystem=NORMAL;
+
+      //T3D
+      static int t3dIx = e->KeywordIx( "T3D");
+      doT3d=e->KeywordSet(t3dIx);
+
+      // get_axis_type
+      gdlGetAxisType("X", xLog);
+      gdlGetAxisType("Y", yLog);
+      gdlGetAxisType("Z", zLog);
+      // get ![XY].CRANGE
+      gdlGetCurrentAxisRange("X", xStart, xEnd);
+      gdlGetCurrentAxisRange("Y", yStart, yEnd);
+      gdlGetCurrentAxisRange("Z", zStart, zEnd);
+
+      if ((yStart == yEnd) || (xStart == xEnd) || (zStart == zEnd))
+      {
+        if (zStart != 0.0 && zStart == zEnd)
+          Message("PLOTS: !Z.CRANGE ERROR, setting to [0,1]");
+          zStart = 0;
+          zEnd = 1;
+
+        if (yStart != 0.0 && yStart == yEnd)
+          Message("PLOTS: !Y.CRANGE ERROR, setting to [0,1]");
+        yStart = 0;
+        yEnd = 1;
+
+        if (xStart != 0.0 && xStart == xEnd)
+          Message("PLOTS: !X.CRANGE ERROR, setting to [0,1]");
+        xStart = 0;
+        xEnd = 1;
+      }
+
+      bool mapSet=false;
 #ifdef USE_LIBPROJ4
-    // Map Stuff (xtype = 3)
-    LPTYPE idata;
-    XYTYPE odata;
-
-    get_mapset(mapSet);
-
-    if ( mapSet) {
-      ref = map_init();
-      if ( ref == NULL) {
-	e->Throw( "Projection initialization failed.");
+      // Map Stuff (xtype = 3)
+
+      get_mapset(mapSet);
+
+      if ( mapSet )
+      {
+        ref=map_init();
+        if ( ref==NULL )
+        {
+          e->Throw("Projection initialization failed.");
+        }
       }
-    }
 #endif
-    //CLIPPING
-    DLong noclip = 1; //PLOTS: default is not to clip, even when clip= is present. Only with noclip=0 a clip is done.
-    e->AssureLongScalarKWIfPresent( "NOCLIP", noclip);
-    if( noclip == 0)
-    {
-      static int clippingix = e->KeywordIx( "CLIP");
-      clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
-    }
+      restoreClipBox=false;
+      int noclipvalue=1;
+      e->AssureLongScalarKWIfPresent( "NOCLIP", noclipvalue);
+      doClip=(noclipvalue==0); //PLOTS by default does not clip, even if clip is defined by CLIP= or !P.CLIP
+      clipBox=e->IfDefGetKWAs<DFloatGDL>(clippingix);
+      if (doClip && clipBox!=NULL && clipBox->N_Elements()>=4 ) //clipbox exist, will be used: convert to device coords
+                                   //and save in !P.CLIP...
+      {
+        restoreClipBox=true; //restore later
+        // save current !P.CLIP box, replace by our current clipbox in whatever coordinates, will
+        // give back the !P.CLIP box at end...
+        static DStructGDL* pStruct=SysVar::P();
+        static unsigned clipTag=pStruct->Desc()->TagIndex("CLIP"); //must be in device coordinates
+        static PLFLT tempbox[4];
+        for ( int i=0; i<4; ++i ) savebox[i]=(*static_cast<DLongGDL*>(pStruct->GetTag(clipTag, 0)))[i];
+        if ( coordinateSystem==DEVICE )
+        {
+          for ( int i=0; i<4; ++i ) tempbox[i]=(*clipBox)[i];
+        }
+        else if ( coordinateSystem==DATA )
+        {
+          //handle log: if existing box is already in log, use log of clipbox values.
+          PLFLT worldbox[4];
+          for ( int i=0; i<4; ++i ) worldbox[i]=(*clipBox)[i];
+          if (xLog) {worldbox[0]=log10(worldbox[0]); worldbox[2]=log10(worldbox[2]);}
+          if (yLog) {worldbox[1]=log10(worldbox[1]); worldbox[3]=log10(worldbox[3]);}
+          bool okClipBox=true;
+          for ( int i=0; i<4; ++i )
+          {
+            if (!(worldbox[i]==worldbox[i])) //NaN
+            {
+              okClipBox=false;restoreClipBox=false;doClip=false;
+            }
+          }
+          if (okClipBox)
+          {
+            actStream->WorldToDevice(worldbox[0], worldbox[1], tempbox[0], tempbox[1]);
+            actStream->WorldToDevice(worldbox[2], worldbox[3], tempbox[2], tempbox[3]);
+          }
+        }
+        else
+        {
+          actStream->NormedDeviceToDevice((*clipBox)[0],(*clipBox)[1], tempbox[0], tempbox[1]);
+          actStream->NormedDeviceToDevice((*clipBox)[2],(*clipBox)[3], tempbox[2], tempbox[3]);
+        }
+        //place in !P.CLIP
+        for ( int i=0; i<4; ++i ) (*static_cast<DLongGDL*>(pStruct->GetTag(clipTag, 0)))[i]=tempbox[i];
+      }
 
-    if (!e->KeywordSet("T3D"))
-    {
-        actStream->NoSub();
-        if (e->KeywordSet("DEVICE"))
+      PLFLT wun, wdeux, wtrois, wquatre;
+      if ( coordinateSystem==DATA) //with PLOTS, we can plot *outside* the box(e)s in DATA coordinates.
+                                   // convert to device coords in this case
+      {
+        actStream->pageWorldCoordinates(wun, wdeux, wtrois, wquatre);
+      }
+
+      actStream->OnePageSaveLayout(); // one page
+
+      actStream->vpor(0, 1, 0, 1);
+      if ( coordinateSystem==DEVICE )
       {
-        actStream->vpor(0, 1, 0, 1);
-        PLFLT xpix, ypix;
-        PLFLT un,deux,trois,quatre;
-        PLINT xleng, yleng, xoff, yoff;
-        actStream->gpage(xpix, ypix, xleng, yleng, xoff, yoff);
-        un=0.0; deux=xleng; trois=0.0; quatre=yleng;
-//        if( clippingD != NULL) Clipping( clippingD, un, deux, trois, quatre);
-        actStream->wind(un, deux, trois, quatre);
-        xLog = false;
-        yLog = false;
-      }
-      else if (e->KeywordSet("NORMAL"))
-      {
-        PLFLT un,deux,trois,quatre;
-        actStream->vpor(0, 1, 0, 1);
-        un=0.0; deux=1.0; trois=0.0; quatre=1.0;
- //       if( clippingD != NULL) Clipping( clippingD, un, deux, trois, quatre);
-        actStream->wind(un, deux, trois, quatre);
-        xLog = false;
-        yLog = false;
-      }
-//      else if( clippingD != NULL)
-//      {
-//         PLFLT un,deux,trois,quatre;
-//         un=xStart; deux=xEnd; trois=yStart; quatre=yEnd;
-//         Clipping( clippingD, un, deux, trois, quatre);
-//         actStream->wind(un, deux, trois, quatre);
-//       }
+        actStream->wind(0.0, actStream->xPageSize(), 0.0, actStream->yPageSize());
+        xLog=false;
+        yLog=false;
+      }
+      else if ( coordinateSystem==NORMAL )
+      {
+        actStream->wind(0, 1, 0, 1);
+        xLog=false;
+        yLog=false;
+      }
       else //with PLOTS, we can plot *outside* the box(e)s in DATA coordinates.
       {
-        DDouble un, deux, trois, quatre;
-        getWorldCoordinatesFromPLPLOT(actStream, 0.0, 0.0, &un, &trois);
-        getWorldCoordinatesFromPLPLOT(actStream, 1.0, 1.0, &deux, &quatre);
-
-        actStream->vpor(0, 1, 0, 1);
-        actStream->wind((PLFLT)un, (PLFLT)deux, (PLFLT)trois, (PLFLT)quatre);
-      }
-   }
-    // start drawing. Graphic Keywords accepted: CLIP(YES), COLOR(OK), DATA(YES), DEVICE(YES),
-    //LINESTYLE(OK), NOCLIP(YES), NORMAL(YES), PSYM(OK), SYMSIZE(OK), T3D(NO), THICK(OK), Z(NO)
-    gkw_color(e, actStream); //COLOR
-    gkw_psym(e, psym); //PSYM
-    gkw_linestyle(e, actStream); //LINESTYLE
-    gkw_symsize(e, actStream); //SYMSIZE
-    gkw_thick(e, actStream); //THICK
+        actStream->wind(wun, wdeux, wtrois, wquatre);
+      }
+    }
 
-  } 
+  private:
 
-    private: void call_plplot(EnvT* e, GDLGStream* actStream) // {{{
+    void call_plplot(EnvT* e, GDLGStream* actStream) 
     {
-      if (e->KeywordSet("T3D")) // TODO: check !P.T3D
+      // start drawing. Graphic Keywords accepted: CLIP(YES), COLOR(OK), DATA(YES), DEVICE(YES),
+      //LINESTYLE(OK), NOCLIP(YES), NORMAL(YES), PSYM(OK), SYMSIZE(OK), T3D(NO), THICK(OK), Z(NO)
+      int colorIx=e->KeywordIx ( "COLOR" ); bool doColor=false;
+      if ( e->GetKW ( colorIx )!=NULL )
       {
-        Warning("PLOTS: 3D plotting does not really work yet (!P.T and !P.T3D are ignored for the moment)");
- /*       actStream->w3d(1.2, 1.2, 2.2, // TODO!
-          xStart, xEnd, yStart, yEnd, xStart, zEnd,
-          30, 30  // TODO!
-        );
-*/
-        PLINT n = xVal->N_Elements();
-        if (yEl > 1 && yEl < n) n = yEl;
-        if (zEl > 1 && zEl < n) n = zEl;
+        color=e->GetKWAs<DLongGDL>( colorIx ); doColor=true;
+      }
+      static DDouble x0,y0,xs,ys; //conversion to normalized coords
+      x0=(xLog)?-log10(xStart):-xStart;
+      y0=(yLog)?-log10(yStart):-yStart;
+      xs=(xLog)?(log10(xEnd)-log10(xStart)):xEnd-xStart;xs=1.0/xs;
+      ys=(yLog)?(log10(yEnd)-log10(yStart)):yEnd-yStart;ys=1.0/ys;
+
+      if ( doT3d && !real3d) { //if X,Y and Z are passed, we will use !P.T and not our plplot "interpretation" of !P.T
+                               //if the x and y scaling is OK, using !P.T directly permits to use other projections
+                               //than those used implicitly by plplot. See @showhaus example for *DL
+        // case where we project 2D data on 3D: use plplot-like matrix.
+        DDouble az, alt, ay, scale;
+        ORIENTATION3D axisExchangeCode;
 
-        PLFLT *x = new PLFLT[n];
+        plplot3d = gdlConvertT3DMatrixToPlplotRotationMatrix( zValue, az, alt, ay, scale, axisExchangeCode);
+        if (plplot3d == NULL)
         {
-          int a = (xEl != 1); 
-          for (PLINT i = 0; i < n; ++i) x[i] = (*xVal)[a * i];
+          e->Throw("Illegal 3D transformation. (FIXME)");
         }
 
-        PLFLT *y = new PLFLT[n];
-        {
-          int a = (yEl != 1); 
-          for (PLINT i = 0; i < n; ++i) y[i] = (*yVal)[a * i];
+        Data3d.zValue = zValue;
+        Data3d.Matrix = plplot3d; //try to change for !P.T in future?
+        switch (axisExchangeCode) {
+          case NORMAL: //X->X Y->Y plane XY
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code012;
+            break;
+          case XY: // X->Y Y->X plane XY
+            Data3d.x0=0;
+            Data3d.y0=x0;
+            Data3d.xs=ys;
+            Data3d.ys=xs;
+            Data3d.code = code102;
+            break;
+          case XZ: // Y->Y X->Z plane YZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code210;
+            break;
+          case YZ: // X->X Y->Z plane XZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code021;
+            break;
+          case XZXY: //X->Y Y->Z plane YZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code120;
+            break;
+          case XZYZ: //X->Z Y->X plane XZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code201;
+            break;
         }
+        actStream->stransform(gdl3dTo2dTransform, &Data3d);
+      }
+      // make all clipping computations BEFORE setting graphic properties (color, size)
+      bool stopClip=false;
+      if ( doClip )  if ( startClipping(e, actStream, true)==TRUE ) stopClip=true;
+      //properties
+      gdlSetGraphicsForegroundColorFromKw(e, actStream); //COLOR
+      gdlGetPsym(e, psym); //PSYM
+      if (psym==10) e->Throw("PSYM (plotting symbol) out of range"); //not allowed for PLOTS!
+      gdlSetLineStyle(e, actStream); //LINESTYLE
+      gdlSetSymsize(e, actStream); //SYMSIZE
+      gdlSetPenThickness(e, actStream); //THICK
 
-        PLFLT *z = new PLFLT[n];
+      if (real3d)
+      {
+        //try first if the matrix is a plplot-compatible one
+        DDouble az, alt, ay, scale;
+        ORIENTATION3D axisExchangeCode;
+        plplot3d = gdlConvertT3DMatrixToPlplotRotationMatrix( zValue, az, alt, ay, scale, axisExchangeCode);
+
+        if (plplot3d == NULL) //use the original !P.T matrix (better than nothing)
+        {
+          Warning("Using Illegal 3D transformation, continuing. (FIXME)");
+          plplot3d=gdlGetT3DMatrix(); //the original one
+          plplot3d_guard.Reset(plplot3d);
+          Data3d.code = code012;
+        } else
         {
-          int a = (zEl != 1); 
-          for (PLINT i = 0; i < n; ++i) z[i] = (*zVal)[a * i];
+          switch (axisExchangeCode) {
+          case NORMAL: //X->X Y->Y plane XY
+            Data3d.code = code012;
+            break;
+          case XY: // X->Y Y->X plane XY
+            Data3d.code = code102;
+            break;
+          case XZ: // Y->Y X->Z plane YZ
+            Data3d.code = code210;
+            break;
+          case YZ: // X->X Y->Z plane XZ
+            Data3d.code = code021;
+            break;
+          case XZXY: //X->Y Y->Z plane YZ
+            Data3d.code = code120;
+            break;
+          case XZYZ: //X->Z Y->X plane XZ
+            Data3d.code = code201;
+            break;
+          }
         }
+        DDoubleGDL *xValou=new DDoubleGDL(dimension(xEl));
+        DDoubleGDL *yValou=new DDoubleGDL(dimension(yEl));
+        Guard<BaseGDL> xval_guard, yval_guard;
+        xval_guard.reset(xValou);
+        yval_guard.reset(yValou);
+        //rescale to normalized box before conversions --- works for both matrices.
+        gdl3dto2dProjectDDouble(gdlGetScaledNormalizedT3DMatrix(plplot3d),xVal,yVal,zVal,xValou,yValou,Data3d.code);
+        draw_polyline(e, actStream, xValou, yValou, 0.0, 0.0, false, xLog, yLog, psym, append, doColor?color:NULL);
+      }
+      else  bool valid=draw_polyline(e, actStream, xVal, yVal, 0.0, 0.0, false, xLog, yLog, psym, append, doColor?color:NULL);
+      if (stopClip) stopClipping(actStream);
+    }
 
-        actStream->line3(n, x, y, z);
+  private:
 
-        delete[] x;
-        delete[] y;
-        delete[] z;
+    virtual void post_call(EnvT*, GDLGStream* actStream)
+    {
+      if (doT3d && !real3d)
+      {
+        plplot3d_guard.Reset(plplot3d);
+        actStream->stransform(NULL,NULL);
       }
-      else 
+      actStream->RestoreLayout();
+      actStream->lsty(1); //reset linestyle
+      if (restoreClipBox)
       {
-        // there is no 'minmax' option for plots. 
-        bool valid = draw_polyline(e, actStream, xVal, yVal, 0.0, 0.0, false, xLog, yLog, psym, append);
-        // TODO: handle valid?
+        static DStructGDL* pStruct=SysVar::P();
+        static unsigned clipTag=pStruct->Desc()->TagIndex("CLIP"); //must be in device coordinates
+        for ( int i=0; i<4; ++i ) (*static_cast<DLongGDL*>(pStruct->GetTag(clipTag, 0)))[i]=savebox[i];
       }
-    } 
-
-    private: virtual void post_call(EnvT*, GDLGStream* actStream) 
-    {
-      actStream->lsty(1);//reset linestyle
-      actStream->vpor(xMarginL, xMarginR, yMarginB, yMarginT);
-      actStream->wind(xStart, xEnd, yStart, yEnd);
-    } 
+    }
 
-  }; // oplot_call class 
+  }; 
 
   void plots(EnvT* e)
   {
     plots_call plots;
     plots.call(e, 1);
-  }  
+  }
 
 } // namespace
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting_polyfill.cpp gdl/src/plotting_polyfill.cpp
--- gdl-0.9.3/src/plotting_polyfill.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting_polyfill.cpp	2013-05-16 12:36:33.617856475 -0600
@@ -19,195 +19,391 @@
 #include "plotting.hpp"
 #include "math_utl.hpp"
 
-#ifdef _MSC_VER
-#define isnan _isnan
-#endif
-
-namespace lib {
+namespace lib
+{
 
   using namespace std;
 
-  class polyfill_call : public plotting_routine_call
+  class polyfill_call: public plotting_routine_call
   {
 
-    private: DDoubleGDL* yVal, *xVal;
-    private: SizeT xEl, yEl;
+  private:
+    DDoubleGDL *xVal, *yVal, *zVal;
+    Guard<BaseGDL> xval_guard, yval_guard, zval_guard;
+    DDouble xStart, xEnd, yStart, yEnd, zStart, zEnd;
+    DLong psym;
+    bool xLog, yLog, zLog;
+    SizeT xEl, yEl, zEl;
+    bool append;
+    bool doClip;
+    bool restoreClipBox;
+    PLFLT savebox[4];
+    bool doT3d, real3d;
+    DDouble zValue;
+    DDoubleGDL* plplot3d;
+    Guard<BaseGDL> plplot3d_guard;
+//    DLongGDL *color;
 
-    private: bool handle_args(EnvT* e) // {{{
+  private:
+
+    bool handle_args(EnvT* e) // {{{
     {
-      return true;
+      real3d=false;
+      //T3D
+      static int t3dIx = e->KeywordIx( "T3D");
+      doT3d=e->KeywordSet(t3dIx);
+
+      //note: Z (VALUE) will be used uniquely if Z is not effectively defined.
+      static int zvIx = e->KeywordIx( "Z");
+      zValue=0.0;
+      e->AssureDoubleScalarKWIfPresent ( zvIx, zValue );
+
+      if ( nParam()==1 )
+      {
+        BaseGDL* p0;
+        p0=e->GetParDefined(0);
+        SizeT dim0=p0->Dim(0);
+        if ( dim0<2 || dim0>3 )
+          e->Throw("When only 1 param, dims must be (2,n) or (3,n)");
+        if (p0->Dim(1) < 3 ) e->Throw("Not enough valid and unique points specified.");
+
+        DDoubleGDL *val=e->GetParAs< DDoubleGDL>(0);
+        xEl=p0->N_Elements()/dim0;
+        xVal=new DDoubleGDL(dimension(xEl), BaseGDL::NOZERO);
+        xval_guard.Reset(xVal); // delete upon exit
+
+        yEl=p0->N_Elements()/dim0;
+        yVal=new DDoubleGDL(dimension(yEl), BaseGDL::NOZERO);
+        yval_guard.Reset(yVal); // delete upon exit
+
+        for ( SizeT i=0; i<xEl; i++ )
+        {
+          (*xVal)[i]=(*val)[dim0*i];
+          (*yVal)[i]=(*val)[dim0*i+1];
+        }
+
+        zEl=p0->N_Elements()/dim0;
+        zVal=new DDoubleGDL(dimension(zEl), BaseGDL::NOZERO);
+        zval_guard.Reset(zVal); // delete upon exit
+        if (dim0==3) for ( SizeT i=0; i<zEl; i++ ) (*zVal)[i]=(*val)[dim0*i+2];
+        else for (SizeT i=0; i< zEl ; ++i) (*zVal)[i]=zValue;
+      }
+      else if ( nParam()==2 )
+      {
+        xVal=e->GetParAs< DDoubleGDL>(0);
+        xEl=xVal->N_Elements();
+
+        yVal=e->GetParAs< DDoubleGDL>(1);
+        yEl=yVal->N_Elements();
+
+        if ( xEl < 3 || yEl < 3 ) e->Throw("Not enough valid and unique points specified.");
+
+        //silently drop unmatched values
+        if ( yEl!=xEl )
+        {
+          SizeT size;
+          size=min(xEl, yEl);
+          xEl=size;
+          yEl=size;
+        }
+        //z will be set at Zero unless Z=value is given
+        zEl=xEl;
+        zVal=new DDoubleGDL(dimension(zEl));
+        zval_guard.Reset(zVal); // delete upon exit
+        for (SizeT i=0; i< zEl ; ++i) (*zVal)[i]=zValue;
+      }
+      else if ( nParam()==3 )
+      {
+        if (doT3d) real3d=true;
+        zVal=e->GetParAs< DDoubleGDL>(2);
+        zEl=zVal->N_Elements();
+
+        xVal=e->GetParAs< DDoubleGDL>(0);
+        xEl=xVal->N_Elements();
+
+        yVal=e->GetParAs< DDoubleGDL>(1);
+        yEl=yVal->N_Elements();
+
+        if ( xEl < 3 || yEl < 3  || zEl < 3) e->Throw("Not enough valid and unique points specified.");
+
+        if ( !(xEl==yEl&&yEl==zEl) )
+        {
+          SizeT size;
+          size=min(xEl, yEl);
+          size=min(size, zEl);
+          xEl=size;
+          yEl=size;
+          zEl=size;
+        }
+      }
+      return false;
+//      return true;
     } // }}}
 
-  void old_body( EnvT* e, GDLGStream* actStream) // {{{
-  {
+    void old_body(EnvT* e, GDLGStream* actStream) // {{{
+    {
+      enum
+      {
+        DATA=0,
+        NORMAL,
+        DEVICE
+      } coordinateSystem=DATA;
+      //check presence of DATA,DEVICE and NORMAL options
+      if ( e->KeywordSet("DATA") ) coordinateSystem=DATA;
+      if ( e->KeywordSet("DEVICE") ) coordinateSystem=DEVICE;
+      if ( e->KeywordSet("NORMAL") ) coordinateSystem=NORMAL;
+
+      // get_axis_type
+      gdlGetAxisType("X", xLog);
+      gdlGetAxisType("Y", yLog);
+      gdlGetAxisType("Z", zLog);
+      // get ![XY].CRANGE
+      gdlGetCurrentAxisRange("X", xStart, xEnd);
+      gdlGetCurrentAxisRange("Y", yStart, yEnd);
+      gdlGetCurrentAxisRange("Z", zStart, zEnd);
 
-    bool mapSet=false;
+      if ((yStart == yEnd) || (xStart == xEnd) || (zStart == zEnd))
+      {
+        if (zStart != 0.0 && zStart == zEnd)
+          Message("POLYFILL: !Z.CRANGE ERROR, setting to [0,1]");
+          zStart = 0;
+          zEnd = 1;
+
+        if (yStart != 0.0 && yStart == yEnd)
+          Message("POLYFILL: !Y.CRANGE ERROR, setting to [0,1]");
+        yStart = 0;
+        yEnd = 1;
+
+        if (xStart != 0.0 && xStart == xEnd)
+          Message("POLYFILL: !X.CRANGE ERROR, setting to [0,1]");
+        xStart = 0;
+        xEnd = 1;
+      }
+
+      bool mapSet=false;
 #ifdef USE_LIBPROJ4
-    LPTYPE idata;
-    XYTYPE odata;
-    get_mapset(mapSet);
-    if (mapSet) 
-    {
-      ref = map_init();
-      if (ref == NULL) e->Throw( "Projection initialization failed.");
-    }
-#endif
+      // Map Stuff (xtype = 3)
 
-    if(nParam() == 1 || nParam() == 3) 
-    {
-      e->Throw("1- and 3-argument case not implemented yet");
-    }
-    else
-    {
-      xVal = !mapSet
-        ? e->GetParAs< DDoubleGDL>(0)
-        : static_cast<DDoubleGDL*>(
-          e->GetNumericArrayParDefined(0)->Convert2(GDL_DOUBLE, BaseGDL::COPY)
-        );
-      yVal = !mapSet
-        ? e->GetParAs< DDoubleGDL>(1)
-        : static_cast<DDoubleGDL*>(
-          e->GetNumericArrayParDefined(1)->Convert2(GDL_DOUBLE, BaseGDL::COPY)
-        );
+      get_mapset(mapSet);
 
-      xEl = xVal->N_Elements();
-      yEl = yVal->N_Elements();
-    }
+      if ( mapSet )
+      {
+        ref=map_init();
+        if ( ref==NULL )
+        {
+          e->Throw("Projection initialization failed.");
+        }
+      }
+#endif
 
-    if (xEl != yEl)
-      e->Throw("xEl != yEl"); // TODO
 
-    if (xEl < 3)
-      e->Throw("Input arrays must define at least three points");
+      PLFLT wun, wdeux, wtrois, wquatre;
+      if ( coordinateSystem==DATA) //with POLYFILL, we can plot *outside* the box(e)s in DATA coordinates.
+                                   // convert to device coords in this case
+      {
+        actStream->pageWorldCoordinates(wun, wdeux, wtrois, wquatre);
+      }
+
+      actStream->OnePageSaveLayout(); // one page
 
-    DFloat xMarginL, xMarginR,yMarginB, yMarginT; 
-    get_axis_margin("X", xMarginL, xMarginR);
-    get_axis_margin("Y", yMarginB, yMarginT);
-    
-    DDouble xStart, xEnd, yStart, yEnd;
-    bool xLog, yLog;
-
-    get_axis_crange("X", xStart, xEnd);
-    get_axis_crange("Y", yStart, yEnd);
-    get_axis_type("X", xLog);
-    get_axis_type("Y", yLog);
-
-    gkw_color(e, actStream);
-
-    PLFLT xMR, xML, yMB, yMT;
-    CheckMargin( e, actStream, xMarginL, xMarginR, yMarginB, yMarginT, xMR, xML, yMB, yMT);
-
-    DDouble *sx, *sy;
-    DFloat *wx, *wy;
-    GetSFromPlotStructs(&sx, &sy);
-    GetWFromPlotStructs(&wx, &wy);
-
-    int toto=0;
-
-    if(e->KeywordSet("DEVICE")) {
-      PLFLT xpix, ypix;
-      PLINT xleng, yleng, xoff, yoff;
-      actStream->gpage(xpix, ypix,xleng, yleng, xoff, yoff);
-      xStart=0; xEnd=xleng;
-      yStart=0; yEnd=yleng;
-      xLog = false; yLog = false;
-      actStream->NoSub();
-      actStream->vpor(0, 1, 0, 1);
-    } else if(e->KeywordSet("NORMAL")) {
-      xStart = 0;
-      xEnd   = 1;
-      yStart = 0;
-      yEnd   = 1;
-      actStream->NoSub();
       actStream->vpor(0, 1, 0, 1);
-      xLog = false; yLog = false;
-    } else {
-      toto=1;
-      actStream->NoSub();
-      if (xLog || yLog) actStream->vpor(wx[0], wx[1], wy[0], wy[1]);
-      else actStream->vpor(0, 1, 0, 1); // (to be merged with the condition on DataCoordLimits...)
-    }
+      if ( coordinateSystem==DEVICE )
+      {
+        actStream->wind(0.0, actStream->xPageSize(), 0.0, actStream->yPageSize());
+        xLog=false;
+        yLog=false;
+      }
+      else if ( coordinateSystem==NORMAL )
+      {
+        actStream->wind(0, 1, 0, 1);
+        xLog=false;
+        yLog=false;
+      }
+      else //with POLYFILL, we can plot *outside* the box(e)s in DATA coordinates.
+      {
+        actStream->wind(wun, wdeux, wtrois, wquatre);
+      }
 
-    // Determine data coordinate limits
-    // These are computed from window and scaling axis system
-    // variables because map routines change these directly.
-    //if (e->KeywordSet("NORMAL") || e->KeywordSet("DATA")) {
-    if (e->KeywordSet("DATA") || (toto == 1)) {
-      DataCoordLimits(sx, sy, wx, wy, &xStart, &xEnd, &yStart, &yEnd, false);
-    }
-    DDouble minVal = yStart, maxVal = yEnd;
+    } // }}}
 
-    //CLIPPING
-//    DLong noclip = 1;
-//    e->AssureLongScalarKWIfPresent( "NOCLIP", noclip);
-//    if (noclip == 0)
-//    {
-//      static int clippingix = e->KeywordIx( "CLIP");
-//      DDoubleGDL* clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
-//      if (clippingD != NULL) Clipping( clippingD, xStart, xEnd, minVal, maxVal);
-//    }
-
-    // SA: following a patch from Joanna (3029409) TODO: this is repeated in PLOTS POLYFILL and XYOUTS
-    if ( xEnd - xStart == 0 || yEnd - yStart == 0 || isnan(xStart) || isnan(yStart) ) {
-      actStream->wind( 0, 1, 0, 1 ); 
-    } else {
-      actStream->wind( xStart, xEnd, yStart, yEnd);
-    }
+  private:
 
-    // LINE_FILL, SPACING, LINESTYLE, ORIENTATION, THICK (thanks to JW)
-    static int line_fillIx = e->KeywordIx("LINE_FILL");
-    if (e->KeywordSet(line_fillIx))
+    void call_plplot(EnvT* e, GDLGStream* actStream) // {{{
     {
-      PLINT inc = 0, del = 1500;
-
-      static int orientationIx = e->KeywordIx("ORIENTATION");
-      if (e->KeywordSet(orientationIx)) inc = PLINT(1e1 * (*e->GetKWAs<DFloatGDL>(orientationIx))[0]);
+      static DDouble x0,y0,xs,ys; //conversion to normalized coords
+      x0=(xLog)?-log10(xStart):-xStart;
+      y0=(yLog)?-log10(yStart):-yStart;
+      xs=(xLog)?(log10(xEnd)-log10(xStart)):xEnd-xStart;xs=1.0/xs;
+      ys=(yLog)?(log10(yEnd)-log10(yStart)):yEnd-yStart;ys=1.0/ys;
+
+      if ( doT3d && !real3d) { //if X,Y and Z are passed, we will use !P.T and not our plplot "interpretation" of !P.T
+                               //if the x and y scaling is OK, using !P.T directly permits to use other projections
+                               //than those used implicitly by plplot. See @showhaus example for *DL
+        // case where we project 2D data on 3D: use plplot-like matrix.
+        DDouble az, alt, ay, scale;
+        ORIENTATION3D axisExchangeCode;
+
+        plplot3d = gdlConvertT3DMatrixToPlplotRotationMatrix( zValue, az, alt, ay, scale, axisExchangeCode);
+        if (plplot3d == NULL)
+        {
+          e->Throw("Illegal 3D transformation. (FIXME)");
+        }
+
+        Data3d.zValue = zValue;
+        Data3d.Matrix = plplot3d; //try to change for !P.T in future?
+        switch (axisExchangeCode) {
+          case NORMAL: //X->X Y->Y plane XY
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code012;
+            break;
+          case XY: // X->Y Y->X plane XY
+            Data3d.x0=0;
+            Data3d.y0=x0;
+            Data3d.xs=ys;
+            Data3d.ys=xs;
+            Data3d.code = code102;
+            break;
+          case XZ: // Y->Y X->Z plane YZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code210;
+            break;
+          case YZ: // X->X Y->Z plane XZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code021;
+            break;
+          case XZXY: //X->Y Y->Z plane YZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code120;
+            break;
+          case XZYZ: //X->Z Y->X plane XZ
+            Data3d.x0=x0;
+            Data3d.y0=y0;
+            Data3d.xs=xs;
+            Data3d.ys=ys;
+            Data3d.code = code201;
+            break;
+        }
+        actStream->stransform(gdl3dTo2dTransform, &Data3d);
+      }
+      //handle clipping
+      bool doClip=(e->KeywordSet("CLIP")||e->KeywordSet("NOCLIP"));
+      // make all clipping computations BEFORE setting graphic properties (color, size)
+      bool stopClip=false;
+      if ( doClip )  if ( startClipping(e, actStream, false)==TRUE ) stopClip=true;
+      //properties
+//      int colorIx=e->KeywordIx ( "COLOR" ); bool doColor=false;
+//      if ( e->GetKW ( colorIx )!=NULL )
+//      {
+//        color=e->GetKWAs<DLongGDL>( colorIx ); doColor=true;
+//      }
+
+      // LINE_FILL, SPACING, LINESTYLE, ORIENTATION, THICK (thanks to JW)
+      static int line_fillIx=e->KeywordIx("LINE_FILL");
+      if ( e->KeywordSet(line_fillIx) )
+      {
+        PLINT ori=0, spa=1500;
 
-      static int spacingIx = e->KeywordIx("SPACING");
-      if (e->KeywordSet(spacingIx)) del = PLINT(1e4 * (*e->GetKWAs<DFloatGDL>(spacingIx))[0]);
-      
-      gkw_thick(e, actStream);
-      gkw_linestyle(e, actStream);
+        static int orientationIx=e->KeywordIx("ORIENTATION");
+        if ( e->KeywordSet(orientationIx) ) ori=PLINT(1e1*(*e->GetKWAs<DFloatGDL>(orientationIx))[0]);
+        static int spacingIx=e->KeywordIx("SPACING");
+        if ( e->KeywordSet(spacingIx) ) spa=PLINT(1e4*(*e->GetKWAs<DFloatGDL>(spacingIx))[0]);
 
-      actStream->psty(8);
-      actStream->pat(1, &inc, &del);
-    }
-    else 
-    {
-      actStream->psty(0);
-    }
+        gdlSetPenThickness(e, actStream);
+        gdlSetLineStyle(e, actStream);
 
-#ifdef USE_LIBPROJ4
-    if (mapSet)
-    {
-      for (SizeT i = 0; i < xEl; ++i) 
+        actStream->psty(8);
+        actStream->pat(1, &ori, &spa);
+      }
+      else
       {
-        idata.lam = (*xVal)[i] * DEG_TO_RAD;
-        idata.phi = (*yVal)[i] * DEG_TO_RAD;
-        odata = PJ_FWD(idata, ref);
-        (*xVal)[i] = odata.x;
-        (*yVal)[i] = odata.y;
+        actStream->psty(0);
       }
-    }
-#endif
+      gdlSetGraphicsForegroundColorFromKw(e, actStream); //COLOR
+      gdlSetLineStyle(e, actStream); //LINESTYLE
+      gdlSetPenThickness(e, actStream); //THICK
 
-  } // }}}
+      if (real3d)
+      {
+        //try first if the matrix is a plplot-compatible one
+        DDouble az, alt, ay, scale;
+        ORIENTATION3D axisExchangeCode;
+        plplot3d = gdlConvertT3DMatrixToPlplotRotationMatrix( zValue, az, alt, ay, scale, axisExchangeCode);
+
+        if (plplot3d == NULL) //use the original !P.T matrix (better than nothing)
+        {
+          Warning("Using Illegal 3D transformation, continuing. (FIXME)");
+          plplot3d=gdlGetT3DMatrix(); //the original one
+          plplot3d_guard.Reset(plplot3d);
+          Data3d.code = code012;
+        } else
+        {
+          switch (axisExchangeCode) {
+          case NORMAL: //X->X Y->Y plane XY
+            Data3d.code = code012;
+            break;
+          case XY: // X->Y Y->X plane XY
+            Data3d.code = code102;
+            break;
+          case XZ: // Y->Y X->Z plane YZ
+            Data3d.code = code210;
+            break;
+          case YZ: // X->X Y->Z plane XZ
+            Data3d.code = code021;
+            break;
+          case XZXY: //X->Y Y->Z plane YZ
+            Data3d.code = code120;
+            break;
+          case XZYZ: //X->Z Y->X plane XZ
+            Data3d.code = code201;
+            break;
+          }
+        }
+        DDoubleGDL *xValou=new DDoubleGDL(dimension(xEl));
+        DDoubleGDL *yValou=new DDoubleGDL(dimension(yEl));
+        Guard<BaseGDL> xval_guard, yval_guard;
+        xval_guard.reset(xValou);
+        yval_guard.reset(yValou);
+        //rescale to normalized box before conversions --- works for both matrices.
+        gdl3dto2dProjectDDouble(gdlGetScaledNormalizedT3DMatrix(plplot3d),xVal,yVal,zVal,xValou,yValou,Data3d.code);
 
-    private: void call_plplot(EnvT* e, GDLGStream* actStream) // {{{
-    {
-      actStream->fill(xEl, static_cast<PLFLT*>(&(*xVal)[0]), static_cast<PLFLT*>(&(*yVal)[0]));
-    } // }}}
+        actStream->fill(xEl, static_cast<PLFLT*>(&(*xValou)[0]), static_cast<PLFLT*>(&(*yValou)[0]));
 
-    private: virtual void post_call(EnvT*, GDLGStream*) // {{{
-    {
+      }
+      else  actStream->fill(xEl, static_cast<PLFLT*>(&(*xVal)[0]), static_cast<PLFLT*>(&(*yVal)[0]));
+      if (stopClip) stopClipping(actStream);
     } // }}}
 
+  private:
+
+    virtual void post_call(EnvT*, GDLGStream *actStream) // {{{
+    {
+      if (doT3d && !real3d)
+      {
+        plplot3d_guard.Reset(plplot3d);
+        actStream->stransform(NULL,NULL);
+      }
+      actStream->RestoreLayout();
+      actStream->lsty(1); //reset linestyle
+      actStream->psty(0); //reset fill
+    }
   };
 
   void polyfill(EnvT* e)
   {
     polyfill_call polyfill;
-    polyfill.call(e, 1); 
+    polyfill.call(e, 1);
   }
 
 } // namespace
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting_shade_surf.cpp gdl/src/plotting_shade_surf.cpp
--- gdl-0.9.3/src/plotting_shade_surf.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/plotting_shade_surf.cpp	2013-05-10 11:04:49.000000000 -0600
@@ -0,0 +1,400 @@
+/***************************************************************************
+                       plotting_shade_surf.cpp  -  GDL routines for plotting
+                             -------------------
+    begin                : May 07 2013
+    copyright            : (C) 2002-2011 by Marc Schellens et al.
+    email                : m_schellens@users.sf.net
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "includefirst.hpp"
+#include "plotting.hpp"
+#include "math_utl.hpp"
+
+namespace lib
+{
+  using namespace std;
+
+// shared parameter
+  static DDouble lightSourcePos[3]={0,0,1.0};
+
+  class shade_surf_call: public plotting_routine_call
+  {
+    DDoubleGDL *zVal, *yVal, *xVal;
+    Guard<BaseGDL> xval_guard, yval_guard, p0_guard;
+    SizeT xEl, yEl, zEl;
+    DDouble xStart, xEnd, yStart, yEnd, zStart, zEnd, datamax, datamin;
+    bool nodata;
+    ORIENTATION3D axisExchangeCode;
+    bool xLog;
+    bool yLog;
+    bool zLog;
+  private:
+    bool handle_args (EnvT* e)
+    {
+      xLog=e->KeywordSet ( "XLOG" );
+      yLog=e->KeywordSet ( "YLOG" );
+      zLog=e->KeywordSet ( "ZLOG" );
+      if ( nParam ( )==1 )
+      {
+        if ( (e->GetNumericArrayParDefined ( 0 ))->Rank ( )!=2 )
+          e->Throw ( "Array must have 2 dimensions: "
+                     +e->GetParString ( 0 ) );
+
+        BaseGDL* p0=e->GetNumericArrayParDefined ( 0 )->Transpose ( NULL );
+        zVal=static_cast<DDoubleGDL*>
+        ( p0->Convert2 ( GDL_DOUBLE, BaseGDL::COPY ) );
+        p0_guard.reset ( p0 ); // delete upon exit
+
+        if ( zVal->Rank ( )!=2 )
+          e->Throw ( "Array must have 2 dimensions: "
+                     +e->GetParString ( 0 ) );
+
+        xEl=zVal->Dim ( 1 );
+        yEl=zVal->Dim ( 0 );
+
+        xVal=new DDoubleGDL ( dimension ( xEl ), BaseGDL::INDGEN );
+        xval_guard.reset ( xVal ); // delete upon exit
+        if (xLog) xVal->Inc();
+        yVal=new DDoubleGDL ( dimension ( yEl ), BaseGDL::INDGEN );
+        yval_guard.reset ( yVal ); // delete upon exit
+        if (yLog) yVal->Inc();
+      }
+      else if ( nParam ( )==2||nParam ( )>3 )
+      {
+        e->Throw ( "Incorrect number of arguments." );
+      }
+      else
+      {
+        BaseGDL* p0=e->GetNumericArrayParDefined ( 0 )->Transpose ( NULL );
+        zVal=static_cast<DDoubleGDL*>
+        ( p0->Convert2 ( GDL_DOUBLE, BaseGDL::COPY ) );
+        p0_guard.reset ( p0 ); // delete upon exit
+
+        if ( zVal->Rank ( )!=2 )
+          e->Throw ( "Array must have 2 dimensions: "
+                     +e->GetParString ( 0 ) );
+        xVal=e->GetParAs< DDoubleGDL>( 1 );
+        yVal=e->GetParAs< DDoubleGDL>( 2 );
+
+        if ( xVal->Rank ( )!=1 )
+          e->Throw ( "Unable to handle non-vectorial array "+e->GetParString ( 1 )+" (FIXME!)" );
+
+        if ( yVal->Rank ( )!=1 )
+          e->Throw ( "Unable to handle non-vectorial array "+e->GetParString ( 1 )+" (FIXME!)" );
+
+        if ( xVal->Rank ( )==1 )
+        {
+          xEl=xVal->Dim ( 0 );
+
+          if ( xEl!=zVal->Dim ( 1 ) )
+            e->Throw ( "X, Y, or Z array dimensions are incompatible." );
+        }
+
+        if ( yVal->Rank ( )==1 )
+        {
+          yEl=yVal->Dim ( 0 );
+
+          if ( yEl!=zVal->Dim ( 0 ) )
+            e->Throw ( "X, Y, or Z array dimensions are incompatible." );
+        }
+
+      }
+
+      GetMinMaxVal ( xVal, &xStart, &xEnd );
+      GetMinMaxVal ( yVal, &yStart, &yEnd );
+      //XRANGE and YRANGE overrides all that, but  Start/End should be recomputed accordingly
+      DDouble xAxisStart, xAxisEnd, yAxisStart, yAxisEnd;
+      bool setx=gdlGetDesiredAxisRange(e, "X", xAxisStart, xAxisEnd);
+      bool sety=gdlGetDesiredAxisRange(e, "Y", yAxisStart, yAxisEnd);
+      if(setx && sety)
+      {
+        xStart=xAxisStart;
+        xEnd=xAxisEnd;
+        yStart=yAxisStart;
+        yEnd=yAxisEnd;
+      }
+      else if (sety)
+      {
+        yStart=yAxisStart;
+        yEnd=yAxisEnd;
+        //must compute min-max for other axis!
+        {
+          gdlDoRangeExtrema(yVal,xVal,xStart,xEnd,yStart,yEnd);
+        }
+      }
+      else if (setx)
+      {
+        xStart=xAxisStart;
+        xEnd=xAxisEnd;
+        //must compute min-max for other axis!
+        {
+          gdlDoRangeExtrema(xVal,yVal,yStart,yEnd,xStart,xEnd);
+        }
+      }
+  #undef UNDEF_RANGE_VALUE
+      // z range
+      datamax=0.0;
+      datamin=0.0;
+      GetMinMaxVal ( zVal, &datamin, &datamax );
+      zStart=datamin;
+      zEnd=datamax;
+      gdlGetDesiredAxisRange(e, "Z", zStart, zEnd);
+
+        return false;
+    } 
+
+  private:
+    void old_body (EnvT* e, GDLGStream* actStream) // {{{
+    {
+      //T3D
+      static int t3dIx = e->KeywordIx( "T3D");
+      bool doT3d=e->KeywordSet(t3dIx);
+      //ZVALUE
+      static int zvIx = e->KeywordIx( "ZVALUE");
+      DDouble zValue=0.0;
+      e->AssureDoubleScalarKWIfPresent ( zvIx, zValue );
+      zValue=min(zValue,0.999999); //to avoid problems with plplot
+      //SAVE
+      static int savet3dIx = e->KeywordIx( "SAVE");
+      bool saveT3d=e->KeywordSet(savet3dIx);
+      //NODATA
+      static int nodataIx = e->KeywordIx( "NODATA");
+      nodata=e->KeywordSet(nodataIx);
+      //SHADES
+      static int shadesIx = e->KeywordIx( "SHADES");
+      BaseGDL* shadevalues=e->GetKW ( shadesIx );
+      bool doShade=(shadevalues != NULL); //... But 3d mesh will be colorized anyway!
+      if (doShade) Warning ( "SHADE_SURF: Using Fixed (Z linear) Shade Values Only (FIXME)." );
+      // [XYZ]STYLE
+      DLong xStyle=0, yStyle=0, zStyle=0; ;
+      gdlGetDesiredAxisStyle(e, "X", xStyle);
+      gdlGetDesiredAxisStyle(e, "Y", yStyle);
+      gdlGetDesiredAxisStyle(e, "Z", zStyle);
+
+      //check here since after AutoIntvAC values will be good but arrays passed
+      //to plplot will be bad...
+      if ( xLog && xStart<=0.0 )
+      {
+        Warning ( "SHADE_SURF: Infinite x plot range." );
+        nodata=true;
+      }
+      if ( yLog && yStart<=0.0 )
+      {
+        Warning ( "SHADE_SURF: Infinite y plot range." );
+        nodata=true;
+      }
+      if ( zLog && zStart<=0.0 ) Warning ( "SHADE_SURF: Infinite z plot range." );
+
+
+      if ( ( xStyle&1 )!=1 )
+      {
+        PLFLT intv=AutoIntvAC ( xStart, xEnd, xLog );
+      }
+
+      if ( ( yStyle&1 )!=1 )
+      {
+        PLFLT intv=AutoIntvAC ( yStart, yEnd, yLog );
+      }
+
+      bool hasMinVal=e->KeywordPresent("MIN_VALUE");
+      bool hasMaxVal=e->KeywordPresent("MAX_VALUE");
+      DDouble minVal=datamin;
+      DDouble maxVal=datamax;
+      e->AssureDoubleScalarKWIfPresent ( "MIN_VALUE", minVal );
+      e->AssureDoubleScalarKWIfPresent ( "MAX_VALUE", maxVal );
+
+      if ( minVal>zEnd || maxVal<zStart) nodata=true; //do not complain but do nothing.
+
+      // then only apply expansion  of axes:
+      if ( ( zStyle&1 )!=1 )
+      {
+        PLFLT intv=AutoIntvAC ( zStart, zEnd, zLog );
+      }
+
+      // background BEFORE next plot since it is the only place plplot may redraw the background...
+      gdlSetGraphicsBackgroundColorFromKw ( e, actStream ); //BACKGROUND
+      gdlNextPlotHandlingNoEraseOption(e, actStream);     //NOERASE
+
+      gdlSetPlotCharsize(e, actStream);
+
+      // Deal with T3D options -- either present and we have to deduce az and alt contained in it,
+      // or absent and we have to compute !P.T from az and alt.
+
+      PLFLT alt=30.0;
+      PLFLT az=30.0;
+      //set az and ax (alt)
+      DFloat alt_change=alt;
+      e->AssureFloatScalarKWIfPresent("AX", alt_change);
+      alt=alt_change;
+
+      alt=fmod(alt,360.0); //restrict between 0 and 90 for plplot!
+      if (alt > 90.0 || alt < 0.0)
+      {
+        e->Throw ( "SHADE_SURF: AX restricted to [0-90] range by plplot (fix plplot!)" );
+      }
+      DFloat az_change=az;
+      e->AssureFloatScalarKWIfPresent("AZ", az_change);
+      az=az_change;
+
+      //now we are in plplot different kind of 3d
+      DDoubleGDL* plplot3d;
+      DDouble ay, scale; //not useful at this time
+      if (doT3d) //convert to this world...
+      {
+
+        plplot3d=gdlConvertT3DMatrixToPlplotRotationMatrix(zValue, az, alt, ay, scale, axisExchangeCode);
+        if (plplot3d == NULL)
+        {
+          e->Throw ( "SHADE_SURF: Illegal 3D transformation." );
+        }
+      }
+      else //make the transformation ourselves
+      {
+        scale=1/sqrt(3);
+        //Compute transformation matrix with plplot conventions:
+        plplot3d=gdlComputePlplotRotationMatrix( az, alt, zValue,scale);
+        // save !P.T if asked to...
+        if (saveT3d) //will use ax and az values...
+        {
+          DDoubleGDL* t3dMatrix=plplot3d->Dup();
+          SelfTranspose3d(t3dMatrix);
+          static DStructGDL* pStruct=SysVar::P();
+          static unsigned tTag=pStruct->Desc()->TagIndex("T");
+          for (int i=0; i<t3dMatrix->N_Elements(); ++i )(*static_cast<DDoubleGDL*>(pStruct->GetTag(tTag, 0)))[i]=(*t3dMatrix)[i];
+          GDLDelete(t3dMatrix);
+        }
+      }
+
+      if ( gdlSet3DViewPortAndWorldCoordinates(e, actStream, plplot3d, xLog, yLog,
+        xStart, xEnd, yStart, yEnd, zStart, zEnd, zLog)==FALSE ) return;
+
+      gdlSetPlotCharthick(e,actStream);
+
+
+      if (xLog) xStart=log10(xStart);
+      if (yLog) yStart=log10(yStart);
+      if (zLog) zStart=log10(zStart);
+      if (xLog) xEnd=log10(xEnd);
+      if (yLog) yEnd=log10(yEnd);
+      if (zLog) zEnd=log10(zEnd);
+
+       actStream->w3d(scale,scale,scale*(1.0-zValue),
+                     xStart, xEnd, yStart, yEnd, zStart, zEnd,
+                     alt, az);
+
+
+      //Draw 3d mesh before axes
+      // PLOT ONLY IF NODATA=0
+      if (!nodata)
+      {
+        //use of intermediate map for correct handling of blanking values and nans.
+        PLFLT ** map;
+        actStream->Alloc2dGrid( &map, xEl, yEl);
+        for ( SizeT i=0, k=0; i<xEl; i++ )
+        {
+          for ( SizeT j=0; j<yEl; j++)
+          { //plplot does not like NaNs and any other terribly large gradient!
+            PLFLT v=(*zVal)[k++];
+            if (zLog)
+            {
+              v= log10(v);
+              PLFLT miv=log10(minVal);
+              PLFLT mav=log10(maxVal);
+              if ( !isfinite(v) ) v=miv;
+              if ( hasMinVal && v < miv) v=miv;
+              if ( hasMaxVal && v > mav) v=mav;
+            }
+            else
+            {
+              if ( !isfinite(v) ) v=minVal;
+              if ( hasMinVal && v < minVal) v=minVal;
+              if ( hasMaxVal && v > maxVal) v=maxVal;
+            }
+            map[i][j] = v;
+          }
+        }
+        // 1 types of grid only: 1D X and Y.
+        PLcGrid cgrid1; // X and Y independent deformation
+        PLFLT* xg1;
+        PLFLT* yg1;
+        xg1 = new PLFLT[xEl];
+        yg1 = new PLFLT[yEl];
+        cgrid1.xg = xg1;
+        cgrid1.yg = yg1;
+        cgrid1.nx = xEl;
+        cgrid1.ny = yEl;
+        for ( SizeT i=0; i<cgrid1.nx; i++ ) cgrid1.xg[i] = (*xVal)[i];
+        for ( SizeT i=0; i<cgrid1.ny; i++ ) cgrid1.yg[i] = (*yVal)[i];
+        //apply projection transformations:
+        //not until plplot accepts 2D X Y!
+        //apply plot options transformations:
+        if (xLog) for ( SizeT i=0; i<cgrid1.nx; i++ ) cgrid1.xg[i] = cgrid1.xg[i]>0?log10(cgrid1.xg[i]):1E-12;  // #define EXTENDED_DEFAULT_LOGRANGE 12
+        if (yLog) for ( SizeT i=0; i<cgrid1.ny; i++ ) cgrid1.yg[i] = cgrid1.yg[i]>0?log10(cgrid1.yg[i]):1E-12;
+
+        // Important: make all clipping computations BEFORE setting graphic properties (color, size)
+        bool doClip=(e->KeywordSet("CLIP")||e->KeywordSet("NOCLIP"));
+        bool stopClip=false;
+        if ( doClip )  if ( startClipping(e, actStream, false)==TRUE ) stopClip=true;
+
+        gdlSetGraphicsForegroundColorFromKw ( e, actStream );
+        //mesh option
+        PLINT meshOpt;
+        actStream->lightsource(lightSourcePos[0],lightSourcePos[1],lightSourcePos[2]);
+        meshOpt=(doShade)?MAG_COLOR:0;
+        if (e->KeywordSet ( "SKIRT" )) meshOpt+=DRAW_SIDES;
+        actStream->surf3d(xg1,yg1,map,cgrid1.nx,cgrid1.ny,meshOpt,NULL,0);
+
+        if (stopClip) stopClipping(actStream);
+//Clean alllocated data struct
+        delete[] xg1;
+        delete[] yg1;
+        actStream->Free2dGrid(map, xEl, yEl);
+      }
+      //Draw axes with normal color!
+      gdlSetGraphicsForegroundColorFromKw ( e, actStream ); //COLOR
+      gdlBox3(e, actStream, xStart, xEnd, yStart, yEnd, zStart, zEnd, xLog, yLog, zLog, true);
+    } 
+
+  private:
+
+    void call_plplot (EnvT* e, GDLGStream* actStream) 
+    {
+    } 
+
+  private:
+
+    virtual void post_call (EnvT*, GDLGStream* actStream) 
+    {
+      actStream->lsty(1);//reset linestyle
+      actStream->sizeChar(1.0);
+    } 
+
+ }; // SHADE_SURF_call class
+
+  void shade_surf(EnvT* e)
+  {
+    shade_surf_call shade_surf;
+    shade_surf.call(e, 1);
+  }
+
+ void set_shading(EnvT* e)
+ {
+    DDoubleGDL *light;
+    int lightIx=e->KeywordIx ( "LIGHT" );
+    if ( e->GetKW ( lightIx )!=NULL )
+    {
+      light=e->GetKWAs<DDoubleGDL>( lightIx );
+      if (light->N_Elements()>3) e->Throw("Keyword array parameter LIGHT must have from 1 to 3 elements.");
+      for (SizeT i=0; i< light->N_Elements(); ++i) lightSourcePos[i]=(*light)[i];
+    }
+ }
+} // namespace
\ No newline at end of file
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting_surface.cpp gdl/src/plotting_surface.cpp
--- gdl-0.9.3/src/plotting_surface.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting_surface.cpp	2013-05-16 12:36:33.664856306 -0600
@@ -17,511 +17,438 @@
 
 #include "includefirst.hpp"
 #include "plotting.hpp"
+#include "math_utl.hpp"
 
-namespace lib {
+namespace lib
+{
+
+  //XRANGE etc behaviour not as IDL (in some ways, better!)
+  //TBD: LEGO
 
   using namespace std;
 
-  class surface_call : public plotting_routine_call
+// shared parameter
+  static bool xLog;
+  static bool yLog;
+  static bool zLog;
+
+  class surface_call: public plotting_routine_call
   {
-    DDouble xStart, xEnd, yStart, yEnd, zStart, zEnd;
-    bool xLog, yLog, zLog;
     DDoubleGDL *zVal, *yVal, *xVal;
-    auto_ptr<BaseGDL> xval_guard, yval_guard;
+    Guard<BaseGDL> xval_guard, yval_guard, p0_guard;
     SizeT xEl, yEl, zEl;
-
-    private: bool handle_args(EnvT* e) // {{{
+    DDouble xStart, xEnd, yStart, yEnd, zStart, zEnd, datamax, datamin;
+    bool nodata;
+    ORIENTATION3D axisExchangeCode;
+  private:
+    bool handle_args (EnvT* e)
     {
+      xLog=e->KeywordSet ( "XLOG" );
+      yLog=e->KeywordSet ( "YLOG" );
+      zLog=e->KeywordSet ( "ZLOG" );
+      if ( nParam ( )==1 )
+      {
+        if ( (e->GetNumericArrayParDefined ( 0 ))->Rank ( )!=2 )
+          e->Throw ( "Array must have 2 dimensions: "
+                     +e->GetParString ( 0 ) );
+
+        BaseGDL* p0=e->GetNumericArrayParDefined ( 0 )->Transpose ( NULL );
+        zVal=static_cast<DDoubleGDL*>
+        ( p0->Convert2 ( GDL_DOUBLE, BaseGDL::COPY ) );
+        p0_guard.reset ( p0 ); // delete upon exit
+
+        if ( zVal->Rank ( )!=2 )
+          e->Throw ( "Array must have 2 dimensions: "
+                     +e->GetParString ( 0 ) );
+
+        xEl=zVal->Dim ( 1 );
+        yEl=zVal->Dim ( 0 );
+
+        xVal=new DDoubleGDL ( dimension ( xEl ), BaseGDL::INDGEN );
+        xval_guard.reset ( xVal ); // delete upon exit
+        if (xLog) xVal->Inc();
+        yVal=new DDoubleGDL ( dimension ( yEl ), BaseGDL::INDGEN );
+        yval_guard.reset ( yVal ); // delete upon exit
+        if (yLog) yVal->Inc();
+      }
+      else if ( nParam ( )==2||nParam ( )>3 )
+      {
+        e->Throw ( "Incorrect number of arguments." );
+      }
+      else
+      {
+        BaseGDL* p0=e->GetNumericArrayParDefined ( 0 )->Transpose ( NULL );
+        zVal=static_cast<DDoubleGDL*>
+        ( p0->Convert2 ( GDL_DOUBLE, BaseGDL::COPY ) );
+        p0_guard.reset ( p0 ); // delete upon exit
+
+        if ( zVal->Rank ( )!=2 )
+          e->Throw ( "Array must have 2 dimensions: "
+                     +e->GetParString ( 0 ) );
+        xVal=e->GetParAs< DDoubleGDL>( 1 );
+        yVal=e->GetParAs< DDoubleGDL>( 2 );
 
-      if (nParam() == 2 || nParam() > 3) 
-        e->Throw( "Incorrect number of arguments.");
-    
-      BaseGDL* p0 = e->GetNumericArrayParDefined( 0)->Transpose( NULL);
-      auto_ptr<BaseGDL> p0_guard;
-      zVal = static_cast<DDoubleGDL*> (p0->Convert2( GDL_DOUBLE, BaseGDL::COPY));
-      p0_guard.reset( p0); // delete upon exit
-
-      if(zVal->Dim(0) == 1)
-        e->Throw( "Array must have 2 dimensions:" +e->GetParString(0));    
-
-      xEl = zVal->Dim(1);
-      yEl = zVal->Dim(0);
-      if (nParam() == 1) 
-      {
-        xVal = new DDoubleGDL( dimension( xEl), BaseGDL::INDGEN);
-        xval_guard.reset( xVal); // delete upon exit
-        yVal = new DDoubleGDL( dimension( yEl), BaseGDL::INDGEN);
-        yval_guard.reset( yVal); // delete upon exit
-      }
-
-      if (nParam() == 3) 
-      {
-      
-        xVal = e->GetParAs< DDoubleGDL>( 1);
-        yVal = e->GetParAs< DDoubleGDL>( 2);
-
-        if (xVal->Rank() > 2)
-          e->Throw( "X, Y, or Z array dimensions are incompatible.");
-      
-        if (yVal->Rank() > 2)
-          e->Throw( "X, Y, or Z array dimensions are incompatible.");
-      
-        if (xVal->Rank() == 1) {
-          if (xEl != xVal->Dim(0))
-            e->Throw( "X, Y, or Z array dimensions are incompatible.");
-	}
-      
-        if (yVal->Rank() == 1) {
-          if (yEl != yVal->Dim(0))
-            e->Throw( "X, Y, or Z array dimensions are incompatible.");
-        }
+        if ( xVal->Rank ( )!=1 )
+          e->Throw ( "Unable to handle non-vectorial array "+e->GetParString ( 1 )+" (FIXME!)" );
 
-        if (xVal->Rank() == 2) {
-          if((xVal->Dim(0) != xEl) && (xVal->Dim(1) != yEl))
-            e->Throw( "X, Y, or Z array dimensions are incompatible.");
+        if ( yVal->Rank ( )!=1 )
+          e->Throw ( "Unable to handle non-vectorial array "+e->GetParString ( 1 )+" (FIXME!)" );
+
+        if ( xVal->Rank ( )==1 )
+        {
+          xEl=xVal->Dim ( 0 );
+
+          if ( xEl!=zVal->Dim ( 1 ) )
+            e->Throw ( "X, Y, or Z array dimensions are incompatible." );
         }
-      
-        if (yVal->Rank() == 2) 
+
+        if ( yVal->Rank ( )==1 )
         {
-	  if((yVal->Dim(0) != xEl) && (yVal->Dim(1) != yEl))
-            e->Throw( "X, Y, or Z array dimensions are incompatible.");
+          yEl=yVal->Dim ( 0 );
+
+          if ( yEl!=zVal->Dim ( 0 ) )
+            e->Throw ( "X, Y, or Z array dimensions are incompatible." );
         }
+
       }
-      return false;
-    } // }}}
 
-  private: void old_body( EnvT* e, GDLGStream* actStream) // {{{
-  {
+      GetMinMaxVal ( xVal, &xStart, &xEnd );
+      GetMinMaxVal ( yVal, &yStart, &yEnd );
+      //XRANGE and YRANGE overrides all that, but  Start/End should be recomputed accordingly
+      DDouble xAxisStart, xAxisEnd, yAxisStart, yAxisEnd;
+      bool setx=gdlGetDesiredAxisRange(e, "X", xAxisStart, xAxisEnd);
+      bool sety=gdlGetDesiredAxisRange(e, "Y", yAxisStart, yAxisEnd);
+      if(setx && sety)
+      {
+        xStart=xAxisStart;
+        xEnd=xAxisEnd;
+        yStart=yAxisStart;
+        yEnd=yAxisEnd;
+      }
+      else if (sety)
+      {
+        yStart=yAxisStart;
+        yEnd=yAxisEnd;
+        //must compute min-max for other axis!
+        {
+          gdlDoRangeExtrema(yVal,xVal,xStart,xEnd,yStart,yEnd);
+        }
+      }
+      else if (setx)
+      {
+        xStart=xAxisStart;
+        xEnd=xAxisEnd;
+        //must compute min-max for other axis!
+        {
+          gdlDoRangeExtrema(xVal,yVal,yStart,yEnd,xStart,xEnd);
+        }
+      }
+  #undef UNDEF_RANGE_VALUE
+      // z range
+      datamax=0.0;
+      datamin=0.0;
+      GetMinMaxVal ( zVal, &datamin, &datamax );
+      zStart=datamin;
+      zEnd=datamax;
+      gdlGetDesiredAxisRange(e, "Z", zStart, zEnd);
 
-    // !P 
-    DLong p_background, p_noErase, p_color, p_psym, p_linestyle;
-    DFloat p_symsize, p_charsize, p_thick, p_ticklen; 
-    DString p_title, p_subTitle; 
-
-    GetPData( p_background,
-	      p_noErase, p_color, p_psym, p_linestyle,
-	      p_symsize, p_charsize, p_thick,
-	      p_title, p_subTitle, p_ticklen);
-
-    // !X, !Y, !Z (also used below)
-    static DStructGDL* xStruct = SysVar::X();
-    static DStructGDL* yStruct = SysVar::Y();
-    static DStructGDL* zStruct = SysVar::Z();
-
-    DLong xStyle, yStyle, zStyle;
-    DString xTitle, yTitle, zTitle; 
-    DFloat x_CharSize, y_CharSize, z_CharSize; 
-    DFloat xMarginL, xMarginR, yMarginB, yMarginF, zMarginB, zMarginT; 
-    DFloat xTicklen, yTicklen, zTicklen;
-
-    GetAxisData( xStruct, xStyle, xTitle, x_CharSize, xMarginL, xMarginR, xTicklen);
-    GetAxisData( yStruct, yStyle, yTitle, y_CharSize, yMarginB, yMarginF, yTicklen);
-    GetAxisData( zStruct, zStyle, zTitle, z_CharSize, zMarginB, zMarginT, zTicklen);
-    
-    // [XY]STYLE
-    e->AssureLongScalarKWIfPresent( "XSTYLE", xStyle);
-    e->AssureLongScalarKWIfPresent( "YSTYLE", yStyle);
-    e->AssureLongScalarKWIfPresent( "ZSTYLE", zStyle);
-
-    // TITLE
-    DString title = p_title;
-    DString subTitle = p_subTitle;
-    e->AssureStringScalarKWIfPresent( "TITLE", title);
-    e->AssureStringScalarKWIfPresent( "SUBTITLE", subTitle);
-
-    // AXIS TITLE
-    e->AssureStringScalarKWIfPresent( "XTITLE", xTitle);
-    e->AssureStringScalarKWIfPresent( "YTITLE", yTitle);
-    e->AssureStringScalarKWIfPresent( "ZTITLE", zTitle);
-
-    // MARGIN (in characters)
-    static int xMarginEnvIx = e->KeywordIx( "XMARGIN"); 
-    static int yMarginEnvIx = e->KeywordIx( "YMARGIN"); 
-    static int zMarginEnvIx = e->KeywordIx( "ZMARGIN"); 
-    BaseGDL* xMargin = e->GetKW( xMarginEnvIx);
-    BaseGDL* yMargin = e->GetKW( yMarginEnvIx);
-    BaseGDL* zMargin = e->GetKW( zMarginEnvIx);
-    if( xMargin != NULL)
-      {
-	if( xMargin->N_Elements() > 2)
-	  e->Throw( "Keyword array parameter XMARGIN"
-		    " must have from 1 to 2 elements.");
-	auto_ptr<DFloatGDL> guard;
-	DFloatGDL* xMarginFl = static_cast<DFloatGDL*>
-	  ( xMargin->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	guard.reset( xMarginFl);
-	xMarginL = (*xMarginFl)[0];
-	if( xMarginFl->N_Elements() > 1)
-	  xMarginR = (*xMarginFl)[1];
-      }
-    if( yMargin != NULL)
-      {
-	if( yMargin->N_Elements() > 2)
-	  e->Throw( "Keyword array parameter YMARGIN"
-		    " must have from 1 to 2 elements.");
-	auto_ptr<DFloatGDL> guard;
-	DFloatGDL* yMarginFl = static_cast<DFloatGDL*>
-	  ( yMargin->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	guard.reset( yMarginFl);
-	yMarginB = (*yMarginFl)[0];
-	if( yMarginFl->N_Elements() > 1)
-	  yMarginF = (*yMarginFl)[1];
-      }
-    if( zMargin != NULL)
-      {
-	if( zMargin->N_Elements() > 2)
-	  e->Throw( "Keyword array parameter ZMARGIN"
-		    " must have from 1 to 2 elements.");
-	auto_ptr<DFloatGDL> guard;
-	DFloatGDL* zMarginFl = static_cast<DFloatGDL*>
-	  ( zMargin->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	guard.reset( zMarginFl);
-	zMarginB = (*zMarginFl)[0];
-	if( zMarginFl->N_Elements() > 1)
-	  zMarginT = (*zMarginFl)[1];
-      }
-
-    // x and y and z range
-    GetMinMaxVal( xVal, &xStart, &xEnd);
-    GetMinMaxVal( yVal, &yStart, &yEnd);
-    GetMinMaxVal( zVal, &zStart, &zEnd);
-
-    xLog = e->KeywordSet( "XLOG");
-    yLog = e->KeywordSet( "YLOG");
-    zLog = e->KeywordSet( "ZLOG");
-
-    if ((xStyle & 1) != 1) {
-      PLFLT intv = AutoIntvAC(xStart, xEnd, false, xLog );
-    }   
-
-    if ((yStyle & 1) != 1) {
-      PLFLT intv = AutoIntvAC(yStart, yEnd, false, yLog );
-    }   
-    
-    if ((zStyle & 1) != 1) {
-      PLFLT intv = AutoIntvAC(zStart, zEnd, false, zLog );
+        return false;
     } 
 
-    //[x|y|z]range keyword
-    static int zRangeEnvIx = e->KeywordIx("ZRANGE");
-    static int yRangeEnvIx = e->KeywordIx("YRANGE");
-    static int xRangeEnvIx = e->KeywordIx("XRANGE");
-    BaseGDL* xRange = e->GetKW( xRangeEnvIx);
-    BaseGDL* yRange = e->GetKW( yRangeEnvIx);
-    BaseGDL* zRange = e->GetKW( zRangeEnvIx);
-    
-    if(xRange != NULL) 
-      {
-	if(xRange->N_Elements() != 2)
-	  e->Throw("Keyword array parameter XRANGE"
-		   " must have 2 elements.");
-	auto_ptr<DFloatGDL> guard;
-	DFloatGDL* xRangeF = static_cast<DFloatGDL*>
-	  ( xRange->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	guard.reset( xRangeF);
-	xStart = (*xRangeF)[0];
-	xEnd = (*xRangeF)[1];
-      }
-
-    if(yRange != NULL)
-      {
-	if(yRange->N_Elements() != 2)
-	  e->Throw("Keyword array parameter YRANGE"
-		   " must have 2 elements.");
-	auto_ptr<DFloatGDL> guard;
-	DFloatGDL* yRangeF = static_cast<DFloatGDL*>
-	  ( yRange->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	guard.reset( yRangeF);
-	yStart = (*yRangeF)[0];
-	yEnd = (*yRangeF)[1];
-      }
-    if(zRange != NULL)
-      {
-	if(zRange->N_Elements() != 2)
-	  e->Throw("Keyword array parameter ZRANGE"
-		   " must have 2 elements.");
-	auto_ptr<DFloatGDL> guard;
-	DFloatGDL* zRangeF = static_cast<DFloatGDL*>
-	  ( zRange->Convert2( GDL_FLOAT, BaseGDL::COPY));
-	guard.reset( zRangeF);
-	zStart = (*zRangeF)[0];
-	zEnd = (*zRangeF)[1];
-      }
-
-    // AC is it useful ? Why not for Y ?
-    //if(xEnd == xStart) xEnd=xStart+1;
-
-    DDouble minVal = zStart;
-    DDouble maxVal = zEnd;
-    e->AssureDoubleScalarKWIfPresent( "MIN_VALUE", minVal);
-    e->AssureDoubleScalarKWIfPresent( "MAX_VALUE", maxVal);
-
-    if( xLog && xStart <= 0.0)
-      Warning( "SURFACE: Infinite x plot range.");
-    if( yLog && yStart <= 0.0)
-      Warning( "SURFACE: Infinite y plot range.");
-    if( zLog && zStart <= 0.0)
-      Warning( "SURFACE: Infinite z plot range.");
-
-    DLong noErase = p_noErase;
-    if( e->KeywordSet( "NOERASE")) noErase = 1;
-
-    DDouble ticklen = p_ticklen;
-    e->AssureDoubleScalarKWIfPresent( "TICKLEN", ticklen);
-
-    // POSITION
-    PLFLT xScale = 1.0;
-    PLFLT yScale = 1.0;
-    //    PLFLT scale = 1.0;
-    static int positionIx = e->KeywordIx( "POSITION"); 
-    DFloatGDL* pos = e->IfDefGetKWAs<DFloatGDL>( positionIx);
-    /*
-    PLFLT position[ 4] = { 0.0, 0.0, 1.0, 1.0};
-    if( pos != NULL)
-      {
-      for( SizeT i=0; i<4 && i<pos->N_Elements(); ++i)
-	position[ i] = (*pos)[ i];
-
-      xScale = position[2]-position[0];
-      yScale = position[3]-position[1];
-      //      scale = sqrt( pow( xScale,2) + pow( yScale,2));
-      }
-    */
-
-    // CHARSIZE
-    DDouble charsize = p_charsize;
-    e->AssureDoubleScalarKWIfPresent( "CHARSIZE", charsize);
-    if( charsize <= 0.0) charsize = 1.0;
-    //    charsize *= scale;
-
-    // AXIS CHARSIZE
-    DDouble xCharSize = x_CharSize;
-    e->AssureDoubleScalarKWIfPresent( "XCHARSIZE", xCharSize);
-    if( xCharSize <= 0.0) xCharSize = 1.0;
-
-    DDouble yCharSize = y_CharSize;
-    e->AssureDoubleScalarKWIfPresent( "YCHARSIZE", yCharSize);
-    if( yCharSize <= 0.0) yCharSize = 1.0;
-    //    yCharSize *= scale;
-
-    DDouble zCharSize = z_CharSize;
-    e->AssureDoubleScalarKWIfPresent( "ZCHARSIZE", zCharSize);
-    if( zCharSize <= 0.0) zCharSize = 1.0;
-
-
-    // THICK
-    DFloat thick = p_thick;
-    e->AssureFloatScalarKWIfPresent( "THICK", thick);
-
-    // *** start drawing
-    gkw_background(e, actStream);  //BACKGROUND   
-    gkw_color(e, actStream);       //COLOR
-
-    actStream->NextPlot( !noErase);
-    if( !noErase) actStream->Clear();
-
-    // plplot stuff
-    // set the charsize (scale factor)
-    DDouble charScale = 1.0;
-    DLongGDL* pMulti = SysVar::GetPMulti();
-    if( (*pMulti)[1] > 2 || (*pMulti)[2] > 2) charScale = 0.5;
-    actStream->schr( 0.0, charsize * charScale);
-
-#if 0
-    // get subpage in mm
-    PLFLT scrXL, scrXR, scrYB, scrYF;
-    actStream->gspa( scrXL, scrXR, scrYB, scrYF); 
-    PLFLT scrX = scrXR-scrXL;
-    PLFLT scrY = scrYF-scrYB;
-#endif
+  private:
+#define DPI (double)(4*atan(1.0))
+#define DEGTORAD DPI/180.0
 
-    // get char size in mm (default, actual)
-    PLFLT defH, actH;
-    actStream->gchr( defH, actH);
-
-    // CLIPPING
-    DDoubleGDL* clippingD=NULL;
-    DLong noclip=0;
-    e->AssureLongScalarKWIfPresent( "NOCLIP", noclip);
-    if(noclip == 0)
-      {
-	static int clippingix = e->KeywordIx( "CLIP"); 
-	clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
-      }
-    
-
-#if 0
-    // viewport and world coordinates
-    bool okVPWC = SetVP_WC( e, actStream, pos, clippingD, 
-			    xLog, yLog,
-			    xMarginL, xMarginR, yMarginB, yMarginT,
-			    xStart, xEnd, minVal, maxVal,(DLong)0);
-    if( !okVPWC) return;
+    void old_body (EnvT* e, GDLGStream* actStream) // {{{
+    {
+     //projection: would work only with 2D X and Y. Not supported here
+      bool mapSet=false;
+#ifdef USE_LIBPROJ4
+      static LPTYPE idata;
+      static XYTYPE odata;
+      static PROJTYPE* ref;
+      get_mapset ( mapSet );
+      if ( mapSet )
+      { // do nothing
+//        ref=map_init ( );
+//        if ( ref==NULL ) e->Throw ( "Projection initialization failed." );
+        // but warn that projection is not taken into account
+        Warning ( "SURFACE: Projection is set, but not taken into account (ony 1d X and Y) (FIX plplot first!)." );
+      }
 #endif
-    
+      //T3D
+      static int t3dIx = e->KeywordIx( "T3D");
+      bool doT3d=e->KeywordSet(t3dIx);
+      //ZVALUE
+      static int zvIx = e->KeywordIx( "ZVALUE");
+      DDouble zValue=0.0;
+      e->AssureDoubleScalarKWIfPresent ( zvIx, zValue );
+      zValue=min(zValue,0.999999); //to avoid problems with plplot
+      //SAVE
+      static int savet3dIx = e->KeywordIx( "SAVE");
+      bool saveT3d=e->KeywordSet(savet3dIx);
+      //NODATA
+      static int nodataIx = e->KeywordIx( "NODATA");
+      nodata=e->KeywordSet(nodataIx);
+      //SHADES
+      static int shadesIx = e->KeywordIx( "SHADES");
+      BaseGDL* shadevalues=e->GetKW ( shadesIx );
+      bool doShade=(shadevalues != NULL); //... But 3d mesh will be colorized anyway!
+      if (doShade) Warning ( "SHADE_SURF: Using Fixed (Z linear) Shade Values Only (FIXME)." );
+
+      // [XYZ]STYLE
+      DLong xStyle=0, yStyle=0, zStyle=0; ;
+      gdlGetDesiredAxisStyle(e, "X", xStyle);
+      gdlGetDesiredAxisStyle(e, "Y", yStyle);
+      gdlGetDesiredAxisStyle(e, "Z", zStyle);
+
+      //check here since after AutoIntvAC values will be good but arrays passed
+      //to plplot will be bad...
+      if ( xLog && xStart<=0.0 )
+      {
+        Warning ( "SURFACE: Infinite x plot range." );
+        nodata=true;
+      }
+      if ( yLog && yStart<=0.0 )
+      {
+        Warning ( "SURFACE: Infinite y plot range." );
+        nodata=true;
+      }
+      if ( zLog && zStart<=0.0 ) Warning ( "SURFACE: Infinite z plot range." );
 
-    //linestyle
-    DLong linestyle = p_linestyle ;
-    DLong temp_linestyle=0;
-    e->AssureLongScalarKWIfPresent( "LINESTYLE", temp_linestyle);
-
-    /*
-    if((temp_linestyle > 0) && (temp_linestyle < 9) )
-	linestyle=temp_linestyle;
-    else if((linestyle > 0) && (linestyle < 9) )
-	linestyle=linestyle+1;
-    else 
-	linestyle=1;
-    */
-
-    linestyle=temp_linestyle+1;
-
-    // pen thickness for axis
-    actStream->wid( 0);
-
-    // axis
-    string xOpt = "bcnst";
-    string yOpt = "bcnstv";
-
-    if( xLog) xOpt += "l";
-    if( yLog) yOpt += "l";
-
-#if 0    
-    // axis titles
-    actStream->schr( 0.0, actH/defH * xCharSize);
-    actStream->mtex("b",3.5,0.5,0.5,xTitle.c_str());
-    // the axis (separate for x and y axis because of charsize)
-    actStream->box( xOpt.c_str(), 0.0, 0, "", 0.0, 0);
-
-    actStream->schr( 0.0, actH/defH * yCharSize);
-    actStream->mtex("l",5.0,0.5,0.5,yTitle.c_str());
-    // the axis (separate for x and y axis because of charsize)
-    actStream->box( "", 0.0, 0, yOpt.c_str(), 0.0, 0);
-#endif
 
-    // pen thickness for plot
-    actStream->wid( static_cast<PLINT>(floor( thick-0.5)));
+      if ( ( xStyle&1 )!=1 )
+      {
+        PLFLT intv=AutoIntvAC ( xStart, xEnd, xLog );
+      }
+
+      if ( ( yStyle&1 )!=1 )
+      {
+        PLFLT intv=AutoIntvAC ( yStart, yEnd, yLog );
+      }
+
+      bool hasMinVal=e->KeywordPresent("MIN_VALUE");
+      bool hasMaxVal=e->KeywordPresent("MAX_VALUE");
+      DDouble minVal=datamin;
+      DDouble maxVal=datamax;
+      e->AssureDoubleScalarKWIfPresent ( "MIN_VALUE", minVal );
+      e->AssureDoubleScalarKWIfPresent ( "MAX_VALUE", maxVal );
 
+      if ( minVal>zEnd || maxVal<zStart) nodata=true; //do not complain but do nothing.
 
-    // plot the data
-    actStream->lsty(linestyle);
+      // then only apply expansion  of axes:
+      if ( ( zStyle&1 )!=1 )
+      {
+        PLFLT intv=AutoIntvAC ( zStart, zEnd, zLog );
+      }
 
-    actStream->vpor(0.0, 1.0, 0.0, .9);
-    //    actStream->wind(-0.8, 0.8, -0.8, .8);
-    actStream->wind( -1.0, 1.0, -0.9, 2.0 );
-    //    actStream->wind(-1.0, 1.0, -1.0, 1.5);
-
-    PLFLT alt = 30.0;
-    DFloat alt_change = alt;
-    e->AssureFloatScalarKWIfPresent( "AX", alt_change);
-    alt=alt_change;
-
-    PLFLT az = 30.0;
-    DFloat az_change = az;
-    e->AssureFloatScalarKWIfPresent( "AZ", az_change);
-    az=az_change;
-
-    actStream->w3d( 1.2, 1.2, 2.2,  // TODO!
-		    xStart, xEnd, yStart, yEnd, minVal, maxVal,
-		    alt, az);
-
-    actStream->box3( "bnstu", xTitle.c_str(), 0.0, 0,
-		     "bnstu", yTitle.c_str(), 0.0, 0,
-		     "bcdmnstuv", zTitle.c_str(), 0.0, 4 );
-
-
-    // 1 DIM X & Y
-    if (xVal->Rank() == 1 && yVal->Rank() == 1) {
-      
-      PLFLT** z;
-      actStream->Alloc2dGrid(&z,xEl,yEl);
-      for( SizeT ii=0; ii<xEl ; ii++) {
-	for( SizeT jj=0; jj<yEl ; jj++) {
-	  z[ii][jj] = (*zVal)[ii*yEl+jj];
-	}
-      }
-      actStream->mesh(static_cast<PLFLT*> (&(*xVal)[0]), 
-		      static_cast<PLFLT*> (&(*yVal)[0]), 
-		      z, (long int) xEl, (long int) yEl, 3);
-      //delete[] z;
-      if (z != NULL) { free((void *) z); z = NULL; }
-    }
-
-    // 2 DIM X & Y
-    if (xVal->Rank() == 2 && yVal->Rank() == 2) {
-
-      PLFLT** z1 = new PLFLT*[xEl];
-      PLFLT* xVec1 = new PLFLT[xEl];
-      PLFLT* yVec1 = new PLFLT[xEl];
-
-      for( SizeT j=0; j<yEl; j++) {
-	for( SizeT i=0; i<xEl; i++) {
-	  z1[i] = &(*zVal)[i*yEl+j];
-	  xVec1[i] = (*xVal)[j*xEl+i];
-	  yVec1[i] = (*yVal)[j*xEl+i];
-	}
-	//lib::mesh_nr(xVec1, yVec1, z1, (long int) xEl, 1,1);
-        actStream->mesh(xVec1, yVec1, z1, (long int) xEl, 1,1); 
-      }
-      delete[] z1;
-      delete[] xVec1;
-      delete[] yVec1;
-
-      //
-      PLFLT** z2 = new PLFLT*[yEl];
-      PLFLT* xVec2 = new PLFLT[yEl];
-      PLFLT* yVec2 = new PLFLT[yEl];
-      
-      for( SizeT j=0; j<xEl; j++) {
-	for( SizeT i=0; i< yEl; i++) {
-	  z2[i] = &(*zVal)[j*yEl+i];       
-	  xVec2[i] = (*xVal)[i*xEl+j];
-	  yVec2[i] = (*yVal)[i*xEl+j];
-	}
-	//lib::mesh_nr(xVec2, yVec2, z2, 1, (long int) yEl, 2);
-        actStream->mesh(xVec2, yVec2, z2, 1, (long int) yEl, 2); 
-      }
-      delete[] z2;
-      delete[] xVec2;
-      delete[] yVec2;
-    }
-
-    // TODO: not sure if this is also valid for 3D?
-    UpdateSWPlotStructs(actStream, xStart, xEnd, yStart, yEnd, xLog, yLog);
-
-    // title and sub title
-    actStream->schr( 0.0, 1.25*actH/defH);
-    actStream->mtex("t",1.25,0.5,0.5,title.c_str());
-    actStream->schr( 0.0, actH/defH); // charsize is reset here
-    actStream->mtex("b",5.4,0.5,0.5,subTitle.c_str());
-    
-  } // }}}
-
-    private: void call_plplot(EnvT* e, GDLGStream* actStream) // {{{
-    { 
-    } // }}}
+      // background BEFORE next plot since it is the only place plplot may redraw the background...
+      gdlSetGraphicsBackgroundColorFromKw ( e, actStream ); //BACKGROUND
+      gdlNextPlotHandlingNoEraseOption(e, actStream);     //NOERASE
 
-    private: virtual void post_call(EnvT*, GDLGStream* actStream) // {{{
+      gdlSetPlotCharsize(e, actStream);
+
+      // Deal with T3D options -- either present and we have to deduce az and alt contained in it,
+      // or absent and we have to compute !P.T from az and alt.
+
+      PLFLT alt=30.0;
+      PLFLT az=30.0;
+      //set az and ax (alt)
+      DFloat alt_change=alt;
+      e->AssureFloatScalarKWIfPresent("AX", alt_change);
+      alt=alt_change;
+
+      alt=fmod(alt,360.0); //restrict between 0 and 90 for plplot!
+      if (alt > 90.0 || alt < 0.0)
+      {
+        e->Throw ( "SURFACE: AX restricted to [0-90] range by plplot (fix plplot!)" );
+      }
+      DFloat az_change=az;
+      e->AssureFloatScalarKWIfPresent("AZ", az_change);
+      az=az_change;
+
+      //now we are in plplot different kind of 3d
+      DDoubleGDL* plplot3d;
+      DDouble ay, scale; //not useful at this time
+      if (doT3d) //convert to this world...
+      {
+
+        plplot3d=gdlConvertT3DMatrixToPlplotRotationMatrix(zValue, az, alt, ay, scale, axisExchangeCode);
+        if (plplot3d == NULL)
+        {
+          e->Throw ( "SURFACE: Illegal 3D transformation." );
+        }
+      }
+      else //make the transformation ourselves
+      {
+        scale=1/sqrt(3);
+        //Compute transformation matrix with plplot conventions:
+        plplot3d=gdlComputePlplotRotationMatrix( az, alt, zValue,scale);
+        // save !P.T if asked to...
+        if (saveT3d) //will use ax and az values...
+        {
+          DDoubleGDL* t3dMatrix=plplot3d->Dup();
+          SelfTranspose3d(t3dMatrix);
+          static DStructGDL* pStruct=SysVar::P();
+          static unsigned tTag=pStruct->Desc()->TagIndex("T");
+          for (int i=0; i<t3dMatrix->N_Elements(); ++i )(*static_cast<DDoubleGDL*>(pStruct->GetTag(tTag, 0)))[i]=(*t3dMatrix)[i];
+          GDLDelete(t3dMatrix);
+        }
+      }
+
+      if ( gdlSet3DViewPortAndWorldCoordinates(e, actStream, plplot3d, xLog, yLog,
+        xStart, xEnd, yStart, yEnd, zStart, zEnd, zLog)==FALSE ) return;
+
+      gdlSetPlotCharthick(e,actStream);
+
+
+      if (xLog) xStart=log10(xStart);
+      if (yLog) yStart=log10(yStart);
+      if (zLog) zStart=log10(zStart);
+      if (xLog) xEnd=log10(xEnd);
+      if (yLog) yEnd=log10(yEnd);
+      if (zLog) zEnd=log10(zEnd);
+
+       actStream->w3d(scale,scale,scale*(1.0-zValue),
+                     xStart, xEnd, yStart, yEnd, zStart, zEnd,
+                     alt, az);
+
+
+      bool up=e->KeywordSet ( "UPPER_ONLY" );
+      bool low=e->KeywordSet ( "LOWER_ONLY" );
+      if (up && low) nodata=true; //IDL behaviour
+
+      DLong bottomColorIndex=-1;
+      e->AssureLongScalarKWIfPresent("BOTTOM", bottomColorIndex);
+
+      //Draw 3d mesh before axes
+      // PLOT ONLY IF NODATA=0
+      if (!nodata)
+      {
+        //use of intermediate map for correct handling of blanking values and nans.
+        PLFLT ** map;
+        actStream->Alloc2dGrid( &map, xEl, yEl);
+        for ( SizeT i=0, k=0; i<xEl; i++ )
+        {
+          for ( SizeT j=0; j<yEl; j++)
+          { //plplot does not like NaNs and any other terribly large gradient!
+            PLFLT v=(*zVal)[k++];
+            if (zLog)
+            {
+              v= log10(v);
+              PLFLT miv=log10(minVal);
+              PLFLT mav=log10(maxVal);
+              if ( !isfinite(v) ) v=miv;
+              if ( hasMinVal && v < miv) v=miv;
+              if ( hasMaxVal && v > mav) v=mav;
+            }
+            else
+            {
+              if ( !isfinite(v) ) v=minVal;
+              if ( hasMinVal && v < minVal) v=minVal;
+              if ( hasMaxVal && v > maxVal) v=maxVal;
+            }
+            map[i][j] = v;
+          }
+        }
+        // 1 types of grid only: 1D X and Y.
+        PLcGrid cgrid1; // X and Y independent deformation
+        PLFLT* xg1;
+        PLFLT* yg1;
+        xg1 = new PLFLT[xEl];
+        yg1 = new PLFLT[yEl];
+        cgrid1.xg = xg1;
+        cgrid1.yg = yg1;
+        cgrid1.nx = xEl;
+        cgrid1.ny = yEl;
+        for ( SizeT i=0; i<cgrid1.nx; i++ ) cgrid1.xg[i] = (*xVal)[i];
+        for ( SizeT i=0; i<cgrid1.ny; i++ ) cgrid1.yg[i] = (*yVal)[i];
+        //apply projection transformations:
+        //not until plplot accepts 2D X Y!
+        //apply plot options transformations:
+        if (xLog) for ( SizeT i=0; i<cgrid1.nx; i++ ) cgrid1.xg[i] = cgrid1.xg[i]>0?log10(cgrid1.xg[i]):1E-12;  // #define EXTENDED_DEFAULT_LOGRANGE 12
+        if (yLog) for ( SizeT i=0; i<cgrid1.ny; i++ ) cgrid1.yg[i] = cgrid1.yg[i]>0?log10(cgrid1.yg[i]):1E-12;
+
+        // Important: make all clipping computations BEFORE setting graphic properties (color, size)
+        bool doClip=(e->KeywordSet("CLIP")||e->KeywordSet("NOCLIP"));
+        bool stopClip=false;
+        if ( doClip )  if ( startClipping(e, actStream, false)==TRUE ) stopClip=true;
+
+        gdlSetGraphicsForegroundColorFromKw ( e, actStream );
+        //mesh option
+        PLINT meshOpt;
+        meshOpt=DRAW_LINEXY;
+        if (e->KeywordSet ( "HORIZONTAL" )) meshOpt=DRAW_LINEX;
+        if (e->KeywordSet ( "SKIRT" )) meshOpt+=DRAW_SIDES;
+        //mesh plots both sides, so use it when UPPER_ONLY is not set.
+        //if UPPER_ONLY is set, use plot3d/plot3dc
+        //if LOWER_ONLY is set, use mesh/meshc and remove by plot3d!
+        //in not up not low: mesh since mesh plots both sides
+        if (up)
+        {
+          if (doShade)
+            actStream->plot3dc(xg1,yg1,map,cgrid1.nx,cgrid1.ny,meshOpt+MAG_COLOR,NULL,0);
+          else
+            actStream->plot3dc(xg1,yg1,map,cgrid1.nx,cgrid1.ny,meshOpt,NULL,0);
+        }
+        else //mesh (both sides) but contains 'low' (remove top) and/or bottom
+        {
+           if (bottomColorIndex!=-1)
+           {
+             gdlSetGraphicsForegroundColorFromKw ( e, actStream, "BOTTOM" );
+             actStream->meshc(xg1,yg1,map,cgrid1.nx,cgrid1.ny,meshOpt,NULL,0);
+             gdlSetGraphicsForegroundColorFromKw ( e, actStream );
+             if (!low) //redraw top with top color
+             {
+               if (doShade) actStream->plot3dc(xg1,yg1,map,cgrid1.nx,cgrid1.ny,meshOpt+MAG_COLOR,NULL,0);
+               else actStream->plot3dc(xg1,yg1,map,cgrid1.nx,cgrid1.ny,meshOpt,NULL,0);
+             }
+           }
+           else
+           {
+             if (doShade) actStream->meshc(xg1,yg1,map,cgrid1.nx,cgrid1.ny,meshOpt+MAG_COLOR,NULL,0);
+             else actStream->meshc(xg1,yg1,map,cgrid1.nx,cgrid1.ny,meshOpt,NULL,0);
+           }
+           //redraw upper part with background color to remove it... Not 100% satisfying though.
+           if (low)
+           {
+            if (e->KeywordSet ( "SKIRT" )) meshOpt-=DRAW_SIDES;
+            gdlSetGraphicsPenColorToBackground(actStream);
+            actStream->plot3dc(xg1,yg1,map,cgrid1.nx,cgrid1.ny,meshOpt,NULL,0);
+            gdlSetGraphicsForegroundColorFromKw ( e, actStream );
+           }
+        }
+
+        if (stopClip) stopClipping(actStream);
+//Clean alllocated data struct
+        delete[] xg1;
+        delete[] yg1;
+        actStream->Free2dGrid(map, xEl, yEl);
+      }
+      //Draw axes with normal color!
+      gdlSetGraphicsForegroundColorFromKw ( e, actStream ); //COLOR
+      gdlBox3(e, actStream, xStart, xEnd, yStart, yEnd, zStart, zEnd, xLog, yLog, zLog, true);
+    } 
+
+  private:
+
+    void call_plplot (EnvT* e, GDLGStream* actStream) 
     {
-      actStream->lsty(1);//reset linestyle
+    } 
 
-      // set ![XY].CRANGE
-      set_axis_crange("X", xStart, xEnd, xLog);
-      set_axis_crange("Y", yStart, yEnd, yLog);
-      set_axis_crange("Z", zStart, zEnd, zLog);
-
-      //set ![x|y].type
-      set_axis_type("X", xLog);
-      set_axis_type("Y", yLog);
-      set_axis_type("Z", zLog);
-    } // }}}
+  private:
 
-  }; // surface_call class
+    virtual void post_call (EnvT*, GDLGStream* actStream) 
+    {
+      actStream->lsty(1);//reset linestyle
+      actStream->sizeChar(1.0);
+    } 
+
+ }; // surface_call class
 
   void surface(EnvT* e)
   {
     surface_call surface;
     surface.call(e, 1);
   }
-
-} // namespace
+} // namespace
\ No newline at end of file
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting_windows.cpp gdl/src/plotting_windows.cpp
--- gdl-0.9.3/src/plotting_windows.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting_windows.cpp	2013-05-16 12:36:33.666856299 -0600
@@ -61,7 +61,7 @@
 	title = "GDL "+i2s( wIx);
       }
 
-    DLong xPos=0, yPos=0;
+    DLong xPos=-1, yPos=-1;
     e->AssureLongScalarKWIfPresent( "XPOS", xPos);
     e->AssureLongScalarKWIfPresent( "YPOS", yPos);
 
@@ -69,7 +69,7 @@
 #ifdef HAVE_X
     DeviceX::DefaultXYSize(&xSize, &ySize);
 #else
-    xSize = 640;
+    xSize = 640;
     ySize = 512;
 #endif
     e->AssureLongScalarKWIfPresent( "XSIZE", xSize);
@@ -80,8 +80,7 @@
       cout << "xPos/yPos   :"<<  xPos << " " << yPos << endl;
       cout << "xSize/ySize :"<<  xSize << " " << ySize << endl;
     }
-
-    if( xSize <= 0 || ySize <= 0 || xPos < 0 || yPos < 0)
+    if( xSize <= 0 || ySize <= 0 || xPos < -1 || yPos < -1)
       e->Throw(  "Unable to create window "
 		 "(BadValue (integer parameter out of range for "
 		 "operation)).");
@@ -89,7 +88,18 @@
     bool success = actDevice->WOpen( wIx, title, xSize, ySize, xPos, yPos);
     if( !success)
       e->Throw(  "Unable to create window.");
-  }
+    success = actDevice->CursorCrosshair();
+    success = actDevice->UnsetFocus();
+    bool doretain=true;
+    DLong retainType ; //=Graphics::getRetain();
+//    if (retainType=0) doretain=false;
+    if( e->KeywordPresent( 3)) // RETAIN
+    {
+      e->AssureLongScalarKWIfPresent( "RETAIN", retainType);
+      if (retainType=0) doretain=false;
+    }
+    success = actDevice->EnableBackingStore(doretain);
+ }
 
   void wset( EnvT* e)
   {
@@ -113,12 +123,15 @@
             #ifdef HAVE_X
                 DeviceX::DefaultXYSize(&xSize, &ySize);
             #else
-                xSize = 640;
+                xSize = 640;
                 ySize = 512;
             #endif
-	    bool success = actDevice->WOpen( 0, "GDL 0", xSize, ySize, 0, 0);
+	    bool success = actDevice->WOpen( 0, "GDL 0", xSize, ySize, -1, -1);
 	    if( !success)
 	      e->Throw( "Unable to create window.");
+        success = actDevice->CursorCrosshair();
+        success = actDevice->UnsetFocus();
+        //FIXME: ADD support for RETAIN (BackingSTORE))
 	    return;
 	  }
       }
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/plotting_xyouts.cpp gdl/src/plotting_xyouts.cpp
--- gdl-0.9.3/src/plotting_xyouts.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/plotting_xyouts.cpp	2013-05-16 12:36:33.670856285 -0600
@@ -18,360 +18,392 @@
 #include "includefirst.hpp"
 #include "plotting.hpp"
 #include "math_utl.hpp"
-#include <plplot/plplotP.h>
 
-namespace lib {
+#define DPI (double)(4*atan(1.0))
+#define DEGTORAD DPI/180.0
+
+namespace lib
+{
 
   using namespace std;
 
-  void takelog(PLFLT *a, PLFLT *a_orient) // {{{
-  {
-    if (*a_orient != 0.) 
-    {
-      *a_orient = log10( *a + *a_orient) - log10( *a); 
-    }   
-    *a = log10( *a); 
-  } // }}}
+  static DDouble lastTextPosX=0.0;
+  static DDouble lastTextPosY=0.0;
 
-  class xyouts_call : public plotting_routine_call
+  class xyouts_call: public plotting_routine_call
   {
+    PLFLT currentBoxXmin, currentBoxXmax, currentBoxYmin, currentBoxYmax, currentBoxZmin, currentBoxZmax;
+    PLFLT vpXmin, vpXmax, vpYmin, vpYmax;
+    DDoubleGDL* yVal, *xVal, *zVal;
+    Guard<DDoubleGDL> xval_guard, yval_guard, zval_guard;
+    DStringGDL* strVal;
+    SizeT xEl, yEl, zEl, strEl;
+    bool xLog, yLog, zLog;
+    bool doClip, restoreClipBox;
+    PLFLT savebox[4];
+    bool kwWidth;
+    PLFLT width;
+    DLong minEl;
+    DLongGDL *color;
+    DFloatGDL *spacing,*orientation,*charthick,*alignement,*size;
+    Guard<BaseGDL> alignement_guard, orientation_guard,size_guard;
+    bool doT3d;
+    DDoubleGDL* t3dMatrix;
+    Guard<BaseGDL> t3dMatrix_guard;
+    DDoubleGDL *xValou;
+    DDoubleGDL *yValou;
+    Guard<BaseGDL> xvalou_guard, yvalou_guard;
+    bool singleArg;
+  private:
 
-    private: bool handle_args( EnvT* e) // {{{
+    bool handle_args(EnvT* e)
     {
-      return true;
-    } // }}}
-
-  private: void old_body( EnvT* e, GDLGStream* actStream) // {{{
-  {
-    DDoubleGDL* yVal, *xVal;
-    DStringGDL* strVal;
-    SizeT xEl, yEl,strEl;
-    if(nParam() == 1) 
+      // KEYWORDS are: CLIP(YES), COLOR(YES), DATA(YES) , DEVICE(YES) ,
+      // NORMAL(YES) , FONT(NO), ORIENTATION(YES), /NOCLIP(YES), T3D(YES), Z(YES)
+      static int zvIx = e->KeywordIx( "Z");
+      DDouble zValue=0.0;
+      e->AssureDoubleScalarKWIfPresent ( zvIx, zValue );
+      singleArg=false;
+      if ( nParam()==1 )
       {
-	//string only... 
-	  e->Throw("String only, not implemented");
+        singleArg=true;
+        //string only...
+        xVal=new DDoubleGDL(1, BaseGDL::ZERO);
+        xval_guard.Reset(xVal); // delete upon exit
+        yVal=new DDoubleGDL(1, BaseGDL::ZERO);
+        yval_guard.Reset(yVal); // delete upon exit
+        xEl=yEl=xVal->N_Elements();
+        strVal=e->GetParAs<DStringGDL>(0);
+        strEl=strVal->N_Elements();
+        zVal=new DDoubleGDL(1);
+        zval_guard.Reset(zVal); // delete upon exit
+        (*zVal)[0]=zValue;
+        minEl=strEl; //in this case only
       }
-    else if(nParam() == 3)
+      else if ( nParam()==3 )
       {
-	xVal = e->GetParAs< DDoubleGDL>(0);
-	xEl = xVal->N_Elements();
-	yVal = e->GetParAs< DDoubleGDL>(1);
-	yEl = yVal->N_Elements();
-	strVal=e->GetParAs<DStringGDL>(2);
-	strEl=strVal->N_Elements();
-      }
-    else
-      {
-	e->Throw("Not enough parameters. Either 1 parameter or 3 "
-		 "parameters valid.");
-      }
-    //ok...
-    DLong minEl = (xEl < yEl)? xEl:yEl;
-    minEl=(minEl < strEl)? minEl:strEl;
-    
-    DFloat xMarginL, xMarginR,yMarginB, yMarginT; 
-    get_axis_margin("X", xMarginL, xMarginR);
-    get_axis_margin("Y", yMarginB, yMarginT);
-    
-    DDouble xStart, xEnd, yStart, yEnd;
-    bool xLog, yLog;
-//    DDouble minVal, maxVal;
-
-    get_axis_crange("X", xStart, xEnd);
-    get_axis_crange("Y", yStart, yEnd);
-    get_axis_type("X", xLog);
-    get_axis_type("Y", yLog);
-
-
-    /*    DLong background = p_background;
-    static int cix=e->KeywordIx("COLOR");
-    BaseGDL* color_arr=e->GetKW(cix);
-    DLongGDL* l_color_arr;
-    if(color_arr != NULL)
-      {
-	l_color_arr=static_cast<DLongGDL*>
-	  (color_arr->Convert2(GDL_LONG, BaseGDL::COPY));
-	if(color_arr->N_Elements() < minEl && color_arr->N_Elements() > 1)
-	  e->Throw( "Array "+e->GetParString(cix)+
-		    " does not have enough elements for COLOR keyword.");
-      }
-    DLong color = p_color;
-
-    if(color_arr != NULL)  
-      if(color_arr->N_Elements() >= 1) 
-	color=(*l_color_arr)[0];
-    */
-    
-// pen thickness for axis
-actStream->wid( 0);
-
-
-    //start drawing. KEYWORDS are: CLIP(NO), COLOR(PARTIALLY), DATA(YES) , DEVICE(YES) ,
-    // NORMAL(YES) , FONT(NO), ORIENTATION(YES), /NOCLIP(YES), T3D(NO), Z(NO)
-    //    actStream->Background( background);
-    //    actStream->Color( color);
-    //    gkw_background(e, actStream);
-    gkw_color(e, actStream);
-
-    PLFLT xMR, xML, yMB, yMT;
-    CheckMargin( e, actStream,
-		 xMarginL, 
-		 xMarginR, 
-		 yMarginB, 
-		 yMarginT,
-		 xMR, xML, yMB, yMT);
-
-    bool mapSet=false;
-#ifdef USE_LIBPROJ4
-    // Map Stuff (xtype = 3)
-    LPTYPE idata;
-    XYTYPE odata;
-
-    get_mapset(mapSet);
-
-    if ( mapSet) {
-      ref = map_init();
-      if ( ref == NULL) {
-	e->Throw( "Projection initialization failed.");
+        xVal=e->GetParAs< DDoubleGDL>(0);
+        xEl=xVal->N_Elements();
+        yVal=e->GetParAs< DDoubleGDL>(1);
+        yEl=yVal->N_Elements();
+        strVal=e->GetParAs<DStringGDL>(2);
+        strEl=strVal->N_Elements();
+         //z will be set at Zero unless Z=value is given
+        zEl=xEl;
+        zVal=new DDoubleGDL(dimension(zEl));
+        zval_guard.Reset(zVal); // delete upon exit
+        for (SizeT i=0; i< zEl ; ++i) (*zVal)[i]=zValue;
+        minEl=(xEl<yEl)?xEl:yEl;
+        minEl=(minEl<strEl)?minEl:strEl;
+      }
+      else
+      {
+        e->Throw("Not enough parameters. Either 1 parameter or 3 "
+                 "parameters valid.");
       }
+      return true;
     }
-#endif
 
-    DDouble *sx, *sy;
-    DFloat *wx, *wy;
-    GetSFromPlotStructs(&sx, &sy);
-    GetWFromPlotStructs(&wx, &wy);
-
-    int isdatabydefault=0;
-
-    if(e->KeywordSet("DEVICE")) {
-      PLFLT xpix, ypix;
-      PLINT xleng, yleng, xoff, yoff;
-      actStream->gpage(xpix, ypix,xleng, yleng, xoff, yoff);
-      xStart=0; xEnd=xleng;
-      yStart=0; yEnd=yleng;
-      xLog = false; yLog = false;
-      actStream->NoSub();
-      actStream->vpor(0, 1, 0, 1);
-   } else if(e->KeywordSet("NORMAL")) {
-      xStart = 0;
-      xEnd   = 1;
-      yStart = 0;
-      yEnd   = 1;
-      actStream->NoSub();
-      actStream->vpor(0, 1, 0, 1);
-      xLog = false; yLog = false;
-    } else {
-      isdatabydefault=1;
-      actStream->NoSub();
-      if (xLog || yLog) actStream->vpor(wx[0], wx[1], wy[0], wy[1]);
-      else actStream->vpor(0, 1, 0, 1); // (to be merged with the condition on DataCoordLimits...)
-    }
+  private:
 
-    // Determine data coordinate limits
-    // These are computed from window and scaling axis system
-    // variables because map routines change these directly.
-
-    //    if (e->KeywordSet("NORMAL") || e->KeywordSet("DATA")) {
-    if (e->KeywordSet("DATA") || (isdatabydefault == 1)) {
-      DataCoordLimits(sx, sy, wx, wy, &xStart, &xEnd, &yStart, &yEnd, (xLog || yLog));
+    void getTextPos(GDLGStream *a, DDouble &wx, DDouble &wy)
+    {
+      a->DeviceToWorld(lastTextPosX, lastTextPosY, wx, wy);
+      if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"getTextPos: Got norm: %lf %lf giving %lf %lf world\n", lastTextPosX, lastTextPosY, wx, wy);
     }
 
-//    minVal=yStart; maxVal=yEnd;
-
-    //CLIPPING
-//    DLong noclip=1;
-//    e->AssureLongScalarKWIfPresent( "NOCLIP", noclip);
-//    if(noclip == 0)
-//      {
-//	static int clippingix = e->KeywordIx( "CLIP");
-//	DDoubleGDL* clippingD = e->IfDefGetKWAs<DDoubleGDL>( clippingix);
-//	if( clippingD != NULL)
-//	    Clipping( clippingD, xStart, xEnd, minVal, maxVal);
-//      }
-
-    // for orient
-    PLFLT xScale = abs(xEnd - xStart), yScale = abs(yEnd - yStart);
-
-
-    // SA: following a patch from Joanna (3029409) TODO: this is repeated in PLOTS POLYFILL and XYOUTS
-    if ( xEnd - xStart == 0 || yEnd - yStart == 0 || isnan(xStart) || isnan(yStart) ) {
-      actStream->wind( 0, 1, 0, 1 ); 
-    } else {
-      actStream->wind( xStart, xEnd, yStart, yEnd);
-    }
+    void old_body(EnvT* e, GDLGStream* actStream)
+    {
+      int clippingix=e->KeywordIx("CLIP");
+      DFloatGDL* clipBox=NULL;
 
-    PLFLT x,y;
-    string out;
 
-    //orientation
-    static int oix=e->KeywordIx("ORIENTATION");
-    BaseGDL* orient=e->GetKW(oix);
-    DDoubleGDL* d_orient;
-    PLFLT p_orient, p_orient_x, p_orient_y;
-    p_orient=0.0;
-    p_orient_x=xScale;
-    p_orient_y=0.0;
-
-    if(orient != NULL)
-      {
-	d_orient=static_cast<DDoubleGDL*>
-	  (orient->Convert2(GDL_DOUBLE, BaseGDL::COPY));
-	if(orient->N_Elements() < minEl && orient->N_Elements() > 1)
-	  e->Throw( "Array "+e->GetParString(oix)+
-		    " does not have enough elements for ORIENTATION keyword.");
-	p_orient=(*d_orient)[0];
-	  while(p_orient < 0) p_orient+=360.0;
-	  while(p_orient > 360.0) p_orient-=360.0;
-      }
-
-    p_orient_x=xScale*cos(p_orient*0.0174533);
-    p_orient_y=yScale*sin(p_orient*0.0174533);
-
-    //ALIGNMENT
-    DDouble alignment = 0.0;
-    e->AssureDoubleScalarKWIfPresent( "ALIGNMENT", alignment);
-
-    // !P.MULTI vs. POSITION
-    handle_pmulti_position(e, actStream);
-
-    //CHARSIZE Note that SIZE is apparently used in some old implementations and
-    //seems to be supported silently with *DL. So we support it also:
-    DFloat charsize;
-    gkw_charsize_xyouts(e, actStream, charsize);
-
-    // WIDTH keyword
-    static int widthIx = e->KeywordIx( "WIDTH");
-    bool kwWidth = e->KeywordPresent(widthIx);
-    PLFLT width = 0.;
-
-    // SA: plplot uses a "reference point" that "lies along a line passing 
-    //     through the string at half the height of a capital letter"
-    //     getting character height so it can be later used to move the 
-    //     "reference point" half character height lower (tracker item no. 2982623)
-    PLFLT charheight;
+      //T3D
+      static int t3dIx = e->KeywordIx( "T3D");
+      doT3d=e->KeywordSet(t3dIx);
 
-#ifdef HAVE_PLPLOT_BEFORE_5994
-    {
-      PLFLT nullf, htmm;
-      plgchr(&nullf, &htmm); // height of a letter in millimetres
-      PLINT htpc = plP_mmpcy(htmm); // height of a letter in physical coordinates
-      PLINT nulli, p_iymin, p_iymax;
-      plP_gphy(&nulli, &nulli, &p_iymin, &p_iymax); // physical device limits in physical coordinates
-      PLFLT wy, wy0;
-      plcalc_world(0., htpc / double(p_iymax - p_iymin), &nullf, &wy, &nulli); // wy = height of a letter in world coordinates
-      plcalc_world(0., 0., &nullf, &wy0, &nulli); // wy = height of a letter in world coordinates
-      charheight = wy - wy0;
-    }
-#else // HAVE_PLPLOT_BEFORE_5994
-    cout << "Warning : charheight not changeable" << endl;
-    cout << "Warning : no more useful symbols in plplot 5.9.9-4" << endl;
-    charheight=1.;
-#endif // HAVE_PLPLOT_BEFORE_5994
 
+      // WIDTH keyword (read, write)
+      static int widthIx=e->KeywordIx("WIDTH");
+      kwWidth=e->KeywordPresent(widthIx);
+      width=0.;
 
-    if(minEl == 1)
+      enum
       {
-	x=static_cast<PLFLT>((*xVal)[0]);
-	y=static_cast<PLFLT>((*yVal)[0]);
-
-	if( yLog) if( y <= 0.0) goto skip; else takelog(&y, &p_orient_y);
-	if( xLog) if( x <= 0.0) goto skip; else takelog(&x, &p_orient_x);
+        DATA=0,
+        NORMAL,
+        DEVICE
+      } coordinateSystem=DATA;
+      //check presence of DATA,DEVICE and NORMAL options
+      if ( e->KeywordSet("DATA") ) coordinateSystem=DATA;
+      if ( e->KeywordSet("DEVICE") ) coordinateSystem=DEVICE;
+      if ( e->KeywordSet("NORMAL") ) coordinateSystem=NORMAL;
+      // get_axis_type
+      gdlGetAxisType("X", xLog);
+      gdlGetAxisType("Y", yLog);
+      gdlGetAxisType("Z", zLog);
 
+      bool mapSet=false;
 #ifdef USE_LIBPROJ4
-	if (mapSet && !e->KeywordSet("NORMAL")) {
-	  idata.lam = x * DEG_TO_RAD;
-	  idata.phi = y * DEG_TO_RAD;
-	  odata = PJ_FWD(idata, ref);
-	  x = odata.x;
-	  y = odata.y;
-	}
-        // TODO: p_orient_x? p_orient_y?
+      get_mapset(mapSet);
+      if ( mapSet )
+      {
+        ref=map_init();
+        if ( ref==NULL )
+        {
+          e->Throw("Projection initialization failed.");
+        }
+      }
 #endif
+      restoreClipBox=false;
+      int noclipvalue=1;
+      e->AssureLongScalarKWIfPresent( "NOCLIP", noclipvalue);
+      doClip=(noclipvalue==0); //XYOUTS by default does not clip, even if clip is defined by CLIP= or !P.CLIP.
+      clipBox=e->IfDefGetKWAs<DFloatGDL>(clippingix);
+      if(doClip && clipBox!=NULL && clipBox->N_Elements()>=4 ) //clipbox exist, will be used: convert to device coords
+                                                               //and save in !P.CLIP...
+      {
+        restoreClipBox=true; //restore later
+        // save current !P.CLIP box, replace by our current clipbox in whatever coordinates, will
+        // give back the !P.CLIP box at end...
+        static DStructGDL* pStruct=SysVar::P();
+        static unsigned clipTag=pStruct->Desc()->TagIndex("CLIP"); //must be in device coordinates
+        static PLFLT tempbox[4];
+        for ( int i=0; i<4; ++i ) savebox[i]=(*static_cast<DLongGDL*>(pStruct->GetTag(clipTag, 0)))[i];
+        if ( coordinateSystem==DEVICE )
+        {
+          for ( int i=0; i<4; ++i ) tempbox[i]=(*clipBox)[i];
+        }
+        else if ( coordinateSystem==DATA )
+        {
+          //handle log: if existing box is already in log, use log of clipbox values.
+          PLFLT worldbox[4];
+          for ( int i=0; i<4; ++i ) worldbox[i]=(*clipBox)[i];
+          if (xLog) {worldbox[0]=log10(worldbox[0]); worldbox[2]=log10(worldbox[2]);}
+          if (yLog) {worldbox[1]=log10(worldbox[1]); worldbox[3]=log10(worldbox[3]);}
+          bool okClipBox=true;
+          for ( int i=0; i<4; ++i )
+          {
+            if (!(worldbox[i]==worldbox[i])) //NaN
+            {
+              okClipBox=false;restoreClipBox=false;doClip=false;
+            }
+          }
+          if (okClipBox)
+          {
+            actStream->WorldToDevice(worldbox[0], worldbox[1], tempbox[0], tempbox[1]);
+            actStream->WorldToDevice(worldbox[2], worldbox[3], tempbox[2], tempbox[3]);
+          }
+        }
+        else
+        {
+          actStream->NormedDeviceToDevice((*clipBox)[0],(*clipBox)[1], tempbox[0], tempbox[1]);
+          actStream->NormedDeviceToDevice((*clipBox)[2],(*clipBox)[3], tempbox[2], tempbox[3]);
+        }
+        //place in !P.CLIP
+        for ( int i=0; i<4; ++i ) (*static_cast<DLongGDL*>(pStruct->GetTag(clipTag, 0)))[i]=tempbox[i];
+      }
 
-        y += .5 * charheight;
+      PLFLT wun, wdeux, wtrois, wquatre;
+      if ( coordinateSystem==DATA) //with PLOTS, we can plot *outside* the box(e)s in DATA coordinates.
+                                   // convert to device coords in this case
+      {
+        actStream->pageWorldCoordinates(wun, wdeux, wtrois, wquatre);
+      }
 
-	out=(*strVal)[0];
-	actStream->ptex(x,y,p_orient_x, p_orient_y,alignment,out.c_str());
-#ifdef HAVE_PLPLOT_BEFORE_5994
-        if (kwWidth) width = plstrl(out.c_str());
-#endif
+      actStream->OnePageSaveLayout(); // one page
+      actStream->vpor(0, 1, 0, 1); //set full viewport
+
+      if ( coordinateSystem==DEVICE )
+      {
+        actStream->wind(0.0, actStream->xPageSize(), 0.0, actStream->yPageSize());
+        xLog=false;
+        yLog=false;
       }
-    else
+      else if ( coordinateSystem==NORMAL )
       {
-	for(int i=0; i<minEl;++i)
-	  {
+        actStream->wind(0.0, 1.0, 0.0, 1.0);
+        xLog=false;
+        yLog=false;
+      }
+      else //with XYOUTS, we can plot *outside* the box(e)s in DATA coordinates.
+      {
+        actStream->wind(wun, wdeux, wtrois, wquatre);
+      }
 
-	    if(orient != NULL && orient->N_Elements() > 1) 
-	    {
-	      p_orient=(*d_orient)[i];
-	      while(p_orient < 0) p_orient+=360.0;
-	      while(p_orient > 360.0) p_orient-=360.0;
-	      p_orient_x=xScale*cos(p_orient*0.0174533);
-	      p_orient_y=yScale*sin(p_orient*0.0174533);
-	    }
+      PLFLT x,y,aspectw,aspectd;
+      aspectw=actStream->boxAspectWorld();
+      aspectd=actStream->boxAspectDevice();
+
+      int colorIx=e->KeywordIx ( "COLOR" ); bool docolor=false;
+      int charthickIx=e->KeywordIx ( "CHARTHICK" ); bool docharthick=false;
+      int charsizeIx=e->KeywordIx ( "CHARSIZE" ); bool docharsize=false;
+      if ( e->GetKW ( colorIx )!=NULL )
+      {
+        color=e->GetKWAs<DLongGDL>( colorIx ); docolor=true;
+      }
+      if ( e->GetKW ( charthickIx )!=NULL )
+      {
+        charthick=e->GetKWAs<DFloatGDL>( charthickIx ); docharthick=true;
+      }
+      if ( e->GetKW ( charsizeIx )!=NULL )
+      {
+        size=e->GetKWAs<DFloatGDL>( charsizeIx ); docharsize=true;
+      }
+      else  //for security in future conditional evaluation...
+      {
+        size=new DFloatGDL  ( dimension (1), BaseGDL::ZERO );
+        size_guard.Init ( size);
+        (*size)[0]=1.0;
+      }
+      int orientationIx=e->KeywordIx ( "ORIENTATION" );
+      if ( e->GetKW ( orientationIx )!=NULL )
+      {
+        orientation=e->GetKWAs<DFloatGDL>( orientationIx ); 
+      }
+      else
+      {
+        orientation=new DFloatGDL  ( dimension (1), BaseGDL::ZERO );
+        orientation_guard.Init ( orientation);
+        (*orientation)[0]=0;
+      }
+      int alignIx=e->KeywordIx ( "ALIGNMENT" );
+      if ( e->GetKW ( alignIx )!=NULL )
+      {
+        alignement=e->GetKWAs<DFloatGDL>( alignIx );
+      }
+      else
+      {
+        alignement=new DFloatGDL  ( dimension (1), BaseGDL::ZERO );
+        alignement_guard.Init (alignement);
+        (*alignement)[0]=0;
+      }
+
+
+      // make all clipping computations BEFORE setting graphic properties (color, size)
+      bool stopClip=false;
+      if ( doClip )  if ( startClipping(e, actStream, true)==TRUE ) stopClip=true;
+
+      // *** start drawing by defalut values
+      gdlSetGraphicsForegroundColorFromKw(e, actStream);
+      gdlSetPlotCharthick(e, actStream);
+      gdlSetPlotCharsize(e, actStream, true); //accept SIZE kw!
 
-	    x=static_cast<PLFLT>((*xVal)[i]);
-	    y=static_cast<PLFLT>((*yVal)[i]);
+      if ( doT3d ) //convert X,Y,Z in X',Y' as per T3D perspective.
+      {
+        DDoubleGDL* t3dMatrix=gdlGetT3DMatrix(); //the original one
+        t3dMatrix_guard.Reset(t3dMatrix);
+        DDouble *sx, *sy, *sz;
+        GetSFromPlotStructs(&sx, &sy, &sz);
+        xValou=new DDoubleGDL(dimension(xEl));
+        yValou=new DDoubleGDL(dimension(yEl));
+        Guard<BaseGDL> xval_guard, yval_guard;
+        xval_guard.reset(xValou);
+        yval_guard.reset(yValou);
+        gdlProject3dCoordinatesIn2d(t3dMatrix, xVal, sx, yVal, sy, zVal, sz, xValou, yValou);
+        xVal=xValou;
+        yVal=yValou;
+      }
+      // Get decomposed value for colors
+      DLong decomposed=Graphics::GetDevice()->GetDecomposed();
 
-	    if( yLog) if( y <= 0.0) continue; else takelog( &y, &p_orient_y);
-	    if( xLog) if( x <= 0.0) continue; else takelog( &x, &p_orient_x);
+      for ( SizeT i=0; i<minEl; ++i )
+      {
+        //if string only, fill empty Xval Yval with current value:
+        if ( nParam()==1 )
+        {
+          DDouble s,t;
+          getTextPos(actStream, s, t);
+          (*xVal)[0]=s;
+          (*yVal)[0]=t;
+        }
+        x=static_cast<PLFLT>((*xVal)[i%xVal->N_Elements ( )]); //insure even 1 parameter, string array
+        y=static_cast<PLFLT>((*yVal)[i%xVal->N_Elements ( )]);
 
+        //following obviously wrong if T3D...
 #ifdef USE_LIBPROJ4
-	    if (mapSet && !e->KeywordSet("NORMAL")) {
-	      idata.lam = x * DEG_TO_RAD;
-	      idata.phi = y * DEG_TO_RAD;
-	      odata = PJ_FWD(idata, ref);
-	      x = odata.x;
-	      y = odata.y;
-	      if (!isfinite(x) || !isfinite(y)) continue;
-	    }
+        if ( mapSet&& coordinateSystem==DATA )
+        {
+          LPTYPE idata;
+          XYTYPE odata;
+          idata.lam=x * DEG_TO_RAD;
+          idata.phi=y * DEG_TO_RAD;
+          odata=PJ_FWD(idata, ref);
+          x=odata.x;
+          y=odata.y;
+        }
 #endif
 
-	    /*	    if(color_arr != NULL)  
-	      if(color_arr->N_Elements() > 1)
-		actStream->Color((*l_color_arr)[i]);
-	    */
-	    out=(*strVal)[i];
-            y += .5 * charheight;
-	    actStream->ptex(x,y,p_orient_x, p_orient_y,alignment,out.c_str());
+        if( xLog ) x=log10(x);
+        if( yLog ) y=log10(y);
 
-#ifdef HAVE_PLPLOT_BEFORE_5994
-            if (kwWidth) width = max(plstrl(out.c_str()), width);
-#endif
-	  }
+        if ( !isfinite(x)|| !isfinite(y) ) continue; //no plot
+        if ( docharsize && ( *size )[i%size->N_Elements ( )] < 0) continue; //no plot either
+
+        //plot!
+        if (docharsize) actStream->sizeChar(( *size )[i%size->N_Elements ( )]);
+        if (docolor) actStream->Color ( ( *color )[i%color->N_Elements ( )], decomposed, 2);
+        if (docharthick) actStream->wid ( ( *charthick )[i%charthick->N_Elements ( )]);
+        PLFLT ori=(( *orientation )[i%orientation->N_Elements ( )]) * DEGTORAD;
+        PLFLT cosOri=cos(ori);
+        PLFLT sinOri=sin(ori);
+        PLFLT align=( *alignement )[i%alignement->N_Elements ( )];
+        PLFLT dispx,dispy, chsize, dx, dy;
+        // displacement due to offset (reference in IDL is baseline,
+        // in plplot it's the half-height) is best computed in device coords
+        chsize=actStream->dCharHeight()*0.5;
+        actStream->WorldToDevice(x, y, dx, dy);
+        actStream->DeviceToWorld(dx-chsize*sinOri,dy+chsize*cosOri,dispx,dispy);
+        string out=(*strVal)[i%strVal->N_Elements ( )];
+        actStream->ptex(dispx, dispy, cosOri, sinOri*aspectw/aspectd, align, out.c_str());
+
+        if (singleArg || (i==minEl-1 ) ) //then x and y are not given and whatever the number of strings, are retrieved
+                       // from lastTextPos. We must thus rememeber lastTextPos.
+        {
+          width=actStream->gdlGetmmStringLength(out.c_str()); //in mm
+          //we want normed size:
+          width=actStream->m2dx(width);
+          //save position - compute must be in DEVICE coords, or in normed*aspect!
+          actStream->WorldToNormedDevice(x, y, dx, dy); //normed
+          actStream->NormedDeviceToWorld(dx+(1.0-align)*width*cosOri,dy+(1.0-align)*width*sinOri*aspectw/aspectd,dispx,dispy);
+          actStream->WorldToDevice(dispx, dispy, lastTextPosX, lastTextPosY);
+        }
       }
-    
-  skip:
-    if (kwWidth)
+      if (stopClip) stopClipping(actStream);
+
+      if ( kwWidth )
+      {
+        // width is in "normalized coordinates"
+        e->SetKW(widthIx, new DFloatGDL(width));
+      }
+    } 
+
+  private:
+
+    void call_plplot(EnvT* e, GDLGStream* actStream) // {{{
     {
-      // SA: we should return value of width in "normalized coordinate units"
-      //     width contains output from plstrl() expressed in millimetres
-      //     plP_mmpcx() converts it into physical coordinates
-      //     plP_gphy() gives "physical device limits in physical coordinates"
-
-#ifdef HAVE_PLPLOT_BEFORE_5994
-      PLINT p_ixmin, p_ixmax, p_iymin, p_iymax;
-      plP_gphy(&p_ixmin, &p_ixmax, &p_iymin, &p_iymax);
-      e->SetKW(widthIx, new DFloatGDL(plP_mmpcx(width)/double(p_ixmax - p_ixmin)));
-#endif
-    }
-  } // }}}
+    } 
 
-  private: void call_plplot(EnvT* e, GDLGStream* actStream) // {{{
-  {
-  } // }}}
+  private:
 
-    private: virtual void post_call(EnvT*, GDLGStream*) // {{{
+    virtual void post_call(EnvT* e, GDLGStream* actStream) // {{{
     {
-    } // }}}
+      actStream->RestoreLayout();
+      if (restoreClipBox)
+      {
+        static DStructGDL* pStruct=SysVar::P();
+        static unsigned clipTag=pStruct->Desc()->TagIndex("CLIP"); //must be in device coordinates
+        for ( int i=0; i<4; ++i ) (*static_cast<DLongGDL*>(pStruct->GetTag(clipTag, 0)))[i]=savebox[i];
+      }
+      actStream->sizeChar(1.0);
+    }
 
-  }; 
+  };
 
   void xyouts(EnvT* e)
   {
     xyouts_call xyouts;
     xyouts.call(e, 1);
   }
- 
+
 } // namespace
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/print.cpp gdl/src/print.cpp
--- gdl-0.9.3/src/print.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/print.cpp	2013-03-25 10:36:38.603968715 -0600
@@ -201,7 +201,7 @@
     // GDL magick (based on the Python interface code)
     static int printIx = LibProIx("PRINT");
     EnvT* env = new EnvT(NULL, libProList[printIx]);
-    auto_ptr<EnvT> env_guard(env);
+    Guard<EnvT> env_guard(env);
     BaseGDL* par;
     env->SetNextPar(&par);
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/pro/diag_matrix.pro gdl/src/pro/diag_matrix.pro
--- gdl-0.9.3/src/pro/diag_matrix.pro	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/pro/diag_matrix.pro	2013-05-16 12:36:33.774855912 -0600
@@ -1,8 +1,69 @@
+;+
 ;
-; limited version of DIAG_MATRIX
 ; please report problems / examples / extensions
 ;
-; Alain C., 23-JAN-2012, under GNU GPL v2 or later
+; NAME:      DIAG_MATRIX
+;
+; PURPOSE:   1/ returning the diagonal of the input matrix
+;            2/ generating a square matrix with a given diagonal.
+;
+; CATEGORY:   Matrix utilities
+;
+; CALLING SEQUENCE:
+;  - case 1:  my_diagonal=DIAG_MATRIX(matrix)
+;  - case 2:  matrix=DIAG_MATRIX(a_diag_vector, an_offset)
+;
+; INPUTS:
+;  - case 1:  a matrix (square or not)
+;  - case 2:  a vector (might be a singleton)
+;
+; OPTIONAL INPUTS: 
+;  - case 1:  none
+;  - case 2:  an offset
+;
+; KEYWORD PARAMETERS:
+;
+; OUTPUTS:
+;  - case 1: a vector, the diagonal
+;  - case 2: a square matrix
+;
+; OPTIONAL OUTPUTS: none
+;
+; COMMON BLOCKS: none
+;
+; SIDE EFFECTS: none
+;
+; RESTRICTIONS: none known !
+;
+; PROCEDURE: straightforward
+;
+; EXAMPLE:
+;
+; - case 1: print, DIAG_MATRIX(DIST(10))
+;
+; - case 2:
+; ** generating a NxN rotation matrix:
+;           matrix=DIAG_MATRIX(REPLICATE(1.,nbp-1),1)
+;           matrix[0,nbp-1]=1.
+; ** generating a IDENTITY matrix (equal to: identity=IDENTITY(nbp)
+;           identity=DIAG_MATRIX(REPLICATE(1.,nbp))
+;
+; MODIFICATION HISTORY:
+;
+; * 23-JAN-2012: initial version by Alain C.
+;
+; * 11-APR-2013: - in fact, when creating the output matrix,
+;                  we have to derive the type from the input diagonal !
+;                - more documentation 
+;
+;-
+; LICENCE:  Copyright (C) 2012, 2013, Alain Coulais, under GNU GPL v2 or later
+;
+; This program is free software; you can redistribute it and/or modify  
+; it under the terms of the GNU General Public License as published by  
+; the Free Software Foundation; either version 2 of the License, or     
+; (at your option) any later version.
+;-
 ;
 function DIAG_MATRIX, input, position, $
                       debug=debug, help=help, test=test
@@ -10,87 +71,98 @@
 if N_PARAMS() EQ 0 then MESSAGE, 'Incorrect number of arguments.'
 ;
 if KEYWORD_SET(help) then begin
-   print, 'function DIAG_MATRIX, input, position, $'
-   print, '                      debug=debug, help=help, test=test'
-   return, -1
+    print, 'function DIAG_MATRIX, input, position, $'
+    print, '                      debug=debug, help=help, test=test'
+    return, -1
 endif
 ;
 if SIZE(input,/n_dim) GT 2 then begin
-   MESSAGE, 'Only 1 or 2 dimensions allowed '+input
+    MESSAGE, 'Only 1 or 2 dimensions allowed '+input
 endif
 ;
+; case 1, first usage: returning the diagonal
+;
 if (SIZE(input,/n_dim) EQ 2) then begin
-   if N_PARAMS() EQ 1 then position=0
-   info_size=SIZE(input,/dim)
-   x=info_size[0]
-   y=info_size[1]
-   ;;   
-   diag=INDGEN(MIN([x,y]))
-   ;;
-   if (position EQ 0) then begin
-      xx=diag
-      yy=diag
-   endif
-   ;;
-   if (position GT 0) then begin
-      if (position GE x) then begin
-         MESSAGE, '% Specified offset to array is out of range: '+STRING(position)+' versus: '+STRING(x)
-      endif
-      xx=diag+position
-      xx=xx[WHERE(xx LT x)]
-      yy=diag[0:N_ELEMENTS(xx)-1]
-   endif  
-   if (position LT 0) then begin
-      if (ABS(position) GE y) then begin
-         MESSAGE, '% Specified offset to array is out of range: '+STRING(position)+' versus: '+STRING(y)
-      endif
-      yy=diag+ABS(position)
-      yy=yy[WHERE(yy LT y)]
-      xx=diag[0:N_ELEMENTS(yy)-1]
-   endif
-   resu=REFORM(input[xx,yy])
-   if KEYWORD_SET(debug) then begin
-      print, '-----------------------'
-      print, 'x :', x, ', y :', y, ', Position indice: ', position
-      print, 'input matrix :'
-      print, input
-      print, 'position XX :', xx
-      print, 'position YY :', yy
-      print, 'extracted vector :', resu
-   endif
+    if N_PARAMS() EQ 1 then position=0
+    info_size=SIZE(input,/dim)
+    x=info_size[0]
+    y=info_size[1]
+    ;;   
+    diag=INDGEN(MIN([x,y]))
+    ;;
+    if (position EQ 0) then begin
+        xx=diag
+        yy=diag
+    endif
+    ;;
+    txt='% Specified offset to array is out of range: '
+    ;;
+    if (position GT 0) then begin
+        if (position GE x) then begin
+            MESSAGE, txt+STRING(position)+' versus: '+STRING(x)
+        endif
+        xx=diag+position
+        xx=xx[WHERE(xx LT x)]
+        yy=diag[0:N_ELEMENTS(xx)-1]
+    endif  
+    if (position LT 0) then begin
+        if (ABS(position) GE y) then begin
+            MESSAGE, txt+STRING(position)+' versus: '+STRING(y)
+        endif
+        yy=diag+ABS(position)
+        yy=yy[WHERE(yy LT y)]
+        xx=diag[0:N_ELEMENTS(yy)-1]
+    endif
+    resu=REFORM(input[xx,yy])
+    if KEYWORD_SET(debug) then begin
+        print, '-----------------------'
+        print, 'x :', x, ', y :', y, ', Position indice: ', position
+        print, 'input matrix :'
+        print, input
+        print, 'position XX :', xx
+        print, 'position YY :', yy
+        print, 'extracted vector :', resu
+    endif
 endif
 ;
+; case 2: second usage: generating a square matrix populated
+; by "diagonals" passed by argument, with a given "offset".
+;
 if (SIZE(input,/n_dim) LE 1) then begin
-   if N_PARAMS() EQ 1 then position=0
-   nbp=N_ELEMENTS(input)+ABS(position)
-   resu=FLTARR(nbp,nbp)
-   diag=INDGEN(nbp)
-   if (position EQ 0) then begin
-      resu[diag,diag]=input
-      xx=diag
-      yy=diag
-   endif
-   if (position GT 0) then begin
-      xx=diag+position
-      xx=xx[WHERE(xx LT nbp)]
-      yy=diag[0:N_ELEMENTS(xx)-1]
-      resu[xx,yy]=input
-   endif
-   if (position LT 0) then begin
-      yy=diag+ABS(position)
-      yy=yy[WHERE(yy LT nbp)]
-      xx=diag[0:N_ELEMENTS(yy)-1]
-      resu[xx,yy]=input
-   endif
-   if KEYWORD_SET(debug) then begin
-      print, '-----------------------'
-      print, 'Position indice: ', position
-      print, 'input vector :', input
-      print, 'position XX :', xx
-      print, 'position YY :', yy
-      print, 'computed matrix :'
-      print, resu
-   endif      
+    ;; determining the size of the output matrix
+    if N_PARAMS() EQ 1 then position=0
+    nbp=N_ELEMENTS(input)+ABS(position)
+    ;; creating wthe output matrix with adequate type
+    type=SIZE(input,/type)
+    resu=MAKE_ARRAY(nbp,nbp, type=type)
+    ;;
+    diag=INDGEN(nbp)
+    if (position EQ 0) then begin
+        resu[diag,diag]=input
+        xx=diag
+        yy=diag
+    endif
+    if (position GT 0) then begin
+        xx=diag+position
+        xx=xx[WHERE(xx LT nbp)]
+        yy=diag[0:N_ELEMENTS(xx)-1]
+        resu[xx,yy]=input
+    endif
+    if (position LT 0) then begin
+        yy=diag+ABS(position)
+        yy=yy[WHERE(yy LT nbp)]
+        xx=diag[0:N_ELEMENTS(yy)-1]
+        resu[xx,yy]=input
+    endif
+    if KEYWORD_SET(debug) then begin
+        print, '-----------------------'
+        print, 'Position indice: ', position
+        print, 'input vector :', input
+        print, 'position XX :', xx
+        print, 'position YY :', yy
+        print, 'computed matrix :'
+        print, resu
+    endif      
 endif
 ;
 if KEYWORD_SET(test) then STOP
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/pro/dialog_pickfile.pro gdl/src/pro/dialog_pickfile.pro
--- gdl-0.9.3/src/pro/dialog_pickfile.pro	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/pro/dialog_pickfile.pro	2013-05-16 12:36:33.775855908 -0600
@@ -116,6 +116,10 @@
 ; 14-NOV-2012: - large part of code, common with DIALOG_MESSAGE,
 ;                related to Zenity, moved into ZENITY_CHECK()
 ;
+; 14-May-2013: - correcting "bug" 3612324: must start in current directory when
+;              no path given. This problem appears due to change in
+;              Zenity in Gnome3 (e.g. : http://www.kirsle.net/blog/kirsle/zenity-and-gnome-3)
+;
 ;-
 ;
 ; This function try to reproduce the IDL's DIALOG_PICKFILE behavior using "zenity".
@@ -141,8 +145,8 @@
 ;
 ;-
 ; LICENCE:
-; Copyright (C) 2010, Maxime Lenoir (main author) and Alain Coulais
-; (idea, contact)
+; Copyright (C) 2010, Maxime Lenoir (main author) and Alain Coulais (idea, contact)
+;
 ; This program is free software; you can redistribute it and/or modify  
 ; it under the terms of the GNU General Public License as published by  
 ; the Free Software Foundation; either version 2 of the License, or     
@@ -180,6 +184,10 @@
                      zenity_version=zenity_version, $
                      help=help, test=test, debug=debug, verbose=verbose)
 ;
+if (!zenity.version LT 0) then begin
+   return, ''
+endif
+;
 ; Check default_extension
 if KEYWORD_SET(default_extension) then default_extension=STRING(default_extension[0])
 ;
@@ -205,14 +213,24 @@
 ; if path and file are set, then initial = path/file if exists, path otherwise (or current working directory if invalid path)
 ; if file is set, initial = file
 ; Zenity can't initialy select a non-exising file/directory
+;
+; in gnome3, by default, Zenity (eg: 3.4.0 in Ubuntu 12.04)
+; uses value storing in ~/.recently-used
+; for the path. We must set it up now :(  
+; (no side effects found up to now with older versions of Zenity)
+;
 start=''
 if KEYWORD_SET(path) then begin
-    path=STRING(path[0])
-    start+=path+path_sep()
-endif
-
+   path=STRING(path[0])
+   start+=path+path_sep()
+endif else begin
+   CD, current=current
+   path=current
+   start+=current+path_sep()
+end
+;
 if KEYWORD_SET(file) then file=STRING(file[0])
-
+;
 if start ne '' then begin
    if KEYWORD_SET(file) && FILE_TEST(start+file) then begin
       cmd+='--filename="'+start+file+'" ' 
Only in gdl-0.9.3/src/pro/dicom: Makefile.in
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/pro/doc_library.pro gdl/src/pro/doc_library.pro
--- gdl-0.9.3/src/pro/doc_library.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/pro/doc_library.pro	2013-03-01 10:35:35.000000000 -0700
@@ -0,0 +1,92 @@
+;+
+; NAME:
+;	DOC_LIBRARY
+;
+; PURPOSE:
+;	Extract and display documentation headers from a program or routine.
+;
+; CATEGORY:
+;	Documentation
+;
+; CALLING SEQUENCE:
+;	DOC_LIBRARY, procedure
+;
+; INPUTS:
+;	procedure	STRING	The procedure to document.
+;
+; KEYWORD PARAMETERS:
+;	/print	Set to print the output to the default printer.
+;
+; SIDE EFFECTS:
+;	A file is created in /tmp and deleted after use.
+;
+; RESTRICTIONS:
+;	Only one documentation block per file is handled.
+;
+; EXAMPLE:
+;	DOC_LIBRARY, 'doc_library'
+;
+; MODIFICATION HISTORY:
+;	Original: 2013-March-28; SJT (see Feature Requests 3606434)
+;
+; LICENCE:
+;       This code in under GNU GPL v2 or later
+;
+;-
+pro DOC_LIBRARY, proc, print = print, test=test
+
+ON_ERROR, 2
+
+if (!version.os_family ne 'unix') then begin
+    print,  "DOC_LIBRARY is currently only available for Unix like systems"
+    return
+endif
+
+if (KEYWORD_SET(print)) then begin
+    less =  FILE_WHICH(getenv('PATH'), 'lp')
+    if (less eq '') then less = FILE_WHICH(GETENV('PATH'), 'lpr')
+    if (less eq '') then begin
+        print, "Neither lp nor lpr was found"
+        return
+    endif
+endif else begin
+    less = FILE_WHICH(GETENV('PATH'), 'less')
+    if (less eq '') then less = FILE_WHICH(GETENV('PATH'), 'more')
+    if (less eq '') then begin
+        print, "Neither more nor less was found"
+        return
+    endif
+endelse
+
+proc_path = FILE_WHICH(proc+'.pro', /include_current)
+if (proc_path eq '') then begin
+    print, proc, ' not found'
+    return
+endif
+
+out_name = '/tmp/'+proc+'.txt'
+
+OPENR, ipu, proc_path, /get
+dflag = 0b
+inln = ''
+
+OPENW, isu, out_name, /get
+
+while (~EOF(ipu)) do begin
+    READF, ipu, inln
+    inln = STRTRIM(inln, 2)
+    if (STRPOS(inln, ';+') eq 0) then dflag = 1b
+    if (STRPOS(inln, ';-') eq 0) then break
+    ;;
+    if dflag then printf, isu, STRMID(inln, 1)
+endwhile
+;
+FREE_LUN,  isu,  ipu
+;
+SPAWN, less+' '+out_name
+;
+FILE_DELETE, out_name
+;
+if KEYWORD_SET(test) then STOP
+;
+end
Only in gdl-0.9.3/src/pro/envi: Makefile.in
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/pro/interpol.pro gdl/src/pro/interpol.pro
--- gdl-0.9.3/src/pro/interpol.pro	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/pro/interpol.pro	2013-02-25 17:04:31.344153596 -0700
@@ -8,6 +8,9 @@
 ; We have to manage also points in "p2" outside "p1" range ...
 ; (new cases not include in testsuite/test_interpol.pro)
 ;
+; revised 18-Feb-2013 by Alain C. after bug report 3602770
+; We have to manage NaN and Infinity ...
+;
 function INTERPOL, p0, p1, p2, lsquadratic=lsquadratic, $
                    quadratic=quadratic, spline=spline, $
                    test=test, help=help, debug=debug
@@ -15,35 +18,35 @@
 ON_ERROR, 2
 ;
 if KEYWORD_SET(help) then begin
-   print, 'function INTERPOL, p0, p1, p2, lsquadratic=lsquadratic, $'
-   print, '                   quadratic=quadratic, spline=spline, $'
-   print, '                   test=test, help=help, debug=debug'
-   print, '/lsquadratic and /quadratic not available, help welcome !'
-   return, -1
+    print, 'function INTERPOL, p0, p1, p2, lsquadratic=lsquadratic, $'
+    print, '                   quadratic=quadratic, spline=spline, $'
+    print, '                   test=test, help=help, debug=debug'
+    print, '/lsquadratic and /quadratic not available, help welcome !'
+    return, -1
 endif
 ;
 ;; sanity checks
 ;
 if N_PARAMS() eq 1 then $
-   MESSAGE, 'Two or three parameters required'
+  MESSAGE, 'Two or three parameters required'
 if KEYWORD_SET(lsquadratic) then $
-   MESSAGE, 'LSQUADRATIC keyword not supported yet (FIXME!)'
+  MESSAGE, 'LSQUADRATIC keyword not supported yet (FIXME!)'
 if KEYWORD_SET(quadratic) then $
-   MESSAGE, 'QUADRATIC keyword not supported yet (FIXME!)'
+  MESSAGE, 'QUADRATIC keyword not supported yet (FIXME!)'
 ;
 ;  if N_PARAMS() eq 3 and N_ELEMENTS(p0) ne N_ELEMENTS(p1) then $
 ;    MESSAGE, 'In the three-parameter case the first and second argument must be of equal length'
 ; <see bug no. 3104537>
 if N_PARAMS() eq 3 then begin
-   if N_ELEMENTS(p0) ne N_ELEMENTS(p1) then $
+    if N_ELEMENTS(p0) ne N_ELEMENTS(p1) then $
       MESSAGE, 'In the three-parameter case the first and second argument must be of equal length'
-   ;;
-   ;; note by AC, 27-02-2012: is it really true ??
-   all_equal_test=ABS((p1 - SHIFT(p1,+1))(1:*))
-   if MIN(TEMPORARY(all_equal_test)) eq 0 then begin
-      MESSAGE, /cont, $         ; usually only triggered for integer arrays
-               'In the three-parameter case, the second argument must be strictly increasing or strictly decreasing.'
-   endif
+    ;;
+    ;; note by AC, 27-02-2012: is it really true ??
+    all_equal_test=ABS((p1 - SHIFT(p1,+1))(1:*))
+    if MIN(TEMPORARY(all_equal_test)) eq 0 then begin
+        MESSAGE, /cont, $  ; usually only triggered for integer arrays
+          'In the three-parameter case, the second argument must be strictly increasing or strictly decreasing.'
+    endif
 endif
 ; </...>
 ;
@@ -53,62 +56,92 @@
 nbp_inside=N_ELEMENTS(p0)
 nbp_outside=0
 ;
+ExistNotFinite=0
+;
 if N_PARAMS() eq 2 then begin
-   ;; regular grid case
-   if SIZE(p1, /dimensions) eq 0 then begin
-       ind = FINDGEN(p1) / (p1 - (p1 eq 1 ? 0 : 1)) * (N_ELEMENTS(p0) - 1)
-   endif else begin
-      MESSAGE, 'In the two-parameter case the second parameter must be a scalar'
-      ;; TODO: IDL does something else here...
-   endelse
+    ;; regular grid case
+    if SIZE(p1, /dimensions) eq 0 then begin
+        ind = FINDGEN(p1) / (p1 - (p1 eq 1 ? 0 : 1)) * (N_ELEMENTS(p0) - 1)
+    endif else begin
+        MESSAGE, 'In the two-parameter case the second parameter must be a scalar'
+        ;; TODO: IDL does something else here...
+    endelse
 endif else if ~KEYWORD_SET(spline) then begin
-   ;; irregular grid case
-   ;; we need to manage points outside p1 range
-   p1_min=MIN(p1, max=p1_max)
-   outside_OK=WHERE((p2 LT p1_min) OR (p2 GT p1_max), nbp_outside)
-   if (nbp_outside GT 0) then begin
-      outside=p2[outside_OK]
-      inside_OK=WHERE((p2 GE p1_min) AND (p2 LE p1_max), nbp_inside)
-      if (nbp_inside GT 0) then begin
-         p2_inside=p2[inside_OK]
-         ind = FINDEX(p1, p2_inside)
-      endif      
-   endif else begin
-      ;; if we are here, all the points in "p2" are inside "p1" range
-      ind=FINDEX(p1,p2)
-   endelse
+    ;; first, we exclude the NaN and Infinity values ...
+    ;; if fact, we copy in another array the not finite values ...
+    p2_info=SIZE(p2,/dim)
+    index_p2_finite=WHERE(FINITE(p2) EQ 1, nbp_ok)
+    if (nbp_ok GT 0) then begin
+        if (N_ELEMENTS(p2) GT nbp_ok) then begin
+            ExistNotFinite=1
+            index_p2_not_finite=WHERE(FINITE(p2) EQ 0)
+            p2_not_finite=p2[index_p2_not_finite]
+            p2=p2[index_p2_finite]
+        endif else begin
+            ;; all data are finite ... we don't need to recopy
+            ExistNotFinite=0
+        endelse
+    endif else begin
+        ;; all input data are not finite ...
+        if KEYWORD_SET(test) then STOP
+        return, p2
+    endelse
+    ;; irregular grid case
+    ;; we need to manage points outside p1 range
+    p1_min=MIN(p1, max=p1_max)
+    outside_OK=WHERE((p2 LT p1_min) OR (p2 GT p1_max), nbp_outside)
+    if (nbp_outside GT 0) then begin
+        outside=p2[outside_OK]
+        inside_OK=WHERE((p2 GE p1_min) AND (p2 LE p1_max), nbp_inside)
+        if (nbp_inside GT 0) then begin
+            p2_inside=p2[inside_OK]
+            ind = FINDEX(p1, p2_inside)
+        endif      
+    endif else begin
+        ;; if we are here, all the points in "p2" are inside "p1" range
+        ind=FINDEX(p1,p2)
+    endelse
 endif
 ;
 if KEYWORD_SET(spline) then begin
+   if (N_ELEMENTS(p0) LT 4) then MESSAGE, 'as least 4 input points need !'
    ;; spline case
    if N_PARAMS() eq 2 then begin
-      x = FINDGEN(N_ELEMENTS(p0))
-      y = SPL_INTERP(x, p0, SPL_INIT(x, p0), ind)
-   endif else begin
-      y = SPL_INTERP(p1, p0, SPL_INIT(p1, p0), p2)
-   endelse
-   result=FIX(TEMPORARY(y), type=SIZE(p0, /type))
+        x = FINDGEN(N_ELEMENTS(p0))
+        y = SPL_INTERP(x, p0, SPL_INIT(x, p0), ind)
+    endif else begin
+       if (N_ELEMENTS(p1) LT 4) then MESSAGE, 'as least 4 input points need !'
+        y = SPL_INTERP(p1, p0, SPL_INIT(p1, p0), p2)
+    endelse
+    result=FIX(TEMPORARY(y), type=SIZE(p0, /type))
 endif else begin
-   ;; linear interpolation case
-   if (nbp_inside GT 0) then result=INTERPOLATE(isint ? FLOAT(p0) : p0, ind)
-   if (nbp_outside GT 0) then begin
-      tmp=p2
-      if (nbp_inside GT 0) then tmp[inside_OK]=result
-      last=N_ELEMENTS(p0)-1
-      slope_begin=(1.*p0[1]-p0[0])/(p1[1]-p1[0])
-      slope_end  =(1.*p0[last-1]-p0[last])/(p1[last-1]-p1[last])
-      for ii=0, nbp_outside-1 do begin
-         if outside[ii] LT p1_min then begin
-            tmp[outside_OK[ii]]=slope_begin*(outside[ii]-p1[0])+p0[0]
-         endif else begin
-            tmp[outside_OK[ii]]=slope_end*(outside[ii]-p1[last-1])+p0[last-1]
-         endelse
-      endfor
-      result=tmp
-   endif
+    ;; linear interpolation case
+    if (nbp_inside GT 0) then result=INTERPOLATE(isint ? FLOAT(p0) : p0, ind)
+    if (nbp_outside GT 0) then begin
+        tmp=p2
+        if (nbp_inside GT 0) then tmp[inside_OK]=result
+        last=N_ELEMENTS(p0)-1
+        slope_begin=(1.*p0[1]-p0[0])/(p1[1]-p1[0])
+        slope_end  =(1.*p0[last-1]-p0[last])/(p1[last-1]-p1[last])
+        for ii=0, nbp_outside-1 do begin
+            if outside[ii] LT p1_min then begin
+                tmp[outside_OK[ii]]=slope_begin*(outside[ii]-p1[0])+p0[0]
+            endif else begin
+                tmp[outside_OK[ii]]=slope_end*(outside[ii]-p1[last-1])+p0[last-1]
+            endelse
+        endfor
+        result=tmp
+    endif
 endelse
 ;
-if KEYWORD_SET(test) then STOP
+if ExistNotFinite then begin
+    resres=MAKE_ARRAY(p2_info, type=SIZE(result,/type))
+    resres[index_p2_not_finite]=p2_not_finite
+    resres[index_p2_finite]=result    
+    result=resres
+endif
+;
+if KEYWORD_SET(test) or KEYWORD_SET(debug) then STOP
 ;
 return, result
 ;
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/pro/loadct.pro gdl/src/pro/loadct.pro
--- gdl-0.9.3/src/pro/loadct.pro	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/pro/loadct.pro	2013-02-25 17:04:31.359153537 -0700
@@ -22,6 +22,8 @@
 ;	NCOLORS   number of colors to use. the smaller of
 ;                 !D.TABLE_SIZE-1 and NCOLORS is used
 ;       BOTTOM    first color index to use
+;       RGB_TABLE=mytable return table colors in mytable, do not load 
+;                         colortable.
 ;
 ; OUTPUTS:
 ;	none
@@ -58,7 +60,7 @@
 ;-
 
 pro LOADCT, table, GET_NAMES=names, FILE=file,$
-            NCOLORS=nColors,BOTTOM=bottom,SILENT=silent
+            NCOLORS=mynColors,BOTTOM=mybottom,SILENT=silent,RGB_TABLE=rgb_table
 
 on_error, 2
 common colors, r_orig, g_orig, b_orig, r_curr, g_curr, b_curr
@@ -70,8 +72,7 @@
   return
 endif
 
-if N_ELEMENTS( table) eq 0 or not KEYWORD_SET( silent) then begin
-
+if N_ELEMENTS( table) eq 0 or not KEYWORD_SET(silent) then begin 
     LOADCT_INTERNALGDL,GET_NAMES=names
     if n_elements( table) eq 0 then begin
         for n=0,n_elements(names)-1 do begin
@@ -82,13 +83,26 @@
     endif
 endif
 
+if KEYWORD_SET(RGB_TABLE) then begin
+  LOADCT_INTERNALGDL,table,RGB_TABLE=rgb_table
+  return
+endif
+
 LOADCT_INTERNALGDL,table
 
 if not KEYWORD_SET( silent) then begin
    MESSAGE,'Loading table ' + names[table],/INFO
 endif
 
-if N_ELEMENTS(bottom) eq 0 then bottom=0
+if N_ELEMENTS(mybottom) eq 0 then bottom=0 else begin
+ bottom=mybottom 
+ bottom >= 0 & bottom <= !D.TABLE_SIZE-1
+end
+if N_ELEMENTS(mynColors) eq 0 then nColors=!D.TABLE_SIZE else begin
+ nColors=mynColors
+ nColors >= 1 & nColors <=!D.TABLE_SIZE
+end
+if (bottom+nColors GE !D.TABLE_SIZE) then nColors=!D.TABLE_SIZE-bottom
 
 TVLCT,r,g,b,/GET
 
@@ -98,14 +112,10 @@
     b_orig = bytarr( !D.TABLE_SIZE)
  endif
 
-if KEYWORD_SET(Ncolors) then begin
-   if N_ELEMENTS(Ncolors) NE 256 then begin
-      idx=Lindgen(Ncolors)*255/(Ncolors-1)
-      r=r[idx]
-      g=g[idx]
-      b=b[idx]
-   endif
-endif
+idx=Lindgen(nColors)*(!D.TABLE_SIZE-1)/(nColors-1)
+r=r[idx]
+g=g[idx]
+b=b[idx]
 
 r_orig[bottom] = r
 g_orig[bottom] = g
@@ -114,7 +124,7 @@
 g_curr = g_orig
 b_curr = b_orig
 
-TVLCT, r, g, b, bottom
+TVLCT, r_curr, g_curr, b_curr
 
 end
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/pro/Makefile.am gdl/src/pro/Makefile.am
--- gdl-0.9.3/src/pro/Makefile.am	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/pro/Makefile.am	2013-03-21 14:04:04.649823919 -0600
@@ -12,6 +12,7 @@
   dialog_message.pro \
   dialog_pickfile.pro \
   dist.pro \
+  doc_library.pro \
   escape_special_char.pro \
   factorial.pro \
   file_basename.pro \
@@ -47,6 +48,7 @@
   meanabsdev.pro \
   moment.pro \
   norm.pro \
+  online_help.pro \
   path_sep.pro \
   ploterr.pro \
   poly.pro \
Only in gdl-0.9.3/src/pro: Makefile.in
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/pro/matrix_multiply.pro gdl/src/pro/matrix_multiply.pro
--- gdl-0.9.3/src/pro/matrix_multiply.pro	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/pro/matrix_multiply.pro	2013-05-16 12:36:33.776855904 -0600
@@ -5,26 +5,60 @@
 ;
 ; AUTHOR: Philippe Prugniel 2008/02/29
 ;
-; Copyright (C) 2008, 
+; Modifications:
+; 05-Feb-2013: when GDL is compiled with Eigen Lib., we use internal
+;              fast MATMUL function. It is not ready for Complex/DoubleComplex
+; 01-Mar-2013: with Eigen Lib, matmul function is OK with complex values, removed
+;              some code
+; 28-Mar-2013: MATMUL removed, direct interface to Eigen3, all types
+;              should be OK
+;
+; Copyright (C) 2008, 2013.
 ; This program is free software; you can redistribute it and/or modify
 ; it under the terms of the GNU General Public License as published by
 ; the Free Software Foundation; either version 2 of the License, or
 ; (at your option) any later version.
 ; 
 ;-----------------------------------------------------------------------------
-function matrix_multiply, a, b, ATRANSPOSE=atr, BTRANSPOSE=btr
-  on_error, 2
-
-  IF (N_PARAMS() NE 2) THEN BEGIN
-    message, 'Incorrect number of arguments.'
-  ENDIF
-;
-  case (1) of
-    keyword_set(atr) and not keyword_set(btr): return, transpose(a) # b
-    keyword_set(btr) and not keyword_set(atr): return, a # transpose(b)
-    keyword_set(atr) and keyword_set(btr): return, transpose(a) # transpose(b)
+;
+function MATRIX_MULTIPLY, a, b, ATRANSPOSE=atr, BTRANSPOSE=btr, help=help
+;
+ON_ERROR, 2
+;
+if KEYWORD_SET(help) then begin
+    print, 'function MATRIX_MULTIPLY, a, b, ATRANSPOSE=atr, BTRANSPOSE=btr, help=help'
+    return, -1
+endif
+;
+IF (N_PARAMS() NE 2) THEN BEGIN
+    MESSAGE, 'Incorrect number of arguments.'
+ENDIF
+;
+; note by AC, 28 MArch 2013: we don't removed that if we need
+; to go back to basic tests related to Eigen3 ...
+;
+; "type" will be 1 if GDL compiled with Eigen, 0
+; !matmul_quiet to avoid repeating internal message if no Eigen around ...
+;
+;DEFSYSV, "!matmul_quiet", exist=quiet
+;if ~quiet then begin
+;    type=MATMUL(/available, quiet=quiet)
+;    DEFSYSV, "!matmul_quiet", 1, 1
+;endif else begin
+;    type=MATMUL(/available,/quiet)
+;endelse
+;
+;if (type EQ 0) then begin
+ 
+case (1) of
+    KEYWORD_SET(atr) and not KEYWORD_SET(btr): return, TRANSPOSE(a) # b
+    KEYWORD_SET(btr) and not KEYWORD_SET(atr): return, a # TRANSPOSE(b)
+    KEYWORD_SET(atr) and KEYWORD_SET(btr): return, TRANSPOSE(a) # TRANSPOSE(b)
     else : return, a # b
-  endcase
+endcase
+;endif else begin
+;    return, MATMUL(a, b, ATRANSPOSE=atr, BTRANSPOSE=btr, debug=debug)
+;endelse
 ;
 end
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/pro/online_help.pro gdl/src/pro/online_help.pro
--- gdl-0.9.3/src/pro/online_help.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/pro/online_help.pro	2013-05-16 12:36:33.777855900 -0600
@@ -0,0 +1,261 @@
+;+
+;
+; NAME:   ONLINE_HELP
+;
+; PURPOSE: accessing the documentation, the general one or for a given
+;          procedure of function (intrinsic or not)
+;
+; CATEGORY: documentation
+;
+; CALLING SEQUENCE:  ( ? or ONLINE_HELP ) or ( ?fft or ONLINE_HELP, 'fft')
+;
+; INPUTS: no mandatory ones
+;
+; OPTIONAL INPUTS: name of a procedure, function or code
+;
+; KEYWORD PARAMETERS: 
+;   original ones: book=, context=, full_path=, title=
+;   extensions : nopdf=nopdf, nohtml=nohtml, nokey=nokey, browser=browser, $
+;                 path2pdf=path2pdf, path2key=path2key, link2html=link2htlm, $
+;                 test=test, debug=debug, help=help, verbose=verbose 
+;
+; OUTPUTS: none
+;
+; OPTIONAL OUTPUTS: none
+;
+; COMMON BLOCKS: none
+;
+; SIDE EFFECTS: may or not succeed to start a WEB browser.
+;
+; RESTRICTIONS:
+;
+; 1/ except if a copy of the "GDL.pdf" is locally available
+; and in the !path, an internet connection is mandatory ...
+;
+; 2/ the result is very sensitive to the version of the WEB browser
+; and which plugings (and pluging versions) are available.
+;
+; PROCEDURE: straitforward
+;
+; EXAMPLE:  ONLINE_HELP, 'fft', browser='midori'
+;
+; MODIFICATION HISTORY:
+; -- 01-March-2013: creation by Alain Coulais, 
+; -- 18-April-2013: managing the book= keyword, with/out /full_path
+; 
+; LICENCE: This code is under GNU GPL v2 or later.
+;
+;
+; Very preliminary concept. the goal is to link to internal pages of 
+; the PDF file "gdl.pdf" (eventually downloaded if not found)
+; (currently at: http://gnudatalanguage.sourceforge.net/gdl.pdf)
+; and also starting online HTML doc.
+;
+; The PDF file is currently at: http://gnudatalanguage.sourceforge.net/gdl.pdf
+; Following Adobe Documention, direct links to page, chapter shall be possible 
+; http://partners.adobe.com/public/developer/en/acrobat/PDFOpenParameters.pdf
+; We use now only the search option ralated to Acroread viewer.
+; Up to now, no equivalent functions inside alternative PDF
+; readers (evince, xpdf) but is is supposed to be OK with "pdf.js"
+; pluging in Firefox https://github.com/mozilla/pdf.js/issues/1875
+;
+; We have to consider to have local HTML version of the documentation.
+;
+; It seems that recent Firefox browsers can be call passing --new-tab
+; / --new-win
+;
+;-
+pro ONLINE_HELP, name, book=book, context=context, full_path=full_path, title=title, $
+                 nopdf=nopdf, nohtml=nohtml, nokey=nokey, browser=browser, $
+                 path2pdf=path2pdf, path2key=path2key, link2html=link2htlm, $
+                 test=test, debug=debug, help=help, verbose=verbose
+;
+ON_ERROR, 2
+;
+if ~KEYWORD_SET(test) then ON_ERROR, 2
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro ONLINE_HELP, name, book=book, context=context, full_path=full_path, title=title, $'
+    print, '                 nopdf=nopdf, nohtml=nohtml, nokey=nokey, browser=browser, $'
+    print, '                 path2pdf=path2pdf, path2key=path2key, link2html=link2htlm, $'
+    print, '                 test=test, debug=debug, help=help, verbose=verbose'
+    print, ''
+    return
+endif
+;
+if N_PARAMS() EQ 0 then name=''
+;
+if N_PARAMS() EQ 1 then name=STRCOMPRESS(name,/remove_all)
+;
+; do we have access to X11 ??
+; (we may consider using Lynx (tested succesfully) but is it really
+; useful ?)
+;
+status=EXECUTE('xy=GET_SCREEN_SIZE()')
+if (status EQ 0) then begin
+   MESSAGE, 'Since we are unable to connect to X Windows display, no ONLINE HELP'
+endif
+;
+if KEYWORD_SET(context) then begin
+    MESSAGE, /continue, 'This option (only MSwin) is not available'
+endif
+;
+; setting a default browser if not provided
+; this code was tested with konqueror, midori and firefox
+;
+if ~KEYWORD_SET(browser) then begin
+   ;; classical default !
+   browser='firefox'
+   ;;
+   ;; on some GNU/Linux systems, a BROWSER is defined ...
+   default_browser=GETENV('BROWSER')
+   if (STRLEN(default_browser) GT 0) then browser=default_browser
+   ;;
+   ;; on OSX, it seems to be better to use "open" but this is not
+   ;; working over ssh -X connection ... (suggestion welcome !)
+   ;;
+   if (!version.os EQ 'darwin') then browser='open'
+endif
+;
+; we check if the default or selected brower is in the path
+;
+SPAWN, 'which '+browser, ok, error
+;
+if (STRLEN(ok) EQ 0) then begin
+    MESSAGE, /continue, 'WEB Browser not found : '+browser
+    MESSAGE, 'Please provide the name (+path) to the browser you want to use'
+endif
+;
+space=' '
+background=' &'
+;
+if KEYWORD_SET(book) then begin
+    ;;
+    ;; when the document is a PDF file, we try to use a PDF viewer
+    ;;
+    idx_suffixe=STRPOS(book, '.', /reverse_search)
+    ;; when the suffixe is not found we keed "browser"
+    if (idx_suffixe GE 0) then begin
+        suffixe=STRMID(book, idx_suffixe+1)
+        if STRLOWCASE(suffixe) EQ 'pdf' then begin
+            ;; don't hesitate to complete this list
+            list_of_pdf_viewers=['xpdf','evince','acroread']
+            ;; if we don't locate a PDF viewer, we will use the default (web) Brower
+            for ii=0, N_ELEMENTS(list_of_pdf_viewers)-1 do begin
+                SPAWN, 'which '+list_of_pdf_viewers[ii], ok, error
+                if (STRLEN(ok) NE 0) then begin
+                    browser=list_of_pdf_viewers[ii]
+                    break
+                endif
+            endfor
+        endif
+    endif
+    if ~KEYWORD_SET(full_path) then begin
+        ;;message, /continue, 'ToDo : managing !HELP_PATH'
+        DEFSYSV, '!HELP_PATH', exist=exist
+        if exist then begin
+            book=FILE_WHICH(!HELP_PATH,book)
+            if (STRLEN(book) EQ 0) then MESSAGE, 'no file found, please check !HELP_PATH and book name'
+        endif else begin
+            ;; falling back to standard multi-tab help
+            MESSAGE, /continue, '!HELP_PATH not set !'
+        endelse
+    endif
+    ;; we have to check whether the file exist or not !!
+    if FILE_TEST(book) then begin
+        command=browser+space+book+background
+        goto, execute_command
+    endif
+endif
+;
+; link to IDL exelis in-line documentation
+;
+link1=''
+if ~KEYWORD_SET(nohtml) then begin
+    if ~KEYWORD_SET(link2html) then link2html='http://www.exelisvis.com/docs/'
+    suffixe='.html'
+    ;;
+    if STRLEN(name) GT 0 then begin
+        link1=space+link2html+STRUPCASE(name)+suffixe
+    endif else begin
+        link1=space+link2html
+    endelse
+endif
+;
+; link to PDF 
+; if not found in the !PATH, this file is downloaded the first time
+;
+link2=''
+if ~KEYWORD_SET(nopdf) then begin
+    path2pdf='http://gnudatalanguage.sourceforge.net/'
+    local_pdf=FILE_WHICH(!path, 'gdl.pdf',/include_current_dir)
+    ;;
+    ;; if no "gdl.pdf" in the !Path, trying to download it
+    if STRLEN(local_pdf) EQ 0 then begin
+        script=''
+        SPAWN, 'which wget', res
+        if STRLEN(res) GT 0 then begin
+            script='wget '
+        endif else begin
+            SPAWN, 'which curl', res
+            if STRLEN(res) GT 0 then script='curl -O '
+        endelse
+        if (STRLEN(script) GT 0) then begin
+            SPAWN, script+path2pdf+'gdl.pdf', ok, pb
+        endif
+        local_pdf=FILE_WHICH(!path, 'gdl.pdf',/include_current_dir)
+    endif
+    ;;
+    if (STRLEN(local_pdf) GT 0) then begin
+        if STRLEN(name) GT 0 then begin
+            ;; activating the search capability inside PDF, 
+            ;; worked on Acroread pluging
+            ;; should worked withing 
+            link2='file://'+FILE_EXPAND_PATH(local_pdf)+'#search="'+name+'"'
+        endif else begin
+            link2='file://'+FILE_EXPAND_PATH(local_pdf)
+        endelse
+    endif else begin
+        MESSAGE, /continue, 'GDL pdf documentaion not found :('
+    endelse
+endif
+;
+link3=''
+if ~KEYWORD_SET(nokey) then begin
+    path2key='http://aramis.obspm.fr/~coulais/IDL_et_GDL/'
+    ;;
+    if (STRLEN(name) GT 0) then begin
+       ;; is it a .PRO file ??
+       pro_file=FILE_WHICH(name+'.pro')
+       if STRLEN(pro_file) GT 0 then begin
+          link3='file://'+pro_file+space
+          link3=link3+path2key+'Matrice_IDLvsGDL.html#'+STRUPCASE(STRMID(name,0,1))
+       endif else begin
+          link3=path2key+'known_keywords.html#GDL_'+STRUPCASE(name)
+       endelse
+    endif else begin
+       link3=path2key+'Matrice_IDLvsGDL.html'
+    endelse
+endif
+;
+; line by line the command used by browser
+;
+if keyword_set(verbose) then begin
+    MESSAGE, /continue, 'link2html= : '+link2html
+    MESSAGE, /continue, 'path2pdf = : '+path2pdf
+    MESSAGE, /continue, 'path2key = : '+path2key
+endif
+;
+command=browser+space+link1+space+link2+space+link3+background
+;
+execute_command:
+;
+if KEYWORD_SET(debug) then begin
+    print, command
+    STOP
+endif
+SPAWN, command
+;
+if KEYWORD_SET(test) then stop
+;
+end
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/pro/read_ascii.pro gdl/src/pro/read_ascii.pro
--- gdl-0.9.3/src/pro/read_ascii.pro	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/pro/read_ascii.pro	2013-05-16 12:36:33.777855900 -0600
@@ -244,8 +244,8 @@
       MESSAGE, 'DATA_START value >= data length (' $
                + STRTRIM(STRING(data_start), 2) + ' >= ' $
                + STRTRIM(STRING(N_ELEMENTS(text)),2) + ')' 
-      text = text[data_start:*]
    endif
+   text = text[data_start:*]
 endif
 ;
 ;-----------------
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/pro/wmenu.pro gdl/src/pro/wmenu.pro
--- gdl-0.9.3/src/pro/wmenu.pro	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/pro/wmenu.pro	2013-01-13 16:49:28.000000000 -0700
@@ -1,8 +1,8 @@
 ;+
 ; NAME:     WMENU
 ;
-; PURPOSE: This a emulation of the famous X11 WMENU (obsolete
-; routine). We provide a Zenity-based version but also a text-based version.
+; PURPOSE: This a emulation of the famous X11 WMENU (obsolete routine).
+; We provide a Zenity-based version but also a text-based version.
 ;
 ; Credits: with some idea form EMENU (from SolarSoft (Soho, Nasa))
 ;
@@ -52,7 +52,7 @@
 ;  - 25-JAN-2006 : created by Alain Coulais
 ;  - 09-FEB-2006 : various debugging (WHERE does not work with STRINGs!)
 ;  - 13-FEB-2006 : title is a index, not a string !
-;  - 19-NOV-2012 : Zenity-based version
+;  - 19-NOV-2012 : Zenity-based version, pushed in the public CVS
 ;-
 ; LICENCE:
 ; Copyright (C) 2006-2012, Alain Coulais
@@ -216,7 +216,7 @@
 ;
 list_flag=REPLICATE('  ', nbp_local)
 if (flag_init EQ 1) then list_flag(init)='* '
-print, transpose(list_flag+answers_str+' | '+local_choice)
+print, TRANSPOSE(list_flag+answers_str+' | '+local_choice)
 ;
 if KEYWORD_SET(test) then stop
 ;
@@ -265,7 +265,7 @@
 ; --------------------------------------------------
 ;
 function WMENU_ZENITY, list_of_choice, title=title, init=init, $
-                       strict=strict, test=test, help=help
+                       strict=strict, test=test, help=help, debug=debug
 ;
 zenity=!zenity.name
 ;
@@ -287,17 +287,19 @@
 for ii=0, N_ELEMENTS(list_of_choice)-1 do begin
     reform_list_of_choice=reform_list_of_choice+' "'+Str_list_of_choice[ii]+'"'
 endfor
-
+;
 command=zenity+cmd_title+cmd_text+cmd_column_text
 command=command+' --list '+reform_list_of_choice
 ;
-help, command
+if KEYWORD_SET(debug) then HELP, command
+;
+SPAWN, command, result, error
+;
+if KEYWORD_SET(debug) then begin
+   print, 'SPAWN returned error  : ', error
+   print, 'SPAWN returned result : ', result
+endif
 ;
-spawn, command, result, error
-
-print, error
-print, result
-
 indice=WHERE(result EQ Str_list_of_choice)
 
 indice2=STRPOS(Str_list_of_choice, result)
@@ -307,22 +309,21 @@
     print, 'Warning, More than one entry found'
 endif
 indice=OK[0]
-
+;
 return, indice
-
+;
 end
-
-
+;
 ; --------------------------------------------------
 ;
 function WMENU, list_of_choice, title=title, init=init, $
-                test=test, help=help
+                test=test, help=help, debug=debug
 ;
 ON_ERROR, 2
 ;
 if KEYWORD_SET(help) then begin
     print, 'function WMENU, list_of_choice, title=title, init=init, $'
-    print, '                test=test, help=help'
+    print, '                test=test, help=help, debug=debug'
     return, -1
 end
 ;
@@ -347,9 +348,11 @@
 endif
 ;
 if (!zenity.version LT 0) then begin
-    resu=WMENU_TEXT(list_of_choice, title=title, init=init, test=test, help=help)
+    resu=WMENU_TEXT(list_of_choice, title=title, init=init, $
+                    test=test, help=help)
 endif else begin
-    resu=WMENU_ZENITY(list_of_choice, title=title, init=init, test=test, help=help)
+    resu=WMENU_ZENITY(list_of_choice, title=title, init=init, $
+                      test=test, help=help, debug=debug)
 endelse
 ;
 if KEYWORD_SET(help) then STOP
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/pro/zenity_check.pro gdl/src/pro/zenity_check.pro
--- gdl-0.9.3/src/pro/zenity_check.pro	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/pro/zenity_check.pro	2013-01-13 16:49:28.000000000 -0700
@@ -14,13 +14,9 @@
 ;
 ; KEYWORD PARAMETERS:
 ;
+; OUTPUTS: a name or ''
 ;
-;
-; OUTPUTS: a name
-;
-;
-;
-; OPTIONAL OUTPUTS: zenity_version= an u
+; OPTIONAL OUTPUTS:
 ;
 ; COMMON BLOCKS: none
 ;
@@ -55,11 +51,13 @@
 ;-
 function ZENITY_CHECK, zenity_name=zenity_name,  zenity_path=zenity_path, $
                        zenity_version=zenity_version, reset=reset, $
+                       show_path=show_path, how_to_install=how_to_install, $
                        help=help, test=test, debug=debug, verbose=verbose
 ;
 if KEYWORD_SET(help) then begin
     print, 'function ZENITY_CHECK, zenity_name=zenity_name,  zenity_path=zenity_path, $'
     print, '                       zenity_version=zenity_version, reset=reset, $'
+    print, '                       show_path=show_path, how_to_install=how_to_install, $'
     print, '                       help=help, test=test, debug=debug, verbose=verbose'
     return, -1
 endif
@@ -128,14 +126,31 @@
     endif
     if (list_zenity eq '') then begin
         MESSAGE, /continue, 'Zenity not found ! Zenity must be installed or in your PATH.'
-        MESSAGE, /continue, 'Your current path is : '+GETENV('PATH')
         MESSAGE, /continue, 'You can give a path to Zenity with keyword ZENITY_PATH='
         MESSAGE, /continue, 'or using shell $ZENITY_PATH'
-        if (STRLOWCASE(!version.OS) EQ 'darwin') then begin
-            MESSAGE, /continue, ' '
-            MESSAGE, /continue, 'How to install "zenity" on OSX ? Please have a look here:'
-            MESSAGE, /continue, 'http://www.macports.org/ports.php?by=name&substr=zenity'
-         endif
+        MESSAGE, /continue, ''        
+        ;;
+        if KEYWORD_SET(show_path) then begin
+           MESSAGE, /continue, 'Your current path where Zenity is searched in is : '
+           print, TRANSPOSE(STRSPLIT(GETENV('PATH'), ':',/extract))
+        endif else begin
+           MESSAGE, /continue, 'zen=ZENITY_CHECK(/show_path) to see the researched paths'
+        endelse
+        ;;
+        if KEYWORD_SET(how_to_install) then begin
+           MESSAGE, /continue, '  On Debian/Ubuntu like distros: sudo apt-get install zenity'
+           MESSAGE, /continue, '  On RH/FC/CentOS like distros: yum install zenity'
+           MESSAGE, /continue, '  On OSX distros: port install zenity'
+           ;;
+           if (STRLOWCASE(!version.OS) EQ 'darwin') then begin
+              MESSAGE, /continue, ' '
+              MESSAGE, /continue, 'How to install "zenity" on OSX ? Please have a look here:'
+              MESSAGE, /continue, 'http://www.macports.org/ports.php?by=name&substr=zenity'
+           endif
+        endif else begin
+           MESSAGE, /continue, 'zen=ZENITY_CHECK(/how_to_install) to see how to add Zenity'
+        endelse
+        ;;           
         zenity_struct={name: '', version: -1}
         DEFSYSV, '!zenity', zenity_struct
         return, ''
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/prognode.cpp gdl/src/prognode.cpp
--- gdl-0.9.3/src/prognode.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/prognode.cpp	2013-03-25 10:36:38.609968687 -0600
@@ -31,13 +31,19 @@
 bool* GetNonCopyNodeLookupArray()
 {
 static bool nonCopyNodeLookupArray[ GDLTokenTypes::MAX_TOKEN_NUMBER];
-for( int i=0; i<GDLTokenTypes::MAX_TOKEN_NUMBER; ++i)
-	nonCopyNodeLookupArray[ i] = false;
-nonCopyNodeLookupArray[ GDLTokenTypes::VAR] = true;
-nonCopyNodeLookupArray[ GDLTokenTypes::VARPTR] = true;
-nonCopyNodeLookupArray[ GDLTokenTypes::DEREF] = true;
-nonCopyNodeLookupArray[ GDLTokenTypes::CONSTANT] = true;
-nonCopyNodeLookupArray[ GDLTokenTypes::SYSVAR] = true;
+static bool doInit = true;
+if( doInit)
+{
+  for( int i=0; i<GDLTokenTypes::MAX_TOKEN_NUMBER; ++i)
+	  nonCopyNodeLookupArray[ i] = false;
+  nonCopyNodeLookupArray[ GDLTokenTypes::VAR] = true;
+  nonCopyNodeLookupArray[ GDLTokenTypes::VARPTR] = true;
+  nonCopyNodeLookupArray[ GDLTokenTypes::DEREF] = true;
+  nonCopyNodeLookupArray[ GDLTokenTypes::CONSTANT] = true;
+  nonCopyNodeLookupArray[ GDLTokenTypes::SYSVAR] = true;
+
+  doInit = true;
+}
 return nonCopyNodeLookupArray;
 }
 
@@ -134,20 +140,20 @@
 {
     ProgNodeP _t = this->getFirstChild();
 
-    auto_ptr<BaseGDL> r_guard;
+    Guard<BaseGDL> r_guard;
 	BaseGDL* res;
     if( _t->getType() == GDLTokenTypes::FCALL_LIB)
         {
             res=interpreter->lib_function_call(_t);
             _t = interpreter->GetRetTree();
             if( !interpreter->CallStackBack()->Contains( res))
-                r_guard.reset( res);
+                r_guard.Reset( res);
         }
     else
         {
             res=interpreter->tmp_expr(_t);
             _t = interpreter->GetRetTree();
-            r_guard.reset( res);
+            r_guard.Reset( res);
         }
 
     BaseGDL** l=_t->LExpr( res); //l_expr(_t, res);
@@ -162,7 +168,7 @@
 {
     ProgNodeP _t = this->getFirstChild();
 
-    auto_ptr<BaseGDL> r_guard;
+    Guard<BaseGDL> r_guard;
 
 	BaseGDL* res;
     if( _t->getType() == GDLTokenTypes::FCALL_LIB)
@@ -170,13 +176,13 @@
             res=interpreter->lib_function_call(_t);
             _t = interpreter->GetRetTree();
             if( !interpreter->CallStackBack()->Contains( res))
-                r_guard.reset( res);
+                r_guard.Reset( res);
         }
     else
         {
             res=interpreter->tmp_expr(_t);
             _t = interpreter->GetRetTree();
-            r_guard.reset( res);
+            r_guard.Reset( res);
         }
 
     ProgNodeP mark = _t;
@@ -220,7 +226,7 @@
 {
     ProgNodeP _t = this->getFirstChild();
 
-    auto_ptr<BaseGDL> r_guard;
+    Guard<BaseGDL> r_guard;
 
 	BaseGDL* res;
     if( _t->getType() == GDLTokenTypes::FCALL_LIB)
@@ -228,13 +234,13 @@
             res=interpreter->lib_function_call(_t);
             _t = interpreter->GetRetTree();
             if( !interpreter->CallStackBack()->Contains( res))
-                r_guard.reset( res);
+                r_guard.Reset( res);
         }
     else
         {
             res=interpreter->tmp_expr(_t);
             _t = interpreter->GetRetTree();
-            r_guard.reset( res);
+            r_guard.Reset( res);
         }
 
     BaseGDL** l=_t->LEval();
@@ -361,7 +367,7 @@
   // instance takes care of nStructDesc since it is unnamed
   //     DStructGDL* instance = new DStructGDL( nStructDesc, dimension(1));
   DStructGDL* instance = new DStructGDL( nStructDesc);
-  auto_ptr<DStructGDL> instance_guard(instance);
+  Guard<DStructGDL> instance_guard(instance);
 	
   ProgNodeP rTree = this->getNextSibling();
   // 	match(antlr::RefAST(_t),STRUC);
@@ -394,7 +400,7 @@
   ProgNodeP ii = NULL;
 	
   DStructDesc*          nStructDesc;
-  auto_ptr<DStructDesc> nStructDescGuard;
+  Guard<DStructDesc> nStructDescGuard;
   BaseGDL* e;
   BaseGDL* ee;
 	
@@ -420,7 +426,7 @@
       nStructDesc= new DStructDesc( id->getText());
 	
       // guard it
-      nStructDescGuard.reset( nStructDesc); 
+      nStructDescGuard.Reset( nStructDesc); 
     } 
   else
     {   // NTags() == 0
@@ -433,7 +439,7 @@
   //                                                       dimension(1)); 
   DStructGDL* instance= new DStructGDL( nStructDesc);
 	
-  auto_ptr<DStructGDL> instance_guard(instance);
+  Guard<DStructGDL> instance_guard(instance);
 	
   while( _t != NULL) 
     {
@@ -879,7 +885,7 @@
 {
   BaseGDL*  r;
   BaseGDL** l;
-  auto_ptr<BaseGDL> r_guard;
+  Guard<BaseGDL> r_guard;
 	
   //     match(antlr::RefAST(_t),ASSIGN);
   ProgNodeP _t = this->getFirstChild();
@@ -894,7 +900,7 @@
       r=ProgNode::interpreter->lib_function_call(_t);
       _t = ProgNode::interpreter->_retTree;		      
       if( !ProgNode::interpreter->callStack.back()->Contains( r)) 
- 	r_guard.reset( r); // guard if no global data
+ 	r_guard.Reset( r); // guard if no global data
       l=_t->LExpr( r); //ProgNode::interpreter->l_expr(_t, r);
   }
   else
@@ -902,7 +908,7 @@
       r=_t->Eval(); //ProgNode::interpreter->indexable_tmp_expr(_t);
       _t = _t->getNextSibling();
 //       _t = ProgNode::interpreter->_retTree;
-      r_guard.reset( r);
+      r_guard.Reset( r);
       l=_t->LExpr( r); //ProgNode::interpreter->l_expr(_t, r);
   }
 //     switch ( _t->getType()) {
@@ -922,7 +928,7 @@
 // 	_t = ProgNode::interpreter->_retTree;
 // 			
 // 	if( !ProgNode::interpreter->callStack.back()->Contains( r)) 
-// 	  r_guard.reset( r); // guard if no global data
+// 	  r_guard.Reset( r); // guard if no global data
 // 			
 // 	break;
 //       }
@@ -930,7 +936,7 @@
 //       {
 // 	r=ProgNode::interpreter->indexable_tmp_expr(_t);
 // 	_t = ProgNode::interpreter->_retTree;
-// 	r_guard.reset( r);
+// 	r_guard.Reset( r);
 // 	break;
 //       }
 //     }//switch
@@ -946,7 +952,7 @@
 {
   BaseGDL*  r;
   BaseGDL** l;
-  auto_ptr<BaseGDL> r_guard;
+  Guard<BaseGDL> r_guard;
 
   //match(antlr::RefAST(_t),ASSIGN_REPLACE);
   ProgNodeP _t = this->getFirstChild();
@@ -962,7 +968,7 @@
 	_t = ProgNode::interpreter->_retTree;
 	
 	if( !ProgNode::interpreter->callStack.back()->Contains( r)) 
-		r_guard.reset( r);
+		r_guard.Reset( r);
 			
       }
     else
@@ -978,7 +984,7 @@
 	  r= _t->Eval(); //ProgNode::interpreter->indexable_tmp_expr(_t);
 	  _t = _t->getNextSibling();
 // 	  _t = ProgNode::interpreter->_retTree;
-	  r_guard.reset( r);
+	  r_guard.Reset( r);
 	}
 
 // 	switch ( _t->getType()) {
@@ -996,7 +1002,7 @@
 // 	  {
 // 	    r=ProgNode::interpreter->indexable_tmp_expr(_t);
 // 	    _t = ProgNode::interpreter->_retTree;
-// 	    r_guard.reset( r);
+// 	    r_guard.Reset( r);
 // 	    break;
 // 	  }
 // 	}//switch
@@ -1042,7 +1048,7 @@
 RetCode  ASSIGN_REPLACENode::Run()
 {
   BaseGDL*  r;
-  auto_ptr<BaseGDL> r_guard;
+  Guard<BaseGDL> r_guard;
 
   //match(antlr::RefAST(_t),ASSIGN_REPLACE);
   ProgNodeP _t = this->getFirstChild();
@@ -1052,17 +1058,17 @@
 // 	r=_t->Eval();//different: ProgNode::interpreter->lib_function_call(_t);
 // 	_t = _t->getNextSibling(); //ProgNode::interpreter->_retTree;
 // 	assert(_t != NULL);
-// 	r_guard.reset( r);
+// 	r_guard.Reset( r);
 // // 	if( !ProgNode::interpreter->callStack.back()->Contains( r))
-// // 		r_guard.reset( r);
+// // 		r_guard.Reset( r);
 // // 	else
-// // 		r_guard.reset( r->Dup());
+// // 		r_guard.Reset( r->Dup());
 //       }
 //     else
       {
 	//r=ProgNode::interpreter->tmp_expr(_t);
  	r = _t->Eval();
-	r_guard.reset( r);
+	r_guard.Reset( r);
  	_t = _t->getNextSibling();
 	assert(_t != NULL);
       }
@@ -1105,7 +1111,7 @@
 {
 //   // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
 //   StackGuard<EnvStackT> guard( ProgNode::interpreter->CallStack());
-  BaseGDL *self;
+//  BaseGDL *self;
 	
   // 		match(antlr::RefAST(_t),PCALL_LIB);
   ProgNodeP _t = this->getFirstChild();
@@ -1113,10 +1119,10 @@
   // 		match(antlr::RefAST(_t),IDENTIFIER);
   _t = _t->getNextSibling();
 		
-  EnvT* newEnv=new EnvT( pl, pl->libPro);//libProList[pl->proIx]);
+  EnvT* newEnv=new EnvT( this, pl->libPro);//libProList[pl->proIx]);
 		
   ProgNode::interpreter->parameter_def_nocheck(_t, newEnv);
-  auto_ptr<EnvT> guardEnv( newEnv);
+  Guard<EnvT> guardEnv( newEnv);
 
   //   _t = _retTree;
   //if( this->getLine() != 0) ProgNode::interpreter->callStack.back()->SetLineNumber( this->getLine());
@@ -1149,7 +1155,7 @@
   // 			match(antlr::RefAST(_t),IDENTIFIER);
   _t = _t->getNextSibling();
 			
-  auto_ptr<BaseGDL> self_guard(self);
+  Guard<BaseGDL> self_guard(self);
 			
   newEnv=new EnvUDT( mp, self);
 			
@@ -1191,7 +1197,7 @@
   // 			match(antlr::RefAST(_t),IDENTIFIER);
   _t = _t->getNextSibling();
 			
-  auto_ptr<BaseGDL> self_guard(self);
+  Guard<BaseGDL> self_guard(self);
 			
   newEnv = new EnvUDT( pp, self, parent->getText());
 			
@@ -1302,7 +1308,7 @@
   
   BaseGDL* s=this->GetFirstChild()->Eval(); 
 //   BaseGDL* s=ProgNode::interpreter->expr( this->GetFirstChild());
-  auto_ptr<BaseGDL> s_guard(s);
+  Guard<BaseGDL> s_guard(s);
   
   GDLDelete(loopInfo.endLoopVar);
   loopInfo.endLoopVar=this->GetFirstChild()->GetNextSibling()->Eval();
@@ -1313,7 +1319,7 @@
   if( loopInfo.endLoopVar->Type() != s->Type()) // promote s
     {
       BaseGDL* sPromote = s->Convert2(loopInfo.endLoopVar->Type(), BaseGDL::COPY);
-      s_guard.reset( sPromote);
+      s_guard.Reset( sPromote);
     }
   
   // ASSIGNMENT used here also
@@ -1383,7 +1389,7 @@
 
   BaseGDL* s=this->GetFirstChild()->Eval(); 
 //  BaseGDL* s=ProgNode::interpreter->expr( this->GetFirstChild());
-  auto_ptr<BaseGDL> s_guard(s);
+  Guard<BaseGDL> s_guard(s);
 
   GDLDelete(loopInfo.endLoopVar);
   loopInfo.endLoopVar=this->GetFirstChild()->GetNextSibling()->Eval();
@@ -1398,7 +1404,7 @@
   if( loopInfo.endLoopVar->Type() != s->Type()) // promote s
     {
       BaseGDL* sPromote = s->Convert2(loopInfo.endLoopVar->Type(), BaseGDL::COPY);
-      s_guard.reset( sPromote);
+      s_guard.Reset( sPromote);
       assert( loopInfo.loopStepVar->Type() == s_guard.get()->Type());
     }
 
@@ -1625,8 +1631,8 @@
 
 RetCode   REPEAT_LOOPNode::Run()
 {
-  auto_ptr<BaseGDL> eVal( this->GetFirstChild()->Eval());
-//  auto_ptr<BaseGDL> eVal( ProgNode::interpreter->expr(this->GetFirstChild()));
+  Guard<BaseGDL> eVal( this->GetFirstChild()->Eval());
+//  Guard<BaseGDL> eVal( ProgNode::interpreter->expr(this->GetFirstChild()));
   if( eVal.get()->False())
   {
   ProgNode::interpreter->SetRetTree( this->GetFirstChild()->GetNextSibling());     // 1st loop statement
@@ -1643,7 +1649,7 @@
 
 RetCode   WHILENode::Run()
 {
-  auto_ptr<BaseGDL> e1_guard;
+  Guard<BaseGDL> e1_guard;
   BaseGDL* e1;
   ProgNodeP evalExpr = this->getFirstChild();
   if( NonCopyNode( evalExpr->getType()))
@@ -1653,9 +1659,9 @@
   else
   {
     e1 = evalExpr->Eval();
-    e1_guard.reset(e1);
+    e1_guard.Reset(e1);
   }
-// 	auto_ptr<BaseGDL> eVal( ProgNode::interpreter->expr( this->GetFirstChild()));
+// 	Guard<BaseGDL> eVal( ProgNode::interpreter->expr( this->GetFirstChild()));
   if( e1->True()) 
   {
     ProgNode::interpreter->SetRetTree( this->GetFirstChild()->GetNextSibling());
@@ -1673,7 +1679,7 @@
 
 RetCode   IFNode::Run()
  {
-  auto_ptr<BaseGDL> e1_guard;
+  Guard<BaseGDL> e1_guard;
   BaseGDL* e1;
   ProgNodeP evalExpr = this->getFirstChild();
   if( NonCopyNode( evalExpr->getType()))
@@ -1683,9 +1689,9 @@
   else
   {
 	e1 = evalExpr->Eval();
-    e1_guard.reset(e1);
+    e1_guard.Reset(e1);
   }
-//	auto_ptr<BaseGDL> eVal( ProgNode::interpreter->expr( this->GetFirstChild()));
+//	Guard<BaseGDL> eVal( ProgNode::interpreter->expr( this->GetFirstChild()));
 	if( e1->True()) 
 	{
 		ProgNode::interpreter->SetRetTree( this->GetFirstChild()->GetNextSibling());
@@ -1699,7 +1705,7 @@
 
 RetCode   IF_ELSENode::Run()
 {	
-  auto_ptr<BaseGDL> e1_guard;
+  Guard<BaseGDL> e1_guard;
   BaseGDL* e1;
   ProgNodeP evalExpr = this->getFirstChild();
   if( NonCopyNode( evalExpr->getType()))
@@ -1709,9 +1715,9 @@
   else
   {
 	e1 = evalExpr->Eval();
-	e1_guard.reset(e1);
+	e1_guard.Reset(e1);
   }
-// 	auto_ptr<BaseGDL> eVal( ProgNode::interpreter->expr( this->GetFirstChild()));
+// 	Guard<BaseGDL> eVal( ProgNode::interpreter->expr( this->GetFirstChild()));
   if( e1->True()) 
   {
 	  ProgNode::interpreter->SetRetTree( this->GetFirstChild()->GetNextSibling()->GetFirstChild());
@@ -1727,7 +1733,7 @@
 
 RetCode   CASENode::Run()
 {
-  auto_ptr<BaseGDL> e1_guard;
+  Guard<BaseGDL> e1_guard;
   BaseGDL* e1;
   ProgNodeP evalExpr = this->getFirstChild();
   if( NonCopyNode( evalExpr->getType()))
@@ -1737,10 +1743,10 @@
   else
   {
 	e1 = evalExpr->Eval();
-    e1_guard.reset(e1);
+    e1_guard.Reset(e1);
   }
 
-// 	auto_ptr<BaseGDL> eVal( ProgNode::interpreter->expr( this->GetFirstChild()));
+// 	Guard<BaseGDL> eVal( ProgNode::interpreter->expr( this->GetFirstChild()));
   	if( !e1->Scalar())
 		throw GDLException( this->GetFirstChild(), "Expression must be a"
 			" scalar in this context: "+ProgNode::interpreter->Name(e1),true,false);
@@ -1767,7 +1773,7 @@
 		{
 			ProgNodeP ex = b->GetFirstChild();  // EXPR
 							
-			auto_ptr<BaseGDL> ee_guard;
+			Guard<BaseGDL> ee_guard;
 			BaseGDL* ee;
 			if( NonCopyNode( ex->getType()))
 				{
@@ -1776,10 +1782,10 @@
 			else
 				{
 					ee = ex->Eval();
-					ee_guard.reset(ee);
+					ee_guard.Reset(ee);
 				}
 // 			BaseGDL* ee=ProgNode::interpreter->expr(ex);
-			// auto_ptr<BaseGDL> ee_guard(ee);
+			// Guard<BaseGDL> ee_guard(ee);
 			bool equalexpr=e1->EqualNoDelete(ee); // Equal deletes ee
 		
 			if( equalexpr)
@@ -1808,7 +1814,7 @@
 
 RetCode   SWITCHNode::Run()
 {
-  auto_ptr<BaseGDL> e1_guard;
+  Guard<BaseGDL> e1_guard;
   BaseGDL* e1;
   ProgNodeP evalExpr = this->getFirstChild();
   if( NonCopyNode( evalExpr->getType()))
@@ -1818,10 +1824,10 @@
   else
   {
 	e1 = evalExpr->Eval();
-    e1_guard.reset(e1);
+    e1_guard.Reset(e1);
   }
 
-// 	auto_ptr<BaseGDL> eVal( ProgNode::interpreter->expr( this->GetFirstChild()));
+// 	Guard<BaseGDL> eVal( ProgNode::interpreter->expr( this->GetFirstChild()));
  	if( !e1->Scalar())
 	throw GDLException( this->GetFirstChild(), "Expression must be a"
 	" scalar in this context: "+ProgNode::interpreter->Name(e1),true,false);
@@ -1849,7 +1855,7 @@
 				
 				if( !hook)
 				{
-					auto_ptr<BaseGDL> ee_guard;
+					Guard<BaseGDL> ee_guard;
 					BaseGDL* ee;
 					if( NonCopyNode( ex->getType()))
 					{
@@ -1858,10 +1864,10 @@
 					else
 					{
 						ee = ex->Eval();
-						ee_guard.reset(ee);
+						ee_guard.Reset(ee);
 					}
 // 					BaseGDL* ee=ProgNode::interpreter->expr(ex);
-					// auto_ptr<BaseGDL> ee_guard(ee);
+					// Guard<BaseGDL> ee_guard(ee);
 					hook=e1->EqualNoDelete(ee); // Equal deletes ee
 				}
 				
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/prognodeexpr.cpp gdl/src/prognodeexpr.cpp
--- gdl-0.9.3/src/prognodeexpr.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/prognodeexpr.cpp	2013-05-16 12:36:33.684856234 -0600
@@ -114,7 +114,7 @@
 
 // converts inferior type to superior type
 // for not (yet) overloaded operators
-void ProgNode::AdjustTypes(auto_ptr<BaseGDL>& a, auto_ptr<BaseGDL>& b)
+void ProgNode::AdjustTypes(Guard<BaseGDL>& a, Guard<BaseGDL>& b)
 {
   DType aTy=a->Type();
   DType bTy=b->Type();
@@ -128,11 +128,11 @@
 //     }
   
   // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-  if( (aTy == GDL_COMPLEX && bTy == GDL_DOUBLE) ||
-      (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
+    DType cxTy = PromoteComplexOperand( aTy, bTy);
+    if( cxTy != GDL_UNDEF)
     {
-      a.reset( a.release()->Convert2( GDL_COMPLEXDBL));
-      b.reset( b.release()->Convert2( GDL_COMPLEXDBL));
+      a.reset( a.release()->Convert2( cxTy));
+      b.reset( b.release()->Convert2( cxTy));
       return;
     }
 
@@ -150,7 +150,7 @@
 }
 // converts inferior type to superior type
 // handles overloaded operators
-void ProgNode::AdjustTypesObj(auto_ptr<BaseGDL>& a, auto_ptr<BaseGDL>& b)
+void ProgNode::AdjustTypesObj(Guard<BaseGDL>& a, Guard<BaseGDL>& b)
 {
   DType aTy=a->Type();
   DType bTy=b->Type();
@@ -164,11 +164,11 @@
 //     }
   
   // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-  if( (aTy == GDL_COMPLEX && bTy == GDL_DOUBLE) ||
-      (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
+    DType cxTy = PromoteComplexOperand( aTy, bTy);
+    if( cxTy != GDL_UNDEF)
     {
-      a.reset( a.release()->Convert2( GDL_COMPLEXDBL));
-      b.reset( b.release()->Convert2( GDL_COMPLEXDBL));
+      a.reset( a.release()->Convert2( cxTy));
+      b.reset( b.release()->Convert2( cxTy));
       return;
     }
 
@@ -190,8 +190,8 @@
 }
 
 // for not (yet) overloaded operators
-void BinaryExprNC::AdjustTypesNC(auto_ptr<BaseGDL>& g1, BaseGDL*& e1,
-				 auto_ptr<BaseGDL>& g2, BaseGDL*& e2)
+void BinaryExprNC::AdjustTypesNC(Guard<BaseGDL>& g1, BaseGDL*& e1,
+				 Guard<BaseGDL>& g2, BaseGDL*& e2)
 {
   if( op1NC)
     {
@@ -221,19 +221,28 @@
 //     {
 //       throw GDLException( "Expressions of this type cannot be converted.");
 //     }
-
-  // Change > to >= JMG
-  if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+    DType cxTy = PromoteComplexOperand( aTy, bTy);
+    if( cxTy != GDL_UNDEF)
     {
-      // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-      if( (aTy == GDL_COMPLEX && bTy == GDL_DOUBLE))
-	{
-	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+	  e2 = e2->Convert2( cxTy, BaseGDL::COPY);
 	  g2.reset( e2); // delete former e2
-	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+	  e1 = e1->Convert2( cxTy, BaseGDL::COPY);
 	  g1.reset( e1); // delete former e1
-	  return;
-	}
+	  return;      
+    }
+    
+  // Change > to >= JMG
+  if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+    {
+//       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
+//       if( (aTy == GDL_COMPLEX && bTy == GDL_DOUBLE))
+// 	{
+// 	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g2.reset( e2); // delete former e2
+// 	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g1.reset( e1); // delete former e1
+// 	  return;
+// 	}
 
       // convert e2 to e1
       e2 = e2->Convert2( aTy, BaseGDL::COPY);
@@ -241,15 +250,15 @@
     }
   else
     {
-      // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-      if( (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
-	{
-	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g2.reset( e2); // delete former e2
-	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g1.reset( e1); // delete former e1
-	  return;
-	}
+//       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
+//       if( (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
+// 	{
+// 	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g2.reset( e2); // delete former e2
+// 	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g1.reset( e1); // delete former e1
+// 	  return;
+// 	}
 
       // convert e1 to e2
       e1 = e1->Convert2( bTy, BaseGDL::COPY);
@@ -342,17 +351,27 @@
 //     }
 
   // Change > to >= JMG
-  if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+    DType cxTy = PromoteComplexOperand( aTy, bTy);
+    if( cxTy != GDL_UNDEF)
     {
-      // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-      if( (aTy == GDL_COMPLEX && bTy == GDL_DOUBLE))
-	{
-	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+	  e2 = e2->Convert2( cxTy, BaseGDL::COPY);
 	  g2.Reset( e2); // delete former e2
-	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+	  e1 = e1->Convert2( cxTy, BaseGDL::COPY);
 	  g1.Reset( e1); // delete former e1
 	  return;
-	}
+    }
+    
+    if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+    {
+//       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
+//       if( (aTy == GDL_COMPLEX && bTy == GDL_DOUBLE))
+// 	{
+// 	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g2.Reset( e2); // delete former e2
+// 	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g1.Reset( e1); // delete former e1
+// 	  return;
+// 	}
 
       // no conversion because of operator overloads
       if( aTy == GDL_OBJ) // only check for aTy is ok because GDL_OBJ has highest order
@@ -364,15 +383,15 @@
     }
   else
     {
-      // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-      if( (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
-	{
-	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g2.Reset( e2); // delete former e2
-	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g1.Reset( e1); // delete former e1
-	  return;
-	}
+//       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
+//       if( (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
+// 	{
+// 	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g2.Reset( e2); // delete former e2
+// 	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g1.Reset( e1); // delete former e1
+// 	  return;
+// 	}
 
       // no conversion because of operator overloads
       if( bTy == GDL_OBJ) // only check for bTy is ok because GDL_OBJ has highest order
@@ -508,7 +527,7 @@
 	
 BaseGDL* DEREFNode::EvalNC()
 {
-  auto_ptr<BaseGDL> e1_guard;
+  Guard<BaseGDL> e1_guard;
   BaseGDL* e1;
   ProgNodeP evalExpr = this->getFirstChild();
   if( NonCopyNode( evalExpr->getType()))
@@ -518,7 +537,7 @@
   else
   {
     e1 = evalExpr->Eval();
-    e1_guard.reset(e1);
+    e1_guard.Reset(e1);
   }
 
   if( e1 == NULL || e1->Type() != GDL_PTR)
@@ -557,7 +576,7 @@
 
   assert( actEnv != NULL);
 
-  auto_ptr<BaseGDL> e1_guard;
+  Guard<BaseGDL> e1_guard;
   BaseGDL* e1;
   ProgNodeP evalExpr = this->getFirstChild();
   if( NonCopyNode( evalExpr->getType()))
@@ -573,13 +592,13 @@
       
       if( !DInterpreter::CallStackBack()->Contains( e1)) 
 	{
-  	  actEnv->Guard( e1); 
+  	  actEnv->DeleteAtExit( e1); 
 	}
     }
   else
     {
       e1 = evalExpr->Eval();
-      actEnv->Guard( e1); 
+      actEnv->DeleteAtExit( e1); 
     }
 
   if( e1 == NULL || e1->Type() != GDL_PTR)
@@ -617,7 +636,7 @@
 // trinary operator
 BaseGDL* QUESTIONNode::Eval()
 {
-  auto_ptr<BaseGDL> e1_guard;
+  Guard<BaseGDL> e1_guard;
   BaseGDL* e1;
   if( NonCopyNode( op1->getType()))
   {
@@ -626,9 +645,9 @@
   else
   {
 	e1 = op1->Eval();
-    e1_guard.reset(e1);
+    e1_guard.Reset(e1);
   }
-//  auto_ptr<BaseGDL> e1( op1->Eval());
+//  Guard<BaseGDL> e1( op1->Eval());
   if( e1->True())
     {
       return op2->Eval(); // right->down
@@ -638,7 +657,7 @@
 
 ProgNodeP QUESTIONNode::AsParameter()
 {
-  auto_ptr<BaseGDL> e1_guard;
+  Guard<BaseGDL> e1_guard;
   BaseGDL* e1;
   if( NonCopyNode( op1->getType()))
   {
@@ -647,9 +666,9 @@
   else
   {
 	e1 = op1->Eval();
-    e1_guard.reset(e1);
+    e1_guard.Reset(e1);
   }
-//  auto_ptr<BaseGDL> e1( op1->Eval());
+//  Guard<BaseGDL> e1( op1->Eval());
   if( e1->True())
     {
       return op2;
@@ -670,15 +689,15 @@
 }
 BaseGDL* LOG_NEGNode::Eval()
 {
-  auto_ptr<BaseGDL> e1( down->Eval());
+  Guard<BaseGDL> e1( down->Eval());
   return e1->LogNeg();
 }
 
 // binary operators
 BaseGDL* AND_OPNode::Eval()
 { BaseGDL* res;
-  auto_ptr<BaseGDL> e1( op1->Eval());
-  auto_ptr<BaseGDL> e2( op2->Eval());
+  Guard<BaseGDL> e1( op1->Eval());
+  Guard<BaseGDL> e2( op2->Eval());
   AdjustTypes(e1,e2);
   if( e1->StrictScalar()) 
     {
@@ -706,8 +725,8 @@
 }
 BaseGDL* OR_OPNode::Eval()
 { BaseGDL* res;
- auto_ptr<BaseGDL> e1( op1->Eval());
- auto_ptr<BaseGDL> e2( op2->Eval());
+ Guard<BaseGDL> e1( op1->Eval());
+ Guard<BaseGDL> e2( op2->Eval());
  AdjustTypes(e1,e2);
  if( e1->StrictScalar())
    {
@@ -735,8 +754,8 @@
 }
 BaseGDL* XOR_OPNode::Eval()
 { BaseGDL* res;
-  auto_ptr<BaseGDL> e1( op1->Eval());
-  auto_ptr<BaseGDL> e2( op2->Eval());
+  Guard<BaseGDL> e1( op1->Eval());
+  Guard<BaseGDL> e2( op2->Eval());
   AdjustTypes(e1,e2);
   if( e1->N_Elements() <= e2->N_Elements())
     {
@@ -752,25 +771,25 @@
 }
 BaseGDL* LOG_ANDNode::Eval()
 { BaseGDL* res;
-  auto_ptr<BaseGDL> e1( op1->Eval());
+  Guard<BaseGDL> e1( op1->Eval());
   if( !e1->LogTrue()) return new DByteGDL( 0);
-  auto_ptr<BaseGDL> e2( op2->Eval());
+  Guard<BaseGDL> e2( op2->Eval());
   if( !e2->LogTrue()) return new DByteGDL( 0);
   return new DByteGDL( 1);
 }
 BaseGDL* LOG_ORNode::Eval()
 { BaseGDL* res;
-  auto_ptr<BaseGDL> e1( op1->Eval());
+  Guard<BaseGDL> e1( op1->Eval());
   if( e1->LogTrue()) return new DByteGDL( 1); 
-  auto_ptr<BaseGDL> e2( op2->Eval());
+  Guard<BaseGDL> e2( op2->Eval());
   if( e2->LogTrue()) return new DByteGDL( 1);
   return new DByteGDL( 0);
 }
 
 BaseGDL* EQ_OPNode::Eval()
 { 
-  auto_ptr<BaseGDL> e1( op1->Eval());
-  auto_ptr<BaseGDL> e2( op2->Eval());
+  Guard<BaseGDL> e1( op1->Eval());
+  Guard<BaseGDL> e2( op2->Eval());
   AdjustTypesObj(e1,e2);
   if( e2->Type() == GDL_OBJ) 
   {
@@ -787,8 +806,8 @@
 }
 BaseGDL* NE_OPNode::Eval()
 { 
-  auto_ptr<BaseGDL> e1( op1->Eval());
-  auto_ptr<BaseGDL> e2( op2->Eval());
+  Guard<BaseGDL> e1( op1->Eval());
+  Guard<BaseGDL> e2( op2->Eval());
   AdjustTypesObj(e1,e2);
   if( e2->Type() == GDL_OBJ) 
   {
@@ -805,32 +824,32 @@
 }
 BaseGDL* LE_OPNode::Eval()
 { BaseGDL* res;
-  auto_ptr<BaseGDL> e1( op1->Eval());
-  auto_ptr<BaseGDL> e2( op2->Eval());
+  Guard<BaseGDL> e1( op1->Eval());
+  Guard<BaseGDL> e2( op2->Eval());
   AdjustTypes(e1,e2);
   res=e1->LeOp(e2.get());
   return res;
 }
 BaseGDL* LT_OPNode::Eval()
 { BaseGDL* res;
-  auto_ptr<BaseGDL> e1( op1->Eval());
-  auto_ptr<BaseGDL> e2( op2->Eval());
+  Guard<BaseGDL> e1( op1->Eval());
+  Guard<BaseGDL> e2( op2->Eval());
   AdjustTypes(e1,e2);
   res=e1->LtOp(e2.get());
   return res;
 }
 BaseGDL* GE_OPNode::Eval()
 { BaseGDL* res;
-  auto_ptr<BaseGDL> e1( op1->Eval());
-  auto_ptr<BaseGDL> e2( op2->Eval());
+  Guard<BaseGDL> e1( op1->Eval());
+  Guard<BaseGDL> e2( op2->Eval());
   AdjustTypes(e1,e2);
   res=e1->GeOp(e2.get());
   return res;
 }
 BaseGDL* GT_OPNode::Eval()
 { BaseGDL* res;
-  auto_ptr<BaseGDL> e1( op1->Eval());
-  auto_ptr<BaseGDL> e2( op2->Eval());
+  Guard<BaseGDL> e1( op1->Eval());
+  Guard<BaseGDL> e2( op2->Eval());
   AdjustTypes(e1,e2);
   res=e1->GtOp(e2.get());
   return res;
@@ -838,8 +857,8 @@
 BaseGDL* PLUSNode::Eval()
 {
   BaseGDL* res;
-  auto_ptr<BaseGDL> e1 ( op1->Eval() );
-  auto_ptr<BaseGDL> e2 ( op2->Eval() );
+  Guard<BaseGDL> e1 ( op1->Eval() );
+  Guard<BaseGDL> e2 ( op2->Eval() );
 	
   DType aTy=e1->Type();
   DType bTy=e2->Type();
@@ -850,11 +869,13 @@
     
   }
       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-  else if( (aTy == GDL_COMPLEX && bTy == GDL_DOUBLE) ||
-      (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
+  else 
+  {
+    DType cxTy = PromoteComplexOperand( aTy, bTy);
+    if( cxTy != GDL_UNDEF)
     {
-      e1.reset( e1.release()->Convert2( GDL_COMPLEXDBL));
-      e2.reset( e2.release()->Convert2( GDL_COMPLEXDBL));
+      e1.reset( e1.release()->Convert2( cxTy));
+      e2.reset( e2.release()->Convert2( cxTy));
     }
   // Change > to >= JMG
   else if( DTypeOrder[aTy] >= DTypeOrder[bTy])
@@ -871,7 +892,8 @@
 	return e2->AddInv( e1.get());; // for operator overloading, do not convert other type then
       e1.reset( e1.release()->Convert2( bTy));
     }
-    
+  }
+  
   if ( e1->StrictScalar() )
   {
     res= e2->AddInvS ( e1.get() ); // scalar+scalar or array+scalar
@@ -900,8 +922,8 @@
 BaseGDL* MINUSNode::Eval()
 { 
   BaseGDL* res;
-  auto_ptr<BaseGDL> e1( op1->Eval());
-  auto_ptr<BaseGDL> e2( op2->Eval());
+  Guard<BaseGDL> e1( op1->Eval());
+  Guard<BaseGDL> e2( op2->Eval());
 //  AdjustTypes(e1,e2);
  
   DType aTy=e1->Type();
@@ -913,11 +935,13 @@
     
   }
       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-  else if( (aTy == GDL_COMPLEX && bTy == GDL_DOUBLE) ||
-      (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
+  else 
+  {
+    DType cxTy = PromoteComplexOperand( aTy, bTy);
+    if( cxTy != GDL_UNDEF)
     {
-      e1.reset( e1.release()->Convert2( GDL_COMPLEXDBL));
-      e2.reset( e2.release()->Convert2( GDL_COMPLEXDBL));
+      e1.reset( e1.release()->Convert2( cxTy));
+      e2.reset( e2.release()->Convert2( cxTy));
     }
   // Change > to >= JMG
   else if( DTypeOrder[aTy] >= DTypeOrder[bTy])
@@ -934,7 +958,7 @@
 	return e2->SubInv( e1.get());; // for operator overloading, do not convert other type then
       e1.reset( e1.release()->Convert2( bTy));
     }
- 
+  }
  if( e1->StrictScalar())
    {
      res= e2->SubInvS(e1.get()); // scalar+scalar or array+scalar
@@ -962,8 +986,8 @@
 }
 BaseGDL* LTMARKNode::Eval()
 { BaseGDL* res;
- auto_ptr<BaseGDL> e1( op1->Eval());
- auto_ptr<BaseGDL> e2( op2->Eval());
+ Guard<BaseGDL> e1( op1->Eval());
+ Guard<BaseGDL> e2( op2->Eval());
  AdjustTypes(e1,e2);
  if( e1->StrictScalar())
    {
@@ -991,8 +1015,8 @@
 }
 BaseGDL* GTMARKNode::Eval()
 { BaseGDL* res;
- auto_ptr<BaseGDL> e1( op1->Eval());
- auto_ptr<BaseGDL> e2( op2->Eval());
+ Guard<BaseGDL> e1( op1->Eval());
+ Guard<BaseGDL> e2( op2->Eval());
  AdjustTypes(e1,e2);
  if( e1->StrictScalar())
    {
@@ -1021,8 +1045,8 @@
 BaseGDL* ASTERIXNode::Eval()
 {
 	BaseGDL* res;
-	auto_ptr<BaseGDL> e1 ( op1->Eval() );
-	auto_ptr<BaseGDL> e2 ( op2->Eval() );
+	Guard<BaseGDL> e1 ( op1->Eval() );
+	Guard<BaseGDL> e2 ( op2->Eval() );
 	AdjustTypes ( e1,e2 );
 	if ( e1->StrictScalar() )
 	{
@@ -1050,18 +1074,20 @@
 
 BaseGDL* MATRIX_OP1Node::Eval()
 { BaseGDL* res;
-  auto_ptr<BaseGDL> e1( op1->Eval());
-  auto_ptr<BaseGDL> e2( op2->Eval());
+  Guard<BaseGDL> e1( op1->Eval());
+  Guard<BaseGDL> e2( op2->Eval());
   DType aTy=e1->Type();
   DType bTy=e2->Type();
-  DType maxTy=(DTypeOrder[aTy] >= DTypeOrder[bTy])? aTy: bTy;
-
-  DType cTy=maxTy;
-  if( maxTy == GDL_BYTE || maxTy == GDL_INT)
-    cTy=GDL_LONG;
-  else if( maxTy == GDL_UINT)
-    cTy=GDL_ULONG;
+  
+//   DType maxTy=(DTypeOrder[aTy] >= DTypeOrder[bTy])? aTy: bTy;
+//   DType cTy=maxTy;
+//   if( maxTy == GDL_BYTE || maxTy == GDL_INT)
+//     cTy=GDL_LONG;
+//   else if( maxTy == GDL_UINT)
+//     cTy=GDL_ULONG;
 
+  DType cTy = PromoteMatrixOperands( aTy, bTy);
+  
   if( aTy != cTy)
     e1.reset( e1.release()->Convert2( cTy));
 
@@ -1071,18 +1097,20 @@
 }
 BaseGDL* MATRIX_OP2Node::Eval()
 { BaseGDL* res;
-  auto_ptr<BaseGDL> e1( op1->Eval());
-  auto_ptr<BaseGDL> e2( op2->Eval());
+  Guard<BaseGDL> e1( op1->Eval());
+  Guard<BaseGDL> e2( op2->Eval());
   DType aTy=e1->Type();
   DType bTy=e2->Type();
-  DType maxTy=(DTypeOrder[aTy] >= DTypeOrder[bTy])? aTy: bTy;
 
-  DType cTy=maxTy;
-  if( maxTy == GDL_BYTE || maxTy == GDL_INT)
-    cTy=GDL_LONG;
-  else if( maxTy == GDL_UINT)
-    cTy=GDL_ULONG;
+//   DType maxTy=(DTypeOrder[aTy] >= DTypeOrder[bTy])? aTy: bTy;
+//   DType cTy=maxTy;
+//   if( maxTy == GDL_BYTE || maxTy == GDL_INT)
+//     cTy=GDL_LONG;
+//   else if( maxTy == GDL_UINT)
+//     cTy=GDL_ULONG;
 
+  DType cTy = PromoteMatrixOperands( aTy, bTy);
+  
   if( aTy != cTy) 
     e1.reset( e1.release()->Convert2( cTy));
 
@@ -1092,8 +1120,8 @@
 }
 BaseGDL* SLASHNode::Eval()
 { BaseGDL* res;
- auto_ptr<BaseGDL> e1( op1->Eval());
- auto_ptr<BaseGDL> e2( op2->Eval());
+ Guard<BaseGDL> e1( op1->Eval());
+ Guard<BaseGDL> e2( op2->Eval());
  AdjustTypes(e1,e2);
  if( e1->StrictScalar())
    {
@@ -1122,8 +1150,8 @@
 }
 BaseGDL* MOD_OPNode::Eval()
 { BaseGDL* res;
- auto_ptr<BaseGDL> e1( op1->Eval());
- auto_ptr<BaseGDL> e2( op2->Eval());
+ Guard<BaseGDL> e1( op1->Eval());
+ Guard<BaseGDL> e2( op2->Eval());
  AdjustTypes(e1,e2);
  if( e1->StrictScalar())
    {
@@ -1153,8 +1181,8 @@
 
 BaseGDL* POWNode::Eval()
 { BaseGDL* res;
-  auto_ptr<BaseGDL> e1( op1->Eval());
-  auto_ptr<BaseGDL> e2( op2->Eval());
+  Guard<BaseGDL> e1( op1->Eval());
+  Guard<BaseGDL> e2( op2->Eval());
   // special handling for aTy == complex && bTy != complex
   DType aTy=e1->Type();
   DType bTy=e2->Type();
@@ -1285,8 +1313,8 @@
 // ***********************
 BaseGDL* AND_OPNCNode::Eval()
 { BaseGDL* res;
- auto_ptr<BaseGDL> g1;
- auto_ptr<BaseGDL> g2;
+ Guard<BaseGDL> g1;
+ Guard<BaseGDL> g2;
  BaseGDL *e1, *e2; AdjustTypesNC( g1, e1, g2, e2); 
 
  if( e1->StrictScalar())
@@ -1339,8 +1367,8 @@
 }
 BaseGDL* OR_OPNCNode::Eval()
 { BaseGDL* res;
- auto_ptr<BaseGDL> g1;
- auto_ptr<BaseGDL> g2;
+ Guard<BaseGDL> g1;
+ Guard<BaseGDL> g2;
  BaseGDL *e1, *e2; AdjustTypesNC( g1, e1, g2, e2); 
 
  if( e1->StrictScalar())
@@ -1392,8 +1420,8 @@
 }
 BaseGDL* XOR_OPNCNode::Eval()
 { BaseGDL* res;
-  auto_ptr<BaseGDL> g1;
-  auto_ptr<BaseGDL> g2;
+  Guard<BaseGDL> g1;
+  Guard<BaseGDL> g2;
   BaseGDL *e1, *e2; AdjustTypesNC( g1, e1, g2, e2); 
 
   if( e1->StrictScalar())
@@ -1443,8 +1471,8 @@
 }
 BaseGDL* LOG_ANDNCNode::Eval()
 { BaseGDL* res;
- auto_ptr<BaseGDL> g1;
- auto_ptr<BaseGDL> g2;
+ Guard<BaseGDL> g1;
+ Guard<BaseGDL> g2;
  BaseGDL *e1, *e2;
  if( op1NC)
    {
@@ -1471,8 +1499,8 @@
 }
 BaseGDL* LOG_ORNCNode::Eval()
 { BaseGDL* res;
- auto_ptr<BaseGDL> g1;
- auto_ptr<BaseGDL> g2;
+ Guard<BaseGDL> g1;
+ Guard<BaseGDL> g2;
  BaseGDL *e1, *e2;
  if( op1NC)
    {
@@ -1538,8 +1566,8 @@
 }
 BaseGDL* LE_OPNCNode::Eval()
 { BaseGDL* res;
-  auto_ptr<BaseGDL> g1;
-  auto_ptr<BaseGDL> g2;
+  Guard<BaseGDL> g1;
+  Guard<BaseGDL> g2;
   BaseGDL *e1, *e2;
   AdjustTypesNC( g1, e1, g2, e2);
   res=e1->LeOp(e2);
@@ -1547,8 +1575,8 @@
 }
 BaseGDL* LT_OPNCNode::Eval()
 { BaseGDL* res;
-  auto_ptr<BaseGDL> g1;
-  auto_ptr<BaseGDL> g2;
+  Guard<BaseGDL> g1;
+  Guard<BaseGDL> g2;
   BaseGDL *e1, *e2;
   AdjustTypesNC( g1, e1, g2, e2);
   res=e1->LtOp(e2);
@@ -1556,8 +1584,8 @@
 }
 BaseGDL* GE_OPNCNode::Eval()
 { BaseGDL* res;
-  auto_ptr<BaseGDL> g1;
-  auto_ptr<BaseGDL> g2;
+  Guard<BaseGDL> g1;
+  Guard<BaseGDL> g2;
   BaseGDL *e1, *e2;
   AdjustTypesNC( g1, e1, g2, e2);
   res=e1->GeOp(e2);
@@ -1565,8 +1593,8 @@
 }
 BaseGDL* GT_OPNCNode::Eval()
 { BaseGDL* res;
-  auto_ptr<BaseGDL> g1;
-  auto_ptr<BaseGDL> g2;
+  Guard<BaseGDL> g1;
+  Guard<BaseGDL> g2;
   BaseGDL *e1, *e2;
   AdjustTypesNC( g1, e1, g2, e2);
   res=e1->GtOp(e2);
@@ -1602,22 +1630,30 @@
       return e2->AddInvNew( e1); // smaller + larger
     }
   }
-  auto_ptr<BaseGDL> g1;
-  auto_ptr<BaseGDL> g2;
-  if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+  Guard<BaseGDL> g1;
+  Guard<BaseGDL> g2;
+  DType cxTy = PromoteComplexOperand( aTy, bTy);
+  if( cxTy != GDL_UNDEF)
+  {
+	  e2 = e2->Convert2( cxTy, BaseGDL::COPY);
+	  g2.reset( e2);
+	  e1 = e1->Convert2( cxTy, BaseGDL::COPY);
+	  g1.reset( e1);
+     }
+  else if( DTypeOrder[aTy] >= DTypeOrder[bTy])
     {
       if( aTy == GDL_OBJ)
 	return e1->Add( e2);
 
-      // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-      if(aTy == GDL_COMPLEX && bTy == GDL_DOUBLE)
-      {
-	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g2.reset( e2);
-	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g1.reset( e1);
-      }
-      else
+//       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
+//       if(aTy == GDL_COMPLEX && bTy == GDL_DOUBLE)
+//       {
+// 	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g2.reset( e2);
+// 	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g1.reset( e1);
+//       }
+//       else
       {
 	// convert e2 to e1
 	e2 = e2->Convert2( aTy, BaseGDL::COPY);
@@ -1630,14 +1666,14 @@
 	return e2->AddInv( e1);
 
       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-      if( (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
-	{
-	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g2.reset( e2);
-	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g1.reset( e1);
-	}
-      else
+//       if( (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
+// 	{
+// 	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g2.reset( e2);
+// 	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g1.reset( e1);
+// 	}
+//       else
 	{// convert e1 to e2
 	    e1 = e1->Convert2( bTy, BaseGDL::COPY);
 	    g1.reset( e1);
@@ -1728,18 +1764,27 @@
   }
   else // aTy != bTy
   {
-    // Change > to >= JMG
-    if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+    DType cxTy = PromoteComplexOperand( aTy, bTy);
+    if( cxTy != GDL_UNDEF)
     {
-      // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-      if( (aTy == GDL_COMPLEX && bTy == GDL_DOUBLE))
-	{
-	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+	  e2 = e2->Convert2( cxTy, BaseGDL::COPY);
 	  g2.Reset( e2); // delete former e2
-	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+	  e1 = e1->Convert2( cxTy, BaseGDL::COPY);
 	  g1.Reset( e1); // delete former e1
-	}
-      else if( aTy == GDL_OBJ) // only check for aTy is ok because GDL_OBJ has highest order
+    }
+    // Change > to >= JMG
+    else if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+    {
+//       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
+//       if( (aTy == GDL_COMPLEX && bTy == GDL_DOUBLE))
+// 	{
+// 	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g2.Reset( e2); // delete former e2
+// 	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g1.Reset( e1); // delete former e1
+// 	}
+//       else 
+      if( aTy == GDL_OBJ) // only check for aTy is ok because GDL_OBJ has highest order
 	return e1->Add(e2); // for operator overloading, do not convert other type then
       else
       {
@@ -1750,15 +1795,16 @@
     }
     else
     {
-      // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-      if( (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
-	{
-	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g2.Reset( e2); // delete former e2
-	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g1.Reset( e1); // delete former e1
-	}
-      else if( bTy == GDL_OBJ) // only check for bTy is ok because GDL_OBJ has highest order
+//       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
+//       if( (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
+// 	{
+// 	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g2.Reset( e2); // delete former e2
+// 	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g1.Reset( e1); // delete former e1
+// 	}
+//       else 
+      if( bTy == GDL_OBJ) // only check for bTy is ok because GDL_OBJ has highest order
 	return e2->AddInv( e1); // for operator overloading, do not convert other type then
       else
       {
@@ -1865,22 +1911,31 @@
     }
   }
 
-  auto_ptr<BaseGDL> g1;
-  auto_ptr<BaseGDL> g2;
-  if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+  Guard<BaseGDL> g1;
+  Guard<BaseGDL> g2;
+
+  DType cxTy = PromoteComplexOperand( aTy, bTy);
+  if( cxTy != GDL_UNDEF)
+    {
+	  e2 = e2->Convert2( cxTy, BaseGDL::COPY);
+	  g2.reset( e2);
+	  e1 = e1->Convert2( cxTy, BaseGDL::COPY);
+	  g1.reset( e1);
+    }
+  else if( DTypeOrder[aTy] >= DTypeOrder[bTy])
     {
       if( aTy == GDL_OBJ)
 	return e1->Sub( e2);
 
-      // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-      if( aTy == GDL_COMPLEX && bTy == GDL_DOUBLE)
-      {
-	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g2.reset( e2);
-	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g1.reset( e1);
-      }
-      else
+//       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
+//       if( aTy == GDL_COMPLEX && bTy == GDL_DOUBLE)
+//       {
+// 	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g2.reset( e2);
+// 	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g1.reset( e1);
+//       }
+//       else
       {
 	// convert e2 to e1
 	e2 = e2->Convert2( aTy, BaseGDL::COPY);
@@ -1892,15 +1947,15 @@
       if( bTy == GDL_OBJ)
 	return e2->SubInv( e1);
       
-      // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-      if( (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
-	{
-	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g2.reset( e2);
-	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g1.reset( e1);
-	}
-      else
+//       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
+//       if( (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
+// 	{
+// 	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g2.reset( e2);
+// 	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g1.reset( e1);
+// 	}
+//       else
 	{// convert e1 to e2
 	    e1 = e1->Convert2( bTy, BaseGDL::COPY);
 	    g1.reset( e1);
@@ -1976,18 +2031,27 @@
   }
   else // aTy != bTy
   {
-    // Change > to >= JMG
-    if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+    DType cxTy = PromoteComplexOperand( aTy, bTy);
+    if( cxTy != GDL_UNDEF)
     {
-      // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-      if( (aTy == GDL_COMPLEX && bTy == GDL_DOUBLE))
-	{
-	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+	  e2 = e2->Convert2( cxTy, BaseGDL::COPY);
 	  g2.Reset( e2); // delete former e2
-	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+	  e1 = e1->Convert2( cxTy, BaseGDL::COPY);
 	  g1.Reset( e1); // delete former e1
-	}
-      else if( aTy == GDL_OBJ) // only check for aTy is ok because GDL_OBJ has highest order
+      
+    }    // Change > to >= JMG
+    else if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+    {
+//       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
+//       if( (aTy == GDL_COMPLEX && bTy == GDL_DOUBLE))
+// 	{
+// 	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g2.Reset( e2); // delete former e2
+// 	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g1.Reset( e1); // delete former e1
+// 	}
+//       else 
+      if( aTy == GDL_OBJ) // only check for aTy is ok because GDL_OBJ has highest order
 	return e1->Sub(e2); // for operator overloading, do not convert other type then
       else
       {
@@ -1998,15 +2062,16 @@
     }
     else
     {
-      // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-      if( (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
-	{
-	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g2.Reset( e2); // delete former e2
-	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g1.Reset( e1); // delete former e1
-	}
-      else if( bTy == GDL_OBJ) // only check for bTy is ok because GDL_OBJ has highest order
+//       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
+//       if( (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
+// 	{
+// 	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g2.Reset( e2); // delete former e2
+// 	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g1.Reset( e1); // delete former e1
+// 	}
+//       else 
+      if( bTy == GDL_OBJ) // only check for bTy is ok because GDL_OBJ has highest order
 	return e2->SubInv( e1); // for operator overloading, do not convert other type then
       else
       {
@@ -2065,8 +2130,8 @@
 }
 BaseGDL* LTMARKNCNode::Eval()
 { BaseGDL* res;
- auto_ptr<BaseGDL> g1;
- auto_ptr<BaseGDL> g2;
+ Guard<BaseGDL> g1;
+ Guard<BaseGDL> g2;
  BaseGDL *e1, *e2; AdjustTypesNC( g1, e1, g2, e2); 
 
  if( e1->StrictScalar())
@@ -2117,8 +2182,8 @@
 }
 BaseGDL* GTMARKNCNode::Eval()
 { BaseGDL* res;
- auto_ptr<BaseGDL> g1;
- auto_ptr<BaseGDL> g2;
+ Guard<BaseGDL> g1;
+ Guard<BaseGDL> g2;
  BaseGDL *e1, *e2; AdjustTypesNC( g1, e1, g2, e2); 
 
  if( e1->StrictScalar())
@@ -2194,19 +2259,28 @@
     }
   }
   
-  auto_ptr<BaseGDL> g1;
-  auto_ptr<BaseGDL> g2;
-  if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+  Guard<BaseGDL> g1;
+  Guard<BaseGDL> g2;
+
+  DType cxTy = PromoteComplexOperand( aTy, bTy);
+  if( cxTy != GDL_UNDEF)
+  {
+      e2 = e2->Convert2( cxTy, BaseGDL::COPY);
+      g2.reset( e2);
+      e1 = e1->Convert2( cxTy, BaseGDL::COPY);
+      g1.reset( e1);
+  }
+  else if( DTypeOrder[aTy] >= DTypeOrder[bTy])
     {
-      // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-      if( aTy == GDL_COMPLEX && bTy == GDL_DOUBLE)
-      {
-	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g2.reset( e2);
-	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g1.reset( e1);
-      }
-      else
+//       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
+//       if( aTy == GDL_COMPLEX && bTy == GDL_DOUBLE)
+//       {
+// 	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g2.reset( e2);
+// 	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g1.reset( e1);
+//       }
+//       else
       {
 	// convert e2 to e1
 	e2 = e2->Convert2( aTy, BaseGDL::COPY);
@@ -2215,15 +2289,15 @@
     }
   else
     {
-      // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-      if( (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
-	{
-	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g2.reset( e2);
-	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g1.reset( e1);
-	}
-      else
+//       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
+//       if( (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
+// 	{
+// 	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g2.reset( e2);
+// 	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g1.reset( e1);
+// 	}
+//       else
 	{// convert e1 to e2
 	    e1 = e1->Convert2( bTy, BaseGDL::COPY);
 	    g1.reset( e1);
@@ -2307,8 +2381,8 @@
 BaseGDL* ASTERIXNCNode::Eval()
 {
 	BaseGDL* res;
-	auto_ptr<BaseGDL> g1;
-	auto_ptr<BaseGDL> g2;
+	Guard<BaseGDL> g1;
+	Guard<BaseGDL> g2;
 	BaseGDL *e1, *e2; AdjustTypesNC ( g1, e1, g2, e2 );
 
 	if ( e1->StrictScalar() )
@@ -2386,8 +2460,8 @@
 
 BaseGDL* MATRIX_OP1NCNode::Eval()
 { BaseGDL* res;
- auto_ptr<BaseGDL> g1;
- auto_ptr<BaseGDL> g2;
+ Guard<BaseGDL> g1;
+ Guard<BaseGDL> g2;
  BaseGDL *e1, *e2;
  if( op1NC)
    {
@@ -2409,17 +2483,17 @@
    }
  DType aTy=e1->Type();
  DType bTy=e2->Type();
- DType maxTy=(DTypeOrder[aTy] >= DTypeOrder[bTy])? aTy: bTy;
- if( maxTy > 100)
-   {
-     throw GDLException( "Expressions of this type cannot be converted.");
-   }
-
- DType cTy=maxTy;
- if( maxTy == GDL_BYTE || maxTy == GDL_INT)
-   cTy=GDL_LONG;
- else if( maxTy == GDL_UINT)
-   cTy=GDL_ULONG;
+//  DType maxTy=(DTypeOrder[aTy] >= DTypeOrder[bTy])? aTy: bTy;
+//  if( maxTy > 100)
+//    {
+//      throw GDLException( "Expressions of this type cannot be converted.");
+//    }
+//  DType cTy=maxTy;
+//  if( maxTy == GDL_BYTE || maxTy == GDL_INT)
+//    cTy=GDL_LONG;
+//  else if( maxTy == GDL_UINT)
+//    cTy=GDL_ULONG;
+ DType cTy = PromoteMatrixOperands( aTy, bTy);
 
  if( aTy != cTy)
    {
@@ -2438,8 +2512,8 @@
 BaseGDL* MATRIX_OP2NCNode::Eval()
 {
  BaseGDL* res;
- auto_ptr<BaseGDL> g1;
- auto_ptr<BaseGDL> g2;
+ Guard<BaseGDL> g1;
+ Guard<BaseGDL> g2;
  BaseGDL *e1, *e2;
  if( op1NC)
    {
@@ -2461,17 +2535,18 @@
    }
  DType aTy=e1->Type();
  DType bTy=e2->Type();
- DType maxTy=(DTypeOrder[aTy] >= DTypeOrder[bTy])? aTy: bTy;
- if( maxTy > 100)
-   {
-     throw GDLException( "Expressions of this type cannot be converted.");
-   }
+//  DType maxTy=(DTypeOrder[aTy] >= DTypeOrder[bTy])? aTy: bTy;
+//  if( maxTy > 100)
+//    {
+//      throw GDLException( "Expressions of this type cannot be converted.");
+//    }
+//  DType cTy=maxTy;
+//  if( maxTy == GDL_BYTE || maxTy == GDL_INT)
+//    cTy=GDL_LONG;
+//  else if( maxTy == GDL_UINT)
+//    cTy=GDL_ULONG;
 
- DType cTy=maxTy;
- if( maxTy == GDL_BYTE || maxTy == GDL_INT)
-   cTy=GDL_LONG;
- else if( maxTy == GDL_UINT)
-   cTy=GDL_ULONG;
+ DType cTy = PromoteMatrixOperands( aTy, bTy);
 
  if( aTy != cTy)
    {
@@ -2513,20 +2588,28 @@
       return e2->DivInvNew( e1); // smaller + larger
     }
   }
+  Guard<BaseGDL> g1;
+  Guard<BaseGDL> g2;
 
-  auto_ptr<BaseGDL> g1;
-  auto_ptr<BaseGDL> g2;
-  if( DTypeOrder[aTy] >= DTypeOrder[bTy])
+  DType cxTy = PromoteComplexOperand( aTy, bTy);
+  if( cxTy != GDL_UNDEF)
+  {
+	e2 = e2->Convert2( cxTy, BaseGDL::COPY);
+	g2.reset( e2);
+	e1 = e1->Convert2( cxTy, BaseGDL::COPY);
+	g1.reset( e1);    
+  }
+  else if( DTypeOrder[aTy] >= DTypeOrder[bTy])
     {
-      // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-      if( aTy == GDL_COMPLEX && bTy == GDL_DOUBLE)
-      {
-	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g2.reset( e2);
-	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g1.reset( e1);
-      }
-      else
+//       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
+//       if( aTy == GDL_COMPLEX && bTy == GDL_DOUBLE)
+//       {
+// 	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g2.reset( e2);
+// 	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g1.reset( e1);
+//       }
+//       else
       {
 	// convert e2 to e1
 	e2 = e2->Convert2( aTy, BaseGDL::COPY);
@@ -2535,15 +2618,15 @@
     }
   else
     {
-      // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
-      if( (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
-	{
-	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g2.reset( e2);
-	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
-	  g1.reset( e1);
-	}
-      else
+//       // GDL_COMPLEX op GDL_DOUBLE = GDL_COMPLEXDBL
+//       if( (bTy == GDL_COMPLEX && aTy == GDL_DOUBLE))
+// 	{
+// 	  e2 = e2->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g2.reset( e2);
+// 	  e1 = e1->Convert2( GDL_COMPLEXDBL, BaseGDL::COPY);
+// 	  g1.reset( e1);
+// 	}
+//       else
 	{// convert e1 to e2
 	    e1 = e1->Convert2( bTy, BaseGDL::COPY);
 	    g1.reset( e1);
@@ -2601,8 +2684,8 @@
 }
 BaseGDL* SLASHNCNode::Eval()
 { BaseGDL* res;
- auto_ptr<BaseGDL> g1;
- auto_ptr<BaseGDL> g2;
+ Guard<BaseGDL> g1;
+ Guard<BaseGDL> g2;
  BaseGDL *e1, *e2; AdjustTypesNC( g1, e1, g2, e2); 
 
  if( e1->StrictScalar())
@@ -2654,8 +2737,8 @@
 }
 BaseGDL* MOD_OPNCNode::Eval()
 { BaseGDL* res;
- auto_ptr<BaseGDL> g1;
- auto_ptr<BaseGDL> g2;
+ Guard<BaseGDL> g1;
+ Guard<BaseGDL> g2;
  BaseGDL *e1, *e2; AdjustTypesNC( g1, e1, g2, e2); 
 
  if( e1->StrictScalar())
@@ -2708,8 +2791,8 @@
 BaseGDL* POWNCNode::Eval()
 {
   BaseGDL* res;
-  auto_ptr<BaseGDL> g1;
-  auto_ptr<BaseGDL> g2;
+  Guard<BaseGDL> g1;
+  Guard<BaseGDL> g2;
   BaseGDL *e1, *e2;
   if( op1NC)
     {
@@ -2965,9 +3048,9 @@
 	BaseGDL* param;
 	bool isReference = 
 	  static_cast<ParameterNode*>(this->getFirstChild())->ParameterDirect( param);
-	auto_ptr<BaseGDL> guard;
+	Guard<BaseGDL> guard;
 	if( !isReference)
-	  guard.reset( param);
+	  guard.Reset( param);
 
 	if( param == NULL)
 	  return new DLongGDL( 0);
@@ -2992,7 +3075,7 @@
 //	_t = _t->getFirstChild();
 // 	match(antlr::RefAST(_t),IDENTIFIER);
     EnvT* newEnv=new EnvT( this, this->libFun);//libFunList[fl->funIx]);
-//     auto_ptr< EnvT> guardEnv( newEnv);
+//     Guard< EnvT> guardEnv( newEnv);
 // 	_t =_t->getFirstChild();
 // 	EnvT* newEnv=new EnvT( fl, fl->libFun);//libFunList[fl->funIx]);
 	// special handling for N_ELEMENTS()
@@ -3009,7 +3092,7 @@
 //         }
     // push id.pro onto call stack
 // 	guardEnv.release();
-	auto_ptr<EnvT> guardEnv( newEnv);
+	Guard<EnvT> guardEnv( newEnv);
 //     // better than auto_ptr: auto_ptr wouldn't remove newEnv from the stack
 //     StackGuard<EnvStackT> guard(ProgNode::interpreter->CallStack());
 //     ProgNode::interpreter->CallStack().push_back(newEnv);
@@ -3030,9 +3113,9 @@
     BaseGDL* param;
     bool isReference = 
       static_cast<ParameterNode*>(this->getFirstChild())->ParameterDirect( param);
-    auto_ptr<BaseGDL> guard;
+    Guard<BaseGDL> guard;
     if( !isReference)
-      guard.reset( param);
+      guard.Reset( param);
     // check already here to keep functions leaner
     if( param == NULL)
     {
@@ -3062,7 +3145,7 @@
     EnvT* newEnv=new EnvT( this, this->libFun);//libFunList[fl->funIx]);
 
     ProgNode::interpreter->parameter_def_nocheck(this->getFirstChild(), newEnv);
-	auto_ptr<EnvT> guardEnv( newEnv);
+	Guard<EnvT> guardEnv( newEnv);
 
     // make the call
     rEval = static_cast<DLibFun*>(newEnv->GetPro())->Fun()(newEnv);
@@ -3081,7 +3164,7 @@
 //     EnvUDT* callerEnv = ProgNode::interpreter->CallStackBack();
 
     ProgNode::interpreter->parameter_def_nocheck(this->getFirstChild(), newEnv);
-    auto_ptr<EnvT> guardEnv( newEnv);
+    Guard<EnvT> guardEnv( newEnv);
 
 //     // push id.pro onto call stack
 //     ProgNode::interpreter->CallStack().push_back(newEnv);
@@ -3124,7 +3207,7 @@
     EnvT* newEnv=new EnvT( this, this->libFun);//libFunList[fl->funIx]);
 	
     ProgNode::interpreter->parameter_def_nocheck(this->getFirstChild(), newEnv);
-	auto_ptr<EnvT> guardEnv( newEnv);
+	Guard<EnvT> guardEnv( newEnv);
 
     assert( dynamic_cast<EnvUDT*>(ProgNode::interpreter->CallStackBack()) != NULL);
     EnvUDT* callStackBack = static_cast<EnvUDT*>(ProgNode::interpreter->CallStackBack());
@@ -3148,7 +3231,7 @@
 
     ProgNode::interpreter->parameter_def_nocheck(this->getFirstChild(), newEnv);
 
-	auto_ptr<EnvT> guardEnv( newEnv);
+	Guard<EnvT> guardEnv( newEnv);
 
     assert( dynamic_cast<EnvUDT*>(ProgNode::interpreter->CallStackBack()) != NULL);
     EnvUDT* callStackBack = static_cast<EnvUDT*>(ProgNode::interpreter->CallStackBack());
@@ -3179,7 +3262,7 @@
     ProgNodeP _t = this->getFirstChild();
 
     BaseGDL* self=_t->Eval(); //ProgNode::interpreter->expr(_t);
-    auto_ptr<BaseGDL> self_guard(self);
+    Guard<BaseGDL> self_guard(self);
     
     _t = _t->getNextSibling();
     //match(antlr::RefAST(_t),IDENTIFIER);
@@ -3211,7 +3294,7 @@
 //		match(antlr::RefAST(_t),MFCALL);
     ProgNodeP _t = this->getFirstChild();
     BaseGDL* self=_t->Eval(); //ProgNode::interpreter->expr(_t);
-    auto_ptr<BaseGDL> self_guard(self);
+    Guard<BaseGDL> self_guard(self);
 
     ProgNodeP mp = _t->getNextSibling();
 //		match(antlr::RefAST(_t),IDENTIFIER);
@@ -3242,7 +3325,7 @@
     ProgNodeP _t = this->getFirstChild();
 
     BaseGDL* self=_t->Eval(); //ProgNode::interpreter->expr(_t);
-    auto_ptr<BaseGDL> self_guard(self);
+    Guard<BaseGDL> self_guard(self);
     
     _t = _t->getNextSibling();
     //match(antlr::RefAST(_t),IDENTIFIER);
@@ -3271,7 +3354,7 @@
 //  match(antlr::RefAST(_t),MFCALL_PARENT);
     ProgNodeP _t = this->getFirstChild();
     BaseGDL* self=_t->Eval(); //ProgNode::interpreter->expr(_t);
-    auto_ptr<BaseGDL> self_guard(self);
+    Guard<BaseGDL> self_guard(self);
     
     _t = _t->getNextSibling();
     ProgNodeP parent = _t;
@@ -3303,7 +3386,7 @@
 //			match(antlr::RefAST(_t),MFCALL_PARENT);
 	ProgNodeP _t = this->getFirstChild();
 	BaseGDL* self=_t->Eval(); //ProgNode::interpreter->expr(_t);
-	auto_ptr<BaseGDL> self_guard(self);
+	Guard<BaseGDL> self_guard(self);
 
 	_t = _t->getNextSibling();
 	ProgNodeP parent = _t;
@@ -3337,7 +3420,7 @@
 //  match(antlr::RefAST(_t),MFCALL_PARENT);
     ProgNodeP _t = this->getFirstChild();
     BaseGDL* self=_t->Eval(); //ProgNode::interpreter->expr(_t);
-    auto_ptr<BaseGDL> self_guard(self);
+    Guard<BaseGDL> self_guard(self);
     
     _t = _t->getNextSibling();
     ProgNodeP parent = _t;
@@ -3545,7 +3628,7 @@
     ProgNodeP _t = mark->getNextSibling(); // skip DOT
 
     BaseGDL* self=_t->Eval(); //ProgNode::interpreter->expr(_t);
-    auto_ptr<BaseGDL> self_guard(self);
+    Guard<BaseGDL> self_guard(self);
 
     ProgNodeP mp2 = _t->getNextSibling();
     //match(antlr::RefAST(_t),IDENTIFIER);
@@ -3570,8 +3653,7 @@
     ProgNode::interpreter->CallStack().push_back(newEnv);
     
     // make the call
-    rEval=
-	    ProgNode::interpreter->
+    rEval= ProgNode::interpreter->
 		    call_fun(static_cast<DSubUD*>(newEnv->GetPro())->GetTree());
     res = ProgNode::interpreter->CallStackBack()->GetPtrTo( rEval);
     return res; // NULL ok, rEval set properly    
@@ -3584,7 +3666,7 @@
     _t = mark->getFirstChild();
 	    
     SizeT nDot=dot->nDot;
-    auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+    Guard<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
 	    
     ProgNode::interpreter->r_dot_array_expr(_t, aD.get());
     _t = _t->getNextSibling();
@@ -3611,7 +3693,7 @@
     ProgNodeP mp2 = _t->getNextSibling(); // interpreter->GetRetTree();
     //match(antlr::RefAST(_t),IDENTIFIER);
     
-    auto_ptr<BaseGDL> self_guard(self);
+    Guard<BaseGDL> self_guard(self);
     
     newEnv=new EnvUDT( self, mp2, "", true);
     
@@ -3639,7 +3721,7 @@
     ProgNodeP _t = mark->getNextSibling(); // skip DOT
 
     BaseGDL* self=_t->Eval(); //ProgNode::interpreter->expr(_t);
-    auto_ptr<BaseGDL> self_guard(self);
+    Guard<BaseGDL> self_guard(self);
 
     ProgNodeP mp2 = _t->getNextSibling();
     //match(antlr::RefAST(_t),IDENTIFIER);
@@ -3679,7 +3761,7 @@
     _t = mark->getFirstChild();
 	    
     SizeT nDot=dot->nDot;
-    auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+    Guard<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
 	    
     ProgNode::interpreter->r_dot_array_expr(_t, aD.get());
     _t = _t->getNextSibling();
@@ -3741,6 +3823,9 @@
   //interpreter->r_dot_array_expr(_t, &aD);
   // r_dot_array_expr /////////////////////
   BaseGDL*         r;
+
+  // clears aL when destroyed
+  ArrayIndexListGuard guard; 
   
   if( _t->getType() == GDLTokenTypes::ARRAYEXPR)
   {
@@ -3754,7 +3839,6 @@
 
     ArrayIndexListT* aL=interpreter->arrayindex_list(_t);
 
-    ArrayIndexListGuard guard;
     guard.reset(aL);
 
     _t = tIn->getNextSibling();
@@ -3762,36 +3846,7 @@
     // check here for object and get struct
     //structR=dynamic_cast<DStructGDL*>(r);
     // this is much faster than a dynamic_cast
-    if( r->Type() != GDL_STRUCT)
-// 		else
-// 			structR = NULL;
-// 		if( structR == NULL)
-    {
-	    bool isObj = interpreter->CallStackBack()->IsObject();
-	    if( isObj)
-	    {
-		    DStructGDL* oStruct = interpreter->ObjectStructCheckAccess( r, tIn);
-
-		    if( aD.IsOwner()) delete r;
-		    aD.SetOwner( false); // object struct, not owned
-
-		    aD.ADRoot( oStruct, guard.release());
-	    }
-	    else
-	    {
-		    throw GDLException( tIn, "Expression must be a"
-		    " STRUCT in this context: "+interpreter->Name(r),true,false);
-	    }
-    }
-    else
-    {
-	    if( r->IsAssoc())
-	    throw GDLException( tIn, "File expression not allowed "
-	    "in this context: "+interpreter->Name(r),true,false);
-
-	    DStructGDL* structR = static_cast<DStructGDL*>(r);
-	    aD.ADRoot( structR, guard.release());
-    }
+    interpreter->SetRootR( tIn, &aD, r, aL);
   }
   else
 // 	case EXPR:
@@ -3799,41 +3854,10 @@
 // 	case VAR:
 // 	case VARPTR:
   {
-	  r=interpreter->r_dot_indexable_expr(_t, &aD);
-	  _t = interpreter->GetRetTree();
+    r=interpreter->r_dot_indexable_expr(_t, &aD);
+    _t = interpreter->GetRetTree();
 
-	  // check here for object and get struct
-	  // this is much faster than a dynamic_cast
-	  if( r->Type() != GDL_STRUCT)
-// 		else
-// 			structR = NULL;
-// 		if( structR == NULL)
-	  {
-		  bool isObj = interpreter->CallStackBack()->IsObject();
-		  if( isObj) // memeber access to object?
-		  {
-			  DStructGDL* oStruct = interpreter->ObjectStructCheckAccess( r, _t);
-			  // oStruct cannot be "Assoc_"
-			  if( aD.IsOwner()) delete r;
-			  aD.SetOwner( false); // object structs are never owned
-			  aD.ADRoot( oStruct);
-		  }
-		  else
-		  {
-			  throw GDLException( _t, "Expression must be a"
-			  " STRUCT in this context: "+interpreter->Name(r),true,false);
-		  }
-	  }
-	  else
-	  {
-		  if( r->IsAssoc())
-		  {
-			  throw GDLException( _t, "File expression not allowed "
-			  "in this context: "+interpreter->Name(r),true,false);
-		  }
-		  DStructGDL* structR = static_cast<DStructGDL*>(r);
-		  aD.ADRoot(structR);
-	  }
+    interpreter->SetRootR( _t, &aD, r, NULL);
   }
 /////////
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/prognodeexpr.hpp gdl/src/prognodeexpr.hpp
--- gdl-0.9.3/src/prognodeexpr.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/prognodeexpr.hpp	2013-03-25 10:36:38.636968562 -0600
@@ -58,8 +58,8 @@
 public:
   BinaryExprNC( const RefDNode& refNode);
 
-  void AdjustTypesNC( std::auto_ptr<BaseGDL>& g1, BaseGDL*& e1, 
-		      std::auto_ptr<BaseGDL>& g2, BaseGDL*& e2);
+  void AdjustTypesNC( Guard<BaseGDL>& g1, BaseGDL*& e1, 
+		      Guard<BaseGDL>& g2, BaseGDL*& e2);
   // for overloaded operators 
   void SetupGuards( Guard<BaseGDL>& g1, BaseGDL*& e1,
 		    Guard<BaseGDL>& g2, BaseGDL*& e2);
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/prognode.hpp gdl/src/prognode.hpp
--- gdl-0.9.3/src/prognode.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/prognode.hpp	2013-03-25 10:36:38.614968664 -0600
@@ -86,11 +86,11 @@
   ProgNodeP down;
   ProgNodeP right;
 
-  static void AdjustTypes(std::auto_ptr<BaseGDL>& a, 
-			  std::auto_ptr<BaseGDL>& b);
+  static void AdjustTypes(Guard<BaseGDL>& a, 
+			  Guard<BaseGDL>& b);
   // for overloaded operators
-  static void AdjustTypesObj(std::auto_ptr<BaseGDL>& a, 
-			  std::auto_ptr<BaseGDL>& b);
+  static void AdjustTypesObj(Guard<BaseGDL>& a, 
+			  Guard<BaseGDL>& b);
 
   BaseGDL*   cData;           // constant data
   DVar*      var;             // ptr to variable 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/prognode_lexpr.cpp gdl/src/prognode_lexpr.cpp
--- gdl-0.9.3/src/prognode_lexpr.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/prognode_lexpr.cpp	2013-03-25 10:36:38.619968641 -0600
@@ -55,7 +55,7 @@
 	ProgNodeP _t = this->getFirstChild();
 	BaseGDL*       e1=interpreter->expr(_t);
 	_t = interpreter->GetRetTree();
-	std::auto_ptr<BaseGDL> e1_guard(e1);
+	Guard<BaseGDL> e1_guard(e1);
 	if( e1->True())
 	{
 	return _t->LExpr( right); //l_expr(_t, right);
@@ -198,12 +198,12 @@
 		true,false);
 
 	BaseGDL** res=this->LEval(); //l_sys_var(this);
-	std::auto_ptr<BaseGDL> conv_guard; //( rConv);
+	Guard<BaseGDL> conv_guard; //( rConv);
 	BaseGDL* rConv = right;
 	if( !(*res)->EqType( right))
 	{
 		rConv = right->Convert2( (*res)->Type(), BaseGDL::COPY);
-		conv_guard.reset( rConv);
+		conv_guard.Reset( rConv);
 	}
 	if( right->N_Elements() != 1 && ((*res)->N_Elements() != right->N_Elements()))
 	{
@@ -333,7 +333,7 @@
 	ProgNodeP _t = this->getFirstChild();
 
 	//SizeT nDot = tIn->nDot;
-	std::auto_ptr<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
+	Guard<DotAccessDescT> aD( new DotAccessDescT(nDot+1));
 
 	interpreter->l_dot_array_expr(_t, aD.get());
 	_t = interpreter->GetRetTree();
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/pythongdl.cpp gdl/src/pythongdl.cpp
--- gdl-0.9.3/src/pythongdl.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/pythongdl.cpp	2013-03-25 10:36:38.647968511 -0600
@@ -375,7 +375,7 @@
     else
       e = new EnvUDT( NULL, sub);
 
-    auto_ptr< EnvBaseT> e_guard( e);
+    Guard< EnvBaseT> e_guard( e);
 
     // copy arguments
     success = CopyArgFromPython( parRef, kwRef, *e, argTuple, kwDict);
@@ -391,7 +391,7 @@
     }
     
     BaseGDL* retValGDL = NULL;
-    auto_ptr<BaseGDL> retValGDL_guard;
+    Guard<BaseGDL> retValGDL_guard;
     if( functionCall)
       {
 	if( libCall) 
@@ -401,7 +401,7 @@
 	  retValGDL = interpreter->call_fun(static_cast<DSubUD*>
 					    (static_cast<EnvUDT*>(e)
 					     ->GetPro())->GetTree());
-	retValGDL_guard.reset( retValGDL);
+	retValGDL_guard.Reset( retValGDL);
       }
     else
       {
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/read.cpp gdl/src/read.cpp
--- gdl-0.9.3/src/read.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/read.cpp	2013-03-25 10:36:38.658968460 -0600
@@ -299,7 +299,7 @@
       throw GDLException( e->CallingNode(), "Parameter undefined: "+
 			  e->GetParString(0));
   
-    //  auto_ptr<DStringGDL> guard;
+    //  Guard<DStringGDL> guard;
     stringstream is;
 
     DStringGDL* iStr = dynamic_cast<DStringGDL*>(p);
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/specializations.hpp gdl/src/specializations.hpp
--- gdl-0.9.3/src/specializations.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/specializations.hpp	2013-05-16 12:36:33.771855921 -0600
@@ -67,22 +67,24 @@
 void Data_<SpDPtr>::Inc();
 template<> 
 void Data_<SpDObj>::Inc();
-template<> 
-Data_<SpDFloat>* Data_<SpDFloat>::AndOp( BaseGDL* r);
+// template<> 
+// Data_<SpDFloat>* Data_<SpDFloat>::AndOp( BaseGDL* r);
 template<> 
 Data_<SpDFloat>* Data_<SpDFloat>::AndOpInv( BaseGDL* r);
-template<> 
-Data_<SpDDouble>* Data_<SpDDouble>::AndOp( BaseGDL* r);
+// template<> 
+// Data_<SpDDouble>* Data_<SpDDouble>::AndOp( BaseGDL* r);
 template<> 
 Data_<SpDDouble>* Data_<SpDDouble>::AndOpInv( BaseGDL* r);
-template<> 
-Data_<SpDString>* Data_<SpDString>::AndOp( BaseGDL* r);
-template<> 
-Data_<SpDComplex>* Data_<SpDComplex>::AndOp( BaseGDL* r);
-template<> 
-Data_<SpDComplexDbl>* Data_<SpDComplexDbl>::AndOp( BaseGDL* r);
-template<> 
-Data_<SpDPtr>* Data_<SpDPtr>::AndOp( BaseGDL* r);
+// template<> 
+// Data_<SpDString>* Data_<SpDString>::AndOp( BaseGDL* r);
+// template<> 
+// Data_<SpDComplex>* Data_<SpDComplex>::AndOp( BaseGDL* r);
+// template<> 
+// Data_<SpDComplexDbl>* Data_<SpDComplexDbl>::AndOp( BaseGDL* r);
+// template<> 
+// Data_<SpDPtr>* Data_<SpDPtr>::AndOp( BaseGDL* r);
+// template<> 
+// Data_<SpDObj>* Data_<SpDObj>::AndOp( BaseGDL* r);
 template<> 
 Data_<SpDFloat>* Data_<SpDFloat>::OrOp( BaseGDL* r);
 template<> 
@@ -339,9 +341,9 @@
 template<> 
 Data_<SpDObj>* Data_<SpDObj>::PowInv( BaseGDL* r);
 template<>
-Data_<SpDString>* Data_<SpDString>::MatrixOp( BaseGDL* r,bool t,bool tr, bool s);
+Data_<SpDString>* Data_<SpDString>::MatrixOp( BaseGDL* r, bool atranspose, bool btranspose);
 template<>
-Data_<SpDPtr>* Data_<SpDPtr>::MatrixOp( BaseGDL* ,bool t,bool tr,bool s);
+Data_<SpDPtr>* Data_<SpDPtr>::MatrixOp( BaseGDL* r, bool atranspose, bool btranspose);
 template<> 
 Data_<SpDByte>* Data_<SpDFloat>::LogNeg();
 template<> 
@@ -393,15 +395,15 @@
 template<> 
 Data_<SpDComplexDbl>::Ty Data_<SpDComplexDbl>::max() const;*/
 template<> 
-int Data_<SpDComplex>::Scalar2index( SizeT& st) const;
+int Data_<SpDComplex>::Scalar2Index( SizeT& st) const;
 template<>  
-int Data_<SpDComplexDbl>::Scalar2index( SizeT& st) const;
+int Data_<SpDComplexDbl>::Scalar2Index( SizeT& st) const;
 template<>  
-int Data_<SpDString>::Scalar2index( SizeT& st) const;
+int Data_<SpDString>::Scalar2Index( SizeT& st) const;
 template<>  
-int Data_<SpDPtr>::Scalar2index( SizeT& st) const;
+int Data_<SpDPtr>::Scalar2Index( SizeT& st) const;
 template<>  
-int Data_<SpDObj>::Scalar2index( SizeT& st) const;
+int Data_<SpDObj>::Scalar2Index( SizeT& st) const;
 template<> 
 bool Data_<SpDFloat>::True();
 template<> 
@@ -644,27 +646,35 @@
        BaseGDL::IOMode oMode); 
 
 
+// template<>
+// void Data_< SpDString>::Construct(); 
+// template<>
+// void Data_< SpDComplex>::Construct(); 
+// template<>
+// void Data_< SpDComplexDbl>::Construct(); 
+template<>
+void Data_< SpDPtr>::Construct(); 
+template<>
+void Data_< SpDObj>::Construct(); 
+// template<>
+// void Data_< SpDString>::ConstructTo0(); 
+// template<>
+// void Data_< SpDComplex>::ConstructTo0(); 
+// template<>
+// void Data_< SpDComplexDbl>::ConstructTo0(); 
+// template<>
+// void Data_< SpDString>::Destruct(); 
+// template<>
+// void Data_< SpDComplex>::Destruct(); 
+// template<>
+// void Data_< SpDComplexDbl>::Destruct(); 
 template<>
-void Data_< SpDString>::Construct(); 
-template<>
-void Data_< SpDComplex>::Construct(); 
-template<>
-void Data_< SpDComplexDbl>::Construct(); 
-template<>
-void Data_< SpDString>::ConstructTo0(); 
+void Data_< SpDPtr>::Destruct(); 
 template<>
-void Data_< SpDComplex>::ConstructTo0(); 
-template<>
-void Data_< SpDComplexDbl>::ConstructTo0(); 
-template<>
-void Data_< SpDString>::Destruct(); 
-template<>
-void Data_< SpDComplex>::Destruct(); 
-template<>
-void Data_< SpDComplexDbl>::Destruct(); 
+void Data_< SpDObj>::Destruct(); 
 
 // GetAsIndex/GetAsIndexStrict
-template<>
+  template<>
 SizeT Data_<SpDInt>::GetAsIndex( SizeT i) const;
 template<>
 SizeT Data_<SpDInt>::GetAsIndexStrict( SizeT i) const;
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/test_template_grouping.cpp gdl/src/test_template_grouping.cpp
--- gdl-0.9.3/src/test_template_grouping.cpp	1969-12-31 17:00:00.000000000 -0700
+++ gdl/src/test_template_grouping.cpp	2013-03-27 06:11:25.000000000 -0600
@@ -0,0 +1,81 @@
+// template<typename Sp>
+// template<typename U>
+// typename Sp::Ty Data_<Sp>::B1() 
+// {
+//     std::cout << "is_integer\n";
+//     return Sp::zero;
+// }
+// template<typename Sp>
+// template<typename U>
+// typename std::enable_if<is_integer<typename U::Ty>::value, typename U::Ty>::type
+// Data_<Sp>::Test1() 
+// {
+//   dd[0]++;
+//   dd[0]--;
+//     std::cout << "is_integer\n";
+//     return Sp::zero;
+// }
+// template<typename Sp>
+// template<typename U>
+// typename std::enable_if<is_float<typename U::Ty>::value, typename U::Ty>::type
+// Data_<Sp>::Test1() 
+// {
+//     std::cout << "is_float\n";
+//     return Sp::zero;
+// }
+// template<typename Sp>
+// template<typename U>
+// typename std::enable_if<is_complex<typename U::Ty>::value, typename U::Ty>::type
+// Data_<Sp>::Test1() 
+// {
+//     std::cout << "is_complex\n";
+//     return Sp::zero;
+// }
+// template<typename Sp>
+// template<typename U>
+// typename std::enable_if<is_other<typename U::Ty>::value, typename U::Ty>::type 
+// Data_<Sp>::Test1() 
+// {
+//     std::cout << "is_other\n";
+//     return Sp::zero;
+// }
+ 
+template<typename Sp>
+template<typename U>
+typename U::template IfInteger<bool>::type 
+Data_<Sp>::Test2() 
+{
+  dd[0]++;
+  dd[0]--;
+    std::cout << "is_integer\n";
+    return true;
+}
+template<typename Sp>
+template<typename U>
+typename U::template IfFloat<bool>::type 
+Data_<Sp>::Test2() 
+{
+    std::cout << "is_float\n";
+    return true;
+}
+template<typename Sp>
+template<typename U>
+typename U::template IfComplex<bool>::type 
+Data_<Sp>::Test2() 
+{
+    std::cout << "is_complex\n";
+    return true;
+}
+template<typename Sp>
+template<typename U>
+typename U::template IfOther<bool>::type 
+Data_<Sp>::Test2() 
+{
+    std::cout << "is_other\n";
+    return false;
+}
+ 
+
+
+
+
Only in gdl-0.9.3/src: .#tmp_scratch.cpp
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/typedefs.hpp gdl/src/typedefs.hpp
--- gdl-0.9.3/src/typedefs.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/typedefs.hpp	2013-03-25 10:36:38.691968308 -0600
@@ -58,15 +58,21 @@
 #include <cassert>
 // #include <cstdio>
 
-// undef for releases (should not give diagnostics)
-// define for the CVS (where the default sizes can easily be adjusted)
-//#define GDL_CVS_VERSION
-#undef GDL_CVS_VERSION
+#undef USE_MPFR
 
-#ifdef GDL_CVS_VERSION
-#include <iostream>
+#ifdef USE_MPFR
+#include "mpreal.h"
 #endif
 
+// // undef for releases (should not give diagnostics)
+// // define for the CVS (where the default sizes can easily be adjusted)
+// #define GDL_CVS_VERSION
+// //#undef GDL_CVS_VERSION
+// // ?
+// #ifdef GDL_CVS_VERSION
+// #include <iostream>
+// #endif
+
 //#define TRACE_OMP_CALLS
 #undef TRACE_OMP_CALLS
 
@@ -79,6 +85,7 @@
 // SA: fixing bug no. 3296360
 typedef unsigned long long int      SizeT;
 typedef long long int RangeT;
+typedef long long int OMPInt;
 
 const SizeT MAXRANK=8;         // arrays are limited to 8 dimensions
 const std::string MAXRANK_STR("8");  // for use in strings (error messages)
@@ -110,6 +117,7 @@
 #ifdef _MSC_VER
 typedef __int64               DLong64;
 typedef unsigned __int64      DULong64;
+
 #else
 //typedef long int               DLong64;
 //typedef unsigned long int      DULong64;
@@ -117,6 +125,19 @@
 typedef unsigned long long int DULong64;
 #endif
 
+#ifdef USE_MPFR
+
+typedef __int128               DLong128;
+typedef unsigned __int128      DULong128;
+
+typedef long double            DLDouble;
+typedef std::complex<DLDouble> DComplexLDbl;
+
+
+typedef mpfr::mpreal           DArbitrary;
+#endif
+
+
 typedef short                  DInt;
 typedef unsigned short         DUInt;
 typedef int                    DLong;
@@ -126,9 +147,8 @@
 typedef std::string            DString;
 typedef SizeT                  DPtr; // ptr to heap
 typedef DPtr                   DObj; // ptr to object heap
-typedef std::complex<float>    DComplex;
-typedef std::complex<double>   DComplexDbl;
-
+typedef std::complex<DFloat>   DComplex;
+typedef std::complex<DDouble>  DComplexDbl;
 
 // list of identifiers (used in several places)
 typedef std::deque<std::string>       IDList;
@@ -194,6 +214,16 @@
 private:
   T*      guarded;
   
+  Guard& operator=( Guard& r)
+  {
+    if( &r == this) return;
+    delete guarded;
+    guarded = r.guarded;
+    r.guarded = NULL;
+    return *this;
+  }
+  
+
 public:
   Guard(): guarded( NULL)
   {}
@@ -210,15 +240,37 @@
     delete guarded;
     guarded = newGuarded;
   }  
+  // for compatibiltiy with replaced auto_ptr
+  void reset( T* newGuarded)
+  {
+    delete guarded;
+    guarded = newGuarded;
+  }  
   void Release()
   {
     guarded = NULL;
   }  
-  T* Get()
+  T* release()
+  {
+    T* g = guarded;
+    guarded = NULL;
+    return g;
+  }  
+  T* Get() const
+  {
+    return guarded;
+  }  
+  // for compatibiltiy with replaced auto_ptr
+  T* get() const
   {
     return guarded;
   }  
-  bool IsNull()
+  // for compatibiltiy with replaced auto_ptr
+  T* operator->() const
+  {
+    return guarded;
+  }
+  bool IsNull() const
   {
     return guarded == NULL;
   }
@@ -352,388 +404,6 @@
   T* Release() { T* r=container; container=NULL; return r;}
 };
 
-// #define GDLARRAY_CACHE
-#undef GDLARRAY_CACHE
-
-#define GDLARRAY_DEBUG
-// #undef GDLARRAY_DEBUG
-
-// const SizeT smallArraySize = 27;
-// const SizeT maxArrayCache = 1000 * 1000; // ComplexDbl is 16 bytes
-
-template <class T>
-class GDLArray
-{
-private:
-	enum GDLArrayConstants
-	{
-		smallArraySize = 27,
-		maxCache = 1000 * 1000 // ComplexDbl is 16 bytes
-	};
-		
-	typedef T Ty;
-
-#ifdef GDLARRAY_CACHE
-		
-	static SizeT cacheSize;
-	static T* cache;
-	static T* Cached( SizeT newSize);
-#endif
-		
-	T scalar[ smallArraySize];
-	T*    buf;
-	SizeT sz;
-
-public:
-  	GDLArray() throw() : buf( NULL), sz( 0) {}
-  
-#ifndef GDLARRAY_CACHE
-
-  GDLArray( const GDLArray& cp) : sz( cp.size())
-  {
-    try {
-		buf = (cp.size() > smallArraySize) ? new T[ cp.size()] : scalar;
-    } catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than available"); }
-/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
-{
-#pragma omp for*/
-    std::memcpy(buf,cp.buf,sz*sizeof(T));
-   
-//     for( SizeT i=0; i<sz; ++i)
-//       buf[ i] = cp.buf[ i];
-// }
-  }
-
-  GDLArray( SizeT s, bool b) : sz( s)
-  {
-	  try {
-		buf = (s > smallArraySize) ? new T[ s] : scalar;
-    } catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than available"); }
-  }
-  
-  GDLArray( T val, SizeT s) : sz( s)
-  {
-	  try {
-	    buf = (s > smallArraySize) ? new T[ s] : scalar;
-    } catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than available"); }
-/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
-{
-#pragma omp for*/
-    for( SizeT i=0; i<sz; ++i)
-      buf[ i] = val;
-// }
-  }
-  
-  GDLArray( const T* arr, SizeT s) : sz( s)
-  {
-	try
-	{
-		buf = ( s > smallArraySize ) ? new T[ s]: scalar;
-	}
-	catch ( std::bad_alloc& ) { ThrowGDLException ( "Array requires more memory than available" ); }
-/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
-{
-#pragma omp for*/
-    
-    std::memcpy(buf,arr,sz*sizeof(T));
-//     for( SizeT i=0; i<sz; ++i)
-//       buf[ i] = arr[ i];
-
-// }
-  }
-
-  ~GDLArray() throw()
-  {
-  if( buf != scalar) 
-      	delete[] buf; // buf == NULL also possible
-  }
-#else
-
-  // use definition in datatypes.cpp
-  GDLArray( const GDLArray& cp) ;
-  GDLArray( SizeT s, bool b) ;
-  GDLArray( T val, SizeT s) ;
-  GDLArray( const T* arr, SizeT s) ;
-  ~GDLArray() throw();
-
-#endif // GDLARRAY_DEBUG
-  
-
-
-  explicit GDLArray( const T& s) throw() : /*scalar( s),*/ buf( scalar), sz( 1)
-  { scalar[0] = s;}
-
-  T& operator[]( SizeT ix) throw()
-  {
-    // if( ix >= sz) 
-    assert( ix < sz);
-    return buf[ ix];
-  }
-  const T& operator[]( SizeT ix) const throw()
-  {
-//     if( ix >= sz) // debug 
-      assert( ix < sz);
-    return buf[ ix];
-  }
-
-// private: // disable
-// only used (indirect) by DStructGDL::DStructGDL(const DStructGDL& d_)
-void InitFrom( const GDLArray& right )
-{
-// 	// assert( sz == right.size());
-// 	if ( sz != right.size() )
-// 		ThrowGDLException ( "GDLArray::operator= operands have not same size (this: " + i2s ( sz ) +", right: " + i2s ( right.size() ) + ")");
-	assert( &right != this);
- 	assert ( sz == right.size() );
-    std::memcpy(buf,right.buf,sz*sizeof(T));
-}
-
-GDLArray& operator= ( const GDLArray& right )
-{
-// 	if ( sz != right.size() )
-// 		ThrowGDLException ( "GDLArray::operator= operands have not same size (this: " + i2s ( sz ) +", right: " + i2s ( right.size() ) + ")");
-
-    assert( this != &right);
-	assert( sz == right.size());
-//   	if ( &right != this )
-       {
-// 		if ( sz == right.size() )
-		{
-			/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
-			{
-			#pragma omp for*/
-			for ( SizeT i=0; i<sz; ++i )
-				buf[ i] = right.buf[ i];
-			return *this;
-// }
-		}
-// 		else
-		{
-			if ( buf != scalar )
-				delete[] buf;
-			sz = right.size();
-			buf = ( sz>smallArraySize ) ? new T[ sz] : scalar;
-			/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
-			{
-			#pragma omp for*/
-			for ( SizeT i=0; i<sz; ++i )
-				buf[ i] = right.buf[ i];
-			return *this;
-		}
-		}
-	//       }
-}
-
-  GDLArray& operator+=( const GDLArray& right) throw()
-  {
-/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
-{
-#pragma omp for*/
-    for( SizeT i=0; i<sz; ++i)
-      buf[ i] += right.buf[ i];
-// }
-    return *this;
-  }
-  GDLArray& operator-=( const GDLArray& right) throw()
-  {
-/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
-{
-#pragma omp for*/
-    for( SizeT i=0; i<sz; ++i)
-      buf[ i] -= right.buf[ i];
-// }
-    return *this;
-  }
-//   GDLArray&operator*=( const GDLArray& right) throw()
-//   {
-//     for( SizeT i=0; i<sz; ++i)
-//       buf[ i] *= right.buf[ i];
-//     return *this;
-//   }
-//   GDLArray&operator/=( const GDLArray& right)
-//   {
-//     for( SizeT i=0; i<sz; ++i)
-//       buf[ i] /= right.buf[ i]; // can be 0
-//     return *this;
-//   }
-
-// private: // disable
-  GDLArray& operator+=( const T& right) throw()
-  {
-/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
-{
-#pragma omp for*/
-    for( SizeT i=0; i<sz; ++i)
-      buf[ i] += right;
-// }
-    return *this;
-  }
-  GDLArray& operator-=( const T& right) throw()
-  {
-/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
-{
-#pragma omp for*/
-    for( SizeT i=0; i<sz; ++i)
-      buf[ i] -= right;
-// }
-    return *this;
-  }
-//   GDLArray&operator*=( const T& right) throw()
-//   {
-//     for( SizeT i=0; i<sz; ++i)
-//       buf[ i] *= right;
-//     return *this;
-//   }
-//   GDLArray&operator/=( const T& right)
-//   {
-//     for( SizeT i=0; i<sz; ++i)
-//       buf[ i] /= right; // can be 0
-//     return *this;
-//   }
-
-  void SetBuffer( T* b) throw()
-  {
-    buf = b;
-  }
-  T* GetBuffer() throw()
-  {
-    return buf;
-  }
-  void SetBufferSize( SizeT s) throw()
-  {
-    sz = s;
-  }
-
-  SizeT size() const throw()
-  {
-    return sz;
-  }
-
-void SetSize( SizeT newSz ) // only used in DStructGDL::DStructGDL( const string& name_) (dstructgdl.cpp)
-{
-	assert ( sz == 0);
-	if ( newSz > smallArraySize )
-	{
-		try
-		{
-			buf = new T[ newSz];
-		}
-		catch ( std::bad_alloc& )
-		{
-			ThrowGDLException ( "Array requires more memory than available" );
-		}
-	}
-	else
-	{
-// default constructed instances have buf == NULL and size == 0
-// make sure buf is set corectly if such instances are resized
-		buf = scalar;
-	}
-	sz = newSz;
-// 	assert ( newSz > sz );
-// 	if ( newSz > smallArraySize )
-// 	{
-// 		try
-// 		{
-// 			T* newBuf = new T[ newSz];
-// 			/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
-// 			{
-// 			#pragma omp for*/
-// 			for ( SizeT i=0; i<sz; ++i )
-// 				newBuf[ i] = buf[ i];
-// // }
-// 			if ( buf != scalar )
-// 				delete[] buf;
-// 			buf = newBuf;
-// 		}
-// 		catch ( std::bad_alloc& )
-// 		{
-// 			ThrowGDLException ( "Array requires more memory than available" );
-// 		}
-// 	}
-// 	else
-// 	{
-// // default constructed instances have buf == NULL and size == 0
-// // make sure buf is set corectly if such instances are resized
-// 		buf = scalar;
-// 	}
-// 	sz = newSz;
-}
-
-//   T min() const
-//   {
-//     T res = buf[ 0];
-//     for( SizeT i=1; i<sz; ++i)
-//       if( res > buf[ i]) res = buf[ i];
-//     return res;
-//   }
-//   T max() const
-//   {
-//     T res = buf[ 0];
-//     for( SizeT i=1; i<sz; ++i)
-//       if( res < buf[ i]) res = buf[ i];
-//     return res;
-//   }
-}; // GDLArray
-
-template<>
-inline void GDLArray<DString>::InitFrom( const GDLArray& right )
-{
-	assert( &right != this);
- 	assert ( sz == right.size() );
-	for ( SizeT i=0; i<sz; ++i )
-		buf[ i] = right.buf[ i];
-}
-
-template<>
-inline GDLArray<DString>::GDLArray( const GDLArray& cp) : sz( cp.size())
-  {
-    try {
-		buf = (cp.size() > smallArraySize) ? new Ty[ cp.size()] : scalar;
-    } catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than available"); }
-/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
-{
-#pragma omp for*/
-     for( SizeT i=0; i<sz; ++i)
-       buf[ i] = cp.buf[ i];
-// }
-  }
-
-template<>
-inline GDLArray<DString>::GDLArray( const Ty* arr, SizeT s) : sz( s)
-  {
-    try {
-    buf = (s > smallArraySize) ? new Ty[ s]: scalar;
-    } catch (std::bad_alloc&) { ThrowGDLException("Array requires more memory than available"); }
-/*#pragma omp parallel if (sz >= CpuTPOOL_MIN_ELTS && (CpuTPOOL_MAX_ELTS == 0 || CpuTPOOL_MAX_ELTS <= sz))
-{
-#pragma omp for*/
-     for( SizeT i=0; i<sz; ++i)
-       buf[ i] = arr[ i];
-// }
-  }
-
-// friend  GDLArray pow(const GDLArray& left, const GDLArray& right);
-
-// friend  GDLArray pow(const GDLArray& left, const T& right);
-
-// friend  GDLArray pow(const T& left, const GDLArray& right);
-
-// };
-
-// template<class Ty>
-//     GDLArray<Ty> pow(const GDLArray<Ty>& left,
-//         const GDLArray<Ty>& right)
-// {
-//   GDLArray<Ty> res( left.size);
-  
-//   for( SizeT i=0; i<left.size(); ++i)
-//     res[ i] = pow(left[i],right[i]);
-// }
-// template<class Ty>
-//     GDLArray<Ty> pow(const GDLArray<Ty> left, const Ty& right);
-// template<class Ty>
-//     GDLArray<Ty> pow(const Ty& left, const GDLArray<Ty>& right);
 
 // this data structure is optimized for list sizes < ExprListDefaultLength
 // ExprListDefaultLength should be set such that it will probably never exceed
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/typetraits.cpp gdl/src/typetraits.cpp
--- gdl-0.9.3/src/typetraits.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/typetraits.cpp	2013-03-21 14:04:04.501824603 -0600
@@ -26,10 +26,6 @@
 const DType  SpDByte::t=GDL_BYTE; // type ID
 const string SpDByte::str("BYTE"); // type string
 const DByte  SpDByte::zero=0;
-const bool SpDByte::IS_INTEGER=true;
-const bool SpDByte::IS_SIGNED=false;
-const bool SpDByte::IS_NUMERIC=true;
-const bool SpDByte::IS_COMPLEX=false;
 BaseGDL* SpDByte::GetTag() const { return new SpDByte(*this);}
 DType   SpDByte::Type()    const { return t;}
 const std::string& SpDByte::TypeStr() const { return str;}
@@ -37,10 +33,6 @@
 const DType  SpDInt::t=GDL_INT; // type ID
 const string SpDInt::str("INT"); // type string
 const DInt   SpDInt::zero=0;
-const bool SpDInt::IS_INTEGER=true;
-const bool SpDInt::IS_SIGNED=true;
-const bool SpDInt::IS_NUMERIC=true;
-const bool SpDInt::IS_COMPLEX=false;
 BaseGDL* SpDInt::GetTag() const { return new SpDInt(*this);}
 DType   SpDInt::Type()    const { return t;}
 const std::string& SpDInt::TypeStr() const { return str;}
@@ -48,10 +40,6 @@
 const DType  SpDUInt::t=GDL_UINT; // type ID
 const string SpDUInt::str("UINT"); // type string
 const DUInt  SpDUInt::zero=0;
-const bool SpDUInt::IS_INTEGER=true;
-const bool SpDUInt::IS_SIGNED=false;
-const bool SpDUInt::IS_NUMERIC=true;
-const bool SpDUInt::IS_COMPLEX=false;
 BaseGDL* SpDUInt::GetTag() const { return new SpDUInt(*this);}
 DType   SpDUInt::Type()    const { return t;}
 const std::string& SpDUInt::TypeStr() const { return str;}
@@ -60,10 +48,6 @@
 const DType  SpDLong::t=GDL_LONG; // type ID
 const string SpDLong::str("LONG"); // type string
 const DLong  SpDLong::zero=0;
-const bool SpDLong::IS_INTEGER=true;
-const bool SpDLong::IS_SIGNED=true;
-const bool SpDLong::IS_NUMERIC=true;
-const bool SpDLong::IS_COMPLEX=false;
 BaseGDL* SpDLong::GetTag() const { return new SpDLong(*this);}
 DType   SpDLong::Type()    const { return t;}
 const std::string& SpDLong::TypeStr() const { return str;}
@@ -71,10 +55,6 @@
 const DType  SpDULong::t=GDL_ULONG; // type ID
 const string SpDULong::str("ULONG"); // type string
 const DULong SpDULong::zero=0;
-const bool SpDULong::IS_INTEGER=true;
-const bool SpDULong::IS_SIGNED=false;
-const bool SpDULong::IS_NUMERIC=true;
-const bool SpDULong::IS_COMPLEX=false;
 BaseGDL* SpDULong::GetTag() const { return new SpDULong(*this);}
 DType   SpDULong::Type()    const { return t;}
 const std::string& SpDULong::TypeStr() const { return str;}
@@ -82,10 +62,6 @@
 const DType  SpDLong64::t=GDL_LONG64; // type ID
 const string SpDLong64::str("LONG64"); // type string
 const DLong64  SpDLong64::zero=0;
-const bool SpDLong64::IS_INTEGER=true;
-const bool SpDLong64::IS_SIGNED=true;
-const bool SpDLong64::IS_NUMERIC=true;
-const bool SpDLong64::IS_COMPLEX=false;
 BaseGDL* SpDLong64::GetTag() const { return new SpDLong64(*this);}
 DType   SpDLong64::Type()    const { return t;}
 const std::string& SpDLong64::TypeStr() const { return str;}
@@ -93,10 +69,6 @@
 const DType  SpDULong64::t=GDL_ULONG64; // type ID
 const string SpDULong64::str("ULONG64"); // type string
 const DULong64 SpDULong64::zero=0;
-const bool SpDULong64::IS_INTEGER=true;
-const bool SpDULong64::IS_SIGNED=false;
-const bool SpDULong64::IS_NUMERIC=true;
-const bool SpDULong64::IS_COMPLEX=false;
 BaseGDL* SpDULong64::GetTag() const { return new SpDULong64(*this);}
 DType   SpDULong64::Type()    const { return t;}
 const std::string& SpDULong64::TypeStr() const { return str;}
@@ -104,10 +76,6 @@
 const DType  SpDFloat::t=GDL_FLOAT; // type ID
 const string SpDFloat::str("FLOAT"); // type string
 const DFloat SpDFloat::zero=0.0;
-const bool SpDFloat::IS_INTEGER=false;
-const bool SpDFloat::IS_SIGNED=true;
-const bool SpDFloat::IS_NUMERIC=true;
-const bool SpDFloat::IS_COMPLEX=false;
 BaseGDL* SpDFloat::GetTag() const { return new SpDFloat(*this);}
 DType   SpDFloat::Type()    const { return t;}
 const std::string& SpDFloat::TypeStr() const { return str;}
@@ -115,10 +83,6 @@
 const DType   SpDDouble::t=GDL_DOUBLE; // type ID
 const string  SpDDouble::str("DOUBLE"); // type string
 const DDouble SpDDouble::zero=0.0;
-const bool SpDDouble::IS_INTEGER=false;
-const bool SpDDouble::IS_SIGNED=true;
-const bool SpDDouble::IS_NUMERIC=true;
-const bool SpDDouble::IS_COMPLEX=false;
 BaseGDL* SpDDouble::GetTag() const { return new SpDDouble(*this);}
 DType   SpDDouble::Type()    const { return t;}
 const std::string& SpDDouble::TypeStr() const { return str;}
@@ -126,10 +90,6 @@
 const DType   SpDString::t=GDL_STRING; // type ID
 const string  SpDString::str("STRING"); // type string
 const DString SpDString::zero(""); // zero string
-const bool SpDString::IS_INTEGER=false;
-const bool SpDString::IS_SIGNED=false;
-const bool SpDString::IS_NUMERIC=false;
-const bool SpDString::IS_COMPLEX=false;
 BaseGDL* SpDString::GetTag() const { return new SpDString(*this);}
 DType   SpDString::Type()    const { return t;}
 const std::string& SpDString::TypeStr() const { return str;}
@@ -137,10 +97,6 @@
 const DType    SpDStruct::t=GDL_STRUCT;      // type ID
 const string   SpDStruct::str("STRUCT"); // type string
 const SpDStruct::Ty  SpDStruct::zero=0; // zero struct, special meaning
-const bool SpDStruct::IS_INTEGER=false;
-const bool SpDStruct::IS_SIGNED=false;
-const bool SpDStruct::IS_NUMERIC=false;
-const bool SpDStruct::IS_COMPLEX=false;
 BaseGDL* SpDStruct::GetTag() const 
 { 
   SpDStruct* newTag = new SpDStruct(*this);
@@ -153,10 +109,6 @@
 const DType   SpDPtr::t=GDL_PTR;   // type ID
 const string  SpDPtr::str("POINTER"); // type string
 const DPtr    SpDPtr::zero=0;  // zero ptr
-const bool SpDPtr::IS_INTEGER=false;
-const bool SpDPtr::IS_SIGNED=false;
-const bool SpDPtr::IS_NUMERIC=false;
-const bool SpDPtr::IS_COMPLEX=false;
 BaseGDL* SpDPtr::GetTag() const { return new SpDPtr(*this);}
 DType   SpDPtr::Type()    const { return t;}
 const std::string& SpDPtr::TypeStr() const { return str;}
@@ -164,10 +116,6 @@
 const DType   SpDObj::t=GDL_OBJ;   // type ID
 const string  SpDObj::str("OBJREF"); // type string
 const DObj    SpDObj::zero=0;  // zero ptr/obj
-const bool SpDObj::IS_INTEGER=false;
-const bool SpDObj::IS_SIGNED=false;
-const bool SpDObj::IS_NUMERIC=false;
-const bool SpDObj::IS_COMPLEX=false;
 BaseGDL* SpDObj::GetTag() const { return new SpDObj(*this);}
 DType   SpDObj::Type()    const { return t;}
 const std::string& SpDObj::TypeStr() const { return str;}
@@ -175,10 +123,6 @@
 const DType  SpDComplex::t=GDL_COMPLEX; // type ID
 const string SpDComplex::str("COMPLEX"); // type string
 const DComplex SpDComplex::zero(0.0,0.0);
-const bool SpDComplex::IS_INTEGER=false;
-const bool SpDComplex::IS_SIGNED=true;
-const bool SpDComplex::IS_NUMERIC=true;
-const bool SpDComplex::IS_COMPLEX=true;
 BaseGDL* SpDComplex::GetTag() const { return new SpDComplex(*this);}
 DType   SpDComplex::Type()    const { return t;}
 const std::string& SpDComplex::TypeStr() const { return str;}
@@ -186,10 +130,6 @@
 const DType  SpDComplexDbl::t=GDL_COMPLEXDBL; // type ID
 const string SpDComplexDbl::str("DCOMPLEX"); // type string
 const DComplexDbl SpDComplexDbl::zero(0.0,0.0);
-const bool SpDComplexDbl::IS_INTEGER=false;
-const bool SpDComplexDbl::IS_SIGNED=true;
-const bool SpDComplexDbl::IS_NUMERIC=true;
-const bool SpDComplexDbl::IS_COMPLEX=true;
 BaseGDL* SpDComplexDbl::GetTag() const { return new SpDComplexDbl(*this);}
 DType   SpDComplexDbl::Type()    const { return t;}
 const std::string& SpDComplexDbl::TypeStr() const { return str;}
@@ -317,3 +257,89 @@
 SpDComplexDbl::SpDComplexDbl( const dimension& dim_): BaseGDL(dim_) {}
 SpDComplexDbl::~SpDComplexDbl() {}
 
+
+
+
+/*
+
+const bool SpDByte::IS_INTEGER=true;
+const bool SpDByte::IS_SIGNED=false;
+const bool SpDByte::IS_NUMERIC=true;
+const bool SpDByte::IS_COMPLEX=false;
+const bool SpDByte::IS_POD=true;
+const bool SpDByte::IS_CONVERTABLE=true;
+
+const bool SpDInt::IS_INTEGER=true;
+const bool SpDInt::IS_SIGNED=true;
+const bool SpDInt::IS_NUMERIC=true;
+const bool SpDInt::IS_COMPLEX=false;
+const bool SpDInt::IS_POD=true;
+const bool SpDInt::IS_CONVERTABLE=true;
+
+const bool SpDUInt::IS_INTEGER=true;
+const bool SpDUInt::IS_SIGNED=false;
+const bool SpDUInt::IS_NUMERIC=true;
+const bool SpDUInt::IS_COMPLEX=false;
+
+const bool SpDLong::IS_INTEGER=true;
+const bool SpDLong::IS_SIGNED=true;
+const bool SpDLong::IS_NUMERIC=true;
+const bool SpDLong::IS_COMPLEX=false;
+
+const bool SpDULong::IS_INTEGER=true;
+const bool SpDULong::IS_SIGNED=false;
+const bool SpDULong::IS_NUMERIC=true;
+const bool SpDULong::IS_COMPLEX=false;
+
+const bool SpDLong64::IS_INTEGER=true;
+const bool SpDLong64::IS_SIGNED=true;
+const bool SpDLong64::IS_NUMERIC=true;
+const bool SpDLong64::IS_COMPLEX=false;
+
+const bool SpDFloat::IS_INTEGER=false;
+const bool SpDFloat::IS_SIGNED=true;
+const bool SpDFloat::IS_NUMERIC=true;
+const bool SpDFloat::IS_COMPLEX=false;
+
+const bool SpDULong64::IS_INTEGER=true;
+const bool SpDULong64::IS_SIGNED=false;
+const bool SpDULong64::IS_NUMERIC=true;
+const bool SpDULong64::IS_COMPLEX=false;
+
+const bool SpDDouble::IS_INTEGER=false;
+const bool SpDDouble::IS_SIGNED=true;
+const bool SpDDouble::IS_NUMERIC=true;
+const bool SpDDouble::IS_COMPLEX=false;
+
+const bool SpDString::IS_INTEGER=false;
+const bool SpDString::IS_SIGNED=false;
+const bool SpDString::IS_NUMERIC=false;
+const bool SpDString::IS_COMPLEX=false;
+
+const bool SpDStruct::IS_INTEGER=false;
+const bool SpDStruct::IS_SIGNED=false;
+const bool SpDStruct::IS_NUMERIC=false;
+const bool SpDStruct::IS_COMPLEX=false;
+
+const bool SpDPtr::IS_INTEGER=false;
+const bool SpDPtr::IS_SIGNED=false;
+const bool SpDPtr::IS_NUMERIC=false;
+const bool SpDPtr::IS_COMPLEX=false;
+
+const bool SpDObj::IS_INTEGER=false;
+const bool SpDObj::IS_SIGNED=false;
+const bool SpDObj::IS_NUMERIC=false;
+const bool SpDObj::IS_COMPLEX=false;
+
+const bool SpDComplex::IS_INTEGER=false;
+const bool SpDComplex::IS_SIGNED=true;
+const bool SpDComplex::IS_NUMERIC=true;
+const bool SpDComplex::IS_COMPLEX=true;
+
+const bool SpDComplexDbl::IS_INTEGER=false;
+const bool SpDComplexDbl::IS_SIGNED=true;
+const bool SpDComplexDbl::IS_NUMERIC=true;
+const bool SpDComplexDbl::IS_COMPLEX=true;
+
+
+*/
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/typetraits.hpp gdl/src/typetraits.hpp
--- gdl-0.9.3/src/typetraits.hpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/typetraits.hpp	2013-03-25 10:36:38.695968289 -0600
@@ -25,6 +25,7 @@
 
 #include "basegdl.hpp"
 #include "dstructdesc.hpp"
+#include "gdlarray.hpp"
 
 // define type parameterization here
 struct SpDByte: public BaseGDL
@@ -36,9 +37,6 @@
   BaseGDL* GetInstance() const;
   BaseGDL* GetEmptyInstance() const;
 
-  typedef DByte Ty;
-  typedef GDLArray<Ty>    DataT;
-
   SizeT NBytes() const
   {
 	return (this->N_Elements() * sizeof( Ty));
@@ -48,11 +46,32 @@
   static const std::string str; 
   static const DByte zero;
 
-  static const bool IS_INTEGER;
-  static const bool IS_SIGNED;
-  static const bool IS_NUMERIC;
-  static const bool IS_COMPLEX;
+//   static const bool IS_INTEGER;
+//   static const bool IS_SIGNED;
+//   static const bool IS_NUMERIC;
+//   static const bool IS_COMPLEX;
+//   static const bool IS_POD;
+//   static const bool IS_CONVERTABLE;
+  static const bool IS_INTEGER = true;
+  static const bool IS_SIGNED = false;
+  static const bool IS_NUMERIC = true;
+  static const bool IS_FLOAT = false;
+  static const bool IS_COMPLEX = false;
+  static const bool IS_POD = true;
+  static const bool IS_CONVERTABLE = true;
+
+  typedef DByte Ty;
+  typedef GDLArray<Ty,IS_POD>    DataT;
 
+  template <typename ReturnType>
+  struct IfInteger { typedef ReturnType type; };
+  template <typename ReturnType>
+  struct IfFloat {};
+  template <typename ReturnType>
+  struct IfComplex {};
+  template <typename ReturnType>
+  struct IfOther {};
+ 
   DType   Type()    const;
   const std::string& TypeStr() const;
 
@@ -68,9 +87,6 @@
   BaseGDL* GetInstance() const;
   BaseGDL* GetEmptyInstance() const;
 
-  typedef DInt Ty;
-  typedef GDLArray<Ty>    DataT;
-
   SizeT NBytes() const
   {
 	return (this->N_Elements() * sizeof( Ty));
@@ -80,11 +96,32 @@
   static const std::string str; 
   static const DInt zero;
 
-  static const bool IS_INTEGER;
-  static const bool IS_SIGNED;
-  static const bool IS_NUMERIC;
-  static const bool IS_COMPLEX;
+//   static const bool IS_INTEGER;
+//   static const bool IS_SIGNED;
+//   static const bool IS_NUMERIC;
+//   static const bool IS_COMPLEX;
+//   static const bool IS_POD;
+//   static const bool IS_CONVERTABLE;
+  static const bool IS_INTEGER = true;
+  static const bool IS_SIGNED = true;
+  static const bool IS_NUMERIC = true;
+  static const bool IS_FLOAT = false;
+  static const bool IS_COMPLEX = false;
+  static const bool IS_POD = true;
+  static const bool IS_CONVERTABLE = true;
 
+  typedef DInt Ty;
+  typedef GDLArray<Ty,IS_POD>    DataT;
+
+  template <typename ReturnType>
+  struct IfInteger { typedef ReturnType type; };
+  template <typename ReturnType>
+  struct IfFloat {};
+  template <typename ReturnType>
+  struct IfComplex {};
+  template <typename ReturnType>
+  struct IfOther {};
+ 
   DType   Type()    const;
   const std::string& TypeStr() const;
 
@@ -100,9 +137,6 @@
   BaseGDL* GetInstance() const;
   BaseGDL* GetEmptyInstance() const;
 
-  typedef DUInt Ty;
-  typedef GDLArray<Ty>    DataT;
-
   SizeT NBytes() const
   {
 	return (this->N_Elements() * sizeof( Ty));
@@ -112,10 +146,32 @@
   static const std::string str; 
   static const DUInt zero;
 
-  static const bool IS_INTEGER;
-  static const bool IS_SIGNED;
-  static const bool IS_NUMERIC;
-  static const bool IS_COMPLEX;
+//   static const bool IS_INTEGER;
+//   static const bool IS_SIGNED;
+//   static const bool IS_NUMERIC;
+//   static const bool IS_COMPLEX;
+//   static const bool IS_POD;
+//   static const bool IS_CONVERTABLE;
+  static const bool IS_INTEGER = true;
+  static const bool IS_SIGNED = false;
+  static const bool IS_NUMERIC = true;
+  static const bool IS_FLOAT = false;
+  static const bool IS_COMPLEX = false;
+  static const bool IS_POD = true;
+  static const bool IS_CONVERTABLE = true;
+
+  typedef DUInt Ty;
+  typedef GDLArray<Ty,IS_POD>    DataT;
+
+  template <typename ReturnType>
+  struct IfInteger { typedef ReturnType type; };
+  template <typename ReturnType>
+  struct IfFloat {};
+  template <typename ReturnType>
+  struct IfComplex {};
+  template <typename ReturnType>
+  struct IfOther {};
+ 
 
   DType   Type()    const;
   const std::string& TypeStr() const;
@@ -132,9 +188,6 @@
   BaseGDL* GetInstance() const;
   BaseGDL* GetEmptyInstance() const;
 
-  typedef DLong Ty;
-  typedef GDLArray<Ty>    DataT;
-
   SizeT NBytes() const
   {
 	return (this->N_Elements() * sizeof( Ty));
@@ -144,10 +197,32 @@
   static const std::string str; 
   static const DLong  zero;
 
-  static const bool IS_INTEGER;
-  static const bool IS_SIGNED;
-  static const bool IS_NUMERIC;
-  static const bool IS_COMPLEX;
+//   static const bool IS_INTEGER;
+//   static const bool IS_SIGNED;
+//   static const bool IS_NUMERIC;
+//   static const bool IS_COMPLEX;
+//   static const bool IS_POD;
+//   static const bool IS_CONVERTABLE;
+  static const bool IS_INTEGER = true;
+  static const bool IS_SIGNED = true;
+  static const bool IS_NUMERIC = true;
+  static const bool IS_FLOAT = false;
+  static const bool IS_COMPLEX = false;
+  static const bool IS_POD = true;
+  static const bool IS_CONVERTABLE = true;
+
+  typedef DLong Ty;
+  typedef GDLArray<Ty,IS_POD>    DataT;
+
+  template <typename ReturnType>
+  struct IfInteger { typedef ReturnType type; };
+  template <typename ReturnType>
+  struct IfFloat {};
+  template <typename ReturnType>
+  struct IfComplex {};
+  template <typename ReturnType>
+  struct IfOther {};
+ 
 
   DType   Type()    const;
   const std::string& TypeStr() const;
@@ -164,9 +239,6 @@
   BaseGDL* GetInstance() const;
   BaseGDL* GetEmptyInstance() const;
 
-  typedef DULong Ty;
-  typedef GDLArray<Ty>    DataT;
-
   SizeT NBytes() const
   {
 	return (this->N_Elements() * sizeof( Ty));
@@ -176,10 +248,32 @@
   static const std::string str; 
   static const DULong zero;
 
-  static const bool IS_INTEGER;
-  static const bool IS_SIGNED;
-  static const bool IS_NUMERIC;
-  static const bool IS_COMPLEX;
+//   static const bool IS_INTEGER;
+//   static const bool IS_SIGNED;
+//   static const bool IS_NUMERIC;
+//   static const bool IS_COMPLEX;
+//   static const bool IS_POD;
+//   static const bool IS_CONVERTABLE;
+  static const bool IS_INTEGER = true;
+  static const bool IS_SIGNED = false;
+  static const bool IS_NUMERIC = true;
+  static const bool IS_FLOAT = false;
+  static const bool IS_COMPLEX = false;
+  static const bool IS_POD = true;
+  static const bool IS_CONVERTABLE = true;
+
+  typedef DULong Ty;
+  typedef GDLArray<Ty,IS_POD>    DataT;
+
+  template <typename ReturnType>
+  struct IfInteger { typedef ReturnType type; };
+  template <typename ReturnType>
+  struct IfFloat {};
+  template <typename ReturnType>
+  struct IfComplex {};
+  template <typename ReturnType>
+  struct IfOther {};
+ 
 
   DType   Type()    const;
   const std::string& TypeStr() const;
@@ -196,9 +290,6 @@
   BaseGDL* GetInstance() const;
   BaseGDL* GetEmptyInstance() const;
 
-  typedef DLong64 Ty;
-  typedef GDLArray<Ty>    DataT;
-
   SizeT NBytes() const
   {
 	return (this->N_Elements() * sizeof( Ty));
@@ -208,10 +299,32 @@
   static const std::string str; 
   static const DLong64  zero;
 
-  static const bool IS_INTEGER;
-  static const bool IS_SIGNED;
-  static const bool IS_NUMERIC;
-  static const bool IS_COMPLEX;
+//   static const bool IS_INTEGER;
+//   static const bool IS_SIGNED;
+//   static const bool IS_NUMERIC;
+//   static const bool IS_COMPLEX;
+//   static const bool IS_POD;
+//   static const bool IS_CONVERTABLE;
+  static const bool IS_INTEGER = true;
+  static const bool IS_SIGNED = true;
+  static const bool IS_NUMERIC = true;
+  static const bool IS_FLOAT = false;
+  static const bool IS_COMPLEX = false;
+  static const bool IS_POD = true;
+  static const bool IS_CONVERTABLE = true;
+
+  typedef DLong64 Ty;
+  typedef GDLArray<Ty,IS_POD>    DataT;
+
+  template <typename ReturnType>
+  struct IfInteger { typedef ReturnType type; };
+  template <typename ReturnType>
+  struct IfFloat {};
+  template <typename ReturnType>
+  struct IfComplex {};
+  template <typename ReturnType>
+  struct IfOther {};
+ 
 
   DType   Type()    const;
   const std::string& TypeStr() const;
@@ -228,9 +341,6 @@
   BaseGDL* GetInstance() const;
   BaseGDL* GetEmptyInstance() const;
 
-  typedef DULong64 Ty;
-  typedef GDLArray<Ty>    DataT;
-
   SizeT NBytes() const
   {
 	return (this->N_Elements() * sizeof( Ty));
@@ -240,10 +350,32 @@
   static const std::string str; 
   static const DULong64 zero;
 
-  static const bool IS_INTEGER;
-  static const bool IS_SIGNED;
-  static const bool IS_NUMERIC;
-  static const bool IS_COMPLEX;
+//   static const bool IS_INTEGER;
+//   static const bool IS_SIGNED;
+//   static const bool IS_NUMERIC;
+//   static const bool IS_COMPLEX;
+//   static const bool IS_POD;
+//   static const bool IS_CONVERTABLE;
+  static const bool IS_INTEGER = true;
+  static const bool IS_SIGNED = false;
+  static const bool IS_NUMERIC = true;
+  static const bool IS_FLOAT = false;
+  static const bool IS_COMPLEX = false;
+  static const bool IS_POD = true;
+  static const bool IS_CONVERTABLE = true;
+
+  typedef DULong64 Ty;
+  typedef GDLArray<Ty,IS_POD>    DataT;
+
+  template <typename ReturnType>
+  struct IfInteger { typedef ReturnType type; };
+  template <typename ReturnType>
+  struct IfFloat {};
+  template <typename ReturnType>
+  struct IfComplex {};
+  template <typename ReturnType>
+  struct IfOther {};
+ 
 
   DType   Type()    const;
   const std::string& TypeStr() const;
@@ -260,9 +392,6 @@
   BaseGDL* GetInstance() const;
   BaseGDL* GetEmptyInstance() const;
 
-  typedef DFloat Ty;
-  typedef GDLArray<Ty>    DataT;
-
   SizeT NBytes() const
   {
 	return (this->N_Elements() * sizeof( Ty));
@@ -272,11 +401,32 @@
   static const std::string str; 
   static const DFloat zero;
 
-  static const bool IS_INTEGER;
-  static const bool IS_SIGNED;
-  static const bool IS_NUMERIC;
-  static const bool IS_COMPLEX;
+//   static const bool IS_INTEGER;
+//   static const bool IS_SIGNED;
+//   static const bool IS_NUMERIC;
+//   static const bool IS_COMPLEX;
+//   static const bool IS_POD;
+//   static const bool IS_CONVERTABLE;
+  static const bool IS_INTEGER = false;
+  static const bool IS_SIGNED = true;
+  static const bool IS_NUMERIC = true;
+  static const bool IS_FLOAT = true;
+  static const bool IS_COMPLEX = false;
+  static const bool IS_POD = true;
+  static const bool IS_CONVERTABLE = true;
+
+  typedef DFloat Ty;
+  typedef GDLArray<Ty,IS_POD>    DataT;
 
+  template <typename ReturnType>
+  struct IfInteger {};
+  template <typename ReturnType>
+  struct IfFloat { typedef ReturnType type; };
+  template <typename ReturnType>
+  struct IfComplex {};
+  template <typename ReturnType>
+  struct IfOther {};
+ 
   DType   Type()    const;
   const std::string& TypeStr() const;
 
@@ -292,9 +442,6 @@
   BaseGDL* GetInstance() const;
   BaseGDL* GetEmptyInstance() const;
 
-  typedef DDouble Ty;
-  typedef GDLArray<Ty>    DataT;
-
   SizeT NBytes() const
   {
 	return (this->N_Elements() * sizeof( Ty));
@@ -304,10 +451,32 @@
   static const std::string str; 
   static const DDouble zero;
 
-  static const bool IS_INTEGER;
-  static const bool IS_SIGNED;
-  static const bool IS_NUMERIC;
-  static const bool IS_COMPLEX;
+//   static const bool IS_INTEGER;
+//   static const bool IS_SIGNED;
+//   static const bool IS_NUMERIC;
+//   static const bool IS_COMPLEX;
+//   static const bool IS_POD;
+//   static const bool IS_CONVERTABLE;
+
+  static const bool IS_INTEGER = false;
+  static const bool IS_SIGNED = true;
+  static const bool IS_NUMERIC = true;
+  static const bool IS_FLOAT = true;
+  static const bool IS_COMPLEX = false;
+  static const bool IS_POD = true;
+  static const bool IS_CONVERTABLE = true;
+
+  typedef DDouble Ty;
+  typedef GDLArray<Ty,IS_POD>    DataT;
+
+  template <typename ReturnType>
+  struct IfInteger {};
+  template <typename ReturnType>
+  struct IfFloat { typedef ReturnType type; };
+  template <typename ReturnType>
+  struct IfComplex {};
+  template <typename ReturnType>
+  struct IfOther {};
 
   DType   Type()    const;
   const std::string& TypeStr() const;
@@ -324,22 +493,40 @@
   BaseGDL* GetInstance() const;
   BaseGDL* GetEmptyInstance() const;
 
-  typedef DString Ty;
-  typedef GDLArray<Ty>    DataT;
-
   SizeT NBytes() const
   {
 	return (this->N_Elements() * sizeof( Ty));
   }
 
+//   static const bool IS_INTEGER;
+//   static const bool IS_SIGNED;
+//   static const bool IS_NUMERIC;
+//   static const bool IS_COMPLEX;
+//   static const bool IS_POD;
+//   static const bool IS_CONVERTABLE;
+  static const bool IS_INTEGER = false;
+  static const bool IS_SIGNED = false;
+  static const bool IS_NUMERIC = false;
+  static const bool IS_FLOAT = false;
+  static const bool IS_COMPLEX = false;
+  static const bool IS_POD = false;
+  static const bool IS_CONVERTABLE = true;
+
+  typedef DString Ty;
+  typedef GDLArray<Ty,IS_POD>    DataT;
+
   static const DType    t;
   static const std::string str; 
   static const Ty       zero;
 
-  static const bool IS_INTEGER;
-  static const bool IS_SIGNED;
-  static const bool IS_NUMERIC;
-  static const bool IS_COMPLEX;
+  template <typename ReturnType>
+  struct IfInteger {};
+  template <typename ReturnType>
+  struct IfFloat {};
+  template <typename ReturnType>
+  struct IfComplex {};
+  template <typename ReturnType>
+  struct IfOther { typedef ReturnType type; };
 
   DType   Type()    const;
   const std::string& TypeStr() const;
@@ -378,23 +565,33 @@
   BaseGDL* GetInstance() const;
   BaseGDL* GetEmptyInstance() const;
 
-  typedef char Ty;
-  typedef GDLArray<Ty> DataT;
-
   SizeT NBytes() const
   {
     return ( this->N_Elements() * desc->NBytes());
   }
 
+//   static const bool IS_INTEGER;
+//   static const bool IS_SIGNED;
+//   static const bool IS_NUMERIC;
+//   static const bool IS_COMPLEX;
+//   static const bool IS_POD;
+//   static const bool IS_CONVERTABLE;
+
+  static const bool IS_INTEGER = false;
+  static const bool IS_SIGNED = false;
+  static const bool IS_NUMERIC = false;
+  static const bool IS_FLOAT = false;
+  static const bool IS_COMPLEX = false;
+  static const bool IS_POD = false;
+  static const bool IS_CONVERTABLE = false;
+
+  typedef char Ty;
+  typedef GDLArray<Ty,true> DataT; // we are using char here
+
   static const DType  t;
   static const std::string str; 
   static const Ty     zero;
 
-  static const bool IS_INTEGER;
-  static const bool IS_SIGNED;
-  static const bool IS_NUMERIC;
-  static const bool IS_COMPLEX;
-
   DType   Type()    const;
   const std::string& TypeStr() const;
 
@@ -411,23 +608,41 @@
   BaseGDL* GetInstance() const;
   BaseGDL* GetEmptyInstance() const;
 
-  typedef DPtr Ty;
-  typedef GDLArray<Ty>    DataT;
-
   SizeT NBytes() const
   {
 	return (this->N_Elements() * sizeof( Ty));
   }
 
+//   static const bool IS_INTEGER;
+//   static const bool IS_SIGNED;
+//   static const bool IS_NUMERIC;
+//   static const bool IS_COMPLEX;
+//   static const bool IS_POD;
+//   static const bool IS_CONVERTABLE;
+  static const bool IS_INTEGER = false;
+  static const bool IS_SIGNED = false;
+  static const bool IS_NUMERIC = false;
+  static const bool IS_FLOAT = false;
+  static const bool IS_COMPLEX = false;
+  static const bool IS_POD = false; // due to ref counting
+  static const bool IS_CONVERTABLE = false;
+
+  typedef DPtr Ty;
+  typedef GDLArray<Ty,true>    DataT; // on this level, DPtr is POD
+
+  template <typename ReturnType>
+  struct IfInteger {};
+  template <typename ReturnType>
+  struct IfFloat {};
+  template <typename ReturnType>
+  struct IfComplex {};
+  template <typename ReturnType>
+  struct IfOther { typedef ReturnType type; };
+
   static const DType    t;
   static const std::string str; 
   static const Ty       zero;
 
-  static const bool IS_INTEGER;
-  static const bool IS_SIGNED;
-  static const bool IS_NUMERIC;
-  static const bool IS_COMPLEX;
-
   DType   Type()    const;
   const std::string& TypeStr() const;
 
@@ -444,23 +659,41 @@
   BaseGDL* GetInstance() const;
   BaseGDL* GetEmptyInstance() const;
 
-  typedef DObj Ty;
-  typedef GDLArray<Ty>    DataT;
-
   SizeT NBytes() const
   {
 	return (this->N_Elements() * sizeof( Ty));
   }
 
+//   static const bool IS_INTEGER;
+//   static const bool IS_SIGNED;
+//   static const bool IS_NUMERIC;
+//   static const bool IS_COMPLEX;
+//   static const bool IS_POD;
+//   static const bool IS_CONVERTABLE;
+  static const bool IS_INTEGER = false;
+  static const bool IS_SIGNED = false;
+  static const bool IS_NUMERIC = false;
+  static const bool IS_FLOAT = false;
+  static const bool IS_COMPLEX = false;
+  static const bool IS_POD = false; // due to ref counting
+  static const bool IS_CONVERTABLE = false;
+
+  typedef DObj Ty;
+  typedef GDLArray<Ty, true>    DataT; // on this level, DObj is POD
+
+  template <typename ReturnType>
+  struct IfInteger {};
+  template <typename ReturnType>
+  struct IfFloat {};
+  template <typename ReturnType>
+  struct IfComplex {};
+  template <typename ReturnType>
+  struct IfOther { typedef ReturnType type; };
+
   static const DType    t;
   static const std::string str; 
   static const Ty       zero;
 
-  static const bool IS_INTEGER;
-  static const bool IS_SIGNED;
-  static const bool IS_NUMERIC;
-  static const bool IS_COMPLEX;
-
   DType   Type()    const;
   const std::string& TypeStr() const;
 
@@ -476,23 +709,42 @@
   BaseGDL* GetInstance() const;
   BaseGDL* GetEmptyInstance() const;
 
-  typedef DComplex Ty;
-  typedef GDLArray<Ty>    DataT;
-
   SizeT NBytes() const
   {
 	return (this->N_Elements() * sizeof( Ty));
   }
 
+//   static const bool IS_INTEGER;
+//   static const bool IS_SIGNED;
+//   static const bool IS_NUMERIC;
+//   static const bool IS_COMPLEX;
+//   static const bool IS_POD;
+//   static const bool IS_CONVERTABLE;
+
+  static const bool IS_INTEGER = false;
+  static const bool IS_SIGNED = true;
+  static const bool IS_NUMERIC = true;
+  static const bool IS_FLOAT = false;
+  static const bool IS_COMPLEX = true;
+  static const bool IS_POD = false;
+  static const bool IS_CONVERTABLE = true;
+
+  typedef DComplex Ty;
+  typedef GDLArray<Ty, TreatPODComplexAsPOD>    DataT; // ATTENTION: srictly complex is non-pod
+
+  template <typename ReturnType>
+  struct IfInteger {};
+  template <typename ReturnType>
+  struct IfFloat {};
+  template <typename ReturnType>
+  struct IfComplex { typedef ReturnType type; };
+  template <typename ReturnType>
+  struct IfOther {};
+
   static const DType  t;
   static const std::string str; 
   static const DComplex zero;
 
-  static const bool IS_INTEGER;
-  static const bool IS_SIGNED;
-  static const bool IS_NUMERIC;
-  static const bool IS_COMPLEX;
-
   DType   Type()    const;
   const std::string& TypeStr() const;
 
@@ -508,23 +760,42 @@
   BaseGDL* GetInstance() const;
   BaseGDL* GetEmptyInstance() const;
 
-  typedef DComplexDbl Ty;
-  typedef GDLArray<Ty>    DataT;
-
   SizeT NBytes() const
   {
 	return (this->N_Elements() * sizeof( Ty));
   }
 
+//   static const bool IS_INTEGER;
+//   static const bool IS_SIGNED;
+//   static const bool IS_NUMERIC;
+//   static const bool IS_COMPLEX;
+//   static const bool IS_POD;
+//   static const bool IS_CONVERTABLE;
+
+  static const bool IS_SIGNED = true;
+  static const bool IS_NUMERIC = true;
+  static const bool IS_INTEGER = false;
+  static const bool IS_FLOAT = false;
+  static const bool IS_COMPLEX = true;
+  static const bool IS_POD = false;
+  static const bool IS_CONVERTABLE = true;
+
+  typedef DComplexDbl Ty;
+  typedef GDLArray<Ty, TreatPODComplexAsPOD>    DataT; // ATTENTION: srictly complex is non-pod
+
+  template <typename ReturnType>
+  struct IfInteger {};
+  template <typename ReturnType>
+  struct IfFloat {};
+  template <typename ReturnType>
+  struct IfComplex { typedef ReturnType type; };
+  template <typename ReturnType>
+  struct IfOther {};
+
   static const DType  t;
   static const std::string str; 
   static const DComplexDbl zero;
 
-  static const bool IS_INTEGER;
-  static const bool IS_SIGNED;
-  static const bool IS_NUMERIC;
-  static const bool IS_COMPLEX;
-
   DType   Type()    const;
   const std::string& TypeStr() const;
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/src/widget.cpp gdl/src/widget.cpp
--- gdl-0.9.3/src/widget.cpp	2012-12-27 09:22:44.000000000 -0700
+++ gdl/src/widget.cpp	2013-03-25 10:36:38.697968280 -0600
@@ -45,7 +45,7 @@
     treeParser.interactive(theAST);
     trAST = treeParser.getAST();
     ProgNodeP progAST = ProgNode::NewProgNode( trAST);
-    auto_ptr< ProgNode> progAST_guard( progAST);
+    Guard< ProgNode> progAST_guard( progAST);
 
     // necessary for correct FOR loop handling
     assert( dynamic_cast<EnvUDT*>(caller) != NULL);
@@ -822,7 +822,7 @@
       trAST = treeParser.getAST();
 
       ProgNodeP progAST = ProgNode::NewProgNode( trAST);
-      auto_ptr< ProgNode> progAST_guard( progAST);
+      Guard< ProgNode> progAST_guard( progAST);
 
       // necessary for correct FOR loop handling
       assert( dynamic_cast<EnvUDT*>(caller) != NULL);
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/templates/cpp gdl/templates/cpp
--- gdl-0.9.3/templates/cpp	1969-12-31 17:00:00.000000000 -0700
+++ gdl/templates/cpp	2004-12-09 08:10:21.000000000 -0700
@@ -0,0 +1,16 @@
+/***************************************************************************
+                          $FILENAME$  -  description
+                             -------------------
+    begin                : $DATE$
+    copyright            : (C) $YEAR$ by $AUTHOR$
+    email                : $EMAIL$
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/templates/h gdl/templates/h
--- gdl-0.9.3/templates/h	1969-12-31 17:00:00.000000000 -0700
+++ gdl/templates/h	2004-12-09 08:10:21.000000000 -0700
@@ -0,0 +1,16 @@
+/***************************************************************************
+                          $FILENAME$  -  description
+                             -------------------
+    begin                : $DATE$
+    copyright            : (C) $YEAR$ by $AUTHOR$
+    email                : $EMAIL$
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/testsuite/benchmark/bench_matrix_multiply.pro gdl/testsuite/benchmark/bench_matrix_multiply.pro
--- gdl-0.9.3/testsuite/benchmark/bench_matrix_multiply.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/benchmark/bench_matrix_multiply.pro	2013-05-16 12:36:33.872855559 -0600
@@ -0,0 +1,125 @@
+;
+; AC 25 February 2013
+;
+; First computation is using "#" operator.
+; the 4 computations after are using MATRIX_MULTIPLY() function,
+; eventualy calling Eigen3 code (a message will be issued if not)
+;
+pro BENCH_MATRIX_MULTIPLY, n1, n2, n3, $
+                           small=small, medium=medium, double=double, $
+                           complex=complex, dblecomplex=dblecomplex, $
+                           output_type=output_type, help=help, test=test
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro BENCH_MATRIX_MULTPLY, n1, n2, n3, '
+    print, '                   small=small, medium=medium, double=double, $'
+    print, '                   complex=complex, dblecomplex=dblecomplex, $'
+    print, '                   output_type=output_type, help=help, test=test'
+    return
+endif
+;
+; Note by AC 28 March 2013
+; obsoleting code, we don't remove if we have to go back to test
+; related to Eigen3 internal use ...
+;
+;DEFSYSV, '!gdl', exist=it_is_GDL
+;
+; if (it_is_GDL) then begin
+;     having_eigen3=EXECUTE("type=MATMUL(/available, quiet=quiet)")
+;     if (having_eigen3 EQ 0) then begin
+;         print, 'You are trying testing new capabilities (Eigen3 usage)'
+;         print, 'on a too OLD GDL version ! Please make tests on CVS version !'
+;         return
+;     endif
+; endif
+;
+if N_PARAMS() EQ 0 then begin
+    colA=1000
+    rowA=3000
+    rowB=751
+endif
+;
+if N_PARAMS() EQ 1 then begin
+    colA=n1
+    rowA=n1
+    rowB=n1
+endif
+;
+if N_PARAMS() EQ 2 then begin
+    colA=n1
+    rowA=n2
+    rowB=n2
+endif
+if N_PARAMS() EQ 3 then begin
+   colA=n1
+   rowA=n2
+   rowB=n3
+endif
+;
+if KEYWORD_SET(medium) then begin
+   colA=colA/2
+   rowA=rowA/2
+   rowB=rowB/2
+endif
+;
+if KEYWORD_SET(small) then begin
+   colA=colA/4
+   rowA=rowA/4
+   rowB=rowB/4
+endif
+;
+colB=rowA
+;
+known_type=0
+if KEYWORD_SET(dblecomplex) then begin
+   a=DCOMPLEXARR(colA ,rowA)
+   b=DCOMPLEXARR(colB ,rowB)
+   known_type=1
+endif
+if KEYWORD_SET(complex) then begin
+   a=COMPLEXARR(colA ,rowA)
+   b=COMPLEXARR(colB ,rowB)
+   known_type=1
+endif
+if KEYWORD_SET(double) then begin
+   a=RANDOMU(seed, colA, rowA, /DOUBLE)
+   b=RANDOMU(seed, colB, rowB, /DOUBLE)
+   known_type=1
+endif
+if (known_type EQ 0) then begin
+   a=RANDOMU(seed, colA, rowA)
+   b=RANDOMU(seed, colB, rowB)
+endif
+;
+b_t=TRANSPOSE(b)
+a_t=TRANSPOSE(a)
+;
+HELP, a, b
+;
+txt='Matrix size are : [' +STRING(colA)+','+STRING(rowA)
+txt=txt+'] # ['+STRING(colB)+','+STRING(rowB)+']'
+print, STRCOMPRESS(txt)
+;
+txt_ref='Classic operator #, '
+txt=    'Matrix_Multiply() , '
+;
+t0=SYSTIME(1) & z=a # b & print, txt_ref+'a#b  :', SYSTIME(1)-t0
+t0=SYSTIME(1) & z=MATRIX_MULTIPLY(a,b) & print, txt+'a#b  :', SYSTIME(1)-t0
+t0=SYSTIME(1) & z=MATRIX_MULTIPLY(a_t,b,/at) & print, txt+'aT#b :', SYSTIME(1)-t0 
+t0=SYSTIME(1) & z=MATRIX_MULTIPLY(a,b_t,/bt) & print, txt+'a#bT :', SYSTIME(1)-t0 
+t0=SYSTIME(1) & z=MATRIX_MULTIPLY(a_t,b_t,/at,/bt) & print, txt+'aT#bT:', SYSTIME(1)-t0
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; ------------------------------
+;
+pro BENCH_MATRIX_MULTIPLY_ALL, small=small
+;
+BENCH_MATRIX_MULTIPLY
+BENCH_MATRIX_MULTIPLY, /double
+BENCH_MATRIX_MULTIPLY, /complex
+BENCH_MATRIX_MULTIPLY, /dblecomplex
+;
+end
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/testsuite/CMakeLists.txt gdl/testsuite/CMakeLists.txt
--- gdl-0.9.3/testsuite/CMakeLists.txt	2012-12-27 09:22:44.000000000 -0700
+++ gdl/testsuite/CMakeLists.txt	2013-05-16 12:36:33.778855896 -0600
@@ -4,6 +4,12 @@
 set(LAUNCH
 "#include<unistd.h>
 #include<stdlib.h>
+#include<stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <sys/wait.h>
+#include<sched.h>
 int main(int c,char**v) {
 char*p;
 if(c!=2) return 1;
@@ -13,7 +19,25 @@
 *(p-4)=0;
 setenv(\"LC_COLLATE\",\"C\",1);
 setenv(\"GDL_PATH\",\"+${BASE_SOURCE}/testsuite/:+${BASE_SOURCE}/src/pro/\",1);
-execl(\"${BASE_BINARY}/src/gdl\",\"-quiet\",\"-e\",v[1],(char*)0);
+unsetenv(\"GDL_STARTUP\");
+unsetenv(\"IDL_STARTUP\");
+int devnull = open(\"/dev/null\",O_RDONLY);
+dup2(devnull, 0);
+int child_pid = fork();
+if(child_pid == 0) {
+  execl(\"${BASE_BINARY}/src/gdl\",\"-quiet\",\"-e\",v[1],(char*)0);
+  exit(1);
+} else {
+  sched_yield();
+  int child_status;
+  waitpid(child_pid, &child_status, 0);
+  if (WEXITSTATUS(child_status) == 77) {
+    printf(\"TEST SKIPPED\");
+    exit(0);
+  } else {
+    exit(WEXITSTATUS(child_status));
+  }
+}
 }
 ")
 file(WRITE ${CMAKE_SOURCE_DIR}/testsuite/launchtest.c "${LAUNCH}")
Only in gdl-0.9.3/testsuite: launchtest.c
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/testsuite/Makefile.am gdl/testsuite/Makefile.am
--- gdl-0.9.3/testsuite/Makefile.am	2012-12-27 09:22:44.000000000 -0700
+++ gdl/testsuite/Makefile.am	2013-05-16 12:36:33.779855893 -0600
@@ -90,6 +90,7 @@
   test_interpol.pro \
   test_interpolate_missing.pro \
   test_ludc_lusol.pro \
+  test_matrix_multiply.pro \
   test_memory.pro \
   test_moment.pro \
   test_mpfit.pro \
@@ -123,6 +124,7 @@
   test_stregex.pro \
   test_strmatch.pro \
   test_strsplit.pro \
+  test_structures.pro \
   test_suite.pro \
   test_systime.pro \
   test_trisol.pro \
Only in gdl-0.9.3/testsuite: Makefile.in
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/testsuite/test_bytscl.pro gdl/testsuite/test_bytscl.pro
--- gdl-0.9.3/testsuite/test_bytscl.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_bytscl.pro	2013-03-21 11:30:42.000000000 -0600
@@ -0,0 +1,38 @@
+;
+; Alain C., 21 March 2013
+;
+; draft: very preliminary version for testing BYTSCL(),
+; the last case is buggy.
+;
+pro TEST_BYTSCL
+;
+ramp=FINDGEN(10)
+;
+expected=BYTARR(10)
+expected[*]=[0,28,56,85,113,142,170,199,227,255]
+;
+resu=BYTSCL(ramp)
+;
+print, ARRAY_EQUAL(expected, resu)
+;
+expected_nan=BYTARR(10)
+expected_nan[6]=255
+;
+expected_nan_flag=expected
+expected_nan_flag[5:6]=0
+;
+;
+ramp_nan=ramp
+ramp_nan[5]=!values.f_nan
+ramp_nan[6]=!values.f_infinity
+;
+resu_nan=BYTSCL(ramp_nan)
+resu_nan_flag=BYTSCL(ramp_nan,/nan)
+;
+print, ARRAY_EQUAL(expected_nan, resu_nan)
+print, ARRAY_EQUAL(expected_nan_flag, resu_nan_flag)
+;
+print, 'not finished'
+
+stop
+end
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/testsuite/test_ce.pro gdl/testsuite/test_ce.pro
--- gdl-0.9.3/testsuite/test_ce.pro	2012-12-27 09:22:44.000000000 -0700
+++ gdl/testsuite/test_ce.pro	2013-03-25 10:38:36.795417927 -0600
@@ -6,7 +6,7 @@
     ; should be used together with test_ce.so compiled from test_ce.c
     ;-----------------------------------------------------------------------
 
-    image = 'libtest_ce.' + (!VERSION.OS_NAME eq 'Darwin' ? "dylib" : "so")
+    image = './libtest_ce.' + (!VERSION.OS_NAME eq 'Darwin' ? "dylib" : "so")
     if ~file_test(image) then image = '.libs/' + image
     if ~file_test(image) then begin
       message, 'library found not compiled!', /conti
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/testsuite/test_histo.pro gdl/testsuite/test_histo.pro
--- gdl-0.9.3/testsuite/test_histo.pro	2012-12-27 09:22:44.000000000 -0700
+++ gdl/testsuite/test_histo.pro	2013-02-25 17:04:31.928151218 -0700
@@ -2,6 +2,7 @@
 ; AC 01-Jun-2007
 ; SA 30-Aug-2009 (TEST_HISTO_BASIC)
 ; AC 06-Dec-2011 (adding TEST_HISTO_NAN)
+; AC 20-Feb-2013 (adding TEST_HISTO_UNITY_BIN)
 ;
 pro TEST_HISTO_RANDOMU, nbp=nbp, nan=nan
 ;
@@ -18,7 +19,7 @@
 ;
 ; based on a IDL example
 ;
-pro TEST_GAUSS_HISTO, test=test
+pro TEST_HISTO_GAUSS, test=test
 ;
 ; Two-hundred values ranging from -5 to 4.95:  
 X = FINDGEN(200) / 20. - 5.  
@@ -117,6 +118,47 @@
 endif
 ;
 end
-
-
+;
+; see bug report 3602623
+; http://sourceforge.net/tracker/?func=detail&aid=3602623&group_id=97659&atid=618683
+;
+; TBC: the effect seems to be different on 32b and 64b machines ...
+;
+pro TEST_HISTO_UNITY_BIN, nbp, display=display, test=test, help=help
+;
+if KEYWORD_SET(help) then begin
+   print, 'pro TEST_HISTO_UNITY_BIN, nbp, display=display, test=test, help=help'
+   return
+endif 
+;
+if (N_PARAMS()) EQ 0 then nbp=13000
+;
+; if 13000 points, we create a shawtooth with 10 points in each unity bin ...
+ramp=LINDGEN(nbp) mod 1300
+;
+h1 = HISTOGRAM(ramp, bin=1)
+h2 = HISTOGRAM(ramp)
+;
+diff=TOTAL(ABS(h2 - h1))
+;
+if (diff GT 0.0) then begin
+   MESSAGE, 'error !', /continue
+endif
+;
+if KEYWORD_SET(display) then begin
+   plot, h1, yrange=[-1, 21], /ystyle
+   oplot, h2, psym=2
+endif 
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; ------------------------------------------------------------------
+;
+pro TEST_HISTO
+;
+TEST_HISTO_UNITY_BIN
+;
+end
 
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/testsuite/test_matrix_multiply.pro gdl/testsuite/test_matrix_multiply.pro
--- gdl-0.9.3/testsuite/test_matrix_multiply.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_matrix_multiply.pro	2013-04-11 10:00:30.000000000 -0600
@@ -0,0 +1,125 @@
+;
+; Under GNU GPL v2 or later
+; Alain Coulais, 8 April 2013
+;
+; Basic tests on matrix multiplication
+; (and also TRANSPOSE and INVERT ...)
+;
+; As mention in the Eigen3 documentation, array aligment and other
+; tricks might fail, we have to check all cases are equivalent OK
+; (internal size of hardware pipes are varying from CPU to CPU ...)
+;
+; This is not a benchmark on Matrix Multiplication and Inversion,
+; look at  testsuite/benchmark/bench_matrix_multiply.pro
+;
+pro TEST_MATRIX_UNITARY, type=type, nbp=nbp, nb_errors=nb_errors, $
+                         test=test, debug=debug, verbose=verbose
+;
+if ~KEYWORD_SET(nb_errors) then nb_errors=0
+if ~KEYWORD_SET(nbp) then nbp=100
+if ~KEYWORD_SET(type) then type=4
+if KEYWORD_SET(debug) then print, ' nbp: ', nbp, 'type=', type
+;
+if ((type EQ 6) OR (type EQ 9)) then begin
+    value=COMPLEX(2,3.)
+    value=value/ABS(value)
+    value=MAKE_ARRAY(1, value=value, type=type)
+endif else begin
+    value=MAKE_ARRAY(1, value=1, type=type)
+endelse
+;
+if KEYWORD_SET(debug) then begin
+    print, 'expected type : ', type
+    print, 'value : ', value
+    print, 'value type : ', SIZE(value,/type)
+endif
+;
+identity=DIAG_MATRIX(REPLICATE(1., nbp))
+;
+matrice=DIAG_MATRIX(REPLICATE(value, nbp-1), 1)
+matrice[0,nbp-1]=value
+;
+inv_matrice=INVERT(matrice)
+;
+; We use a "rotation matrix"
+;
+trans_matrice=TRANSPOSE(matrice)
+effective_type=SIZE(matrice,/type)
+if ((effective_type EQ 6) OR (effective_type EQ 9)) then trans_matrice=CONJ(trans_matrice)
+;
+test1=matrice#inv_matrice-identity
+test2=inv_matrice#matrice-identity
+test3=matrice#trans_matrice-identity
+test4=trans_matrice#matrice-identity
+;
+errors=0
+tolerance=1e-5
+if ABS(MIN(test1)) GT tolerance then errors++
+if ABS(MAX(test1)) GT tolerance then errors++
+if ABS(MIN(test2)) GT tolerance then errors++
+if ABS(MAX(test2)) GT tolerance then errors++
+if ABS(MIN(test3)) GT tolerance then errors++
+if ABS(MAX(test3)) GT tolerance then errors++
+if ABS(MIN(test4)) GT tolerance then errors++
+if ABS(MAX(test4)) GT tolerance then errors++
+;
+if (errors GT 0) then begin
+    print, 'size of matrix : ', nbp
+    print, 'nb errors : ', errors
+    print, 'input type : ', type
+    print, 'effective type : ', effective_type
+    nb_errors=nb_errors+errors
+endif
+;
+if KEYWORD_SET(debug) then begin
+    print, MIN(test1), MAX(test1)
+    print, MIN(test2), MAX(test2)
+    print, MIN(test3), MAX(test3)
+    print, MIN(test4), MAX(test4)
+endif
+;
+if KEYWORD_SET(test) then STOP
+;
+end
+;
+; ---------------------------------------------
+;
+pro  TEST_MATRIX_MULTIPLY, no_exit=no_exit, extended=extended,$
+                           help=help, verbose=verbose, test=test
+;
+if KEYWORD_SET(test) then begin
+    print, 'pro  TEST_MATRIX_MULTIPLY, no_exit=no_exit, extended=extended,$'
+    print, '                           help=help, verbose=verbose, test=test'
+    return
+endif
+;
+; today, the two last cases with types 14 and 15 are not working in GDL
+;
+if ~KEYWORD_SET(extended) then begin
+    msg='Types 14 and 15 desactivated due to pbs in INVERT() in GDL for these 2 type'
+    MESSAGE, /continue, msg
+    liste_type=[1,2,3,4,5,6,9,12,13]
+endif else begin
+    liste_type=[1,2,3,4,5,6,9,12,13,14,15]
+endelse
+;
+nb_errors=0
+;
+liste_taille=[2,3,4,10,11,13,25,50,51,100,101,220,255,256,260]
+;
+for itailles=0, N_ELEMENTS(liste_taille)-1 do begin
+    for itypes=0, N_ELEMENTS(liste_type)-1 do begin
+        TEST_MATRIX_UNITARY, type=liste_type[itypes], $
+          nbp=liste_taille[itailles], nb_errors=nb_errors, verbose=verbose
+    endfor
+endfor
+;
+if KEYWORD_SET(test) then STOP
+;
+if (nb_errors GT 0) then begin
+    msg='At least one error encountered, please rerun code with /verbose'
+    MESSAGE, /continue, msg
+    if ~KEYWORD_SET(no_exit) then EXIT, status=1
+endif
+;
+end
Only in gdl-0.9.3/testsuite: test_stregex.pro.~1.1.~
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/testsuite/test_structures.pro gdl/testsuite/test_structures.pro
--- gdl-0.9.3/testsuite/test_structures.pro	1969-12-31 17:00:00.000000000 -0700
+++ gdl/testsuite/test_structures.pro	2013-01-29 04:48:35.000000000 -0700
@@ -0,0 +1,61 @@
+;
+; AC 28/01/2013: I found no equivalent tests in the testsuite !
+;
+; bug reported by Gilles on Jan. 23, 2013
+; http://sourceforge.net/tracker/?func=detail&aid=3601949&group_id=97659&atid=618683
+;
+pro TEST_STRUCTURES, no_exit=no_exit, verbose=verbose, $
+                     help=help, test=test, debug=debug
+;
+if KEYWORD_SET(help) then begin
+    print, 'pro TEST_STRUCTURES, no_exit=no_exit, verbose=verbose, $'
+    print, '                     help=help, test=test, debug=debug, $'
+    return
+endif
+;
+nb_errors=0
+;
+structarray=REPLICATE({test, value:0.0},10)
+;populate values:
+structarray.value=FINDGEN(10)
+;
+HELP, structarray.value
+;
+;get subset:
+www=WHERE(structarray.value gt 6)
+HELP, www
+;
+if (ARRAY_EQUAL(www, [7,8,9]) NE 1) then begin
+    message,/continue, '(1) unexpected results in <<www>> values !'
+    nb_errors=nb_errors+1
+endif
+;
+res1=EXECUTE('HELP, structarray[www].value')
+if (res1 NE 1) then begin
+    message,/continue, ' unexpected badly interpreted Struct indexing ! (case 1)'
+    nb_errors=nb_errors+1
+endif
+;
+tab=0.
+res2=EXECUTE('tab=structarray[www].value')
+if (res2 NE 1) then begin
+    message,/continue, ' unexpected badly interpreted Struct indexing ! (case 2)'
+    nb_errors=nb_errors+1
+endif
+;
+if (ARRAY_EQUAL(tab, 1.*[7,8,9]) NE 1) then begin
+    message,/continue, '(2) unexpected results in extracted values !'
+    nb_errors=nb_errors+1
+endif
+;
+if (nb_errors GT 0) then begin
+    MESSAGE, STRING(nb_errors)+' Errors found', /continue
+endif else begin
+    MESSAGE, ' No Errors found', /continue
+endelse
+;
+if KEYWORD_SET(test) then STOP
+;
+if (nb_errors GT 0) AND ~KEYWORD_SET(no_exit) then EXIT, status=1
+;
+end
Only in gdl-0.9.3/testsuite: testsuite
diff -ru --unidirectional-new-file --exclude CVS gdl-0.9.3/testsuite/test_suite.pro gdl/testsuite/test_suite.pro
--- gdl-0.9.3/testsuite/test_suite.pro	2012-12-27 09:22:44.000000000 -0700
+++ gdl/testsuite/test_suite.pro	2013-05-16 12:36:33.861855598 -0600
@@ -538,8 +538,21 @@
   a = {a0, var1: 0, var2: 0.0d0}
   b = {a0, '0L', ' 1.0'}
 
-  print,'STRUCT: OK'
+; bug tracker ID: 3612104
+  a=ptrarr(1)
+  a(0)=ptr_new('a')
+  s={a:a}
+  ss={sst:s}
+  if *s.a(0) ne 'a' then begin
+    message, '***STRUCT: ERROR12', /conti
+    exit, status=1
+  endif
+  if *ss.sst.a(0) ne 'a' then begin
+    message, '***STRUCT: ERROR13', /conti
+    exit, status=1
+  endif 
 
+  print,'STRUCT: OK'
 end
 
 pro multi,a,b,c
Only in gdl-0.9.3/testsuite: test_suite.pro.~1.16.~
